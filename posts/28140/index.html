<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="深入理解Cpp对象模型, joytsing blog"><meta name="description" content="读书笔记系列"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="theme-color" content="white"><title>深入理解Cpp对象模型 | JoyTsing</title><link rel="apple-touch-icon" href="/"><link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="/favicon.ico"><link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css"><link rel="stylesheet" type="text/css" href="/libs/aos/aos.css"><link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css"><link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" type="text/css" href="/css/matery.css"><link rel="stylesheet" type="text/css" href="/css/my.css"><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style><script src="/libs/jquery/jquery.min.js"></script><script src="https://cdn-go.cn/aegis/aegis-sdk/latest/aegis.min.js"></script><script>const aegis=new Aegis({id:"6ojk8FlnQlqWeL6vQo",uin:"joyblog",reportApiSpeed:!0,reportAssetSpeed:!0,spa:!0,hostUrl:"https://rumt-sg.com"});console.log("aegis load")</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="JoyTsing" type="application/atom+xml"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><img src="/apple-touch-icon.png" class="logo-img" alt="LOGO"> <span class="logo-span">JoyTsing</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fa fa-home"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-tags"></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-bookmark"></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-archive"></i> <span>归档</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa fa-user-circle-o"></i> <span>关于</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa fa-envelope"></i> <span>留言</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa fa-address-book"></i> <span>友链</span></a></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fa fa-search" title="搜索"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="/medias/avatars/touxiang2.jpg" class="logo-img circle responsive-img"><div class="logo-name">JoyTsing</div><div class="logo-desc">joytsing的个人网站</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="m-nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-fw fa-bookmark"></i> 分类</a></li><li class="m-nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li class="m-nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa fa-fw fa-user-circle-o"></i> 关于</a></li><li class="m-nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa fa-fw fa-envelope"></i> 留言</a></li><li class="m-nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa fa-fw fa-address-book"></i> 友链</a></li><li><div class="divider"></div></li><li><a href="https://github.com/JoyTsing" class="waves-effect waves-light" target="_blank"><i class="fa fa-github-square fa-fw"></i>Follow Me</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#000;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href="https://github.com/JoyTsing" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Follow Me" data-position="left" data-delay="50"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a></nav></header><div class="bg-cover pd-header post-cover" style="background-image:url(/medias/featureimages/16.jpg)"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">深入理解Cpp对象模型</h1></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{width:345px;padding-left:20px}.toc-widget .toc-title{margin:35px 0 15px 0;padding-left:17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content{height:calc(100vh - 250px);overflow:auto}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px;position:absolute;right:23.5vw;display:block}#toc-content .is-active-link{color:#42b983}#floating-toc-btn{position:fixed;right:15px;bottom:76px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/Cpp/"><span class="chip bg-color">Cpp</span> </a><a href="/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"><span class="chip bg-color">原理剖析</span> </a><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="chip bg-color">读书笔记</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="post-category">读书笔记</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp; 2024-03-15</div><div class="post-date info-break-policy"><i class="fa fa-calendar-check-o fa-fw"></i>更新日期:&nbsp;&nbsp; 2024-03-21</div><div class="info-break-policy"><i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp; 10.8k</div><div class="info-break-policy"><i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp; 40 分</div><div id="busuanzi_container_page_pv" class="info-break-policy"><i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp; <span id="busuanzi_value_page_pv"></span></div></div></div><hr class="clearfix"><div class="card-content article-card-content"><div id="articleContent"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>C++对象模型，启动！</p><h2 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h2><ul><li>简单对象模型(A Simple Object Model)</li></ul><p>对象保存成员的指针，成员实际存放在其他区域.</p><p>这种模型保证了成员中每个元素需要的内存空间都是一样的, 不论元素是何种类型, 访问时只需要确定成员的index和对象首地址即可. 坏处是访问成员时需要多进行一次内存访问, 并且占用了更多的内存空间.</p><ul><li>表格驱动对象模型(A Table-driven Object Model)</li></ul><p>将对象中的数据成员和函数成员分别组织, 放在不同的内存区域, 对象中保存了指向这两个内存区域的指针.</p><p>这种模型保证了不同类型的对象具有相同的内存布局,</p><h2 id="C-对象模型"><a href="#C-对象模型" class="headerlink" title="C++对象模型"></a>C++对象模型</h2><p>每个有虚函数的类产生一个virtual table, 保存所有虚函数的指针, 对象在所在内存开始位置保存指向 vtable 的指针 vptr. 在调用类的虚函数时, 会沿着虚函数表搜索, 第一个满足条件的就是要调用的函数. 在调用类的构造函数, 复制构造函数等时这些函数会自动处理类的vptr. 比如下面的代码中, 假设类Base 是Derived的父类, 二者都定义了函数f(), 那么自然就有vptr. 在第二行中, 调用了Base的复制构造函数, 对象d会被截断, 并且b的vptr会在复制构造函数中设置, 因此第三行中b调用的是Base中的f(). 另外一个值得注意的是, 运行时多态只能通过指针和引用来实现.</p><pre class="line-numbers language-cpp"><code class="language-cpp">Derived d<span class="token punctuation">;</span>
Base b <span class="token operator">=</span> b<span class="token punctuation">;</span>
b<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>单继承且无继承时, 每个对象只有一个vptr, 而当存在虚继承时, 虚继承的直接子类还会产生一个附加的 vptr, 指向自身的virtual table. 当存在多继承时, 会为每个父类产生一个vptr. 下面针对这些情况 详细举例说明.</p><ul><li>单继承, 无虚继承时的对象模型</li></ul><p>这是最简单的情况, 在对象的开始处保存一个vptr指针, 指向一个虚函数指针数组, 非静态数据成员按继承, 声明的顺序排列.</p><ul><li>单继承, 有虚继承时的对象模型</li></ul><p>采用虚继承的类会在产生多个vptr, 对象开始处是父类的vptr, 父类成员之后, 子类成员之前保存子类的vptr. 如下:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">BB</span>
<span class="token punctuation">{</span>
    int64_t m_bb<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B1</span> <span class="token operator">:</span> <span class="token keyword">public</span> <span class="token keyword">virtual</span> BB
<span class="token punctuation">{</span>
    int64_t m_b1<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">DD</span> <span class="token operator">:</span> <span class="token keyword">public</span> B1
<span class="token punctuation">{</span>
    int64_t m_dd<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">D1</span> <span class="token operator">:</span> <span class="token keyword">public</span> DD
<span class="token punctuation">{</span>
    int64_t m_d1<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// D1对象的结构, gcc 8.2.0, GNU gdb 8.1.1</span>
<span class="token comment" spellcheck="true">// 注意, 这是在gdb中查看的结果, 并不代表真正的对象内存布局. 比如多继承, 有虚继承的情况.</span>
<span class="token punctuation">{</span>
    <span class="token operator">&lt;</span>DD<span class="token operator">></span> <span class="token operator">=</span>
    <span class="token punctuation">{</span>
        <span class="token operator">&lt;</span>B1<span class="token operator">></span> <span class="token operator">=</span>
        <span class="token punctuation">{</span>
            <span class="token operator">&lt;</span>BB<span class="token operator">></span> <span class="token operator">=</span>
            <span class="token punctuation">{</span>
                _vptr<span class="token punctuation">.</span>BB <span class="token operator">=</span> <span class="token operator">&lt;</span>vtable <span class="token keyword">for</span> D1<span class="token operator">+</span><span class="token number">112</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 父类的vptr</span>
                m_bb
            <span class="token punctuation">}</span><span class="token punctuation">,</span>
            _vptr<span class="token punctuation">.</span>B1 <span class="token operator">=</span> <span class="token operator">&lt;</span>vtable <span class="token keyword">for</span> D1<span class="token operator">+</span><span class="token number">24</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 虚继承子类B1的vptr</span>
            m_b1
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        m_dd
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    m_d1 <span class="token comment" spellcheck="true">// 没有采用虚继承, 因此与基类BB共用vptr.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>继承, 无虚继承时的对象模型</li></ul><p>保留多个父类的vptr.</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">BB</span>
<span class="token punctuation">{</span>
    int64_t m_bb<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B1</span> <span class="token operator">:</span> <span class="token keyword">public</span> BB
<span class="token punctuation">{</span>
    int64_t m_b1<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B2</span> <span class="token operator">:</span> <span class="token keyword">public</span> BB
<span class="token punctuation">{</span>
    int64_t m_b2<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">DD</span> <span class="token operator">:</span> <span class="token keyword">public</span> B1<span class="token punctuation">,</span> B2
<span class="token punctuation">{</span>
    int64_t m_dd<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// DD对象的结构, gcc 8.2.0, GNU gdb 8.1.1</span>
<span class="token punctuation">{</span>
    <span class="token operator">&lt;</span>B1<span class="token operator">></span> <span class="token operator">=</span>
    <span class="token punctuation">{</span>
        <span class="token operator">&lt;</span>BB<span class="token operator">></span> <span class="token operator">=</span>
        <span class="token punctuation">{</span>
            _vptr<span class="token punctuation">.</span>BB <span class="token operator">=</span> <span class="token operator">&lt;</span>vtable <span class="token keyword">for</span> DD<span class="token operator">+</span><span class="token number">16</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// B1的vptr</span>
            m_bb
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        m_b1
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token operator">&lt;</span>B2<span class="token operator">></span> <span class="token operator">=</span>
    <span class="token punctuation">{</span>
        <span class="token operator">&lt;</span>BB<span class="token operator">></span> <span class="token operator">=</span>
        <span class="token punctuation">{</span>
            _vptr<span class="token punctuation">.</span>BB <span class="token operator">=</span> <span class="token operator">&lt;</span>vtable <span class="token keyword">for</span> DD<span class="token operator">+</span><span class="token number">80</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// B2的vptr</span>
            m_bb
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        m_b2
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    m_dd <span class="token comment" spellcheck="true">// 与基类B1共用vptr.</span>
<span class="token punctuation">}</span>

BB <span class="token operator">*</span>bp <span class="token operator">=</span> <span class="token keyword">new</span> DD<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 错误, 有歧义</span>
BB <span class="token operator">*</span>bp1 <span class="token operator">=</span> <span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span>B1<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> DD<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正确, bp1指向DD中的B1部分.</span>
BB <span class="token operator">*</span>bp2 <span class="token operator">=</span> <span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span>B2<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> DD<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正确, bp2指向DD中的B2部分.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很自然地, 当用BB类型的指针/引用保存DD对象时, 就会出现歧义, 编译器无法确定采用B1中的BB还是B2中BB. 可以使用 dynamic_cast 进行干预, 以达到预期目的.</p><ul><li>多继承, 有虚继承时的对象模型<br>有了上面的结论, 就不难推测这种情况下的对象模型了.</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">BB</span>
<span class="token punctuation">{</span>
    int64_t m_bb<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B1</span> <span class="token operator">:</span> <span class="token keyword">virtual</span> <span class="token keyword">public</span> BB
<span class="token punctuation">{</span>
    int64_t m_b1<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B2</span> <span class="token operator">:</span> <span class="token keyword">virtual</span> <span class="token keyword">public</span> BB
<span class="token punctuation">{</span>
    int64_t m_b2<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">DD</span> <span class="token operator">:</span> <span class="token keyword">public</span> B1<span class="token punctuation">,</span> B2
<span class="token punctuation">{</span>
    int64_t m_dd<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// DD对象的结构, gcc 8.2.0, GNU gdb 8.1.1</span>
<span class="token punctuation">{</span>
    <span class="token operator">&lt;</span>B1<span class="token operator">></span> <span class="token operator">=</span>
    <span class="token punctuation">{</span>
        <span class="token operator">&lt;</span>BB<span class="token operator">></span> <span class="token operator">=</span>
        <span class="token punctuation">{</span>
            _vptr<span class="token punctuation">.</span>BB <span class="token operator">=</span> <span class="token operator">&lt;</span>vtable <span class="token keyword">for</span> DD<span class="token operator">+</span><span class="token number">160</span><span class="token operator">></span><span class="token punctuation">,</span>
            m_bb <span class="token operator">=</span> <span class="token number">1</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        _vptr<span class="token punctuation">.</span>B1 <span class="token operator">=</span> <span class="token operator">&lt;</span>vtable <span class="token keyword">for</span> DD<span class="token operator">+</span><span class="token number">24</span><span class="token operator">></span><span class="token punctuation">,</span>
        m_b1
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token operator">&lt;</span>B2<span class="token operator">></span> <span class="token operator">=</span>
    <span class="token punctuation">{</span>
        _vptr<span class="token punctuation">.</span>B2 <span class="token operator">=</span> <span class="token operator">&lt;</span>vtable <span class="token keyword">for</span> DD<span class="token operator">+</span><span class="token number">88</span><span class="token operator">></span><span class="token punctuation">,</span>
        m_b2
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    m_dd
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 实际内存布局可能是:</span>
<span class="token punctuation">{</span>
    <span class="token operator">&lt;</span>B1<span class="token operator">></span> <span class="token operator">=</span>
    <span class="token punctuation">{</span>
        vptr<span class="token punctuation">.</span>B1<span class="token punctuation">,</span>
        m_b1
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token operator">&lt;</span>B2<span class="token operator">></span> <span class="token operator">=</span>
    <span class="token punctuation">{</span>
        vptr<span class="token punctuation">.</span>B2<span class="token punctuation">,</span>
        m_b2
    <span class="token punctuation">}</span>
    m_dd<span class="token punctuation">,</span>
    <span class="token operator">&lt;</span>BB<span class="token operator">></span> <span class="token operator">=</span>
    <span class="token punctuation">{</span>
        vptr<span class="token punctuation">.</span>BB<span class="token punctuation">,</span>
        m_bb
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="关键字class和struct的区别"><a href="#关键字class和struct的区别" class="headerlink" title="关键字class和struct的区别"></a>关键字class和struct的区别</h2><p>二者在绝大多数情况下是完全相同的, 可以互换, 只有几点不同.</p><p>class可以用于模板声明, struct不可以. C++引入class关键字, 保留struct的一个原因是为了体现OO, 并且兼容C, 而C中不需要模板, 也就不需要保证struct可以用于模板.</p><p>另外, 当用于声明类类型时二者略有差别:</p><ul><li>用class声明的类的成员的默认访问级别是private, 用struct声明的类的成员的默认访问级别是public.</li><li>有继承时, 用class声明的类的默认继承方式是private, 用struct声明的类的默认继承方式是public. 这里的class, struct是指用于子类, 父类的声明方式不影响默认方式. 如下代码:</li></ul><pre class="line-numbers language-text"><code class="language-text">class BB {};
class D1 : BB {}; // private继承
struct D2 : BB {}; // public继承 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="运行时多态必须通过public继承实现"><a href="#运行时多态必须通过public继承实现" class="headerlink" title="运行时多态必须通过public继承实现"></a>运行时多态必须通过public继承实现</h2><p>这个设计是符合逻辑的. 可以设想, 如果使用其他继承方式, 那么从逻辑上说, 在类外不应该能访问父类成 员. 但是要实现运行时多态, 正常做法是将子类指针/引用赋值给一个父类类型的指针/引用(设为bp), 一旦复制成功, 我们就可以通过bp访问父类的public成员, 这显然与前面的逻辑要求矛盾. 所以, 在C++中, 前面说得”赋值”是违法的. 而没有这个”赋值”操作, 也就无法实现运行时多态, 因此必须通过public继承实现运行时多态.</p><h2 id="Default-Constructor的构造操作"><a href="#Default-Constructor的构造操作" class="headerlink" title="Default Constructor的构造操作"></a>Default Constructor的构造操作</h2><p><strong>默认构造函数(default constructor)的定义</strong>:</p><blockquote><p>一个可以以空参数列表调用的构造函数称为默认构造函数, 这有两种情形, 一种是构造函数参数列表为空, 另一种是每个参数都在声明中给出了默认值.</p></blockquote><p>默认构造函数可以是自己定义的, 也可以由编译器自动生成. 当用户没有定义任何构造函数时, 编译器就会为用户生成一个参数列表为空的默认构造函数.</p><p><strong>trivial default constructor(无用默认构造函数)</strong></p><blockquote><p>满足下面所有的条件时, 一个默认构造函数是trivial的: - 不是由用户提供的, 即是由编译器生成的或者声明为default. - 类没有虚成员函数 - 类没有虚基类 - 类没有默认初始化的非静态成员 - 直接基类有trivial default constructor - 非静态类成员有trivial default constructor<br>显然, trivial default constructor不进行任何操作. 所有与C语言兼容的数据类型(POD类型)都具有trivial default constructor.</p></blockquote><h3 id="带有default-constructor的member-class-object"><a href="#带有default-constructor的member-class-object" class="headerlink" title="带有default constructor的member class object"></a>带有default constructor的member class object</h3><p>编译器会为没有定义构造函数的类合成默认构造函数, 但是这个合成操作只有在构造函数真正需要被调用时才会发生.</p><p>那么在C++不同编译模块中, 编译器怎么避免生成多个默认构造函数呢? 解决方法是把合成的默认构造函数, 复制构造函数, 析构函数, 赋值运算符都作为inline, 而inline函数是静态链接(static linkage)的, 不会被编译模块(即文件)以外的看到. 如果函数太复杂, 作为inline不合适, 就会合成一个显式non-inline静态(explicit non-inline static)实例.</p><p>我们知道, 类对象是必须要初始化的, 当一个类的成员有其他类对象时, 就必须在构造函数中对类成员进行初始化. 如果是编译器合成的默认构造函数, 就在合成的默认构造函数中按类成员声明顺序调用它们的默认构造函数(当然, 如果没有就会引起错误). 注意一点, 对于显式定义的构造函数函数, 如果没有对部分类成员对象的初始化, 编译器会自动插入一些代码, 使得用户代码被执行之前, 先调用必要的默认构造函数, 调用顺序与它们的声明相同. 但是如果有的对象显式调用了构造函数, 有的没有, 顺序是如何确定的呢? 仍然按照它们的声明顺序调用.</p><h3 id="“带有default-constructor”的Base-Class"><a href="#“带有default-constructor”的Base-Class" class="headerlink" title="“带有default constructor”的Base Class"></a>“带有default constructor”的Base Class</h3><p>如果一个子类的基类带有默认构造函数, 那么在合成子类的构造函数时, 会在其中插入对基类的默认构造函 数会的调用代码, 这个代码在成员的默认构造函数调用代码之前. 即先初始化基类, 再按声明顺序初始化子 类成员.</p><h3 id="“带有一个Virtual-Function”的Class"><a href="#“带有一个Virtual-Function”的Class" class="headerlink" title="“带有一个Virtual Function”的Class"></a>“带有一个Virtual Function”的Class</h3><p>对于带有虚函数的类, 不论是直接声明的还是直接/间接继承而来的, 都有虚函数表, 对应对象有虚函数表指 针(vptr)作为数据成员. 那么vptr是如何确定的呢? 显然, 虚函数表是在编译阶段就可以确定的, 因此由 编译器合成. 但是vptr的确定就要分情况讨论了:</p><ul><li>对于静态初始化的对象, vptr由编译器初始化.</li><li>对于动态初始化的对象, <strong>vptr由构造函数初始化</strong>. 因此编译器会在所有的构造函数中插入一些代码来完成这个任务.</li></ul><h3 id="“带有一个Virtual-Base-Class”的Class"><a href="#“带有一个Virtual-Base-Class”的Class" class="headerlink" title="“带有一个Virtual Base Class”的Class"></a>“带有一个Virtual Base Class”的Class</h3><p>当存在虚基类时, 通过虚基类指针/引用访问其非虚函数, 数据成员时, 应该是不属于多态的, 但是仍然在 运行时才能决定. 指针所指对象的实际类型很多时候是未知的, 在不同类型中, 由于采用了虚继承, 同一变 量偏移可能不一样(这是由实现决定的), 简而言之就是编译器不知道成员在指针所指对象的什么位置. 因此, 存在虚基类时, 就需要提供某种方法, 使我们能够通过虚基类指针访问虚基类的非虚函数和数据成员. 一种 方法是在子类中插入一个指向虚基类的指针, 将原始的通过虚基类指针访问那些成员的代码替换为先访问这个 指针, 再访问成员的代码. 如下所示:</p><pre class="line-numbers language-cpp"><code class="language-cpp">virtualBasePointer<span class="token operator">-</span><span class="token operator">></span>virtualBaseData<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 原始代码</span>
virtualBasePointer<span class="token operator">-</span><span class="token operator">></span>virtualBaseVptr<span class="token operator">-</span><span class="token operator">></span>virtualBaseData<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 编译器替换后的代码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>而这个<strong>虚基类指针的初始化</strong>就是由构造函数完成的.</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li>类的默认构造函数只有真正需要时才会被合成, 而不是没有定义构造函数时就会合成.</li><li>对于一个类的所有类成员对象, 如果没有显式初始化, 编译器会对其进行默认初始化. 但是对于内置类型, 例如int, 指针类型等, 不会进行初始化, 这是程序员的工作.</li></ol><h2 id="Copy-Constructor的构造操作"><a href="#Copy-Constructor的构造操作" class="headerlink" title="Copy Constructor的构造操作"></a>Copy Constructor的构造操作</h2><p>3种情况下会调用复制构造函数:</p><ol><li>用一个对象作为参数初始化另一个对象时.</li><li>对象作为函数参数时, 会用参数对象在函数作用域构造一个新的对象.</li><li>对象作为返回值时, 会用函数内部的对象在返回值所在作用域构造一个新的对象.</li></ol><p>注意, 2, 3不一定会发生, 因为可能会存在右值参数, 返回值优化等, 具体情况不做详述.</p><p>如果不显式定义复制构造函数, 编译器有两种复制对象的方法: bitwise copy和default memberwise copy, 区别如下:</p><ul><li>bitwise copy并不调用复制构造函数, 可能的实现方式如利用memcpy等, 因此效率更高, 复制出的对象和原对象完全相同.</li><li>default memberwise copy就如同对每个成员分别赋值一样, 对于内置类型, 直接初始化, 对于类类型, 递归调用其默认复制构造函数来初始化. 默认构造函数是由编译器合成的, 或者被声明为default. 其产生的新对象的用户定义的数据成员与原对象是一样的, 但是隐式的成员(如vptr), 内存布局(子类初始化父类)等不一定相同.</li></ul><blockquote><p><strong>注意:</strong><br>bitwise copy和浅复制(shallow copy)是不同的, 浅复制更侧重于当在类内部保存指针成员, 用指针指向实际数据的时候, 复制时仅仅复制指针的值. 这种情况包含在bitwise copy中.</p></blockquote><p>那么在没有定义复制构造函数的时候, 编译器在什么情况下采用bitwise copy, 在什么情况下合成默认复制构造函数(即采用default memberwise copy)? 下面四种情况, 会采用后者, 其他情况采用前者.</p><ol><li>当类含有类对象成员, 且这个成员含有复制构造函数时(不论是编译器合成的还是显式定义的).</li><li>当类继承自一个基类, 并且基类含有复制构造函数时(不论是编译器合成的还是显式定义的).</li><li>当类含有虚函数时.</li><li>当类有虚基类时.</li></ol><p>上面的情况很容易理解. 对于1和2, 由于复制对象时, 要复制数据成员和基类, 既然它们提供了复制构造函数, 就可以认为需要在它们的复制构造函数中进行某些bitwise copy无法实现的操作, 因此不能采用bitwise copy. 对于3, 由于含有虚函数, 所以需要初始化对象的vtpr, 而vptr的值显然不一定等于参数对象的值, 例如用子类对象初始化父类对象时. 所以bitwise不能满足需求. 对于4, 由于含有虚基类, 父子基类的内存布局可能存在区别, 更不能采用bitwise copy.</p><p>当合成/用户定义的复制构造函数的语意和bitwise copy相同时, 是否应该用bitwise copy替换复制构造函数?</p><h2 id="程序转化语意学-Program-Transformation-Semantics"><a href="#程序转化语意学-Program-Transformation-Semantics" class="headerlink" title="程序转化语意学(Program Transformation Semantics)"></a>程序转化语意学(Program Transformation Semantics)</h2><p>尽管在程序中可以使用不同的形式来初始化一个类对象, 但在编译阶段都会被转化成相同的形式. 例如:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">X</span><span class="token punctuation">;</span>
X <span class="token function">x0</span><span class="token punctuation">(</span>paras<span class="token punctuation">)</span><span class="token punctuation">;</span>
X x1 <span class="token operator">=</span> <span class="token function">X</span><span class="token punctuation">(</span>paras<span class="token punctuation">)</span><span class="token punctuation">;</span>
X <span class="token function">x2</span><span class="token punctuation">(</span>x0<span class="token punctuation">)</span><span class="token punctuation">;</span>
X x3 <span class="token operator">=</span> x0<span class="token punctuation">;</span>
X x4 <span class="token operator">=</span> <span class="token function">X</span><span class="token punctuation">(</span>x0<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>会被转化为:</p><pre class="line-numbers language-cpp"><code class="language-cpp">X x0<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 声明但不初始化</span>
X x1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 声明但不初始化</span>
X x2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 声明但不初始化</span>
X x3<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 声明但不初始化</span>
X x4<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 声明但不初始化</span>

<span class="token comment" spellcheck="true">// 调用构造函数初始化对象</span>
x0<span class="token punctuation">.</span>X<span class="token operator">::</span><span class="token function">X</span><span class="token punctuation">(</span>paras<span class="token punctuation">)</span>
x1<span class="token punctuation">.</span>X<span class="token operator">::</span><span class="token function">X</span><span class="token punctuation">(</span>paras<span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">// 调用复制构造函数初始化对象</span>
x2<span class="token punctuation">.</span>X<span class="token operator">::</span><span class="token function">X</span><span class="token punctuation">(</span>x0<span class="token punctuation">)</span>
x3<span class="token punctuation">.</span>X<span class="token operator">::</span><span class="token function">X</span><span class="token punctuation">(</span>x0<span class="token punctuation">)</span>
x4<span class="token punctuation">.</span>X<span class="token operator">::</span><span class="token function">X</span><span class="token punctuation">(</span>x0<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数复制优化和返回值优化(都是指省略不必要的复制构造函数的调用, 后面统称为复制优化或copy elision)</p><p>从C++17开始, 标准规定了必须进行copy elision的情况:</p><ul><li>类似下面的情形:</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp">T t <span class="token operator">=</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token function">T</span><span class="token punctuation">(</span><span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 只会调用一次默认构造函数, 要求类型相同(不考虑cv).</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>在返回类对象时, 如果直接在return语句中创建对象, 并且该对象与函数返回值类型一致(不考虑cv)时, 一般称这个优化为RVO(return value optimization)(注意, RVO在C++17之前都不是强制的, 从C++17开始才规定为mandatory的.), 如下例子:</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp">T <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

T t <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 只会调用一次默认构造函数.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样也规定了可以实施copy elision, 但不强制的情况, 比如NRVO(named return value optimization), 是指函数返回一个具名对象, 该对象是函数体内部定义的自动存储期变量, 并且是non-volatile的, 与函数返回值具有相同类型(不考虑cv). 具体可以参考<a href="https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/language/copy_elision">copy elision</a></p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ol><li>只有当存在复制构造函数(不论是显式定义的还是编译器生成的)时, 编译器才有可能实施复制优化.</li><li>谨慎对待copy elision, 因为类设计者可能需要在复制/移动构造函数中进行某些特殊操作, 省略了之后可能带来难以调试的错误.</li></ol><h2 id="成员初始化列表-Member-Initialization-List"><a href="#成员初始化列表-Member-Initialization-List" class="headerlink" title="成员初始化列表(Member Initialization List)"></a>成员初始化列表(Member Initialization List)</h2><p>应该用成员初始化列表来初始化变量的情况:</p><ol><li>初始化一个引用时.</li><li>初始化一个常量成员时.</li><li>调用基类的构造函数, 并且这个构造函数有一组参数时.</li><li>调用类成员的构造函数, 并且这个构造函数有一组参数时.</li></ol><p>类成员的初始化顺序与初始化列表的顺序无关, 而是与成员在类声明中的顺序一致. 所以, 尽量使初始化列表的顺序与声明顺序一致, 最好不要用一个成员来初始化另一个成员. 在编译阶段, 会将初始化列表转化为成员的初始化代码, 并置于构造函数体内的代码之前.</p><p>注意一点, 用成员函数的返回值来作为初始化列表的参数语法上是没有问题的, 但是需要保证这个成员函数不依赖于成员的数据对象, 因为很可能这个在调用此函数时还没有初始化其依赖的数据成员, 这就会引起难以发现的错误. 另外, 最好不要将其用于初始化基类成员, 详情见后面的讨论.</p><h2 id="不含数据成员的类对象"><a href="#不含数据成员的类对象" class="headerlink" title="不含数据成员的类对象"></a>不含数据成员的类对象</h2><p>对于不存在继承和虚函数的类, 没有数据成员时, 其大小至少是1 byte, 以保证变量有唯一的地址. 当加上虚函数后, 由于有虚函数指针, 对象大小等于一个指针的大小, 32位系统中是4 bytes, 64位系统中是8 bytes. 看下面的代码:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Empty <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> VirtualEmpty
<span class="token punctuation">{</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Empty a<span class="token punctuation">;</span>
Empty b<span class="token punctuation">;</span>

cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Empty<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出为1</span>
cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>VirtualEmpty<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出为8</span>

cout<span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>a<span class="token operator">&lt;&lt;</span><span class="token string">' '</span><span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>b<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 在输出中可以看到b的地址比a的地址大一.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是, 当其作为基类时, 在某些情况下则不必遵循上面的要求, 可以在子类中将其优化掉, 节省所占空间. 例如下面的情况:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Base <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> Derived <span class="token operator">:</span> Base
<span class="token punctuation">{</span>
    int64_t i<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Base<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出为1</span>
cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Derived<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl <span class="token comment" spellcheck="true">// 输出为8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显然这里没有必要保留额外空间来表示基类对象. 上面说过, 为空对象保留空间的原因是保证其有唯一地址, 避免出现不同对象的地址相同的情形. 但是在这里, 子类地址就可以作为父类地址, 不会出现不同对象地址相同的情形. 但是即使是继承, 也有不能进行优化的情况:</p><ul><li>子类的第一个非静态数据成员的类型和空基类相同.</li><li>子类的第一个非静态数据成员的基类类型和空基类相同.</li></ul><p>不难看出, 这两种情况下, 会有两个空基类对象(父类对象和子类数据成员对象)连续出现, 如果优化掉, 将不能区别二者. 示例如下:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Base <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> Derived1 <span class="token operator">:</span> Base <span class="token comment" spellcheck="true">// 情况一</span>
<span class="token punctuation">{</span>
    Base b<span class="token punctuation">;</span>
    int64_t i<span class="token punctuation">;</span>
<span class="token punctuation">}</span>d1<span class="token punctuation">;</span>

<span class="token keyword">struct</span> Derived2
<span class="token punctuation">{</span>
    Base b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> Derived3 <span class="token operator">:</span> Base
<span class="token punctuation">{</span>
    Derived2 d2<span class="token punctuation">;</span>
    int64_t i<span class="token punctuation">;</span>
<span class="token punctuation">}</span>d3<span class="token punctuation">;</span>

cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Derived1<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出为16, 基类对象和成员b各占1 byte, 由于内存对齐补齐8 bytes</span>
cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Derived2<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出为1</span>
cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Derived3<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出为16, 基类对象和成员d2各占1 byte, 由于内存对齐补齐8 bytes</span>

cout<span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>d1<span class="token operator">&lt;&lt;</span><span class="token string">' '</span><span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>d1<span class="token punctuation">.</span>b<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 前者(基类对象地址)比后者小1</span>
cout<span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>d3<span class="token operator">&lt;&lt;</span><span class="token string">' '</span><span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>d3<span class="token punctuation">.</span>d2<span class="token punctuation">.</span>b<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 前者(基类对象地址)比后者小1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于空类作为虚基类的情况, 同样可以进行优化. 例如下面的代码:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Base <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> Derived1 <span class="token operator">:</span> <span class="token keyword">virtual</span> Base <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> Derived2 <span class="token operator">:</span> <span class="token keyword">virtual</span> Base <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> Derived3 <span class="token operator">:</span> Derived1<span class="token punctuation">,</span> Derived1 <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> Derived4 <span class="token operator">:</span> Derived1<span class="token punctuation">,</span> Derived1
<span class="token punctuation">{</span>
    Base b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>d4<span class="token punctuation">;</span>

cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Derived3<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出为16</span>
cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Derived4<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出为24</span>

cout<span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>d4<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出为0x55c6986ffe70</span>
cout<span class="token operator">&lt;&lt;</span><span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span>Base<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d4<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出为0x55c6986ffe70</span>
cout<span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>d4<span class="token operator">-</span><span class="token operator">></span>b<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出为0x55c6986ffe80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了实现虚继承, 类Derived1和Derived2包含一个指针. 而虚基类Base被优化掉了, 因此Derived3大小为16 bytes. 而Derived4中由于包含类型是Base的非静态成员, 需要占据8 bytes, 即Derived4大小为24 bytes. 注意这里基类被优化了, 子类数据成员没有被优化. 测试显示, 即使这个成员不是第一个或最后一个, 编译器仍然不会优化.</p><p>虽然标准没有规定非静态数据成员在内存中的排列顺序, 但是一般实现都是按照声明顺序排列. 而由于内存对齐的要求, 仅仅改变成员的声明顺序可能产生不同大小的对象, 例如下面的声明:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Test1 <span class="token comment" spellcheck="true">// 大小为16 bytes</span>
<span class="token punctuation">{</span>
    int64_t i1<span class="token punctuation">;</span>
    <span class="token keyword">char</span> c1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// c1 和 c2 被放置在一个字(16 bytes)中</span>
    <span class="token keyword">char</span> c2<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> Test2 <span class="token comment" spellcheck="true">// 大小为24 bytes</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> c1<span class="token punctuation">;</span>
    int64_t i1<span class="token punctuation">;</span>
    <span class="token keyword">char</span> c2<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> Test3 <span class="token comment" spellcheck="true">// 大小为16 bytes</span>
<span class="token punctuation">{</span>
    int64_t i1<span class="token punctuation">;</span>
    int32_t i2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// i2,c1,c2 被放置在一个字(16 bytes)中</span>
    <span class="token keyword">char</span> c1<span class="token punctuation">;</span>
    <span class="token keyword">char</span> c2<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于计算机是以字(32位机为4 bytes, 64位机为8 bytes)为单位来读写, 因此内存对齐可以加快存取操作. 否则当一个变量跨字时, 读取这个变量就需要两次内存读. 但是这可能会增加需要的内存空间, 这就需要程序员仔细安排变量顺序, 以保证获得最佳的空间利用率.</p><p>而对于普通类的静态数据成员, 则具有独立于对象的静态生存期, 保存在全局数据段中. 模板类的静态数据成员如果没有被显式特化或实例化, 则在使用时会被隐式特化, 只有当特化/实例化后才是有效定义的. 有下面几种情况, 而这几种都可以归到C++14引入的 <em>variable template</em>(变量模板), 参考<a href="https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/language/variable_template">cppreference</a>.</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Test1
<span class="token punctuation">{</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span> <span class="token keyword">static</span> T val<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 非模板类的模板静态成员.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span> T Test1<span class="token operator">::</span>val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">struct</span> Test2
<span class="token punctuation">{</span>
    <span class="token keyword">static</span> T val<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 模板类的非模板静态成员.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span> T Test2<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token operator">></span>
<span class="token keyword">struct</span> Test3
<span class="token punctuation">{</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T2<span class="token operator">></span> <span class="token keyword">static</span> std<span class="token operator">::</span>pair<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token operator">></span> val<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 模板类的模板静态成员.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token operator">></span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T2<span class="token operator">></span>
std<span class="token operator">::</span>pair<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token operator">></span> Test2<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token operator">::</span>val <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token function">T1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">T2</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">auto</span> var <span class="token operator">=</span> Test3<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>val<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 即pair&lt;int, float>(1, 2)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数据成员的存取"><a href="#数据成员的存取" class="headerlink" title="数据成员的存取"></a>数据成员的存取</h2><h3 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h3><p>对静态成员, 通过对象或对象指针访问和通过类名访问没有区别, 编译器一般会将二者统一为相同形式. 类成员指针不能指向静态成员, 因为对静态成员取地址得到的是一个该成员的指针. 如:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>A<span class="token operator">::</span>x<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 其类型是 int*</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为类静态成员都是保存在全局数据段中, 如果不同类具有相同名字的静态成员, 就需要保证不会发生名称冲突. 编译器的解决方法是对每个静态数据成员编码(这种操作称为name-mangling), 以得到一个独一无二的名称.</p><h3 id="非静态数据成员"><a href="#非静态数据成员" class="headerlink" title="非静态数据成员"></a>非静态数据成员</h3><p>不存在虚基类时, 通过对象名或对象指针访问非静态数据成员没有区别. 存在虚基类时, 通过对象指针访问非静态数据成员需要在运行时才能确定, 因为无法确定指针所指对象的实际类型, 也就不能判断对象的内存布局, 也就不知道对象中该数据成员的偏移. 普通继承和虚继承的这个区别的原因在于, 普通继承的类对象的内存布局在编译时就可以决定, 而存在虚继承时则需要在运行时决定, 详情见下文虚继承对内存布局的影响的讨论.</p><h2 id="继承对对象布局的影响"><a href="#继承对对象布局的影响" class="headerlink" title="继承对对象布局的影响"></a>继承对对象布局的影响</h2><h3 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h3><p>最简单的一种情况, 单继承不会修改父类的内存布局, 例如父类由于内存对齐产生的额外空间在子类中不会被消除, 而是保持原样. 所以下面的代码中, 子类大小是24 bytes, 而不是16 bytes.</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Base <span class="token comment" spellcheck="true">// 16 bytes</span>
<span class="token punctuation">{</span>
    int64_t i1<span class="token punctuation">;</span>
    <span class="token keyword">char</span> c1<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> Derived <span class="token operator">:</span> Base <span class="token comment" spellcheck="true">// 24 bytes</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> c2<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其原因是如果消除了这些额外空间, 将子类对象赋值给父类对象时就可能会在父类对象的额外空间位置赋值, 这改变了程序的语义, 显然是不合适的.</p><h3 id="加上多态"><a href="#加上多态" class="headerlink" title="加上多态"></a>加上多态</h3><p>为了支持动态绑定, 编译器需要在对象中添加虚表指针(vptr), 指向虚表. 虚表中包含类的类型信息和虚函数指针, 值得注意的是, vptr并不是指向虚表的起始地址, 很多时候该地址之前会保存着对象的类型信息, 程序通过此类型信息实现RTTI. 而vptr初值的设置和其所占空间的回收, 则分别由构造函数和析构函数负责, 编译器自动在其中插入相应代码. 这是多态带来的空间负担和时间负担.</p><p>那么vptr放在什么位置呢? 这是由编译器决定的, gcc将其放在对象头部, 这导致对象不能兼容C语言中的struct, 但是在多重继承中, 通过类成员指针访问虚函数会更容易实现. 如果放在对象末尾则可以保证兼容性, 但是就需要在执行期间获得各个vptr在对象中的偏移, 在多重继承中尤其会增加额外负担.</p><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>标准并没有规定不同基类在布局中的顺序, 但是大多数实现按照继承声明顺序安排. 多重继承给程序带来了这些负担:</p><ul><li>将子类地址赋值给基类指针变量时, 如果是声明中的第一个基类, 二者地址相等, 可以直接赋值. 否则, 需要加上一个偏移量, 已获得对应对象的地址.</li><li>上面的直接加偏移并不能保证正确性, 设想子类指针值为0, 直接加上偏移后指向的是一个内容未知的地址. 正确做法应该是将0值赋给基类指针变量. 因此, 需要先判断基类指针是否为0, 再做处理. 而对于引用, 虽然其底层是指针, 但是不需要检查是否为0, 因为引用必须要绑定到一个有效地址, 不可能为0.</li></ul><h3 id="虚拟继承"><a href="#虚拟继承" class="headerlink" title="虚拟继承"></a>虚拟继承</h3><p>主要问题是如何实现只有一个虚拟基类. 主流方案是将虚拟基类作为共享部分, 其他类通过指针等方式指向虚拟基类, 访问时需要通过指针或其他方式获得虚拟基类的地址. gcc的做法是将虚基类放在对象末尾, 在虚表中添加一项, 记录基类对象在对象中的偏移, 从而获得其地址. 我们可以通过gdb调试来看看具体情况.</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> B
<span class="token punctuation">{</span>
    int64_t i1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout<span class="token operator">&lt;&lt;</span><span class="token string">"B::f() called\n"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> D1 <span class="token operator">:</span> <span class="token keyword">virtual</span> B
<span class="token punctuation">{</span>
    int64_t i2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> D2 <span class="token operator">:</span> <span class="token keyword">virtual</span> B
<span class="token punctuation">{</span>
    int64_t i3 <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> D3 <span class="token operator">:</span> D1<span class="token punctuation">,</span> D2
<span class="token punctuation">{</span>
    int64_t i4 <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>d3<span class="token punctuation">;</span>

<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>d3<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">8</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token string">"d3["</span><span class="token operator">&lt;&lt;</span>i<span class="token operator">&lt;&lt;</span><span class="token string">"] = 0x"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>hex<span class="token operator">&lt;&lt;</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>int64_t<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>d3 <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先用g++编译, 载入gdb中</p><pre class="line-numbers language-shell"><code class="language-shell"># g++ main.cc -g
# gdb a.out<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>之后, 设置断点, 运行程序, 再通过下面的命令查看对象d3的虚表.</p><pre class="line-numbers language-assembly"><code class="language-assembly">(gdb) p d3
$2 = {<d1> = {<b> = {_vptr.B = 0x555555557c58 <vtable for d3+72>, i1 = 1}, _vptr.D1 = 0x555555557c28 <vtable for d3+24>, i2 = 2}, <d2> = { _vptr.D2 = 0x555555557c40 <vtable for d3+48>, i3 = 3}, i4 = 4}
(gdb) p /a *((void**)0x555555557c28-3)@10
$4 = {0x28,
      0x0,
      0x555555557d20 <_zti2d3>,
      0x18,
      0xfffffffffffffff0,
      0x555555557d20 <_zti2d3>,
      0x0,
      0xffffffffffffffd8,
      0x555555557d20 <_zti2d3>,
      0x555555555446 <b ::f()>}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></b></_zti2d3></_zti2d3></_zti2d3></vtable></d2></vtable></vtable></b></d1></code></pre><p>可以发现, _vptr.D1等于<em>(int64_t *)&amp;d3, _vptr.D2等于</em>((int64_t <em>)&amp;d3 + 2), _vptr.B等于</em>((int64_t *)&amp;d3 + 5). 显然分别是各个对象的vptr的值. gdb的第二个命令是打印部分虚表内容, -3指定起始位置, 10指定长度. 可见_vptr.D1指向输出的第四个, _vptr.D2指向输出的第七个, 二者指向位置的地址减3即为对应对象和基类对象的偏移. 同样可以看到前一个是当前对象的类型信息. 如果在C++中直接访问虚表, 可以用下面的代码, 这和上面用gdb打印虚表等效:</p><pre class="line-numbers language-cpp"><code class="language-cpp">int64_t <span class="token operator">*</span>vptr <span class="token operator">=</span> <span class="token punctuation">(</span>int64_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>int64_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>d3<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// D1的虚表地址.</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">7</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token string">"_vptr.D1["</span><span class="token operator">&lt;&lt;</span>i<span class="token operator">&lt;&lt;</span><span class="token string">"] = 0x"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>hex<span class="token operator">&lt;&lt;</span><span class="token operator">*</span><span class="token punctuation">(</span>vptr<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="成员函数的调用"><a href="#成员函数的调用" class="headerlink" title="成员函数的调用"></a>成员函数的调用</h2><h3 id="普通非静态成员函数"><a href="#普通非静态成员函数" class="headerlink" title="普通非静态成员函数"></a>普通非静态成员函数</h3><blockquote><p>C++的设计准则之一就是: nonstatic member function至少必须和一般的nonmember funciton有相同的效率.</p></blockquote><p>为了保证类成员函数的效率, 编译器将对普通非静态成员函数的调用转换为对普通函数的调用. 步骤如下:</p><ol><li>修改函数签名, 添加一个额外的参数(作为第一个参数), 称为this指针. 由此将函数和对象关联起来.</li><li>将函数中对非静态成员的访问改为经过this指针访问.</li><li>将成员函数重写为一个外部函数, 生成一个独一无二的名字(name mangling).</li></ol><h3 id="虚成员函数"><a href="#虚成员函数" class="headerlink" title="虚成员函数"></a>虚成员函数</h3><p>编译器将对虚成员函数的调用转化为通过vptr调用函数. 在虚继承体系下, 任何含有某一虚函数的类, 该函数在虚表中的偏移都是固定的, 因此编译器可以根据函数名在编译期确定函数指针在虚表中的下标. 所以, 虚函数带来的额外负担就是增加一个内存访问.</p><pre class="line-numbers language-cpp"><code class="language-cpp">p<span class="token operator">-</span><span class="token operator">></span><span class="token function">func</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 设其在虚表中的下标为index.</span>

<span class="token comment" spellcheck="true">// 上面的语句将被转化为</span>
<span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">></span>vptr<span class="token punctuation">)</span><span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> param<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 这里p等于this指针, 所以将其作为第一个参数.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><p>对静态成员函数的访问将被转化为对普通函数的访问, 由于静态成员不能访问非静态数据成员, 因此不需要添加this指针. 静态函数有下面几个特点:</p><ul><li>不能直接访问类对象的非静态成员.</li><li>不能被声明为const, volatile, virtual.</li><li>可以通过类对象和类名来调用.</li></ul><p>注意一点, 当通过类对象来调用静态成员函数, 并且这个对象是由一个表达式得到时, 虽然不需要执行表达式就能直接调用函数, 但是表达式仍然会被执行(evaluate), 因为此表达式可能会有副作用, 不能被忽略. 例如:</p><pre class="line-numbers language-cpp"><code class="language-cpp">Object <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">static_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// func()仍然会被先执行, func()中可能会有某些不可省略的操作.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="虚成员函数的实现"><a href="#虚成员函数的实现" class="headerlink" title="虚成员函数的实现"></a>虚成员函数的实现</h2><h3 id="单继承-1"><a href="#单继承-1" class="headerlink" title="单继承"></a>单继承</h3><p>前文提到的虚成员函数实现是单继承下的模型, 下面具体说明其实现(注意下面提到的函数都指的是虚函数). 首先, 我们知道每个类都只有一个虚表(多继承和虚继承的类对象有多个vtpr, 指向不同的虚表, 但是实际上这些虚表是一个, vptr只是指向虚表的不同偏移位置), 也就是说相同类型的对象的vptr值是相同的. 当单继承发生时, 子类不仅继承了父类的数据成员, 还继承了函数成员, 前者体现在类对象布局上, 而后者体现在虚表上. 虚表继承的步骤可能包含下面几步:</p><ol><li>将父类虚表中的虚函数指针拷贝到子类虚表的相同下标位置.</li><li>如果子类重写了父类的虚函数, 就将被重写的虚函数的指针修改为对应函数的地址.</li><li>如果子类加入新的虚函数, 就增加虚表容量, 在后面添加新的函数指针.</li></ol><p>从上面可以看到, 单继承下的虚函数效率高, 实现简单, 但是多继承和虚拟继承则要复杂很多.</p><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>多继承的复杂性在于下面几个问题:</p><ul><li>通过第2,3,…个父类的指针访问子类的虚函数.</li><li>通过子类指针访问第2,3,…个父类的虚函数.</li><li>重写的虚函数的返回类型可能和父类的被重写函数的返回类型不一样, 这是标准允许的.</li></ul><p>在讨论上面的问题之前, 先复习一下C++中虚函数相关的知识.</p><p>首先, 明确虚函数重写的概念. 父类声明了一个虚函数, 如果其(直接或间接)子类定义了函数, 与父类虚函数具有相同的:</p><ul><li>名字</li><li>参数类型列表(不包含返回值)</li><li>const/volatile类型, 参考 <a href="https://zhuanlan.zhihu.com/p/61610818/edit#1">[1]</a></li><li>引用类型(三种: 无引用符号, &amp;, &amp;&amp;), 参考 <a href="https://zhuanlan.zhihu.com/p/61610818/edit#1">[1]</a></li></ul><p>则子类函数为虚函数(无论是否声明为virtual), 并且重写了父类的虚函数.</p><p>第二点, 多继承时, 我们通过子类指针可以访问所有父类的函数, 这一点很明确. 但是不能通过一个父类的指针访问其他父类的函数. 看下面的例子:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> B1
<span class="token punctuation">{</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> B2
<span class="token punctuation">{</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> D
<span class="token punctuation">{</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

B1 <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token keyword">new</span> D<span class="token punctuation">;</span>
p1<span class="token operator">-</span><span class="token operator">></span><span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// illegal</span>

B2 <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token keyword">new</span> D<span class="token punctuation">;</span>
p2<span class="token operator">-</span><span class="token operator">></span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// illegal</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也就是说, 通过一个类对象指针调用函数时, 这个函数必须要在这个类或其父类中声明过.</p><p>下面举例说明上面问题的复杂性.(调用虚函数时一定是通过指针或引用, 由于引用本质上是指针, 下面只讨论指针.)</p><p>对于第一个问题, 通过父类指针直接调用子类定义的函数时有两种情况:</p><ul><li>通过第一个基类指针访问时, 直接将指针值作为this指针值传给函数.</li><li>通过第2,3,…个基类指针访问时, 需要调整指针值, 加上/减去一个偏移, 再作为this指针传给函数.</li></ul><p>显然第二种情况下需要<strong>在运行时调整this指针的值</strong>, 因为编译时无法确定指针所指对象的实际类型.</p><p>除此之外, 再考虑一种特殊情况(间接调用子类虚函数):</p><ul><li>对一个父类指针调用delete.</li></ul><p>如果析构函数被声明为virtual, 那么程序将根据指针所指对象的实际类型决定调用哪个析构函数. 这就需要<strong>在运行时需要调整指针的值</strong>, 以保证能够访问正确的vptr, 从而获得对应的析构函数.</p><p>上面两个例子说明第一个问题的复杂性在于需要在运行时根据指针所指对象的实际类型来调整指针的值, 使之指向子类对象. 其他两个问题复杂性的根源也来自于此, 不(会)做详述.</p><p>问题明确了, 解决办法呢? 老实说没怎么看懂, 就不瞎说了, 等以后看明白了再补.</p><h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>其复杂性同样在于指针值的运行时修改, 书中建议不要在虚基类中声明非静态的函数.</p><h2 id="成员函数指针"><a href="#成员函数指针" class="headerlink" title="成员函数指针"></a>成员函数指针</h2><p>成员函数指针只能指向类的非静态成员函数, 使用方法如下:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> C
<span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token punctuation">(</span>C<span class="token operator">::</span><span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>C<span class="token operator">::</span>f<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// pointer to member function</span>
C c<span class="token punctuation">,</span> <span class="token operator">*</span>cp <span class="token operator">=</span> <span class="token operator">&amp;</span>c<span class="token punctuation">;</span>
<span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过对象调用函数f</span>
<span class="token punctuation">(</span>cp<span class="token operator">-</span><span class="token operator">></span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过对象指针调用函数f</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>父类成员函数指针可以直接赋值给子类成员函数指针, 如下面的例子:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> B
<span class="token punctuation">{</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> D <span class="token operator">:</span> B
<span class="token punctuation">{</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token punctuation">(</span>B<span class="token operator">::</span><span class="token operator">*</span> bf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>B<span class="token operator">::</span>f<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token punctuation">(</span>D<span class="token operator">::</span><span class="token operator">*</span> df<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> bf<span class="token punctuation">;</span>

B bp <span class="token operator">=</span> <span class="token keyword">new</span> D<span class="token punctuation">;</span>
<span class="token punctuation">(</span>bp<span class="token punctuation">.</span><span class="token operator">*</span>bf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用D::f()</span>
<span class="token punctuation">(</span>bp<span class="token punctuation">.</span><span class="token operator">*</span>df<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用D::f()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而子类的成员函数指针可以通过static_cast或C风格的类型转换将其转换为父类的成员函数指针.</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token punctuation">(</span>D<span class="token operator">::</span><span class="token operator">*</span> df<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>D<span class="token operator">::</span>f<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token punctuation">(</span>B<span class="token operator">::</span><span class="token operator">*</span> bf1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">void</span> <span class="token punctuation">(</span>B<span class="token operator">::</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span>df<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token punctuation">(</span>B<span class="token operator">::</span><span class="token operator">*</span> bf2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span>B<span class="token operator">::</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>df<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>从上面的例子中可以看到, 成员函数指针仍然支持虚函数机制. 下面看看编译器是如何支持各种虚拟机制的.</p><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>成员函数指针可以指向一个普通函数, 此时她可以是函数地址. 如果指向一个虚函数, 她可以是该函数在虚表中的偏移. 这两种值可以保存在相同类型的变量中, 但是如何区分她们呢? 早期C++限制最多有128个虚函数(应该是限制虚表长度为128吧), 所以偏移值最大为127. 而程序空间起始地址必定大于127, 因此可以通过将指针值和127做”&amp;”(按位与)运算来判断是偏移还是函数地址.</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>pmf<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token number">127</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token operator">*</span>pmf<span class="token punctuation">)</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token operator">-</span><span class="token operator">></span>vptr<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>pmf<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="多继承和虚继承"><a href="#多继承和虚继承" class="headerlink" title="多继承和虚继承"></a>多继承和虚继承</h3><p>支持这些机制的方法就更加复杂了. Stroustrup提出的一种方式是将成员函数指针定义为一个结构体, 包含this指针偏移, 虚基类指针偏移等等. 不过因为对不需要如此复杂机制的函数调用带来额外负担而受到批评. 有的实现对成员函数指针有多种实现方式, 以减少不必要的负担. 比如微软, 对单继承, 多继承, 虚继承就采用不同的方式来实现. 这个地方感觉还是不够具体, 坑先留着, 以后再填.</p><h3 id="inline函数"><a href="#inline函数" class="headerlink" title="inline函数"></a>inline函数</h3><p>在下面的情况下, 一个函数是inline函数:</p><ul><li>声明中包含inline关键字的函数</li><li>当一个函数(成员函数或非成员友元函数)的定义在类内部时</li><li>被声明为constexpr的函数(since C++11)</li></ul><p>inline函数只是一种建议, 建议编译器将对inline函数的调用转换, 但是编译器并不一定会接受该建议, 而且非inline函数也有可能被转换, 这依赖于具体实现. 使用inline函数时要注意下面几点:</p><ul><li><p>inline函数可能会增加生成的文件的大小.</p></li><li><p>inline函数尽可能简单. 减少不必要的局部变量, 否则可能会在结果中产生大量的局部变量.(现在的编译器应该可以优化这个了吧)</p></li><li><p>赋值运算符.</p></li><li><p>显式定义复制赋值运算符,</p></li><li><p>拒绝赋值行为.</p></li></ul><p>对于第三点, C++11之前需要将<em>operator =</em>声明为private, 并且不提供其定义. 而C++11之后, 可以用下面的语句实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp">ClassName<span class="token operator">&amp;</span> ClassName<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> ClassName<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>另外C++11提供的一个语法是可以将其显式声明为default, 虽然用户显式声明之, 但是定义是由编译器隐式生成的.</p><pre class="line-numbers language-cpp"><code class="language-cpp">ClassName<span class="token operator">&amp;</span> ClassName<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> ClassName<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当不需要拒绝赋值时, 就需要考虑是不是显式提供一个<em>operator =</em>. 一个原则是:</p><blockquote><p><strong>只有在默认复制赋值运算符的行为不安全或不正确时, 才需要显式定义复制赋值运算符</strong>.</p></blockquote><p>那么问题来了, 默认复制赋值运算符的行为是什么?</p><h3 id="Trivial-copy-assignment-operator"><a href="#Trivial-copy-assignment-operator" class="headerlink" title="Trivial copy assignment operator"></a>Trivial copy assignment operator</h3><p>当复制赋值运算符满足下面的条件是, 她就是tirivial的:</p><ul><li>不是用户提供的(隐式定义的或声明为default).</li><li>类没有虚函数.</li><li>类没有虚基类.</li><li>直接基类的复制赋值运算符都是trivial的.</li><li>非静态成员的复制赋值运算符是tirvial的.</li></ul><p>满足这个条件的对象的赋值行为是bitwise的, 就如同调用std::memmove一样. 所有与C语言兼容的数据类型都满足此条件. 不满足上面的的条件时, 就采用member-wise复制赋值行为. 以上的bitwise和member-wise就是默认复制赋值运算符的行为.</p><p>另一个问题是存在虚基类时复制赋值运算符可能会多次对基类子对象调用<em>operator =</em>, gcc-8就是如此. 一般含有虚基类的子类的复制赋值运算符定义如下:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> A <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*...*/</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> B <span class="token operator">:</span> <span class="token keyword">virtual</span> A <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*...*/</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> C <span class="token operator">:</span> <span class="token keyword">virtual</span> A <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*...*/</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> D <span class="token operator">:</span> B<span class="token punctuation">,</span> C <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*...*/</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

A<span class="token operator">&amp;</span> A<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> a<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">/*
    ... // member copy assignment
    */</span>
<span class="token punctuation">}</span>

B<span class="token operator">&amp;</span> B<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>A<span class="token operator">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 直接调用 A::operator =</span>
    <span class="token comment" spellcheck="true">/*
    ... // member copy assignment
    */</span>
<span class="token punctuation">}</span>

C<span class="token operator">&amp;</span> C<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> C<span class="token operator">&amp;</span> c<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>A<span class="token operator">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 直接调用 A::operator =</span>
    <span class="token comment" spellcheck="true">/*
    ... // member copy assignment
    */</span>
<span class="token punctuation">}</span>

D<span class="token operator">&amp;</span> D<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> D<span class="token operator">&amp;</span> d<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>A<span class="token operator">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 直接调用 A::operator =</span>
    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>B<span class="token operator">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 间接调用 A::operator =</span>
    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>C<span class="token operator">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 间接调用 A::operator =</span>
    <span class="token comment" spellcheck="true">/*
    ... // member copy assignment
    */</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++并没有提供类似复制构造函数的语法来保证虚基类只会被复制一次. 所以, 书中建议将虚基类的复制赋值运算符声明为delete, 甚至不要再虚基类中声明数据成员.</p><h2 id="对象析构"><a href="#对象析构" class="headerlink" title="对象析构"></a>对象析构</h2><p>书中提到一个值得注意的问题, 并不是定义了构造函数就需要定义析构函数, 这种”对称”是无意义的. 只有当需要一个析构函数时, 我们才应该显式定义之. 那么什么时候需要呢? 首先要搞清楚析构函数的作用, 她是对象的生命周期的终结, 而函数体内执行的主要是是对对象持有的资源的释放, 例如在构造函数中动态申请的空间. 析构函数的操作与构造函数类似, 但是顺序相反.</p><h3 id="Trivial-destructor"><a href="#Trivial-destructor" class="headerlink" title="Trivial destructor"></a>Trivial destructor</h3><p>类T的析构函数如果满足下面的条件, 就是trivial的:</p><ul><li>析构函数不是用户定义的.(隐式声明或声明为default)</li><li>析构函数非虚.(这就要求父类的虚函数也非虚)</li><li>直接父类的析构函数是trivial的.</li><li>非静态数据成员(数组的数据成员)的析构函数是trivial的.</li></ul><p>trivial析构函数不进行任何操作, 析构时只需要释放对象的空间即可. 所有与C语言兼容的数据类型都是<em>trivial destructible</em>的.</p></div><hr><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/tags/Cpp/"><span class="chip bg-color">Cpp</span> </a><a href="/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"><span class="chip bg-color">原理剖析</span> </a><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="chip bg-color">读书笔记</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="wechat,qq" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="/libs/share/js/social-share.min.js"></script></div></div></div></div></div><style>.valine-card{margin:1.5rem auto}.valine-card .card-content{padding:20px 20px 5px 20px}#vcomments textarea{box-sizing:border-box;background:url(/medias/comment_bg.png) 100% 100% no-repeat}#vcomments p{margin:2px 2px 10px;font-size:1.05rem;line-height:1.78rem}#vcomments blockquote p{text-indent:.2rem}#vcomments a{padding:0 2px;color:#4cbf30;font-weight:500;text-decoration:none}#vcomments img{max-width:100%;height:auto;cursor:pointer}#vcomments ol li{list-style-type:decimal}#vcomments ol,ul{display:block;padding-left:2em;word-spacing:.05rem}#vcomments ul li,ol li{display:list-item;line-height:1.8rem;font-size:1rem}#vcomments ul li{list-style-type:disc}#vcomments ul ul li{list-style-type:circle}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}#vcomments table,td,th{border:0}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments h1{font-size:1.85rem;font-weight:700;line-height:2.2rem}#vcomments h2{font-size:1.65rem;font-weight:700;line-height:1.9rem}#vcomments h3{font-size:1.45rem;font-weight:700;line-height:1.7rem}#vcomments h4{font-size:1.25rem;font-weight:700;line-height:1.5rem}#vcomments h5{font-size:1.1rem;font-weight:700;line-height:1.4rem}#vcomments h6{font-size:1rem;line-height:1.3rem}#vcomments p{font-size:1rem;line-height:1.5rem}#vcomments hr{margin:12px 0;border:0;border-top:1px solid #ccc}#vcomments blockquote{margin:15px 0;border-left:5px solid #42b983;padding:1rem .8rem .3rem .8rem;color:#666;background-color:rgba(66,185,131,.1)}#vcomments pre{font-family:monospace,monospace;padding:1.2em;margin:.5em 0;background:#272822;overflow:auto;border-radius:.3em;tab-size:4}#vcomments code{font-family:monospace,monospace;padding:1px 3px;font-size:.92rem;color:#e96900;background-color:#f8f8f8;border-radius:2px}#vcomments pre code{font-family:monospace,monospace;padding:0;color:#e8eaf6;background-color:#272822}#vcomments pre[class*=language-]{padding:1.2em;margin:.5em 0}#vcomments code[class*=language-],pre[class*=language-]{color:#e8eaf6}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}#vcomments b,strong{font-weight:700}#vcomments dfn{font-style:italic}#vcomments small{font-size:85%}#vcomments cite{font-style:normal}#vcomments mark{background-color:#fcf8e3;padding:.2em}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}.v .vlist .vcard{padding-top:2.5em!important}</style><div class="card valine-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;left:20px;top:15px;padding-bottom:5px"><i class="fa fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="vcomments" class="card-content" style="display:grid"></div></div><script src="/libs/valine/av-min.js"></script><script src="/libs/valine/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"98JpzSGcrl9jFqHO13vqxHvX-gzGzoHsz",appKey:"mDmr2h9PB20xvPMNqgyRnNIC",notify:!0,verify:!0,visitor:!0,avatar:"mm",pageSize:"10",lang:"zh-cn",placeholder:"just go go"})</script><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fa fa-chevron-left"></i>&nbsp;上一篇</div><div class="card"><a href="/posts/34936/"><div class="card-image"><img src="/medias/featureimages/22.jpg" class="responsive-img" alt="如何用lambda表达式快速刷题"> <span class="card-title">如何用lambda表达式快速刷题</span></div></a><div class="card-content article-content"><div class="summary block-with-text">用现代c++优化你的刷题体验</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2024-03-20 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/Cpp/" class="post-category">Cpp</a></span></div></div><div class="card-action article-tags"><a href="/tags/Cpp/"><span class="chip bg-color">Cpp</span> </a><a href="/tags/Leetcode/"><span class="chip bg-color">Leetcode</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fa fa-chevron-right"></i></div><div class="card"><a href="/posts/17028/"><div class="card-image"><img src="/medias/featureimages/0.jpg" class="responsive-img" alt="一些有关本站升级的故事"> <span class="card-title">一些有关本站升级的故事</span></div></a><div class="card-content article-content"><div class="summary block-with-text">一些关于站点的事情</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2024-03-13 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E6%9D%82%E8%AE%B0/" class="post-category">杂记</a></span></div></div><div class="card-action article-tags"><a href="/tags/%E7%AB%99%E7%82%B9%E7%9B%B8%E5%85%B3/"><span class="chip bg-color">站点相关</span></a></div></div></div></div></article></div><script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script><script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script><script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script><script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget"><div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fa fa-list"></i></a></div><script src="/libs/tocbot/tocbot.min.js"></script><script>$(function(){tocbot.init({tocSelector:"#toc-content",contentSelector:"#articleContent",headingsOffset:-(.4*$(window).height()-45),headingSelector:"h2, h3, h4, h5"});let t=0;var e="toc-heading-";$("#toc-content a").each(function(){$(this).attr("href","#"+e+ ++t)}),t=0,$("#articleContent").children("h2, h3, h4, h5").each(function(){$(this).attr("id",e+ ++t)});var n=parseInt(.4*$(window).height()-64);let o=$(".toc-widget");$(window).scroll(function(){var t=$(window).scrollTop();n<t?o.addClass("toc-fixed"):o.removeClass("toc-fixed")});var i="expanded";let a=$("#toc-aside"),c=$("#main-content");$("#floating-toc-btn .btn-floating").click(function(){a.hasClass(i)?(a.removeClass(i).hide(),c.removeClass("l9")):(a.addClass(i).show(),c.addClass("l9")),function(){let e=$("#artDetail");if(0!==e.length){let t=e.width();450<=t?t+=21:350<=t&&t<450?t+=18:300<=t&&t<350?t+=16:t+=14,$("#prenext-posts").width(t)}}()})})</script></main><footer class="page-footer bg-color"><div class="container row center-align"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2019</span> <a href="/about" rel="external nofollow noreferrer">JoyTsing</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br><span id="sitetime">载入运行时间...</span> <span id="busuanzi_container_site_pv">|&nbsp;<i class="fa fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span>&nbsp;次 </span><span id="busuanzi_container_site_uv">|&nbsp;<i class="fa fa-user"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv" class="white-color"></span>&nbsp;人</span><br>&nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;<span class="white-color">718.4k</span>&nbsp;字 <span id="icp"><img src="/medias/icp.png" style="vertical-align:text-bottom" alt="icp"> <a href="https://beian.miit.gov.cn/" target="_blank">陕公网安备61019002002862号 滇ICP备2024026466号-1</a></span><script>function siteTime(){var e=864e5,t="2019",n=(m=new Date).getFullYear(),o=m.getMonth()+1,r=m.getDate(),a=m.getHours(),i=m.getMinutes(),l=m.getSeconds(),m=Date.UTC(t,"7","24","0","0","0"),r=Date.UTC(n,o,r,a,i,l)-m,a=Math.floor(r/31536e6),i=Math.floor(r/e-365*a),l=Math.floor((r-(365*a+i)*e)/36e5),m=Math.floor((r-(365*a+i)*e-36e5*l)/6e4),M=Math.floor((r-(365*a+i)*e-36e5*l-6e4*m)/1e3);t==n?(document.getElementById("year").innerHTML=n,document.getElementById("sitetime").innerHTML="本站已安全运行 "+i+" 天 "+l+" 小时 "+m+" 分钟 "+M+" 秒"):(document.getElementById("year").innerHTML=t+" - "+n,document.getElementById("sitetime").innerHTML="本站已安全运行 "+a+" 年 "+i+" 天 "+l+" 小时 "+m+" 分钟 "+M+" 秒")}setInterval(siteTime,1e3)</script></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/JoyTsing" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fa fa-github"></i> </a><a href="/medias/wechat.jpg" target="_blank" data-tooltip="添加我的微信: [object Object]" data-position="top" data-delay="50"><i class="fa fa-weixin"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script src="/js/search.js"></script><script type="text/javascript">$(function(){searchFunc("/search.xml","searchInput","searchResult")})</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fa fa-angle-up"></i></a></div><script src="/libs/materialize/materialize.min.js"></script><script src="/libs/masonry/masonry.pkgd.min.js"></script><script src="/libs/aos/aos.js"></script><script src="/libs/scrollprogress/scrollProgress.min.js"></script><script src="/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="/js/matery.js"></script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?3a39d92b69933ae56c7eb41ffb9aa2e0";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js",(e=document.getElementsByTagName("script")[0]).parentNode.insertBefore(t,e)}()</script><script async src="/libs/others/busuanzi.pure.mini.js"></script><script type="text/javascript">var st,OriginTitile=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="(oﾟvﾟ)ノ Hi",clearTimeout(st)):(document.title="(*´∇｀*) 欢迎回来！",st=setTimeout(function(){document.title=OriginTitile},3e3))})</script><script type="text/javascript" color="0,0,255" pointcolor="0,0,255" opacity="0.8" zindex="-1" count="150" src="/libs/background/canvas-nest.js"></script><script src="/libs/instantpage/instantpage.js" type="module"></script><script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script><script>const hasAttr = (e,a) => a.some(_=> e.attr(_)!==undefined);
        $('a').each(function() {
          const $this = $(this);
          if(hasAttr($this,["data-fancybox","ignore-external-link"])) return;
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== '' || window.location.host) {
                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/shizuku.model.json"},display:{position:"left",width:150,height:200},mobile:{show:!1},react:{opacity:.7}})</script></body></html>