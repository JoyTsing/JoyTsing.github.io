<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JoyTsing</title>
  
  <subtitle>[object Object]</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://joytsing.github.io/"/>
  <updated>2024-03-11T11:45:49.440Z</updated>
  <id>https://joytsing.github.io/</id>
  
  <author>
    <name>JoyTsing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Cpp 中如何优雅进行 enum 到 string 的转换</title>
    <link href="https://joytsing.github.io/posts/30790/"/>
    <id>https://joytsing.github.io/posts/30790/</id>
    <published>2024-03-11T11:27:58.000Z</published>
    <updated>2024-03-11T11:45:49.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这里不介绍非侵入式的写法，具体想要了解的话可以观看<a href="https://zhuanlan.zhihu.com/p/680412313">这篇文章</a>,这里仅介绍通过宏写法来进行转换的情况。</p><h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><p>这里拿minilog的log-level定义来介绍，首先肯定是需要按照等级先进行定义：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">define</span> MINILOG_FOREACH_LOG_LEVEL(f) \  f(trace) f(debug) f(info) f(critical) f(warn) f(error) f(fatal)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>后续如果要修改只用修改这一处就行了，优点是一劳永逸，不存在维护额外开销的问题，当然缺点也有，比如在写server的时候遇到过需要将传入的指令进行与操作整合的情况，这种类型的情况下就无法使用宏的方法，或者说需要额外处理。</p><p>在定义好各个level后就需要进行enum的声明了：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">log_level</span> <span class="token operator">:</span> std<span class="token operator">::</span>uint8_t <span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">define</span> _FUNCTION(name) name,</span>  <span class="token function">MINILOG_FOREACH_LOG_LEVEL</span><span class="token punctuation">(</span>_FUNCTION<span class="token punctuation">)</span><span class="token macro property">#<span class="token directive keyword">undef</span> _FUNCTION</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体来说就是将log_level在enum中用宏函数进行了展开，避免无用代码的编写。接下来是文章的核心，怎么进行enum和string的相互转化。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">inline</span> std<span class="token operator">::</span>string <span class="token function">log_level_name</span><span class="token punctuation">(</span>log_level level<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">switch</span> <span class="token punctuation">(</span>level<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">define</span> _FUNCTION(name) \  case log_level::name: \    return #name;</span>    <span class="token function">MINILOG_FOREACH_LOG_LEVEL</span><span class="token punctuation">(</span>_FUNCTION<span class="token punctuation">)</span><span class="token macro property">#<span class="token directive keyword">undef</span> _FUNCTION</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token string">"unknown"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">inline</span> log_level <span class="token function">log_level_from_name</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string_view lev<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">define</span> _FUNCTION(name) \  if (lev == #name) return log_level::name;</span>  <span class="token function">MINILOG_FOREACH_LOG_LEVEL</span><span class="token punctuation">(</span>_FUNCTION<span class="token punctuation">)</span><span class="token macro property">#<span class="token directive keyword">undef</span> _FUNCTION</span>  <span class="token keyword">return</span> log_level<span class="token operator">::</span>info<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>非常方便，相当于自动维护对应的代码，事实上，clang 在定义TokenKind的时候，就是这么做的，具体的案例请参考。由于 clang 要适配多种语言前端，最后总计的TokenKind有几百个之多。如果不这样做，可想而知，进行Token的增加和修改会十分困难。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;这里不介绍非侵入式的写法，具体想要了解的话可以观看&lt;a href=&quot;https://zhuanlan.zhihu.com/p/6804123
      
    
    </summary>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>More Effective-CPP:读书笔记</title>
    <link href="https://joytsing.github.io/posts/59007/"/>
    <id>https://joytsing.github.io/posts/59007/</id>
    <published>2024-03-11T06:30:01.000Z</published>
    <updated>2024-03-11T09:10:08.977Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>虽然早在4年前的大二时期就看过并且实践在工程作业里面，但一直没有一个完整的记录，想着别的几本都有了干脆补全一下吧，个人总结，难免会出现一些不太准确的地方，欢迎各位指正。</p><h2 id="条款1：仔细区别-pointers-和-references"><a href="#条款1：仔细区别-pointers-和-references" class="headerlink" title="条款1：仔细区别 pointers 和 references"></a>条款1：仔细区别 pointers 和 references</h2><ul><li>reference 不能为 null。</li><li>一般而言，当你需要考虑“不指向任何对象”的可能性时，或是考虑“在不同事件指向不同对象”的能力时，你就应该采用 pointer。</li><li>当你知道你需要指向某个东西，而且绝不会改变指向其他东西，或是当你实现一个操作符而其语法需求无法由 pointers 达成，你就应该选择 reference。任何其他时候，请采用 pointers。</li></ul><h2 id="条款2：最好使用-C-转型操作符"><a href="#条款2：最好使用-C-转型操作符" class="headerlink" title="条款2：最好使用 C++ 转型操作符"></a>条款2：最好使用 C++ 转型操作符</h2><h3 id="1-static-cast"><a href="#1-static-cast" class="headerlink" title="1 static_cast"></a>1 static_cast</h3><p>使用 <code>static_cast&lt;type&gt;(expression)</code>代替 (type)expression</p><h3 id="2-const-cast"><a href="#2-const-cast" class="headerlink" title="2 const_cast"></a>2 const_cast</h3><p>将某个对象的常量性去除掉</p><h3 id="3-dynamic-cast"><a href="#3-dynamic-cast" class="headerlink" title="3 dynamic_cast"></a>3 dynamic_cast</h3><ul><li>利用<code>dynamic_cast</code>，将“指向 base class objects 的 pointers 或 references”转型为“指向derived（或 sibling base）class objects 的 pointers 或 references”， 并得知转型是否成功。</li><li>如果转型失败，会以一个 null 指针（当转型对象是指针）或一个 exception （当转型对象是 reference）表现出来。</li></ul><h3 id="4-reinterpret-cast"><a href="#4-reinterpret-cast" class="headerlink" title="4 reinterpret_cast"></a>4 reinterpret_cast</h3><p>最常用用途是转换“函数指针”类型，对应C里面的强制转换</p><h2 id="条款3：绝对不要以多态（polymorphically）方式处理数组"><a href="#条款3：绝对不要以多态（polymorphically）方式处理数组" class="headerlink" title="条款3：绝对不要以多态（polymorphically）方式处理数组"></a>条款3：绝对不要以多态（polymorphically）方式处理数组</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">base</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">base</span><span class="token punctuation">(</span><span class="token keyword">int</span> p1<span class="token punctuation">,</span> <span class="token keyword">int</span> p2<span class="token punctuation">)</span>        <span class="token operator">:</span><span class="token function">p1</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">p2</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> p1<span class="token punctuation">,</span> p2<span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> p1 <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> p2 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">derived</span> <span class="token operator">:</span> <span class="token keyword">public</span> base<span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">derived</span><span class="token punctuation">(</span><span class="token keyword">int</span> p1<span class="token punctuation">,</span> <span class="token keyword">int</span> p2<span class="token punctuation">,</span> <span class="token keyword">int</span> p3<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">base</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">p3</span><span class="token punctuation">(</span>p3<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> p3<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override<span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> p1 <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> p2 <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> p3 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>base array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">"th item's size is: "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    base    <span class="token function">b1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span>  <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    derived <span class="token function">d1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>   <span class="token number">2</span><span class="token punctuation">,</span>  <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    base    <span class="token function">b2</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">,</span>  <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    derived <span class="token function">d2</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span>   <span class="token number">5</span><span class="token punctuation">,</span>  <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    base array<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>d1<span class="token punctuation">,</span> b1<span class="token punctuation">,</span> d2<span class="token punctuation">,</span> b2<span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sizeof(base): "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>b1<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\tsizeof(derived): "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>d1<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// sizeof(base): 8 sizeof(derived): 12</span>    <span class="token function">print</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 0th item's size is: 8    1, 2</span>    <span class="token comment" spellcheck="true">// 1th item's size is: 8    10, 20</span>    <span class="token comment" spellcheck="true">// 2th item's size is: 8    4, 5</span>    <span class="token comment" spellcheck="true">// 3th item's size is: 8    40, 50</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你交给printBaseArray函数一个包含derived对象组成的数组，你的编译器就会被误导。这种情况下它仍假设数组中的每一个元素的大小是base的大小，但其实每一个元素的大小是不一样的。</p><h2 id="条款4：非必要不提供-default-constructor"><a href="#条款4：非必要不提供-default-constructor" class="headerlink" title="条款4：非必要不提供 default constructor"></a>条款4：非必要不提供 default constructor</h2><ul><li>在一个完美的世界中，凡可以“合理地从无到有生成对象”的 classes，都应该内含 default constructors，“必须有某些外来信息才能生成对象” 的 classes，则不必拥有 default constructors。</li><li>在进退维谷的情况下，最后一个考虑点和 virtual base classes 有关。 Virtual base classes 如果缺乏 default constructors，与之合作将会是一种刑法。</li><li>添加无意义的 constructors，也会影响 classes 的效率。</li></ul><h2 id="条款5：对定制的-“类型转换函数”-保持警觉"><a href="#条款5：对定制的-“类型转换函数”-保持警觉" class="headerlink" title="条款5：对定制的 “类型转换函数” 保持警觉"></a>条款5：对定制的 “类型转换函数” 保持警觉</h2><p>下述代码根本的原因在于，在你从未打算也未预期的情况下，此函数可能会被调用，而其结果可能是不正确.不直观的程序行为很难发现调试。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Rational</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Rational</span><span class="token punctuation">(</span><span class="token keyword">int</span> numerator <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">int</span> denominator <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">operator</span> <span class="token keyword">double</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token keyword">friend</span> std<span class="token operator">::</span>ostream <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>std<span class="token operator">::</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> Rational <span class="token operator">&amp;</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> numerator<span class="token punctuation">;</span>    <span class="token keyword">int</span> denominator<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Rational<span class="token operator">::</span><span class="token function">Rational</span><span class="token punctuation">(</span><span class="token keyword">int</span> numerator<span class="token punctuation">,</span> <span class="token keyword">int</span> denominator<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>numerator <span class="token operator">=</span> numerator<span class="token punctuation">;</span>     <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>denominator <span class="token operator">=</span> denominator<span class="token punctuation">;</span><span class="token punctuation">}</span>Rational<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">double</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>numerator<span class="token punctuation">)</span><span class="token operator">/</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>denominator<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>std<span class="token operator">::</span>ostream <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>std<span class="token operator">::</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> Rational <span class="token operator">&amp;</span>r<span class="token punctuation">)</span> <span class="token punctuation">{</span>    os <span class="token operator">&lt;&lt;</span> r<span class="token punctuation">.</span>numerator <span class="token operator">&lt;&lt;</span> <span class="token string">"/"</span> <span class="token operator">&lt;&lt;</span> r<span class="token punctuation">.</span>denominator <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> os<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   Rational <span class="token function">r</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> r<span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// 1/2</span>   <span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">0.5</span> <span class="token operator">*</span> r<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 0.25</span>   std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> d <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假设你忘了为 Rational 写一个 operator&lt;&lt;，你或许以为上述的 std::cout &lt;&lt; r; 不会成功，因为没有适当的 operator&lt;&lt; 可以调用。但是你错了，你的编译器面对上述动作，发现不存在任何 operator&lt;&lt; 可以接受一个 Rational，但它会想尽各种办法（包括找出一系列可接受的隐式类型转换）让函数调用动作成功。即进行了隐式类型转换，导致（非预期）的函数被调用。</p><p>解决这个问题，可以采用:</p><ul><li>以功能对等的另一个函数取代类型转换操作符</li><li>使用关键字 explicit</li></ul><h2 id="条款6：区别-increment-decrement-操作符的前置-prefix-和后置-postfix-形式"><a href="#条款6：区别-increment-decrement-操作符的前置-prefix-和后置-postfix-形式" class="headerlink" title="条款6：区别 increment/decrement 操作符的前置(prefix)和后置(postfix)形式"></a>条款6：区别 increment/decrement 操作符的前置(prefix)和后置(postfix)形式</h2><pre class="line-numbers language-c++"><code class="language-c++">class UPInt{public:    UPInt(int i)                    //提供一个构造函数        :val(i){};    UPInt& operator++();            //前置++    const UPInt operator++(int);    //后置++    UPInt& operator--();            //前置--    const UPInt operator--(int);    //后置--    UPInt& operator+=(const int i); //+=操作符    //...    int val;};//前置++，返回referenceUPInt &UPInt::operator++() {    *this += 1;    return *this;}//后置++，返回一个const对象const UPInt UPInt::operator++(int) {    UPInt oldValue = *this;    ++(*this);    return oldValue;}//前置--，返回referenceUPInt &UPInt::operator--() {    *this += -1;    return *this;}//后置--，返回一个const对象const UPInt UPInt::operator--(int) {    UPInt oldValue = *this;    --(*this);    return oldValue;}//+=操作符，看需求，这里返回一个 referenceUPInt &UPInt::operator+=(const int i) {    this->val = this->val + i;    return *this;}//这里帮助打印UPint里的val值void print(const UPInt &up) { std::cout << up.val <<std::endl; }int main(){    UPInt i(0);    print(i);       // 0    print(++i);     // 1    print(i++);     // 1    print(i);       // 2    print(--i);     // 1    print(i--);     // 1    print(i);       // 0}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为什么后置++或–返回的是一个const值呢？如果不是一个const值的话，那么下面的动作就是合法的。</p><pre class="line-numbers language-cpp"><code class="language-cpp">    UPInt <span class="token function">i</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    i<span class="token operator">++</span><span class="token operator">++</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>处理用户定制类型时，应尽可能使用前置式 increment，因为它天生体质较佳。</p><h2 id="条款7：千万不要重载-amp-amp-，-和-操作符"><a href="#条款7：千万不要重载-amp-amp-，-和-操作符" class="headerlink" title="条款7：千万不要重载 &amp;&amp;，|| 和 , 操作符"></a>条款7：千万不要重载 &amp;&amp;，|| 和 , 操作符</h2><p>C++ 对于“真假值表达式”采用所谓的“骤死式”评估方式。意思是一旦该表达式的真假值确定，即使表达式中还有部分尚未检验，整个评估工作仍结束。</p><p>如果你决定重载 operator&amp;&amp; 或 operator||，你必须知道，你正在从根本层面改变整个游戏规则，因为从此“函数调用”语义会取代“骤死式”语义。</p><p>如果你将 &amp;&amp; 或 || 重载，就没有办法提供程序员预期（甚至依赖）的某种行为模式。</p><p><strong>如果你没有什么好的理由将某个操作符重载，就不要去做。</strong></p><h2 id="条款8：了解各种不同意义的-new-和-delete"><a href="#条款8：了解各种不同意义的-new-和-delete" class="headerlink" title="条款8：了解各种不同意义的 new 和 delete"></a>条款8：了解各种不同意义的 new 和 delete</h2><h3 id="new-operator"><a href="#new-operator" class="headerlink" title="new operator"></a>new operator</h3><p>举个例子，当你写出这样的代码，就是使用了所谓的 new operator</p><p>string *ps = new string(“Hello World!”);<br>分配足够的内存，用来放置某类型的对象<br>调用一个constructor，为上一步中分配的内存中的那个对象设定初始值。<br>new operator 总是做这两件事，无论如何你不能改变其行为。</p><h3 id="operator-new"><a href="#operator-new" class="headerlink" title="operator new"></a>operator new</h3><p>举个例子，函数 operator new 通常声明如下</p><blockquote><p>void *operator new(size_t size);</p></blockquote><p>上述返回值类型是 void*。此函数返回一个指针，直线一块原始的、未设初始值的内存。函数中的 size_t 参数表示需要分配多少内存。你可以将 operator new 重载，加上额外的参数，但第一参数的类型必须总是 size_t。</p><p>举个例子</p><blockquote><p>void *rawMemory = operator new(sizeof(string))</p></blockquote><p>这里的 operator new 将返回指针，指向一块足够容纳一个 string 对象的内存。和 malloc 一样 operator new 的唯一任务就是分配内存。</p><h3 id="placement-new"><a href="#placement-new" class="headerlink" title="placement new"></a>placement new</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">new</span><span class="token punctuation">(</span>内存地址<span class="token punctuation">)</span> 类<span class="token punctuation">(</span><span class="token punctuation">[</span>实参<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">base</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">base</span><span class="token punctuation">(</span><span class="token keyword">int</span> p1<span class="token punctuation">)</span>        <span class="token operator">:</span><span class="token function">p1</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> p1<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>base<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 4</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 1</span>    <span class="token keyword">char</span> <span class="token operator">*</span>memory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>base<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// address: 0xdb3278</span>    base <span class="token operator">*</span>b1 <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>memory<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">base</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// address:0xdb3278    val:e8 03 00 00     03e8    = 1000</span>    base <span class="token operator">*</span>b2 <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>memory<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">base</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// address:0xdb327c    val:02 00 00 00     02      = 2</span>    base <span class="token operator">*</span>b3 <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>memory<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">base</span><span class="token punctuation">(</span><span class="token number">9999999</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// address:0xdb3280    val:7f 96 98 00     98967f  = 9999999</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简而言之，如果你有一些分配好的内存，且需要在上面构建对象。那么可以使用 placement new。</p><table><thead><tr><th></th><th>分配内存</th><th>构造</th></tr></thead><tbody><tr><td>new operator</td><td>√</td><td>√</td></tr><tr><td>operator new</td><td>√</td><td>×</td></tr><tr><td>placement new</td><td>×</td><td>√</td></tr></tbody></table><p>至于delete也是同理，不在这过多描述(很少使用)。</p><h2 id="条款9：利用-deconstructors-避免泄露资源"><a href="#条款9：利用-deconstructors-避免泄露资源" class="headerlink" title="条款9：利用 deconstructors 避免泄露资源"></a>条款9：利用 deconstructors 避免泄露资源</h2><ul><li>使用析构函数</li><li>使用智能指针</li></ul><p>当然，到了现在一般更喜欢依赖RAII来对资源进行自动管理，也更加优雅。</p><h2 id="条款10：在-constructors-内阻止资源泄露"><a href="#条款10：在-constructors-内阻止资源泄露" class="headerlink" title="条款10：在 constructors 内阻止资源泄露"></a>条款10：在 constructors 内阻止资源泄露</h2><ul><li>C++ 只会析构已构造完成的对象</li><li>对于在构造期抛出 exceptions 的对象，C++不会自动清理，所以你必须设计你的 constructors 使它们能够在那种情况下也能自我清理。</li><li>一个更好的解答是，接受条款9的忠告，将point data members所指对象视为资源，交给局部对象管理（即使用智能指针）。</li></ul><h2 id="条款11：禁止异常（exceptions）流出-destructors-之外"><a href="#条款11：禁止异常（exceptions）流出-destructors-之外" class="headerlink" title="条款11：禁止异常（exceptions）流出 destructors 之外"></a>条款11：禁止异常（exceptions）流出 destructors 之外</h2><p>两种情况下 destructor <strong>会被调用</strong>：</p><ul><li>当对象在正常状态下被销毁，也就是当它离开了它的生存空间(scope)或是被明确地删除。</li><li>当对象被 exception 处理机制——也就是 exception 传播过程中的 stk-unwinding(栈展开)机制——销毁。</li></ul><p><strong>危害</strong>：</p><ul><li>如果控制权基于 exception 的因素离开 destructor，而此时正有另一个 exception 处于作用状态，C++ 会调用 terminate 函数。此函数会将你的程序结束掉——它会立刻动手，甚至不等局部对象被销毁。</li></ul><p>全力阻止 exceptions 传出 destructors 的好处：</p><ul><li>避免 terminate 函数在 exception 传播过程的栈展开(stack-unwinding)机制中被调用。</li><li>协助确保 destructors 完成其应该完成的所有事情。</li></ul><p>换句话说，一定要保证析构函数是nonexpection的。</p><h2 id="条款12：了解“抛出一个-exception”-与-“传递一个参数”-或-“调用一个虚函数”-之间的差异"><a href="#条款12：了解“抛出一个-exception”-与-“传递一个参数”-或-“调用一个虚函数”-之间的差异" class="headerlink" title="条款12：了解“抛出一个 exception” 与 “传递一个参数” 或 “调用一个虚函数” 之间的差异"></a>条款12：了解“抛出一个 exception” 与 “传递一个参数” 或 “调用一个虚函数” 之间的差异</h2><p>函数参数和 exceptions 的传递方式有3种:</p><ul><li>by value</li><li>by reference</li><li>by pointer</li></ul><p>区别1：当你调用一个函数，控制器最终会回到调用端（除非函数失败以至于无法返回），但是当你抛出一个 exception ，控制权不会再回到抛出端。而且一个对象被抛出作为 exception 时，总是会发生复制(copy)。</p><p>区别2：“抛出exception”比“传递参数”慢。因为“exception objects 必定会造成复制行为”这一事实，所以解释了“抛出exception”常常比“传递参数”慢。复制动作永远是以静态类型为本。</p><p>区别3：函数调用过程中将一个临时对象传递给一个 non-const reference 参数是不允许的，但是对 exceptions 则属合法。一个被抛出的对象（必为临时对象）可以简单地用 by reference 的方式捕捉，不需要以 by reference-to-const 的方式捕捉。</p><p>区别4：“抛出exception” 比 “传递函数参数”多构造一个“被抛出物”的副本（并于稍后析构），千万不要抛出一个指向局部对象的指针，因为该局部对象会在 exception 传离其 scope 时被销毁，因此 catch 子句会获得一个指向“已被销毁的对象”的指针。这正时“义务性复制(copy)规则”的设计要避免的情况。</p><p>区别5：“自变量传递”与“exception 传播”两动作有着互异的做法。</p><p>区别6：catch 子句总是依出现顺序做匹配尝试。</p><p><strong>总结</strong>：“传递对象到函数去，或是以对象调用虚函数”和“将对象抛出成为一个exception”之间，有3个主要差异</p><ul><li>exception objects 总是会被复制，如果以 by value 方式捕捉，它们甚至被复制两次。至于传递给函数参数的对象则不一定得复制。</li><li>被抛出成为 exceptions 的对象，其被允许的类型转换动作，比“被传递到函数去”的对象少。</li><li>catch 子句以其“出现于源代码的顺序”被编译器检验对比，其中第一个匹配成功者变执行；而当我们以某对象调用一个虚函数，被选中执行的是那个“与对象类型最佳吻合”的函数，不论它是不是源代码所列的第一个。</li></ul><h2 id="条款13：以-by-reference-方式捕捉-exceptions"><a href="#条款13：以-by-reference-方式捕捉-exceptions" class="headerlink" title="条款13：以 by reference 方式捕捉 exceptions"></a>条款13：以 by reference 方式捕捉 exceptions</h2><ul><li>避开 exception objects 的切割（slicing）的问题</li><li>保留捕捉标准 exceptions 的能力</li><li>约束了exception objects 需被复制的次数</li></ul><h2 id="条款14：明智运用-exception-specifications"><a href="#条款14：明智运用-exception-specifications" class="headerlink" title="条款14：明智运用 exception specifications"></a>条款14：明智运用 exception specifications</h2><p>告诉编译器函数不引发任何异常。 但是，在 std:c++14 模式下，如果函数确实引发异常，这可能会导致未定义的行为。 因此，建议使用 noexcept 运算符：</p><h2 id="条款15：了解异常处理（exception-handling）的成本"><a href="#条款15：了解异常处理（exception-handling）的成本" class="headerlink" title="条款15：了解异常处理（exception handling）的成本"></a>条款15：了解异常处理（exception handling）的成本</h2><p>只要你用上那么一个，也就是说一旦你决定捕捉 exceptions，你就得付出那样的成本。不同的编译器以不同的方法实现 try 语句块，代码大约整体膨胀 5%~10%，执行速度亦下降这个数。</p><p><strong>为了将此成本最小化，你应该避免非必要的 try 语句块</strong>。</p><h2 id="条款16：谨记-80-20-法则"><a href="#条款16：谨记-80-20-法则" class="headerlink" title="条款16：谨记 80-20 法则"></a>条款16：谨记 80-20 法则</h2><p>软件的证一性能几乎总是由其构成要素（代码）的一小部分决定。</p><h2 id="条款17：考虑使用-lazy-evaluation（缓式评估）"><a href="#条款17：考虑使用-lazy-evaluation（缓式评估）" class="headerlink" title="条款17：考虑使用 lazy evaluation（缓式评估）"></a>条款17：考虑使用 lazy evaluation（缓式评估）</h2><ul><li>Reference Counting（引用计数）：在你真正需要之前，不必着急为某物做一个副本——可避免非必要的对象复制</li><li>区分读和写：可区别 operator[]的读和写的动作</li><li>Lazy Fatching（缓式取出）：可避免非必要的数据库读取动作</li><li>Lazy Expression Evaluation（表达式缓评估）：可避免非必要的数值计算动作</li></ul><p><strong>总结</strong><br>如果你的计算是必要的，lazy evaluation 并不会为你的程序节省人和工作或任何时间。只有当“你的软件被要求执行某些计算，而那些计算其实可以避免”的情况下，lazy evaluation 才有用处。</p><h2 id="条款18：分期摊还预期的计算成本"><a href="#条款18：分期摊还预期的计算成本" class="headerlink" title="条款18：分期摊还预期的计算成本"></a>条款18：分期摊还预期的计算成本</h2><p>简单来说，就是使用缓存。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">findCubicleNumber</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>employeeName<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">typedef</span> map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> CubicleMap<span class="token punctuation">;</span>    <span class="token keyword">static</span> CubicleMap cubes<span class="token punctuation">;</span>    CubicleMap<span class="token operator">::</span>iterator it <span class="token operator">=</span> cubes<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>employeeName<span class="token punctuation">)</span>  <span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>it <span class="token operator">==</span> cubes<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> cubicle <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   <span class="token comment" spellcheck="true">// 这里逻辑处理</span>        cubes<span class="token punctuation">[</span>employeeName<span class="token punctuation">]</span> <span class="token operator">=</span> cubicle<span class="token punctuation">;</span>        <span class="token keyword">return</span> cubicle<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后一个语句返回 (*it).second 而非传统的 it-&gt;second，为什么？答案关系到STL实行的规矩。简单地说，iterator本身是对象，不是指针，所以并不能保证 -&gt; 可施行于 it 身上。但STL明确要求 . 和 * 对 iterators 必须有效，所以 (*it).second 虽然语法上笨拙，却保证能够有效运行。</p><h2 id="条款19：了解临时对象的来源"><a href="#条款19：了解临时对象的来源" class="headerlink" title="条款19：了解临时对象的来源"></a>条款19：了解临时对象的来源</h2><p>临时对象可能很耗成本，所以你应该尽可能消除它们。这本书写成的时候比较早，到现在有了std::move和移动构造，移动赋值，就转换成了左值和右值的问题。</p><h2 id="条款20：协助完成“返回值优化-RVO"><a href="#条款20：协助完成“返回值优化-RVO" class="headerlink" title="条款20：协助完成“返回值优化(RVO)"></a>条款20：协助完成“返回值优化(RVO)</h2><p>函数返回对象，背后隐藏着 constructor 和 destructor。如果是为了行为正确而不得不这么做，是可以返回一个对象的；否则就不要那么做。</p><p>有人企图采用某些方法消除 by-value的返回方式</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const</span> Rational<span class="token operator">*</span> <span class="token keyword">operator</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>Rational a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>Rational c <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>a <span class="token operator">*</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样会使得整个调用流程显得不自然，同时调用者也需要手动删除此函数返回的指针，不然会导致资源泄露。</p><p>有些人试图返回 references, 于是就有了</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//h</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//cpp</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">{</span>    Rational <span class="token function">result</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span><span class="token function">numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> rhs<span class="token punctuation">.</span><span class="token function">numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lhs<span class="token punctuation">.</span>denominator <span class="token operator">*</span> rhs<span class="token punctuation">.</span><span class="token function">denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//use</span>Rational a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>Rational c <span class="token operator">=</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这看起来似乎没有问题，但是当局部变量 result 离开了 const Rational&amp; operator* 之后，就被自动销毁了。所以 const Rational&amp; operator* 实际返回的 reference 指向的是一个不在存活的对象。</p><h2 id="条款21：利用重载技术（overload）避免隐式类型转换"><a href="#条款21：利用重载技术（overload）避免隐式类型转换" class="headerlink" title="条款21：利用重载技术（overload）避免隐式类型转换"></a>条款21：利用重载技术（overload）避免隐式类型转换</h2><p>假设我们有这么一个结构</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">UPInt</span><span class="token punctuation">{</span>    <span class="token function">UPInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">UPInt</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>UPInt <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> UPInt<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> UPInt<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当我们调用</p><pre class="line-numbers language-cpp"><code class="language-cpp">UPInt upi1<span class="token punctuation">,</span> upi2<span class="token punctuation">,</span> upi3<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>upi3 <span class="token operator">=</span> upi1 <span class="token operator">+</span> upi2<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 成功，调用了 UPInt operator+(const UPInt&amp; lhs, const UPInt&amp; rhs);</span>upi3 <span class="token operator">=</span> upi1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 成功，生成了临时对象</span>upi3 <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> upi1<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 成功，生成了临时对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 upi1 + 1 与 1 + upi1 都会进行隐式类型转换，这里会有一点成本。为了避免隐式类型转换带来的开销，我们可以重载 UPInt operator+ 这个函数</p><pre class="line-numbers language-cpp"><code class="language-cpp">UPInt <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> UPInt<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>UPInt <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> UPInt<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>来消除类型转换。但是我们不能狂热过度写出下面的函数</p><blockquote><p>UPInt operator+(const int lhs, const int rhs);</p></blockquote><p>这会导致可怕的灾难。</p><h2 id="条款22：考虑以操作符符合形式（op-）取代其独身形式（op）"><a href="#条款22：考虑以操作符符合形式（op-）取代其独身形式（op）" class="headerlink" title="条款22：考虑以操作符符合形式（op=）取代其独身形式（op）"></a>条款22：考虑以操作符符合形式（op=）取代其独身形式（op）</h2><p>到目前为止 C++ 并不考虑在 operator+，operator= 和 operator+= 之间设立任何互动关系。如果你希望这三个操作符都存在并且有着你所期望的互动关系，你必须自己实现。</p><p><strong>三个于效率有关的情况需要注意</strong></p><ol><li>一般而言，符合操作符比起对应的独身版本效率高，因为独身版通常必须返回一个新对象，而我们必须因此负担一个临时对象的构造成本和析构成本。至于复合版本则是直接将结果写入其左端自变量，所以不需要产生一个临时对象来放置返回值。</li><li>如果同提供某个操作符的复合形式和独身形式，便允许你的客户在效率与便利性之间做取舍。</li></ol><p>下面的两个例子中，第二个虽然更容易理解，但是却比第一个多构造了一个临时对象。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//Good</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">const</span> T <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">T</span><span class="token punctuation">(</span>lhs<span class="token punctuation">)</span> <span class="token operator">+</span> rhs<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Not Good</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">const</span> T <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">{</span>     T <span class="token function">result</span><span class="token punctuation">(</span>lhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result <span class="token operator">+</span><span class="token operator">=</span> rhs<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>身为一位程序库设计者，你应该为两者都提供。</p><h2 id="条款23：考虑使用其他程序库"><a href="#条款23：考虑使用其他程序库" class="headerlink" title="条款23：考虑使用其他程序库"></a>条款23：考虑使用其他程序库</h2><p>由于不同的程序库将效率、扩充性、移植性、类型安全性等的不同设计具体化，有时候你可以找找看是否存在另一个功能相近的程序库而其在效率上有较高的设计权重。</p><h2 id="条款24：了解虚函数、多重继承、虚基类和运行类型的成本"><a href="#条款24：了解虚函数、多重继承、虚基类和运行类型的成本" class="headerlink" title="条款24：了解虚函数、多重继承、虚基类和运行类型的成本"></a>条款24：了解虚函数、多重继承、虚基类和运行类型的成本</h2><ol><li>虚函数<br>当一个虚函数被调用，执行的代码必须对应于“调用者（对象）的动态类型”。大部分编译器使用所谓的 virtual tables 和 virtual table pointers —— 此二者通常被简写为 vtabls 和 vptrs。</li></ol><p><strong>虚函数成本：</strong></p><ul><li>你必须为每个拥有虚函数的 class 耗费一个 vtable 空间，其大小视虚函数的个数（包括继承而来的）而定。</li><li>你必须在每一个拥有虚函数的对象内付出“一个额外指针”的代价。调用一个虚函数的成本，基本上和”通过一个函数指针来调用函数“相同。虚函数本身并不构成性能上的瓶颈。</li><li>你事实上废弃了 inlining。虚函数不应该 inlined。因为 inline 意味“在编译期，将调用端的调用动作被调用函数的函数本身取代”，而 virtual 则意味着“等待，知道运行时期才知道哪个函数被调用”。</li></ul><ol start="2"><li><p>多重继承<br>多重继承问我导致 virtual base classes（虚拟基类）的需求。<br>在 non-virtual base class 的情况下，如果 derived class 在其 base class 有多条继承路径，则此 base class 的 data members 会在每一个 derived class object 体内复制滋生，每一个副本对应 “derived class 和 base class 之间的一条继承路线”。</p></li><li><p>虚拟继承<br>让base class 成为 virtual，可以消除这样的复制现象，<a href="https://blog.csdn.net/qq_45615577/article/details/115345490">学习资料</a>。</p></li><li><p>RTTI<br><a href="https://zhuanlan.zhihu.com/p/509453699">RTTI</a> 让我们得以在运行时获得 objects 和 classes 的相关信息，他们被存发在类型为 type_info 的对象内。一个 class 只需要一份 RTTI 信息就好，但是必须有某种办法让其下属的每个对象都能取用它。只有当某种类型拥有至少一个虚函数，才保证我们能够检验该类型对象的动态类型。</p></li></ol><table><thead><tr><th>性质</th><th>对象大小增加</th><th>Class数据量增加</th><th>Inlining 几率低</th></tr></thead><tbody><tr><td>虚函数 Virtual Functions</td><td>是</td><td>是</td><td>是</td></tr><tr><td>多重继承Multiple Inheritance</td><td>是</td><td>是</td><td>否</td></tr><tr><td>虚拟基类 Virtual Base Classes</td><td>往往如此</td><td>有时候</td><td>否</td></tr><tr><td>运行时期类型辨识</td><td>RTTI</td><td>否</td><td>是</td></tr></tbody></table><h2 id="条款25：将-constructor-和-non-member-functions-虚化"><a href="#条款25：将-constructor-和-non-member-functions-虚化" class="headerlink" title="条款25：将 constructor 和 non-member functions 虚化"></a>条款25：将 constructor 和 non-member functions 虚化</h2><p>constructor 虚化其实不是真正的虚化构造函数，书中所讲不是很好理解，可以参考下面的例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Shape</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>                 <span class="token comment" spellcheck="true">// A virtual destructor</span>  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// A pure virtual function</span>  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">move</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// ...</span>  <span class="token keyword">virtual</span> Shape<span class="token operator">*</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// Uses the copy constructor</span>  <span class="token keyword">virtual</span> Shape<span class="token operator">*</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// Uses the default constructor</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Circle</span> <span class="token operator">:</span> <span class="token keyword">public</span> Shape <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  Circle<span class="token operator">*</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">const</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// Covariant Return Types; see below</span>  Circle<span class="token operator">*</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// Covariant Return Types; see below</span>  <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Circle<span class="token operator">*</span> Circle<span class="token operator">::</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">Circle</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>Circle<span class="token operator">*</span> Circle<span class="token operator">::</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">Circle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过调用 clone() 或 create()虚函数来间接地调用构造函数与拷贝构造。即虚假的构造函数与真正的构造函数。</p><p>而至于non-member functions 的虚化十分容易：写一个虚函数做实际工作，再写一个什么都不做的非虚函数，只负责调用虚函数。</p><h2 id="条款26：限制某个class所能产生的对象数量"><a href="#条款26：限制某个class所能产生的对象数量" class="headerlink" title="条款26：限制某个class所能产生的对象数量"></a>条款26：限制某个class所能产生的对象数量</h2><h3 id="1-允许零个或一个对象"><a href="#1-允许零个或一个对象" class="headerlink" title="1.允许零个或一个对象"></a>1.允许零个或一个对象</h3><h4 id="1-1-零个对象"><a href="#1-1-零个对象" class="headerlink" title="1.1.零个对象"></a>1.1.零个对象</h4><p>每当即将产生一个对象，就会有一个 <code>constructor</code> 被调用。阻止某个 <code>class</code> 产出对象的最简单方法就是将其 <code>constructors</code> 声明为 <code>private</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">CantBeInstantiated</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token function">CatBeInstantiated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">CantBeInstantiated</span><span class="token punctuation">(</span><span class="token keyword">const</span> CantBeInstantiated<span class="token operator">&amp;</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-封装对象在函数内"><a href="#1-2-封装对象在函数内" class="headerlink" title="1.2.封装对象在函数内"></a>1.2.封装对象在函数内</h4><p>我们可以将对象封装在某个函数内，如此一来只有唯一一个对象被产生.<br>接下使用打印机的例子来说明。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">PrintJob</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Printer</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">submitJob</span><span class="token punctuation">(</span><span class="token keyword">const</span> PrintJob<span class="token operator">&amp;</span> job<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">performSelfTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">friend</span> Printer<span class="token operator">&amp;</span> <span class="token function">thePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token keyword">const</span> Printer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Printer<span class="token operator">&amp;</span> <span class="token function">thePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> Printer p<span class="token punctuation">;</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//唯一一个打印机对象</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里有三个点值得注意</p><ul><li><code>Printer class</code> 的 <code>constructors</code> 属性 <code>private</code>，可以压制对象的诞生。</li><li>全局函数 <code>thePrinter</code> 被声明在此 <code>class</code> 的一个 <code>friend</code>，致使 <code>thePrinter</code> 不受 <code>private constructors</code> 的约束。</li><li><code>thePrinter</code> 内含一个 <code>static Printer</code> 对象，意思只有一个 <code>Printer</code> 对象被产生出来。</li></ul><p>在使用的时候，只需要调用 <code>thePrinter().</code> 就可以</p><h4 id="1-2-消除firend"><a href="#1-2-消除firend" class="headerlink" title="1.2.消除firend"></a>1.2.消除<code>firend</code></h4><p>以上方的例子为例，我们可以让 <code>thePrinter</code> 成为 <code>Printer</code> 的一个 <code>static member function</code>，消除 <code>friend</code> 的必要性。我们就能获得接下来的代码</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Printer</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">static</span> Printer<span class="token operator">&amp;</span> <span class="token function">thePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token keyword">const</span> Printer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Printer<span class="token operator">&amp;</span> Printer<span class="token operator">::</span><span class="token function">thePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> Printer p<span class="token punctuation">;</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在用户调用 <code>Printer</code>时，会显得冗长</p><pre class="line-numbers language-cpp"><code class="language-cpp">Printer<span class="token operator">::</span><span class="token function">thePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="1-3-使用namespace"><a href="#1-3-使用namespace" class="headerlink" title="1.3.使用namespace"></a>1.3.使用<code>namespace</code></h4><p>另一个做法是把 <code>Printer</code> 和 <code>thePrinter</code> 从全局空间移走，放进一个 <code>namespace</code> 内。我们就可以得到以下代码</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">namespace</span> PrintingStuff<span class="token punctuation">{</span>    <span class="token keyword">class</span> <span class="token class-name">Printer</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">//这个class 位于 PrintingStuff namespace 内</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token keyword">void</span> <span class="token function">submitJob</span><span class="token punctuation">(</span><span class="token keyword">const</span> PrintJob<span class="token operator">&amp;</span> job<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token function">performSelfTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">friend</span> Printer<span class="token operator">&amp;</span> <span class="token function">thePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token keyword">const</span> Printer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    Printer<span class="token operator">&amp;</span> <span class="token function">thePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   这个函数也位于 PrintingStuff <span class="token keyword">namespace</span> 内    <span class="token punctuation">{</span>        <span class="token keyword">static</span> Printer p<span class="token punctuation">;</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//唯一一个打印机对象</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了这个 <code>namespace</code>，用户就能使用完全限定名来取用 <code>thePrinter</code>:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> PrintingStuff<span class="token operator">::</span>theprinter<span class="token punctuation">;</span><span class="token function">thePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在此代码实现中，又两个精细的地方值得探讨。</p><ul><li>形成唯一一个 <code>Printer</code> 对象的，是函数中的 <code>static</code> 对象，而非 <code>class</code> 中的 <code>static</code> 对象。<br>C++ 的一个设计哲学基础是你不应该为你并不使用的东西付出任何代价。<br><code>function static</code>的初始时机：在该函数第一次被调用时。<br><code>class static</code> 则不一定在什么时候初始化。</li><li>函数的 <code>static</code> 对象与 <code>inlining</code> 的互动。</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp">Printer<span class="token operator">&amp;</span> <span class="token function">thePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">static</span> Printer p<span class="token punctuation">;</span> <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果上方的函数被声明为 <code>inline</code>，那么你的程序可能会拥有多份该 <code>static</code> 对象的副本。因为 <code>inline</code> 意味着编译器应该将每一个调用动作以函数本身取代。<br>千万不要产生内含 <code>local static</code> 对象的 <code>inline non-member functions</code>。</p><h4 id="1-4-使用抛出异常提示产生了过多的对象"><a href="#1-4-使用抛出异常提示产生了过多的对象" class="headerlink" title="1.4.使用抛出异常提示产生了过多的对象"></a>1.4.使用抛出异常提示产生了过多的对象</h4><p>我们继续改进我们的 <code>Printer</code>,给定一个函数来抛出一个类型为 <code>TooManyObjects</code> 的 <code>exception</code></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Printer</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">class</span> <span class="token class-name">TooManyObjects</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">static</span> size_t numberObjects<span class="token punctuation">;</span>    <span class="token function">Printer</span><span class="token punctuation">(</span>cosnt Printer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//我们限制只有一个打印机，所以绝不允许复制行为，所以放在private区</span><span class="token punctuation">}</span>size_t Printer<span class="token operator">::</span>numberObjects <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>Printer<span class="token operator">::</span><span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>numObjects <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token function">TooManyObjects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 这里处理一般的构造</span>    <span class="token operator">++</span>numObjects<span class="token punctuation">;</span><span class="token punctuation">}</span>Printer<span class="token operator">::</span><span class="token operator">~</span><span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 这里处理析构</span>    <span class="token operator">--</span>numObjects<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个非常简单直观。</p><h3 id="2-不同的对象构造状态"><a href="#2-不同的对象构造状态" class="headerlink" title="2.不同的对象构造状态"></a>2.不同的对象构造状态</h3><h4 id="2-1-继承问题"><a href="#2-1-继承问题" class="headerlink" title="2.1.继承问题"></a>2.1.继承问题</h4><p>假设我们有一台彩色打印机</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">ColorPrinter</span><span class="token operator">:</span> <span class="token keyword">public</span> Printer<span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当我们调用下面的代码时</p><pre class="line-numbers language-cpp"><code class="language-cpp">Printer p<span class="token punctuation">;</span>ColorPrinter cp<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们其实构造了两个Printer对象，这个时候就会有 <code>TooManyObjects exception</code> 被抛出。</p><h4 id="2-2-对象包含问题"><a href="#2-2-对象包含问题" class="headerlink" title="2.2.对象包含问题"></a>2.2.对象包含问题</h4><p>当我们有对象包含<code>Printer</code>时，就会出现这样的代码</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Machine</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//这是一个机器，处理打印、传真等功能</span><span class="token keyword">private</span><span class="token operator">:</span>    Printer p<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 针对打印功能</span>    FaxMachine f<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 针对传真功能</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 这里调用</span>Machine m1<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 没有问题</span>Machine m2<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 抛出 TooManyObjects exception</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，当我们构造 <code>m2</code> 的时候，就出现问题了，因为此时 <code>Printer</code> 对象位于较大对象当中</p><h4 id="2-3-阻止继承"><a href="#2-3-阻止继承" class="headerlink" title="2.3.阻止继承"></a>2.3.阻止继承</h4><p>为了阻止上述的继承导致的问题，我们可以通过把 <code>constructors</code> 变为 <code>private</code> 来实现禁止派生。</p><h3 id="3-允许对象生生灭灭"><a href="#3-允许对象生生灭灭" class="headerlink" title="3.允许对象生生灭灭"></a>3.允许对象生生灭灭</h3><p>到这里我们已经能得到一个较好的版本了，可以限制对象生成的数量。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Printer</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">class</span> <span class="token class-name">TooManyObjects</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> Printer <span class="token operator">*</span><span class="token function">MakePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">submitJob</span><span class="token punctuation">(</span>cibst PrintJob <span class="token operator">&amp;</span>job<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这里是一些外部调用的接口</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">static</span> size_t<span class="token operator">::</span>numObjects<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 用于记录已经生成的Printer对象</span>    <span class="token keyword">const</span> size_t Printer<span class="token operator">::</span>maxObject <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 用于限制最大的对象数量</span>    <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                              <span class="token comment" spellcheck="true">// 我们不允许继承，所以放置再private区</span>    <span class="token function">Printer</span><span class="token punctuation">(</span>cosnt Printer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 我们不允许直接调用拷贝构造，所以放在private区</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>Printer<span class="token operator">::</span><span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>numObjects <span class="token operator">>=</span> maxObjects<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token function">TooManyObjects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 这里处理一般的构造</span>    <span class="token operator">++</span>numObjects<span class="token punctuation">;</span><span class="token punctuation">}</span>Printer<span class="token operator">::</span><span class="token function">Printer</span><span class="token punctuation">(</span>cosnt Printer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 这里处理和默认构造函数一致</span><span class="token punctuation">}</span>Printer<span class="token operator">::</span><span class="token operator">~</span><span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 这里处理析构</span>    <span class="token operator">--</span>numObjects<span class="token punctuation">;</span><span class="token punctuation">}</span>Printer <span class="token operator">*</span>Printer<span class="token operator">::</span><span class="token function">makePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">new</span> Printer<span class="token punctuation">;</span> <span class="token punctuation">}</span>Printer <span class="token operator">*</span>Printer<span class="token operator">::</span><span class="token function">MakePrinter</span><span class="token punctuation">(</span><span class="token keyword">const</span> Printer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">Printer</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-一个用来计算对象个数的-Base-Class"><a href="#4-一个用来计算对象个数的-Base-Class" class="headerlink" title="4.一个用来计算对象个数的 Base Class"></a>4.一个用来计算对象个数的 <code>Base Class</code></h3><p>接下来我们使用 <code>template</code> 来实现</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">BeingCounted</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Counted</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">class</span> <span class="token class-name">TooManyObjects</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">objectCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> numObjects<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token function">Counted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Counted</span><span class="token punctuation">(</span><span class="token keyword">const</span> Counted <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">Counted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">--</span>numObjects<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> numObjects<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> size_t maxObjects<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 用以避免 ctor 码重复出现</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">BeingCounted</span><span class="token operator">></span>Counted<span class="token operator">&lt;</span>BeingCounted<span class="token operator">></span><span class="token operator">::</span><span class="token function">Counted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">BeingCounted</span><span class="token operator">></span>Counted<span class="token operator">&lt;</span>BeingCounted<span class="token operator">></span><span class="token operator">::</span><span class="token function">Counted</span><span class="token punctuation">(</span><span class="token keyword">const</span> Counted<span class="token operator">&lt;</span>BeingCounted<span class="token operator">></span><span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">BeingCounted</span><span class="token operator">></span><span class="token keyword">void</span> Counted<span class="token operator">&lt;</span>BeingCounted<span class="token operator">></span><span class="token operator">::</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>numObjects <span class="token operator">>=</span> maxObjects<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token function">TooManyObjects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">++</span>numObjects<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 下面我们要使用上面的模板，实现一个只能构造 10 个对象的打印机</span><span class="token keyword">const</span> size_t Counted<span class="token operator">&lt;</span>Printer<span class="token operator">></span><span class="token operator">::</span>maxObjects <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Printer</span> <span class="token operator">:</span> <span class="token keyword">private</span> Counted<span class="token operator">&lt;</span>Printer<span class="token operator">></span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">// pseudo-constructors</span>    <span class="token keyword">static</span> Printer <span class="token operator">*</span><span class="token function">makePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> Printer <span class="token operator">*</span><span class="token function">makePrinter</span><span class="token punctuation">(</span><span class="token keyword">const</span> Printer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>    <span class="token operator">~</span><span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">submitJob</span><span class="token punctuation">(</span><span class="token keyword">const</span> PrintJob<span class="token operator">&amp;</span> job<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">performSelfTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">using</span> Counted<span class="token operator">&lt;</span>Printer<span class="token operator">></span><span class="token operator">::</span>objectCount<span class="token punctuation">;</span>    <span class="token keyword">using</span> Counted<span class="token operator">&lt;</span>Printer<span class="token operator">></span><span class="token operator">::</span>TooManyObjects<span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token keyword">const</span> Printer <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="条款27：要求（或禁止）对象产生于-heap-中"><a href="#条款27：要求（或禁止）对象产生于-heap-中" class="headerlink" title="条款27：要求（或禁止）对象产生于 heap 中"></a>条款27：要求（或禁止）对象产生于 heap 中</h2><h3 id="要求对象产生于-heap-之中（Heap-Based-Objects）"><a href="#要求对象产生于-heap-之中（Heap-Based-Objects）" class="headerlink" title="要求对象产生于 heap 之中（Heap-Based Objects）"></a>要求对象产生于 <code>heap 之中</code>（<code>Heap-Based Objects</code>）</h3><p>只要限制 <code>destructor</code> 或 <code>constructors</code> 的运用，便可阻止 <code>non-heap object</code> 的诞生。但是他同时也妨碍了继承（<code>inheritance</code>）和包含（<code>containment</code>）</p><h3 id="禁止对象产生于-heap-中"><a href="#禁止对象产生于-heap-中" class="headerlink" title="禁止对象产生于 heap 中"></a>禁止对象产生于 <code>heap</code> 中</h3><p>首先我们需要知道有三种情况下，对象可能被产生于 <code>heap</code> 中</p><ol><li>对象被直接实例化</li><li>对象被实例化为 <code>derived class objects</code> 内的 “base class 成分”</li><li>对象被内嵌于其他对象之中</li></ol><p>简单来说，可以直接设置 <code>operator new</code> 和 <code>operator delete</code> 为 <code>private</code> 即可</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">UPNumber</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你也像禁止“由 <code>UPNumber</code> 对象所组成的数组” 位于 <code>heap</code> 内，可以将 <code>operator new[]</code> 和 <code>operator delete[]</code> 亦声明为 <code>private</code>。当然现在更推荐直接delete掉。</p><h2 id="条款28：Smart-Pointers（智能指针）"><a href="#条款28：Smart-Pointers（智能指针）" class="headerlink" title="条款28：Smart Pointers（智能指针）"></a>条款28：Smart Pointers（智能指针）</h2><p>这里的智能指针比较早，包括了auto_ptr，可以单独了解，本书内容有点过时了。</p><h2 id="条款29：Reference-counting（引用计数）"><a href="#条款29：Reference-counting（引用计数）" class="headerlink" title="条款29：Reference counting（引用计数）"></a>条款29：Reference counting（引用计数）</h2><p>总体意思需要结合上一个条款中谈到的 <code>smart ptr</code> 来实现引用计数。有几个方面需要考虑</p><ul><li>需要有一个结构体即存储引用次数，也要存储数据</li><li>上述需要生成在堆中，通过指针访问地址</li><li>正确且自动处理引用增加及减少情况<ul><li>构造函数（包括拷贝构造等）</li><li>析构函数</li><li>赋值</li></ul></li><li>修改对象数据时需要调整引用及分享权限（也就是 <code>copy on write</code>）</li><li>避免内存泄漏</li></ul><h2 id="条款30：Proxy-classes（替身类、代理类）"><a href="#条款30：Proxy-classes（替身类、代理类）" class="headerlink" title="条款30：Proxy classes（替身类、代理类）"></a>条款30：Proxy classes（替身类、代理类）</h2><p>简单来说，如果我们有一个 <code>string a = &quot;123&quot;;</code> 此时我们想用 <code>a[0]</code> 取得 <code>&#39;1&#39;</code>。然而我们这里取得<code>&#39;1&#39;</code>之后，我们会有以下一种行为</p><ol><li>只读，此时我们不需要修改 <code>reference count</code></li><li>写入，此时我们需要修改 <code>reference count</code></li></ol><p>所以我们这里返回的时候可以不返回一个 <code>char</code> 而是返回一个结构体，且只要这个结构体能够转换为<code>char</code>就行了。这个和之前所讲的 条款17：缓式评估 有相同的实现思路，可以折回去参考一下。</p><h2 id="条款31：让函数根据一个以上的对象类型来决定如何虚化"><a href="#条款31：让函数根据一个以上的对象类型来决定如何虚化" class="headerlink" title="条款31：让函数根据一个以上的对象类型来决定如何虚化"></a>条款31：让函数根据一个以上的对象类型来决定如何虚化</h2><p>这里指出了一个情况，例如我们有三种物体，且都继承<code>GameObject</code></p><ul><li><code>SpaceShip</code> 飞船</li><li><code>SpaceStation</code> 空间站</li><li><code>Asteroid</code> 陨石</li></ul><p>不同的物体会相撞，且会产生不同的结果。例如飞船和空间站相撞，飞船能进入到空间站内；飞船和陨石相撞，两者都会摧毁。<br>这个时候，我们需要一个方法，传入任意俩个<code>GameObject</code>都可以处理。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">processCollision</span><span class="token punctuation">(</span>GameObject<span class="token operator">&amp;</span> object1<span class="token punctuation">,</span> GameObject<span class="token operator">&amp;</span> object2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>书中讨论了一套方法，是一个不错的方法，但是感觉还不是很完美。目前就整理一下代码，记录下来。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;map></span></span><span class="token keyword">class</span> <span class="token class-name">GameObject</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">GameObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//基类里面有虚函数，派生类继承后，使用typeid().name才能取得对应的class name</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">SpaceShip</span> <span class="token operator">:</span> <span class="token keyword">public</span> GameObject <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">SpaceStation</span> <span class="token operator">:</span> <span class="token keyword">public</span> GameObject <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Asteroid</span> <span class="token operator">:</span> <span class="token keyword">public</span> GameObject <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//匿名namespace</span><span class="token keyword">namespace</span> <span class="token punctuation">{</span>    <span class="token keyword">using</span> std<span class="token operator">::</span>string<span class="token punctuation">;</span>    <span class="token keyword">using</span> std<span class="token operator">::</span>map<span class="token punctuation">;</span>    <span class="token keyword">using</span> std<span class="token operator">::</span>make_pair<span class="token punctuation">;</span>    <span class="token keyword">using</span> std<span class="token operator">::</span>pair<span class="token punctuation">;</span>    <span class="token keyword">using</span> std<span class="token operator">::</span>cout<span class="token punctuation">;</span>    <span class="token keyword">using</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">shipAsteroid</span><span class="token punctuation">(</span>GameObject<span class="token operator">&amp;</span> spaceShip<span class="token punctuation">,</span> GameObject<span class="token operator">&amp;</span> asteroid<span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"spaceShip collide with asteroid"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">shipStation</span><span class="token punctuation">(</span>GameObject<span class="token operator">&amp;</span> spaceShip<span class="token punctuation">,</span> GameObject<span class="token operator">&amp;</span> spaceStation<span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"spaceShip collide with spaceStation"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">asteroidStation</span><span class="token punctuation">(</span>GameObject<span class="token operator">&amp;</span> asteroid<span class="token punctuation">,</span> GameObject<span class="token operator">&amp;</span> spaceStation<span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"asteroid collide with spaceStation"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">asteroidShip</span><span class="token punctuation">(</span>GameObject<span class="token operator">&amp;</span> asteroid<span class="token punctuation">,</span> GameObject<span class="token operator">&amp;</span> spaceShip<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">shipAsteroid</span><span class="token punctuation">(</span>spaceShip<span class="token punctuation">,</span> asteroid<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">stationShip</span><span class="token punctuation">(</span>GameObject<span class="token operator">&amp;</span> spaceStation<span class="token punctuation">,</span> GameObject<span class="token operator">&amp;</span> spaceShip<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">shipStation</span><span class="token punctuation">(</span>spaceShip<span class="token punctuation">,</span> spaceStation<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">stationAsteroid</span><span class="token punctuation">(</span>GameObject<span class="token operator">&amp;</span> spaceStation<span class="token punctuation">,</span> GameObject<span class="token operator">&amp;</span> asteroid<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">asteroidStation</span><span class="token punctuation">(</span>asteroid<span class="token punctuation">,</span> spaceStation<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//碰撞map</span><span class="token keyword">class</span> <span class="token class-name">CollisionMap</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">//这里使用单例</span>    <span class="token keyword">static</span> CollisionMap<span class="token operator">*</span> <span class="token function">theCollisionMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">static</span> CollisionMap CM<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">&amp;</span>CM<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>HitFunctionPtr<span class="token punctuation">)</span><span class="token punctuation">(</span>GameObject<span class="token operator">&amp;</span><span class="token punctuation">,</span> GameObject<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//这里添加新的碰撞处理函数，成对处理</span>    <span class="token keyword">void</span> <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> type1<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> type2<span class="token punctuation">,</span> HitFunctionPtr collisionFunction<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>collisionMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">make_pair</span><span class="token punctuation">(</span>type1<span class="token punctuation">,</span> type2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> collisionMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//成对添加</span>        collisionMap<span class="token punctuation">[</span>std<span class="token operator">::</span><span class="token function">make_pair</span><span class="token punctuation">(</span>type1<span class="token punctuation">,</span> type2<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> collisionFunction<span class="token punctuation">;</span>        collisionMap<span class="token punctuation">[</span>std<span class="token operator">::</span><span class="token function">make_pair</span><span class="token punctuation">(</span>type2<span class="token punctuation">,</span> type1<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> collisionFunction<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//这里移除碰撞函数</span>    <span class="token keyword">void</span> <span class="token function">removeEntry</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> type1<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> type2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>collisionMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">make_pair</span><span class="token punctuation">(</span>type1<span class="token punctuation">,</span> type2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> collisionMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//成对移除</span>        collisionMap<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">make_pair</span><span class="token punctuation">(</span>type1<span class="token punctuation">,</span> type2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        collisionMap<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">make_pair</span><span class="token punctuation">(</span>type2<span class="token punctuation">,</span> type1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//查找有没有对应的碰撞函数</span>    HitFunctionPtr <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> class1<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> class2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        HitMap<span class="token operator">::</span>iterator it <span class="token operator">=</span> collisionMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span>class1<span class="token punctuation">,</span> class2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>it <span class="token operator">==</span> collisionMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> map<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> string<span class="token operator">></span><span class="token punctuation">,</span> HitFunctionPtr<span class="token operator">></span> HitMap<span class="token punctuation">;</span>    HitMap collisionMap<span class="token punctuation">;</span>    <span class="token function">CollisionMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">initializeCollisionMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">CollisionMap</span><span class="token punctuation">(</span><span class="token keyword">const</span> CollisionMap<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这里可以内部初始化，也可以改为一个函数，来注册一下函数</span>    <span class="token keyword">void</span> <span class="token function">initializeCollisionMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        collisionMap<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token string">"class SpaceShip"</span><span class="token punctuation">,</span> <span class="token string">"class Asteroid"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>shipAsteroid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token string">"class SpaceShip"</span><span class="token punctuation">,</span> <span class="token string">"class SpaceStation"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>shipStation<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// ...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//匿名namespace</span><span class="token keyword">namespace</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//这里处理碰撞，会查找碰撞map，如果有函数就执行，没有的话就抛出异常</span>    <span class="token keyword">void</span> <span class="token function">processCollision</span><span class="token punctuation">(</span>GameObject<span class="token operator">&amp;</span> object1<span class="token punctuation">,</span> GameObject<span class="token operator">&amp;</span> object2<span class="token punctuation">)</span> <span class="token punctuation">{</span>          CollisionMap<span class="token operator">*</span> CM <span class="token operator">=</span> CollisionMap<span class="token operator">::</span><span class="token function">theCollisionMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        CollisionMap<span class="token operator">::</span>HitFunctionPtr phf <span class="token operator">=</span> CM<span class="token operator">-</span><span class="token operator">></span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">typeid</span><span class="token punctuation">(</span>object1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>object2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>phf<span class="token punctuation">)</span> <span class="token function">phf</span><span class="token punctuation">(</span>object1<span class="token punctuation">,</span> object2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"UnkowCollision! "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>object1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" - "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>object2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    SpaceShip spaceShip<span class="token punctuation">;</span>    Asteroid asteroid<span class="token punctuation">;</span>    SpaceStation spaceStation<span class="token punctuation">;</span>    <span class="token function">processCollision</span><span class="token punctuation">(</span>spaceShip<span class="token punctuation">,</span> asteroid<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//spaceShip collide with asteroid</span>    <span class="token function">processCollision</span><span class="token punctuation">(</span>asteroid<span class="token punctuation">,</span> spaceShip<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//UnkowCollision! class Asteroid - class SpaceShip</span>    <span class="token function">processCollision</span><span class="token punctuation">(</span>spaceShip<span class="token punctuation">,</span> spaceStation<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//spaceShip collide with spaceStation</span>    <span class="token function">processCollision</span><span class="token punctuation">(</span>asteroid<span class="token punctuation">,</span> spaceStation<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//UnkowCollision! class Asteroid - class SpaceStation</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="条款32：在未来时态下发展程序"><a href="#条款32：在未来时态下发展程序" class="headerlink" title="条款32：在未来时态下发展程序"></a>条款32：在未来时态下发展程序</h2><p>对于未来式思维，作者希望我们多考虑一些东西：</p><ul><li>提供玩真的<code>class</code> —— 即使某些部分目前用不到。当心的需求进来，你不太需要回头去修改那些 <code>classes</code>。</li><li>设计你的接口，使有利于共同的操作行为，阻止共同的错误。让这些 <code>classes</code> 轻易地被正确运用，难以被错误运用。</li><li>尽量使你都代码一般化（泛化），除非有不良的巨大后果。</li></ul><p>但是注意在之前的effective c++中提到的，过早优化是性能恶化之源。</p><h2 id="条款33：将非尾端类-non-leaf-classes-设计为-抽象类-abstract-classes"><a href="#条款33：将非尾端类-non-leaf-classes-设计为-抽象类-abstract-classes" class="headerlink" title="条款33：将非尾端类(non-leaf classes) 设计为 抽象类(abstract classes)"></a>条款33：将非尾端类(non-leaf classes) 设计为 抽象类(abstract classes)</h2><p>继承体系中的 <code>non-leaf</code>(非尾端)类应该使抽象类。如果 使用外界供应的程序库，你或许可以对其法则做点变通；单如果代码完全在你掌控之下，坚持这个法则，可以为你带来许多好处，并提升整个软件的可靠度、健壮度、精巧度、扩充度。</p><p>当然了，现在的设计思路一般都是组合优于继承，继承能干的组合就能够解决。</p><h2 id="条款34：如何在同一程序中结合-C-和-C"><a href="#条款34：如何在同一程序中结合-C-和-C" class="headerlink" title="条款34：如何在同一程序中结合 C++ 和 C"></a>条款34：如何在同一程序中结合 C++ 和 C</h2><ul><li><code>Name Mangling</code>(名命重整)</li><li><code>Statics</code> 的初始化</li><li>动态内存分配</li><li>数据结构的兼容性</li></ul><p>并指明了以下守则</p><ul><li>确定你的 C++ 和 C 编译器产出兼容的目标文件(<code>object files</code>)。</li><li>将双方都使用的函数声明为 <code>extern &quot;C&quot;</code>。</li><li>如果可能，尽可能在 C++ 中撰写 <code>main</code>。</li><li>总是以 <code>delete</code> 删除 <code>new</code> 返回的内存：总是以 <code>free</code> 释放 <code>malloc</code> 放回的内存。</li><li>将两个语言间的“数据结构传递”限制于 C 所能了解的形式；C++ <code>structs</code> 如果内含非虚函数，但是不受此限。</li></ul><h2 id="条款35：让自己习惯于标准-C-语言"><a href="#条款35：让自己习惯于标准-C-语言" class="headerlink" title="条款35：让自己习惯于标准 C++ 语言"></a>条款35：让自己习惯于标准 C++ 语言</h2><p>拥抱新的c++标准。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;虽然早在4年前的大二时期就看过并且实践在工程作业里面，但一直没有一个完整的记录，想着别的几本都有了干脆补全一下吧，个人总结，难免会出现一些不
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Cpp工程实践必备技能</title>
    <link href="https://joytsing.github.io/posts/23555/"/>
    <id>https://joytsing.github.io/posts/23555/</id>
    <published>2024-03-06T08:24:58.000Z</published>
    <updated>2024-03-06T09:08:17.677Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本科时候质疑CMAKE，后面理解CMAKE,加入CMAKE。言归正传，之前不喜欢用clion的原因，一是因为clion每次使用的时候启动慢，加上卡，其次是那会真不会CMAKE，而clion是强制用，然后后面就选择用vs去了，到现在大部分时间都在linux下写代码，慢慢开始熟悉CMAKE，突然有点感慨，遇到这么多人大部分人还停留在学校用vs教个基础语法的阶段，modern cpp不了解，cmake更是不知道。</p><p>接下来会对现代工程进行一个初步介绍，对单元测试框架以及benchmark框架的引入和使用进行个预览。</p><h2 id="CMAKE"><a href="#CMAKE" class="headerlink" title="CMAKE"></a>CMAKE</h2><p>首先是CMAKE，CMAKE写不好你都不要想着启动程序（迫真），目前来说，我觉得CMAKE不需要完全像一门编程语言一样能够熟悉到默写，只要能够看懂仿写我觉得就足够了。目前来说比较优秀的资料有这两个，两者都是类似讲座的形式，对现代CMAKE进行个粗略的介绍：<a href="https://www.bilibili.com/video/BV1nu411u7rb/?spm_id_from=333.999.0.0">一个半小时入门现代CMake</a>，<a href="https://www.bilibili.com/video/BV16P4y1g7MH/?spm_id_from=333.999.0.0&vd_source=698e8d6597cbbceb9e4ea1aa22057b46">现代CMake高级教程</a>, <a href="https://www.bilibili.com/video/BV1V84y117YU/?spm_id_from=333.999.0.0&vd_source=698e8d6597cbbceb9e4ea1aa22057b46">现代CMake模块化项目管理指南</a>大概就能了解个差不多了。</p><h2 id="单元测试框架"><a href="#单元测试框架" class="headerlink" title="单元测试框架"></a>单元测试框架</h2><p>本来想用google test的，后面想想选择更加现代化的 catch2 或 doetest，两者都是head-only类型的，只需要引入就能够使用，不过更推荐用doctest，因为他编译速度比catch2快很多，如果想要使用方便的话直接使用 <code>include(FetchContent)</code>的方式使用即可。</p><pre class="line-numbers language-cmake"><code class="language-cmake"> include(FetchContent) FetchContent_Declare(         doctest         GIT_REPOSITORY https://github.com/doctest/doctest.git         GIT_TAG master         GIT_SHALLOW TRUE ) FetchContent_MakeAvailable(doctest) ​ target_link_libraries(target doctest_with_main)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体使用不在这讲，看<a href="https://github.com/doctest/doctest/tree/master/doc/markdown">官方文档</a>即可，非常方便。</p><h2 id="benchmark框架"><a href="#benchmark框架" class="headerlink" title="benchmark框架"></a>benchmark框架</h2><p>建议使用 nanobench ，同样也是因为引入简单轻量，使用简单且 head only 。使用可以去看<a href="https://nanobench.ankerl.com/tutorial.html#usage">官方文档</a>。</p><pre class="line-numbers language-cmake"><code class="language-cmake">include(FetchContent) ​ FetchContent_Declare(     nanobench     GIT_REPOSITORY https://github.com/martinus/nanobench.git     GIT_TAG master     GIT_SHALLOW TRUE) ​ FetchContent_MakeAvailable(nanobench)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体输出的话如下：</p><ul><li>ns/op：每个bench内容需要经历的时间（ns为单位）。</li><li>op/s：每秒可以执行多少次操作。</li><li>err%：运行多次测试的波动情况（误差）。</li><li>ins/op：每次操作需要多少条指令。</li><li>cyc/op：每次操作需要多少次时钟周期。</li><li>bra/op：每次操作有多少次分支预判。</li><li>miss%：分支预判的miss率。</li><li>total：本次消耗的总时间。</li><li>benchmark：对应的名字。</li></ul><p>注意测试的时候，有时需要记得防止被编译器优化。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;nanobench.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;doctest/doctest.h></span></span><span class="token function">TEST_CASE</span><span class="token punctuation">(</span><span class="token string">"tutorial_fast_v2"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    uint64_t x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    ankerl<span class="token operator">::</span>nanobench<span class="token operator">::</span><span class="token function">Bench</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token string">"++x"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ankerl<span class="token operator">::</span>nanobench<span class="token operator">::</span><span class="token function">doNotOptimizeAway</span><span class="token punctuation">(</span>x <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="内存泄露检测"><a href="#内存泄露检测" class="headerlink" title="内存泄露检测"></a>内存泄露检测</h2><p>推荐使用backward-cpp，同样是head-only类型的，同样的也可以用上面的方式引入。</p><pre class="line-numbers language-cmake"><code class="language-cmake">include(FetchContent)# Also requires one of: libbfd (gnu binutils), libdwarf, libdw (elfutils)FetchContent_Declare(backward    GIT_REPOSITORY https://github.com/bombela/backward-cpp    GIT_TAG master  # or a version tag, such as v1.6    GIT_SHALLOW TRUE    SYSTEM          # optional, the Backward include directory will be treated as system directory)FetchContent_MakeAvailable(backward)# Add Backward to your target (either Backward::Interface, Backward::Object, or Backward::Backward)target_link_libraries(mytarget PUBLIC Backward::Interface)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于perf，sanitizers等就不在这介绍了。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>├── build<br>├── include<br>├── src<br>│  ├── CMakeLists.txt<br>│  └── main.cpp<br>└── test<br>   └── CMakeLists.txt</p><p>对于一个CMAKE构建的cpp工程应该具有类似上面的项目格式，在总目录下有 CMakeLists.txt,同时，在对应的src和test，有时还会有third-party目录下同样具有CMakeLists.txt。</p><pre class="line-numbers language-cmake"><code class="language-cmake">cmake_minimum_required(VERSION 3.20)if(NOT CMAKE_BUILD_TYPE)  set(CMAKE_BUILD_TYPE "Debug")endif()project(main LANGUAGES CXX)include(FetchContent)#用于引入上面介绍的三方库include_directories(${PROJECT_SOURCE_DIR}/include)set(CMAKE_EXPORT_COMPILE_COMMANDS ON)set(CMAKE_CXX_STANDARD 20)add_subdirectory(src/)add_subdirectory(test/)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总的项目cmakelists应该如上，当然对于第三方库的使用除了上面介绍的方法还有将文件download下来编译的，只不过现在介绍的方法更方便。</p><p>对应的src目录的cmakelists应该如下：</p><pre class="line-numbers language-cmake"><code class="language-cmake"># track the stack info# Also requires one of: libbfd (gnu binutils), libdwarf, libdw (elfutils)FetchContent_Declare(  backward  GIT_REPOSITORY https://github.com/bombela/backward-cpp  GIT_TAG master # or a version tag, such as v1.6  GIT_SHALLOW TRUE  SYSTEM # optional, the Backward include directory will be treated as system directory)FetchContent_MakeAvailable(backward)# srcfile(GLOB_RECURSE all_src CONFIGURE_DEPENDS *.cpp)add_executable(main ${all_src})target_include_directories(main PUBLIC ${PROJECT_SOURCE_DIR}/include/)target_link_libraries(main PRIVATE Backward::Backward)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>test的则是如下：</p><pre class="line-numbers language-cmake"><code class="language-cmake"># doctestFetchContent_Declare(  doctest  GIT_REPOSITORY https://github.com/doctest/doctest.git  GIT_TAG master  GIT_SHALLOW TRUE)FetchContent_MakeAvailable(doctest)# benchmarkFetchContent_Declare(  nanobench  GIT_REPOSITORY https://github.com/martinus/nanobench.git  GIT_TAG master  GIT_SHALLOW TRUE)FetchContent_MakeAvailable(nanobench)file(GLOB_RECURSE all_tests *.cpp)file(GLOB_RECURSE all_src CONFIGURE_DEPENDS ${PROJECT_SOURCE_DIR}/src/*.cpp)list(REMOVE_ITEM all_src ${PROJECT_SOURCE_DIR}/src/main.cpp)foreach(v ${all_tests})  string(REGEX MATCH "test/.*" relative_path ${v})  string(REGEX REPLACE "test/" "" target_name ${relative_path})  string(REGEX REPLACE ".cpp" "" target_name ${target_name})  add_executable(${target_name} ${v} ${all_src})  target_include_directories(${target_name} PUBLIC ${PROJECT_SOURCE_DIR}/include/)  target_link_libraries(${target_name} PRIVATE doctest_with_main nanobench Backward::Backward)endforeach()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;本科时候质疑CMAKE，后面理解CMAKE,加入CMAKE。言归正传，之前不喜欢用clion的原因，一是因为clion每次使用的时候启动慢，
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>通过折叠表达式简化返回值检测</title>
    <link href="https://joytsing.github.io/posts/33498/"/>
    <id>https://joytsing.github.io/posts/33498/</id>
    <published>2024-03-04T07:14:44.000Z</published>
    <updated>2024-03-04T07:26:37.535Z</updated>
    
    <content type="html"><![CDATA[<h2 id="返回值检查"><a href="#返回值检查" class="headerlink" title="返回值检查"></a>返回值检查</h2><p>比如在启动服务器或者客户端的时候编写init函数， 此时需要依次去config目录加载对应的配置，log的配置等等，在这个时候如果一行行写的话就会有如下代码：</p><pre class="line-numbers language-c++"><code class="language-c++">error_t result{};result = check1(…);if (result != error_t::ok) {  return result;}result = check2(…);if (result != error_t::ok) {  return result;}result = check3(…);if (result != error_t::ok) {  return result;}result = check4(…);if (result != error_t::ok) {  return result;}return error_t::ok;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽说也可以但是终归是比较丑陋，如果应用折叠表达式的话可以写成如下形式：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">return</span> <span class="token function">checked_exec</span><span class="token punctuation">(</span>  error_t<span class="token operator">::</span>ok<span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">check1</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">check2</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">check3</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">check4</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对应的check_exec可以写成：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> R<span class="token punctuation">,</span>          <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Fn<span class="token operator">></span>R <span class="token function">checked_exec</span><span class="token punctuation">(</span><span class="token keyword">const</span> R<span class="token operator">&amp;</span> expected<span class="token punctuation">,</span>               Fn<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> fn<span class="token punctuation">)</span><span class="token punctuation">{</span>  R result <span class="token operator">=</span> expected<span class="token punctuation">;</span>  <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>result <span class="token operator">=</span> forward<span class="token operator">&lt;</span>Fn<span class="token operator">></span><span class="token punctuation">(</span>             fn<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> expected<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>         <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，前提是不传入参数，传入参数不同的话就需要额外编写。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;返回值检查&quot;&gt;&lt;a href=&quot;#返回值检查&quot; class=&quot;headerlink&quot; title=&quot;返回值检查&quot;&gt;&lt;/a&gt;返回值检查&lt;/h2&gt;&lt;p&gt;比如在启动服务器或者客户端的时候编写init函数， 此时需要依次去config目录加载对应的配置，log的配置等等，
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>vscode CMake Tools 传递命令行参数</title>
    <link href="https://joytsing.github.io/posts/61384/"/>
    <id>https://joytsing.github.io/posts/61384/</id>
    <published>2024-01-20T15:03:02.000Z</published>
    <updated>2024-01-20T15:17:21.433Z</updated>
    
    <content type="html"><![CDATA[<p>vscode调试C++程序时，有时需要给程序传递命令行参数。这么说，如果是用F5去运行的话那么则是另外一套配置配置方法，但现在最近已经习惯了CMake一套工具链，同时懒得跳到命令行里面去打make或者运行脚本。这种时候，通常做法是配置<code>launch.json</code>文件中要调试程序的<code>args</code>字段。但是设置<code>tasks.json</code>和<code>launch.json</code>的方式不如使用CMake Tools插件调试运行程序方便。CMake Tools插件调试运行程序可以在多个cmake的target中切换，省去了写那些配置的繁琐步骤。</p><p><img src="/posts/61384/image-20240120230905008.png" alt></p><h2 id="1-设置方法-设置-cmake-debugConfig-的-args字段"><a href="#1-设置方法-设置-cmake-debugConfig-的-args字段" class="headerlink" title="1. 设置方法: 设置 cmake.debugConfig 的 args字段"></a>1. 设置方法: 设置 cmake.debugConfig 的 args字段</h2><p>注意要是去设置<code>Workspace</code>的<code>settings.json</code>,因为每个项目需要的设置的命令行参数不一样。</p><p>如果设置<code>User</code>的<code>settings.json</code>会对其他项目产生影响。</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"cmake.debugConfig"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"args"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"arg1"</span><span class="token punctuation">,</span> <span class="token string">"arg2"</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里只配置了<code>cmake.debugConfig</code>中的<code>args</code>字段，其他字段省去了，因为我们当前只需要设置命令行参数。</p><p>虽然名字叫<code>debugConfig</code>，这里传递的命令行参数在<code>Release</code>和<code>Debug</code>模式下都是有效的。</p><h2 id="2-例子"><a href="#2-例子" class="headerlink" title="2. 例子"></a>2. 例子</h2><p>假设<code>main.cpp</code>需要用到命令行参数</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> argc <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后直接创建一个.vscode文件夹，创建一个settings.json文件，把上面1中提到的内容加进去就好了。</p><p><img src="/posts/61384/image-20240120230941833.png" alt></p><p>这样用CMake一套就能直接带参数调试或者运行了，同理，想要配置clangd的话也是直接去settings设置就好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;vscode调试C++程序时，有时需要给程序传递命令行参数。这么说，如果是用F5去运行的话那么则是另外一套配置配置方法，但现在最近已经习惯了CMake一套工具链，同时懒得跳到命令行里面去打make或者运行脚本。这种时候，通常做法是配置&lt;code&gt;launch.json&lt;/c
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://JoyTsing.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
      <category term="Tool" scheme="https://JoyTsing.github.io/tags/Tool/"/>
    
  </entry>
  
  <entry>
    <title>贵安，元旦快乐</title>
    <link href="https://joytsing.github.io/posts/53667/"/>
    <id>https://joytsing.github.io/posts/53667/</id>
    <published>2024-01-01T16:54:05.000Z</published>
    <updated>2024-01-01T16:58:55.541Z</updated>
    
    <content type="html"><![CDATA[<h2 id="元旦快乐"><a href="#元旦快乐" class="headerlink" title="元旦快乐"></a>元旦快乐</h2><p>2024年伊始，很久没有更新新的博文了，先给大家祝贺一下。在这里顺便说一下本站接下来的计划吧：</p><p>因为这个blog是我大二时候一时兴起搭的，大部分插件什么的也是那会弄的，现在发现已经有很多不能用了，可能之后会有一次大的迭代或者重构吧。毕竟前端这东西还是迭代太快了，这才4年hexo的结构就已经变了个样了，插件统计什么的我估计之前都是靠着缓存在工作，clean之后直接罢工了（笑。</p><p>希望新的一年多多努力，好好奋斗，多读点书（不管是什么样的），做一些有意义的工作，别的想说的都融在那两首歌里面了，愿意听就去听吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;元旦快乐&quot;&gt;&lt;a href=&quot;#元旦快乐&quot; class=&quot;headerlink&quot; title=&quot;元旦快乐&quot;&gt;&lt;/a&gt;元旦快乐&lt;/h2&gt;&lt;p&gt;2024年伊始，很久没有更新新的博文了，先给大家祝贺一下。在这里顺便说一下本站接下来的计划吧：&lt;/p&gt;
&lt;p&gt;因为这个blo
      
    
    </summary>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Linux下多Clang工具链的踩坑</title>
    <link href="https://joytsing.github.io/posts/19689/"/>
    <id>https://joytsing.github.io/posts/19689/</id>
    <published>2023-12-21T11:21:21.000Z</published>
    <updated>2023-12-21T11:55:43.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>故事是从C++ 17标准说起，在写线程池异步执行的时候发现居然没法使用move移动，然后怀疑到了clang头上，因为发现当我使用C++17标准下的<code>std::invoke_result</code>时直接报错是没有这个函数实现，说明clang版本有点旧了(加上我需要C++20的实现)，然后就开始研究起来clang的更新。</p><p><img src="/posts/19689/2.png" alt></p><h2 id="第一个坑"><a href="#第一个坑" class="headerlink" title="第一个坑"></a>第一个坑</h2><p>首先，因为需要做cmu15445 2023spring的project，在我的环境下安装了全套clang-14的tool-chain，那么问题来了，首先，你直接apt install只能安装到14的版本，其次，如果能安装了，但我需要使用最新的C++标准，但我又想保留老的tool chain怎么办？（可以试一试，如果直接安装的话会把老的版本卸载了）</p><p>首先是安装：我先找到了llvm官网的安装脚本，但又存在一个问题，通过这个安装脚本下载的话速度太慢（是的挂梯子也不行），后来翻找发现果然国内有对应的<a href="https://mirrors.tuna.tsinghua.edu.cn/help/llvm-apt/">镜像源</a>。那么怎么做，长话短说，直接通过脚本安装的话会卸载，这里是手动启用了一部分，即首先信任来自 <a href="https://apt.llvm.org/">llvm</a> 的 PGP 公钥。然后先手动安装clang-17以及clang++-17（或许还有别的，但这两个是肯定有的），在手动安装的情况下因为指定了版本号，所以是不会冲突的（clang-14与clang-17），最重要的部分安装好后通过先前的脚本将完整的tool-chain下载下来（即clang-tidy-17等等）。</p><p>到目前为止没结束，因为还需管理多版本clang，需要通过<code>update-alternatives</code>选择对应版本号，具体怎么用直接搜索该命令就好，最后应该把这3个软件版本设成最新的：clang、clang++、clangd。那么目前多版本算是好了。</p><h2 id="第二个坑"><a href="#第二个坑" class="headerlink" title="第二个坑"></a>第二个坑</h2><p>那么怎么使用多版本呢？如果你不是命令行档（即干啥都坚持在命令行cmake），想要自己多个选择的话，那么此时你打开vscode对应的项目会出现下面的问题<img src="/posts/19689/1.png" alt></p><p>原因很显然，因为我们将对应的默认clang版本更改了，但是理论上说，在vscode上选择对应工具链会切换成对应的版本号，那么为什么？我花了大量时间在.vscode和插件的配置上，但实际上这些都是没用的。上图是我已经正常配置过了的版本，如果你之前使用的话，那么你会发现clang 14和clang17这两个地方的编译器的链接是完全相同的。</p><p>出现这个情况的原因在上文中已经说了，因为我们使用的<code>update-alternatives</code>，做的实际上是帮助我们创建对应的软链接，即：对于<code>clang</code> ，如果我在<code>update-alternatives</code>中把clang版本中的14设为高优先级那么clang链接的就是14，设置的是17就是17。我们需要做的是更改tool chain对应找的工具，也就是不再要之前的软链接（曾经是对的，但不会自动更改）。</p><p><img src="/posts/19689/3.png" alt></p><p>当时思路是正确了，那么怎么更改？在扫描tool chain的时候我注意到他会去一个目录下加载，于是去那个目录：</p><p><img src="/posts/19689/4.png" alt></p><p>把对应的clang14和clang17的tool-chain加上版本号即可，这时候vscode的cmake tool chain也设置好了。以后如果是多环境也是这样即可。</p><h2 id="别的坑"><a href="#别的坑" class="headerlink" title="别的坑"></a>别的坑</h2><p>其实实际上踩的坑不止这些，包括但不限于把公钥全删了导致apt报错等等，但最后终于把vscode下c++的clangd更新，不再给我那些C++17语法报错，总的来说还是指的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;故事是从C++ 17标准说起，在写线程池异步执行的时候发现居然没法使用move移动，然后怀疑到了clang头上，因为发现当我使用C++17标
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>内存分配函数malloc的原理及实现</title>
    <link href="https://joytsing.github.io/posts/8649/"/>
    <id>https://joytsing.github.io/posts/8649/</id>
    <published>2023-12-19T15:41:01.000Z</published>
    <updated>2024-01-01T16:46:29.971Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是malloc"><a href="#1-什么是malloc" class="headerlink" title="1 什么是malloc"></a>1 什么是malloc</h2><p>在实现malloc之前，先要相对正式地对malloc做一个定义。</p><p>根据标准C库函数的定义，malloc具有如下原型：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">malloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个函数要实现的功能是在系统中分配一段连续的可用的内存，具体有如下要求：</p><ul><li>malloc分配的内存大小<strong>至少</strong>为size参数所指定的字节数</li><li>malloc的返回值是一个指针，指向一段可用内存的起始地址</li><li>多次调用malloc所分配的地址不能有重叠部分，除非某次malloc所分配的地址被释放掉</li><li>malloc应该尽快完成内存分配并返回（不能使用<a href="http://en.wikipedia.org/wiki/NP-hard">NP-hard</a>的内存分配算法）</li><li>实现malloc时应同时实现内存大小调整和内存释放函数（即realloc和free）</li></ul><p>对于malloc更多的说明可以在命令行中键入以下命令查看：</p><pre><code>man malloc</code></pre><h2 id="2-预备知识"><a href="#2-预备知识" class="headerlink" title="2 预备知识"></a>2 预备知识</h2><p>在实现malloc之前，需要先解释一些Linux系统内存相关的知识。</p><h3 id="2-1-Linux内存管理"><a href="#2-1-Linux内存管理" class="headerlink" title="2.1 Linux内存管理"></a>2.1 Linux内存管理</h3><h4 id="2-1-1-虚拟内存地址与物理内存地址"><a href="#2-1-1-虚拟内存地址与物理内存地址" class="headerlink" title="2.1.1 虚拟内存地址与物理内存地址"></a>2.1.1 虚拟内存地址与物理内存地址</h4><p>为了简单，现代操作系统在处理内存地址时，普遍采用虚拟内存地址技术。即在汇编程序（或机器语言）层面，当涉及内存地址时，都是使用虚拟内存地址。采用这种技术时，每个进程仿佛自己独享一片$2^N$字节的内存，其中$N$是机器位数。例如在64位CPU和64位操作系统下，每个进程的虚拟地址空间为$2^{64}$Byte。</p><p>这种虚拟地址空间的作用主要是简化程序的编写及方便操作系统对进程间内存的隔离管理，真实中的进程不太可能（也用不到）如此大的内存空间，实际能用到的内存取决于物理内存大小。</p><p>由于在机器语言层面都是采用虚拟地址，当实际的机器码程序涉及到内存操作时，需要根据当前进程运行的实际上下文将虚拟地址转换为物理内存地址，才能实现对真实内存数据的操作。这个转换一般由一个叫<a href="http://en.wikipedia.org/wiki/Memory_management_unit">MMU</a>（Memory Management Unit）的硬件完成。</p><h4 id="2-1-2-页与地址构成"><a href="#2-1-2-页与地址构成" class="headerlink" title="2.1.2 页与地址构成"></a>2.1.2 页与地址构成</h4><p>在现代操作系统中，不论是虚拟内存还是物理内存，都不是以字节为单位进行管理的，而是以页（Page）为单位。一个内存页是一段固定大小的连续内存地址的总称，具体到Linux中，典型的内存页大小为4096Byte（4K）。</p><p>所以内存地址可以分为页号和页内偏移量。下面以64位机器，4G物理内存，4K页大小为例，虚拟内存地址和物理内存地址的组成如下：</p><p><img src="https://pic4.zhimg.com/80/v2-b37992424628f32bc5e8245b689a31df_720w.webp" alt="img"></p><p>上面是虚拟内存地址，下面是物理内存地址。由于页大小都是4K，所以页内偏移都是用低12位表示，而剩下的高地址表示页号。</p><p>MMU映射单位并不是字节，而是页，这个映射通过查一个常驻内存的数据结构<a href="http://en.wikipedia.org/wiki/Page_table">页表</a>来实现。现在计算机具体的内存地址映射比较复杂，为了加快速度会引入一系列缓存和优化，例如<a href="http://en.wikipedia.org/wiki/Translation_lookaside_buffer">TLB</a>等机制。下面给出一个经过简化的内存地址翻译示意图，虽然经过了简化，但是基本原理与现代计算机真实的情况的一致的。</p><p><img src="https://pic3.zhimg.com/80/v2-15d430b30f223794b85ce6f54a95006e_720w.webp" alt="img"></p><h4 id="2-1-3-内存页与磁盘页"><a href="#2-1-3-内存页与磁盘页" class="headerlink" title="2.1.3 内存页与磁盘页"></a>2.1.3 内存页与磁盘页</h4><p>我们知道一般将内存看做磁盘的的缓存，有时MMU在工作时，会发现页表表明某个内存页不在物理内存中，此时会触发一个缺页异常（Page Fault），此时系统会到磁盘中相应的地方将磁盘页载入到内存中，然后重新执行由于缺页而失败的机器指令。关于这部分，因为可以看做对malloc实现是透明的，所以不再详细讲述，有兴趣的可以参考《深入理解计算机系统》相关章节。</p><p>最后附上一张在维基百科找到的更加符合真实地址翻译的流程供大家参考，这张图加入了TLB和缺页异常的流程（<a href="http://en.wikipedia.org/wiki/Page_table">图片来源页</a>）。</p><p><img src="https://pic3.zhimg.com/80/v2-5bb7bf5a484d6185e9d5a06a20408da6_720w.webp" alt="img"></p><h3 id="2-2-Linux进程级内存管理"><a href="#2-2-Linux进程级内存管理" class="headerlink" title="2.2 Linux进程级内存管理"></a>2.2 Linux进程级内存管理</h3><h4 id="2-2-1-内存排布"><a href="#2-2-1-内存排布" class="headerlink" title="2.2.1 内存排布"></a>2.2.1 内存排布</h4><p>明白了虚拟内存和物理内存的关系及相关的映射机制，下面看一下具体在一个进程内是如何排布内存的。</p><p>以Linux 64位系统为例。理论上，64bit内存地址可用空间为0x0000000000000000 ~ 0xFFFFFFFFFFFFFFFF，这是个相当庞大的空间，Linux实际上只用了其中一小部分（256T）。</p><p>根据<a href="https://www.kernel.org/doc/Documentation/x86/x86_64/mm.txt">Linux内核相关文档</a>描述，Linux64位操作系统仅使用低47位，高17位做扩展（只能是全0或全1）。所以，实际用到的地址为空间为0x0000000000000000 ~ 0x00007FFFFFFFFFFF和0xFFFF800000000000 ~ 0xFFFFFFFFFFFFFFFF，其中前面为用户空间（User Space），后者为内核空间（Kernel Space）。图示如下：</p><p><img src="https://pic3.zhimg.com/80/v2-c9969fd8e48b5dcdd813de6d0756434a_720w.webp" alt="img"></p><p>对用户来说，主要关注的空间是User Space。将User Space放大后，可以看到里面主要分为如下几段：</p><ul><li>Code：这是整个用户空间的最低地址部分，存放的是指令（也就是程序所编译成的可执行机器码）</li><li>Data：这里存放的是初始化过的全局变量</li><li>BSS：这里存放的是未初始化的全局变量</li><li>Heap：堆，这是我们本文重点关注的地方，堆自低地址向高地址增长，后面要讲到的brk相关的系统调用就是从这里分配内存</li><li>Mapping Area：这里是与mmap系统调用相关的区域。大多数实际的malloc实现会考虑通过mmap分配较大块的内存区域，本文不讨论这种情况。这个区域自高地址向低地址增长</li><li>Stack：这是栈区域，自高地址向低地址增长</li></ul><p>下面我们主要关注Heap区域的操作。对整个Linux内存排布有兴趣的同学可以参考其它资料。</p><h4 id="2-2-2-Heap内存模型"><a href="#2-2-2-Heap内存模型" class="headerlink" title="2.2.2 Heap内存模型"></a>2.2.2 Heap内存模型</h4><p>一般来说，malloc所申请的内存主要从Heap区域分配（本文不考虑通过mmap申请大块内存的情况）。</p><p>由上文知道，进程所面对的虚拟内存地址空间，只有按页映射到物理内存地址，才能真正使用。受物理存储容量限制，整个堆虚拟内存空间不可能全部映射到实际的物理内存。Linux对堆的管理示意如下：</p><p><img src="https://pic2.zhimg.com/80/v2-9bd8544cccfc3709a2139a6121aeab31_720w.webp" alt="img"></p><p>Linux维护一个break指针，这个指针指向堆空间的某个地址。从堆起始地址到break之间的地址空间为映射好的，可以供进程访问；而从break往上，是未映射的地址空间，如果访问这段空间则程序会报错。</p><h4 id="2-2-3-brk与sbrk"><a href="#2-2-3-brk与sbrk" class="headerlink" title="2.2.3 brk与sbrk"></a>2.2.3 brk与sbrk</h4><p>由上文知道，要增加一个进程实际的可用堆大小，就需要将break指针向高地址移动。Linux通过brk和sbrk系统调用操作break指针。两个系统调用的原型如下：</p><pre><code>int brk(void *addr);void *sbrk(intptr_t increment);</code></pre><p>brk将break指针直接设置为某个地址，而sbrk将break从当前位置移动increment所指定的增量。brk在执行成功时返回0，否则返回-1并设置errno为ENOMEM；sbrk成功时返回break移动之前所指向的地址，否则返回(void *)-1。</p><p>一个小技巧是，如果将increment设置为0，则可以获得当前break的地址。</p><p>另外需要注意的是，由于Linux是按页进行内存映射的，所以如果break被设置为没有按页大小对齐，则系统实际上会在最后映射一个完整的页，从而实际已映射的内存空间比break指向的地方要大一些。但是使用break之后的地址是很危险的（尽管也许break之后确实有一小块可用内存地址）。</p><h4 id="2-2-4-资源限制与rlimit"><a href="#2-2-4-资源限制与rlimit" class="headerlink" title="2.2.4 资源限制与rlimit"></a>2.2.4 资源限制与rlimit</h4><p>系统对每一个进程所分配的资源不是无限的，包括可映射的内存空间，因此每个进程有一个rlimit表示当前进程可用的资源上限。这个限制可以通过getrlimit系统调用得到，下面代码获取当前进程虚拟内存空间的rlimit：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> rlimit <span class="token operator">*</span>limit <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> rlimit <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> rlimit<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">getrlimit</span><span class="token punctuation">(</span>RLIMIT_AS<span class="token punctuation">,</span> limit<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"soft limit: %ld, hard limit: %ld\n"</span><span class="token punctuation">,</span> limit<span class="token operator">-></span>rlim_cur<span class="token punctuation">,</span> limit<span class="token operator">-></span>rlim_max<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中rlimit是一个结构体：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> rlimit <span class="token punctuation">{</span>    rlim_t rlim_cur<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* Soft limit */</span>    rlim_t rlim_max<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* Hard limit (ceiling for rlim_cur) */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>每种资源有软限制和硬限制，并且可以通过setrlimit对rlimit进行有条件设置。其中硬限制作为软限制的上限，非特权进程只能设置软限制，且不能超过硬限制。</p><h2 id="3-实现malloc"><a href="#3-实现malloc" class="headerlink" title="3 实现malloc"></a>3 实现malloc</h2><h3 id="3-1-玩具实现"><a href="#3-1-玩具实现" class="headerlink" title="3.1 玩具实现"></a>3.1 玩具实现</h3><p>在正式开始讨论malloc的实现前，我们可以利用上述知识实现一个简单但几乎没法用于真实的玩具malloc，权当对上面知识的复习：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 一个玩具malloc */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">malloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token function">sbrk</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sbrk</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个malloc每次都在当前break的基础上增加size所指定的字节数，并将之前break的地址返回。这个malloc由于对所分配的内存缺乏记录，不便于内存释放，所以无法用于真实场景。</p><h3 id="3-2-正式实现"><a href="#3-2-正式实现" class="headerlink" title="3.2 正式实现"></a>3.2 正式实现</h3><p>下面严肃点讨论malloc的实现方案。</p><h4 id="3-2-1-数据结构"><a href="#3-2-1-数据结构" class="headerlink" title="3.2.1 数据结构"></a>3.2.1 数据结构</h4><p>首先我们要确定所采用的数据结构。一个简单可行方案是将堆内存空间以块（Block）的形式组织起来，每个块由meta区和数据区组成，meta区记录数据块的元信息（数据区大小、空闲标志位、指针等等），数据区是真实分配的内存区域，并且数据区的第一个字节地址即为malloc返回的地址。</p><p>可以用如下结构体定义一个block：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> s_block <span class="token operator">*</span>t_block<span class="token punctuation">;</span><span class="token keyword">struct</span> s_block <span class="token punctuation">{</span>    size_t size<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 数据区大小 */</span>    t_block next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 指向下个块的指针 */</span>    <span class="token keyword">int</span> free<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* 是否是空闲块 */</span>    <span class="token keyword">int</span> padding<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 填充4字节，保证meta块长度为8的倍数 */</span>    <span class="token keyword">char</span> data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">/* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于我们只考虑64位机器，为了方便，我们在结构体最后填充一个int，使得结构体本身的长度为8的倍数，以便内存对齐。示意图如下：</p><p><img src="https://pic2.zhimg.com/80/v2-7f5b5dcb606608867c9d03cc908bcfa1_720w.webp" alt="img"></p><h4 id="3-2-2-寻找合适的block"><a href="#3-2-2-寻找合适的block" class="headerlink" title="3.2.2 寻找合适的block"></a>3.2.2 寻找合适的block</h4><p>现在考虑如何在block链中查找合适的block。一般来说有两种查找算法：</p><ul><li><strong>First fit</strong>：从头开始，使用第一个数据区大小大于要求size的块所谓此次分配的块</li><li><strong>Best fit</strong>：从头开始，遍历所有块，使用数据区大小大于size且差值最小的块作为此次分配的块</li></ul><p>两种方法各有千秋，best fit具有较高的内存使用率（payload较高），而first fit具有更好的运行效率。这里我们采用first fit算法。</p><pre><code>/* First fit */t_block find_block(t_block *last, size_t size) {    t_block b = first_block;    while(b &amp;&amp; !(b-&gt;free &amp;&amp; b-&gt;size &gt;= size)) {        *last = b;        b = b-&gt;next;    }    return b;}</code></pre><p>find_block从frist_block开始，查找第一个符合要求的block并返回block起始地址，如果找不到这返回NULL。这里在遍历时会更新一个叫last的指针，这个指针始终指向当前遍历的block。这是为了如果找不到合适的block而开辟新block使用的，具体会在接下来的一节用到。</p><h4 id="3-2-3-开辟新的block"><a href="#3-2-3-开辟新的block" class="headerlink" title="3.2.3 开辟新的block"></a>3.2.3 开辟新的block</h4><p>如果现有block都不能满足size的要求，则需要在链表最后开辟一个新的block。这里关键是如何只使用sbrk创建一个struct：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> BLOCK_SIZE 24 </span><span class="token comment" spellcheck="true">/* 由于存在虚拟的data字段，sizeof不能正确计算meta长度，这里手工设置 */</span>t_block <span class="token function">extend_heap</span><span class="token punctuation">(</span>t_block last<span class="token punctuation">,</span> size_t s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    t_block b<span class="token punctuation">;</span>    b <span class="token operator">=</span> <span class="token function">sbrk</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">sbrk</span><span class="token punctuation">(</span>BLOCK_SIZE <span class="token operator">+</span> s<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    b<span class="token operator">-></span>size <span class="token operator">=</span> s<span class="token punctuation">;</span>    b<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>last<span class="token punctuation">)</span>        last<span class="token operator">-></span>next <span class="token operator">=</span> b<span class="token punctuation">;</span>    b<span class="token operator">-></span>free <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-4-分裂block"><a href="#3-2-4-分裂block" class="headerlink" title="3.2.4 分裂block"></a>3.2.4 分裂block</h4><p>First fit有一个比较致命的缺点，就是可能会让很小的size占据很大的一块block，此时，为了提高payload，应该在剩余数据区足够大的情况下，将其分裂为一个新的block，示意如下：</p><p><img src="https://pic4.zhimg.com/80/v2-bd539864955725b96751f9b23b8ca293_720w.webp" alt="img"></p><p>实现代码：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">split_block</span><span class="token punctuation">(</span>t_block b<span class="token punctuation">,</span> size_t s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    t_block new<span class="token punctuation">;</span>    new <span class="token operator">=</span> b<span class="token operator">-></span>data <span class="token operator">+</span> s<span class="token punctuation">;</span>    new<span class="token operator">-></span>size <span class="token operator">=</span> b<span class="token operator">-></span>size <span class="token operator">-</span> s <span class="token operator">-</span> BLOCK_SIZE <span class="token punctuation">;</span>    new<span class="token operator">-></span>next <span class="token operator">=</span> b<span class="token operator">-></span>next<span class="token punctuation">;</span>    new<span class="token operator">-></span>free <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    b<span class="token operator">-></span>size <span class="token operator">=</span> s<span class="token punctuation">;</span>    b<span class="token operator">-></span>next <span class="token operator">=</span> new<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-5-malloc的实现"><a href="#3-2-5-malloc的实现" class="headerlink" title="3.2.5 malloc的实现"></a>3.2.5 malloc的实现</h4><p>有了上面的代码，我们可以利用它们整合成一个简单但初步可用的malloc。注意首先我们要定义个block链表的头first_block，初始化为NULL；另外，我们需要剩余空间至少有BLOCK_SIZE + 8才执行分裂操作。</p><p>由于我们希望malloc分配的数据区是按8字节对齐，所以在size不为8的倍数时，我们需要将size调整为大于size的最小的8的倍数：</p><pre class="line-numbers language-c"><code class="language-c">size_t <span class="token function">align8</span><span class="token punctuation">(</span>size_t s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>s <span class="token operator">&amp;</span> <span class="token number">0x7</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> s<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">>></span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">define</span> BLOCK_SIZE 24</span><span class="token keyword">void</span> <span class="token operator">*</span>first_block<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* other functions... */</span><span class="token keyword">void</span> <span class="token function">malloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    t_block b<span class="token punctuation">,</span> last<span class="token punctuation">;</span>    size_t s<span class="token punctuation">;</span>    <span class="token operator">/</span> 对齐地址 <span class="token operator">/</span>    s <span class="token operator">=</span> <span class="token function">align8</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>first_block<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">/</span> 查找合适的block <span class="token operator">/</span>        last <span class="token operator">=</span> first_block<span class="token punctuation">;</span>        b <span class="token operator">=</span> <span class="token function">find_block</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>last<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">/</span> 如果可以，则分裂 <span class="token operator">/</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>b<span class="token operator">-></span>size <span class="token operator">-</span> s<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token punctuation">(</span> BLOCK_SIZE <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token function">split_block</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>            b<span class="token operator">-></span>free <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token operator">/</span> 没有合适的block，开辟一个新的 <span class="token operator">*</span><span class="token operator">/</span>        b <span class="token operator">=</span> <span class="token function">extend_heap</span><span class="token punctuation">(</span>last<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>b<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    b <span class="token operator">=</span> <span class="token function">extend_heap</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>b<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    first_block <span class="token operator">=</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> b<span class="token operator">-></span>data<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-6-calloc的实现"><a href="#3-2-6-calloc的实现" class="headerlink" title="3.2.6 calloc的实现"></a>3.2.6 calloc的实现</h4><p>有了malloc，实现calloc只要两步：</p><ol><li>malloc一段内存</li><li>将数据区内容置为0</li></ol><p>由于我们的数据区是按8字节对齐的，所以为了提高效率，我们可以每8字节一组置0，而不是一个一个字节设置。我们可以通过新建一个size_t指针，将内存区域强制看做size_t类型来实现。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">calloc</span><span class="token punctuation">(</span>size_t number<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    size_t <span class="token operator">*</span>new<span class="token punctuation">;</span>    size_t s8<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    new <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>number <span class="token operator">*</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>new<span class="token punctuation">)</span> <span class="token punctuation">{</span>        s8 <span class="token operator">=</span> <span class="token function">align8</span><span class="token punctuation">(</span>number <span class="token operator">*</span> size<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s8<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            new<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> new<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-7-free的实现"><a href="#3-2-7-free的实现" class="headerlink" title="3.2.7 free的实现"></a>3.2.7 free的实现</h4><p>free的实现并不像看上去那么简单，这里我们要解决两个关键问题：</p><ol><li>如何验证所传入的地址是有效地址，即确实是通过malloc方式分配的数据区首地址</li><li>如何解决碎片问题</li></ol><p>首先我们要保证传入free的地址是有效的，这个有效包括两方面：</p><ul><li>地址应该在之前malloc所分配的区域内，即在first_block和当前break指针范围内</li><li>这个地址确实是之前通过我们自己的malloc分配的</li></ul><p>第一个问题比较好解决，只要进行地址比较就可以了，关键是第二个问题。这里有两种解决方案：一是在结构体内埋一个magic number字段，free之前通过相对偏移检查特定位置的值是否为我们设置的magic number，另一种方法是在结构体内增加一个magic pointer，这个指针指向数据区的第一个字节（也就是在合法时free时传入的地址），我们在free前检查magic pointer是否指向参数所指地址。这里我们采用第二种方案：</p><p>首先我们在结构体中增加magic pointer（同时要修改BLOCK_SIZE）：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> s_block <span class="token operator">*</span>t_block<span class="token punctuation">;</span><span class="token keyword">struct</span> s_block <span class="token punctuation">{</span>    size_t size<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 数据区大小 */</span>    t_block next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 指向下个块的指针 */</span>    <span class="token keyword">int</span> free<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* 是否是空闲块 */</span>    <span class="token keyword">int</span> padding<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 填充4字节，保证meta块长度为8的倍数 */</span>    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Magic pointer，指向data */</span>    <span class="token keyword">char</span> data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">/* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们定义检查地址合法性的函数：</p><pre class="line-numbers language-c"><code class="language-c">t_block <span class="token function">get_block</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>tmp<span class="token punctuation">;</span>      tmp <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> tmp <span class="token operator">-</span><span class="token operator">=</span> BLOCK_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">valid_addr</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>first_block<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">></span> first_block <span class="token operator">&amp;&amp;</span> p <span class="token operator">&lt;</span> <span class="token function">sbrk</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> p <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token function">get_block</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-></span>ptr<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当多次malloc和free后，整个内存池可能会产生很多碎片block，这些block很小，经常无法使用，甚至出现许多碎片连在一起，虽然总体能满足某此malloc要求，但是由于分割成了多个小block而无法fit，这就是碎片问题。</p><p>一个简单的解决方式时当free某个block时，如果发现它相邻的block也是free的，则将block和相邻block合并。为了满足这个实现，需要将s_block改为双向链表。修改后的block结构如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> s_block <span class="token operator">*</span>t_block<span class="token punctuation">;</span><span class="token keyword">struct</span> s_block <span class="token punctuation">{</span>    size_t size<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 数据区大小 */</span>    t_block prev<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 指向上个块的指针 */</span>    t_block next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 指向下个块的指针 */</span>    <span class="token keyword">int</span> free<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* 是否是空闲块 */</span>    <span class="token keyword">int</span> padding<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 填充4字节，保证meta块长度为8的倍数 */</span>    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Magic pointer，指向data */</span>    <span class="token keyword">char</span> data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">/* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>合并方法如下：</p><pre class="line-numbers language-c"><code class="language-c">t_block <span class="token function">fusion</span><span class="token punctuation">(</span>t_block b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token operator">-></span>next <span class="token operator">&amp;&amp;</span> b<span class="token operator">-></span>next<span class="token operator">-></span>free<span class="token punctuation">)</span> <span class="token punctuation">{</span>        b<span class="token operator">-></span>size <span class="token operator">+</span><span class="token operator">=</span> BLOCK_SIZE <span class="token operator">+</span> b<span class="token operator">-></span>next<span class="token operator">-></span>size<span class="token punctuation">;</span>        b<span class="token operator">-></span>next <span class="token operator">=</span> b<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">-></span>next<span class="token punctuation">)</span>            b<span class="token operator">-></span>next<span class="token operator">-></span>prev <span class="token operator">=</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了上述方法，free的实现思路就比较清晰了：首先检查参数地址的合法性，如果不合法则不做任何事；否则，将此block的free标为1，并且在可以的情况下与后面的block进行合并。如果当前是最后一个block，则回退break指针释放进程内存，如果当前block是最后一个block，则回退break指针并设置first_block为NULL。实现如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">free</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    t_block b<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">valid_addr</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        b <span class="token operator">=</span> <span class="token function">get_block</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        b<span class="token operator">-></span>free <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">-></span>prev <span class="token operator">&amp;&amp;</span> b<span class="token operator">-></span>prev<span class="token operator">-></span>free<span class="token punctuation">)</span>            b <span class="token operator">=</span> <span class="token function">fusion</span><span class="token punctuation">(</span>b<span class="token operator">-></span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">-></span>next<span class="token punctuation">)</span>            <span class="token function">fusion</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">-></span>prev<span class="token punctuation">)</span>                b<span class="token operator">-></span>prev<span class="token operator">-></span>prev <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                first_block <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            <span class="token function">brk</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-8-realloc的实现"><a href="#3-2-8-realloc的实现" class="headerlink" title="3.2.8 realloc的实现"></a>3.2.8 realloc的实现</h4><p>为了实现realloc，我们首先要实现一个内存复制方法。如同calloc一样，为了效率，我们以8字节为单位进行复制：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">copy_block</span><span class="token punctuation">(</span>t_block src<span class="token punctuation">,</span> t_block dst<span class="token punctuation">)</span> <span class="token punctuation">{</span>    size_t <span class="token operator">*</span>sdata<span class="token punctuation">,</span> <span class="token operator">*</span>ddata<span class="token punctuation">;</span>    size_t i<span class="token punctuation">;</span>    sdata <span class="token operator">=</span> src<span class="token operator">-></span>ptr<span class="token punctuation">;</span>    ddata <span class="token operator">=</span> dst<span class="token operator">-></span>ptr<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>i <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> src<span class="token operator">-></span>size <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>i <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> dst<span class="token operator">-></span>size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        ddata<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> sdata<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们开始实现realloc。一个简单（但是低效）的方法是malloc一段内存，然后将数据复制过去。但是我们可以做的更高效，具体可以考虑以下几个方面：</p><ul><li>如果当前block的数据区大于等于realloc所要求的size，则不做任何操作</li><li>如果新的size变小了，考虑split</li><li>如果当前block的数据区不能满足size，但是其后继block是free的，并且合并后可以满足，则考虑做合并</li></ul><p>下面是realloc的实现：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">realloc</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    size_t s<span class="token punctuation">;</span>    t_block b<span class="token punctuation">,</span> new<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>newp<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">/* 根据标准库文档，当p传入NULL时，相当于调用malloc */</span>        <span class="token keyword">return</span> <span class="token function">malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">valid_addr</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        s <span class="token operator">=</span> <span class="token function">align8</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>        b <span class="token operator">=</span> <span class="token function">get_block</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">-></span>size <span class="token operator">>=</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">-></span>size <span class="token operator">-</span> s <span class="token operator">>=</span> <span class="token punctuation">(</span>BLOCK_SIZE <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token function">split_block</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/* 看是否可进行合并 */</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">-></span>next <span class="token operator">&amp;&amp;</span> b<span class="token operator">-></span>next<span class="token operator">-></span>free                    <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>b<span class="token operator">-></span>size <span class="token operator">+</span> BLOCK_SIZE <span class="token operator">+</span> b<span class="token operator">-></span>next<span class="token operator">-></span>size<span class="token punctuation">)</span> <span class="token operator">>=</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">fusion</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">-></span>size <span class="token operator">-</span> s <span class="token operator">>=</span> <span class="token punctuation">(</span>BLOCK_SIZE <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token function">split_block</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">/* 新malloc */</span>                newp <span class="token operator">=</span> <span class="token function">malloc</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>newp<span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                new <span class="token operator">=</span> <span class="token function">get_block</span><span class="token punctuation">(</span>newp<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">copy_block</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> new<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">(</span>newp<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-遗留问题和优化"><a href="#3-3-遗留问题和优化" class="headerlink" title="3.3 遗留问题和优化"></a>3.3 遗留问题和优化</h3><p>以上是一个较为简陋，但是初步可用的malloc实现。还有很多遗留的可能优化点，例如：</p><ul><li>同时兼容32位和64位系统</li><li>在分配较大快内存时，考虑使用mmap而非sbrk，这通常更高效</li><li>可以考虑维护多个链表而非单个，每个链表中的block大小均为一个范围内，例如8字节链表、16字节链表、24-32字节链表等等。此时可以根据size到对应链表中做分配，可以有效减少碎片，并提高查询block的速度</li><li>可以考虑链表中只存放free的block，而不存放已分配的block，可以减少查找block的次数，提高效率</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-什么是malloc&quot;&gt;&lt;a href=&quot;#1-什么是malloc&quot; class=&quot;headerlink&quot; title=&quot;1 什么是malloc&quot;&gt;&lt;/a&gt;1 什么是malloc&lt;/h2&gt;&lt;p&gt;在实现malloc之前，先要相对正式地对malloc做一个定义。&lt;/
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Effective Cpp：条款 &amp; 实践</title>
    <link href="https://joytsing.github.io/posts/22113/"/>
    <id>https://joytsing.github.io/posts/22113/</id>
    <published>2023-12-16T12:23:38.000Z</published>
    <updated>2023-12-16T12:26:10.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章：让自己习惯-C"><a href="#第一章：让自己习惯-C" class="headerlink" title="第一章：让自己习惯 C++"></a>第一章：让自己习惯 C++</h2><h3 id="条款-1：视-C-为一个语言联邦"><a href="#条款-1：视-C-为一个语言联邦" class="headerlink" title="条款 1：视 C++ 为一个语言联邦"></a>条款 1：视 C++ 为一个语言联邦</h3><p>C++ 拥有多种不同的编程范式，而这些范式集成在一个语言中，使得 C++ 是一门即灵活又复杂的语言：</p><ol><li>传统的面向过程 C：区块，语句，预处理器，内置数据类型，数组，指针。</li><li>面向对象的 C with Classes：类，封装，继承，多态，动态绑定。</li><li>模板编程 Template C++ 和堪称黑魔法的模板元编程（TMP）。</li><li>C++ 标准库 STL。</li></ol><p>C++ 高效编程守则视情况而变化，程序设计没有银弹。</p><h3 id="条款-2：尽量以-const-enum-inline-替换-define"><a href="#条款-2：尽量以-const-enum-inline-替换-define" class="headerlink" title="条款 2：尽量以 const, enum, inline 替换 #define"></a>条款 2：尽量以 const, enum, inline 替换 #define</h3><p>在原书写成时 C++11 中的<code>constexpr</code>还未诞生，现在一般认为应当用<code>constexpr</code>定义编译期常量来替代大部分的<code>#define</code>宏常量定义：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">define</span> ASPECT_RATIO 1.653</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>替代为：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">auto</span> aspect_ratio <span class="token operator">=</span> <span class="token number">1.653</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们也可以将编译期常量定义为类的静态成员：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">GamePlayer</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> <span class="token keyword">auto</span> numTurns <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>enum</code>可以用于替代整型的常量，并且在模板元编程中应用广泛（见条款 48）：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">GamePlayer</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">enum</span> <span class="token punctuation">{</span> numTurns <span class="token operator">=</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>大部分<code>#define</code>宏常量应当用内联模板函数替代：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">define</span> CALL_WITH_MAX(a, b) f((a) > (b) ? (a) : (b))</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>替代为：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">CallWithMax</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">f</span><span class="token punctuation">(</span>a <span class="token operator">></span> b <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，宏和函数的行为本身并不完全一致，宏只是简单的替换，并不涉及传参和复制。</p><h3 id="条款-3：尽可能使用-const"><a href="#条款-3：尽可能使用-const" class="headerlink" title="条款 3：尽可能使用 const"></a>条款 3：尽可能使用 const</h3><p>若你想让一个常量只读，那你应该明确说出它是const常量，对于指针来说，更是如此：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">char</span> greeting<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span> p <span class="token operator">=</span> greeting<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 指针可修改，数据可修改</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> p <span class="token operator">=</span> greeting<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 指针可修改，数据不可修改</span><span class="token keyword">char</span> <span class="token keyword">const</span><span class="token operator">*</span> p <span class="token operator">=</span> greeting<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 指针可修改，数据不可修改</span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> p <span class="token operator">=</span> greeting<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 指针不可修改，数据可修改</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> p <span class="token operator">=</span> greeting<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 指针不可修改，数据不可修改</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于 STL 迭代器，分清使用<code>const</code>还是<code>const_iterator</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator iter <span class="token operator">=</span> vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 迭代器不可修改，数据可修改</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>const_iterator iter <span class="token operator">=</span> vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 迭代器可修改，数据不可修改</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>面对函数声明时，如果你不想让一个函数的结果被无意义地当作左值，请使用const返回值：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>const成员函数：</strong></p><p>const成员函数允许我们操控const对象，这在传递常引用时显得尤为重要：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">TextBlock</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t position<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// const对象使用的重载</span>        <span class="token keyword">return</span> text<span class="token punctuation">[</span>position<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">char</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t position<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// non-const对象使用的重载</span>        <span class="token keyword">return</span> text<span class="token punctuation">[</span>position<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>string text<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，const和non-const对象都有其各自的重载版本：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token keyword">const</span> Textblock<span class="token operator">&amp;</span> ctb<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> ctb<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 调用 const TextBlock::operator[]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>编译器对待const对象的态度通常是 bitwise constness，而我们在编写程序时通常采用 logical constness，这就意味着，在确保客户端不会察觉的情况下，我们认为const对象中的某些成员变量应当是允许被改变的，使用关键字<code>mutable</code>来标记这些成员变量：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">CTextBlock</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    std<span class="token operator">::</span>size_t <span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">char</span><span class="token operator">*</span> pText<span class="token punctuation">;</span>    <span class="token keyword">mutable</span> std<span class="token operator">::</span>size_t textLength<span class="token punctuation">;</span>    <span class="token keyword">mutable</span> <span class="token keyword">bool</span> lengthIsValid<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span>size_t CTextBlock<span class="token operator">::</span><span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>lengthIsValid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        textLength <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">strlen</span><span class="token punctuation">(</span>pText<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 可以修改mutable成员变量</span>        lengthIsValid <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 可以修改mutable成员变量</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> textLength<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在重载const和non-const成员函数时，需要尽可能避免书写重复的内容，这促使我们去进行常量性转除。在大部分情况下，我们应当避免转型的出现，但在此处为了减少重复代码，转型是适当的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">TextBlock</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t position<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 假设这里有非常多的代码</span>        <span class="token keyword">return</span> text<span class="token punctuation">[</span>position<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">char</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t position<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">const</span> TextBlock<span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">[</span>position<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>string text<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，反向做法：令const版本调用non-const版本以避免重复——并不被建议，一般而言const版本的限制比non-const版本的限制更多，因此这样做会带来风险。</p><h3 id="条款-4：确定对象在使用前已被初始化"><a href="#条款-4：确定对象在使用前已被初始化" class="headerlink" title="条款 4：确定对象在使用前已被初始化"></a>条款 4：确定对象在使用前已被初始化</h3><p>无初值对象在 C/C++ 中广泛存在，因此这一条款就尤为重要。在定义完一个对象后需要尽快为它赋初值：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> text <span class="token operator">=</span> <span class="token string">"A C-style string"</span><span class="token punctuation">;</span><span class="token keyword">double</span> d<span class="token punctuation">;</span>std<span class="token operator">::</span>cin <span class="token operator">>></span> d<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于类中的成员变量而言，我们有两种建议的方法完成初始化工作，一种是直接在定义处赋初值（since C++11）：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">CTextBlock</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>size_t textLength<span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">bool</span> lengthIsValid<span class="token punctuation">{</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一种是使用构造函数成员初始化列表：</p><pre class="line-numbers language-cpp"><code class="language-cpp">ABEntry<span class="token operator">::</span><span class="token function">ABEntry</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> name<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> address<span class="token punctuation">,</span>                 <span class="token keyword">const</span> std<span class="token operator">::</span>list<span class="token operator">&lt;</span>PhoneNumber<span class="token operator">></span><span class="token operator">&amp;</span> phones<span class="token punctuation">)</span>    <span class="token operator">:</span> <span class="token function">theName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">theAddress</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">thePhones</span><span class="token punctuation">(</span>phones<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">numTimesConsulted</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>成员初始化列表也可以留空用来执行默认构造函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp">ABEntry<span class="token operator">::</span><span class="token function">ABEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token operator">:</span> <span class="token function">theName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">theAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">thePhones</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">numTimesConsulted</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，类中成员的初始化具有次序性，而这次序与成员变量的声明次序一致，与成员初始化列表的次序无关。</p><blockquote><p>类中成员的初始化是可选的，但是引用类型必须初始化。</p></blockquote><p><strong>静态对象的初始化：</strong></p><p>C++ 对于定义于不同编译单元内的全局静态对象的初始化相对次序并无明确定义，因此，以下代码可能会出现使用未初始化静态对象的情况：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// File 1</span><span class="token keyword">extern</span> FileSystem tfs<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// File 2</span><span class="token keyword">class</span> <span class="token class-name">Directory</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Directory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        FileSystem disk <span class="token operator">=</span> tfs<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Directory tempDir<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面这个例子中，你无法确保位于不同编译单元内的<code>tfs</code>一定在<code>tempDir</code>之前初始化完成。</p><p>这个问题的一个有效解决方案是采用 <strong>Meyers’ singleton</strong>，将全局静态对象转化为局部静态对象：</p><pre class="line-numbers language-cpp"><code class="language-cpp">FileSystem<span class="token operator">&amp;</span> <span class="token function">tfs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> FileSystem fs<span class="token punctuation">;</span>    <span class="token keyword">return</span> fs<span class="token punctuation">;</span><span class="token punctuation">}</span>Directory<span class="token operator">&amp;</span> <span class="token function">tempDir</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> Directory td<span class="token punctuation">;</span>    <span class="token keyword">return</span> td<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个手法的基础在于：C++ 保证，函数内的局部静态对象会在<strong>该函数被调用期间</strong>和<strong>首次遇上该对象之定义式</strong>时被初始化。</p><p>当然，这种做法对于多线程来说并不具有优势，最好还是在单线程启动阶段手动调用函数完成初始化。</p><h2 id="第二章：构造-析构-赋值运算"><a href="#第二章：构造-析构-赋值运算" class="headerlink" title="第二章：构造/析构/赋值运算"></a>第二章：构造/析构/赋值运算</h2><h3 id="条款-5：了解-C-默默编写并调用哪些函数"><a href="#条款-5：了解-C-默默编写并调用哪些函数" class="headerlink" title="条款 5：了解 C++ 默默编写并调用哪些函数"></a>条款 5：了解 C++ 默默编写并调用哪些函数</h3><p>C++ 中的空类并不是真正意义上的空类，编译器会为它预留以下内容：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Empty</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>                           <span class="token comment" spellcheck="true">// 默认构造函数（没有任何构造函数时）</span>    <span class="token function">Empty</span><span class="token punctuation">(</span><span class="token keyword">const</span> Empty<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>               <span class="token comment" spellcheck="true">// 拷贝构造函数</span>    <span class="token function">Empty</span><span class="token punctuation">(</span>Empty<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">// 移动构造函数 (since C++11)</span>    <span class="token operator">~</span><span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>                          <span class="token comment" spellcheck="true">// 析构函数</span>    Empty<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Empty<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 拷贝赋值运算符</span>    Empty<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Empty<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>         <span class="token comment" spellcheck="true">// 移动赋值运算符 (since C++11)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>唯有当这些函数被调用时，它们才会真正被编译器创建出来，下面代码将造成上述每一个函数被创建：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Empty e1<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 默认构造函数 &amp; 析构函数</span>Empty <span class="token function">e2</span><span class="token punctuation">(</span>e1<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 拷贝构造函数</span>Empty e3 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>e2<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 移动构造函数 (since C++11)</span>e2 <span class="token operator">=</span> e1<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 拷贝赋值运算符</span>e3 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>e1<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 移动赋值运算符 (since C++11)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，拷贝赋值运算符只有在允许存在时才会自动创建，比如以下情况：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">NamedObject</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>string<span class="token operator">&amp;</span> nameValue<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在该类中，我们有一个string引用类型，然而引用无法指向不同对象，因此编译器会拒绝为该类创建一个默认的拷贝赋值运算符。</p><p>除此之外，以下情形也会导致拷贝赋值运算符不会自动创建：</p><ol><li>类中含有const成员。</li><li>基类中含有private的拷贝赋值运算符。</li></ol><h3 id="条款-6：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款-6：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款 6：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款 6：若不想使用编译器自动生成的函数，就该明确拒绝</h3><p>原书中使用的做法是将不想使用的函数声明为private，但在 C++11 后我们有了更好的做法：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Uncopyable</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Uncopyable</span><span class="token punctuation">(</span><span class="token keyword">const</span> Uncopyable<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>    Uncopyable<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Uncopyable<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-7：为多态基类声明虚析构函数"><a href="#条款-7：为多态基类声明虚析构函数" class="headerlink" title="条款 7：为多态基类声明虚析构函数"></a>条款 7：为多态基类声明虚析构函数</h3><p>当派生类对象经由一个基类指针被删除，而该基类指针带着一个非虚析构函数，其结果是未定义的，可能会无法完全销毁派生类的成员，造成内存泄漏。消除这个问题的方法就是对基类使用虚析构函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你不想让一个类成为基类，那么在类中声明虚函数是是一个坏主意，因为额外存储的虚表指针会使类的体积变大。</p><blockquote><p>只要基类的析构函数是虚函数，那么派生类的析构函数不论是否用virtual关键字声明，都自动成为虚析构函数。</p></blockquote><p>虚析构函数的运作方式是，最深层派生的那个类的析构函数最先被调用，然后是其上的基类的析构函数被依次调用。</p><p>如果你想将基类作为抽象类使用，但手头上又没有别的虚函数，那么将它的析构函数设为纯虚函数是一个不错的想法。考虑以下情形：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但若此时从该基类中派生出新的类，会发生报错，这是因为编译器无法找到基类的析构函数的实现。因此，即使是纯虚析构函数，也需要一个函数体：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Base<span class="token operator">::</span><span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者以下写法也被允许：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-8：别让异常逃离析构函数"><a href="#条款-8：别让异常逃离析构函数" class="headerlink" title="条款 8：别让异常逃离析构函数"></a>条款 8：别让异常逃离析构函数</h3><p>在析构函数中吐出异常并不被禁止，但为了程序的可靠性，应当极力避免这种行为。</p><p>为了实现 RAII，我们通常会将对象的销毁方法封装在析构函数中，如下例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">DBConn</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token operator">~</span><span class="token function">DBConn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        db<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 该函数可能会抛出异常</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    DBConnection db<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但这样我们就需要在析构函数中完成对异常的处理，以下是几种常见的做法：</p><p>第一种：杀死程序：</p><pre class="line-numbers language-cpp"><code class="language-cpp">DBConn<span class="token operator">::</span><span class="token operator">~</span><span class="token function">DBConn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span> db<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 记录运行日志，以便调试</span>        std<span class="token operator">::</span><span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二种：直接吞下异常不做处理，但这种做法不被建议。</p><p>第三种：重新设计接口，将异常的处理交给客户端完成：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">DBConn</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        db<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        closed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">DBConn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>closed<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                db<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 处理异常</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    DBConnection db<span class="token punctuation">;</span>    <span class="token keyword">bool</span> closed<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个新设计的接口中，我们提供了<code>close</code>函数供客户手动调用，这样客户也可以根据自己的意愿处理异常；若客户忘记手动调用，析构函数才会自动调用<code>close</code>函数。</p><p>当一个操作可能会抛出需要客户处理的异常时，将其暴露在普通函数而非析构函数中是一个更好的选择。</p><h3 id="条款-9：绝不在构造和析构过程中调用虚函数"><a href="#条款-9：绝不在构造和析构过程中调用虚函数" class="headerlink" title="条款 9：绝不在构造和析构过程中调用虚函数"></a>条款 9：绝不在构造和析构过程中调用虚函数</h3><p>在创建派生类对象时，基类的构造函数永远会早于派生类的构造函数被调用，而基类的析构函数永远会晚于派生类的析构函数被调用。</p><p>在派生类对象的基类构造和析构期间，对象的类型是基类而非派生类，因此此时调用虚函数会被编译器解析至基类的虚函数版本，通常不会得到我们想要的结果。</p><p>间接调用虚函数是一个比较难以发现的危险行为，需要尽量避免：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Transaction</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Transaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">LogTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token function">LogTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 此处间接调用了虚函数！</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果想要基类在构造时就得知派生类的构造信息，推荐的做法是在派生类的构造函数中将必要的信息向上传递给基类的构造函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Transaction</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">explicit</span> <span class="token function">Transaction</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> logInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">LogTransaction</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> logInfo<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Transaction<span class="token operator">::</span><span class="token function">Transaction</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> logInfo<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">LogTransaction</span><span class="token punctuation">(</span>logInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>                           <span class="token comment" spellcheck="true">// 更改为了非虚函数调用</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">BuyTransaction</span> <span class="token operator">:</span> <span class="token keyword">public</span> Transaction <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">BuyTransaction</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">Transaction</span><span class="token punctuation">(</span><span class="token function">CreateLogString</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 将信息传递给基类构造函数</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">static</span> std<span class="token operator">::</span>string <span class="token function">CreateLogString</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意此处的<code>CreateLogString</code>是一个静态成员函数，这是很重要的，因为静态成员函数可以确保不会使用未完成初始化的成员变量。</p><h3 id="条款-10：令-operator-返回一个指向-this-的引用"><a href="#条款-10：令-operator-返回一个指向-this-的引用" class="headerlink" title="条款 10：令 operator= 返回一个指向 *this 的引用"></a>条款 10：令 operator= 返回一个指向 *this 的引用</h3><p>虽然并不强制执行此条款，但为了实现连锁赋值，大部分时候应该这样做：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">+</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 这个条款适用于</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                    <span class="token comment" spellcheck="true">// +=, -=, *= 等等运算符</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">// 即使参数类型不是 Widget&amp; 也适用</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-11：在-operator-中处理“自我赋值”"><a href="#条款-11：在-operator-中处理“自我赋值”" class="headerlink" title="条款 11：在 operator= 中处理“自我赋值”"></a>条款 11：在 operator= 中处理“自我赋值”</h3><p>自我赋值是合法的操作，但在一些情况下可能会导致意外的错误，例如在复制堆上的资源时：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">+</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">delete</span> pRes<span class="token punctuation">;</span>                          <span class="token comment" spellcheck="true">// 删除当前持有的资源</span>    pRes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Resource</span><span class="token punctuation">(</span><span class="token operator">*</span>rhs<span class="token punctuation">.</span>pRes<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 复制传入的资源</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但若<code>rhs</code>和<code>*this</code>指向的是相同的对象，就会导致访问到已删除的数据。</p><p>最简单的解决方法是在执行后续语句前先进行<strong>证同测试（Identity test）</strong>：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 若是自我赋值，则不做任何事</span>    <span class="token keyword">delete</span> pRes<span class="token punctuation">;</span>    pRes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Resource</span><span class="token punctuation">(</span><span class="token operator">*</span>rhs<span class="token punctuation">.</span>pRes<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一个常见的做法是只关注异常安全性，而不关注是否自我赋值：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Resource<span class="token operator">*</span> pOrigin <span class="token operator">=</span> pRes<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 先记住原来的pRes指针</span>    pRes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Resource</span><span class="token punctuation">(</span><span class="token operator">*</span>rhs<span class="token punctuation">.</span>pRes<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 复制传入的资源</span>    <span class="token keyword">delete</span> pOrigin<span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">// 删除原来的资源</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>仅仅是适当安排语句的顺序，就可以做到使整个过程具有异常安全性。</p><p>还有一种取巧的做法是使用 copy and swap 技术，这种技术聪明地利用了栈空间会自动释放的特性，这样就可以通过析构函数来实现资源的释放：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Widget <span class="token function">temp</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述做法还可以写得更加巧妙，就是利用按值传参，自动调用构造函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Widget rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">,</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-12：复制对象时勿忘其每一个成分"><a href="#条款-12：复制对象时勿忘其每一个成分" class="headerlink" title="条款 12：复制对象时勿忘其每一个成分"></a>条款 12：复制对象时勿忘其每一个成分</h3><p>这个条款正如其字面意思，当你决定手动实现拷贝构造函数或拷贝赋值运算符时，忘记复制任何一个成员都可能会导致意外的错误。</p><p>当使用继承时，继承自基类的成员往往容易忘记在派生类中完成复制，如果你的基类拥有拷贝构造函数和拷贝赋值运算符，应该记得调用它们：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">PriorityCustomer</span> <span class="token operator">:</span> <span class="token keyword">public</span> Customer <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">PriorityCustomer</span><span class="token punctuation">(</span><span class="token keyword">const</span> PriorityCustomer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    PriorityCustomer<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> PriorityCustomer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> priority<span class="token punctuation">;</span><span class="token punctuation">}</span>PriorityCustomer<span class="token operator">::</span><span class="token function">PriorityCustomer</span><span class="token punctuation">(</span><span class="token keyword">const</span> PriorityCustomer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>    <span class="token operator">:</span> <span class="token function">Customer</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token comment" spellcheck="true">// 调用基类的拷贝构造函数</span>      <span class="token function">priority</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>priority<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>PriorityCustomer<span class="token operator">::</span>PriorityCustomer<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> PriorityCustomer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Customer<span class="token operator">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 调用基类的拷贝赋值运算符</span>    priority <span class="token operator">=</span> rhs<span class="token punctuation">.</span>priority<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，不要尝试在拷贝构造函数中调用拷贝赋值运算符，或在拷贝赋值运算符的实现中调用拷贝构造函数，一个在初始化时，一个在初始化后，它们的功用是不同的。</p><h2 id="第三章：资源管理"><a href="#第三章：资源管理" class="headerlink" title="第三章：资源管理"></a>第三章：资源管理</h2><h3 id="条款-13：以对象管理资源"><a href="#条款-13：以对象管理资源" class="headerlink" title="条款 13：以对象管理资源"></a>条款 13：以对象管理资源</h3><p>对于传统的堆资源管理，我们需要使用成对的<code>new</code>和<code>delete</code>，这样若忘记<code>delete</code>就会造成内存泄露。因此，我们应尽可能以对象管理资源，并采用RAII（Resource Acquisition Is Initialize，资源取得时机便是初始化时机），让析构函数负责资源的释放。</p><p>原书此处关于智能指针的内容已经过时，在 C++11 中，通过专一所有权来管理RAII对象可以使用<code>std::unique_ptr</code>，通过引用计数来管理RAII对象可以使用<code>std::shared_ptr</code>。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// Investment* CreateInvestment();</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Investment<span class="token operator">></span> <span class="token function">pUniqueInv1</span><span class="token punctuation">(</span><span class="token function">CreateInvestment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Investment<span class="token operator">></span> <span class="token function">pUniqueInv2</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>pUniqueInv1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 转移资源所有权</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Investment<span class="token operator">></span> <span class="token function">pSharedInv1</span><span class="token punctuation">(</span><span class="token function">CreateInvestment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Investment<span class="token operator">></span> <span class="token function">pSharedInv2</span><span class="token punctuation">(</span>pSharedInv1<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 引用计数+1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>智能指针默认会自动delete所持有的对象，我们也可以为智能指针指定所管理对象的释放方式（删除器deleter）：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// void GetRidOfInvestment(Investment*) {}</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Investment<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>GetRidOfInvestment<span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">></span> <span class="token function">pUniqueInv</span><span class="token punctuation">(</span><span class="token function">CreateInvestment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> GetRidOfInvestment<span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Investment<span class="token operator">></span> <span class="token function">pSharedInv</span><span class="token punctuation">(</span><span class="token function">CreateInvestment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> GetRidOfInvestment<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-14：在资源管理类中小心拷贝行为"><a href="#条款-14：在资源管理类中小心拷贝行为" class="headerlink" title="条款 14：在资源管理类中小心拷贝行为"></a>条款 14：在资源管理类中小心拷贝行为</h3><p>我们应该永远保持这样的思考：当一个RAII对象被复制，会发生什么事？</p><p><strong>选择一：禁止复制</strong></p><p>许多时候允许RAII对象被复制并不合理，如果确是如此，那么就该明确禁止复制行为，条款 6 已经阐述了怎么做这件事。</p><p><strong>选择二：对底层资源祭出“引用计数法”</strong></p><p>正如<code>std::shared_ptr</code>所做的那样，每一次复制对象就使引用计数+1，每一个对象离开定义域就调用析构函数使引用计数-1，直到引用计数为0就彻底销毁资源。</p><p><strong>选择三：复制底层资源</strong></p><p>在复制对象的同时复制底层资源的行为又被称作<strong>深拷贝（Deep copying）</strong>，例如在一个对象中有一个指针，那么在复制这个对象时就不能只复制指针，也要复制指针所指向的数据。</p><p><strong>选择四：转移底层资源的所有权</strong></p><p>和<code>std::unique_ptr</code>的行为类似，永远保持只有一个对象拥有对资源的管理权，当需要复制对象时转移资源的管理权。</p><h3 id="条款-15：在资源管理类中提供对原始资源的访问"><a href="#条款-15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款 15：在资源管理类中提供对原始资源的访问"></a>条款 15：在资源管理类中提供对原始资源的访问</h3><p>和所有的智能指针一样，STL 中的智能指针也提供了对原始资源的隐式访问和显式访问：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Investment<span class="token operator">*</span> pRaw <span class="token operator">=</span> pSharedInv<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 显式访问原始资源</span>Investment raw <span class="token operator">=</span> <span class="token operator">*</span>pSharedInv<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 隐式访问原始资源</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当我们在设计自己的资源管理类时，也要考虑在提供对原始资源的访问时，是使用显式访问还是隐式访问的方法，还是两者皆可。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Font</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    FontHandle <span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> handle<span class="token punctuation">;</span> <span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">// 显式转换函数</span>    <span class="token keyword">operator</span> <span class="token function">FontHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> handle<span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 隐式转换函数</span><span class="token keyword">private</span><span class="token operator">:</span>    FontHandle handle<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般而言显式转换比较安全，但隐式转换对客户比较方便。</p><h3 id="条款-16：成对使用-new-和-delete-时要采用相同形式"><a href="#条款-16：成对使用-new-和-delete-时要采用相同形式" class="headerlink" title="条款 16：成对使用 new 和 delete 时要采用相同形式"></a>条款 16：成对使用 new 和 delete 时要采用相同形式</h3><p>使用<code>new</code>来分配单一对象，使用<code>new[]</code>来分配对象数组，必须明确它们的行为并不一致，分配对象数组时会额外在内存中记录“数组大小”，而使用<code>delete[]</code>会根据记录的数组大小多次调用析构函数，使用<code>delete</code>则仅仅只会调用一次析构函数。对于单一对象使用<code>delete[]</code>其结果也是未定义的，程序可能会读取若干内存并将其错误地解释为数组大小。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">*</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token operator">*</span> object <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">;</span><span class="token keyword">delete</span> object<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，使用<code>typedef</code>定义数组类型会带来额外的风险：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> std<span class="token operator">::</span>string AddressLines<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>std<span class="token operator">::</span>string<span class="token operator">*</span> pal <span class="token operator">=</span> <span class="token keyword">new</span> AddressLines<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// pal 是一个对象数组，而非单一对象</span><span class="token keyword">delete</span> pal<span class="token punctuation">;</span>                             <span class="token comment" spellcheck="true">// 行为未定义</span><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pal<span class="token punctuation">;</span>                           <span class="token comment" spellcheck="true">// 正确</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-17：以独立语句将-newed-对象置入智能指针"><a href="#条款-17：以独立语句将-newed-对象置入智能指针" class="headerlink" title="条款 17：以独立语句将 newed 对象置入智能指针"></a>条款 17：以独立语句将 newed 对象置入智能指针</h3><p>原书此处所讲已过时，现在更好的做法是使用<code>std::make_unique</code>和<code>std::make_shared</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> pUniqueInv <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Investment<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// since C++14</span><span class="token keyword">auto</span> pSharedInv <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>Investment<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// since C++11</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="第四章：设计与声明"><a href="#第四章：设计与声明" class="headerlink" title="第四章：设计与声明"></a>第四章：设计与声明</h2><h3 id="条款-18：让接口容易被正确使用，不易被误用"><a href="#条款-18：让接口容易被正确使用，不易被误用" class="headerlink" title="条款 18：让接口容易被正确使用，不易被误用"></a>条款 18：让接口容易被正确使用，不易被误用</h3><ol><li>好的接口很容易被正确使用，不易被误用。你应在在你的所有接口中努力达成这些性质。</li><li>“促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容。</li><li>“阻止误用”的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。</li></ol><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 三个参数类型相同的函数容易造成误用</span>Data<span class="token operator">::</span><span class="token function">Data</span><span class="token punctuation">(</span><span class="token keyword">int</span> month<span class="token punctuation">,</span> <span class="token keyword">int</span> day<span class="token punctuation">,</span> <span class="token keyword">int</span> year<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 通过适当定义新的类型加以限制，降低误用的可能性</span>Data<span class="token operator">::</span><span class="token function">Data</span><span class="token punctuation">(</span><span class="token keyword">const</span> Month<span class="token operator">&amp;</span> m<span class="token punctuation">,</span> <span class="token keyword">const</span> Day<span class="token operator">&amp;</span> d<span class="token punctuation">,</span> <span class="token keyword">const</span> Year<span class="token operator">&amp;</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>尽量使用智能指针，避免跨DLL的 new 和 delete，使用智能指针自定义删除器来解除互斥锁（mutexes）。</li></ol><h3 id="条款-19：设计-class-犹如设计-type"><a href="#条款-19：设计-class-犹如设计-type" class="headerlink" title="条款 19：设计 class 犹如设计 type"></a>条款 19：设计 class 犹如设计 type</h3><p>几乎在设计每一个 class 时，都要面对如下问题：</p><p><strong>新 type 对象应该如何被创建和销毁？</strong> 这会影响到类中构造函数、析构函数、内存分配和释放函数（<code>operator new</code>，<code>operator new[]</code>，<code>operator delete</code>，<code>operator delete[]</code>）的设计。</p><p><strong>对象的初始化和赋值该有什么样的差别？</strong> 这会影响到构造函数和拷贝赋值运算之间行为的差异。</p><p><strong>新 type 的对象如果被按值传递，意味着什么？</strong> 这会影响到拷贝构造函数的实现。</p><p><strong>什么是新 type 的合法值？</strong> 你的类中的成员函数必须对类中成员变量的值进行检查，如果不合法就要尽快解决或明确地抛出异常。</p><p><strong>你的新 type 需要配合某个继承图系吗？</strong> 你的类是否受到基类设计地束缚，是否拥有该覆写地虚函数，是否允许被继承（若不想要被继承，应该声明为<code>final</code>）。</p><p><strong>什么样的运算符和函数对此新 type 而言是合理的？</strong> 这会影响到你将为你的类声明哪些函数和重载哪些运算符。</p><p><strong>什么样的标准函数应该被驳回？</strong> 这会影响到你将哪些标准函数声明为<code>= delete</code>。</p><p><strong>谁该取用新 type 的成员？</strong> 这会影响到你将类中哪些成员设为 public，private 或 protected，也将影响到友元类和友元函数的设置。</p><p><strong>什么是新 type 的“未声明接口”？</strong> 为未声明接口提供效率、异常安全性以及资源运用上的保证，并在实现代码中加上相应的约束条件。</p><p><strong>你的新 type 有多么一般化？</strong> 如果你想要一系列新 type 家族，应该优先考虑模板类。</p><h3 id="条款-20：宁以按常引用传参替换按值传参"><a href="#条款-20：宁以按常引用传参替换按值传参" class="headerlink" title="条款 20：宁以按常引用传参替换按值传参"></a>条款 20：宁以按常引用传参替换按值传参</h3><p>当使用按值传参时，程序会调用对象的拷贝构造函数构建一个在函数内作用的局部对象，这个过程的开销可能会较为昂贵。对于任何用户自定义类型，使用按常引用传参是较为推荐的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">ValidateStudent</span><span class="token punctuation">(</span><span class="token keyword">const</span> Student<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为没有任何新对象被创建，这种传参方式不会调用任何构造函数或析构函数，所以效率比按值传参高得多。</p><p>使用按引用传参也可以避免<strong>对象切片（Object slicing）</strong> 的问题，参考以下例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Window</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    std<span class="token operator">::</span>string <span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">WindowWithScrollBars</span> <span class="token operator">:</span> <span class="token keyword">public</span> Window <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> override<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此处一个<code>WindowWithScrollBars</code>类继承自<code>Window</code>基类。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">PrintNameAndDisplay</span><span class="token punctuation">(</span>Window w<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 按值传参，会发生对象切片</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> w<span class="token punctuation">.</span><span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    w<span class="token punctuation">.</span><span class="token function">Display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>此处在传参时，调用了基类<code>Window</code>的拷贝构造函数而非派生类的拷贝构造函数，因此在函数种使用的是一个<code>Window</code>对象，调用虚函数时也只能调用到基类的虚函数<code>Window::Display</code>。</p><p>由于按引用传递不会创建新对象，这个问题就能得到避免：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">PrintNameAndDisplay</span><span class="token punctuation">(</span><span class="token keyword">const</span> Window<span class="token operator">&amp;</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 参数不会被切片</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> w<span class="token punctuation">.</span><span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    w<span class="token punctuation">.</span><span class="token function">Display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>也并非永远都使用按引用传参，对于内置类型、STL的迭代器和函数对象，我们认为使用按值传参是比较合适的。</p><h3 id="条款-21：必须返回对象时，别妄想返回其引用"><a href="#条款-21：必须返回对象时，别妄想返回其引用" class="headerlink" title="条款 21：必须返回对象时，别妄想返回其引用"></a>条款 21：必须返回对象时，别妄想返回其引用</h3><p>返回一个指向函数内部局部变量的引用是严重的错误，因为局部变量在离开函数时就被销毁了，除此之外，返回一个指向局部静态变量的引用也是不被推荐的。</p><p>尽管返回对象会调用拷贝构造函数产生开销，但这开销比起出错而言微不足道。</p><h3 id="条款-22：将成员变量声明为-private"><a href="#条款-22：将成员变量声明为-private" class="headerlink" title="条款 22：将成员变量声明为 private"></a>条款 22：将成员变量声明为 private</h3><p>出于对封装性的考虑，应该尽可能地隐藏类中的成员变量，并通过对外暴露函数接口来实现对成员变量的访问：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">AccessLevels</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">GetReadOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> readOnly<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">SetReadWrite</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> readWrite <span class="token operator">=</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">GetReadWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> readWrite<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">SetWriteOnly</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> writeOnly <span class="token operator">=</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> noAccess<span class="token punctuation">;</span>    <span class="token keyword">int</span> readOnly<span class="token punctuation">;</span>    <span class="token keyword">int</span> readWrite<span class="token punctuation">;</span>    <span class="token keyword">int</span> writeOnly<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过为成员变量提供 getter 和 setter 函数，我们就能避免客户做出写入只读变量或读取只写变量这样不被允许的操作。</p><p>将成员变量隐藏在函数接口的背后，可以为“所有可能的实现”提供弹性。例如这可使得在成员变量被读或写时轻松通知其它对象，可以验证类的约束条件以及函数的提前和事后状态，可以在多线程环境中执行同步控制……</p><p><code>protected</code>和<code>public</code>一样，都不该被优先考虑。假设我们有一个public成员变量，最终取消了它，那么所有使用它的客户代码都将被破坏；假设我们有一个protected成员变量，最终取消了它，那么所有使用它的派生类都将被破坏。</p><p>综合以上讨论，在类中应当将成员变量优先声明为 private。</p><h3 id="条款-23：宁以非成员、非友元函数替换成员函数"><a href="#条款-23：宁以非成员、非友元函数替换成员函数" class="headerlink" title="条款 23：宁以非成员、非友元函数替换成员函数"></a>条款 23：宁以非成员、非友元函数替换成员函数</h3><p>假设有这样一个类：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">WebBrowser</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">void</span> <span class="token function">ClearCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">ClearHistory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">RemoveCookies</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果想要一次性调用这三个函数，那么需要额外提供一个新的函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">ClearEverything</span><span class="token punctuation">(</span>WebBrowser<span class="token operator">&amp;</span> wb<span class="token punctuation">)</span> <span class="token punctuation">{</span>    wb<span class="token punctuation">.</span><span class="token function">ClearCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    wb<span class="token punctuation">.</span><span class="token function">ClearHistory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    wb<span class="token punctuation">.</span><span class="token function">RemoveCookies</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，虽然成员函数和非成员函数都可以完成我们的目标，但此处更建议使用非成员函数，这是为了遵守一个原则：<strong>越少的代码可以访问数据，数据的封装性就越强</strong>。此处的<code>ClearEverything</code>函数仅仅是调用了<code>WebBrowser</code>的三个public成员函数，而并没有使用到<code>WebBrowser</code>内部的private成员，因此没有必要让其也拥有访问类中private成员的能力。</p><p>这个原则对于友元函数也是相同的，因为友元函数和成员函数拥有相同的权力，所以在能使用非成员函数完成任务的情况下，就不要使用友元函数和成员函数。</p><p>如果你觉得一个全局函数并不自然，也可以考虑将<code>ClearEverything</code>函数放在工具类中充当静态成员函数，或与<code>WebBrowser</code>放在同一个命名空间中：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">namespace</span> WebBrowserStuff <span class="token punctuation">{</span>    <span class="token keyword">class</span> <span class="token class-name">WebBrowser</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">ClearEverything</span><span class="token punctuation">(</span>WebBrowser<span class="token operator">&amp;</span> wb<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-24：若所有参数皆需类型转换，请为此采用非成员函数"><a href="#条款-24：若所有参数皆需类型转换，请为此采用非成员函数" class="headerlink" title="条款 24：若所有参数皆需类型转换，请为此采用非成员函数"></a>条款 24：若所有参数皆需类型转换，请为此采用非成员函数</h3><p>现在我们手头上拥有一个<code>Rational</code>类，并且它可以和<code>int</code>隐式转换：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Rational</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Rational</span><span class="token punctuation">(</span><span class="token keyword">int</span> numerator <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> denominator <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，我们需要重载乘法运算符来实现<code>Rational</code>对象之间的乘法：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Rational</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将运算符重载放在类中是行得通的，至少对于<code>Rational</code>对象来说是如此。但当我们考虑混合运算时，就会出现一个问题：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Rational <span class="token function">oneEight</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Rational <span class="token function">oneHalf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Rational result <span class="token operator">=</span> oneHalf <span class="token operator">/</span> oneEight<span class="token punctuation">;</span>result <span class="token operator">=</span> oneHalf <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 正确</span>result <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> oneHalf<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 报错</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假如将乘法运算符写成函数形式，错误的原因就一目了然了：</p><pre class="line-numbers language-cpp"><code class="language-cpp">result <span class="token operator">=</span> oneHalf<span class="token punctuation">.</span><span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 正确</span>result <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">.</span><span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span>oneHalf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 报错</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在调用<code>operator*</code>时，<code>int</code>类型的变量会隐式转换为<code>Rational</code>对象，因此用<code>Rational</code>对象乘以<code>int</code>对象是合法的，但反过来则不是如此。</p><p>所以，为了避免这个错误，我们应当将运算符重载放在类外，作为非成员函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="条款-25：考虑写出一个不抛异常的swap函数"><a href="#条款-25：考虑写出一个不抛异常的swap函数" class="headerlink" title="条款 25：考虑写出一个不抛异常的swap函数"></a>条款 25：考虑写出一个不抛异常的swap函数</h3><p>由于<code>std::swap</code>函数在 C++11 后改为了用<code>std::move</code>实现，因此几乎已经没有性能的缺陷，也不再有像原书中所说的为自定义类型去自己实现的必要。不过原书中透露的思想还是值得一学的。</p><p>如果想为自定义类型实现自己的swap方法，可以考虑使用模板全特化，并且这种做法是被 STL 允许的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">using</span> std<span class="token operator">::</span>swap<span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>pImpl<span class="token punctuation">,</span> other<span class="token punctuation">.</span>pImpl<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    WidgetImpl<span class="token operator">*</span> pImpl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">namespace</span> std <span class="token punctuation">{</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span>    <span class="token keyword">void</span> swap<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> Widget<span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        a<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，由于外部函数并不能直接访问<code>Widget</code>的private成员变量，因此我们先是在类中定义了一个 public 成员函数，再由<code>std::swap</code>去调用这个成员函数。</p><p>然而若<code>Widget</code>和<code>WidgetImpl</code>是类模板，情况就没有这么简单了，因为 C++ 不支持函数模板偏特化，所以只能使用重载的方式：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">namespace</span> std <span class="token punctuation">{</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>    <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Widget<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span> Widget<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        a<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但很抱歉，这种做法是被 STL 禁止的，因为这是在试图向 STL 中添加新的内容，所以我们只能退而求其次，在其它命名空间中定义新的swap函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">namespace</span> WidgetStuff <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>    <span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token number">3</span>    <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Widget<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span> Widget<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        a<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们希望在对自定义对象进行操作时找到正确的swap函数重载版本，这时候如果再写成<code>std::swap</code>，就会强制使用 STL 中的swap函数，无法满足我们的需求，因此需要改写成：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> std<span class="token operator">::</span>swap<span class="token punctuation">;</span><span class="token function">swap</span><span class="token punctuation">(</span>obj1<span class="token punctuation">,</span> obj2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样，C++ 名称查找法则能保证我们优先使用的是自定义的swap函数而非 STL 中的swap函数。</p><blockquote><p>C++ 名称查找法则：编译器会从使用名字的地方开始向上查找，由内向外查找各级作用域（命名空间）直到全局作用域（命名空间），找到同名的声明即停止，若最终没找到则报错。 函数匹配优先级：普通函数 &gt; 特化函数 &gt; 模板函数</p></blockquote><h2 id="第五章：实现"><a href="#第五章：实现" class="headerlink" title="第五章：实现"></a>第五章：实现</h2><h3 id="条款-26：尽可能延后变量定义式出现的时间"><a href="#条款-26：尽可能延后变量定义式出现的时间" class="headerlink" title="条款 26：尽可能延后变量定义式出现的时间"></a>条款 26：尽可能延后变量定义式出现的时间</h3><p>当变量定义出现时，程序需要承受其构造成本；当变量离开其作用域时，程序需要承受其析构成本。因此，避免不必要的变量定义，以及延后变量定义式直到你确实需要它。</p><p>延后变量定义式还有一个意义，即“默认构造+赋值”效率低于“直接构造”：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 效率低</span>std<span class="token operator">::</span>string encrypted<span class="token punctuation">;</span>encrypted <span class="token operator">=</span> password<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 效率高</span>std<span class="token operator">::</span>string <span class="token function">encrypted</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于循环中变量的定义，我们一般有两种做法：</p><p>A. 定义于循环外，在循环中赋值：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget w<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    w <span class="token operator">=</span> 取决于 i 的某个值<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种做法产生的开销：1 个构造函数 + 1 个析构函数 + n 个赋值操作</p><p>B. 定义于循环内：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Widget <span class="token function">w</span><span class="token punctuation">(</span>取决于 i 的某个值<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这种做法产生的开销：n 个构造函数 + n 个析构函数</p><p>由于做法A会将变量的作用域扩大，因此除非知道该变量的赋值成本比“构造+析构”成本低，或者对这段程序的效率要求非常高，否则建议使用做法B。</p><h3 id="条款-27：少做转型动作"><a href="#条款-27：少做转型动作" class="headerlink" title="条款 27：少做转型动作"></a>条款 27：少做转型动作</h3><p>C 式转型：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">(</span>T<span class="token punctuation">)</span>expression<span class="token function">T</span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>C++ 式转型：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const_cast</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>const_cast</code>用于常量性转除，这也是唯一一个有这个能力的 C++ 式转型。</li><li><code>dynamic_cast</code>用于安全地向下转型，这也是唯一一个 C 式转型无法代替的转型操作，它会执行对继承体系的检查，因此会带来额外的开销。只有拥有虚函数的基类指针能进行<code>dynamic_cast</code>。</li><li><code>reinterpret_cast</code>用于在任意两个类型间进行低级转型，执行该转型可能会带来风险，也可能不具备移植性。</li><li><code>static_cast</code>用于进行强制隐式转换，也是最常用的转型操作，可以将内置数据类型互相转换，也可以将<code>void*</code>和typed指针，基类指针和派生类指针互相转换。</li></ul><p>尽量在 C++ 程序中使用 C++ 式转型，因为 C++ 式转型操作功能更明确，可以避免不必要的错误。</p><p>唯一使用 C 式转型的时机可能是在调用 explicit 构造函数时：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">explicit</span> <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">DoSomeWork</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">DoSomeWork</span><span class="token punctuation">(</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 等价于 DoSomeWork(static_cast&lt;Widget>(15));</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，转型并非什么都没有做，而是可能会更改数据的底层表述，或者为指针附加偏移值，这和具体平台有关，因此不要妄图去揣测转型后对象的具体布局方式。</p><p>避免对<code>*this</code>进行转型，参考以下例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Window</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">OnResize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">SpecialWindow</span> <span class="token operator">:</span> <span class="token keyword">public</span> Window <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">OnResize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Window<span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">OnResize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码试图通过转型<code>*this</code>来调用基类的虚函数，然而这是严重错误的，这样做会得到一个新的<code>Window</code>副本并在该副本上调用函数，而非在原本的对象上调用函数。</p><p>正确的做法如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">SpecialWindow</span> <span class="token operator">:</span> <span class="token keyword">public</span> Window <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">OnResize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Window<span class="token operator">::</span><span class="token function">OnResize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当你想知道一个基类指针是否指向一个派生类对象时，你需要用到<code>dynamic_cast</code>，如果不满足，则会产生报错。但是对于继承体系的检查可能是非常慢的，所以在注重效率的程序中应当避免使用<code>dynamic_cast</code>，改用<code>static_cast</code>或别的代替方法。</p><h3 id="条款-28：避免返回-handles-指向对象的内部成分"><a href="#条款-28：避免返回-handles-指向对象的内部成分" class="headerlink" title="条款 28：避免返回 handles 指向对象的内部成分"></a>条款 28：避免返回 handles 指向对象的内部成分</h3><p>考虑以下<code>Rectangle</code>类：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> RectData <span class="token punctuation">{</span>    Point ulhc<span class="token punctuation">;</span>    Point lrhc<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    Point<span class="token operator">&amp;</span> <span class="token function">UpperLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> pData<span class="token operator">-</span><span class="token operator">></span>ulhc<span class="token punctuation">;</span> <span class="token punctuation">}</span>    Point<span class="token operator">&amp;</span> <span class="token function">LowerRight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> pData<span class="token operator">-</span><span class="token operator">></span>lrhc<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>RectData<span class="token operator">></span> pData<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码看起来没有任何问题，但其实是在做自我矛盾的事情：我们通过const成员函数返回了一个指向成员变量的引用，这使得成员变量可以在外部被修改，而这是违反 logical constness 的原则的。换句话说，你<strong>绝对不应该令成员函数返回一个指针指向“访问级别较低”的成员函数</strong>。</p><p>改成返回常引用可以避免对成员变量的修改：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const</span> Point<span class="token operator">&amp;</span> <span class="token function">UpperLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> pData<span class="token operator">-</span><span class="token operator">></span>ulhc<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">const</span> Point<span class="token operator">&amp;</span> <span class="token function">LowerRight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> pData<span class="token operator">-</span><span class="token operator">></span>lrhc<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>但是这样依然会带来一个称作 <strong>dangling handles（空悬句柄）</strong> 的问题，当对象不复存在时，你将无法通过引用获取到返回的数据。</p><p>采用最保守的做法，返回一个成员变量的副本：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Point <span class="token function">UpperLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> pData<span class="token operator">-</span><span class="token operator">></span>ulhc<span class="token punctuation">;</span> <span class="token punctuation">}</span>Point <span class="token function">LowerRight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> pData<span class="token operator">-</span><span class="token operator">></span>lrhc<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>避免返回 handles（包括引用、指针、迭代器）指向对象内部。遵循这个条款可增加封装性，使得const成员函数的行为符合常量性，并将发生 “空悬句柄” 的可能性降到最低。</p><h3 id="条款-29：为“异常安全”而努力是值得的"><a href="#条款-29：为“异常安全”而努力是值得的" class="headerlink" title="条款 29：为“异常安全”而努力是值得的"></a>条款 29：为“异常安全”而努力是值得的</h3><p>异常安全函数提供以下三个保证之一：</p><p><strong>基本承诺：</strong> 如果异常被抛出，程序内的任何事物仍然保持在有效状态下，没有任何对象或数据结构会因此败坏，所有对象都处于一种内部前后一致的状态，然而程序的真实状态是不可知的，也就是说客户需要额外检查程序处于哪种状态并作出对应的处理。</p><p><strong>强烈保证：</strong> 如果异常被抛出，程序状态完全不改变，换句话说，程序会回复到“调用函数之前”的状态。</p><p><strong>不抛掷（nothrow）保证：</strong> 承诺绝不抛出异常，因为程序总是能完成原先承诺的功能。作用于内置类型身上的所有操作都提供 nothrow 保证。</p><p>原书中实现 nothrow 的方法是<code>throw()</code>，不过这套异常规范在 C++11 中已经被弃用，取而代之的是<code>noexcept</code>关键字：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">DoSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意，使用<code>noexcept</code>并不代表函数绝对不会抛出异常，而是在抛出异常时，将代表出现严重错误，会有意想不到的函数被调用（可以通过<code>set_unexpected</code>设置），接着程序会直接崩溃。</p><p>当异常被抛出时，带有异常安全性的函数会：</p><ol><li>不泄漏任何资源。</li><li>不允许数据败坏。</li></ol><p>考虑以下<code>PrettyMenu</code>的<code>ChangeBackground</code>函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">PrettyMenu</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">void</span> <span class="token function">ChangeBackground</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>uint8_t<span class="token operator">></span><span class="token operator">&amp;</span> imgSrc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    Mutex mutex<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 互斥锁</span>    Image<span class="token operator">*</span> bgImage<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 目前的背景图像</span>    <span class="token keyword">int</span> imageChanges<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 背景图像被改变的次数</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> PrettyMenu<span class="token operator">::</span><span class="token function">ChangeBackground</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>uint8_t<span class="token operator">></span><span class="token operator">&amp;</span> imgSrc<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> bgImage<span class="token punctuation">;</span>    <span class="token operator">++</span>imageChanges<span class="token punctuation">;</span>    bgImage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Image</span><span class="token punctuation">(</span>imgSrc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很明显这个函数不满足我们所说的具有异常安全性的任何一个条件，若在函数中抛出异常，<code>mutex</code>会发生资源泄漏，<code>bgImage</code>和<code>imageChanges</code>也会发生数据败坏。</p><p>通过以对象管理资源，使用智能指针和调换代码顺序，我们能将其变成一个具有强烈保证的异常安全函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> PrettyMenu<span class="token operator">::</span><span class="token function">ChangeBackground</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>uint8_t<span class="token operator">></span><span class="token operator">&amp;</span> imgSrc<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Lock <span class="token function">m1</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    bgImage<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>Image<span class="token operator">></span><span class="token punctuation">(</span>imgSrc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">++</span>imageChanges<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一个常用于提供强烈保证的方法是我们所提到过的 copy and swap，为你打算修改的对象做出一份副本，对副本执行修改，并在所有修改都成功执行后，用一个不会抛出异常的swap方法将原件和副本交换：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> PMImpl <span class="token punctuation">{</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Image<span class="token operator">></span> bgImage<span class="token punctuation">;</span>    <span class="token keyword">int</span> imageChanges<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">PrettyMenu</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    Mutex mutex<span class="token punctuation">;</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>PMImpl<span class="token operator">></span> pImpl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> PrettyMenu<span class="token operator">::</span><span class="token function">ChangeBackground</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>uint8_t<span class="token operator">></span><span class="token operator">&amp;</span> imgSrc<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Lock <span class="token function">m1</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> pNew <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>PMImpl<span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">*</span>pImpl<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取副本</span>    pNew<span class="token operator">-</span><span class="token operator">></span>bgImage<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>Image<span class="token operator">></span><span class="token punctuation">(</span>imgSrc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">++</span>pNew<span class="token operator">-</span><span class="token operator">></span>imageChanges<span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">swap</span><span class="token punctuation">(</span>pImpl<span class="token punctuation">,</span> pNew<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当一个函数调用其它函数时，函数提供的“异常安全保证”通常最高只等于其所调用的各个函数的“异常安全保证”中的最弱者。</p><p>强烈保证并非永远都是可实现的，特别是当函数在操控非局部对象时，这时就只能退而求其次选择不那么美好的基本承诺，并将该决定写入文档，让其他人维护时不至于毫无心理准备。</p><h3 id="条款-30：透彻了解-inlining-的里里外外"><a href="#条款-30：透彻了解-inlining-的里里外外" class="headerlink" title="条款 30：透彻了解 inlining 的里里外外"></a>条款 30：透彻了解 inlining 的里里外外</h3><p>将函数声明为内联一共有两种方法，一种是为其显式指定<code>inline</code>关键字，另一种是直接将成员函数的定义式写在类中，如下所示：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">int</span> <span class="token function">Age</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> theAge<span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 隐式声明为 inline</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> theAge<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>inline</code>诞生之初，它被当作是一种对编译器的优化建议，即将“对此函数的每一个调用”都以函数本体替换之。但在编译器的具体实现中，该行为完全被优化等级所控制，与函数是否内联无关。</p><p>在现在的 C++ 标准中，<code>inline</code>作为优化建议的含义已经被完全抛弃，取而代之的是“允许函数在不同编译单元中多重定义”，使得可以在头文件中直接给出函数的实现。</p><p>在 C++17 中，引入了一个新的<code>inline</code>用法，使静态成员变量可以在类中直接定义：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> theAge <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// since C++17</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-31：将文件间的编译依存关系降至最低"><a href="#条款-31：将文件间的编译依存关系降至最低" class="headerlink" title="条款 31：将文件间的编译依存关系降至最低"></a>条款 31：将文件间的编译依存关系降至最低</h3><p>C++ 坚持将类的实现细节放置于类的定义式中，这就意味着，即使你只改变类的实现而不改变类的接口，在构建程序时依然需要重新编译。这个问题的根源出在编译器必须在编译期间知道对象的大小，如果看不到类的定义式，就没有办法为对象分配内存。也就是说，C++ 并没有把“将接口从实现中分离”这件事做得很好。</p><p><strong>用“声明的依存性”替换“定义的依存性”：</strong></p><p>我们可以玩一个“将对象实现细目隐藏于一个指针背后”的游戏，称作 <strong>pimpl idiom（pimpl 是 pointer to implemention 的缩写）</strong>：将原来的一个类分割为两个类，一个只提供接口，另一个负责实现该接口，称作<strong>句柄类（handle class）</strong>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// person.hpp 负责声明类</span><span class="token keyword">class</span> <span class="token class-name">PersonImpl</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>PersonImpl<span class="token operator">></span> pImpl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// person.cpp 负责实现类</span><span class="token keyword">class</span> <span class="token class-name">PersonImpl</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> data<span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Person<span class="token operator">::</span><span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    pImpl <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>PersonImpl<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> Person<span class="token operator">::</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> pImpl<span class="token operator">-</span><span class="token operator">></span>data<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，假如我们要修改<code>Person</code>的private成员，就只需要修改<code>PersonImpl</code>中的内容，而<code>PersonImpl</code>的具体实现是被隐藏起来的，对它的任何修改都不会使得<code>Person</code>客户端重新编译，真正实现了“类的接口和实现分离”。</p><p><strong>如果使用对象引用或对象指针可以完成任务，就不要使用对象本身：</strong></p><p>你可以只靠一个类型声明式就定义出指向该类型的引用和指针；但如果定义某类型的对象，就需要用到该类型的定义式。</p><p><strong>如果能够，尽量以类声明式替换类定义式：</strong></p><p>当你在声明一个函数而它用到某个类时，你不需要该类的定义；但当你触及到该函数的定义式后，就必须也知道类的定义：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Date</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">// 类的声明式</span>Date <span class="token function">Today</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">ClearAppointments</span><span class="token punctuation">(</span>Data d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 此处并不需要得知类的定义</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>为声明式和定义式提供不同的头文件：</strong></p><p>为了避免频繁地添加声明，我们应该为所有要用的类声明提供一个头文件，这种做法对 template 也适用：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"datefwd.h"</span>            </span><span class="token comment" spellcheck="true">// 这个头文件内声明 class Date</span>Date <span class="token function">Today</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">ClearAppointments</span><span class="token punctuation">(</span>Data d<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此处的头文件命名方式<code>&quot;datefwd.h&quot;</code>取自标准库中的<code>&lt;iosfwd&gt;</code>。</p><p>上面我们讲述了接口与实现分离的其中一个方法——提供句柄类，另一个方法就是将句柄类定义为抽象基类，称作<strong>接口类（interface class）</strong>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了将<code>Person</code>对象实际创建出来，我们一般采用工厂模式。可以尝试在类中塞入一个静态成员函数<code>Create</code>用于创建对象：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">static</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Person<span class="token operator">></span> <span class="token function">Create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但此时<code>Create</code>函数还无法使用，需要在派生类中给出<code>Person</code>类中的函数的具体实现：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">RealPerson</span> <span class="token operator">:</span> <span class="token keyword">public</span> Person <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">RealPerson</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">RealPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> data<span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完成<code>Create</code>函数的定义：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">static</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Person<span class="token operator">></span> Person<span class="token operator">::</span><span class="token function">Create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>RealPerson<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>毫无疑问的是，句柄类和接口类都需要额外的开销：句柄类需要通过 pimpl 取得对象数据，增加一层间接访问、指针大小和动态分配内存带来的开销；而接口类会增加存储虚表指针和实现虚函数跳转带来的开销。</p><p>而当这些开销过于重大以至于类之间的耦合度在相形之下不成为关键时，就以具象类（concrete class）替换句柄类和接口类。</p><h2 id="第六章：继承与面向对象设计"><a href="#第六章：继承与面向对象设计" class="headerlink" title="第六章：继承与面向对象设计"></a>第六章：继承与面向对象设计</h2><h3 id="条款-32：确定你的public继承塑模出-is-a-关系"><a href="#条款-32：确定你的public继承塑模出-is-a-关系" class="headerlink" title="条款 32：确定你的public继承塑模出 is-a 关系"></a>条款 32：确定你的public继承塑模出 is-a 关系</h3><p>“public继承”意味着 is-a，所谓 is-a，就是指适用于基类身上的每一件事情一定也适用于继承类身上，因为我们可以认为每一个派生类对象也都是一个基类对象。</p><p>这看似很自然，但在面对自然语言的表述时，往往会产生歧义。</p><p>考虑<code>Bird</code>类和<code>Penguin</code>类的继承关系：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Bird</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Penguin</span> <span class="token operator">:</span> <span class="token keyword">public</span> Bird <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Penguin</code>类会获得来自<code>Bird</code>类的飞行方法，这就造成了误解，因为企鹅恰恰是不会飞的鸟类。一种解决方法是当调用<code>Penguin</code>类中的<code>Fly</code>函数时，抛出一个运行期错误，但这种做法通常不够直观；另一个解决方法是使用双继承，区分会飞和不会飞的鸟类：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Bird</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">FlyingBird</span> <span class="token operator">:</span> <span class="token keyword">public</span> Bird <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Penguin</span> <span class="token operator">:</span> <span class="token keyword">public</span> FlyingBird <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但若要处理鸟类的多钟不同属性时，双继承模式就不太管用了，因此我们总是说程序设计没有银弹。</p><p>另一个常见的例子是用<code>Square</code>类继承自<code>Rectangle</code>类，从几何学的角度来讲这很自然，然而正方形的长宽是相等的，矩形却不是如此，因此<code>Square</code>类和<code>Rectangle</code>类也无法满足严格的 is-a 关系。</p><h3 id="条款-33：避免遮掩继承而来的名称"><a href="#条款-33：避免遮掩继承而来的名称" class="headerlink" title="条款 33：避免遮掩继承而来的名称"></a>条款 33：避免遮掩继承而来的名称</h3><p>之前我们了解过 C++ 名称查找法则，这在继承体系中也是类似的，当我们在派生类中使用到一个名字时，编译器会优先查找派生类覆盖的作用域，如果没找到，再去查找基类的作用域，最后再查找全局作用域。</p><p>考虑以下情形：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">mf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">mf</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">mf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样会导致派生类无法使用来自基类的重载函数，因为派生类中的名称<code>mf</code>掩盖了来自基类的名称<code>mf</code>。</p><p>对于名称掩盖问题的一种方法是使用<code>using</code>关键字：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> Base<span class="token operator">::</span>mf<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>using</code>关键字会将基类中所有使用到名称<code>mf</code>的函数全部包含在派生类中，包括其重载版本。</p><p>若有时我们不想要一个函数的全部版本，只想要单一版本（特别是在private继承时），可以考虑使用<strong>转发函数（forwarding function）</strong>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Base<span class="token operator">::</span><span class="token function">mf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-34：区分接口继承和实现继承"><a href="#条款-34：区分接口继承和实现继承" class="headerlink" title="条款 34：区分接口继承和实现继承"></a>条款 34：区分接口继承和实现继承</h3><ol><li>接口继承和实现继承不一样。在public继承下，派生类总是继承基类的接口。</li><li>声明一个纯虚函数的目的，是为了让派生类只继承函数接口。</li><li>声明简朴的非纯虚函数的目的，是让派生类继承该函数的接口和缺省实现。</li><li>声明非虚函数的目的，是为了令派生类继承函数的接口及一份强制性实现。</li></ol><p>通常而言，我们不会为纯虚函数提供具体实现，然而这样做是被允许的，并且用于替代简朴的非纯虚函数，提供更平常更安全的缺省实现。</p><p>用非纯虚函数提供缺省的默认实现：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Airplane</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 缺省实现</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Model</span> <span class="token operator">:</span> <span class="token keyword">public</span> Airplane <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是最简朴的做法，但是这样做会带来的问题是，由于不强制对虚函数的覆写，在定义新的派生类时可能会忘记进行覆写，导致错误地使用了缺省实现。</p><p>使用纯虚函数并提供默认实现：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Airplane</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">DefaultFly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 缺省实现</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Model</span> <span class="token operator">:</span> <span class="token keyword">public</span> Airplane <span class="token punctuation">{</span> <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        <span class="token function">DefaultFly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述写法可以替代为：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Airplane</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> Airplane<span class="token operator">::</span><span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 缺省实现</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Model</span> <span class="token operator">:</span> <span class="token keyword">public</span> Airplane <span class="token punctuation">{</span> <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        Airplane<span class="token operator">::</span><span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-35：考虑虚函数以外的其它选择"><a href="#条款-35：考虑虚函数以外的其它选择" class="headerlink" title="条款 35：考虑虚函数以外的其它选择"></a>条款 35：考虑虚函数以外的其它选择</h3><p><strong>藉由非虚接口手法实现 template method：</strong></p><p><strong>非虚接口（non-virtual interface，NVI）</strong> 设计手法的核心就是用一个非虚函数作为 wrapper，将虚函数隐藏在封装之下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">GameCharacter</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">HealthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 做一些前置工作</span>        <span class="token keyword">int</span> retVal <span class="token operator">=</span> <span class="token function">DoHealthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 做一些后置工作</span>        <span class="token keyword">return</span> retVal<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">int</span> <span class="token function">DoHealthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 缺省算法</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>NVI手法的一个优点就是在 wrapper 中做一些前置和后置工作，确保得以在一个虚函数被调用之前设定好适当场景，并在调用结束之后清理场景。如果你让客户直接调用虚函数，就没有任何好办法可以做这些事。</p><p>NVI手法允许派生类重新定义虚函数，从而赋予它们“如何实现机能”的控制能力，但基类保留诉说“函数何时被调用”的权利。</p><p>在NVI手法中虚函数除了可以是private，也可以是protected，例如要求在派生类的虚函数实现内调用其基类的对应虚函数时，就必须得这么做。</p><p><strong>藉由函数指针实现 Strategy 模式：</strong></p><p>参考以下例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">GameCharacter</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">DefaultHealthCalc</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 缺省算法</span><span class="token keyword">class</span> <span class="token class-name">GameCharacter</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> HealthCalcFunc <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 定义函数指针类型</span>    <span class="token keyword">explicit</span> <span class="token function">GameCharacter</span><span class="token punctuation">(</span>HealthCalcFunc hcf <span class="token operator">=</span> DefaultHealthCalc<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">healthFunc</span><span class="token punctuation">(</span>hcf<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">HealthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">healthFunc</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    HealthCalcFunc healthFunc<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同一个人物类型的不同实体可以有不同的健康计算函数，并且该计算函数可以在运行期变更。</p><p>这间接表明健康计算函数不再是<code>GameCharacter</code>继承体系内的成员函数，它也无权使用非public成员。为了填补这个缺陷，我们唯一的做法是弱化类的封装，引入友元或提供public访问函数。</p><p><strong>藉由 std::function 完成 Strategy 模式</strong></p><p><code>std::function</code>是 C++11 中引入的函数包装器，使用它能提供比函数指针更强的灵活度：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">GameCharacter</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">DefaultHealthCalc</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 缺省算法</span><span class="token keyword">class</span> <span class="token class-name">GameCharacter</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> HealthCalcFunc <span class="token operator">=</span> std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 定义函数包装器类型</span>    <span class="token keyword">explicit</span> <span class="token function">GameCharacter</span><span class="token punctuation">(</span>HealthCalcFunc hcf <span class="token operator">=</span> DefaultHealthCalc<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">healthFunc</span><span class="token punctuation">(</span>hcf<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">HealthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">healthFunc</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    HealthCalcFunc healthFunc<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看起来并没有很大的改变，但当我们需要时，<code>std::function</code>就能展现出惊人的弹性：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 使用返回值不同的函数</span><span class="token keyword">short</span> <span class="token function">CalcHealth</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>GameCharacter <span class="token function">chara1</span><span class="token punctuation">(</span>CalcHealth<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用函数对象（仿函数）</span><span class="token keyword">struct</span> HealthCalculator <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>GameCharacter <span class="token function">chara2</span><span class="token punctuation">(</span><span class="token function">HealthCalculator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用某个成员函数</span><span class="token keyword">class</span> <span class="token class-name">GameLevel</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">float</span> <span class="token function">Health</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>GameLevel currentLevel<span class="token punctuation">;</span>GameCharacter <span class="token function">chara2</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>GameLevel<span class="token operator">::</span>Health<span class="token punctuation">,</span> currentLevel<span class="token punctuation">,</span> std<span class="token operator">::</span>placeholders<span class="token operator">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>古典的 Strategy 模式：</strong></p><p>在古典的 Strategy 模式中，我们并非直接利用函数指针（或包装器）调用函数，而是内含一个指针指向来自<code>HealthCalcFunc</code>继承体系的对象：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">GameCharacter</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">HealthCalcFunc</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">int</span> <span class="token function">Calc</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span> gc<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>HealthCalcFunc defaultHealthCalc<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">GameCharacter</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">explicit</span> <span class="token function">GameCharacter</span><span class="token punctuation">(</span>HealthCalcFunc<span class="token operator">*</span> phcf <span class="token operator">=</span> <span class="token operator">&amp;</span>defaultHealthCalc<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">pHealthCalc</span><span class="token punctuation">(</span>phcf<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">HealthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> pHealthCalc<span class="token operator">-</span><span class="token operator">></span><span class="token function">Calc</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    HealthCalcFunc<span class="token operator">*</span> pHealthCalc<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个设计模式的好处在于足够容易辨认，想要添加新的计算函数也只需要为<code>HealthCalcFunc</code>基类添加一个派生类即可。</p><h3 id="条款-36：绝不重新定义继承而来的非虚函数"><a href="#条款-36：绝不重新定义继承而来的非虚函数" class="headerlink" title="条款 36：绝不重新定义继承而来的非虚函数"></a>条款 36：绝不重新定义继承而来的非虚函数</h3><p>非虚函数和虚函数具有本质上的不同：非虚函数执行的是静态绑定（statically bound，又称前期绑定，early binding），由对象类型本身（称之静态类型）决定要调用的函数；而虚函数执行的是动态绑定（dynamically bound，又称后期绑定，late binding），决定因素不在对象本身，而在于“指向该对象之指针”当初的声明类型（称之动态类型）。</p><p>前面我们已经说过，public继承意味着 is-a 关系，而在基类中声明一个非虚函数将会为该类建立起一种不变性（invariant），凌驾其特异性（specialization）。而若在派生类中重新定义该非虚函数，则会使人开始质疑是否该使用public继承的形式；如果必须使用，则又打破了基类“不变性凌驾特异性”的性质，就此产生了设计上的矛盾。</p><p>综上所述，在任何情况下都不该重新定义一个继承而来的非虚函数。</p><h3 id="条款-37：绝不重新定义继承而来的缺省参数值"><a href="#条款-37：绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款 37：绝不重新定义继承而来的缺省参数值"></a>条款 37：绝不重新定义继承而来的缺省参数值</h3><p>在条款 36 中我们已经否定了重新定义非虚函数的可能性，因此此处我们只讨论带有缺省参数值的虚函数。</p><p>虚函数是动态绑定而来，意思是调用一个虚函数时，究竟调用哪一份函数实现代码，取决于发出调用的那个对象的动态类型。但与之不同的是，<strong>缺省参数值却是静态绑定</strong>，意思是你可能会在“调用一个定义于派生类的虚函数”的同时，却使用基类为它所指定的缺省参数值。考虑以下例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">ShapeColor</span> <span class="token punctuation">{</span> Red<span class="token punctuation">,</span> Green<span class="token punctuation">,</span> Blue <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Draw</span><span class="token punctuation">(</span>ShapeColor color <span class="token operator">=</span> ShapeColor<span class="token operator">::</span>Red<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Rectangle</span> <span class="token operator">:</span> <span class="token keyword">public</span> Shape <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Draw</span><span class="token punctuation">(</span>ShapeColor color <span class="token operator">=</span> ShapeColor<span class="token operator">::</span>Green<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Circle</span> <span class="token operator">:</span> <span class="token keyword">public</span> Shape <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Draw</span><span class="token punctuation">(</span>ShapeColor color<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时若对派生类对象调用<code>Draw</code>函数，则会发现：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Shape<span class="token operator">*</span> pr <span class="token operator">=</span> <span class="token keyword">new</span> Rectangle<span class="token punctuation">;</span>Shape<span class="token operator">*</span> pc <span class="token operator">=</span> <span class="token keyword">new</span> Circle<span class="token punctuation">;</span>pr<span class="token operator">-</span><span class="token operator">></span><span class="token function">Draw</span><span class="token punctuation">(</span>Shape<span class="token operator">::</span>ShapeColor<span class="token operator">::</span>Green<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用 Rectangle::Draw(Shape::Green)</span>pr<span class="token operator">-</span><span class="token operator">></span><span class="token function">Draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// 调用 Rectangle::Draw(Shape::Red)</span>pc<span class="token operator">-</span><span class="token operator">></span><span class="token function">Draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// 调用 Rectangle::Draw(Shape::Red)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这就迫使我们在指定虚函数时使用相同的缺省参数值，为了避免不必要的麻烦和错误，可以考虑条款 35 中列出的虚函数的替代设计，例如NVI手法：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">ShapeColor</span> <span class="token punctuation">{</span> Red<span class="token punctuation">,</span> Green<span class="token punctuation">,</span> Blue <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">Draw</span><span class="token punctuation">(</span>ShapeColor color <span class="token operator">=</span> ShapeColor<span class="token operator">::</span>Red<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token function">DoDraw</span><span class="token punctuation">(</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">DoDraw</span><span class="token punctuation">(</span>ShapeColor color<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Rectangle</span> <span class="token operator">:</span> <span class="token keyword">public</span> Shape <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">DoDraw</span><span class="token punctuation">(</span>ShapeColor color<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-38：通过复合塑模出-has-a-或“根据某物实现出”"><a href="#条款-38：通过复合塑模出-has-a-或“根据某物实现出”" class="headerlink" title="条款 38：通过复合塑模出 has-a 或“根据某物实现出”"></a>条款 38：通过复合塑模出 has-a 或“根据某物实现出”</h3><p>所谓<strong>复合（composition）</strong>，指的是某种类型的对象内含它种类型的对象。复合通常意味着 <strong>has-a</strong> 或<strong>根据某物实现出（is-implemented-in-terms-of）</strong> 的关系，当复合发生于应用域（application domain）内的对象之间，表现出 has-a 的关系；当它发生于实现域（implementation domain）内则是表现出“根据某物实现出”的关系。</p><p>下面是一个 has-a 关系的例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Address</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">PhoneNumber</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>string name<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 合成成分物（composed object）</span>    Address address<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 同上</span>    PhoneNumber voiceNumber<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 同上</span>    PhoneNumber faxNumber<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 同上</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是一个“根据某物实现出”关系的例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 将 list 应用于 Set</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Set</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">member</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> item<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>size_t <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>list<span class="token operator">&lt;</span>T<span class="token operator">></span> rep<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 用来表述 Set 的数据</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-39：明智而审慎地使用private继承"><a href="#条款-39：明智而审慎地使用private继承" class="headerlink" title="条款 39：明智而审慎地使用private继承"></a>条款 39：明智而审慎地使用private继承</h3><p>private继承的特点：</p><ol><li>如果类之间是private继承关系，那么编译器不会自动将一个派生类对象转换为一个基类对象。</li><li>由private继承来的所有成员，在派生类中都会变为private属性，换句话说，private继承只继承实现，不继承接口。</li></ol><p>private继承的意义是“根据某物实现出”，如果你读过条款 38，就会发现private继承和复合具有相同的意义，事实上也确实如此，绝大部分private继承的使用场合都可以被“public继承+复合”完美解决：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Timer</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">explicit</span> <span class="token function">Timer</span><span class="token punctuation">(</span><span class="token keyword">int</span> tickFrequency<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">OnTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token operator">:</span> <span class="token keyword">private</span> Timer <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">OnTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>替代为：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">class</span> <span class="token class-name">WidgetTimer</span> <span class="token operator">:</span> <span class="token keyword">public</span> Timer <span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">OnTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    WidgetTimer timer<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用后者比前者好的原因有以下几点：</p><ol><li>private继承无法阻止派生类重新定义虚函数，但若使用public继承定义<code>WidgetTimer</code>类并复合在<code>Widget</code>类中，就能防止在<code>Widget</code>类中重新定义虚函数。</li><li>可以仅提供<code>WidgetTimer</code>类的声明，并将<code>WidgetTimer</code>类的具体定义移至实现文件中，从而降低<code>Widget</code>的编译依存性。</li></ol><p>然而private继承并非完全一无是处，一个适用于它的极端情况是<strong>空白基类最优化（empty base optimization，EBO）</strong>，参考以下例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Empty</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">HoldsAnInt</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    Empty e<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个没有非静态成员变量、虚函数的类，看似不需要任何存储空间，但实际上 C++ 规定凡是独立对象都必须有非零大小，因此此处<code>sizeof(HoldsAnInt)</code>必然大于<code>sizeof(int)</code>，通常会多出一字节大小，但有时考虑到内存对齐之类的要求，可能会多出更多的空间。</p><p>使用private继承可以避免产生额外存储空间，将上面的代码替代为：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">HoldsAnInt</span> <span class="token operator">:</span> <span class="token keyword">private</span> Empty <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-40：明智而审慎地使用多重继承"><a href="#条款-40：明智而审慎地使用多重继承" class="headerlink" title="条款 40：明智而审慎地使用多重继承"></a>条款 40：明智而审慎地使用多重继承</h3><p>多重继承是一个可能会造成很多歧义和误解的设计，因此反对它的声音此起彼伏，下面我们来接触几个使用多重继承的场景。</p><p>最先需要认清的一件事是，程序有可能从一个以上的基类继承相同名称，那会导致较多的歧义机会：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">BorrowableItem</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">CheckOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">ElectronicGadget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">CheckOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">MP3Player</span> <span class="token operator">:</span> <span class="token keyword">public</span> BorrowableItem<span class="token punctuation">,</span> <span class="token keyword">public</span> ElectronicGadget <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>MP3Player mp<span class="token punctuation">;</span>mp<span class="token punctuation">.</span><span class="token function">CheckOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// MP3Player::CheckOut 不明确！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果真遇到这种情况，必须明确地指出要调用哪一个基类中的函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp">mp<span class="token punctuation">.</span>BorrowableItem<span class="token operator">::</span><span class="token function">CheckOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 使用 BorrowableItem::CheckOut</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在使用多重继承时，我们可能会遇到要命的“菱形继承”：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">File</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">InputFile</span> <span class="token operator">:</span> <span class="token keyword">public</span> File <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">OutputFile</span> <span class="token operator">:</span> <span class="token keyword">public</span> File <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">IOFile</span> <span class="token operator">:</span> <span class="token keyword">public</span> InputFile<span class="token punctuation">,</span> <span class="token keyword">public</span> OutputFile <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这时候必须面对这样一个问题：是否打算让基类内的成员变量经由每一条路径被复制？如果不想要这样，应当使用虚继承，指出其愿意共享基类：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">File</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">InputFile</span> <span class="token operator">:</span> <span class="token keyword">virtual</span> <span class="token keyword">public</span> File <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">OutputFile</span> <span class="token operator">:</span> <span class="token keyword">virtual</span> <span class="token keyword">public</span> File <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">IOFile</span> <span class="token operator">:</span> <span class="token keyword">public</span> InputFile<span class="token punctuation">,</span> <span class="token keyword">public</span> OutputFile <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然而由于虚继承会在派生类中额外存储信息来确认成员来自于哪个基类，虚继承通常会付出更多空间和速度的代价，并且由于虚基类的初始化责任是由继承体系中最底层的派生类负责，就导致了虚基类必须认知其虚基类并且承担虚基类的初始化责任。因此我们应当遵循以下两个建议：</p><ol><li>非必要不使用虚继承。</li><li>如果必须使用虚继承，尽可能避免在虚基类中放置数据。</li></ol><p>多重继承可用于结合public继承和private继承，public继承用于提供接口，private继承用于提供实现：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// IPerson 类指出要实现的接口</span><span class="token keyword">class</span> <span class="token class-name">IPerson</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">IPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> std<span class="token operator">::</span>string <span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> std<span class="token operator">::</span>string <span class="token function">BirthDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">DatabaseID</span> <span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// PersonInfo 类有若干已实现的函数</span><span class="token comment" spellcheck="true">// 可用以实现 IPerson 接口</span><span class="token keyword">class</span> <span class="token class-name">PersonInfo</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">explicit</span> <span class="token function">PersonInfo</span><span class="token punctuation">(</span>DatabaseID pid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">PersonInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">TheName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">TheBirthDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">ValueDelimOpen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">ValueDelimClose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// CPerson 类使用多重继承</span><span class="token keyword">class</span> <span class="token class-name">CPerson</span><span class="token operator">:</span> <span class="token keyword">public</span> IPerson<span class="token punctuation">,</span> <span class="token keyword">private</span> PersonInfo <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">explicit</span> <span class="token function">CPerson</span><span class="token punctuation">(</span>DatabaseID pid<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">PersonInfo</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">virtual</span> std<span class="token operator">::</span>string <span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// 实现必要的 IPerson 成员函数</span>        <span class="token keyword">return</span> PersonInfo<span class="token operator">::</span><span class="token function">TheName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token keyword">virtual</span> std<span class="token operator">::</span>string <span class="token function">BirthDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 实现必要的 IPerson 成员函数</span>        <span class="token keyword">return</span> PersonInfo<span class="token operator">::</span><span class="token function">TheBirthDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">// 重新定义继承而来的虚函数</span>    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">ValueDelimOpen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">ValueDelimClose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第七章：模板与泛型编程"><a href="#第七章：模板与泛型编程" class="headerlink" title="第七章：模板与泛型编程"></a>第七章：模板与泛型编程</h2><h3 id="条款-41：了解隐式接口和编译期多态"><a href="#条款-41：了解隐式接口和编译期多态" class="headerlink" title="条款 41：了解隐式接口和编译期多态"></a>条款 41：了解隐式接口和编译期多态</h3><p>类与模板都支持接口和多态。对于类而言接口是显式的，以函数签名为中心，多态则是通过虚函数发生于运行期；而对模板参数而言，接口是隐式的，奠基于有效表达式，多态则是通过模板具现化和函数重载解析（function overloading resolution）发生于编译期。</p><p>考虑以下例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">DoProcessing</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>w<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">10</span> <span class="token operator">&amp;&amp;</span> w <span class="token operator">!=</span> someNastyWidget<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码中，<code>T</code>类型的隐式接口要求：</p><ol><li>提供一个名为<code>size</code>的成员函数，该函数的返回值可与<code>int</code>（10 的类型）执行<code>operator&gt;</code>，或经过隐式转换后可执行<code>operator&gt;</code>。</li><li>必须支持一个<code>operator!=</code>函数，接受<code>T</code>类型和<code>someNastyWidget</code>的类型，或其隐式转换后得到的类型。</li></ol><blockquote><p>此处没有考虑<code>operator&amp;&amp;</code>被重载的可能性。</p></blockquote><p>加诸于模板参数身上的隐式接口，就像加诸于类对象身上的显式接口“一样真实”，两者都在编译期完成检查，你无法在模板中使用“不支持模板所要求之隐式接口”的对象（代码无法通过编译）。</p><h3 id="条款-42：了解-typename-的双重含义"><a href="#条款-42：了解-typename-的双重含义" class="headerlink" title="条款 42：了解 typename 的双重含义"></a>条款 42：了解 typename 的双重含义</h3><p>在模板声明式中，使用<code>class</code>和<code>typename</code>关键字并没有什么不同，但在模板内部，<code>typename</code>拥有更多的一重含义。</p><p>为了方便解释，我们首先需要引入一个模板相关的概念：模板内出现的名称如果相依于某个模板参数，我们称之为<strong>从属名称（dependent names）</strong>；如果从属名称在类内呈嵌套状，我们称之为<strong>嵌套从属名称（nested dependent name）</strong>；如果一个名称并不倚赖任何模板参数的名称，我们称之为<strong>非从属名称（non-dependent names）</strong>。</p><p>考虑以下模板代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> C<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">Print2nd</span><span class="token punctuation">(</span><span class="token keyword">const</span> C<span class="token operator">&amp;</span> container<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>container<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        C<span class="token operator">::</span>const_iterator <span class="token function">iter</span><span class="token punctuation">(</span>container<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">++</span>iter<span class="token punctuation">;</span>        <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token operator">*</span>iter<span class="token punctuation">;</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码看起来没有任何问题，但实际编译时却会报错，这一切的罪魁祸首便是<code>C::const_iterator</code>。此处的<code>C::const_iterator</code>是一个指向某类型的<strong>嵌套从属类型名称（nested dependent type name）</strong>，而嵌套从属名称可能会导致解析困难，因为在编译器知道<code>C</code>是什么之前，没有任何办法知道<code>C::const_iterator</code>是否为一个类型，这就导致出现了歧义状态，而 C++ 默认假设嵌套从属名称不是类型名称。</p><p>显式指明嵌套从属类型名称的方法就是将<code>typename</code>关键字作为其前缀词：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">typename</span> C<span class="token operator">::</span>const_iterator <span class="token function">iter</span><span class="token punctuation">(</span>container<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同样地，若嵌套从属名称出现在模板函数声明部分，也需要显式地指明是否为类型名称：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> C<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">Print2nd</span><span class="token punctuation">(</span><span class="token keyword">const</span> C<span class="token operator">&amp;</span> container<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">typename</span> C<span class="token operator">::</span>iterator iter<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这一规则的例外是，<code>typename</code>不可以出现在基类列表内的嵌套从属类型名称之前，也不可以在成员初始化列表中作为基类的修饰符：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>Nested <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 基类列表中不允许使用 typename</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">explicit</span> <span class="token function">Derived</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>        <span class="token operator">:</span> Base<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">Nested</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                 <span class="token comment" spellcheck="true">// 成员初始化列表中不允许使用 typename</span>        <span class="token keyword">typename</span> Base<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>Nested temp<span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在类型名称过于复杂时，可以使用<code>using</code>或<code>typedef</code>来进行简化：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> value_type <span class="token operator">=</span> <span class="token keyword">typename</span> std<span class="token operator">::</span>iterator_traits<span class="token operator">&lt;</span>IterT<span class="token operator">></span><span class="token operator">::</span>value_type<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="条款-43：学习处理模板化基类内的名称"><a href="#条款-43：学习处理模板化基类内的名称" class="headerlink" title="条款 43：学习处理模板化基类内的名称"></a>条款 43：学习处理模板化基类内的名称</h3><p>在模板编程中，模板类的继承并不像普通类那么自然，考虑以下情形：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MsgInfo</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Company<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">MsgSender</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">SendClear</span><span class="token punctuation">(</span><span class="token keyword">const</span> MsgInfo<span class="token operator">&amp;</span> info<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Company<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">LoggingMsgSender</span> <span class="token operator">:</span> <span class="token keyword">public</span> MsgSender<span class="token operator">&lt;</span>Company<span class="token operator">></span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">SendClearMsg</span><span class="token punctuation">(</span><span class="token keyword">const</span> MsgInfo<span class="token operator">&amp;</span> info<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">SendClear</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 调用基类函数，这段代码无法通过编译</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很明显，由于直到模板类被真正实例化之前，编译器并不知道<code>MsgSender&lt;Company&gt;</code>具体长什么样，有可能它是一个全特化的版本，而在这个版本中不存在<code>SendClear</code>函数。由于 C++ 的设计策略是宁愿较早进行诊断，所以编译器会拒绝承认在基类中存在一个<code>SendClear</code>函数。</p><p>为了解决这个问题，我们需要令 C++“进入模板基类观察”的行为生效，有三种办法达成这个目标：</p><p>第一种：在基类函数调用动作之前加上<code>this-&gt;</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">SendClear</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第二种：使用<code>using</code>声明式：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> MsgSender<span class="token operator">&lt;</span>Company<span class="token operator">></span><span class="token operator">::</span>SendClear<span class="token punctuation">;</span><span class="token function">SendClear</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第三种：明白指出被调用的函数位于基类内：</p><pre class="line-numbers language-cpp"><code class="language-cpp">MsgSender<span class="token operator">&lt;</span>Company<span class="token operator">></span><span class="token operator">::</span><span class="token function">SendClear</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第三种做法是最不令人满意的，如果被调用的是虚函数，上述的明确资格修饰（explicit qualification）会使“虚函数绑定行为”失效。</p><h3 id="条款-44：将与参数无关的代码抽离模板"><a href="#条款-44：将与参数无关的代码抽离模板" class="headerlink" title="条款 44：将与参数无关的代码抽离模板"></a>条款 44：将与参数无关的代码抽离模板</h3><p>模板可以节省时间和避免代码重复，编译器会为填入的每个不同模板参数具现化出一份对应的代码，但长此以外，可能会造成代码膨胀（code bloat），生成浮夸的二进制目标码。</p><p>基于<strong>共性和变性分析（commonality and variability analysis）</strong> 的方法，我们需要分析模板中重复使用的部分，将其抽离出模板，以减轻模板具现化带来的代码量。</p><ul><li>因非类型模板参数而造成的代码膨胀，往往可以消除，做法是以函数参数或类成员变量替换模板参数。</li><li>因类型模板参数而造成的代码膨胀，往往可以降低，做法是让带有完全相同二进制表述的具现类型共享实现代码。</li></ul><p>参考以下矩阵类的例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t n<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">SquareMatrix</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">Invert</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>array<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> n <span class="token operator">*</span> n<span class="token operator">></span> data<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改为：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">SquareMatrixBase</span> <span class="token punctuation">{</span><span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">Invert</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t matrixSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>array<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> n <span class="token operator">*</span> n<span class="token operator">></span> data<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t n<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">SquareMatrix</span> <span class="token operator">:</span> <span class="token keyword">private</span> SquareMatrixBase<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// private 继承实现，见条款 39</span>    <span class="token keyword">using</span> SquareMatrixBase<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>Invert<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 避免掩盖基类函数，见条款 33</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">Invert</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">Invert</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>              <span class="token comment" spellcheck="true">// 调用模板基类函数，见条款 43</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Invert</code>并不是我们唯一要使用的矩阵操作函数，而且每次都往基类传递矩阵尺寸显得太过繁琐，我们可以考虑将数据放在派生类中，在基类中储存指针和矩阵尺寸。修改代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">SquareMatrixBase</span> <span class="token punctuation">{</span><span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token function">SquareMatrixBase</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t n<span class="token punctuation">,</span> T<span class="token operator">*</span> pMem<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">size</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">pData</span><span class="token punctuation">(</span>pMem<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">SetDataPtr</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span> pData <span class="token operator">=</span> ptr<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>size_t size<span class="token punctuation">;</span>    T<span class="token operator">*</span> pData<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t n<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">SquareMatrix</span> <span class="token operator">:</span> <span class="token keyword">private</span> SquareMatrixBase<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">SquareMatrix</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> SquareMatrixBase<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> data<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>array<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> n <span class="token operator">*</span> n<span class="token operator">></span> data<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然而这种做法并非永远能取得优势，硬是绑着矩阵尺寸的那个版本，有可能生成比共享版本更佳的代码。例如在尺寸专属版中，尺寸是个编译期常量，因此可以在编译期藉由常量的广传达到最优化；而在共享版本中，不同大小的矩阵只拥有单一版本的函数，可减少可执行文件大小，也就因此降低程序的 working set（在“虚内存环境”下执行的进程所使用的一组内存页），并强化指令高速缓存区内的引用集中化（locality of reference），这些都可能使程序执行得更快速。究竟哪个版本更佳，只能经由具体的测试后决定。</p><p>同样地，上面的代码也使用到了牺牲封装性的<code>protected</code>，可能会导致资源管理上的混乱和复杂，考虑到这些，也许一点点模板代码的重复并非不可接受。</p><h3 id="条款-45：运用成员函数模板接受所有兼容类型"><a href="#条款-45：运用成员函数模板接受所有兼容类型" class="headerlink" title="条款 45：运用成员函数模板接受所有兼容类型"></a>条款 45：运用成员函数模板接受所有兼容类型</h3><p>C++ 视模板类的不同具现体为完全不同的的类型，但在泛型编程中，我们可能需要一个模板类的不同具现体能够相互类型转换。</p><p>考虑设计一个智能指针类，而智能指针需要支持不同类型指针之间的隐式转换（如果可以的话），以及普通指针到智能指针的显式转换。很显然，我们需要的是模板拷贝构造函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">SmartPtr</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> U<span class="token operator">></span>    <span class="token function">SmartPtr</span><span class="token punctuation">(</span><span class="token keyword">const</span> SmartPtr<span class="token operator">&lt;</span>U<span class="token operator">></span><span class="token operator">&amp;</span> other<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">heldPtr</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> U<span class="token operator">></span>    <span class="token keyword">explicit</span> <span class="token function">SmartPtr</span><span class="token punctuation">(</span>U<span class="token operator">*</span> p<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">heldPtr</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>    T<span class="token operator">*</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> heldPtr<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    T<span class="token operator">*</span> heldPtr<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>get</code>获取原始指针，并将在原始指针之间进行类型转换本身提供了一种保障，如果原始指针之间不能隐式转换，那么其对应的智能指针之间的隐式转换会造成编译错误。</p><p>模板构造函数并不会阻止编译器暗自生成默认的构造函数，所以如果你想要控制拷贝构造的方方面面，你必须同时声明泛化拷贝构造函数和普通拷贝构造函数，相同规则也适用于赋值运算符：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">shared_ptr</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">shared_ptr</span><span class="token punctuation">(</span>shared_ptr <span class="token keyword">const</span><span class="token operator">&amp;</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 拷贝构造函数</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Y<span class="token operator">></span>    <span class="token function">shared_ptr</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>Y<span class="token operator">></span> <span class="token keyword">const</span><span class="token operator">&amp;</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 泛化拷贝构造函数</span>    shared_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>shared_ptr <span class="token keyword">const</span><span class="token operator">&amp;</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 拷贝赋值运算符</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Y<span class="token operator">></span>    shared_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>Y<span class="token operator">></span> <span class="token keyword">const</span><span class="token operator">&amp;</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 泛化拷贝赋值运算符</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-46：需要类型转换时请为模板定义非成员函数"><a href="#条款-46：需要类型转换时请为模板定义非成员函数" class="headerlink" title="条款 46：需要类型转换时请为模板定义非成员函数"></a>条款 46：需要类型转换时请为模板定义非成员函数</h3><p>该条款与条款 24 一脉相承，还是使用原先的例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Rational</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Rational</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> numerator <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> denominator <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token function">Numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token function">Denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span><span class="token function">Numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> rhs<span class="token punctuation">.</span><span class="token function">Numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lhs<span class="token punctuation">.</span><span class="token function">Denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> rhs<span class="token punctuation">.</span><span class="token function">Denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Rational<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">oneHalf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Rational<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> result <span class="token operator">=</span> oneHalf <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 无法通过编译！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述失败启示我们：模板实参在推导过程中，从不将隐式类型转换纳入考虑。虽然以<code>oneHalf</code>推导出<code>Rational&lt;int&gt;</code>类型是可行的，但是试图将<code>int</code>类型隐式转换为<code>Rational&lt;T&gt;</code>是绝对会失败的。</p><p>由于模板类并不依赖模板实参推导，所以编译器总能够在<code>Rational&lt;T&gt;</code>具现化时得知<code>T</code>，因此我们可以使用友元声明式在模板类内指涉特定函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Rational</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">friend</span> <span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在模板类内，模板名称可被用来作为“模板及其参数”的简略表达形式，因此下面的写法也是一样的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Rational</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">friend</span> <span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当对象<code>oneHalf</code>被声明为一个<code>Rational&lt;int&gt;</code>时，<code>Rational&lt;int&gt;</code>类于是被具现化出来，而作为过程的一部分，友元函数<code>operator*</code>也就被自动声明出来，其为一个普通函数而非模板函数，因此在接受参数时可以正常执行隐式转换。</p><p>为了使程序能正常链接，我们需要为其提供对应的定义式，最简单有效的方法就是直接合并至声明式处：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">friend</span> <span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">Rational</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span><span class="token function">Numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> rhs<span class="token punctuation">.</span><span class="token function">Numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lhs<span class="token punctuation">.</span><span class="token function">Denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> rhs<span class="token punctuation">.</span><span class="token function">Denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>由于定义在类内的函数都会暗自成为内联函数，为了降低内联带来的冲击，可以使<code>operator*</code>调用类外的辅助模板函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Rational</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">DoMultiply</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span><span class="token function">Numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> rhs<span class="token punctuation">.</span><span class="token function">Numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lhs<span class="token punctuation">.</span><span class="token function">Denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> rhs<span class="token punctuation">.</span><span class="token function">Denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Rational</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">friend</span> <span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">DoMultiply</span><span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-47：请使用-traits-classes-表现类型信息"><a href="#条款-47：请使用-traits-classes-表现类型信息" class="headerlink" title="条款 47：请使用 traits classes 表现类型信息"></a>条款 47：请使用 traits classes 表现类型信息</h3><p>traits classes 可以使我们在编译期就能获取某些类型信息，它被广泛运用于 C++ 标准库中。traits 并不是 C++ 关键字或一个预先定义好的构件：它们是一种技术，也是 C++ 程序员所共同遵守的协议，并要求对用户自定义类型和内置类型表现得一样好。</p><p>设计并实现一个 trait class 的步骤如下：</p><ol><li>确认若干你希望将来可取得的类型相关信息。</li><li>为该类型选择一个名称。</li><li>提供一个模板和一组特化版本，内含你希望支持的类型相关信息。</li></ol><p>以迭代器为例，标准库中拥有多种不同的迭代器种类，它们各自拥有不同的功用和限制：</p><ol><li><code>input_iterator_tag</code>：单向输入迭代器，只能向前移动，一次一步，客户只可读取它所指的东西。</li><li><code>output_iterator_tag</code>：单向输出迭代器，只能向前移动，一次一步，客户只可写入它所指的东西。</li><li><code>forward_iterator_tag</code>：单向访问迭代器，只能向前移动，一次一步，读写均允许。</li><li><code>bidirectional_iterator_tag</code>：双向访问迭代器，去除了只能向前移动的限制。</li><li><code>random_access_iterator_tag</code>：随机访问迭代器，没有一次一步的限制，允许随意移动，可以执行“迭代器算术”。</li></ol><p>标准库为这些迭代器种类提供的卷标结构体（tag struct）的继承关系如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> input_iterator_tag <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> output_iterator_tag <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> forward_iterator_tag <span class="token operator">:</span> input_iterator_tag <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> bidirectional_iterator_tag <span class="token operator">:</span> forward_iterator_tag <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> random_access_iterator_tag <span class="token operator">:</span> bidirectional_iterator_tag <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将<code>iterator_category</code>作为迭代器种类的名称，嵌入容器的迭代器中，并且确认使用适当的卷标结构体：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">deque</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">class</span> <span class="token class-name">iterator</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token keyword">using</span> iterator_category <span class="token operator">=</span> random_access_iterator<span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">list</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">class</span> <span class="token class-name">iterator</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token keyword">using</span> iterator_category <span class="token operator">=</span> bidirectional_iterator<span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了做到类型的 traits 信息可以在类型自身之外获得，标准技术是把它放进一个模板及其一个或多个特化版本中。这样的模板在标准库中有若干个，其中针对迭代器的是<code>iterator_traits</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">IterT</span><span class="token operator">></span><span class="token keyword">struct</span> iterator_traits <span class="token punctuation">{</span>    <span class="token keyword">using</span> iterator_category <span class="token operator">=</span> IterT<span class="token operator">::</span>iterator_category<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了支持指针迭代器，<code>iterator_traits</code>特别针对指针类型提供一个偏特化版本，而指针的类型和随机访问迭代器类似，所以可以写出如下代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">IterT</span><span class="token operator">></span><span class="token keyword">struct</span> iterator_traits<span class="token operator">&lt;</span>IterT<span class="token operator">*</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">using</span> iterator_category <span class="token operator">=</span> random_access_iterator_tag<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当我们需要为不同的迭代器种类应用不同的代码时，traits classes 就派上用场了：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> IterT<span class="token punctuation">,</span> <span class="token keyword">typename</span> DisT<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">advance</span><span class="token punctuation">(</span>IterT<span class="token operator">&amp;</span> iter<span class="token punctuation">,</span> DisT d<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeid</span><span class="token punctuation">(</span>std<span class="token operator">::</span>iterator_traits<span class="token operator">&lt;</span>IterT<span class="token operator">></span><span class="token operator">::</span>iterator_category<span class="token punctuation">)</span>        <span class="token operator">==</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>std<span class="token operator">::</span>random_access_iterator_tag<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但这些代码实际上是错误的，我们希望类型的判断能在编译期完成。<code>iterator_category</code>是在编译期决定的，然而<code>if</code>却是在运行期运作的，无法达成我们的目标。</p><p>在 C++17 之前，解决这个问题的主流做法是利用函数重载（也是原书中介绍的做法）：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> IterT<span class="token punctuation">,</span> <span class="token keyword">typename</span> DisT<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">doAdvance</span><span class="token punctuation">(</span>IterT<span class="token operator">&amp;</span> iter<span class="token punctuation">,</span> DisT d<span class="token punctuation">,</span> std<span class="token operator">::</span>random_access_iterator_tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>   <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> IterT<span class="token punctuation">,</span> <span class="token keyword">typename</span> DisT<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">doAdvance</span><span class="token punctuation">(</span>IterT<span class="token operator">&amp;</span> iter<span class="token punctuation">,</span> DisT d<span class="token punctuation">,</span> std<span class="token operator">::</span>bidirectional_iterator_tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> IterT<span class="token punctuation">,</span> <span class="token keyword">typename</span> DisT<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">doAdvance</span><span class="token punctuation">(</span>IterT<span class="token operator">&amp;</span> iter<span class="token punctuation">,</span> DisT d<span class="token punctuation">,</span> std<span class="token operator">::</span>input_iterator_tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>d <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">out_of_range</span><span class="token punctuation">(</span><span class="token string">"Negative distance"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 单向迭代器不允许负距离</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> IterT<span class="token punctuation">,</span> <span class="token keyword">typename</span> DisT<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">advance</span><span class="token punctuation">(</span>IterT<span class="token operator">&amp;</span> iter<span class="token punctuation">,</span> DisT d<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">doAdvance</span><span class="token punctuation">(</span>iter<span class="token punctuation">,</span> d<span class="token punctuation">,</span> std<span class="token operator">::</span>iterator_traits<span class="token operator">&lt;</span>IterT<span class="token operator">></span><span class="token operator">::</span><span class="token function">iterator_category</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 C++17 之后，我们有了更简单有效的做法——使用<code>if constexpr</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> IterT<span class="token punctuation">,</span> <span class="token keyword">typename</span> DisT<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">Advance</span><span class="token punctuation">(</span>IterT<span class="token operator">&amp;</span> iter<span class="token punctuation">,</span> DisT d<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span><span class="token keyword">typeid</span><span class="token punctuation">(</span>std<span class="token operator">::</span>iterator_traits<span class="token operator">&lt;</span>IterT<span class="token operator">></span><span class="token operator">::</span>iterator_category<span class="token punctuation">)</span>        <span class="token operator">==</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>std<span class="token operator">::</span>random_access_iterator_tag<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-48：认识模板元编程"><a href="#条款-48：认识模板元编程" class="headerlink" title="条款 48：认识模板元编程"></a>条款 48：认识模板元编程</h3><p>模板元编程（Template metaprogramming，TMP）是编写基于模板的 C++ 程序并执行于编译期的过程，它并不是刻意被设计出来的，而是当初 C++ 引入模板带来的副产品，事实证明模板元编程具有强大的作用，并且现在已经成为 C++ 标准的一部分。实际上，在条款 47 中编写 traits classes 时，我们就已经在进行模板元编程了。</p><p>由于模板元程序执行于 C++ 编译期，因此可以将一些工作从运行期转移至编译期，这可以帮助我们在编译期时发现一些原本要在运行期时才能察觉的错误，以及得到较小的可执行文件、较短的运行期、较少的内存需求。当然，副作用就是会使编译时间变长。</p><p>模板元编程已被证明是“图灵完备”的，并且以“函数式语言”的形式发挥作用，因此在模板元编程中没有真正意义上的循环，所有循环效果只能藉由递归实现，而递归在模板元编程中是由 <strong>“递归模板具现化（recursive template instantiation）”</strong> 实现的。</p><p>常用于引入模板元编程的例子是在编译期计算阶乘：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">unsigned</span> n<span class="token operator">></span>            <span class="token comment" spellcheck="true">// Factorial&lt;n> = n * Factorial&lt;n-1></span><span class="token keyword">struct</span> Factorial <span class="token punctuation">{</span>    <span class="token keyword">enum</span> <span class="token punctuation">{</span> value <span class="token operator">=</span> n <span class="token operator">*</span> Factorial<span class="token operator">&lt;</span>n<span class="token number">-1</span><span class="token operator">></span><span class="token operator">::</span>value <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">struct</span> Factorial<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">></span> <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">// 处理特殊情况：Factorial&lt;0> = 1</span>    <span class="token keyword">enum</span> <span class="token punctuation">{</span> value <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> Factorial<span class="token operator">&lt;</span><span class="token number">5</span><span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>模板元编程很酷，但对其进行调试可能是灾难性的，因此在实际应用中并不常见。我们可能会在下面几种情形中见到它的出场：</p><ol><li>确保量度单位正确。</li><li>优化矩阵计算。</li><li>可以生成客户定制之设计模式（custom design pattern）实现品。</li></ol><h2 id="第八章：定制-new-和-delete"><a href="#第八章：定制-new-和-delete" class="headerlink" title="第八章：定制 new 和 delete"></a>第八章：定制 new 和 delete</h2><h3 id="条款-49：了解-new-handler-的行为"><a href="#条款-49：了解-new-handler-的行为" class="headerlink" title="条款 49：了解 new-handler 的行为"></a>条款 49：了解 new-handler 的行为</h3><p>当<code>operator new</code>无法满足某一内存分配需求时，会不断调用一个客户指定的错误处理函数，即所谓的 <strong>new-handler</strong>，直到找到足够内存为止，调用声明于<code>&lt;new&gt;</code>中的<code>set_new_handler</code>可以指定这个函数。<code>new_handler</code>和<code>set_new_handler</code>的定义如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">namespace</span> std <span class="token punctuation">{</span>    <span class="token keyword">using</span> new_handler <span class="token operator">=</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    new_handler <span class="token function">set_new_handler</span><span class="token punctuation">(</span>new_handler<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 返回值为原来持有的 new-handler</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>一个设计良好的 new-handler 函数必须做以下事情之一：</p><p><strong>让更多的内存可被使用：</strong> 可以让程序一开始执行就分配一大块内存，而后当 new-handler 第一次被调用，将它们释还给程序使用，造成<code>operator new</code>的下一次内存分配动作可能成功。</p><p><strong>安装另一个 new-handler：</strong> 如果目前这个 new-handler 无法取得更多内存，可以调换为另一个可以完成目标的 new-handler（令 new-handler 修改“会影响 new-handler 行为”的静态或全局数据）。</p><p><strong>卸除 new-handler：</strong> 将<code>nullptr</code>传给<code>set_new_handler</code>，这样会使<code>operator new</code>在内存分配不成功时抛出异常。</p><p><strong>抛出 bad_alloc（或派生自 bad_alloc）的异常：</strong> 这样的异常不会被<code>operator new</code>捕捉，因此会被传播到内存分配处。</p><p><strong>不返回：</strong> 通常调用<code>std::abort</code>或<code>std::exit</code>。</p><p>有的时候我们或许会希望在为不同的类分配对象时，使用不同的方式处理内存分配失败情况。这时候使用静态成员是不错的选择：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> std<span class="token operator">::</span>new_handler <span class="token function">set_new_handler</span><span class="token punctuation">(</span>std<span class="token operator">::</span>new_handler p<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">static</span> std<span class="token operator">::</span>new_handler currentHandler<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 做和 std::set_new_handler 相同的事情</span>std<span class="token operator">::</span>new_handler Widget<span class="token operator">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>std<span class="token operator">::</span>new_handler p<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>new_handler oldHandler <span class="token operator">=</span> currentHandler<span class="token punctuation">;</span>    currentHandler <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token keyword">return</span> oldHandler<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">void</span><span class="token operator">*</span> Widget<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> globalHandler <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>currentHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 切换至 Widget 的专属 new-handler</span>    <span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>                           <span class="token comment" spellcheck="true">// 分配内存或抛出异常</span>    std<span class="token operator">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>globalHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 切换回全局的 new-handler</span>    <span class="token keyword">return</span> globalHandler<span class="token punctuation">;</span><span class="token punctuation">}</span>std<span class="token operator">::</span>new_handler Widget<span class="token operator">::</span>currentHandler <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Widget</code>的客户应该类似这样使用其 new-handling：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">OutOfMem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Widget<span class="token operator">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>OutOfMem<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> pw1 <span class="token operator">=</span> <span class="token keyword">new</span> Widget<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 若分配失败，则调用 OutOfMem</span>Widget<span class="token operator">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> pw2 <span class="token operator">=</span> <span class="token keyword">new</span> Widget<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 若分配失败，则抛出异常</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现这一方案的代码并不因类的不同而不同，因此对这些代码加以复用是合理的构想。一个简单的做法是建立起一个“mixin”风格的基类，让其派生类继承它们所需的<code>set_new_handler</code>和<code>operator new</code>，并且使用模板确保每一个派生类获得一个实体互异的<code>currentHandler</code>成员变量：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">NewHandlerSupport</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// “mixin”风格的基类</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> std<span class="token operator">::</span>new_handler <span class="token function">set_new_handler</span><span class="token punctuation">(</span>std<span class="token operator">::</span>new_handler p<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                         <span class="token comment" spellcheck="true">// 其它的 operator new 版本，见条款 52</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">static</span> std<span class="token operator">::</span>new_handler currentHandler<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>std<span class="token operator">::</span>new_handler NewHandlerSupport<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>std<span class="token operator">::</span>new_handler p<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>new_handler oldHandler <span class="token operator">=</span> currentHandler<span class="token punctuation">;</span>    currentHandler <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token keyword">return</span> oldHandler<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span><span class="token operator">*</span> NewHandlerSupport<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> globalHandler <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>currentHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>globalHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> globalHandler<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>std<span class="token operator">::</span>new_handler NewHandlerSupport<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>currentHandler <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token operator">:</span> <span class="token keyword">public</span> NewHandlerSupport<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                         <span class="token comment" spellcheck="true">// 不必再声明 set_new_handler 和 operator new</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意此处的模板参数<code>T</code>并没有真正被当成类型使用，而仅仅是用来区分不同的派生类，使得模板机制为每个派生类具现化出一份对应的<code>currentHandler</code>。</p><p>这个做法用到了所谓的 <strong>CRTP（curious recurring template pattern，奇异递归模板模式）</strong> ，除了在上述设计模式中用到之外，它也被用于实现<strong>静态多态</strong>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Derived</span><span class="token operator">></span> <span class="token keyword">struct</span> Base <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">Interface</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Derived<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">Implementation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 在基类中暴露接口</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> Derived <span class="token operator">:</span> Base<span class="token operator">&lt;</span>Derived<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">Implementation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                  <span class="token comment" spellcheck="true">// 在派生类中提供实现</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了会调用 new-handler 的<code>operator new</code>以外，C++ 还保留了传统的“分配失败便返回空指针”的<code>operator new</code>，称为 nothrow new，通过<code>std::nothrow</code>对象来使用它：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget<span class="token operator">*</span> pw1 <span class="token operator">=</span> <span class="token keyword">new</span> Widget<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 如果分配失败，抛出 bad_alloc</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pw1 <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                     <span class="token comment" spellcheck="true">// 这个测试一定失败</span>Widget<span class="token operator">*</span> pw2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>nothrow<span class="token punctuation">)</span> Widget<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果分配失败，返回空指针</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pw2 <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                     <span class="token comment" spellcheck="true">// 这个测试可能成功</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>nothrow new 对异常的强制保证性并不高，使用它只能保证<code>operator new</code>不抛出异常，而无法保证像<code>new (std::nothrow) Widget</code>这样的表达式不会导致异常，因此实际上并没有使用 nothrow new 的必要。</p><h3 id="条款-50：了解-new-和-delete-的合理替换时机"><a href="#条款-50：了解-new-和-delete-的合理替换时机" class="headerlink" title="条款 50：了解 new 和 delete 的合理替换时机"></a>条款 50：了解 new 和 delete 的合理替换时机</h3><p>以下是常见的替换默认<code>operator new</code>和<code>operator delete</code>的理由：</p><p><strong>用来检测运用上的错误：</strong> 如果将“new 所得内存”delete 掉却不幸失败，会导致内存泄漏；如果在“new 所得内存”身上多次 delete 则会导致未定义行为。如果令<code>operator new</code>持有一串动态分配所得地址，而<code>operator delete</code>将地址从中移除，就很容易检测出上述错误用法。此外各式各样的编程错误可能导致 <strong>“overruns”（写入点在分配区块尾端之后）</strong> 和 <strong>“underruns”（写入点在分配区块起点之前）</strong>，以额外空间放置特定的 byte pattern 签名，检查签名是否原封不动就可以检测此类错误，下面给出了一个这样的范例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> signature <span class="token operator">=</span> <span class="token number">0xDEADBEEF</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 调试“魔数”</span><span class="token keyword">using</span> Byte <span class="token operator">=</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>    size_t realSize <span class="token operator">=</span> size <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 分配额外空间以塞入两个签名</span>    <span class="token keyword">void</span><span class="token operator">*</span> pMem <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>realSize<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 调用 malloc 取得内存</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pMem<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token function">bad_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将签名写入内存的起点和尾端</span>    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>pMem<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> signature<span class="token punctuation">;</span>    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Byte<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>pMem<span class="token punctuation">)</span> <span class="token operator">+</span> realSize <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> signature<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Byte<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>pMem<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 返回指针指向第一个签名后的内存位置</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上这段代码不能保证内存对齐，并且有许多地方不遵守 C++ 规范，我们将在条款 51 中进行详细讨论。</p><p><strong>为了收集使用上的统计数据：</strong> 定制 new 和 delete 动态内存的相关信息：分配区块的大小分布，寿命分布，FIFO（先进先出）、LIFO（后进先出）或随机次序的倾向性，不同的分配/归还形态，使用的最大动态分配量等等。</p><p><strong>为了增加分配和归还的速度：</strong> 泛用型分配器往往（虽然并非总是）比定制型分配器慢，特别是当定制型分配器专门针对某特定类型之对象设计时。类专属的分配器可以做到“区块尺寸固定”，例如 Boost 提供的 Pool 程序库。又例如，编译器所带的内存管理器是线程安全的，但如果你的程序是单线程的，你也可以考虑写一个不线程安全的分配器来提高速度。当然，这需要你对程序进行分析，并确认程序瓶颈的确发生在那些内存函数身上。</p><p><strong>为了降低缺省内存管理器带来的空间额外开销：</strong> 泛用型分配器往往（虽然并非总是）还比定制型分配器使用更多内存，那是因为它们常常在每一个分配区块身上招引某些额外开销。针对小型对象而开发的分配器（例如 Boost 的 Pool 程序库）本质上消除了这样的额外开销。</p><p><strong>为了弥补缺省分配器中的非最佳内存对齐（suboptimal alignment）：</strong> 许多计算机体系架构要求特定的类型必须放在特定的内存地址上，如果没有奉行这个约束条件，可能导致运行期硬件异常，或者访问速度变低。<code>std::max_align_t</code>用来返回当前平台的最大默认内存对齐类型，对于<code>malloc</code>分配的内存，其对齐和<code>max_align_t</code>类型的对齐大小应当是一致的，但若对<code>malloc</code>返回的指针进行偏移，就没有办法保证内存对齐。</p><p>在 C++11 中，提供了以下内存对齐相关方法：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// alignas 用于指定栈上数据的内存对齐要求</span><span class="token keyword">struct</span> <span class="token keyword">alignas</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> testStruct <span class="token punctuation">{</span> <span class="token keyword">double</span> data<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// alignof 和 std::alignment_of 用于得到给定类型的内存对齐要求</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">alignof</span><span class="token punctuation">(</span>std<span class="token operator">::</span>max_align_t<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>alignment_of<span class="token operator">&lt;</span>std<span class="token operator">::</span>max_align_t<span class="token operator">></span><span class="token operator">::</span>value <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// std::align 用于在一大块内存中获取一个符合指定内存要求的地址</span><span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"memory alignment"</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> buffer<span class="token punctuation">;</span>std<span class="token operator">::</span>size_t space <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>std<span class="token operator">::</span><span class="token function">align</span><span class="token punctuation">(</span><span class="token keyword">alignof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ptr<span class="token punctuation">,</span> space<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 C++17 后，可以使用<code>std::align_val_t</code>来重载需求额外内存对齐的<code>operator new</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t count<span class="token punctuation">,</span> std<span class="token operator">::</span>align_val_t al<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>为了将相关对象成簇集中：</strong> 如果你知道特定的某个数据结构往往被一起使用，而你又希望在处理这些数据时将“内存页错误（page faults）”的频率降至最低，那么可以考虑为此数据结构创建一个堆，将它们成簇集中在尽可能少的内存页上。一般可以使用 placement new 达成这个目标（见条款 52）。</p><p><strong>为了获得非传统的行为：</strong> 有时候你会希望<code>operator new</code>和<code>operator delete</code>做编译器版不会做的事情，例如分配和归还共享内存（shared memory），而这些事情只能被 C API 完成，则可以将 C API 封在 C++ 的外壳里，写在定制的 new 和 delete 中。</p><h3 id="条款-51：编写-new-和-delete-时需固守常规"><a href="#条款-51：编写-new-和-delete-时需固守常规" class="headerlink" title="条款 51：编写 new 和 delete 时需固守常规"></a>条款 51：编写 new 和 delete 时需固守常规</h3><p>我们在条款 49 中已经提到过一些<code>operator new</code>的规矩，比如内存不足时必须不断调用 new-handler，如果无法供应客户申请的内存，就抛出<code>std::bad_alloc</code>异常。C++ 还有一个奇怪的规定，即使客户需求为0字节，<code>operator new</code>也得返回一个合法的指针，这种看似诡异的行为其实是为了简化语言其他部分。</p><p>根据这些规约，我们可以写出非成员函数版本的<code>operator new</code>代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// 处理0字节申请</span>        size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 将其视为1字节申请</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 如果分配成功</span>            <span class="token keyword">return</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回指针指向分配得到的内存</span>        <span class="token comment" spellcheck="true">// 如果分配失败，调用目前的 new-handler</span>        <span class="token keyword">auto</span> globalHandler <span class="token operator">=</span> <span class="token function">get_new_handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// since C++11</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>globalHandler<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>globalHandler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">bad_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>operator new</code>的成员函数版本一般只会分配大小刚好为类的大小的内存空间，但是情况并不总是如此，比如假设我们没有为派生类声明其自己的<code>operator new</code>，那么派生类会从基类继承<code>operator new</code>，这就导致派生类可以使用其基类的 new 分配方式，但派生类和基类的大小很多时候是不同的。</p><p>处理此情况的最佳做法是将“内存申请量错误”的调用行为改为采用标准的<code>operator new</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> Base<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">!=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Base<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 转交给标准的 operator new 进行处理</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意在<code>operator new</code>的成员函数版本中我们也不需要检测分配的大小是否为0了，因为在条款 39 中我们提到过，非附属对象必须有非零大小，所以<code>sizeof(Base)</code>无论如何也不能为0。</p><p>如果你打算实现<code>operator new[]</code>，即所谓的 array new，那么你唯一要做的一件事就是分配一块未加工的原始内存，因为你无法对 array 之内迄今尚未存在的元素对象做任何事情，实际上你甚至无法计算这个 array 将含有多少元素对象。</p><p><code>operator delete</code>的规约更加简单，你需要记住的唯一一件事情就是 C++ 保证 <strong>“删除空指针永远安全”</strong>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> rawMemory<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>rawMemory <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 归还 rawMemory 所指的内存</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>operator delete</code>的成员函数版本要多做的唯一一件事就是将大小有误的删除行为转交给标准的<code>operator delete</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> Base<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> rawMemory<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t size<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>rawMemory <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">!=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Base<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span>rawMemory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 转交给标准的 operator delete 进行处理</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 归还 rawMemory 所指的内存</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果即将被删除的对象派生自某个基类而后者缺少虚析构函数，那么 C++ 传给<code>operator delete</code>的<code>size</code>大小可能不正确，这或许是“为多态基类声明虚析构函数”的一个足够的理由，能作为对条款 7 的补充。</p><h3 id="条款-52：写了-placement-new-也要写-placement-delete"><a href="#条款-52：写了-placement-new-也要写-placement-delete" class="headerlink" title="条款 52：写了 placement new 也要写 placement delete"></a>条款 52：写了 placement new 也要写 placement delete</h3><p>placement new 最初的含义指的是“接受一个指针指向对象该被构造之处”的<code>operator new</code>版本，它在标准库中的用途广泛，其中之一是负责在 vector 的未使用空间上创建对象，它的声明如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> pMemory<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们此处要讨论的是广义上的 placement new，即带有附加参数的<code>operator new</code>，例如下面这种：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t<span class="token punctuation">,</span> std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span> logStream<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> pw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>cerr<span class="token punctuation">)</span> Widget<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当我们在使用 new 表达式创建对象时，共有两个函数被调用：一个是用以分配内存的<code>operator new</code>，一个是对象的构造函数。假设第一个函数调用成功，而第二个函数却抛出异常，那么会由 C++ runtime 调用<code>operator delete</code>，归还已经分配好的内存。</p><p>这一切的前提是 C++ runtime 能够找到<code>operator new</code>对应的<code>operator delete</code>，如果我们使用的是自定义的 placement new，而没有为其准备对应的 placement delete 的话，就无法避免发生内存泄漏。因此，合格的代码应该是这样的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">,</span> std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span> logStream<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// placement new</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> pMemory<span class="token punctuation">)</span><span class="token punctuation">;</span>                             <span class="token comment" spellcheck="true">// delete 时调用的正常 operator delete</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> pMemory<span class="token punctuation">,</span> std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span> logStream<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// placement delete</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一个要注意的问题是，由于成员函数的名称会掩盖其外部作用域中的相同名称（见条款 33），所以提供 placement new 会导致无法使用正常版本的<code>operator new</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">,</span> std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span> logStream<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">auto</span> pb <span class="token operator">=</span> <span class="token keyword">new</span> Base<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 无法通过编译！</span><span class="token keyword">auto</span> pb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>cerr<span class="token punctuation">)</span> Base<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正确</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样道理，派生类中的<code>operator new</code>会掩盖全局版本和继承而得的<code>operator new</code>版本：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">auto</span> pd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>clog<span class="token punctuation">)</span> Derived<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 无法通过编译！</span><span class="token keyword">auto</span> pd <span class="token operator">=</span> <span class="token keyword">new</span> Derived<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 正确</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了避免名称遮掩问题，需要确保以下形式的<code>operator new</code>对于定制类型仍然可用，除非你的意图就是阻止客户使用它们：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span>std<span class="token operator">::</span>bad_alloc<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// normal new</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// placement new</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>nothrow_t<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// nothrow new</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一个最简单的实现方式是，准备一个基类，内含所有正常形式的 new 和 delete：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">StadardNewDeleteForms</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">// normal new/delete</span>    <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> pMemory<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>        <span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span>pMemory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// placement new/delete</span>    <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> pMemory<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>        <span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span>pMemory<span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// nothrow new/delete</span>    <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>nothrow_t<span class="token operator">&amp;</span> nt<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span>nt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> pMemory<span class="token punctuation">,</span><span class="token keyword">const</span> std<span class="token operator">::</span>nothrow_t<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>        <span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span>pMemory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>凡是想以自定义形式扩充标准形式的客户，可以利用继承和<code>using</code>声明式（见条款 33）取得标准形式：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span><span class="token operator">:</span> <span class="token keyword">public</span> StandardNewDeleteForms<span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> StandardNewDeleteForms<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">;</span>    <span class="token keyword">using</span> StandardNewDeleteForms<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">,</span> std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span> logStream<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token function">detele</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">,</span> std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span> logStream<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第九章：杂项讨论"><a href="#第九章：杂项讨论" class="headerlink" title="第九章：杂项讨论"></a>第九章：杂项讨论</h2><h3 id="条款-53：不要轻忽编译器的警告"><a href="#条款-53：不要轻忽编译器的警告" class="headerlink" title="条款 53：不要轻忽编译器的警告"></a>条款 53：不要轻忽编译器的警告</h3><ol><li>严肃对待编译器发出的警告信息。努力在你的编译器的最高（最严苛）警告级别下争取“无任何警告”的荣誉。</li><li>不要过度依赖编译器的警告能力，因为不同的编译器对待事情的态度不同。一旦移植到另一个编译器上，你原本依赖的警告信息可能会消失。</li></ol><h3 id="条款-54：让自己熟悉包括-TR1-在内的标准程序库"><a href="#条款-54：让自己熟悉包括-TR1-在内的标准程序库" class="headerlink" title="条款 54：让自己熟悉包括 TR1 在内的标准程序库"></a>条款 54：让自己熟悉包括 TR1 在内的标准程序库</h3><p>如今 TR1 草案已完全融入 C++ 标准当中，没有再过多了解 TR1 标准库的必要。</p><h3 id="条款-55：让自己熟悉-Boost"><a href="#条款-55：让自己熟悉-Boost" class="headerlink" title="条款 55：让自己熟悉 Boost"></a>条款 55：让自己熟悉 Boost</h3><p>Boost 是若干个程序库的集合，并且当中的许多库已经被 C++ 吸纳为标准库的一部分。不过在现在的 Modern C++ 时代，是否该在项目中使用 Boost 仍然有一定的争议，一些 Boost 组件并无法做到像 C++ 标准库那样高性能，零开销抽象，但毫无疑问的是，Boost 的参考价值是无法忽视的，你可以在 Boost 中找到许多非常值得学习和借鉴的实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一章：让自己习惯-C&quot;&gt;&lt;a href=&quot;#第一章：让自己习惯-C&quot; class=&quot;headerlink&quot; title=&quot;第一章：让自己习惯 C++&quot;&gt;&lt;/a&gt;第一章：让自己习惯 C++&lt;/h2&gt;&lt;h3 id=&quot;条款-1：视-C-为一个语言联邦&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Cpp中RAII和智能指针</title>
    <link href="https://joytsing.github.io/posts/57427/"/>
    <id>https://joytsing.github.io/posts/57427/</id>
    <published>2023-12-14T07:39:36.000Z</published>
    <updated>2023-12-14T14:45:37.916Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概-述"><a href="#概-述" class="headerlink" title="概 述"></a>概 述</h2><h3 id="RAII-Resource-Acquisition-Is-Initialization"><a href="#RAII-Resource-Acquisition-Is-Initialization" class="headerlink" title="RAII (Resource Acquisition Is Initialization)"></a><strong>RAII (Resource Acquisition Is Initialization)</strong></h3><p>RAII 要求，资源的有效期与持有资源的对象的生命期严格绑定，即由对象的构造函数完成资源的分配（获取），同时由析构函数，完成资源的释放。在这种要求下，只要对象能正确地析构，就不会出现资源泄露问题。</p><h3 id="C-三-五法则"><a href="#C-三-五法则" class="headerlink" title="C++三/五法则"></a><strong>C++三/五法则</strong></h3><ul><li>当定义一个类时，我们显式地或隐式地指定了此类型的对象在拷贝、赋值和销毁时做什么。一个类通过定义三种特殊的成员函数来控制这些操作，分别是拷贝构造函数、赋值运算符和析构函数。</li><li><strong>拷贝构造函数，定义了当用同类型的另一个对象初始化新对象时做什么；赋值运算符，定义了将一个对象赋予同类型的另一个对象时做什么；析构函数，定义了此类型的对象销毁时做什么。我们将这些操作称为拷贝控制操作</strong>。</li><li>由于拷贝控制操作是由三个特殊的成员函数来完成的，所以我们称此为“C++三法则”。在较新的C++11标准中，为了支持移动语义，又增加了<strong>移动构造函数</strong>和<strong>移动赋值运算符</strong>，这样共有五个特殊的成员函数，所以又称为“C++五法则”。也就是说，“三法则”是针对较旧的C++98 标准说的，“五法则” 是针对较新的C++11标准说的。为了统一称呼，后来人们干把它叫做“C++ 三/五法则”。</li></ul><p>RAII ， 如果没有解构函数，在每个带有返回的分支，都要手动释放所有之前的资源；与Java Python 等自动垃圾回收语言不同（由gc延时回收），C++结构函数是显示的，当进程离开了函数作用域自动销毁之前的资源，不含糊。这样做，有好处也有坏处，对于高性能计算，利大于弊。</p><h3 id="RAII，异常安全（exception-safe）"><a href="#RAII，异常安全（exception-safe）" class="headerlink" title="RAII，异常安全（exception-safe）"></a>RAII，异常安全（exception-safe）</h3><p>C++ 标准保证了当异常发生时，会调用已创建对象的解构函数，因此 C++中不需要 finally 语句。</p><pre class="line-numbers language-java"><code class="language-java">connection c <span class="token operator">=</span> driver<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>   c<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比如Java语句，需要在 finally 里显示 close资源，而 C++可以在 catch异常同时，自动释放资源。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>ofstream <span class="token function">fout</span><span class="token punctuation">(</span><span class="token string">"a.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    fout <span class="token operator">&lt;&lt;</span> <span class="token string">"in\n"</span><span class="token punctuation">;</span>    <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    fout <span class="token operator">&lt;&lt;</span> <span class="token string">"out\n"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>exception <span class="token keyword">const</span> <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"catch"</span> <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="编译器自动生成的函数：全家桶"><a href="#编译器自动生成的函数：全家桶" class="headerlink" title="编译器自动生成的函数：全家桶"></a><strong>编译器自动生成的函数：全家桶</strong></h2><p>除了 <strong>拷贝构造</strong>和 <strong>拷贝赋值</strong>，编译器会自动生成特殊函数。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> C <span class="token punctuation">{</span>    <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 默认构造函数</span>    <span class="token function">C</span><span class="token punctuation">(</span>C <span class="token keyword">const</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 拷贝构造函数</span>    <span class="token function">C</span><span class="token punctuation">(</span>C <span class="token operator">&amp;&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 移动构造函数 (C++11 引入)</span>    C <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>C <span class="token keyword">const</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 拷贝赋值函数</span>    C <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>C <span class="token operator">&amp;&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 移动赋值函数 (C++11 引入)</span>    <span class="token operator">~</span><span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 解构函数</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在其他面向对象语言中是看不到这些底层的函数。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">Pig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 拷贝构造</span><span class="token function">Pig</span><span class="token punctuation">(</span>Pig <span class="token keyword">const</span> <span class="token operator">&amp;</span>other<span class="token punctuation">)</span>    <span class="token operator">:</span> <span class="token function">m_name</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>m_name<span class="token punctuation">)</span>    <span class="token punctuation">,</span> <span class="token function">m_weight</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>m_weight<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 移动构造</span><span class="token function">Pig</span><span class="token punctuation">(</span>Pig <span class="token operator">&amp;&amp;</span>other<span class="token punctuation">)</span>    <span class="token operator">:</span> <span class="token function">m_name</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>m_name<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">,</span> <span class="token function">m_weight</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>m_weight<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 拷贝赋值</span>Pig <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Pig <span class="token keyword">const</span> <span class="token operator">&amp;</span>other<span class="token punctuation">)</span> <span class="token punctuation">{</span>    m_name <span class="token operator">=</span> other<span class="token punctuation">.</span>m_name<span class="token punctuation">;</span>    m_weight <span class="token operator">=</span> other<span class="token punctuation">.</span>m_weight<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 移动赋值</span>Pig <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Pig <span class="token operator">&amp;&amp;</span>other<span class="token punctuation">)</span> <span class="token punctuation">{</span>    m_name <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>m_name<span class="token punctuation">)</span><span class="token punctuation">;</span>    m_weight <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>m_weight<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">~</span><span class="token function">Pig</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++规定，除了智能指针，都是用深拷贝。以上这些函数都是编译器默认生成的。</p><h3 id="三五法则深入理解"><a href="#三五法则深入理解" class="headerlink" title="三五法则深入理解"></a>三五法则深入理解</h3><p><img src="https://pic4.zhimg.com/v2-666b134737e695bee046025df65e381b_r.jpg" alt></p><p>从一个例子出发。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">struct</span> Vector <span class="token punctuation">{</span>    size_t m_size<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>m_data<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//    Vector(size_t n) {    // 构造函数 - 对象初始化时调用</span><span class="token comment" spellcheck="true">//        m_size = n;</span><span class="token comment" spellcheck="true">//        m_data = (int *)malloc(n * sizeof(int));</span><span class="token comment" spellcheck="true">//    }</span>    <span class="token function">Vector</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">)</span>      <span class="token operator">:</span> <span class="token function">m_size</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_data</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>n <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">Vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">// 解构函数 - 对象销毁时调用</span>        <span class="token function">free</span><span class="token punctuation">(</span>m_data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>       size_t <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> m_size<span class="token punctuation">;</span>    <span class="token punctuation">}</span>       <span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>        m_size <span class="token operator">=</span> size<span class="token punctuation">;</span>        m_data <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">realloc</span><span class="token punctuation">(</span>m_data<span class="token punctuation">,</span> m_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>       <span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>size_t index<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 当 v[index] 时调用</span>        <span class="token keyword">return</span> m_data<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Vector <span class="token function">v</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    v<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    v<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    v<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        sum <span class="token operator">+</span><span class="token operator">=</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>       std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> sum <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>Vector类 并没有定义拷贝构造函数，编译器实际会发生拷贝构造，发生一次浅拷贝。如果我们使用拷贝操作，会发生什么问题吗？</p><p><img src="https://pic3.zhimg.com/80/v2-2af21508834624d5214285b0418c7192_720w.webp" alt></p><pre class="line-numbers language-text"><code class="language-text">41行     Vector v2 = v1; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在执行以上语句时，编译器默认是会发生一次浅拷贝，那么在退出main函数时候，v1.m_data 会被释放两次（析构v1 v2，就会发生两次对 v1.m_data的释放；更危险的是，如果v1被释放，而v2还在被使用，空指针出现）</p><p>– 这就是为什么，一个类定义了 <strong>解构函数，</strong> 还要定义或删除 <strong>拷贝构造函数</strong> 和 <strong>拷贝赋值函数</strong> 的原因。</p><ul><li>两种解决办法：</li></ul><p>① 直接禁止用户拷贝这个类的对象，让用户拷贝时，报错</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">Vector</span><span class="token punctuation">(</span>Vector <span class="token keyword">const</span> <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://pic4.zhimg.com/80/v2-91861b16bf3b362d7650bd32183da6f3_720w.webp" alt></p><p>② 我们自己实现一下拷贝构造函数，通过深拷贝，解决指针双重释放的问题。– 如果要用浅拷贝，那涉及到 <strong>智能指针</strong>。</p><p><img src="https://pic1.zhimg.com/80/v2-80ca3e62c5cc9a96612d9fa4cfe10764_720w.webp" alt></p><p>这样保证了 任何单次操作前后，对象都处于正确状态（存在或者删除），从而避免程序读到空悬指针。这就是保证了面向对象的 “封装：不变性”。</p><p>无论，size()/resize()这样的get/set模式，还是深拷贝，都是为了满足 “封装： 不变性” – 也就是ACID中的C（consistency）。一次对象的操作，要么完成，要么不完成，要保证 对象始终处于正确的状态。</p><h3 id="拷贝赋值函数"><a href="#拷贝赋值函数" class="headerlink" title="拷贝赋值函数"></a>拷贝赋值函数</h3><p>同理，如果使用了拷贝赋值，也需要定义拷贝赋值函数。</p><p><img src="https://pic1.zhimg.com/80/v2-37fdd4f26dbee98666227602895a5f58_720w.webp" alt></p><p>以上方式，先销毁，再通过 placement new，在原有this指针上构造。为了提高性能，推荐使用，realloc，从而就地利用现有m_data，避免重新分配。</p><p><img src="https://pic4.zhimg.com/80/v2-c03216e982a84dd1123035865f2aa763_720w.webp" alt></p><p>m_data显然，本来就有一段内存，那么通过 realloc 可以方便在原有的指针地址上扩展内存，避免了一次销毁在分配操作。</p><h3 id="移动构造函数-amp-移动赋值函数"><a href="#移动构造函数-amp-移动赋值函数" class="headerlink" title="移动构造函数 &amp; 移动赋值函数"></a>移动构造函数 &amp; 移动赋值函数</h3><p><img src="https://pic4.zhimg.com/80/v2-06d734b391ec5af5320b2ff777f842ff_720w.webp" alt></p><ul><li>std::move</li></ul><p>调用 std::move，V1 接管了V2的这块内存的所有权。</p><p>而拷贝赋值的 复杂度为 O(n)，因为分配了两块内存，v1 = v2 完成的是深拷贝。</p><p>以上两个操作，都不会产生二次free。</p><ul><li>std::swap</li></ul><p>另外还有 通过 std::swap 完成两块内存内容的交换。</p><p><img src="https://pic3.zhimg.com/80/v2-9c74e7f4751238aefa8f15f3973de46a_720w.webp" alt></p><ul><li>隐式发生 Move的情况</li></ul><p>① return v2 // C++规定，return 的对象不会再使用，自然等价于 std::move 语义。</p><ul><li>显式发生 拷贝的情况</li></ul><p>① return std::as_const(v2) // 显式拷贝</p><p>② v1 = v2 // 默认拷贝</p><p><img src="https://pic2.zhimg.com/80/v2-f0385bfdf4e88fdfb80b63f596a5a301_720w.webp" alt></p><p>自定义移动构造、移动赋值，可以提高执行效率。</p><p><img src="https://pic4.zhimg.com/80/v2-c3ff25be1b7a8b0cfb1107dd130b8727_720w.webp" alt></p><p>因为移动后，销毁了原对象，不存在两次free的情况，移动是浅移动。</p><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a><strong>unique_ptr</strong></h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a><strong>含义</strong></h3><p>对象释放，保证释放之前和之后，对象都处于正常状态。这样，不会出现 野指针(空悬指针)。</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> p <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在解构函数中，会自动调用 delete p 释放 p。对比 C++ 98 古老的释放对象的方法。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 之后要设null，不然可能会被再利用。</span>p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>而 unique_ptr 只需要 即可提前释放对象。– 体现了封装：一致性。</p><pre class="line-numbers language-cpp"><code class="language-cpp">p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 等价于 p.reset();</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="浅拷贝问题"><a href="#浅拷贝问题" class="headerlink" title="浅拷贝问题"></a>浅拷贝问题</h3><p>以下代码，unique_ptr 是删除了拷贝函数的，调用类的成员函数会报错。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> C <span class="token punctuation">{</span>    <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">do_sth</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 调用时，发生了浅拷贝</span>    p<span class="token operator">-</span><span class="token operator">></span><span class="token function">do_sth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> p <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">func</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//报错</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为 unique_ptr 删除了 拷贝构造函数，不能被拷贝。宁可编译器出错，不在运行时出错。按照三五法则，unique_ptr 自定义了解构函数，所以它必须删除拷贝构造函数。unique_ptr 采用的是上文提到的第一种方法，来避免 double free的情况。</p><ul><li>那么如何解决这个问题，解决方法</li></ul><p>可以这样修改，从 unique_ptr 获取 原始指针</p><ul><li><strong>case 1</strong></li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>C <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    p<span class="token operator">-</span><span class="token operator">></span><span class="token function">do_sth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> p <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 从p中 get出原始指针，并不是要夺取资源的占有权，只是调用p的成员函数，并没有接管对象生命周期。</span>    <span class="token function">func</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一种情况，我们只是对 p做了一些事情，并不是需要获取p 的控制权，此时只需要指针的 get() 出一个原始指针，并没有修改它什么时候释放这件事。还可以这样，把 p 指针 move到全局变量。（不推荐）</p><ul><li><strong>case 2</strong></li></ul><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>C<span class="token operator">>></span> objlist<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 把指针放到一个全局列表，那么 p的生命周期将变得和 objlist一样长。所以需要接管p的生命周期。</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    objlist<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 进一步移动到 objlist</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> p <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//  不为空</span>    <span class="token function">func</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过移动构造函数，转移指针控制器</span>    p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//  为空</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但移交了p 的控制权，就不能再访问 p 这个地址了。如果还想对 移交后的指针p，调用成员函数等操作，可以这样操作（不推荐，都这样做了还用什么unique_ptr）</p><ul><li><strong>case 3</strong></li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> p <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    C <span class="token operator">*</span>raw_p <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 先把原始指针拷贝一份</span>    <span class="token function">func</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 转移p 控制权给 objlist </span>    <span class="token comment" spellcheck="true">// 但需要注意，要保证 raw_p的存在时间不能超过 p的生命周期，否则 会出现危险的空悬指针。</span>    <span class="token comment" spellcheck="true">//objlist.clear();</span>    raw_p<span class="token operator">-</span><span class="token operator">></span><span class="token function">do_something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic2.zhimg.com/80/v2-b7c7fbfbb20e00f81ebb1ad056a41165_720w.webp" alt></p><p>raw_p 返回错误值。报错分析如下图，</p><p><img src="/posts/57427/1.jpg" alt></p><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a><strong>shared_ptr</strong></h2><h3 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h3><p>下面的例子说明了 shared_ptr 的使用特点，</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">struct</span> C <span class="token punctuation">{</span>     <span class="token keyword">int</span> m_number<span class="token punctuation">;</span>    <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"分配内存!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        m_number <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>       <span class="token operator">~</span><span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"释放内存!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        m_number <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2333333</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>       <span class="token keyword">void</span> <span class="token function">do_something</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"我的数字是 %d!\n"</span><span class="token punctuation">,</span> m_number<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>C<span class="token operator">>></span> objlist<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    objlist<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 这里用移动可以更高效，但不必须</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> p <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 引用计数初始化为1</span>    <span class="token function">func</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// shared_ptr 允许拷贝！和当前指针共享所有权，引用计数加1</span>    <span class="token function">func</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 多次也没问题~ 多个 shared_ptr 会共享所有权，引用计数加1</span>    p<span class="token operator">-</span><span class="token operator">></span><span class="token function">do_something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 正常执行，p 指向的地址本来就没有改变</span>    objlist<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 刚刚 p 移交给 func 的生命周期结束了！引用计数减2</span>    p<span class="token operator">-</span><span class="token operator">></span><span class="token function">do_something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 正常执行，因为引用计数还剩1，不会被释放</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 到这里最后一个引用 p 也被释放，p 指向的对象才终于释放</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>unique_ptr</strong> 解决了重复释放的方式是禁止拷贝，这样虽然效率高，但导致使用困难，容易出错；</p><p>相比之下，牺牲效率换来自由度的 <strong>shared_ptr</strong> 允许拷贝，他解决重复释放的方式是通过<strong>引用计数</strong>；</p><p>1、当初始化一个 shared_ptr时，计数初始化为 1</p><p>2、shared_ptr 被拷贝一次，计数加 1</p><p>3、shared_ptr 被解构一次，计数减 1， 减到 0 则自动销毁他指向的对象，比如 main函数 return</p><p>从而保证要还有引用存在，就不会解构对象。</p><ul><li>总结下 两种指针的特点，</li></ul><p>1&gt; unique_ptr 容易保证原子性，shared_ptr 需要硬件指令保证原子性，效率没有 unique_ptr 高；</p><p>2&gt; shared_ptr 方便，但还有循环引用问题，接着往下看。</p><h3 id="循环引用问题"><a href="#循环引用问题" class="headerlink" title="循环引用问题"></a>循环引用问题</h3><ul><li>一个 使用 shared_ptr 的 <strong>Bad Case</strong></li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token keyword">struct</span> C <span class="token punctuation">{</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> m_child<span class="token punctuation">;</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> m_parent<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> parent <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> child <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 建立相互引用</span>    parent<span class="token operator">-</span><span class="token operator">></span>m_child <span class="token operator">=</span> child<span class="token punctuation">;</span>    child<span class="token operator">-</span><span class="token operator">></span>m_parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>    parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// parent 不会被释放，child 还指向它</span>    child <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// child  不会被释放，parent 还指向它</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 完了，直到main函数退出，这两块内存都没有被释放。</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面实例的目的，通常 释放 parent时候，希望 child也同时被释放，但是因为产生了循环引用，导致内存泄漏。</p><p>总结一下：</p><p>动态指针 shared_ptr，可以适当减少使用者的出错概率，因为他的行为类似 GC语言的引用计数机制，但也有以下问题：</p><p>1、shared_ptr 需要维护一个 atomic 的引用计数器，效率会降低，需要额外维护一块管理内存，访问实际对象需要二级指针，而且 deleter 使用了<strong>类型擦除技术</strong>；</p><p>2、另外，全部使用 shared_ptr，可能会出现循环引用的问题，导致内存泄漏，那么要使用不影响计数的原始指针，或者 <strong>weak_ptr</strong> 来避免这个问题。</p><blockquote><p>c语言有特定方法解决循环引用，c++需要改造如下: 使用 weak_ptr</p></blockquote><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a><strong>weak_ptr</strong></h2><h3 id="讲解-weak-ptr-概念"><a href="#讲解-weak-ptr-概念" class="headerlink" title="讲解 weak_ptr 概念"></a>讲解 weak_ptr 概念</h3><ul><li>case 1</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>C<span class="token operator">>></span> objlist<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    objlist<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 进一步移动到 objlist</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> p <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 引用数初始化为 1</span>    p<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span>    std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> weak_p <span class="token operator">=</span> p<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 创建一个不影响计数器的弱引用</span>    p<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span>    <span class="token function">func</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 控制权转移，p 变为 null， 引用计数不变!</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>weak_p<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// here</span>        weak_p<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">do_sth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 正常执行，p 的生命周期仍然被 objlist 延续</span>    <span class="token punctuation">}</span>    objlist<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 刚刚 p移交给 objlist的生命周期结束，引用数-1 变0</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>weak_p<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 因为 shared_ptr 指向的对象，已经释放，弱引用会失败。</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// here</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        weak_p<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">do_sth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 不会执行到这.</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这里最后一个弱引用 weak_p 也被释放，他指向的管理块 被释放。</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="解决方案1"><a href="#解决方案1" class="headerlink" title="# 解决方案1"></a># 解决方案1</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token keyword">struct</span> C <span class="token punctuation">{</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> m_child<span class="token punctuation">;</span>    std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> m_parent<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> parent <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> child <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 建立相互引用</span>    parent<span class="token operator">-</span><span class="token operator">></span>m_child <span class="token operator">=</span> child<span class="token punctuation">;</span>    child<span class="token operator">-</span><span class="token operator">></span>m_parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>    parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    child <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不影响 shared_ptr 计数，弱引用 weak_ptr</p><p>有时候，我们希望维护一个 shared_ptr 的弱引用 weak_ptr, 即 弱引用的拷贝与 解构不影响其引用计数器。</p><p>之后，有需要时，可以再通过 lock() 随时产生一个新的 shared_ptr 作为强引用，但不lock的时候，不影响计数。</p><blockquote><p>lock(): creates a shared_ptr that manages the referenced object</p></blockquote><p>如果失效了(计数器归零), 则 expired() 会返回 true，并且 lock() 会返回nullptr</p><p><strong>可以把 C * 理解为 unique_ptr 的弱引用，weak_ptr 理解为 shared_ptr 的弱引用。但 weak_ptr 能提供 失效检测，更安全。</strong></p><p>shared_ptr 管理的对象生命周期，取决于所有引用中，最长寿的哪一个；</p><p>unique_ptr 管理的对象生命周期长度，取决于他所属的唯一一个引用的寿命。</p><h3 id="智能指针-做为类的成员变量"><a href="#智能指针-做为类的成员变量" class="headerlink" title="# 智能指针 做为类的成员变量"></a># 智能指针 做为类的成员变量</h3><p>可以在类中使用智能指针作为成员变量，需要根据所有权情况，判断使用哪一种智能指针</p><p>1、<strong>unique_ptr</strong>: 当该对象仅仅属于我时，比如 父对象中指向子对象的指针；</p><p>2、<strong>原始指针</strong>: 当该对象不属于我，但他释放前，我必然被释放。比如：子对象中指向父对象的指针；– unique_ptr 和 原始指针 一起使用。</p><p>3、<strong>shared_ptr</strong>: 当该对象由多个对象共享，或虽然该对象仅属于我，但有使用weak_ptr的需要</p><p>4、<strong>weak_ptr</strong>: 当该对象不属于我，且他释放后，我仍可能不被释放时。比如：指向窗口中上一次被点击的元素。</p><p>5、shared_ptr 和 weak_ptr 一起使用。即使 weak_ptr 指向的原指针已失效， expired可以判断出，而不会造成报错。这一点，强于原始指针对 unique_ptr 的弱引用。</p><p><strong>综上 ，初学者 更推荐 shared_ptr 和 weak_ptr的组合，而不是 unique_ptr 和 原始指针的组合。</strong></p><h3 id="解决方案2"><a href="#解决方案2" class="headerlink" title="# 解决方案2"></a># 解决方案2</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token keyword">struct</span> C <span class="token punctuation">{</span>     std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> m_child<span class="token punctuation">;</span>    C <span class="token operator">*</span>m_parent<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> parent <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> child <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 建立相互引用：</span>    parent<span class="token operator">-</span><span class="token operator">></span>m_child <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 移交 child 的所属权给 parent</span>    child<span class="token operator">-</span><span class="token operator">></span>m_parent <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// parent 会被释放。因为 child 指向他的是原始指针</span>    <span class="token comment" spellcheck="true">// 此时 child 也已经被释放了，因为 child 完全隶属于 parent</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>刚才提到的 unique_ptr 的应用场景，“当该对象仅仅属于我时”。既然都是用了原始指针（假设它释放前我必然被释放），因而我们完全可以把 m_child 变成一个标志着 “完全所有权”的 unique_ptr 。</p><p>这样 也不需要， shared_ptr 维护原子计数器的开销。</p><blockquote><p>C++ 中所有的拷贝都是深拷贝，除了 shared_ptr 和 weak_ptr 是浅拷贝，而 unique_ptr 禁止拷贝。</p></blockquote><h2 id="三五法则"><a href="#三五法则" class="headerlink" title="三五法则"></a>三五法则</h2><h3 id="安全和不安全的类型"><a href="#安全和不安全的类型" class="headerlink" title="安全和不安全的类型"></a>安全和不安全的类型</h3><p>① 以下类型是安全的：</p><ul><li>int id; // 基础类型</li><li>std::vector<int> arr; // STL容器 自动调用 vector的深拷贝</int></li><li>std::shared_ptr<Object> child; // 智能指针，它是浅拷贝，引用了计数，也不会出错。除非有循环引用需要 weak_ptr配合</Object></li><li>Object *parent; // 原始指针，前提是从 unique_ptr里 .get() 出来的弱引用，才是合理的</li></ul><p>② 以下对象时不安全的：</p><ul><li>char *ptr; // 原始指针，如果是通过 malloc/free 或者 new/delete 分配的， 需要自己去删除拷贝，或者定义拷贝。</li><li>GLint tex; // 是基础类型 int，但对应的某种资源。实际和 malloc/free函数一样是分配释放资源函数。</li><li>std::vector&lt;Object *&gt; obj; // STL容器，但存储了不安全的对象。 最好，通过深拷贝，或者禁止拷贝来避免 double free 的问题。</li></ul><h3 id="那么什么样的类定义是安全的呢"><a href="#那么什么样的类定义是安全的呢" class="headerlink" title="那么什么样的类定义是安全的呢"></a>那么什么样的类定义是安全的呢</h3><ul><li>如果你的类所有成员，都是安全类型。那么五大函数都不需要声明 (或声明为 = default)，你的类自动就是安全的；</li></ul><p>那么举一个安全的结构体定义</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Mesh <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// points</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>math<span class="token operator">::</span>vec3f<span class="token operator">></span> vert<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// corners</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>uint32_t<span class="token operator">></span> loop<span class="token punctuation">;</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>math<span class="token operator">::</span>vec2f<span class="token operator">></span> loop_uv<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// faces</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>uint32_t<span class="token operator">></span> poly<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>最好的判断方式，如果你不需自定义解构函数，便可不担心安全问题，<strong>因为通常自定义解构函数</strong>，意味着你的类成员里，包含不安全的类型。</li></ul><p>管理资源的类，先删除它的拷贝构造和拷贝赋值函数。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">Shader</span><span class="token punctuation">(</span>Shader <span class="token keyword">const</span> <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>Shader <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Shader <span class="token keyword">const</span> <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>既然，标准库已经提供了 shared_ptr，直接用 shared_ptr<Shader> 来管理。</Shader></p><h3 id="对于数据结构"><a href="#对于数据结构" class="headerlink" title="对于数据结构"></a>对于数据结构</h3><p>如果可以（它的构造函数使用 malloc()），自己定义拷贝和移动函数。</p><p><img src="https://pic4.zhimg.com/80/v2-5070fdad816a798edfcdda5afbaf2707_720w.webp" alt></p><h3 id="如何避免不必要的拷贝：常引用"><a href="#如何避免不必要的拷贝：常引用" class="headerlink" title="如何避免不必要的拷贝：常引用"></a>如何避免不必要的拷贝：常引用</h3><p>函数的参数声明为值类型，此时，实际调用了类的拷贝构造函数。产生了一次不必要的拷贝。那么替换成 const &amp;，常引用，从而传递了一个指针，避免了拷贝。</p><h3 id="函数参数类型优化规则：-按引用还是按值？"><a href="#函数参数类型优化规则：-按引用还是按值？" class="headerlink" title="函数参数类型优化规则： 按引用还是按值？"></a>函数参数类型优化规则： 按引用还是按值？</h3><pre class="line-numbers language-text"><code class="language-text">① 如果参数是基础类型（int、float） 则按值传递；       float  squareRoot(float val);② 如果是原始指针（int*、Object*）则按值传递；       void doSomethingWith(Object *ptr);③ 如果是 容器类型（vector、string）则按常引用传递；       int sumArray(std::vector<int> const &arr);④ 如果容器不大 （tuple<int, int>）按值传递；       glm::vec3 calculate(glm::vec3 pos);⑤ 如果智能指针（shared_ptr）且需要生命周期控制权，则按值传递；用户自己调用 std::move()       void addObject(std::shared_ptr<Object> obj);⑥ 如果是智能指针，但不需要生命周期，则通过 .get() 获取原始指针后，按值传递；       void modifyObject(Object *obj);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>只有数据容器、自定义的可拷贝的类，使用常引用的方法。</li></ul><h3 id="避免不必要的隐式拷贝"><a href="#避免不必要的隐式拷贝" class="headerlink" title="避免不必要的隐式拷贝"></a>避免不必要的隐式拷贝</h3><p>我们 可以将拷贝构造函数声明为 explicit (明确的)，这样隐式拷贝会出错，从而发现不必要的拷贝。</p><p><img src="https://pic2.zhimg.com/80/v2-20424e22ed1a52d441d087e172255fd5_720w.webp" alt></p><h2 id="语言管理资源"><a href="#语言管理资源" class="headerlink" title="语言管理资源"></a>语言管理资源</h2><p>为什么很多面向对象的语言，比如Java，都没有构造函数全家桶的概念呢？</p><ul><li>因为，他们的业务需求大都是面向资源的，比如操作数据库，发送http请求等等。</li><li>这些业务往往都是和“资源”在打交道，从而，基本上都是删除了拷贝函数的那一类，解决这类需求，几乎总是在用 shared_ptr<GLShader> 的模式，于是 Java和Python 干脆简化：一切非基础类型的对象都是 <strong>浅拷贝</strong>，使用引用计数，同时再通过 <strong>垃圾回收机制</strong> 自动管理。</GLShader></li></ul><p>因此，以<strong>系统级编程、算法数据结构、高性能计算</strong> 为主要业务的C++，才发展出了这些思想，并将 <strong>拷贝、移动、指针、可变性、多线程</strong> 等概念作为 <strong>语言基础元素</strong> 而存在。这些在我们的业务中非常重要，所以不可替代。</p><h2 id="扩展关键词"><a href="#扩展关键词" class="headerlink" title="扩展关键词"></a>扩展关键词</h2><p>1、P-IMPL 的模式</p><p>2、虚函数和纯虚函数</p><p>3、拷贝如何作为虚函数</p><p>4、std::unique_ptr::release()</p><p>5、std::enable_shared_from_this</p><p>6、dynamic_cast</p><p>7、std::dynamic_pointer_cast</p><p>8、运算符重载</p><p>9、右值引用 &amp;&amp;</p><p>10、std::shared_ptr<void> 和 std::any // 可以接受任何一个对象指针，和c的void *像，但可以管理生命周期，std::any 深拷贝版本的 shared_ptr<void></void></void></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概-述&quot;&gt;&lt;a href=&quot;#概-述&quot; class=&quot;headerlink&quot; title=&quot;概 述&quot;&gt;&lt;/a&gt;概 述&lt;/h2&gt;&lt;h3 id=&quot;RAII-Resource-Acquisition-Is-Initialization&quot;&gt;&lt;a href=&quot;#RAII-R
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Effective STL-STL使用经验</title>
    <link href="https://joytsing.github.io/posts/15264/"/>
    <id>https://joytsing.github.io/posts/15264/</id>
    <published>2023-12-12T02:41:15.000Z</published>
    <updated>2023-12-14T07:44:24.562Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>基于接口和实现分离的原则，了解STL的接口和STL的实现。</p><h2 id="第-1-条：慎重选择容器类型"><a href="#第-1-条：慎重选择容器类型" class="headerlink" title="第 1 条：慎重选择容器类型"></a><strong>第 1 条：慎重选择容器类型</strong></h2><ul><li>标准 STL 序列容器：vector、string、deque、list。</li><li>标准 STL 关联容器：set、multiset、map、multimap（注：unordered_set、unordered_map 在 C++11 的时候也被引入标准库）。</li><li>非标准序列容器：slist：是一个单向链表，rope 本质上是一个”重型“string。</li><li>非标准的关联容器：hash_set、hash_multiset、hash_map、hash_multimap。</li></ul><p>如何区分以上序列容器还是关联容器，《ESTL》提供了一种分类方法：基于连续内存容器和基于节点的容器分类。</p><p><strong>连续内存容器</strong> ：把它的元素存放在一块或多块（动态分配）内存中，每块内存中存有多个元素，当有新元素插入或已有的元素被删除时，统一内存块的元素需要向前或向后移动。以便给新元素让出空间，或者填充被删除元素所留下的空隙，这种移动影响效率和异常安全性。</p><p><strong>基于节点的容器</strong>：每一个（动态分配）的内存块中只存放一个元素。容器中元素的插入或删除只影响到指向节点的指针，而不影响节点本身的内容，所以当有插入或删除操作时候，元素的值不需要移动。</p><ul><li><strong>是否需要在容器的任意位置插入新元素？</strong> 如果需要，就选择序列容器否则选择关联容器。</li><li><strong>是否关心容器中元素是排序的？</strong> 如果不关心则哈希容器是一个可行选择方案；否则你要避免哈希容器。</li><li><strong>需要哪种类型的迭代器？</strong> 如果必须是随机访问迭代器，则对容器的选择就限定为vector、deque和string。如果要求使用双向迭代器，则避免使用slist和哈希容器。</li><li><strong>当发生元素的插入和删除操作时候，避免移动容器中原来的元素是否重要？</strong> 如果是就要避免选择序列容器。</li><li><strong>容器中数据布局是否需要和C保持兼容？</strong> 如果是是只能选择 vector。</li><li><strong>元素的查找速度是否是关键的考虑因素？</strong> 如果是考虑哈希容器。</li><li><strong>如果容器内部使用引用计数技术是否介意？</strong> 如果是则避免使用string因为许多string的实现都是用了引用计数。如果需要表示某种字符串的方法，可以使用vector方法。</li><li><strong>对插入和删除操作，需要事务语义么</strong> 在插入和操作失败的时需要回滚的能力么？如果需要就有使用基于节点的容器，如果需要对多个元素插入操作需要事务，则可以选择list。因为在标准容器中，只有list提供了多个元素的事务语义。但注意：事务语义对编写异常安全代码很重要但同时付出性能上代价。</li><li><strong>需要使用迭代器、指针和引用变为无效的次数最少么</strong> 如果是就需要使用基于节点的容器，因为这类对容器的插入和删除从来不会使用迭代器和指针和引用无效；而对连续内存的容器的插入和删除一般会对指向该容器的迭代器和指针、引用变为无效。</li><li><strong>如果在容器上使用swap使得迭代器失效了会在意吗</strong> 如果在意那么避免使用 string，因为 string 是唯一在STL中 swap 操作过程中导致迭代器、指针和引用无效唯一的容器。</li><li><strong>如果序列容器迭代器是随机访问，而且只要没有删除操作发生，且插入操作只发生容器末尾，则指向数据的指针和引用就不会变为无效，这样容器是否考虑</strong> 这是一种很特殊的情况，如果是则 deque 满足你的需求，deque 是唯一的迭代器可能会变为无效和指针和引用不会变为无效的 STL 标准容器。</li></ul><h2 id="第-2-条：不要试图编写独立于容器类型的代码"><a href="#第-2-条：不要试图编写独立于容器类型的代码" class="headerlink" title="第 2 条：不要试图编写独立于容器类型的代码"></a><strong>第 2 条：不要试图编写独立于容器类型的代码</strong></h2><p>STL 是以泛化原则为基础的：</p><ul><li>数组被泛化为”以其包含的对象的类型为参数“的容器；</li><li>函数被泛化为”以其使用的迭代器的类型为参数“的算法；</li><li>指针被泛化为”以其指向的对象的类型为参数“的迭代器；</li><li>容器被泛化为”序列式和关联式“容器。</li></ul><p>试图编写对序列式容器和关联式容器都适用的代码几乎是毫无意义的。面对实际情况，不同容器是不同的，它们有非常明显的优缺点，不同的适用场景适合选择不同的容器。</p><h2 id="第-3-条：确保容器中的对象拷贝正确而高效"><a href="#第-3-条：确保容器中的对象拷贝正确而高效" class="headerlink" title="第 3 条：确保容器中的对象拷贝正确而高效"></a><strong>第 3 条：确保容器中的对象拷贝正确而高效</strong></h2><p>当(通过如 insert 或 push_back 之类的操作)向容器中加入对象时，存入容器的是你所指定的对象的拷贝。</p><p>当(通过如front或back之类的操作)从容器中取出一个对象时，你所得到的是容器中所保存的对象的拷贝。</p><p><strong>进去的是拷贝，出来的也是拷贝(copy in, copy out)。这就是 STL 的工作方式。</strong></p><p>一旦一个对象被保存到容器中，它经常会进一步被拷贝。当对 vector、string 或 deque 进行元素的插入或删除操作时，现有元素的位置通常会被移动(拷贝)。如果你使用下列任何操作—-排序算法，next_permutation 或previous_permutation, remove、unique 或类似的操作，rotate 或 reverse,等等—-那么对象将会被移动(拷贝)。没错，拷贝对象是 STL 的工作方式。</p><p>在存在继承关系的基础下，拷贝动作会导致剥离，也就是说，如果你创建了一个存放基类对象的容器，却向其中插入派生类的对象，那么在派生类对象(通过基类的拷贝构造函数)被拷贝进容器时，它所特有的部分(即派生类中的信息)将会丢失。<strong>剥离问题</strong>意味着向基类对象的容器中插入派生类对象<strong>几乎总是错误的</strong>。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">SpecialWidget</span><span class="token operator">:</span> <span class="token keyword">public</span> Widget <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">test_item_3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>Widget<span class="token operator">></span> vw<span class="token punctuation">;</span>  SpecialWidget sw<span class="token punctuation">;</span>  vw<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>sw<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//sw作为基类对象被拷贝进vw，它的派生类特有的部分在拷贝的时候被丢弃了</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使拷贝动作高效、正确，并防止剥离问题发生的一个简单办法是使容器包含指针而不是对象。比如使用 <code>std::vector&lt;Widget*&gt; vw</code>; 而非上述操作。</p><h2 id="第-4-条：调用-empty-而不是检查-size-是否为-0"><a href="#第-4-条：调用-empty-而不是检查-size-是否为-0" class="headerlink" title="第 4 条：调用 empty 而不是检查 size() 是否为 0"></a><strong>第 4 条：调用 empty 而不是检查 size() 是否为 0</strong></h2><pre class="line-numbers language-text"><code class="language-text">//对任意 c 容器，下面的代码本质上等价的if (c.size() == 0) {}if (c.empty()) {}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>那既然如此，为何建议使用 empty 优先级于 size()，原因在于：empty 对所有的标准容器都是常数时间操作，而对一些 list 实现，size 函数耗费线性时间。（比如 list 容器的 splice 函数）。</p><h2 id="第-5-条：区间成员函数优先于与之对应的单元素成员函数"><a href="#第-5-条：区间成员函数优先于与之对应的单元素成员函数" class="headerlink" title="第 5 条：区间成员函数优先于与之对应的单元素成员函数"></a><strong>第 5 条：区间成员函数优先于与之对应的单元素成员函数</strong></h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget5</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">test_item_5</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>Widget5<span class="token operator">></span> v1<span class="token punctuation">,</span> v2<span class="token punctuation">;</span> v1<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>v2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> v2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> v2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 推荐</span> v1<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>Widget5<span class="token operator">></span><span class="token operator">::</span>const_iterator ci <span class="token operator">=</span> v2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> v2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> ci <span class="token operator">!=</span> v2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>ci<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 不推荐</span>   v1<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token operator">*</span>ci<span class="token punctuation">)</span><span class="token punctuation">;</span> v1<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> std<span class="token operator">::</span><span class="token function">copy</span><span class="token punctuation">(</span>v2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> v2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> v2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">back_inserter</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 效率不如assign</span> v1<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> v1<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> v2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> v2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 对copy的调用可以被替换为利用区间的insert版本</span> <span class="token keyword">const</span> <span class="token keyword">int</span> numValues <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token keyword">int</span> data<span class="token punctuation">[</span>numValues<span class="token punctuation">]</span><span class="token punctuation">;</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">;</span> v<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> data<span class="token punctuation">,</span> data <span class="token operator">+</span> numValues<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 推荐，使用区间成员函数insert</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator <span class="token function">insertLoc</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numValues<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>   insertLoc <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>insertLoc<span class="token punctuation">,</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不推荐，使用单元素成员函数</span>   <span class="token operator">++</span>insertLoc<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>区间成员函数是指这样的一类成员函数，它们像 STL 算法一样，使用两个迭代器参数来确定该成员操作所执行的区间。如果不使用区间成员函数就得写一个显示的循环。</p><p>优点在于：</p><ul><li>C++ 标准要求区间insert 函数把现有容器中元素直接移动到它们最终的位置上，即只需要付出每个元素移动一次的代价。</li><li>明智地使用区间插入而不是单元素重复插入会提高程序的性能问题，比如对于vector来说如果内存已满再插入新元素会触发两倍扩容，区间插入不必多次重新分配内存。</li><li>区间成员函数减少代码量，形成更易懂的代码，增强软件长期可维护性。</li></ul><p>那么，都有哪些区间成员函数？</p><ul><li>区间创建函数、insert、erase、assign等</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp">container<span class="token operator">::</span><span class="token function">container</span><span class="token punctuation">(</span>InputIterator begin<span class="token punctuation">,</span> InputIterator end<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//区间</span><span class="token keyword">void</span> container<span class="token operator">::</span><span class="token function">container</span><span class="token punctuation">(</span>iterator position<span class="token punctuation">,</span> InputIterator begin<span class="token punctuation">,</span> InputIterator end<span class="token punctuation">)</span><span class="token punctuation">;</span>iterator container<span class="token operator">::</span><span class="token function">erase</span><span class="token punctuation">(</span>iterator begin<span class="token punctuation">,</span> iterator end<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> container<span class="token operator">::</span><span class="token function">erase</span><span class="token punctuation">(</span>iterator begin<span class="token punctuation">,</span> iterator end<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> container<span class="token operator">::</span><span class="token function">assign</span><span class="token punctuation">(</span>iterator begin<span class="token punctuation">,</span> iterator end<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第-6-条：当心-C-编译器最烦人的分析机制"><a href="#第-6-条：当心-C-编译器最烦人的分析机制" class="headerlink" title="第 6 条：当心 C++ 编译器最烦人的分析机制"></a><strong>第 6 条：当心 C++ 编译器最烦人的分析机制</strong></h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 注意：围绕参数名的括号(比如对f2中d)与独立的括号的区别：围绕参数名的括号被忽略，而独立的括号则表明参数</span><span class="token comment" spellcheck="true">// 列表的存在：它们说明存在一个函数指针参数</span><span class="token keyword">int</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">double</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 声明了一个带double参数并返回int的函数</span><span class="token keyword">int</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 同上，d两边的括号被忽略,可以给参数名加上圆括号</span><span class="token keyword">int</span> <span class="token function">f3</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 同上，参数名被忽略</span><span class="token keyword">int</span> <span class="token function">g1</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 参数是一个指向不带任何参数的函数的指针，该函数返回double值；g1以指向函数的指针为参数</span><span class="token keyword">int</span> <span class="token function">g2</span><span class="token punctuation">(</span><span class="token keyword">double</span> <span class="token function">pf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 同上，pf为隐式指针</span><span class="token keyword">int</span> <span class="token function">g3</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 同上，省去参数名</span><span class="token keyword">int</span> <span class="token function">test_item_6</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 把一个存有整数(int)的文件ints.dat拷贝到一个list中</span> std<span class="token operator">::</span>ifstream <span class="token function">dataFile</span><span class="token punctuation">(</span><span class="token string">"ints.dat"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> std<span class="token operator">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">data1</span><span class="token punctuation">(</span>std<span class="token operator">::</span>istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>dataFile<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 小心，结果不会是你所想象的那样</span> std<span class="token operator">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">data2</span><span class="token punctuation">(</span><span class="token punctuation">(</span>std<span class="token operator">::</span>istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>dataFile<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正确，注意list构造函数的第一个参数两边的括号</span> std<span class="token operator">::</span>istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dataBegin</span><span class="token punctuation">(</span>dataFile<span class="token punctuation">)</span><span class="token punctuation">;</span> std<span class="token operator">::</span>istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> dataEnd<span class="token punctuation">;</span> std<span class="token operator">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">data3</span><span class="token punctuation">(</span>dataBegin<span class="token punctuation">,</span> dataEnd<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正确</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用命名的迭代器对象与通常的STL程序风格相违背，但你或许觉得为了使代码对所有编译器都没有二义性，并且使维护代码的人理解起来更容易，这一代价是值得的。</p><h2 id="第-7-条：如果容器中包含了通过-new-操作创建的指针，切记在容器对象析构前将指针-delete-掉"><a href="#第-7-条：如果容器中包含了通过-new-操作创建的指针，切记在容器对象析构前将指针-delete-掉" class="headerlink" title="第 7 条：如果容器中包含了通过 new 操作创建的指针，切记在容器对象析构前将指针 delete 掉"></a><strong>第 7 条：如果容器中包含了通过 new 操作创建的指针，切记在容器对象析构前将指针 delete 掉</strong></h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget7</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> DeleteObject <span class="token punctuation">{</span> <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span> <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>  <span class="token keyword">delete</span> ptr<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">test_item_7</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">const</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>Widget7<span class="token operator">*</span><span class="token operator">></span> vwp1<span class="token punctuation">,</span> vwp2<span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>  vwp1<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget7<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果在后面自己不delete，使用vwp在这里发生了Widget7的泄露</span>  vwp2<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget7<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>Widget7<span class="token operator">*</span><span class="token operator">></span><span class="token operator">::</span>iterator i <span class="token operator">=</span> vwp1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> vwp1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">delete</span> <span class="token operator">*</span>i<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 能行，但不是异常安全的</span> <span class="token punctuation">}</span> <span class="token function">for_each</span><span class="token punctuation">(</span>vwp2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vwp2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">DeleteObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正确，类型安全，但仍不是异常安全的</span> <span class="token keyword">typedef</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget7<span class="token operator">></span> SPW<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// SPW"指向Widget7的shared_ptr"</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>SPW<span class="token operator">></span> vwp3<span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>  vwp3<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">SPW</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget7<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 从Widget7创建SPW,然后对它进行一次push_back使用vwp3,这里不会有Widget7泄露，即使有异常被抛出</span> <span class="token punctuation">}</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>STL 容器很智能，但没有智能到知道是否该删除自己所包含的指针的程度。当你使用指针的容器，而其中的指针应该被删除时，为了避免资源泄漏，你必须或者用引用计数形式的智能指针对象(比如std::shared_ptr)代替指针，或者当容器被析构时手工删除其中的每个指针。</p><h2 id="第-8-条：切勿创建包含-auto-ptr-的容器对象"><a href="#第-8-条：切勿创建包含-auto-ptr-的容器对象" class="headerlink" title="第 8 条：切勿创建包含 auto_ptr 的容器对象"></a><strong>第 8 条：切勿创建包含 auto_ptr 的容器对象</strong></h2><p>auto_ptr 的容器(简称COAP) 是被禁止的。当你拷贝一个 auto_ptr 时，它所指向的对象的所有权被移交到拷入的 auto_ptr 上，而它自身被置为 NULL。如果你的目标是包含智能指针的容器，这并不意味着你要倒霉，包含智能指针的容器是没有问题的。但 auto_ptr 非智能指针。</p><h2 id="第-9-条：慎重选择删除元素的方法"><a href="#第-9-条：慎重选择删除元素的方法" class="headerlink" title="第 9 条：慎重选择删除元素的方法"></a><strong>第 9 条：慎重选择删除元素的方法</strong></h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">badValue</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 返回x是否为"坏值"</span><span class="token keyword">int</span> <span class="token function">test_item_9</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 删除c中所有值为1963的元素</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> c1<span class="token punctuation">;</span> c1<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">remove</span><span class="token punctuation">(</span>c1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1963</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当c1是vector, string或deque时，erase-remove习惯用法是删除特定值的元素的最好办法</span> std<span class="token operator">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> c2<span class="token punctuation">;</span> c2<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">1963</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当c2是list时，remove成员函数是删除特定值的元素的最好办法</span> std<span class="token operator">::</span>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> c3<span class="token punctuation">;</span> c3<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token number">1963</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当c3是标准关联容器时，erase成员函数是删除特定值元素的最好办法</span> <span class="token comment" spellcheck="true">// 删除判别式(predicate)返回true的每一个对象</span> c1<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">remove_if</span><span class="token punctuation">(</span>c1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> badValue<span class="token punctuation">)</span><span class="token punctuation">,</span> c1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当c1是vector, string或deque时，这是删除使badValue返回true的对象的最好办法</span> c2<span class="token punctuation">.</span><span class="token function">remove_if</span><span class="token punctuation">(</span>badValue<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当c2是list时，这是删除使badValue返回true的对象的最好办法</span> <span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator i <span class="token operator">=</span> c3<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> c3<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">badValue</span><span class="token punctuation">(</span><span class="token operator">*</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> c3<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 对坏值，把当前的i传给erase，递增i是副作用</span>  <span class="token keyword">else</span> <span class="token operator">++</span>i<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 对好值，则简单的递增i</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 每次元素被删除时，都向一个日志(log)文件中写一条信息</span> std<span class="token operator">::</span>ofstream logFile<span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator i <span class="token operator">=</span> c3<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> c3<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">badValue</span><span class="token punctuation">(</span><span class="token operator">*</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   logFile <span class="token operator">&lt;&lt;</span> <span class="token string">"Erasing "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>i <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 写日志文件</span>   c3<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 对坏值，把当前的i传给erase，递增i是副作用</span>  <span class="token punctuation">}</span>  <span class="token keyword">else</span> <span class="token operator">++</span>i<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 对好值，则简单第递增i</span> <span class="token punctuation">}</span> <span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator i <span class="token operator">=</span> c1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> c1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">badValue</span><span class="token punctuation">(</span><span class="token operator">*</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   logFile <span class="token operator">&lt;&lt;</span> <span class="token string">"Erasing "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>i <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>   i <span class="token operator">=</span> c1<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 把erase的返回值赋给i，使i的值保持有效</span>  <span class="token punctuation">}</span>  <span class="token keyword">else</span> <span class="token operator">++</span>i<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结一下：</p><ul><li>要删除容器中有特定值的所有对象：如果容器是 vector，string 或deque，则使用 erase-remove 习惯用法；如果容器是list，则使用 list::remove；如果容器是一个标准关联容器，则使用它的 erase 成员函数。</li><li>要删除容器中满足特定判别式(条件)的所有对象：如果容器是vector， string或deque，则使用erase-remove_if习惯用法；如果容器是list，则使用list::remove_if；如果容器是一个标准关联容器，则使用remove_copy_if和swap，或者写一个循环来遍历容器中的元素，记住当把迭代器传给erase时，要对它进行后缀递增。</li><li>要在循环内做某些(除了删除对象之外的)操作：如果容器是一个标准序列容器，则写一个循环来遍历容器中的元素，记住每次调用erase时，要用它的返回值更新迭代器；如果容器是一个标准关联容器，则写一个循环来遍历容器中的元素，记住当把迭代器传给erase时，要对迭代器做后缀递增。</li></ul><h2 id="第-10-条：了解分配子-allocator-的约定和限制"><a href="#第-10-条：了解分配子-allocator-的约定和限制" class="headerlink" title="第 10 条：了解分配子(allocator)的约定和限制"></a><strong>第 10 条：了解分配子(allocator)的约定和限制</strong></h2><p>编写自定义的分配子，需要注意：</p><ul><li>你的分配子是一个模板，模板参数T代表你为它分配内存的对象的类型。</li><li>提供类型定义 pointer 和 reference，但是始终让 pointer 为T指针，reference为T&amp;。</li><li>千万别让你的分配子拥有随对象而不同的状态(per-object state)。通常，分配子不应该有非静态的数据成员。*</li><li>记住，传给分配子的 allocate 成员函数的是那些要求内存的对象的个数，而不是所需的字节数。同时要记住，这些函数返回T*指针(通过pointer类型定义)，即使尚未有T对象被构造出来。</li><li>一定要提供嵌套的 rebind 模板，因为标准容器依赖该模板。</li></ul><h2 id="第-11-条：理解并自定义分配子的合理用法"><a href="#第-11-条：理解并自定义分配子的合理用法" class="headerlink" title="第 11 条：理解并自定义分配子的合理用法"></a><strong>第 11 条：理解并自定义分配子的合理用法</strong></h2><p>看一段代码</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">mallocShared</span><span class="token punctuation">(</span>size_t bytesNeed<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">malloc</span><span class="token punctuation">(</span>bytesNeed<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">freeShared</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">SharedMemoryAllocator</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> T<span class="token operator">*</span> pointer<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//pointer是个类型定义，它实际上总是T*</span>    <span class="token keyword">typedef</span> size_t size_type<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//通常情况下，size_type 是 size_t 的一个类型定义</span>    <span class="token keyword">typedef</span> T value_type<span class="token punctuation">;</span>    pointer <span class="token function">allocate</span><span class="token punctuation">(</span>size_type numObj<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> localHint <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>pointer<span class="token operator">></span><span class="token punctuation">(</span><span class="token function">mallocShared</span><span class="token punctuation">(</span>numObj <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">deallocate</span><span class="token punctuation">(</span>pointer ptrToMemory<span class="token punctuation">,</span> size_type numObj<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">freeShared</span><span class="token punctuation">(</span>ptrToMemory<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> U<span class="token operator">></span> <span class="token keyword">struct</span> rebind <span class="token punctuation">{</span>  <span class="token keyword">typedef</span> std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>U<span class="token operator">></span> other<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">test_item_11</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">typedef</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token punctuation">,</span> SharedMemoryAllocator<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">>></span> SharedDoubleVec<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// v所分配的用来容纳其元素的内存将来自共享内存</span> <span class="token comment" spellcheck="true">// 而v自己----包括它所有的数据成员----几乎肯定不会位于共享内存中，v只是普通的基于栈(stack)的对象，所以，像所有基于栈的对象一样，它将会被运行时系统放在任意可能的位置上。这个位置几乎肯定不是共享内存</span> SharedDoubleVec v<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 创建一个vector,其元素位于共享内存中</span> <span class="token comment" spellcheck="true">// 为了把v的内容和v自身都放到共享内存中，需要这样做</span> <span class="token keyword">void</span><span class="token operator">*</span> pVectorMemory <span class="token operator">=</span> <span class="token function">mallocShared</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>SharedDoubleVec<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 为SharedDoubleVec对象分配足够的内存</span> SharedDoubleVec<span class="token operator">*</span> pv <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>pVectorMemory<span class="token punctuation">)</span>SharedDoubleVec<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用"placement new"在内存中创建一个SharedDoubleVec对象</span> <span class="token comment" spellcheck="true">// ... // 使用对象(通过pv)</span> pv<span class="token operator">-</span><span class="token operator">></span><span class="token operator">~</span><span class="token function">SharedDoubleVec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 析构共享内存中的对象</span> <span class="token function">freeShared</span><span class="token punctuation">(</span>pVectorMemory<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 释放最初分配的那一块共享内存</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>遵守同一类型的分配子必须是等价的这一限制要求。</p><h2 id="第-12-条：切勿对-STL-容器的线程安全性有不切实际的依赖"><a href="#第-12-条：切勿对-STL-容器的线程安全性有不切实际的依赖" class="headerlink" title="第 12 条：切勿对 STL 容器的线程安全性有不切实际的依赖"></a><strong>第 12 条：切勿对 STL 容器的线程安全性有不切实际的依赖</strong></h2><p>对一个 STL 实现，你最多只能期望：</p><ul><li>多个线程读取是安全的。</li><li>多个线程对不同的容器做写入操作是安全的</li></ul><p>考虑当一个库视图实现完全的容器线程安全性时可能采取的方式：</p><ul><li>对容器成员函数的每次调用，都锁住容器直到调用结束</li><li>在容器所返回的每个迭代器的生存期结束前，都锁住容器</li><li>对作用于容器的每个算法，都锁住该该容器，直到容器结束</li></ul><p>当涉及到STL容器和线程安全性时，你可以指望一个STL库允许多个线程同时读一个容器，以及多个线程对不同的容器做写入操作。你不能指望STL库会把你从手工同步控制中解脱出来，而且你不能依赖于任何线程支持。</p><p>例如</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> g_v<span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        g_v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第-13-条：vector和string优先于动态分配的数组"><a href="#第-13-条：vector和string优先于动态分配的数组" class="headerlink" title="第 13 条：vector和string优先于动态分配的数组"></a><strong>第 13 条：vector和string优先于动态分配的数组</strong></h2><p>如果使用动态的分配数组，那么可能需要做更多的工作，为了减轻负担，使用 vector 和 string 。</p><h2 id="第-14-条：使用-reserve-来避免不必要的重新分配"><a href="#第-14-条：使用-reserve-来避免不必要的重新分配" class="headerlink" title="第 14 条：使用 reserve 来避免不必要的重新分配"></a><strong>第 14 条：使用 reserve 来避免不必要的重新分配</strong></h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">test_item_14</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">;</span> v<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果不使用reserve,下面的循环在进行过程中将导致2到10次重新分配;加上reserve，则在循环过程中,将不会再发生重新分配</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">1000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于 vector 和 string，增长过程是这样来实现的：每当需要更多空间时，就调用与 realloc类似的操作。这一类似于 realloc 的操作分为四部分：</p><ul><li>分配一块大小为当前容量的某个倍数的新内存。在大多数实现中，vector 和 string 的容量每次以 2 的倍数增长，即，每当容器需要扩张时，它们的容量即加倍。</li><li>把容器的所有元素从旧的内存拷贝到新的内存中。</li><li>析构掉就内存中的对象。</li><li>释放旧内存。</li></ul><p>reserve 函数能使你把重新分配的次数减少到最低程度，从而避免了重新分配和指针/迭代器/引用失效带来的开销。避免重新分配的关键在于，尽早地使用 reserve ，把容器的容量设为足够大的值，最好是在容器刚被构造出来之后就使用reserve。</p><p>通常有两种方式来使用reserve以避免不必要的重新分配。 第一种方式是，若能确切知道或大致预计容器中最终会有多少元素，则此时可以使用reserve。第二种方式是，先预留足够大的空间(根据你的需要而定)，然后，当把所有数据都加入以后，再去除多余的容量。</p><h2 id="第-15-条：注意-string-实现的多样性"><a href="#第-15-条：注意-string-实现的多样性" class="headerlink" title="第 15 条：注意 string 实现的多样性"></a><strong>第 15 条：注意 string 实现的多样性</strong></h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">test_item_15</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token string">"string size: %d, char* size: %d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>string 的值可能会被引用计数，也可能不会。很多实现在默认情况下会使用引用计数，但它们通常提供了关闭默认选择的方法，往往是通过预处理宏来做到这一点。</li><li>string 对象大小的范围可以是一个 char* 指针大小的 1 倍到 7 倍。</li><li>创建一个新的字符串值可能需要零次、一次或两次动态分配内存。</li><li>string 对象可能共享，也可能不共享其大小和容量信息。</li><li>string 可能支持，也可能不支持针对单个对象的分配子。</li><li>不同的实现对字符内存的最小分配单位有不同的策略。</li></ul><h2 id="第-16-条：了解如何把-vector-和-string-数据传给旧的-API"><a href="#第-16-条：了解如何把-vector-和-string-数据传给旧的-API" class="headerlink" title="第 16 条：了解如何把 vector 和 string 数据传给旧的 API"></a><strong>第 16 条：了解如何把 vector 和 string 数据传给旧的 API</strong></h2><p>C++ 标准要求 vector 中的元素存储在连续的内存中，就像数组一样。string 中的数据不一定存储在连续的内存中，而且 string 的内部表示不一定是以空字符结尾的。</p><h2 id="第-17-条：使用”swap技巧”除去多余的容量"><a href="#第-17-条：使用”swap技巧”除去多余的容量" class="headerlink" title="第 17 条：使用”swap技巧”除去多余的容量"></a><strong>第 17 条：使用”swap技巧”除去多余的容量</strong></h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Contestant</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">test_item_17</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 从contestants矢量中除去多余的容量</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>Contestant<span class="token operator">></span> contestants<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ... // 让contestants变大，然后删除它的大部分元素</span> <span class="token comment" spellcheck="true">// vector&lt;Contestant>(contestants)创建一个临时矢量，vector的拷贝构造函数只为所拷贝的元素分配所需要的内存</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>Contestant<span class="token operator">></span><span class="token punctuation">(</span>contestants<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>contestants<span class="token punctuation">)</span><span class="token punctuation">;</span> contestants<span class="token punctuation">.</span><span class="token function">shrink_to_fit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// C++11</span> std<span class="token operator">::</span>string s<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ... // 让s变大，然后删除它的大部分字符</span> std<span class="token operator">::</span><span class="token function">string</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> s<span class="token punctuation">.</span><span class="token function">shrink_to_fit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// C++11</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>Contestant<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>contestants<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 清除contestants并把它的容量变为最小</span> std<span class="token operator">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 清除s并把它的容量变为最小</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对 vector 或 string 进行 shrink-to-fit 操作时，考虑”swap”技巧。C++11 中增加了shrink_to_fit 成员函数。</p><p>swap 技巧的一种变化形式可以用来清除一个容器，并使其容量变为该实现下的最下值。</p><p>在做 swap 的时候，不仅两个容器的内容被交换，同时它们的迭代器、指针和引用也将被交换(string除外)。在 swap 发生后，原先指向某容器中元素的迭代器、指针和引用依然有效，并指向同样的元素—-但是，这些元素已经在另一个容器中了。</p><h2 id="第-18-条：-避免使用-vector-lt-bool-gt-类型"><a href="#第-18-条：-避免使用-vector-lt-bool-gt-类型" class="headerlink" title="第 18 条： 避免使用 vector &lt; bool&gt; 类型"></a><strong>第 18 条： 避免使用 vector &lt; bool&gt; 类型</strong></h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">test_item_18</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> v<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error: cannot convert 'std::vector&lt;bool>::reference* {aka std::_Bit_reference}' to 'bool*' in initialization</span> <span class="token comment" spellcheck="true">//bool* pb = &amp;v[0]; // 不能被编译，原因：vector&lt;bool>是一个假的容器，它并不真的储存bool，相反，为了节省空间，它储存的是bool的紧凑表示</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>作为一个 STL 容器，vector 只有两点不对。首先，它不是一个 STL 容器；其次，它并不存储bool。除此以外，一切正常。</p><p>在一个典型的实现中，储存在 ”vector” 中的每个 ”bool” 仅占一个二进制位，一个 8 位的字节可容纳 8 个 ”bool”。在内部，vector 使用了与位域 (bit field)一样的思想，来表示它所存储的那些bool，实际上它只是假装存储了这些 bool。</p><p>位域与 bool 相似，它只能表示两个可能的值，但是在 bool 和看似 bool 的位域之间有一个很重要的区别：你可以创建一个指向 bool 的指针，而指向单个位的指针则是不允许的。指向单个位的引用也是被禁止的。</p><p>当你需要 vector时，标准库提供了两种选择，可以满足绝大多数情况下的需求。</p><ul><li>第一种是 deque。deque 几乎提供了 vector 所提供的一切(没有reserve和capacity)，但deque 是一个 STL 容器，而且它确实存储 bool。当然 deque 中元素的内存不是连续的，所以你不能把 deque 中的数据传递给一个期望 bool 数组的 C API。</li><li>第二种可以替代 vector 的选择是 bitset。bitset 不是 STL 容器，但它是标准 C++ 库的一部分。与 STL 容器不同的是，它的大小(即元素的个数)在编译时就确定了，所以它不支持插入和删除元素。</li></ul><h2 id="第-19-条：理解相等-equality-和等价-equivalence-的区别"><a href="#第-19-条：理解相等-equality-和等价-equivalence-的区别" class="headerlink" title="第 19 条：理解相等(equality)和等价(equivalence)的区别"></a><strong>第 19 条：理解相等(equality)和等价(equivalence)的区别</strong></h2><p>相等的概念是基于 operator== 的。等价关系是以”在已排序的区间中对象值的相对顺序”为基础的。标准关联容器是基于等价而不是相等。</p><p>标准关联容器总是保持排列顺序的，所以每个容器必须有一个比较函数(默认为 less )来决定保持怎样的顺序。等价的定义正是通过该比较函数而确定的，因此，标准关联容器的使用者要为所使用的每个容器指定一个比较函数(用来决定如何排序)。</p><p>如果该关联容器使用相等来决定两个对象是否有相同的值，那么每个关联容器除了用于排序的比较函数外，还需要另一个比较函数来决定两个值是否相等。(默认情况下，该比较函数应该是 equal_to，但 equal_to 从来没有被用作 STL 的默认比较函数。当 STL 中需要相等判断时，一般的惯例是直接调用 operator ==)。</p><h2 id="第-20-条：为包含指针的关联容器指定比较类型"><a href="#第-20-条：为包含指针的关联容器指定比较类型" class="headerlink" title="第 20 条：为包含指针的关联容器指定比较类型"></a><strong>第 20 条：为包含指针的关联容器指定比较类型</strong></h2><p>每当你要创建包含指针的关联容器时，一定要记住，容器将会按照指针的值进行排序。绝大多数情况下，这不会是你所希望的，所以你几乎肯定要创建自己的函数子类作为该容器的比较类型(comparison type)。</p><p>如果你有一个包含智能指针或迭代器的容器，那么你也要考虑为它指定一个比较类型。对指针的解决方案同样也适用于那些类似指针的对象。就像DereferenceLess适合作为包含T*的关联容器的比较类型一样，对于容器中包含了指向T对象的迭代器或智能指针的情形，DereferenceLess也同样可用作比较类型。</p><h2 id="第-21-条：总是让比较函数在等值情况下返回-false"><a href="#第-21-条：总是让比较函数在等值情况下返回-false" class="headerlink" title="第 21 条：总是让比较函数在等值情况下返回 false"></a><strong>第 21 条：总是让比较函数在等值情况下返回 false</strong></h2><p>实际踩坑简化版</p><p>背景：现在我们有一个排序的结构体，假设数据经过召回、过滤等一系列操作后，得到最终的候选集，需要根据相应的策略，进行排序，最终返回 top k 结果</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> DataItem <span class="token punctuation">{</span>  std<span class="token operator">::</span>string data_id<span class="token punctuation">;</span>  <span class="token keyword">int</span> priority<span class="token punctuation">;</span>  <span class="token keyword">int</span> score<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先根据 priority 值判断，最终根据 score 值是否相等返回。</p><p>线上代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">DataSort</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>DataItem<span class="token operator">></span> <span class="token operator">&amp;</span>data_items<span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span><span class="token function">sort</span><span class="token punctuation">(</span>data_items<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> data_items<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> DataItem <span class="token operator">&amp;</span>item1<span class="token punctuation">,</span> <span class="token keyword">const</span> DataItem <span class="token operator">&amp;</span>item2<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>item1<span class="token punctuation">.</span>priority <span class="token operator">&lt;</span> item2<span class="token punctuation">.</span>priority<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>item1<span class="token punctuation">.</span>priority <span class="token operator">></span> item2<span class="token punctuation">.</span>priority<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> item1<span class="token punctuation">.</span>score <span class="token operator">>=</span> item2<span class="token punctuation">.</span>score<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试环境构造测试 case，符合预期，上线。但不久问题就出现了，上线不久后，程序直接 coredump，然后自动重启把 core 文件拉到本地调试或者编译成 debug 版，线上问题复现，原因就是因为 DataSort 导致，但是在 DataSort 中，就一个简单的排序，sort 不可能出现崩溃，唯一的原因，就是 lambda 函数实现有问题。重新修改 lambda 函数，把最后一句 return item1.score &gt;= item2.score 改成 return false 执行，运行正常</p><p>打开 Google，输入 std::sort coredump，看到了一句话</p><blockquote><p>❝ Having a non-circular relationship is called non-transitivity for the &lt; operator. It’s not too hard to realise that if your relationships are circular then you won’t be getting reasonable results. In fact there is a very strict set of rules that a data type and its comparators must abide by in order to get correct results from C++ STL algorithms, that is 「strict weak ordering」. ❞</p></blockquote><p>从上面的意思看，在 STL 中，对于 sort 函数中的排序算法，需要遵循严格弱序(strict weak ordering)的原则。</p><p>上面概念，总结下就是，存在两个变量x和y：</p><ul><li>x &gt; y 等同于 y &lt; x</li><li>x == y 等同于 !(x &lt; y) &amp;&amp; !(x &gt; y)</li></ul><p>对于 std::sort()，当容器里面元素的个数大于 <em>S</em>threshold 的枚举常量值时，会使用快速排序，在 STL 中这个值的默认值是16</p><p>调试跟踪定位发现 sort 的函数调用链最终会调用 __unguarded_partition， 我们看下 __unguarded_partition 函数的定义：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _RandomAccessIterator<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Compare<span class="token operator">></span>     _RandomAccessIterator     <span class="token function">__unguarded_partition</span><span class="token punctuation">(</span>_RandomAccessIterator __first<span class="token punctuation">,</span>               _RandomAccessIterator __last<span class="token punctuation">,</span>               _Tp __pivot<span class="token punctuation">,</span> _Compare __comp<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">__comp</span><span class="token punctuation">(</span><span class="token operator">*</span>__first<span class="token punctuation">,</span> __pivot<span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token operator">++</span>__first<span class="token punctuation">;</span>       <span class="token operator">--</span>__last<span class="token punctuation">;</span>       <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">__comp</span><span class="token punctuation">(</span>__pivot<span class="token punctuation">,</span> <span class="token operator">*</span>__last<span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token operator">--</span>__last<span class="token punctuation">;</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>__first <span class="token operator">&lt;</span> __last<span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token keyword">return</span> __first<span class="token punctuation">;</span>       std<span class="token operator">::</span><span class="token function">iter_swap</span><span class="token punctuation">(</span>__first<span class="token punctuation">,</span> __last<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token operator">++</span>__first<span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面代码中，有下面一段：</p><pre class="line-numbers language-text"><code class="language-text">while (__comp(*__first, __pivot))         ++__first;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中，<strong>first 为迭代器，</strong>pivot 为中间值，<strong>comp 为传入的比较函数。 如果传入的 vector 中，按照之前的写法 &gt;= 元素完全相等的情况下那么 __comp 比较函数一直是 true，那么后面 ++</strong>first，最终就会使得迭代器失效，从而导致 coredump。 至此，分析完毕，请记住，STL sort 自定义比较函数，总是对相同值的比较返回 false。</p><h2 id="第-22-条：切勿直接修改-set-或-multiset-中的键"><a href="#第-22-条：切勿直接修改-set-或-multiset-中的键" class="headerlink" title="第 22 条：切勿直接修改 set 或 multiset 中的键"></a><strong>第 22 条：切勿直接修改 set 或 multiset 中的键</strong></h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">test_item_22</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> std<span class="token operator">::</span>string<span class="token operator">></span> m<span class="token punctuation">{</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"xxx"</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//m.begin()->first = 10; // build error, map的键不能修改</span> std<span class="token operator">::</span>multimap<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> std<span class="token operator">::</span>string<span class="token operator">></span> mm<span class="token punctuation">{</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"yyy"</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//mm.begin()->first = 10; // build error, multimap的键同样不能修改</span> std<span class="token operator">::</span>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> s<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//*(s.begin()) = 10; // build error, set的键不能修改</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">*</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 强制类型转换</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token operator">*</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>像所有的标准关联容器一样，set 和 multiset 按照一定的顺序来存放自己的元素，而这些容器的正确行为也是建立在其元素保持有序的基础之上的。如果你把关联容器中的一个元素的值改变了(比如把10改为1000)，那么，新的值可能不在正确的位置上，这将会打破容器的有序性。</p><p>对于 map 和 multimap 尤其简单，因为如果有程序试图改变这些容器中的键，它将不能通过编译。这是因为，对于一个 map&lt;K, V&gt;或 multimap&lt;K, V&gt; 类型的对象，其中的元素类型是 pair&lt;const K, V&gt;。因为键的类型是 const K，所以它不能被修改。(如果利用 const_cast，你或许可以修改它。)</p><p>对于 set 或 multiset 类型的对象，容器中元素的类型是 T，而不是 const T。注：不通过强制类型转换并不能改变 set 或 multiset 中的元素。</p><h2 id="第-23-条：考虑用排序的vector替代关联容器"><a href="#第-23-条：考虑用排序的vector替代关联容器" class="headerlink" title="第 23 条：考虑用排序的vector替代关联容器"></a><strong>第 23 条：考虑用排序的vector替代关联容器</strong></h2><p>这个建议的前提是：</p><ul><li>创建一个新的数据结构，并插入大量元素，在这个阶段，几乎所有的操作都是插入和删除操作。很少或几乎没有查找操作。</li><li>查找阶段：查询该数据结构找到特点的信息，在这个阶段，几乎所有的操作都是查找很少或几乎没有删除。</li><li>重组阶段：改变数据结构的内容。</li></ul><p>这种方式使用其数据结构的应用程序来说，排序的 vector 可能比管理容器提供了更好的性能。</p><h2 id="第-24-条：当效率至关重要的时候，请在-map-operator-和-map-insert-之间作慎重选择"><a href="#第-24-条：当效率至关重要的时候，请在-map-operator-和-map-insert-之间作慎重选择" class="headerlink" title="第 24 条：当效率至关重要的时候，请在 map::operator[] 和 map::insert 之间作慎重选择"></a><strong>第 24 条：当效率至关重要的时候，请在 map::operator[] 和 map::insert 之间作慎重选择</strong></h2><h3 id="当做“添加”操作时，insert-效率比-operator-更高"><a href="#当做“添加”操作时，insert-效率比-operator-更高" class="headerlink" title="当做“添加”操作时，insert 效率比 operator[] 更高"></a><strong>当做“添加”操作时，insert 效率比 operator[] 更高</strong></h3><p>map::operator[] 工作原理：operator[] 返回一个引用，它指向与 k 相关联的值对象。然后 v 被赋给了该引用所指向的对象。如果键 k 已经有了相关联的值，则该值被更新。如果 k 还没有在映射表中，那就没有 operator[] 可以指向的值对象，这种情况下，它使用值类型的默认构造函数创建一个新的对象，然后 operator[] 就能返回一个指向该新对象的引用。</p><p>看一个样例：</p><pre class="line-numbers language-text"><code class="language-text">std::map<int, Widget> m;m[1] = 5.13<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>表达式 m[1] 是 m.operator 的缩写形式，所以这是对 map::operator[] 的调用。该函数必须返回一个指向 Widget 的引用，因为 m 所映射的值对象类型是 Widget。这时候 m 中什么也没有，所以键 1 没有多余的值对象。因此，operator[]默认构造了一个 Widget，作为 1 相关联的值，然后返回一个指向 Widget 的引用，最后，这个 Widget 赋值为 5.13</p><p>而如果直接用</p><pre class="line-numbers language-text"><code class="language-text">m.insert(Widget::value_type(1,5.13))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样直接用我们所需的值构造了一个 Widget 比 ”先默认构造一个 Widget在赋值“ 效率更高。</p><p>与之相比，通常节省了三个函数调用：一个用于创建默认构造的临时 Widget 对象，一个用以析构该临时对象，一个是调用 Widget 的赋值操作符。</p><h3 id="当做“更新”操作时，operator-效率比-insert-更高"><a href="#当做“更新”操作时，operator-效率比-insert-更高" class="headerlink" title="当做“更新”操作时，operator[] 效率比 insert 更高"></a><strong>当做“更新”操作时，operator[] 效率比 insert 更高</strong></h3><p>原因在于 insert 调用需要一个 Widget::value_type 类型的参数（pair&lt;int,Widget&gt;），所以当我们调用 insert 时候，必须构造和析构一个该类型的对象，这样付出一个 pair 构造函数和一个 pair 析构函数的代价。而这又会导致 Widget 的构造和析构，因为 pair&lt;int,Widget&gt; 本身包含了一个 Widget 对象，而 operator[] 不使用 pair 对象，所以它不会构造和析构任何 pair 和 Widget</p><h2 id="第-25-条：熟悉非标准的散列容器"><a href="#第-25-条：熟悉非标准的散列容器" class="headerlink" title="第 25 条：熟悉非标准的散列容器"></a><strong>第 25 条：熟悉非标准的散列容器</strong></h2><p>C++11 中新增了四种关联容器，使用哈希函数组织的，即 unordered_map、unordered_multimap、unordered_set、unordered_multiset。</p><ul><li>set：集合。底层为红黑树，元素有序，不重复；multiset：底层为红黑树，元素有序，可重复</li><li>map：底层为红黑树，键有序，不重复；multimap：底层为红黑树，键有序，可重复</li><li>unordered_set：底层为哈希表，无序，不重复；unordered_multiset：底层为哈希表，无序，可重复</li><li>unordered_map：底层为哈希表，无序，不重复；unordered_multiap：底层为哈希表，无序，可重复</li></ul><h2 id="第-26-条：iterator-优先于-const-iterator、reverse-iterator-以及-const-reverse-iterator"><a href="#第-26-条：iterator-优先于-const-iterator、reverse-iterator-以及-const-reverse-iterator" class="headerlink" title="第 26 条：iterator 优先于 const_iterator、reverse_iterator 以及 const_reverse_iterator"></a><strong>第 26 条：iterator 优先于 const_iterator、reverse_iterator 以及 const_reverse_iterator</strong></h2><p>STL 中的所有标准容器都提供了 4 种迭代器类型。</p><p>对容器类 container 而言，iterator 类型的功效相当于 T<em>，而 const_iterator 则相当于 const T</em>。对一个 iterator 或者 const_iterator 进行递增则可以移动到容器中的下一个元素，通过这种方式可以从容器的头部一直遍历到尾部。reverse_iterator 与 const_reverse_iterator 同样分别对应于 T<em>和const T</em>，所不同的是，对这两个迭代器进行递增的效果是由容器的尾部反向遍历到容器头部。</p><p>注意：vector::insert，对于 C++98 中，第一个参数均为 iterator；而对于 C++11中，第一个参数均为 const_iterator。vector::erase 的情况也是这样。</p><h2 id="第-27-条：-使用-distance-和-advance-将容器的-const-iterator-转换成-iterator"><a href="#第-27-条：-使用-distance-和-advance-将容器的-const-iterator-转换成-iterator" class="headerlink" title="第 27 条： 使用 distance 和 advance 将容器的 const_iterator 转换成 iterator"></a><strong>第 27 条： 使用 distance 和 advance 将容器的 const_iterator 转换成 iterator</strong></h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">test_item_27</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">typedef</span> std<span class="token operator">::</span>deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> IntDeque<span class="token punctuation">;</span> <span class="token keyword">typedef</span> IntDeque<span class="token operator">::</span>iterator Iter<span class="token punctuation">;</span> <span class="token keyword">typedef</span> IntDeque<span class="token operator">::</span>const_iterator ConstIter<span class="token punctuation">;</span> IntDeque <span class="token function">d</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ConstIter ci<span class="token punctuation">;</span> ci <span class="token operator">=</span> d<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使ci指向d</span> Iter <span class="token function">i</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> std<span class="token operator">::</span><span class="token function">advance</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> std<span class="token operator">::</span>distance<span class="token operator">&lt;</span>ConstIter<span class="token operator">></span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> ci<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>std::distance 用以取得两个迭代器(它们指向同一个容器)之间的距离；std::advance 则用于将一个迭代器移动指定的距离。</p><h2 id="第-28-条：正确理解由-reverse-iterator-的-base-成员函数所产生的-iterator-的用法"><a href="#第-28-条：正确理解由-reverse-iterator-的-base-成员函数所产生的-iterator-的用法" class="headerlink" title="第 28 条：正确理解由 reverse_iterator 的 base() 成员函数所产生的 iterator 的用法"></a><strong>第 28 条：正确理解由 reverse_iterator 的 base() 成员函数所产生的 iterator 的用法</strong></h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">test_item_28</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">;</span> v<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>reverse_iterator ri <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">rend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使ri指向3</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator <span class="token function">i</span><span class="token punctuation">(</span>ri<span class="token punctuation">.</span><span class="token function">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 4</span> v<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> v<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span> <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token string">"value: %d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1 2 3 99 4 5</span> v<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> v<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> ri <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">rend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> v<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">++</span>ri<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> v<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span> <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token string">"value: %d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1 2 4 5</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果要在一个reverse_iterator ri指定的位置上插入新元素，则只需在ri.base()位置处插入元素即可。对于插入操作而言，ri和ri.base()是等价的，ri.base()是真正与ri对应的iterator。 如果要在一个reverse_iterator ri指定的位置上删除一个元素，则需要在ri.base()前面的位置上执行删除操作。对于删除操作而言，ri和ri.base()是不等价的，ri.base()不是与ri对应的iterator。</p><h2 id="第-29-条：对于逐个字符的输入请考虑使用-istreambuf-iterator"><a href="#第-29-条：对于逐个字符的输入请考虑使用-istreambuf-iterator" class="headerlink" title="第 29 条：对于逐个字符的输入请考虑使用 istreambuf_iterator"></a><strong>第 29 条：对于逐个字符的输入请考虑使用 istreambuf_iterator</strong></h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">test_item_29</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 把一个文本文件的内容拷贝到一个string对象中</span> std<span class="token operator">::</span>ifstream <span class="token function">inputFile</span><span class="token punctuation">(</span><span class="token string">"interestingData.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> inputFile<span class="token punctuation">.</span><span class="token function">unsetf</span><span class="token punctuation">(</span>std<span class="token operator">::</span>ios<span class="token operator">::</span>skipws<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 禁止忽略inputFile中的空格</span> std<span class="token operator">::</span>string <span class="token function">fileData</span><span class="token punctuation">(</span><span class="token punctuation">(</span>std<span class="token operator">::</span>istream_iterator<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span><span class="token punctuation">(</span>inputFile<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>istream_iterator<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 速度慢</span> std<span class="token operator">::</span>string <span class="token function">fileData2</span><span class="token punctuation">(</span><span class="token punctuation">(</span>std<span class="token operator">::</span>istreambuf_iterator<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span><span class="token punctuation">(</span>inputFile<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>istreambuf_iterator<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 速度快</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>std::istream_iterator对象使用operator&gt;&gt;从输入流中读取单个字符，而std::istreambuf_iterator则直接从流的缓冲区中读取下一个字符。std::istreambuf_iterator不会跳过任何字符，它只是简单地取回流缓冲区中的下一个字符，而不管它们是什么字符，因此用不着清除输入流的skipws标志。</p><h2 id="第-30-条：确保目标区间足够大"><a href="#第-30-条：确保目标区间足够大" class="headerlink" title="第 30 条：确保目标区间足够大"></a><strong>第 30 条：确保目标区间足够大</strong></h2><p>需求1：希望像 transform 这样的算法把结果以新元素的形式插入到容器末尾开始。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">transmogrify</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">test_item_30</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> values<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> results<span class="token punctuation">;</span> results<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>results<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> values<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 可避免内存的重新分配</span> <span class="token comment" spellcheck="true">//std::transform(values.cbegin(), values.cend(), results.end(), transmogrify); // 错误，segmentation fault</span> std<span class="token operator">::</span><span class="token function">transform</span><span class="token punctuation">(</span>values<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> values<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">back_inserter</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span><span class="token punctuation">,</span> transmogrify<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正确 {2,4,6}</span> <span class="token comment" spellcheck="true">// 在内部，std::back_inserter返回的迭代器将使得push_back被调用，所以back_inserter可适用于所有提供了push_back方法的容器</span> std<span class="token operator">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> results2<span class="token punctuation">;</span> std<span class="token operator">::</span><span class="token function">transform</span><span class="token punctuation">(</span>values<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> values<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">front_inserter</span><span class="token punctuation">(</span>results2<span class="token punctuation">)</span><span class="token punctuation">,</span> transmogrify<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// std::front_inserter在内部利用了push_front，所以front_inserter仅适用于那些提供了push_front成员函数的容器</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需求2：假设希望 transform 这样的算法覆盖容器中已有的元素，那么就需要确保 result 已有的元素至少和 values 的元素一样多。否则，就必须使用 resize 来保证这一点</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> values<span class="token punctuation">;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> results<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//...</span><span class="token keyword">if</span> <span class="token punctuation">(</span>results<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> values<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> results<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>values<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//确保size一样大</span><span class="token punctuation">}</span>std<span class="token operator">::</span><span class="token function">transform</span><span class="token punctuation">(</span>values<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> values<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>results<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fun<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//覆盖 results 中前 values.size() 的元素</span>或者，也可以先清空 results 然后按照普通的方式使用一个插入行迭代器results<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>results<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>values<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span><span class="token function">transform</span><span class="token punctuation">(</span>values<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> values<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">back_inserter</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span><span class="token punctuation">,</span> fun<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//覆盖 results 中前 values.size() 的元素</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>无论何时，如果所使用的算法需要指定一个目标区间，那么必须确保目标区间足够大，或者确保它会随着算法的运行而增大。要在算法执行过程中增大目标区间，请使用插入型迭代器，比如ostream_iterator或者由back_inserter、front_inserter和inserter返回的迭代器。</p><h2 id="第-31-条：了解各种与排序有关的选择"><a href="#第-31-条：了解各种与排序有关的选择" class="headerlink" title="第 31 条：了解各种与排序有关的选择"></a><strong>第 31 条：了解各种与排序有关的选择</strong></h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">qualityCompare</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>lhs <span class="token operator">&lt;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">bool</span> <span class="token function">hasAcceptableQuality</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 判断w的质量值是否为2或者更好</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">test_item_31</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> <span class="token function">vec</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token string">"xxx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> std<span class="token operator">::</span><span class="token function">partial_sort</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">20</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> qualityCompare<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将质量最好的20个元素顺序放在vec的前20个位置上</span> std<span class="token operator">::</span><span class="token function">nth_element</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">19</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> qualityCompare<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将最好的20个元素放在vec的前部，但并不关心它们的具体排列顺序</span> <span class="token comment" spellcheck="true">// std::partia_sort和std::nth_element在效果上唯一不同之处在于：partial_sort对位置1--20中的元素进行了排序，而</span> <span class="token comment" spellcheck="true">// nth_element没有对它们进行排序。然而，这两个算法都将质量最好的20个vec放到了矢量的前部</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token operator">::</span>iterator <span class="token function">begin</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token operator">::</span>iterator <span class="token function">end</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token operator">::</span>iterator goalPosition<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用于定位感兴趣的元素</span> <span class="token comment" spellcheck="true">// 找到具有中间质量级别的string</span> goalPosition <span class="token operator">=</span> begin <span class="token operator">+</span> vec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果全排序的话，待查找的string应该位于中间</span> std<span class="token operator">::</span><span class="token function">nth_element</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> goalPosition<span class="token punctuation">,</span> end<span class="token punctuation">,</span> qualityCompare<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 找到vec的中间质量值</span> <span class="token comment" spellcheck="true">// 现在goalPosition所指的元素具有中间质量</span> <span class="token comment" spellcheck="true">// 找到区间中具有75%质量的元素</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token operator">::</span>size_type goalOffset <span class="token operator">=</span> <span class="token number">0.25</span> <span class="token operator">*</span> vec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 找出如果全排序的话，待查找的string离起始处有多远</span> std<span class="token operator">::</span><span class="token function">nth_element</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> begin <span class="token operator">+</span> goalOffset<span class="token punctuation">,</span> end<span class="token punctuation">,</span> qualityCompare<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 找到75%处的质量值 </span> <span class="token comment" spellcheck="true">// 将满足hasAcceptableQuality的所有元素移到前部，然后返回一个迭代器，指向第一个不满足条件的string</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token operator">::</span>iterator goodEnd <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">partition</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hasAcceptableQuality<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>std::nth_element：用于排序一个区间，它使得位置n上的元素正好是全排序情况下的第n个元素。而且，当nth_element返回的时候，所有按全排序规则(即sort的结果)排在位置n之前的元素也都被排在位置n之前，而所有按全排序规则排在位置n之后的元素则都被排在位置n之后。</li><li>std::partial_sort和std::nth_element在排列等价元素的时候，有它们自己的做法，你无法控制它们的行为。</li><li>std::partial_sort、std::nth_element和std::sort都属于非稳定的排序算法，但是有一个名为std::stable_sort的算法可以提供稳定排序特性。</li><li>std::nth_element除了可以用来找到排名在前的n个元素以外，它还可以用来找到一个区间的中间值，或者找到某个特定百分比上的值。</li><li>std::partition：可以把所有满足某个特定条件的元素放在区间的前部。</li></ul><p>总结排序选择：</p><ul><li>如果需要对 vector、string、deque 或者数组中的元素执行一次完全排序，那么可以使用sort或者stable_sort。</li><li>如果有一个 vector、string、deque 或者数组，并且只需要对等价性最前面的n个元素进行排序，那么可以使用partial_sort。</li><li>如果有一个 vector、string、deque 或者数组，并且需要找到第n个位置上的元素，或者，需要找到等价性前面的n个元素但又不必对这n个元素进行排序，那么，nth_element正是你所需要的函数。</li><li>如果需要将一个标准序列容器中的元素按照是否满足某个特定的条件区分开来，那么，partition 和 stable_partition 可能正是你所需要的。</li><li>如果你的数据在一个 list，那么你仍然可以直接调用 partition 和 stable_partition 算法；你可以用 list::sort 来替代 sort 和 stable_sort 算法。但是，如果你需要获得 partial_sort 或 nth_element 算法的效果，那么，你可以有一些间接的途径来完成这项任务。</li></ul><h2 id="第-32-条：如果确实需要删除元素，则需要在-remove-这一类算法之后调用-erase"><a href="#第-32-条：如果确实需要删除元素，则需要在-remove-这一类算法之后调用-erase" class="headerlink" title="第 32 条：如果确实需要删除元素，则需要在 remove 这一类算法之后调用 erase"></a><strong>第 32 条：如果确实需要删除元素，则需要在 remove 这一类算法之后调用 erase</strong></h2><p>记住一句话：remove 不是真正意义上的删除，因为它做不到。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">test_item_32</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">;</span> v<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token string">"v.size: %d\n"</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出10</span> v<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">99</span><span class="token punctuation">;</span> std<span class="token operator">::</span><span class="token function">remove</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 删除所有值等于99的元素</span> <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token string">"v.size: %d\n"</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 仍然输出10, remove不是真正意义上的删除，因为它做不到</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> v<span class="token punctuation">)</span> <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token string">"%d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> v<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">remove</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 真正删除所有值等于99的元素 </span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>remove 的原理：移动了区间中的元素，将 “不用被删除”的元素在v.begin()和newEnd之间，“需要被删除”的元素在newEnd和v.end()之间。它返回的迭代器是指向最后一个“不用被删除”的元素之后的元素。这个返回值相当于该区间“新的逻辑结尾”。</p><p>remove 的声明：</p><pre class="line-numbers language-text"><code class="language-text">template<class ForwardIterator, class T>ForwardIterator remove(ForwardIterator first, ForwardIterator last, const T& value);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>根本就不接受容器作为参数，所以并不知道这些元素被存放在哪个容器中，删除区间中的 1 元素。</p><p><img src="https://pic3.zhimg.com/80/v2-c9523e9292df36bab6d6e01792c381ce_720w.webp" alt></p><p>std::remove并不接受容器作为参数，所以remove并不知道这些元素被存放在哪个容器中。并且，remove也不可能推断出是什么容器，因为无法从迭代器推知对应的容器类型。因为从容器中删除元素的唯一方法是调用该容器的成员函数，而remove并不知道它操作的元素所在的容器，所以remove不可能从容器中删除元素。</p><p>std::list的remove成员函数是STL中唯一一个名为remove并且确实删除了容器中元素的函数。</p><p>std::remove并不是唯一一个适用于这种情形的算法，其它还有两个属于”remove类”的算法：remove_if和unique。如同list::remove会真正删除元素(并且比使用erase-remove习惯用法更为高效)一样，std::list::unique也会真正删除元素(而且比使用erase-unique更为高效)。</p><h2 id="第-33-条：对包含指针的容器使用-remove-这一类算法时要特别小心"><a href="#第-33-条：对包含指针的容器使用-remove-这一类算法时要特别小心" class="headerlink" title="第 33 条：对包含指针的容器使用 remove 这一类算法时要特别小心"></a><strong>第 33 条：对包含指针的容器使用 remove 这一类算法时要特别小心</strong></h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget33</span> <span class="token punctuation">{</span> <span class="token keyword">public</span><span class="token operator">:</span> <span class="token keyword">bool</span> <span class="token function">isRemove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果 pwidget 是一个未被验证的 Widget33 则删除该指针，并置位空</span><span class="token keyword">void</span> <span class="token function">delAndNullifyUnremove</span><span class="token punctuation">(</span>Widget33<span class="token operator">*</span><span class="token operator">&amp;</span> pWidget<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pWidget<span class="token operator">-</span><span class="token operator">></span><span class="token function">isRemove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">delete</span> pWidget<span class="token punctuation">;</span>  pWidget <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">test_item_33</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>Widget33<span class="token operator">*</span><span class="token operator">></span> v<span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget33<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 删除那些指向未被验证过的Widget33对象的指针，会资源泄露</span> v<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">remove_if</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">not1</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">mem_fun</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Widget33<span class="token operator">::</span>isCertified<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 一种可以消除资源泄露的做法</span> <span class="token comment" spellcheck="true">// 将所有指向未被验证的Widget33对象的指针删除并置成空</span> std<span class="token operator">::</span><span class="token function">for_each</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> delAndNullifyUnremove<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 删除v中的空指针，必须将0转换成一个指针，这样C++才能正确推断出remove的第三个参数类型</span> v<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">remove</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Widget33<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用智能指针可防止资源泄露</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget33<span class="token operator">>></span> v2<span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> v2<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>Widget33<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 下面语句需要编译器必须能够把智能指针类型std::shared&lt;Widget33>隐式转换为对应的内置指针类型Widget33*才能通过编译</span> <span class="token comment" spellcheck="true">//v2.erase(std::remove_if(v2.begin(), v2.end(), std::not1(std::mem_fun(&amp;Widget33::isCertified))), v2.end());</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当容器中存放的是指向动态分配的对象的指针的时候，应该避免使用remove和类似的算法(remove_if和unique)。 如果容器中存放的不是普通指针，而是具有引用计数功能的智能指针，那么就可以直接使用erase-remove的习惯用法。</p><h2 id="第-34-条：了解哪些算法要求使用排序的区间作为参数"><a href="#第-34-条：了解哪些算法要求使用排序的区间作为参数" class="headerlink" title="第 34 条：了解哪些算法要求使用排序的区间作为参数"></a><strong>第 34 条：了解哪些算法要求使用排序的区间作为参数</strong></h2><p>并非所有的算法都可以应用于任何区间。举例来说，remove算法要求单向迭代器并且要求可以通过这些迭代器向容器中的对象赋值。所以，它不能用于由输入迭代器指定的区间，也不适用于map或multimap，同样不适用于某些set和multiset的实现。同样地，很多排序算法要求随机访问迭代器，所以对于list的元素不可能调用这些算法。有些算法要求排序的区间，即区间中的值是排过序的。有些算法既可以与排序的区间一起工作，也可以与未排序的区间一起工作，但是当它们作用在排序的区间上时，算法会更加有效。</p><p>要求排序区间的STL算法：binaray_search、lower_bound、upper_bound、equal_range、set_union、set_intersection、set_difference、set_symmetric_difference、merge、inplace_merge、includes。</p><p>unique、unique_copy并不一定要求排序的区间，但通常情况下会与排序区间一起使用。</p><h2 id="第-35-条：通过-mismatch-或-lexicographical-compare-实现简单的忽略大小写的字符串比较"><a href="#第-35-条：通过-mismatch-或-lexicographical-compare-实现简单的忽略大小写的字符串比较" class="headerlink" title="第 35 条：通过 mismatch 或 lexicographical_compare 实现简单的忽略大小写的字符串比较"></a><strong>第 35 条：通过 mismatch 或 lexicographical_compare 实现简单的忽略大小写的字符串比较</strong></h2><p>std::lexicographical_compare是strcmp的一个泛化版本。不过，strcmp只能与字符数组一起工作，而lexicographical_compare则可以与任何类型的值的区间一起工作。而且，strcmp总是通过比较两个字符来判断它们的关系相等、小于还是大于，而lexicographical_compare则可以接受一个判别式，由该判别式来决定两个值是否满足一个用户自定义的准则。</p><p>strcmp通常是被优化过的，它们在字符串的处理上一般要比通用算法mismatch和lexicographical_compare快。</p><h2 id="第-36-条-理解copy-if算法的正确实现"><a href="#第-36-条-理解copy-if算法的正确实现" class="headerlink" title="第 36 条: 理解copy_if算法的正确实现"></a><strong>第 36 条: 理解copy_if算法的正确实现</strong></h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">test_item_36</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v1<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token function">v2</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">auto</span> it <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">copy_if</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> v2<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">distance</span><span class="token punctuation">(</span>v2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> it<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> v <span class="token operator">:</span> v2<span class="token punctuation">)</span>  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token string">"%d\n"</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1 3 5</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++11 中增加了 std::copy_if 函数。拷贝带条件判断的算法。</p><h2 id="第-37-条-使用accumulate或者for-each进行区间统计"><a href="#第-37-条-使用accumulate或者for-each进行区间统计" class="headerlink" title="第 37 条: 使用accumulate或者for_each进行区间统计"></a><strong>第 37 条: 使用accumulate或者for_each进行区间统计</strong></h2><p>std::accumulate有两种形式：第一种形式有两个迭代器和一个初始值，它返回该初始值加上由迭代器标识的区间中的值的总和。</p><p>std::accumulate只要求输入迭代器，所以你可以使用std::istream_iterator和std::istreambuf_iterator。</p><p>std::accumulate的第二种形式带一个初始值和一个任意的统计函数。</p><p>std::for_each是另一个可被用来统计区间的算法，而且它不受accumulate的那些限制。如同accumulate一样，for_each也带两个参数：一个是区间，另一个是函数(通常是函数对象)—-对区间中的每个元素都要调用这个函数，但是，传给for_each的这个函数只接收一个实参(即当前的区间元素)。for_each执行完毕后会返回它的函数。(实际上，它返回的是这个函数的一份拷贝。)重要的是，传给for_each的函数(以及后来返回的函数)可以有副作用。</p><p>std::for_each和std::accumulate在两个方面有所不同：首先，名字accumulate暗示着这个算法将会计算出一个区间的统计信息。而for_each听起来就好像是对一个区间的每个元素做一个操作。用for_each来统计一个区间是合法的，但是不如accumulate来得清晰。其次，accumulate直接返回我们所要的统计结果，而for_each却返回一个函数对象，我们必须从这个函数对象中提取出我们所要的统计信息。在C++中，这意味着我们必须在函数子类中 加入一个成员函数，以便获得我们想要的统计信息。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 接受当前的长度总和值和新的字符串，然后返回更新之后的总和值</span>std<span class="token operator">::</span>string<span class="token operator">::</span>size_type <span class="token function">stringLengthSum</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string<span class="token operator">::</span>size_type sumSoFar<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> sumSoFar <span class="token operator">+</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">struct</span> Point <span class="token punctuation">{</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">double</span> initX<span class="token punctuation">,</span> <span class="token keyword">double</span> initY<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>initX<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>initY<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">double</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">PointAverage</span> <span class="token operator">:</span> <span class="token keyword">public</span> std<span class="token operator">::</span>unary_function<span class="token operator">&lt;</span>Point<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span> <span class="token function">PointAverage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">xSum</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">ySum</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">numPoints</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> Point<span class="token operator">&amp;</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token operator">++</span>numPoints<span class="token punctuation">;</span>  xSum <span class="token operator">+</span><span class="token operator">=</span> p<span class="token punctuation">.</span>x<span class="token punctuation">;</span>  ySum <span class="token operator">+</span><span class="token operator">=</span> p<span class="token punctuation">.</span>y<span class="token punctuation">;</span> <span class="token punctuation">}</span> Point <span class="token function">result</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">Point</span><span class="token punctuation">(</span>xSum <span class="token operator">/</span> numPoints<span class="token punctuation">,</span> ySum <span class="token operator">/</span> numPoints<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span> size_t numPoints<span class="token punctuation">;</span> <span class="token keyword">double</span> xSum<span class="token punctuation">,</span> ySum<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">test_item_37</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> v<span class="token punctuation">{</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">2.2f</span><span class="token punctuation">,</span> <span class="token number">3.3f</span><span class="token punctuation">,</span> <span class="token number">4.5f</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">double</span> sum <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">accumulate</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 注意：初始值被指定为0.0,而不是简单的0</span> <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token string">"vaule: %f\n"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 11.000000</span> <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token string">"sum of the ints: %d\n"</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">accumulate</span><span class="token punctuation">(</span>std<span class="token operator">::</span>istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>std<span class="token operator">::</span>cin<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输入非整数值结束,如字母</span> std<span class="token operator">::</span>set<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> ss<span class="token punctuation">{</span> <span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"cde"</span><span class="token punctuation">,</span> <span class="token string">"xyzw"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 计算一个容器中字符串的长度总和</span> std<span class="token operator">::</span>string<span class="token operator">::</span>size_type lengthSum <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">accumulate</span><span class="token punctuation">(</span>ss<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ss<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">::</span>size_type<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> stringLengthSum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token string">"length sum: %d\n"</span><span class="token punctuation">,</span> lengthSum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 10</span> <span class="token comment" spellcheck="true">// 计算一个区间中数值的乘积</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> vf<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">.</span>f<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">.</span>f<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">.</span>f<span class="token punctuation">,</span> <span class="token number">1.5f</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">float</span> product <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">accumulate</span><span class="token punctuation">(</span>vf<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vf<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">.</span>f<span class="token punctuation">,</span> std<span class="token operator">::</span>multiplies<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token string">"product: %f\n"</span><span class="token punctuation">,</span> product<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 9.000000</span> <span class="token comment" spellcheck="true">// 计算出一个区间中所有点的平均值</span> std<span class="token operator">::</span>list<span class="token operator">&lt;</span>Point<span class="token operator">></span> lp<span class="token punctuation">{</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> Point avg <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">for_each</span><span class="token punctuation">(</span>lp<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lp<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PointAverage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第-38-条-遵循按值传递的原则来设计函数子类"><a href="#第-38-条-遵循按值传递的原则来设计函数子类" class="headerlink" title="第 38 条: 遵循按值传递的原则来设计函数子类"></a><strong>第 38 条: 遵循按值传递的原则来设计函数子类</strong></h2><p>无论是C还是C++，都不允许将一个函数作为参数传递给另一个函数，相反，你必须传递函数指针。C和C++的标准库函数都遵循这一规则：函数指针是按值传递的。</p><h2 id="第-39-条-确保判别式是”纯函数”"><a href="#第-39-条-确保判别式是”纯函数”" class="headerlink" title="第 39 条: 确保判别式是”纯函数”"></a><strong>第 39 条: 确保判别式是”纯函数”</strong></h2><p>一个判别式(predicate)是一个返回值为bool类型(或者可以隐式地转换为bool类型)的函数。在STL中，判别式有着广泛的用途。标准关联容器的比较函数就是判别式；对于像find_if以及各种与排序有关的算法，判别式往往也被作为参数来传递。</p><h2 id="第-40-条-若一个类是函数子，则应使它可配接"><a href="#第-40-条-若一个类是函数子，则应使它可配接" class="headerlink" title="第 40 条: 若一个类是函数子，则应使它可配接"></a><strong>第 40 条: 若一个类是函数子，则应使它可配接</strong></h2><h2 id="第-41-条-理解ptr-fun、men-fun和mem-fun-ref的来由"><a href="#第-41-条-理解ptr-fun、men-fun和mem-fun-ref的来由" class="headerlink" title="第 41 条: 理解ptr_fun、men_fun和mem_fun_ref的来由"></a><strong>第 41 条: 理解ptr_fun、men_fun和mem_fun_ref的来由</strong></h2><p>std::ptr_fun：将函数指针转换为函数对象。</p><p>std::mem_fun：将成员函数转换为函数对象(指针版本)。</p><p>std::mem_fun_ref：将成员函数转换为函数对象(引用版本)。</p><h2 id="第-42-条-确保less与operator-lt-具有相同的语义"><a href="#第-42-条-确保less与operator-lt-具有相同的语义" class="headerlink" title="第 42 条: 确保less与operator&lt;具有相同的语义"></a><strong>第 42 条: 确保less与operator&lt;具有相同的语义</strong></h2><p>应该尽量避免修改less的行为，因为这样做很可能会误导其他的程序员。如果你使用了less，无论是显式地或是隐式地，你都需要确保它与operator&lt;具有相同的意义。如果你希望以一种特殊的方式来排序对象，那么最好创建一个特殊的函数子类，它的名字不能是less。</p><h2 id="第-43-条-算法调用优先于手写的循环"><a href="#第-43-条-算法调用优先于手写的循环" class="headerlink" title="第 43 条: 算法调用优先于手写的循环"></a><strong>第 43 条: 算法调用优先于手写的循环</strong></h2><p>理由：</p><ul><li>效率：算法通常比程序员自己写的循环效率更高。</li><li>正确性：自己写循环比使用算法更容易出错。</li><li>可维护性：使用算法的代码通常比手写循环的代码更加简洁明了。</li></ul><p>如果你要做的工作与一个算法所实现的功能很相近，那么用算法调用更好。但是如果你的循环很简单，而若使用算法来实现的话，却要求混合使用绑定器和配接器或者要求一个单独的函数子类，那么，可能使用手写的循环更好。最后，如果你在循环中要做的工作很多，而且又很复杂，则最好使用算法调用。</p><h2 id="第-44-条-容器的成员函数优先于同名的算法"><a href="#第-44-条-容器的成员函数优先于同名的算法" class="headerlink" title="第 44 条: 容器的成员函数优先于同名的算法"></a><strong>第 44 条: 容器的成员函数优先于同名的算法</strong></h2><p>有些STL容器提供了一些与算法同名的成员函数。比如，关联容器提供了count、find、lower_bound、upper_bound和equal_range，而list则提供了remove、remove_if、unique、sort、merge和reverse。大多数情况下，你应该使用这些成员函数，而不是相应的STL算法。这里有两个理由：第一，成员函数往往速度快；第二，成员函数通常与容器(特别是关联容器)结合得更加紧密，这是算法所不能比的。原因在于，算法和成员函数虽然有同样的名称，但是它们所做的事情往往不完全相同。</p><h2 id="第-45-条-正确区分count、find、binary-search、lower-bound、upper-bound和equal-range"><a href="#第-45-条-正确区分count、find、binary-search、lower-bound、upper-bound和equal-range" class="headerlink" title="第 45 条: 正确区分count、find、binary_search、lower_bound、upper_bound和equal_range"></a><strong>第 45 条: 正确区分count、find、binary_search、lower_bound、upper_bound和equal_range</strong></h2><p>如果区间是排序的，那么通过binary_search、lower_bound、upper_bound和equal_range，你可以获得更快的查找速度(通常是对数时间的效率)。 如果迭代器并没有指定一个排序的区间，那么你的选择范围将局限于count、count_if、find以及find_if，而这些算法仅能提供线性时间的效率。</p><h2 id="第-46-条-考虑使用函数对象而不是函数作为STL算法的参数"><a href="#第-46-条-考虑使用函数对象而不是函数作为STL算法的参数" class="headerlink" title="第 46 条: 考虑使用函数对象而不是函数作为STL算法的参数"></a><strong>第 46 条: 考虑使用函数对象而不是函数作为STL算法的参数</strong></h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> StringSize <span class="token operator">:</span> <span class="token keyword">public</span> std<span class="token operator">::</span>unary_function<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> std<span class="token operator">::</span>string<span class="token operator">::</span>size_type<span class="token operator">></span> <span class="token punctuation">{</span> std<span class="token operator">::</span>string<span class="token operator">::</span>size_type <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">test_item_46</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>set<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> s<span class="token punctuation">{</span> <span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"cde"</span><span class="token punctuation">,</span> <span class="token string">"xyzw"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> std<span class="token operator">::</span><span class="token function">transform</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>ostream_iterator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">::</span>size_type<span class="token operator">></span><span class="token punctuation">(</span>std<span class="token operator">::</span>cout<span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">mem_fun_ref</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>std<span class="token operator">::</span>string<span class="token operator">::</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3 3 4，普通函数</span> std<span class="token operator">::</span><span class="token function">transform</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>ostream_iterator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">::</span>size_type<span class="token operator">></span><span class="token punctuation">(</span>std<span class="token operator">::</span>cout<span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">StringSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3 3 4, 函数对象</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在C/C++中并不能真正地将一个函数作为参数传递给另一个函数。如果我们试图将一个函数作为参数进行传递，则编译器会隐式地将它转换成一个指向该函数的指针，并将该指针传递过去。函数指针参数抑制了内联机制。</p><h2 id="第-47-条-避免产生”直写型”-write-only-的代码"><a href="#第-47-条-避免产生”直写型”-write-only-的代码" class="headerlink" title="第 47 条: 避免产生”直写型”(write-only)的代码"></a><strong>第 47 条: 避免产生”直写型”(write-only)的代码</strong></h2><p>当你编写代码的时候，它看似非常直接和简捷，因为它是由某些基本想法(比如，erase-remove习惯用法加上在find中使用reverse_interator的概念)自然而形成的。然而，阅读代码的人却很难将最终的语句还原成它所依据的思路，这就是”直写型的代码”叫法的来历：虽然很容易编写，但是难以阅读和理解。一段代码是否是”直写型”取决于其读者的知识水平。</p><h2 id="第-48-条-总是包含-include-正确的头文件"><a href="#第-48-条-总是包含-include-正确的头文件" class="headerlink" title="第 48 条: 总是包含(#include)正确的头文件"></a><strong>第 48 条: 总是包含(#include)正确的头文件</strong></h2><p>C++标准与C的标准有所不同，它没有规定标准库中的头文件之间的相互包含关系。</p><p>总结每个与STL有关的标准头文件中所包含的内容：</p><p>(1). 几乎所有的标准STL容器都被声明在与之同名的头文件中，比如vector被声明在<vector>中，list被声明在<list>中，等等。但是set和map是个例外，<set>中声明了set和multiset，<map>中声明了map和multimap。</map></set></list></vector></p><p>(2). 除了4个STL算法以外，其它所有的算法都被声明在<algorithm>中，这4个算法是accumulate、inner_product、adjacent_difference和partial_sum，它们被声明在<numeric>头文件中。</numeric></algorithm></p><p>(3). 特殊类型的迭代器，包括istream_iterator和istreambuf_iterator，被声明在<iterator>中。</iterator></p><p>(4). 标准的函数子(比如less)和函数子配接器(比如not1、bind2nd)被声明在头文件<functional>中。</functional></p><p>任何时候如果你使用了某个头文件中的一个STL组件，那么你就一定要提供对应的#include指令，即使你正在使用的STL平台允许你省略#include指令，你也要将它们包含到你的代码中。当你需要将代码移植到其它平台上的时候，移植的压力就会减轻。</p><h2 id="第-49-条-学会分析与STL相关的编译器诊断信息"><a href="#第-49-条-学会分析与STL相关的编译器诊断信息" class="headerlink" title="第 49 条: 学会分析与STL相关的编译器诊断信息"></a><strong>第 49 条: 学会分析与STL相关的编译器诊断信息</strong></h2><p>一些技巧：</p><ul><li>vector和string的迭代器通常就是指针，所以当错误地使用了iterator的时候，编译器的诊断信息中可能会引用到指针类型。例如，如果源代码中引用了vector::iterator，那么编译器的诊断信息中极有可能就会提及double*指针。</li><li>如果诊断信息中提到了back_insert_iterator、front_insert_iterator或者insert_iterator，则几乎总是意味着你错误地调用了back_inserter、front_inserter或者inserter。如果你并没有直接调用这些函数，则一定是你所调用的某个函数直接或者间接地调用了这些函数。</li><li>类似地，如果诊断信息中提到了binder1st或者binder2nd，那么你可能是错误地使用了bind1st和bind2nd。</li><li>输出迭代器(如ostream_iterator、ostreambuf_iterator以及那些由back_inserter、front_inserter、front_inserter和inserter函数返回的迭代器)在赋值操作符内部完成其输出或者插入工作，所以，如果在使用这些迭代器的时候犯了错误，那么你所看到的错误消息中可能会提到与赋值操作符有关的内容。</li><li>如果你得到的错误消息来源于某一个STL算法的内部实现(例如，引起错误的源代码在中)，那也许是你在调用算法的时候使用了错误的类型。例如，你可能使用了不恰当的迭代器类型。</li><li>如果你正在使用一个很常见的STL组件，比如vector、string或者for_each算法，但是从错误消息来看，编译器好像对此一无所知，那么可能是你没有包含相应的头文件。</li></ul><h2 id="第-50-条-熟悉与-STL-相关的-Web-站点"><a href="#第-50-条-熟悉与-STL-相关的-Web-站点" class="headerlink" title="第 50 条: 熟悉与 STL 相关的 Web 站点"></a><strong>第 50 条: 熟悉与 STL 相关的 Web 站点</strong></h2><p><a href="https://link.zhihu.com/?target=http%3A//www.cplusplus.com/">http://www.cplusplus.com/</a> 尤其是其中的 Reference(<a href="https://link.zhihu.com/?target=http%3A//www.cplusplus.com/reference/">http://www.cplusplus.com/reference/</a>)</p><p>如果 有时 cplusplus 网站打不开，此时也可参考cppreference：<a href="https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp">https://en.cppreference.com/w/c</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;基于接口和实现分离的原则，了解STL的接口和STL的实现。&lt;/p&gt;
&lt;h2 id=&quot;第-1-条：慎重选择容器类型&quot;&gt;&lt;a href=&quot;#第-
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Cpp Core Guidelines</title>
    <link href="https://joytsing.github.io/posts/8961/"/>
    <id>https://joytsing.github.io/posts/8961/</id>
    <published>2023-12-05T07:39:23.000Z</published>
    <updated>2023-12-14T07:43:53.644Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章实际上是<a href="https://zhuanlan.zhihu.com/p/662592729">C++ Core Guidelines</a>解析的转载加上一些自己的理解(相当于自己集合一些觉得精华的内容放在自己blog上),废话少说。开始挖坑！</p><p>C++ Core Guidelines 由 16 个主要部分组成：</p><ul><li>简介</li><li>理念</li><li>接口</li><li>函数</li><li>类和类的层次结构</li><li>枚举</li><li>资源管理</li><li>表达式和语句</li><li>性能</li><li>并发性</li><li>错误处理</li><li>常量和不变性</li><li>模板和泛型编程</li><li>C 风格编程</li><li>源文件</li></ul><h2 id="理念"><a href="#理念" class="headerlink" title="理念"></a>理念</h2><p>理念性规则概览：理念性规则强调一般性，因此，无法进行检查。不过，理念性规则为下面的具体规则提供了理论依据。一共有 13 条理念性规则。可以简单理解为一般情况下的编码规范。</p><h3 id="P-1-在代码中直接表达思想"><a href="#P-1-在代码中直接表达思想" class="headerlink" title="P.1 在代码中直接表达思想"></a>P.1 在代码中直接表达思想</h3><p>编译器是不会去读注释（或设计文档）的，许多程序员也（固执地）不去读它们。 而代码中所表达的东西是带有 明确的语义 的，并且（原则上）是可以由编译器和其他工具进行检验的。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Date</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    Month <span class="token function">month</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 好</span>    <span class="token keyword">int</span> <span class="token function">month</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 不好</span>    <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一个 <code>month</code> 比第二个，有更多的信息，以 <code>const</code> 修饰，代表不会修改当前的日期，返回类型 <code>Month</code> 也非常明确。</p><blockquote><p>成员函数修饰 <code>const</code> 是为什么，能做什么。只是默认，不修改当前类的数据成员就要加 <code>const</code>，明确语义，增加可读性。 <strong>但不够正确，也远不止如此</strong>。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">class</span> <span class="token class-name">Date</span> <span class="token punctuation">{</span>    <span class="token keyword">using</span> Month <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    Month m<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">month</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> m<span class="token punctuation">;</span> <span class="token punctuation">}</span>          <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date<span class="token operator">&amp;</span> date<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> date<span class="token punctuation">.</span><span class="token function">month</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Date d<span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">func</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码会得到一个编译错误，这应该是很常见的调用方式。为什么呢？显然，就是因为 <code>month</code> 成员函数没有以 <code>const</code> 修饰。<strong><code>C++</code> 不允许 const 的对象调用没有以 const 修饰的成员函数</strong>，事实上这个语义非常的合理：我都是 const 对象了，你为啥要修改？但是明明 <code>month</code> 函数根本没有修改对象的数据，所以这其实是开发者的问题，不应该写出这种代码。当前的语境很简单，我们只需要改成：</p><p>但是明明 <code>month</code> 函数根本没有修改对象的数据，所以这其实是开发者的问题，不应该写出这种代码。</p><p>当前的语境很简单，我们只需要改成：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Month <span class="token function">month</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> m<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// const 对象和非 const 对象都能调用</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果你阅读过 <code>STL</code> 源码，或者看过基本的<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/container/array">文档</a>，会知道，<strong>大部分成员函数都要提供 <code>const</code> 和非 <code>const</code> 两种版本，我们以 <code>std::array</code> 的 <code>operator[]</code> 为例</strong>。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> reference <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span> size_type pos <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">constexpr</span> const_reference <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span> size_type pos <span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两个成员函数都不会修改自己存储的对象，但是为什么要写 <code>const</code> 版本呢？<strong>注意返回类型</strong>。</p><ul><li>如果没有以 const 修饰的 std::array 对象，那么它调用 <code>operator[]</code> 自然是可以修改的，行为就像普通数组那样，我们就返回 <code>reference</code>。</li><li>如果是以 const 修饰的 std::array 对象，那么它调用 <code>operator[]</code> 根据我们的语义，自然不该让它外部能够修改，所以我们返回 <code>const_reference</code>。</li></ul><p><strong>一个成员函数是否以 const 修饰，不在于这个成员函数到底是否会修改自己的成员，而在于 “可变性”。</strong></p><p>相对于 标准库（STL）的算法，使用 for 或 while 等方式的手工循环通常也有上面一样的可读性问题。比如下面这样：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                          <span class="token comment" spellcheck="true">//不好</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>        index <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">auto</span> it <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//更好</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个专业的 C++ 开发者应该了解 <strong>STL 算法</strong>。使用它们的话，你就可以避免显式使用循环，你的代码也会变得更容易理解，更容易维护，因此，也更不容易出错。现代 C++ 中有一句谚语：</p><ul><li><em>如果你显式使用循环的话，说明你不了解 STL 算法。</em></li></ul><blockquote><p>其实就是说成员函数注意返回类型的名字，和 const 修饰，增加可读性。 多使用 STL 算法，而不是自己搓，既能增加可读性也能减少错误。</p></blockquote><h3 id="P-2-用-ISO-标准写代码"><a href="#P-2-用-ISO-标准写代码" class="headerlink" title="P.2 用 ISO 标准写代码"></a>P.2 用 ISO 标准写代码</h3><p>要想得到一个可移植的 C++ 程序，最好的选择就是按照标准写代码。</p><p>使用当前的 C++ 标准，不要使用编译器扩展，同时注意，<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/ub">未定义行为和实现定义行为</a>。</p><p><strong>当你必须使用没有写在 ISO 标准里的扩展时，可以用一个稳定的接口将它们封装起来</strong>。</p><blockquote><p>比如将使用的编译器扩展用宏封装起来，以后如果要修改，或者说要适应别的平台，都很方便。举一个古代<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/jGfGz941G">例子</a>：</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">if</span> __cplusplus >= 201103L</span><span class="token macro property">#<span class="token directive keyword">define</span> INLINE inline</span><span class="token macro property">#<span class="token directive keyword">else</span></span><span class="token macro property">#<span class="token directive keyword">define</span> INLINE __attribute__((__always_inline__))</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="P-3-表达意图"><a href="#P-3-表达意图" class="headerlink" title="P.3 表达意图"></a>P.3 表达意图</h3><p>以下的隐式和显式循环中，你能看出什么意图？</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> v<span class="token operator">:</span> vec<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>                              <span class="token comment" spellcheck="true">// (1)</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> v<span class="token operator">:</span> vec<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>                                    <span class="token comment" spellcheck="true">// (2)</span>std<span class="token operator">::</span><span class="token function">for_each</span><span class="token punctuation">(</span>std<span class="token operator">::</span>execution<span class="token operator">::</span>par<span class="token punctuation">,</span> vec<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// (3) 很抽象，这种形式其实根本做不到，当伪代码就好</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>循环（1）不修改容器 vec 的元素。（2）有可能修改。算法 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/algorithm/for_each">std::for_each</a>（3）以并行方式（<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/algorithm/execution_policy_tag_t">std::execution::par</a>）执行。这意味着我们不关心处理的顺序。<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/hxfdnT6W8">举个例子</a>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>vec<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">for_each</span><span class="token punctuation">(</span>std<span class="token operator">::</span>execution<span class="token operator">::</span>par<span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//打印的顺序是随机的</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">for_each</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//12345</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>表达意图也是良好代码文档的一个重要准测。</p><ul><li><em>文档应该说明代码会做什么，而不是代码会怎么做</em>。</li></ul><blockquote><p>其实这里是在指，文档应该讲功能，而非实现细节。 不过事实上技术文档一般都不会完全这样，多少会提一些实现细节的，具体情况具体分析。</p></blockquote><h3 id="P-4-理想情况下，程序应该是静态类型安全的"><a href="#P-4-理想情况下，程序应该是静态类型安全的" class="headerlink" title="P.4 理想情况下，程序应该是静态类型安全的"></a>P.4 理想情况下，程序应该是静态类型安全的</h3><p>C++ 是一种静态类型的语言。静态类型意味着编译器知道数据的类型，此外，还说明，编译器可以检测到类型错误。 由于现有的问题领域，我们并非一直能够达到这一目标，但对于联合体、转型(cast)、数组退化、范围错误或窄化转换，确实是有办法的。</p><ul><li>在 C++17 中，可以使用 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/utility/variant">std::variant</a> 安全地替代<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/union">联合体</a>。</li><li>基于模板的泛型代码减少了转型的需要，因此，也减少了类型错误。<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/YrfcvsTGY">如</a>。</li><li>当用一个 C 数组调用一个函数时，就会发生<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/implicit_conversion">数组退化</a>。函数需要用指向数组第一个元素的指针，另加数组的长度。这意味着，你从一个类型丰富的数据结构 C 数组开始，却以类型极差的数组首项指针结束。<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/KPPcP5j89">解决方法</a>在 C++20 里：<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/container/span">std::span</a>。std::span 可以自动推算出 C 数组的大小，也可以防止范围错误的发生。如果你还没有使用 C++20，请使用 Guidelines 支持库（GSL）提供的实现。</li><li><a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/list_initialization">窄化转换</a>是对算术值的有精度损失的隐式转换。</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">i1</span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> i2 <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果你使用 {} 初始化语法，编译器就能<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/j6GTbGvvn">检测到窄化转换</a>。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> i1<span class="token punctuation">{</span><span class="token number">3.14</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> i2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">3.14</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="P-5-编译期检查优先于运行期检查"><a href="#P-5-编译期检查优先于运行期检查" class="headerlink" title="P.5 编译期检查优先于运行期检查"></a>P.5 编译期检查优先于运行期检查</h3><ul><li><em>如果可以在编译期检查，那就应该在编译期检查</em>。</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// Int 被用作整数的别名</span><span class="token keyword">int</span> bits <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 请勿如此: 可以避免的代码</span><span class="token keyword">for</span> <span class="token punctuation">(</span>Int i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token punctuation">;</span> i <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token operator">++</span>bits<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>bits <span class="token operator">&lt;</span> <span class="token number">32</span><span class="token punctuation">)</span>    cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"Int too small\n"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个例子并没有达成其所要达成的目的（因为溢出是未定义行为），应当被替换为简单的 static_assert：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// Int 被用作整数类型的别名</span><span class="token keyword">static_assert</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Int<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// do: 编译时检查</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>或者更好的方式是直接利用类型系统，将 int 替换 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/types/integer">int32_t</a>。</p><blockquote><p>如果当前环境有 int32_t 这个别名，那么代表，你的环境支持 32位整数类型。</p></blockquote><p>或用来检测<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/meta%23.E7.B1.BB.E5.9E.8B.E7.89.B9.E6.80.A7">类型特征</a>（type traits），比如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">static_assert</span><span class="token punctuation">(</span>std<span class="token operator">::</span>is_integral_v<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="P-6-不能在编译期检查的事项应该在运行期检查"><a href="#P-6-不能在编译期检查的事项应该在运行期检查" class="headerlink" title="P.6 不能在编译期检查的事项应该在运行期检查"></a>P.6 不能在编译期检查的事项应该在运行期检查</h3><p>因为有 <code>dynamic_cast</code> ，可以安全的将类的指针和引用沿着继承层次结构进行向上，向下以及测向的转换。如果转型失败，</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span> 新类型 <span class="token operator">></span><span class="token punctuation">(</span> 表达式 <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果转型失败且 新类型 是指针类型，那么它会返回该类型的空指针。</p><p>如果转型失败且 新类型 是引用类型，那么它会抛出与类型 <code>std::bad_cast</code> 的处理块匹配的异常。</p><p>第五章中 “dynamic_cast” 一节中会有更多的细节。</p><h3 id="P-7-尽早识别运行期错误"><a href="#P-7-尽早识别运行期错误" class="headerlink" title="P.7 尽早识别运行期错误"></a>P.7 尽早识别运行期错误</h3><p>可以采取很多对策来摆脱运行期错误。管理好指针和 C 数组，检查他们的范围。对于转换，同样需要检测：</p><ul><li><em>如有可能，应尽量避免转换，对于窄化转换，尤其如此。检查输入也属于这个范畴</em>。</li></ul><h3 id="P-8-不要泄露任何资源"><a href="#P-8-不要泄露任何资源" class="headerlink" title="P.8 不要泄露任何资源"></a>P.8 不要泄露任何资源</h3><p>资源可以是内存、文件句柄、套接字，等等。处理资源的惯用法是 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/raii">RAII</a> 。RAII 是资源获取即初始化（Resource Acquisition Is Initialization）。 是一种 C++ 编程技术，它将必须在使用前请求的资源（分配的堆内存、执行线程、打开的套接字、打开的文件、锁定的互斥体、磁盘空间、数据库连接等——任何存在受限供给中的事物）的生命周期与一个对象的生存期相绑定。 即：构造函数中获取资源，析构函数中释放资源。</p><p>C++ 大量使用 RAII：锁负责处理互斥量，智能指针负责处理原始内存，STL 的容器负责处理底层元素，等等。</p><blockquote><p>这里居然用中文的 “锁” 这个字来指代那些通用锁管理类（<code>std::lock_guard</code>），原书这里用这个字描述是有问题的，请不要模仿。</p></blockquote><h3 id="P-9-不要浪费时间和空间"><a href="#P-9-不要浪费时间和空间" class="headerlink" title="P.9 不要浪费时间和空间"></a>P.9 不要浪费时间和空间</h3><p>节省时间和空间都是一种美德。我们用的是 C++。你发现下面循环中的问题了吗？</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">lower</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string s<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> std<span class="token operator">::</span><span class="token function">strlen</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>        s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">tolower</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>虽然是个错误示例，但这代码写的太过愚蠢了，函数形参不用引用直接拷贝是其一，s 明明是个 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/string/basic_string">std::string</a> 对象，不去调用 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/string/basic_string/size">size()</a> 成员函数，跑去用 C 标准库的玩意？</p></blockquote><p>使用 STL 中的算法 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/algorithm/transform">std::transform</a> ，就可以把前面的函数变成一行。</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span><span class="token function">transform</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">tolower</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>与函数 lower 相比，算法 std::transform 自动确定了字符串的大小。因此，你不需要使用 std::strlen 指定字符串的长度。</p><p>下面是另一个经常出现在生产代码中的典型例子。为一个用户定义的数据类型声明拷贝语义。（拷贝构造函数和拷贝赋值运算符）。最终，编译器永远用不了廉价的移动语义。（即使实际上移动是适用的），而只能一直依赖代价高昂的拷贝语义。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> S<span class="token punctuation">{</span>    std<span class="token operator">::</span>string s_<span class="token punctuation">;</span>    <span class="token function">S</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string s<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">s_</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token function">S</span><span class="token punctuation">(</span><span class="token keyword">const</span> S<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">s_</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>s_<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    S<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> S<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span> s_ <span class="token operator">=</span> rhs<span class="token punctuation">.</span>s_<span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp"><code class="language-cpp">S s1<span class="token punctuation">;</span>S s2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//进行拷贝，而不能从 s1.s_ 移动。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>这里没有任何问题，但是我们详细的描述一下，因为我觉得很多人不清楚移动语义能带来什么。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//不修改 S 类</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    S s1<span class="token punctuation">{</span> <span class="token string">"aaaaaaaaaaaaaaaa"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span>s_<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    S s2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span>s_<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/5Kr51KeMo">打印</a>的地址不一样，这代表实际上是复制了 <code>std::string</code> 管理的数据的。</p><p>但是，如果我们修改 S 类，比如直接把复制构造和复制赋值运算符给删了，会怎么样？</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token keyword">struct</span> S<span class="token punctuation">{</span>    std<span class="token operator">::</span>string s_<span class="token punctuation">;</span>    <span class="token function">S</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string s<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">s_</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    S s1<span class="token punctuation">{</span><span class="token string">"aaaaaaaaaaaaaaaa"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span>s_<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    S s2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span>s_<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/4rGxq1h5Y">打印</a>的地址完全一致。</p><p>这代表了 std::string 对象管理的数据并没有真的进行复制。</p><p>我们讲一下为什么：没有了复制构造函数和复制赋值运算符后，移动构造不会再被抑制了，编译器可以<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/move_constructor">隐式定义移动构造函数</a>。</p><p>这个隐式定义的移动构造函数，你大约可以理解为，我们的 <code>S s2 = std::move(s1)</code> 这里调用了 S 的移动构造函数，那么，它的数据成员，同时，也会被 移动，如果是类类型，且有移动构造函数的话，会被调用，相当于，<code>std::string</code> 被调用了移动构造，然后进行了转移。我们知道 std::string 的移动构造，是转移所有权（其实你就可以理解为把原对象的指向数据的指针给了我们当前的对象，然后原对象赋空）。</p><p>我们举个例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">struct</span> X<span class="token punctuation">{</span>    <span class="token function">X</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>    <span class="token function">X</span><span class="token punctuation">(</span>X<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"X(X&amp;&amp;)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token function">X</span><span class="token punctuation">(</span><span class="token keyword">const</span> X<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"X(const X&amp;)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">X</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> Y<span class="token punctuation">{</span>    X x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Y y1<span class="token punctuation">;</span>    Y y2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>y1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码会打印一个 <code>X(X&amp;&amp;)</code>，这证明了我们前面说的：</p><p>编译器隐式定义的移动构造函数，被调用，相当于会把自身的数据成员也进行移动，如果它是类类型，且有移动构造，那么也会匹配上，进行调用。</p><h3 id="P-10-不可变数据优先于可变数据"><a href="#P-10-不可变数据优先于可变数据" class="headerlink" title="P.10 不可变数据优先于可变数据"></a>P.10 不可变数据优先于可变数据</h3><p>使用不可变数据的理由有很多。首先，当你使用常量时，你的代码更容易验证。<strong>常量也有更高的优化潜力</strong>。但最重要的是，常量在并发程序中具有很大的优势。不可变数据在设计上是没有数据竞争的，因为数据竞争的必要条件就是对数据进行修改。</p><blockquote><p>其实只需要考虑一个事情：<strong>如果它可以是常量，那就把它设置为常量</strong>。</p></blockquote><h3 id="P-11-封装杂乱的构建，不要让它在代码中散布开"><a href="#P-11-封装杂乱的构建，不要让它在代码中散布开" class="headerlink" title="P.11 封装杂乱的构建，不要让它在代码中散布开"></a>P.11 封装杂乱的构建，不要让它在代码中散布开</h3><p>混乱的代码往往是低级代码，易于隐藏错误，容易出问题。如果可能的话，用 STL 中的高级构建（如容器或算法）来取代你的杂乱代码。如果这不可能，就把那些杂乱代码封装到一个用户定义的类型或函数中去。</p><h3 id="P-12-适当使用辅助工具"><a href="#P-12-适当使用辅助工具" class="headerlink" title="P.12 适当使用辅助工具"></a>P.12 适当使用辅助工具</h3><p>计算机比人类更擅长做枯燥和重复性的工作。也就是说，应该使用静态分析工具、并发工具和测试工具来自动完成这些验证步骤。<strong>用一个以上的 C++ 编译器来编译代码，往往是验证代码的最简方式</strong>。一个编译器可能检测不到某种未定义行为，而另一个编译器可能会在同样情况下发出警告或产生错误。</p><h3 id="P-13-适当使用支持库"><a href="#P-13-适当使用支持库" class="headerlink" title="P.13 适当使用支持库"></a>P.13 适当使用支持库</h3><p>这也很好解释。你应该去找设计良好、文档齐全、支持良好的库。你会得到经过良好测试、<strong>几乎</strong>没有错误的库，其中的算法经过领域专家的高度优化。突出的例子包括：<strong>C++ 标准库</strong>、Guidelines 支持库和 Boost 库。</p><blockquote><p>我觉得一定有人看到这段会嗤之以鼻，但是总体其实没错的。</p></blockquote><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口是服务的提供者和使用者之间的契约。根据 C++ Core Guidelines，接口”可能是代码辅助中最重要的一个方面”。“接口”这一部分大约有 20 条规则。</p><blockquote><p><em>让接口易于正确使用，难以错误使用</em>。</p></blockquote><h3 id="I-2-避免非-const-的全局变量"><a href="#I-2-避免非-const-的全局变量" class="headerlink" title="I.2 避免非 const 的全局变量"></a>I.2 避免非 const 的全局变量</h3><p>当然，你应该避免非 const 的全局变量。但是为什么呢？为什么全局变量（尤其是当它不是常量时）会很糟糕？<strong>全局变量会在函数中注入隐藏的依赖，而该依赖并不是接口的一部分</strong>。下面的代码片段说明了我的观点：</p><blockquote><p>加粗的话注意理解。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> glob<span class="token punctuation">{</span> <span class="token number">2011</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">multiply</span><span class="token punctuation">(</span><span class="token keyword">int</span> fac<span class="token punctuation">)</span><span class="token punctuation">{</span>    glob <span class="token operator">*</span><span class="token operator">=</span> glob<span class="token punctuation">;</span>    <span class="token keyword">return</span> glob <span class="token operator">*</span> fac<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数 multiply 的执行有一个副作用——会改变全局变量 glob 的值。因此，<strong>你无法对函数进行孤立测试或推理</strong>。当更多的线程并发地使用 multiply 时，你就必须对变量 glob 加以保护。非 const 的全局变量还有更多其他弊端。<strong>如果函数 multiply 没有副作用，那你可以为了性能而将之前的结果存储到缓存中以进行复用。</strong></p><blockquote><p>注意到我们加粗的内容了吗？这非常重要，自行理解。 我们就讲一下最后一句，这其实是在描述<strong>编译器优化</strong> ，我们举个例子：什么情况才可能会是我们说的：<strong>没有副作用，那你可以为了性能而将之前的结果存储到缓存中以进行复用</strong>。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实无非就是：编译器看到你用同样的入参调用了两次 就可以干掉第二次调用。之前的结果被缓存了。（前提是这得是<a href="https://en.m.wikipedia.org/wiki/Pure_function">纯函数</a>）。</p><p>但是我们前面依赖了全局变量，就不行，它有外部的副作用，返回的结果可能会根据全局变量的不同而不同，没办法缓存。不能保证：<strong>多次调用传入的数据相同就能得到完全一致的结果</strong>。</p><h3 id="3-1-非-const-全局变量的弊端"><a href="#3-1-非-const-全局变量的弊端" class="headerlink" title="3.1 非 const 全局变量的弊端"></a>3.1 非 const 全局变量的弊端</h3><p>非 const 的全局变量有许多弊端。首当其冲的弊端是，<strong>非 const 的全局变量破坏了封装。这种对封装的破坏让你无法对函数/类（实体）进行独立思考</strong>。下面列举非 const 全局变量的主要弊端。</p><ul><li><strong>可测试性</strong>：无法孤立地测试你的实体。如果单元不存在，那么单元测试也将不存在。你只能进行系统测试。实体的执行效果要依赖整个系统状态。</li><li><strong>重构</strong>：因为你无法孤立地对代码进行推理，重构它会相当有挑战。</li><li><strong>优化</strong>：你无法轻易地重新安排函数调用或者在不同的线程上进行函数调用，因为可能有隐藏的依赖。缓存之前函数调用的结果也极为危险。</li><li><strong>并发</strong>：产生数据竞争的必要条件是有共享而可变的状态。而非 const 全局变量正是共享而可变的。</li></ul><h3 id="I-3-避免单例"><a href="#I-3-避免单例" class="headerlink" title="I.3 避免单例"></a>I.3 避免单例</h3><p>有时，全局变量伪装得很好。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// singleton.cpp</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">class</span> <span class="token class-name">MySingleton</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">MySingleton</span><span class="token punctuation">(</span><span class="token keyword">const</span> MySingleton<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>    MySingleton<span class="token operator">&amp;</span> <span class="token keyword">operator</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> MySingleton<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> MySingleton<span class="token operator">*</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>instance<span class="token punctuation">)</span><span class="token punctuation">{</span>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">MySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">static</span> MySingleton<span class="token operator">*</span> instance<span class="token punctuation">;</span>    <span class="token function">MySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">MySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>MySingleton<span class="token operator">*</span> MySingleton<span class="token operator">::</span>instance <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><em>单例就是全局变量，因此你应当尽可能*</em>避免单例***。</li></ul><p>单例简单、直接地保证该类最多只有一个实例存在。作为全局变量，单例注入了一个依赖，而该依赖忽略了函数的接口。这是因为作为静态变量，单例通常会被直接调用，正如上面例子主函数中的两行所展示的那样：Singleton::getInstance()。而对单例的直接调用有一些严重的后果。你无法对有单例的函数进行<strong>单元测试</strong>，因为单元不存在。此外，你也不能创建单例的伪对象并在运行期替换，因为单例并不是函数接口的一部分。</p><blockquote><p>我们先聊一下最后一句话：其实就是说，我没办法创造一个和单例一样类型的对象，然后进行函数传参。因为单例不是函数接口的一部分，它通常会被直接调用。 另外，我们要明白，“单例” 它是<strong>带状态</strong>的，单例的状态是经常变化和难以确定的，因为大家都使用和修改这个单例。如果某个函数使用了这个单例，就没办法对它进行单独的单元测试，因为单例的状态无法确定，单例的状态依赖于所有修改它的代码。这也就是前面说的：<strong>你无法对有单例的函数进行单元测试</strong>。</p></blockquote><ul><li><em>简而言之，单例破坏了代码的可测试性</em>。</li></ul><p>实现单例看似小事一桩，但其实不然。你将面对几个挑战：</p><ul><li>谁来负责单例的销毁？</li><li>是否应该允许从单例派生？</li><li>如何以线程安全的方式初始化单例？</li><li>当单例互相依赖并属于不同的翻译单元时，应该以何种顺序初始化这些单例？这里要吓唬吓唬你了。这一难题被称为<strong><a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/xd3G9sh7P">静态初始化顺序问题</a></strong>。</li></ul><h3 id="3-2-运用依赖注入化解"><a href="#3-2-运用依赖注入化解" class="headerlink" title="3.2 运用依赖注入化解"></a>3.2 运用依赖注入化解</h3><p><strong>当某个对象使用单例的时候，注入的依赖就被注入对象中</strong>。而借助依赖注入技术，这个依赖可以变成接口的一部分，并且服务时从外界注入的。这样，客户代码和注入的服务之间就没有依赖了。依赖注入的典型方式是构造函数、设置函数（setter）成员或模板参数。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;chrono></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token keyword">class</span> <span class="token class-name">Logger</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Logger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">SimpleLogger</span><span class="token operator">:</span><span class="token keyword">public</span> Logger<span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> mess<span class="token punctuation">)</span> override<span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> mess <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">TimeLogger</span><span class="token operator">:</span><span class="token keyword">public</span> Logger<span class="token punctuation">{</span>    <span class="token keyword">using</span> MySecondTick <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>duration<span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">;</span>    <span class="token keyword">long</span> <span class="token keyword">double</span> <span class="token function">timeSinceEpoch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">auto</span> timeNow <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>system_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">auto</span> duration <span class="token operator">=</span> timeNow<span class="token punctuation">.</span><span class="token function">time_since_epoch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        MySecondTick <span class="token function">sec</span><span class="token punctuation">(</span>duration<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> sec<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> mess<span class="token punctuation">)</span> override<span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>fixed<span class="token punctuation">;</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Time since epoch: "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">timeSinceEpoch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> mess <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Client</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Client</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Logger<span class="token operator">></span>log<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">logger</span><span class="token punctuation">(</span>log<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        logger<span class="token operator">-</span><span class="token operator">></span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"Message"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">setLogger</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Logger<span class="token operator">></span>log<span class="token punctuation">)</span><span class="token punctuation">{</span>        logger <span class="token operator">=</span> log<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Logger<span class="token operator">></span>logger<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Client <span class="token function">cl</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>SimpleLogger<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//（1）</span>    cl<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cl<span class="token punctuation">.</span><span class="token function">setLogger</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>TimeLogger<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// （2）</span>    cl<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cl<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-构建良好的接口"><a href="#3-3-构建良好的接口" class="headerlink" title="3.3 构建良好的接口"></a>3.3 构建良好的接口</h3><ul><li><em>函数应该通过接口（而不是全局变量）进行沟通</em>。</li></ul><p>现在我们来到了本章的核心。按照 C++ Core Guidelines，下面是关于接口的建议。</p><ul><li>接口明确（I.1）</li><li>接口精确并具有强类型（I.4）</li><li>保持较低的参数数目（I.23）</li><li>避免相同类型却不相关的参数相邻（I.24）</li></ul><p>下面的函数 showRectangle 违反了刚提及的接口的所有规则：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">showRectangle</span><span class="token punctuation">(</span><span class="token keyword">double</span> a<span class="token punctuation">,</span><span class="token keyword">double</span> b<span class="token punctuation">,</span><span class="token keyword">double</span> c<span class="token punctuation">,</span><span class="token keyword">double</span> d<span class="token punctuation">)</span><span class="token punctuation">{</span>    a <span class="token operator">=</span> <span class="token function">floor</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    b <span class="token operator">=</span> <span class="token function">ceil</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">showRectangle</span><span class="token punctuation">(</span>Point top_left<span class="token punctuation">,</span> Point bottom_right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 好</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>尽管函数 showRectangle 本应当只显示一个矩形，但修改了它的参数。实质上它有两个目的，因此，它的名字有误导性（I.1）。另外，函数签名没有提供关于参数应该是什么的任何信息，也没有关于应该以什么顺序提供参数的信息（I.23 和 I.24）。此外，参数是没有取值范围约束的双精度浮点数。因此，这种约束必须在函数中确立（I.4）。对比而言，第二个 showRectangle 函数接受两个具体的点对象（Point）。</p><ul><li><em>检查 Point是否合法值是 Point 构造函数的工作。这种检查工作本来就不是函数 showRectangle 的职责</em>。</li></ul><p>进一步阐述规则 <strong>I.23</strong> 和 <strong>I.24</strong> 以及标准模板库（STL）中的函数 <strong><code>std::transform_reduce</code></strong>。首先，需要定义属于“<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/named_req/Callable">可调用</a>”（callable）。可调用实体是在行为上像函数的东西。它可以是函数，也可以是函数对象，或者是 lambda 表达式。如果可调用实体接受一个参数，它就是一元可调用实体；如果它接受两个参数，则称为二元可调用实体。</p><p>std::transform_reduce 先将一元可调用实体应用到一个范围或将二元可调用实体应用在两个范围，然后将二元可调用实体应用到前一步的结果的范围上。当你使用一个一元 lambda 表达式调用 std::transform_reduce时，这种调用易于正确使用。</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span>strVec<span class="token punctuation">{</span><span class="token string">"Only"</span><span class="token punctuation">,</span> <span class="token string">"for"</span><span class="token punctuation">,</span> <span class="token string">"testing"</span><span class="token punctuation">,</span> <span class="token string">"purpose"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span>size_t res <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">transform_reduce</span><span class="token punctuation">(</span>    std<span class="token operator">::</span>execution<span class="token operator">::</span>par<span class="token punctuation">,</span>    strVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> strVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t a<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t b<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//res 值为 21。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>事实上原书给的上面这段代码是有问题的，无法在 <code>msvc</code> 通过编译，这里使用的是 <code>0</code> 做初始值，有窄化转换，<a href="https://zhuanlan.zhihu.com/p/662592729/https://github.com/microsoft/STL/blob/adea8d5ae280cafb91ae69b8dfaecd1c37a847d9/stl/inc/execution#L4235">msvc 使用的是 {} 初始化</a>。，检测到了，于是编译错误。（但是需要注意，不是简单的 <code>{}</code> 检测的问题，msvc 的实现和其他 stl 从根本上就不一样） 这里其实可以算作是 msvc 的bug，这个场景需要良构 这里应该把 0 换成 <code>Oull</code> （基于当前 64 位环境），或者标准够高使用 <code>0uz</code>，再或者直接 <code>std::size_t{0}</code>。</p></blockquote><p>函数 <code>std::transform_reduce</code> 先将每个字符串变换为它的长度 <code>[](std::string s) {return s.size(); }</code> , 并将二元可调用实体 <code>[](std::size_t a, std::size_t b) {return a + b; },</code> 应用到结果的范围上。求和的初始值是 0。整个计算是并行的 <code>std::execution::par</code>。</p><p>当你使用以下接受两个二元可调用实体的重载版本时，函数声明会变得相当复杂且易错。这违反了 I.23 和 I.24。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ExecutionPolicy</span><span class="token punctuation">,</span>         <span class="token keyword">class</span> <span class="token class-name">ForwardIt1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">ForwardIt2</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">BinaryOp1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">BinaryOp2</span><span class="token operator">></span>T <span class="token function">transform_reduce</span><span class="token punctuation">(</span>ExecutionPolicy<span class="token operator">&amp;&amp;</span> policy<span class="token punctuation">,</span>                   ForwardIt1 first1<span class="token punctuation">,</span> ForwardIt1 last1<span class="token punctuation">,</span> ForwardIt2 first2<span class="token punctuation">,</span>                   T init<span class="token punctuation">,</span> BinaryOp1 binary_op1<span class="token punctuation">,</span> BinaryOp2 binary_op2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用这个重载函数需要 6 个模板参数和 7 个函数参数。按正确顺序使用两个二元可调用实体，可能也是个挑战。</p><blockquote><p>我们展示一下使用这个重载函数的示例代码</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span>strVec<span class="token punctuation">{</span><span class="token string">"Only"</span><span class="token punctuation">,</span> <span class="token string">"for"</span><span class="token punctuation">,</span> <span class="token string">"testing"</span><span class="token punctuation">,</span> <span class="token string">"purpose"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span>vec<span class="token punctuation">{</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token string">"d"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span>size_t res <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">transform_reduce</span><span class="token punctuation">(</span>    std<span class="token operator">::</span>execution<span class="token operator">::</span>par<span class="token punctuation">,</span>    strVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> strVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    std<span class="token operator">::</span>size_t<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t a<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t b<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string s<span class="token punctuation">,</span> std<span class="token operator">::</span>string s2<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>res</code> <a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/oeffEexrc">结果</a> 是 25。</p><p>函数 std::transform_reduce 复杂的原因在于两个函数被合并成了一个。更好的选择应该是分别定义函数 transform 和 reduce，并支持管道运算符调用：<strong>transform | reduce</strong>。</p><h3 id="I-13-不要用单个指针来传递数组"><a href="#I-13-不要用单个指针来传递数组" class="headerlink" title="I.13 不要用单个指针来传递数组"></a>I.13 不要用单个指针来传递数组</h3><ul><li><em>不要用单个指针来传递数组</em>。</li></ul><p>这是一条非常特殊的规则，肯定会有很多人不屑一顾。这条规则的出现正是为了解决一些未定义行为。例如下面的函数 copy_n 相当容易出错。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">copy_n</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">*</span> p<span class="token punctuation">,</span> T<span class="token operator">*</span> q<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 从[p:p+n] 拷贝到 [q:q+n]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">copy_n</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token number">101</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也许某一天累得精疲力尽，就数错了一个。结果会引发一个元素的越界错误，造成未定义行为。补救方法也很简单，使用 STL 中的容器，如 <strong>std::vector</strong>，并在函数体中检查容器大小。C++20 提供的 std::span 能更优雅地解决这个问题。<strong>std::span</strong> 是个对象，它可以指代连续存储的一串对象。 std::span 永远不是所有者（其实就是说它是个视图，没所有权）。而这段连续的内容可以是数组，或是带有大小的指针，或是 std::vector。</p><blockquote><p>函数传参数组不用指针，而是用 C++20 的 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/container/span">std::span</a>。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">copy</span><span class="token punctuation">(</span>std<span class="token operator">::</span>span<span class="token operator">&lt;</span><span class="token keyword">const</span> T<span class="token operator">></span>src<span class="token punctuation">,</span> std<span class="token operator">::</span>span<span class="token operator">&lt;</span>T<span class="token operator">></span> des<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> arr1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> arr2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">copy</span><span class="token punctuation">(</span>arr1<span class="token punctuation">,</span>arr2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>copy 不需要元素的数目。一种常见的错误来源就这样被 <code>std::span&lt;T&gt;</code> 消除了。</p><h3 id="I-27-为了库-ABI-的文档，考虑使用-PImpl"><a href="#I-27-为了库-ABI-的文档，考虑使用-PImpl" class="headerlink" title="I.27 为了库 ABI 的文档，考虑使用 PImpl"></a>I.27 为了库 ABI 的文档，考虑使用 PImpl</h3><p>由于私有数据成员参与类的内存布局，而私有成员函数参与重载决议，<strong>对这些实现细节的改动都要求使用了这类的所有用户全部重新编译</strong>。而持有指向实现的指针（Pimpl）的 非多态的接口类，则可以将类的用户从其实现的改变隔离开来，<strong>而代价是一层间接</strong>。</p><ul><li><strong>接口： Widget.h</strong></li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">widget</span> <span class="token punctuation">{</span>    <span class="token keyword">class</span> <span class="token class-name">impl</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>impl<span class="token operator">></span> pimpl<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 公开 API 转发给实现</span>    <span class="token function">widget</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 定义于实现文件中</span>    <span class="token operator">~</span><span class="token function">widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 定义于实现文件中，其中 impl 将为完整类型</span>    <span class="token function">widget</span><span class="token punctuation">(</span>widget<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 定义于实现文件中</span>    <span class="token function">widget</span><span class="token punctuation">(</span><span class="token keyword">const</span> widget<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>    widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>widget<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 定义于实现文件中</span>    widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> widget<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>实现： Widget.cpp</strong></li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">widget</span><span class="token operator">::</span>impl <span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// private data</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token keyword">const</span> widget<span class="token operator">&amp;</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* ... */</span> <span class="token punctuation">}</span>    <span class="token function">impl</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">n</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> widget<span class="token operator">::</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> pimpl<span class="token operator">-</span><span class="token operator">></span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>widget<span class="token operator">::</span><span class="token function">widget</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token operator">:</span> pimpl<span class="token punctuation">{</span>std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>impl<span class="token operator">></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>widget<span class="token operator">::</span><span class="token function">widget</span><span class="token punctuation">(</span>widget<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>widget<span class="token operator">::</span><span class="token operator">~</span><span class="token function">widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>widget<span class="token operator">&amp;</span> widget<span class="token operator">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>widget<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://link.zhihu.com/?target=http%3A//cppreference.com">http://cppreference.com</a> 提供了关于 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/pimpl">PImpl</a> 惯用法的更多信息。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="4-1-函数定义"><a href="#4-1-函数定义" class="headerlink" title="4.1 函数定义"></a>4.1 函数定义</h3><ul><li><em>好软件的重要原则是好名字</em>。</li></ul><p>这一原则经常被忽视，但对函数而言它尤其适用。</p><h3 id="好名字"><a href="#好名字" class="headerlink" title="好名字"></a>好名字</h3><p>C++ Core Guidelines 用了前三条规则专门讨论好的名字：“F.1：将有意义的操作 ‘打包’ 成精心命名的函数” “F.2：一个函数应该执行单一的逻辑操作” “F.3：使函数保持简短”。</p><blockquote><p>让我从一则轶事开始。几年前，一位软件开发者问我：“我应该如何称呼我的函数？”我告诉他给函数起一个如 verbObject（动词加对象）这样的名字。如果是成员函数，可能用 verb 就可以了，因为该函数已经对一个对象执行了操作。动词代表了对象执行的操作。那位软件开发者反驳这是不可能的；该函数必须被称为 getTimeAndAddToPhonebook 或 processData，因为这些函数执行不止一项工作（单一责任原则）。</p></blockquote><ul><li><em>当你无法为函数找到一个有意义的名称（F.1）时，这充分说明你的函数执行不止一项逻辑操作（F.2），而且你的函数并不简短（F.3）</em>。</li></ul><p>如果一个函数放不进一屏，那就是太长了。一屏意味着大约 60 行，每行 140 个字符，但你的衡量标准可能有所不同。这时，你就应该识别出函数的操作，并将这些操作打包成精心命名的函数。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">read_and_print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//不好</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    std<span class="token operator">::</span>cin <span class="token operator">>></span> x<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//检查错误</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于许多原因，函数 read_and_print 不好。该函数与特定的输入和输出捆绑在一起，不能在不同的上下文中使用。将该函数重构为两个函数，可以解决这些问题，使其更易于测试和维护。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">read</span><span class="token punctuation">(</span>std<span class="token operator">::</span>istream<span class="token operator">&amp;</span>is<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//更好</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    is <span class="token operator">>></span> x<span class="token punctuation">;</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span>os<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    os <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;sstream></span></span><span class="token keyword">int</span> <span class="token function">read</span><span class="token punctuation">(</span>std<span class="token operator">::</span>istream<span class="token operator">&amp;</span>is<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//更好</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    is <span class="token operator">>></span> x<span class="token punctuation">;</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span>os<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    os <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>stringstream s<span class="token punctuation">{</span><span class="token string">"10 "</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> result <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//从 stringstream 中读取</span>    <span class="token function">print</span><span class="token punctuation">(</span>std<span class="token operator">::</span>cout<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//输出到标准输出中</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//打印 stringstream 中的内容</span>    <span class="token function">print</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//输出到 stringstream 中。</span>    <span class="token function">print</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//输出到 stringstream 中。</span>    <span class="token function">print</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//输出到 stringstream 中。</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//打印 stringstream 中的内容</span>    s<span class="token punctuation">.</span><span class="token function">seekg</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//需要进行回溯，因为默认读取位置在上一个read到的位置</span>    <span class="token keyword">auto</span> result2 <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> result2 <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//从 stringstream 中读取</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="F-4-如果函数有可能需要在编译期求值，就把它声明为-constexpr"><a href="#F-4-如果函数有可能需要在编译期求值，就把它声明为-constexpr" class="headerlink" title="F.4 如果函数有可能需要在编译期求值，就把它声明为 constexpr"></a>F.4 如果函数有可能需要在编译期求值，就把它声明为 constexpr</h3><p>constexpr 函数是可能在编译期运行的函数。当你在常量表达式中调用 constexpr 函数时，或者当你要用一个 constexpr 变量来获取 constexpr 函数的结果时，它会在编译期运行。也可以用只能在运行期求值的参数来调用 constexpr 函数。constexpr 函数是隐含内联的。</p><p>编译期求值的 constexpr 的结果通常会被系统标记为只读。性能是 constexpr 函数的一大好处；它的第二大好处是：</p><p><strong>编译期求值的 constexpr 是纯函数，因此 constexpr 函数是线程安全的</strong>。</p><blockquote><p>加粗这句话是因为这句话是 <strong>错误</strong> 的。 我们下面把这句话分开来聊：</p></blockquote><ul><li>“<strong>constexpr 函数是线程安全的</strong>”？</li></ul><p>完全错误。</p><p>这里会涉及到一个问题：</p><ul><li>C++23 前，标准要求至少存在一组实参值，使得函数的一个调用为核心常量表达式的被求值的子表达式（对于构造函数为足以用于常量初始化器）。<strong>不要求诊断是否违反这点</strong>。</li><li>C++23 起，<strong>标准移除了这一要求</strong>。</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//永远不可能编译期求值</span>    <span class="token keyword">return</span> n <span class="token operator">*</span><span class="token operator">=</span> n<span class="token punctuation">,</span> n <span class="token operator">*</span> v<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//C++23前可能可以通过编译，也可能不行；C++23起能通过编译</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不过这还是太牵强了，我们可以用一个更简单直接的 demo 展示：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token operator">++</span>a<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token function">f</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//运行期调用，修改b</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上这段代码显然不是线程安全的，各位可以自己<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/co8TdvEos">测试</a>。<strong>你可能可以看到结果是正确的，但是事实上这没什么价值，某些 CPU 能保证标量类型的读写线程安全</strong>。</p><ul><li>“<strong>编译期求值的 constexpr 函数是纯函数</strong>“？</li></ul><p>完全错误（C++11 以后）</p><blockquote><p>C++11 的常量求值中函数只能表现为纯的，一旦有修改操作就导致常量求值失败</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>v<span class="token punctuation">)</span><span class="token punctuation">{</span>    v <span class="token operator">+</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> v <span class="token operator">*</span> v<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">constexpr</span> std<span class="token operator">::</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> r1 <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> r2 <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span> r1<span class="token punctuation">,</span>r2 <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">constexpr</span> <span class="token keyword">auto</span> result <span class="token operator">=</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> result<span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span> <span class="token operator">&lt;&lt;</span> result<span class="token punctuation">.</span>second <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我的函数 f <strong>的确是编译期求值</strong>，没毛病，难不成它是<a href="https://link.zhihu.com/?target=https%3A//en.m.wikipedia.org/wiki/Pure_function">纯函数</a>？你要不看看它都做了什么.</p><blockquote><p>我们回到前面的性能话题</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">auto</span> <span class="token function">gcd</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>b<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">auto</span> t <span class="token operator">=</span> b<span class="token punctuation">;</span>        b <span class="token operator">=</span> a <span class="token operator">%</span> b<span class="token punctuation">;</span>        a <span class="token operator">=</span> t<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">gcd</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">121</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//（1）编译期求值</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">121</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token function">gcd</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//（2）非编译期求值</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>原书这里是要你看<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/qjzxxv5oe">汇编</a>的，友情提示，别开优化，这么点代码，开优化，啥 call 都没有。 下面是使用 gcc13.2 生成的 Intel 风格的汇编代码。</p></blockquote><p><img src="/posts/8961/image.png" alt></p><p>（1）所对应汇编指令就是 26行。（2）所对应的汇编指令就是 31~34 行。</p><p>调用 <code>constexpr int i = gcd(11, 121);</code> 会变成值 11，但调用 <code>int j = gcd(a, b);</code> 却会产生一个函数调用。</p><h3 id="F-6-如果你的函数必定不抛出异常，就把它声明为-noexcept"><a href="#F-6-如果你的函数必定不抛出异常，就把它声明为-noexcept" class="headerlink" title="F.6 如果你的函数必定不抛出异常，就把它声明为 noexcept"></a>F.6 如果你的函数必定不抛出异常，就把它声明为 noexcept</h3><p>通过将函数声明为 noexcept，你减少了备选控制路径的数量；因此，noexcept 对优化器来说是一个有价值的提示。</p><ul><li><em>即使你的函数可以抛出异常，noexcept 往往也合理</em>。</li></ul><p>noexcept 在这种情况下意味着：</p><ul><li><em>我不在乎异常。其原因可能是，你无法对异常做出反应</em>。</li></ul><p>这种情况下，系统处理异常的唯一办法是调用 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/error/terminate">std::terminate()</a>。这个 noexcept 声明也为代码的读者提供了有价值的信息。</p><p>下面的函数会在内存耗尽时崩溃。</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> <span class="token function">collect</span><span class="token punctuation">(</span>std<span class="token operator">::</span>istream<span class="token operator">&amp;</span> is<span class="token punctuation">)</span><span class="token keyword">noexcept</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span>res<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>string s<span class="token punctuation">;</span> is <span class="token operator">>></span> s<span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下类型的函数永远不该抛出异常：析构函数（见第 5 章中 “失败的析构函数” 一节）、swap 函数，移动操作和默认构造函数。</p><h3 id="F-8-优先使用纯函数"><a href="#F-8-优先使用纯函数" class="headerlink" title="F.8 优先使用纯函数"></a>F.8 优先使用纯函数</h3><ul><li><em>纯函数是指在给定相同参数时总返回相同结果的函数</em>。</li></ul><blockquote><p>其实还有：该函数没有副作用（局部静态变量、非局部变量、可变引用参数或输入/输出流没有突变）。下面也略微提到了。</p></blockquote><p>函数模板 square 就是纯函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">square</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> t <span class="token operator">*</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>而非纯函数是指 random() 或 time() 这样的函数，<strong>它们会在不同的调用中返回不同的结果</strong>。换句话说：</p><ul><li><em>与函数体之外的状态交互的函数是不纯的</em>。</li></ul><p>纯函数可以：</p><ul><li>孤立地侧测试</li><li>孤立地验证或重构</li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/Mq-b/Loser-HomeWork/blob/main/C%2B%2BCoreGuidelines%E8%A7%A3%E6%9E%90/%E7%AC%AC3%E7%AB%A0-%E6%8E%A5%E5%8F%A3.md%23i2-%E9%81%BF%E5%85%8D%E9%9D%9E-const-%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F">缓存其结果</a></li><li>被自动重排或在其他线程上执行</li></ul><p>纯函数也被称为数学函数。C++ 中的函数默认情况下不是像纯函数式编程语言 Haskell 中那样的纯函数。 在 C++ 中使用纯函数时要基于程序员的素养。<strong>constexpr 函数在编译期求值时是纯的</strong>。</p><blockquote><p>加粗的原因很简单，因为这句话是<strong>错的</strong> 在 <code>F.4</code> 已经介绍过了。</p></blockquote><p>模板元编程时一种嵌在命令式语言 C++ 中的纯函数式语言。</p><p>第 13 章将简单介绍编译期编程，其中包括模板元编程。</p><h3 id="4-2-参数传递：入与出"><a href="#4-2-参数传递：入与出" class="headerlink" title="4.2 参数传递：入与出"></a>4.2 参数传递：入与出</h3><p>C++ Core Guidelines 有若干条规则表达了在函数中传入和传出参数的各种方式。</p><h3 id="F-15-优先采用简单而约定俗成的信息传递方式"><a href="#F-15-优先采用简单而约定俗成的信息传递方式" class="headerlink" title="F.15 优先采用简单而约定俗成的信息传递方式"></a>F.15 优先采用简单而约定俗成的信息传递方式</h3><p>第一条规则展示了大局。首先，它提供了一个概览，介绍了在函数中传入和传出信息的各种方式（见表 4.1）</p><p>表 4.1 很简洁：表头表述了数据在拷贝和移动开销方面的特征，而各行则表明了参数传递的方向。</p><p><strong>表 4.1 普通的参数传递</strong></p><table><thead><tr><th></th><th>拷贝开销低或不可能拷贝</th><th>移动开销低到中，或者未知</th><th>移动开销高</th></tr></thead><tbody><tr><td>入</td><td>func(x)</td><td>func(const X&amp;)</td><td></td></tr><tr><td>入并保留“拷贝”</td><td></td><td></td><td></td></tr><tr><td>入/出</td><td>func(X&amp;)</td><td></td><td></td></tr><tr><td>出</td><td>X func()</td><td>func(X&amp;)</td><td></td></tr></tbody></table><ul><li>数据类型</li><li><strong>拷贝开销低或不可能拷贝</strong>：<code>int</code> 或 <code>std::unique_ptr</code></li><li><strong>移动开销低</strong>：<code>std::vector&lt;T&gt;</code> 或 <code>BigPOD</code>（POD 代表 Old Data “简旧数据”，意为一般的传统数据——没有析构函数、构造函数以及虚成员函数的类）</li><li><strong>移动开销未知</strong>：模板</li><li><strong>移动开销高</strong>：<code>BigPOD[]</code> 或者 <code>std::array&lt;BigPOD&gt;</code></li><li>参数传递的方向</li><li><strong>入</strong>：输入参数</li><li><strong>入并保留“拷贝”</strong>：被调用者保留一份数据</li><li><strong>入/出</strong>：参数会被修改</li><li><strong>出</strong>：输出参数</li></ul><p>对几个 int 大小的数据的操作是低开销的；在不进行内存分配的前提下，1000 字节左右的操作属于中等开销。</p><p>这些普通的参数传递规则则应当是你的首选。不过，也有高级的参数传递规则（见表4.2）。实质上，就是加入了“入并移入”的语义。</p><p><strong>表 4.2 高级的参数传递</strong></p><table><thead><tr><th></th><th>拷贝开销低或不可能拷贝</th><th>移动开销低到中，或者未知</th><th>移动开销高</th></tr></thead><tbody><tr><td>入</td><td>func(x)</td><td>func(const X&amp;)</td><td></td></tr><tr><td>入并保留“拷贝”</td><td></td><td></td><td></td></tr><tr><td>入并移入</td><td>func(X&amp;&amp;)</td><td></td><td></td></tr><tr><td>入/出</td><td>func(X&amp;)</td><td></td><td></td></tr><tr><td>出</td><td>X func()</td><td>func(X&amp;)</td><td></td></tr></tbody></table><blockquote><p>这两个表的 “<strong>出</strong>” 用的 <code>func(X&amp;)</code> 其实是指代那种老式的写法，传入参数做传出参数，Win32中很常见。 “<strong>不可能拷贝</strong>” 其实是指：<code>f(X{})</code> 这种形式，C++17 起强制的复制消除，不可能再复制。 “<strong>入并移入</strong>” 就是让你 <code>f(std::move(...))</code>。</p></blockquote><p>在 “入并移入” 调用后，参数处在所谓的被移动状态。被移动状态意味着它处于合法但未指定的状态。基本上，你在重新使用被移动的对象前必须对它进行初始化。</p><p>其余的参数传递规则为以上这些表格提供了必要的背景信息。</p><h3 id="F-16-对于-“入”参，拷贝开销低的类型按值传递，其他类型则以-const-引用来传递"><a href="#F-16-对于-“入”参，拷贝开销低的类型按值传递，其他类型则以-const-引用来传递" class="headerlink" title="F.16 对于 “入”参，拷贝开销低的类型按值传递，其他类型则以 const 引用来传递"></a>F.16 对于 “入”参，拷贝开销低的类型按值传递，其他类型则以 const 引用来传递</h3><p>这条规则执行起来直截了当。默认情况下，输入值可以拷贝就拷贝。如果拷贝开销不低，就通过 const 引用来传入。C++ Core Guidelines 给出了回答以下问题的经验法则：</p><p><strong>哪些对象拷贝开销低？哪些对象拷贝高？</strong></p><ul><li><em>如果 `sizeof(par) &lt;= 2 \</em> sizeof(void*)`，则按值传递参数 par*。</li><li><em>如果 `sizeof(par) &gt; 2 \</em> sizeof(void*)`，则按 const 引用 传递参数 par*。</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 可以：按 const 的引用传递；</span>                                 <span class="token comment" spellcheck="true">// 总是低开销</span><span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string s<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 差劲：潜在的高昂开销</span><span class="token keyword">void</span> <span class="token function">f3</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// 可以：无可匹敌</span><span class="token keyword">void</span> <span class="token function">f4</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 差劲：在 f4() 里面访问时有额外开销</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="F-19-对于“转发”参数，要用-Tp-amp-amp-来传递，并且只-std-forward-该参数"><a href="#F-19-对于“转发”参数，要用-Tp-amp-amp-来传递，并且只-std-forward-该参数" class="headerlink" title="F.19 对于“转发”参数，要用 Tp&amp;&amp; 来传递，并且只 std::forward 该参数"></a>F.19 对于“转发”参数，要用 Tp&amp;&amp; 来传递，并且只 std::forward 该参数</h3><p>这条规则代表了一种特殊的输入值。有时你想完美转发参数 par。这意味着你希望保持左值的左值性，以及右值的右值性，这样才能“完美”地转发参数，使它的语义不发生变化。</p><p>该转发参数的典型用例是工厂函数，工厂函数通过调用某个用户指定对象的构造函数创造处该对象。你不知道参数是不是右值，也不知道构造函数需要多少参数。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;utility></span></span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span><span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>T1<span class="token operator">></span>     <span class="token comment" spellcheck="true">//（1）</span>T <span class="token function">create</span><span class="token punctuation">(</span>T1<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>t1<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">T</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">struct</span> MyType<span class="token punctuation">{</span>    <span class="token function">MyType</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 左值</span>    <span class="token keyword">int</span> five <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> myFive <span class="token operator">=</span> create<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>five<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 右值</span>    <span class="token keyword">int</span> myFive2 <span class="token operator">=</span> create<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 无参数</span>    <span class="token keyword">int</span> myZero <span class="token operator">=</span> create<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 三个参数；（左值，右值，右值）</span>    MyType myType <span class="token operator">=</span> create<span class="token operator">&lt;</span>MyType<span class="token operator">></span><span class="token punctuation">(</span>myZero<span class="token punctuation">,</span> <span class="token number">5.5</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>形参包的打包和解包</strong></p><p>当省略号在类型参数 T1 的左边时，参数包被打包；当省略号在右边时，参数包被解包。返回语句 <code>T(std::forwardt1(t1)...)</code> 中的这种解包实质上意味着表达式 <code>std::forwardt1(t1)</code> <strong>被不断重复，直到形参包中的所有参数都被消耗掉，并且会在每一个子表达式之间加一个逗号</strong>。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>T1<span class="token operator">></span>     <span class="token comment" spellcheck="true">//（1）</span>T <span class="token function">create</span><span class="token punctuation">(</span>T1<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>t1<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">T</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">struct</span> X<span class="token punctuation">{</span>    <span class="token function">X</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">double</span><span class="token punctuation">,</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    X resutl <span class="token operator">=</span> create<span class="token operator">&lt;</span>X<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1.2</span><span class="token punctuation">,</span> <span class="token string">'*'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码的 <code>create</code> 模板，实例化相当于下面这种形式：（也符合前面说的“被不断重复，直到形参包中的所有参数都被消耗掉，并且会在每一个子表达式之间加一个逗号”）</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span>X create<span class="token operator">&lt;</span>X<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span> __t10<span class="token punctuation">,</span> <span class="token keyword">double</span> <span class="token operator">&amp;&amp;</span> __t11<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">&amp;&amp;</span> __t12<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">X</span><span class="token punctuation">(</span><span class="token function">X</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>__t10<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">(</span>__t11<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span><span class="token punctuation">(</span>__t12<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于好奇的读者 <a href="https://link.zhihu.com/?target=https%3A//cppinsights.io/">C++ Insights</a> 可以展示这个过程。</p><p>转发与变参模板的结合是 C++ 中典型的创建模式。下面是 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/memory/unique_ptr/make_unique">std::make_unique</a> 的一种可能实现。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token operator">></span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">make_unique</span><span class="token punctuation">(</span>Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">T</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Args<span class="token operator">></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="F-17-对于“入-出”参数，使用非-const-的引用来传递"><a href="#F-17-对于“入-出”参数，使用非-const-的引用来传递" class="headerlink" title="F.17 对于“入-出”参数，使用非 const 的引用来传递"></a>F.17 对于“入-出”参数，使用非 const 的引用来传递</h3><p>这条规则把函数的设计意图传递给了调用方：该函数会修改它的参数。</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>myVec<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">modifyVector</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> vec<span class="token punctuation">)</span><span class="token punctuation">{</span>    vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vec<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="F-20-对于“出”的输出值，优先使用返回值而非输出参数"><a href="#F-20-对于“出”的输出值，优先使用返回值而非输出参数" class="headerlink" title="F.20 对于“出”的输出值，优先使用返回值而非输出参数"></a>F.20 对于“出”的输出值，优先使用返回值而非输出参数</h3><p>这条规则很简单。</p><ul><li><em>用返回值就好，但别用 const，因为它不但没有附加价值，而且会干扰移动语义</em>。</li></ul><p>也许你认为值的复制开销巨大，这<strong>既对也不对</strong>。原因在于编译器会应用 RVO（return value optimization，返回值优化）或 NRVO（named return value optimization，具名返回值优化）。</p><p>RVO 意味着编译器可以消除不必要的复制操作。到了 C++17，原本只是可能会做的优化成了一种<strong>保证</strong>。</p><pre class="line-numbers language-cpp"><code class="language-cpp">MyType <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> MyType<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// C++17 中不会拷贝</span><span class="token punctuation">}</span>MyType myType <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// C++17 中不会拷贝</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这几行中可能会发生两次不必要的拷贝操作：第一次在返回调用中，第二次在函数调用中。C++17 中则不会有拷贝操作发生。如果这个返回值有名字，我们就称这种优化为 NRVO。你大概也已经猜到了。</p><pre class="line-numbers language-cpp"><code class="language-cpp">MyType <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    NyType myValue<span class="token punctuation">;</span>    <span class="token keyword">return</span> myValue<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 允许拷贝一次</span><span class="token punctuation">}</span>MyType myType <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 在 C++17 中不会拷贝</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里有一个细微的区别：按照 C++17 编译器仍然可以在返回语句中拷贝值 myValue，但在函数调用的地方则不会发生拷贝。</p><blockquote><p>这里详细聊一下 复制消除 NRVO RVO 吧：</p></blockquote><p>下列环境下，允许但不要求编译器省略类对象的复制和移动 (C++11 起)构造，即使复制/移动 (C++11 起)构造函数和析构函数拥有可观察的副作用。这些对象将直接构造到它们本来要复制/移动到的存储中。<strong>这是一项优化</strong>：即使进行了优化而不调用复制/移动 (C++11 起)构造函数，它仍然必须存在且可访问（如同完全未发生优化），否则程序非良构</p><p><strong>在对象的初始化中，当源对象是无名临时量且与目标对象具有相同类型（忽略 cv 限定）时。当无名临时量为 return 语句的操作数时，称这种复制消除的变体为 RVO，“返回值优化 (return value optimization)”。</strong></p><p>C++17起 返回值优化是<strong>强制要求的</strong>（也就是不再被当成优化），而不再被当做复制消除。</p><p>这就是 RVO 的规则，只要满足，那么在 C++17 就不可能有复制开销。</p><p>我们看到先前的代码示例，之所以第一个示例在 C++17 都不会有额外拷贝就是因为它</p><p><code>return MyType{};</code> 满足了：<strong>当无名临时量为 return 语句的操作数</strong>。</p><p><code>MyType myType = func();</code> 满足了：<strong>在对象的初始化中，当源对象是无名临时量且与目标对象具有相同类型（忽略 cv 限定）时</strong>。</p><p>因为 <strong>NRVO</strong> 的存在，不一定会拷贝，只是不保证而已。</p><p><strong>return 语句中，当操作数是拥有自动存储期的非 volatile 对象的名字，该名字不是函数形参或 catch 子句形参，且其具有与函数返回类型相同的类类型（忽略 cv 限定）时。这种复制消除的变体被称为</strong> NRVO<strong>，“具名返回值优化 (named return value optimization)”。</strong></p><p>函数往往必须返回多于一个值。于是，规则 F.21 来了。</p><h3 id="F-21-要返回多个“出”值，优先考虑返回结构体或者多元组"><a href="#F-21-要返回多个“出”值，优先考虑返回结构体或者多元组" class="headerlink" title="F.21 要返回多个“出”值，优先考虑返回结构体或者多元组"></a>F.21 要返回多个“出”值，优先考虑返回结构体或者多元组</h3><p>当你向 std::set 中插入一个值时，成员函数 insert 的重载会返回一个 std::pair，它由两部分组成：一个指向所插入元素的迭代器；还有一个 bool，如果插入成功，它会被设置为 true。C++11 中的 std::tie 和 C++17 中的结构化绑定是将两个值绑定到某变量的两种优雅方式。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;set></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;tuple></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>mySet<span class="token punctuation">;</span>    std<span class="token operator">::</span>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator iter<span class="token punctuation">;</span>    <span class="token keyword">bool</span> inserted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">tie</span><span class="token punctuation">(</span>iter<span class="token punctuation">,</span> inserted<span class="token punctuation">)</span> <span class="token operator">=</span> mySet<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">2011</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//（1）</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>inserted<span class="token punctuation">)</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"2011 was inserted successfully\n"</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> <span class="token punctuation">[</span>iter2<span class="token punctuation">,</span> inserted2<span class="token punctuation">]</span> <span class="token operator">=</span> mySet<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">2017</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//（2）</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>inserted2<span class="token punctuation">)</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"2017 was inserted successfully\n"</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在（1）处，我们使用 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/utility/tuple/tie">std::tie</a> 将插入操作的返回值解包到 iter 和 inserted 中。而在（2）处，我们使用结构化绑定将插入操作的返回值解包到 iter2 和 inserted2 中。与结构化绑定相比，std::tie 还需要预先声明的变量。<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/3GKbGeYsY">运行结果</a>：</p><pre class="line-numbers language-text"><code class="language-text">2011 was inserted successfully2017 was inserted successfully<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="4-3-参数传递：所有权语义"><a href="#4-3-参数传递：所有权语义" class="headerlink" title="4.3 参数传递：所有权语义"></a>4.3 参数传递：所有权语义</h3><p>上一节探讨参数的流向：哪些参数是入，哪些参数是入/出或出。但对参数来说，除了流动的方向，还有其他需要考虑的问题。传递参数也事关<strong>所有权语义</strong>。但本节会介绍 5 种典型的参数传递方式：通过拷贝、通过指针、通过引用、通过 std::unique_ptr 和通过 std::shared_ptr 。</p><p>只有通过智能指针传参的相关规则是在本节内新出现的。</p><p>通过拷贝传参的规则是 4.2 节“参数传递：入与出” 的一部分。而通过指针和引用传参的规则是 第 3 章的一部分。</p><p><strong>表 4.3 参数传递的所有权语义</strong></p><table><thead><tr><th>例子</th><th>所有权</th><th>规则</th></tr></thead><tbody><tr><td>func(value)</td><td>func 是资源所有者</td><td>F.16</td></tr><tr><td>func(pointer*)</td><td>func 借用了资源</td><td>I.11 和 F.7</td></tr><tr><td>func(reference&amp;)</td><td>func 借用了资源</td><td>I.11 和 F.7</td></tr><tr><td>func(std::unique_ptr)</td><td>func 是资源的独占所有者</td><td>F.26</td></tr><tr><td>func(std::shared_ptr)</td><td>func 是资源的共享所有者</td><td>F.27</td></tr></tbody></table><p>更多细节如下。</p><ul><li>func(value)：函数 func 自己有一份 value 的拷贝并且就是其所有者。func 会自动释放该资源。</li><li>func(pointer*)：func 借用了资源，所以无权删除该资源。func 在每次使用前都必须检查该指针是否为空指针。</li><li>func(reference&amp;)：func 借用了资源。与指针不同，引用的值总是合法的。</li><li>func(std::unique_ptr)：func 是资源的新所有者。func 的调用方显式地把资源的所有权传给了被调用方。func 会自动释放该资源。</li><li>func(std::shared_ptr)：func 是资源的额外所有者。func 会延长资源的生存期。在 func 结束时，它也会结束对资源的所有权。如果 func 是资源的最后一个所有者，那么它的结束会导致资源的释放。</li></ul><h3 id="谁是所有者？"><a href="#谁是所有者？" class="headerlink" title="谁是所有者？"></a>谁是所有者？</h3><p>务必明确表达出所有权。试想一下，你的程序是用传统 C++ 编写的，只能使用原始指针来表达指针、引用、std::unique_ptr 或 std::shared_ptr 这四种传参方式的所有权语义。</p><ul><li><em>传统 C++ 的关键问题是，谁是所有者？</em></li></ul><p>下面的代码说明了我的观点：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">double</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">double</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">func</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关键问题是，谁是资源的所有者？是使用该数组的 func 中的被调用方，还是创建该数组的 func 的调用方？如果 func 是所有者，那么它必须释放该资源。如果不是，则func 不可以释放资源。这种情况不能令人满意。如果 func 不释放资源，可能会发生内存泄露。如果 func 释放了资源，可能会导致未定义行为。</p><p>因此，所有权需要记录在文档中。使用现代 C++ 中的类型系统来定义所有权的契约是朝正确方向迈出的一大步，可以消除文档的模糊性。</p><ul><li>！！！！！<em>在应用层面使用 <code>std::move</code> 的意图并不在于移动，而是所有权的转移</em>。</li></ul><p>举例来说，若对 std::unique_ptr 应用 std::move，会将内存的所有权转移到另一个 std::unique_ptr。智能指针 uniquePtr1 是原来的所有者，而 uniquePtr2 将成为新的所有者。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> uniquePtr1 <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">2011</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> uniquePtr2<span class="token punctuation">{</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>uniquePtr1<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>下面是所有权在实践中的五种变体：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;utility></span></span><span class="token keyword">class</span> <span class="token class-name">MyInt</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">explicit</span> <span class="token function">MyInt</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">myInt</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">MyInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> myInt <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> myInt<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">funcCopy</span><span class="token punctuation">(</span>MyInt myInt<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">funcPtr</span><span class="token punctuation">(</span>MyInt<span class="token operator">*</span> myInt<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">funcRef</span><span class="token punctuation">(</span>MyInt<span class="token operator">&amp;</span> myInt<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">funcUniqPtr</span><span class="token punctuation">(</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>MyInt<span class="token operator">></span>myInt<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">funcSharedPtr</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>MyInt<span class="token operator">></span>myInt<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"=== Begin"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    MyInt myInt<span class="token punctuation">{</span> <span class="token number">1998</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    MyInt<span class="token operator">*</span> myIntPtr <span class="token operator">=</span> <span class="token operator">&amp;</span>myInt<span class="token punctuation">;</span>    MyInt<span class="token operator">&amp;</span> myIntRef <span class="token operator">=</span> myInt<span class="token punctuation">;</span>    <span class="token keyword">auto</span> uniqPtr <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>MyInt<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">2011</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> sharedPtr <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>MyInt<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">2014</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">funcCopy</span><span class="token punctuation">(</span>myInt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">funcPtr</span><span class="token punctuation">(</span>myIntPtr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">funcRef</span><span class="token punctuation">(</span>myIntRef<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">funcUniqPtr</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>uniqPtr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">funcSharedPtr</span><span class="token punctuation">(</span>sharedPtr<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"=== End"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/z8Tn197Ph">运行结果</a>：</p><pre class="line-numbers language-text"><code class="language-text">=== Begin19982011=== End20141998<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果显示，有两个析构函数在 main 函数结束之前被调用，还有两个析构函数在 main 函数结束的地方被调用。</p><p>在 main 函数结束之前析构的是 被<strong>拷贝</strong>到函数中（<code>funcCopy(myInt)</code>），以及被<strong>移动</strong>到函数中 （<code>funcUniqPtr(std::move(uniqPtr))</code>）。</p><ol><li>拷贝拷贝了一份新的 MyInt 到函数 func 中，func 结束的时候，自然进行析构，打印 <code>1998</code>。</li><li>移动转移了智能指针资源的所有权，所以在 func 结束的时候，<code>RAII</code> 释放了内存，打印 <code>2011</code>。</li><li><code>shared_ptr</code> 对象的资源并没有转移，它是共享的，有两个对象共享资源，分别是 main 函数局部的，以及 func 函数中的，所以当 func 结束的时候，只是引用计数减一，不会释放资源。只能等到 main 函数也结束的时候才会析构，释放内存，打印 <code>2014</code> 。</li><li><code>MyInt myInt</code> 析构，打印 <code>1998</code>。其实你可以注意到，打印了两次 <code>1998</code>，因为第一次析构的是复制到函数中的。</li></ol><h3 id="4-4-值返回语义"><a href="#4-4-值返回语义" class="headerlink" title="4.4 值返回语义"></a>4.4 值返回语义</h3><p>本节中的 7 条规则与前面提到的规则 “F.20：对于‘出’的输出值，优先使用返回值而非输出参数”相一致。这一节的规则还与一些特殊用例和不建议的做法相关。</p><h3 id="F-42-返回-T-（仅仅）用于表示位置"><a href="#F-42-返回-T-（仅仅）用于表示位置" class="headerlink" title="F.42 返回 T* （仅仅）用于表示位置"></a>F.42 返回 T* （仅仅）用于表示位置</h3><ul><li><em>指针仅用于表示位置</em></li></ul><p>这正是 find 的作用。</p><pre class="line-numbers language-cpp"><code class="language-cpp">Node <span class="token operator">*</span> <span class="token function">find</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> t<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>t <span class="token operator">||</span> t<span class="token operator">-</span><span class="token operator">></span>name <span class="token operator">==</span> s<span class="token punctuation">)</span><span class="token keyword">return</span> t<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">auto</span> p <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>t<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">auto</span> p <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>t<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里指针表示名字与 s 相匹配的 Node 的位置。</p><h3 id="F-44-当不希望发生拷贝，也不需要表达“没有返回对象”时，应返回-T-amp"><a href="#F-44-当不希望发生拷贝，也不需要表达“没有返回对象”时，应返回-T-amp" class="headerlink" title="F.44 当不希望发生拷贝，也不需要表达“没有返回对象”时，应返回 T&amp;"></a>F.44 当不希望发生拷贝，也不需要表达“没有返回对象”时，应返回 T&amp;</h3><p>当不存在“没有返回对象” 这种可能性的时候就可以返回引用而非指针了。</p><p>有时你<strong>想进行链式操作</strong>，但不想为不必要的临时对象进行拷贝和析构。典型的用例是输入和输出流或赋值运算符（“F.47：从赋值运算符返回 T&amp;”）。在下面的代码片段中，通过 <strong>T&amp;</strong> 返回和通过 <strong>T</strong> 返回有什么微秒的区别？</p><pre class="line-numbers language-cpp"><code class="language-cpp">A<span class="token operator">&amp;</span> <span class="token keyword">operator</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>A <span class="token keyword">operator</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>A a1<span class="token punctuation">,</span> a2<span class="token punctuation">,</span> a3<span class="token punctuation">;</span>a1 <span class="token operator">=</span> a2 <span class="token operator">=</span> a3<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>返回拷贝（A）的拷贝赋值运算符会触发两个额外的 A 类型临时对象的创建。</p><h3 id="局部对象的引用"><a href="#局部对象的引用" class="headerlink" title="局部对象的引用"></a>局部对象的引用</h3><p>返回局部对象的引用（指针）是<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/ub">未定义行为</a>。</p><ul><li><em>未定义行为本质上意味着，不要假想程序的行为</em>。</li></ul><p>先修复未定义行为。程序 <code>lambdaFuncionCapture.cpp</code> 返回了局部对象的引用。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token keyword">auto</span> <span class="token function">makeLambda</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">const</span> std<span class="token operator">::</span>string val <span class="token operator">=</span> <span class="token string">"on stack created"</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>val<span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token keyword">return</span> val<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//（2）</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">auto</span> bad <span class="token operator">=</span> <span class="token function">makeLambda</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//（1）</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">bad</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//（3）</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>main 函数调用函数 makeLambda()（1）。该函数返回一个 Lambda 表达式，它具有对局部变量 val（2）的引用。</p><p>调用 bad()（3）导致了未定义行为，因为 Lambda 表达式使用了局部变量 val 的引用。由于它是局部变量，它的生存期随着 makeLambda() 的作用域结束而结束。</p><p>执行该程序时会得到无法预知的结果。有时我得到整个字符串，有时得到字符串的一部分，有时只得到 0。</p><blockquote><p>且可能随着 C++ 标准的不同，优化的等级等，而<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/GzGe7T97o">变化</a>。纠结这个结果并没有多少价值，<strong>未定义行为本质上意味着，不要假想程序的行为</strong>。</p></blockquote><h3 id="F-45-不要返回-T-amp-amp"><a href="#F-45-不要返回-T-amp-amp" class="headerlink" title="F.45 不要返回 T&amp;&amp;"></a>F.45 不要返回 T&amp;&amp;</h3><p>以及</p><h3 id="F-48-不要返回-std-move-本地变量"><a href="#F-48-不要返回-std-move-本地变量" class="headerlink" title="F.48 不要返回 std::move(本地变量)"></a>F.48 不要返回 std::move(本地变量)</h3><p>两条规则都非常严格。</p><p>不应当以 T&amp;&amp; 作为返回类型。下面的小例子展示了这个问题。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> <span class="token function">returnRvalueReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">auto</span> myInt <span class="token operator">=</span> <span class="token function">returnRvalueReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在编译时，GCC 编译器会立即抱怨对临时对象的引用。准确地说，临时对象的生存期随着整个表达式 <code>auto myInt = returnRvalueReference();</code> 的结束而结束。</p><blockquote><p><strong>在函数调用中绑定到函数形参的临时量，存在到含这次函数调用的全表达式结尾为止：如果函数返回一个生命长于全表达式的引用，那么它会成为悬垂引用。</strong></p></blockquote><pre class="line-numbers language-text"><code class="language-text"><source>: In function 'int&& returnRvalueReference()':<source>:2:16: warning: returning reference to temporary [-Wreturn-local-addr]    2 |     return int{};      |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="std-move-本地变量"><a href="#std-move-本地变量" class="headerlink" title="std::move(本地变量)"></a>std::move(本地变量)</h3><p>由于 RVO 和 NRVO 的拷贝消除，return std::move(本地变量)的使用不是优化而是劣化。劣化意味着<strong>程序可能会变得更慢</strong>。</p><blockquote><p>std::move(本地变量)的确毫无意义，但是 <code>return std::move(expr)</code> 不是，可以看之前的<a href="https://zhuanlan.zhihu.com/p/654113232">文章</a>。</p></blockquote><h3 id="F-46-main-的返回类型是-int"><a href="#F-46-main-的返回类型是-int" class="headerlink" title="F.46 main() 的返回类型是 int"></a>F.46 main() 的返回类型是 int</h3><p>依照 C++ 标准，main 函数体有两种变体：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>第二个版本等效于 <code>int main(int argc, char* argv[]){ ... }</code>。</p><p>main 函数并不需要返回语句。如果控制流抵达 main 函数的末尾而没有碰到一条返回语句，其效果相当于 <code>return 0;</code>。return 0 意味着程序成功执行。</p><blockquote><p>这里最前面说的 <strong>依照 C++ 标准</strong>。 我们都知道 main 函数的形式远不止这些，但那些都是编译器的扩展，我们用 msvc 举几个例子。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">wmain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">wmain</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">wchar_t</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>参见 <a href="https://link.zhihu.com/?target=https%3A//learn.microsoft.com/zh-cn/cpp/cpp/main-function-command-line-args%3Fview%3Dmsvc-170">msvc 文档</a>。</p><h3 id="F-50-当函数不适用时（需要捕获局部变量，或者编写一个局部函数），请使用-Lambda-表达式"><a href="#F-50-当函数不适用时（需要捕获局部变量，或者编写一个局部函数），请使用-Lambda-表达式" class="headerlink" title="F.50 当函数不适用时（需要捕获局部变量，或者编写一个局部函数），请使用 Lambda 表达式"></a>F.50 当函数不适用时（需要捕获局部变量，或者编写一个局部函数），请使用 Lambda 表达式</h3><p>这条规则说明了 Lambda 表达式的使用场合。这立刻引出了问题：</p><ul><li>什么时候必须用 Lambda 表达式？</li><li>什么时候必须用普通函数？</li></ul><p>这里有两条明显的理由。</p><ul><li><strong>如果可调用实体必须捕获局部变量，或者它是在局部作用域内声明的，你就必须使用 Lambda 表达式</strong>。</li><li><strong>如果可调用实体需要支持重载，那么应使用普通函数</strong>。</li></ul><p>现在我想亮出我对 Lambda 表达式的关键论点，它们经常会被忽视。</p><p><strong>表达力</strong></p><p>”明确优于隐晦“这条来自 Python（PEP 20 —— 《Python 之阐》）的元规则也适用于 C++。它意味着代码应该明确地表达其意图（见规则”P.1：在代码中直接表达思想“）。 当然，这对 Lambda 表达式来说尤其正确。</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> myStrVec <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"523345"</span><span class="token punctuation">,</span><span class="token string">"4336893456"</span><span class="token punctuation">,</span><span class="token string">"7234"</span><span class="token punctuation">,</span>                                    <span class="token string">"564"</span><span class="token punctuation">,</span><span class="token string">"199"</span><span class="token punctuation">,</span><span class="token string">"433"</span><span class="token punctuation">,</span><span class="token string">"2435345"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span><span class="token function">sort</span><span class="token punctuation">(</span>myStrVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> myStrVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> f<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> f<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> myStrVec <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"523345"</span><span class="token punctuation">,</span><span class="token string">"4336893456"</span><span class="token punctuation">,</span><span class="token string">"7234"</span><span class="token punctuation">,</span>                                        <span class="token string">"564"</span><span class="token punctuation">,</span><span class="token string">"199"</span><span class="token punctuation">,</span><span class="token string">"433"</span><span class="token punctuation">,</span><span class="token string">"2435345"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">lessLength</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> f<span class="token punctuation">,</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> f<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>std<span class="token operator">::</span><span class="token function">sort</span><span class="token punctuation">(</span>myStrVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> myStrVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>lessLength<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Lambda 表达式和函数都为排序算法提供了相同的顺序谓词。如果你不相信他们，你就必须分析其实现。也许这并不可能，因为你只有函数的声明。有了 Lambda 表达式，你的同事无法欺骗你。代码就是真相。让我更挑衅的说：</p><ul><li><strong><em>你的代码的表达能力应该强到不需要文档\</em></strong>。</li></ul><blockquote><p><strong>表达能力与不要重复自己</strong><br>“用 Lambda 编写表达力丰富的代码”这条设计规则往往与另一条重要的设计规则相矛盾：不要重复自己（don’t repeat yourself, DRY）。DRY 意味着你不应该多次编写相同的代码。编写一个可重复使用的单元，如一个函数，并给它指定一个不言自明的名称，是对 DRY 的合适补救。最终，必须在具体的案例中决定是否把表达力看得比 DRY 更重要。</p></blockquote><h3 id="F-52-在局部使用（包括要传递给算法）的-Lambda-表达式中，优先通过引用来捕获"><a href="#F-52-在局部使用（包括要传递给算法）的-Lambda-表达式中，优先通过引用来捕获" class="headerlink" title="F.52 在局部使用（包括要传递给算法）的 Lambda 表达式中，优先通过引用来捕获"></a>F.52 在局部使用（包括要传递给算法）的 Lambda 表达式中，优先通过引用来捕获</h3><p>以及</p><h3 id="F-53-在非局部使用（包括要被返回、存储在堆上或要传给其他线程）的-Lambda-表达式中，避免通过引用来捕获"><a href="#F-53-在非局部使用（包括要被返回、存储在堆上或要传给其他线程）的-Lambda-表达式中，避免通过引用来捕获" class="headerlink" title="F.53 在非局部使用（包括要被返回、存储在堆上或要传给其他线程）的 Lambda 表达式中，避免通过引用来捕获"></a>F.53 在非局部使用（包括要被返回、存储在堆上或要传给其他线程）的 Lambda 表达式中，避免通过引用来捕获</h3><p>这两条规则高度关联，它们可以归结为：<strong>Lambda 表达式应该只对有效数据进行操作</strong>。</p><ul><li>当 Lambda 通过拷贝捕获数据时，根据定义，数据总是有效的。</li><li>当 Lambda 通过引用捕获数据时，数据的生存期必须超过 Lambda 的生存期。</li></ul><p>前面局部对象引用的例子就展示了 Lambda 引用无效数据时的各种问题。</p><p>有时问题还不那么容易发现。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>string str<span class="token punctuation">{</span><span class="token string">"C++11"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>thread thr<span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token operator">&amp;</span>str<span class="token punctuation">]</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    thr<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在新创建的线程 thr 中使用的 Lambda 表达式通过引用捕获了变量 str。之后，thr 从其创建者（即主线程）的生存期中分离出来。因此，不能保证创建的线程 thr 使用的是有效的字符串 str，因为 str 的生存期与主线程的生存期绑定了。</p><p>可以采用一个直截了断的方法来解决这个问题。通过拷贝捕获 str。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>string str<span class="token punctuation">{</span><span class="token string">"C++11"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>thread thr<span class="token punctuation">{</span><span class="token punctuation">[</span>str<span class="token punctuation">]</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    thr<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>问题解决了吗？没有！关键的问题是:</p><ul><li><strong>谁是 std::cout 的所有者？</strong></li></ul><p>std::cout 的生存期与进程的生存期绑定。这意味着，在屏幕上打印出“C++11”之前，std::cout 对象可能已经消失了。解决这个问题的方法是汇合（join）线程 thr。这种情况下，创建者会等待，直到被创建者完全任务，因此，通过引用捕获也就可以了。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>string str<span class="token punctuation">{</span><span class="token string">"C++11"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>thread thr<span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token operator">&amp;</span>str<span class="token punctuation">]</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    thr<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="F-51-在有选择的情况下，优先采用默认参数而非重载"><a href="#F-51-在有选择的情况下，优先采用默认参数而非重载" class="headerlink" title="F.51 在有选择的情况下，优先采用默认参数而非重载"></a>F.51 在有选择的情况下，优先采用默认参数而非重载</h3><p>如果你需要不同数量的参数来调用一个函数，尽可能优先采用默认参数而不是重载。这样你就遵循了 DRY（不要重复自己）原则。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">,</span> format f <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>若要使用重载实现相同的功能，则需要两个函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">,</span> format f<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="F-55-不要使用-va-arg-参数"><a href="#F-55-不要使用-va-arg-参数" class="headerlink" title="F.55 不要使用 va_arg 参数"></a>F.55 不要使用 va_arg 参数</h3><p>当你的函数需要接受任意数量的参数时，要使用变参模板而不是 va_arg 参数。</p><p>变参函数（variadic function）是像 std::printf 这样的函数，可以接受任意数量的参数。问题是，必须假设传递的类型总是正确的。当然，这种假设非常容易出错，其正确性依赖于程序员的素养。</p><blockquote><p>std::printf 不是类型安全的函数，很多东西理论上根本无法检测，但是因为用的太多了，大部分编译器都给它开洞检查类型之类的玩意了。</p></blockquote><p>为了理解变参函数的隐含危险，请看下面的小例子。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdarg></span></span><span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    va_list argPointer<span class="token punctuation">;</span>    <span class="token function">va_start</span><span class="token punctuation">(</span>argPointer<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>num<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>        sum <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>argPointer<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">va_end</span><span class="token punctuation">(</span>argPointer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sum(1, 5): "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sum(3, 1, 2, 3): "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sum(3, 1, 2, 3, 4): "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//（1）</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sum(3, 1, 2, 3.5): "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3.5</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//（2）</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>sum 是一个变参数函数。它的第一个参数是需要被求和的参数个数。以下是关于 va_arg 宏的背景信息，有助于理解该代码。</p><ul><li><strong>va_list:</strong> 保存下列宏的必要信息。</li><li><strong>va_start:</strong> 启用对变参函数参数的访问。</li><li><strong>va_arg:</strong> 访问下一个变参函数的参数。</li><li><strong>va_end:</strong> 结束对变参函数参数的访问。</li></ul><p>请阅读 <a href="https://link.zhihu.com/?target=http%3A//cppreference.com">http://cppreference.com</a> 中关于<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/variadic_arguments">变参数函数</a>的部分来获取进一步的信息。</p><p>代码行（1）和（2）中出了些状况。（1）中参数 num 的数量是错的；（2）中我提供了一个 double 而不是一个int。<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/nch8fjdf5">输出结果</a>显示了这两个问题。（1）中的最后一个元素丢失了，而 double 被解释为 int（2）。</p><pre class="line-numbers language-text"><code class="language-text">sum(1, 5): 5sum(3, 1, 2, 3): 6sum(3, 1, 2, 3, 4): 6sum(3, 1, 2, 3.5): 539767595<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意，最后一个输出结果并不一定，我们只是按照书上的结果写了。经过实测的话，msvc 和 mingw clang 都是 <strong>6</strong>，gcc 是 <strong>3075</strong>。</p></blockquote><p>这些问题可以通过 C++17 的折叠表达式轻松解决。跟 va_arg 相比，折叠表达式会自动推导出其参数的数量和类型。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">sum</span><span class="token punctuation">(</span>Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">+</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sum(5): "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sum(1, 2, 3): "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sum(1, 2, 3, 4): "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sum(1, 2, 3.5): "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3.5</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数 sum 可能看起来挺可怕，它需要至少一个参数，并使用 C++11 的变参模板。变参模板可以接受任意数量的参数。这些任意数量的参数由所谓的参数包持有，用省略号（…）表示。此外，在 C++17 中，可以用二元运算符直接对参数包进行归约。这一针对变参模板的增强被称为折叠表达式。在 sum 函数的例子中，应用了二元的 + 运算符（… + args）。想要了解 C++17 折叠表达式的更多信息可参阅 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/fold">https://zh.cppreference.com/w/cpp/language/fold</a> 了解更多细节。</p><p>程序的输出正如预期：</p><pre class="line-numbers language-text"><code class="language-text">sum(5): 5sum(1, 2, 3): 6sum(1, 2, 3, 4): 10sum(1, 2, 3.5): 6.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-6-相关规则"><a href="#4-6-相关规则" class="headerlink" title="4.6 相关规则"></a>4.6 相关规则</h3><p>关于 Lambda 表达式的另一条规则在第 8 章中——“SE.28”：使用 Lambda 表达式进行复杂的初始化（尤其是对 const 变量）。</p><p>我在本章中跳过了 C++20 特性 std::span。我会在第 7 章中提供关于 std::span 的基本信息。</p><hr><p><strong>本章精华</strong></p><p><strong>重要</strong></p><ul><li>一个函数应该执行一个操作，要简短，并有一个精心选择的名字。</li><li>要把可以在编译期运行的函数实现为 constexpr。</li><li>如果可能的话，将你的函数实现为纯函数。</li><li>区分一个函数的入、入/出和出参。对入参使用按值传递或按 const 引用传递，对入/出参使用按引用传递，对出参使用按值传递。</li><li>向函数传递参数涉及所有权语义的问题。按值传递使函数称为资源的独立所有者。按指针或引用传递意味着函数只是借用了该资源。std::unique_ptr 将所有权转移给函数，std::shared_ptr 则使函数称为共享的所有者。</li><li>当你的函数需要接受任意数量的参数时，要使用变参模板而不是 va_arg 参数。</li></ul><h2 id="类和类的层次结构"><a href="#类和类的层次结构" class="headerlink" title="类和类的层次结构"></a>类和类的层次结构</h2><p>类是一种用户定义类型，程序员可以为其指定表示方法、操作和接口。类的层次结构被用来组织相关的结构。</p><p>C++ Core Guidelines 中大约有100条关于用户定义类型的规则。</p><p>Guidelines 先给出了一些概要规则，然后深入讨论了下面的特殊规则：</p><ul><li>具体类型</li><li>构造函数、赋值和析构函数</li><li>类的层次结构</li><li>重载和运算符重载</li><li>联合体</li></ul><p>下面的 8 条概要规则为特殊规则提供了背景。</p><h3 id="5-1-概要规则"><a href="#5-1-概要规则" class="headerlink" title="5.1 概要规则"></a>5.1 概要规则</h3><p>概要规则相当简短，没有涉及太多细节。它们对类概括提供了有价值的深刻见解。</p><blockquote><p><strong>class（类）和struct（结构体）之间的语法差异</strong> 本节经常提到类和结构体之间的语义区别。首先。语法上的差异是什么？差异很小，但很重要： - 在结构体中，所有成员默认为 public（公开）；类为（private）私有。 - 继承情况也是如此。结构体默认继承权限为 public，类为 private。</p></blockquote><p><strong>除此之外，二者在语言语法层面完全一致</strong>。</p><h3 id="C-1-把相关的数据组织到结构（struct-或-class）中"><a href="#C-1-把相关的数据组织到结构（struct-或-class）中" class="headerlink" title="C.1 把相关的数据组织到结构（struct 或 class）中"></a>C.1 把相关的数据组织到结构（struct 或 class）中</h3><p>如何改进 draw 的接口？</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token keyword">int</span> fromX<span class="token punctuation">,</span> <span class="token keyword">int</span> fromY<span class="token punctuation">,</span> <span class="token keyword">int</span> toX<span class="token punctuation">,</span> <span class="token keyword">int</span> toY<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不明显的是，这些 int 代表了什么。因此，调用函数的时候参数顺序可能会出错。可以对比一下上面的 draw 和下面的新函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span>Point from<span class="token punctuation">,</span> Point to<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过将相关元素放在结构体中，函数签名变得可以自我描述，因此，比起之前的函数，新函数更不容易出错。</p><blockquote><p>类对象的构造函数也可以用来检测参数的合法性，不过这里的 Point 类型倒是没啥好检测的了。</p></blockquote><h3 id="C-2-当类具有不变式时使用-class；如果数据成员可以独立变化，则使用-struct"><a href="#C-2-当类具有不变式时使用-class；如果数据成员可以独立变化，则使用-struct" class="headerlink" title="C.2 当类具有不变式时使用 class；如果数据成员可以独立变化，则使用 struct"></a>C.2 当类具有不变式时使用 class；如果数据成员可以独立变化，则使用 struct</h3><blockquote><p>不变式（Invariant）是一个在程序执行过程中永远保持成立的条件。不变式在检测程序是否正确方面非常有用。例如编译器优化就用到了不变式。</p></blockquote><p>类的不变式是用于约束类的实例的不变式。成员函数必须使这个不变式保持成立。 不变式约束了类的实例的可能取值。</p><p>这是 C++ 中一个常见的问题：<em>什么时候该使用 class，什么时候该用 struct？</em></p><p>C++ Core Guidelines 给出了以下建议。<strong>如果类有不变式，就使用 class</strong>。</p><blockquote><p><strong>如果类有一个需要在程序执行过程中永远保持成立的条件，就使用 class</strong>。</p></blockquote><p>一个可能的类的不变式是，（y，m，d）可表示一个有效的日期。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Pair<span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//成员可以独立变化</span>    string name<span class="token punctuation">;</span>    <span class="token keyword">int</span> volume<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Date</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">//校验 {yy，mm，dd}是不是合法的日期并进行初始化</span>    <span class="token function">Date</span><span class="token punctuation">(</span><span class="token keyword">int</span> yy<span class="token punctuation">,</span> Month mm<span class="token punctuation">,</span> <span class="token keyword">char</span> dd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ...</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> y<span class="token punctuation">;</span>    Month m<span class="token punctuation">;</span>    <span class="token keyword">char</span> d<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//日</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类的不变式在构造函数中被初始化和检查。数据类型 Pair 没有不变式，因为名称（name）和体积（volume）的所有值都是有效的。Pair 是简单的数据持有者，不需要显式提供构造函数。</p><blockquote><p>值得一提的是，很多库并没有很好的遵守，我们举例 <a href="https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/qpoint.html">QPoint</a>，<a href="https://link.zhihu.com/?target=https%3A//codebrowser.dev/qt5/qtbase/src/corelib/tools/qpoint.h.html">源码</a>。</p></blockquote><p>QPoint 显然是没有不变式，它的成员（xp，yp）所有的值都是有效的，但它依旧使用的是 class。 以及，它没有将它的数据成员设置为 public，反而提供了愚蠢的 6 个成员函数进行访问：<code>rx，ry，x，y，setX，setY</code>。</p><h3 id="C-3-在类中体现出接口和实现之间的区别"><a href="#C-3-在类中体现出接口和实现之间的区别" class="headerlink" title="C.3 在类中体现出接口和实现之间的区别"></a>C.3 在类中体现出接口和实现之间的区别</h3><p>类的公开成员函数是类的接口，私有部分则是实现。</p><pre class="line-numbers language-cpp"><code class="language-cpp">类的公开成员函数是类的接口，私有部分则是实现。<span class="token keyword">class</span> <span class="token class-name">Date</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//校验 {yy，mm，dd}是不是合法的日期并进行初始化</span>    <span class="token function">Date</span><span class="token punctuation">(</span><span class="token keyword">int</span> yy<span class="token punctuation">,</span> Month mm<span class="token punctuation">,</span> <span class="token keyword">char</span> dd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">day</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">;</span>    Month <span class="token function">month</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ...</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">// ... 具体的内部表示</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从可维护性的角度看，可以修改 Date 类的实现，而毫不影响该类的使用者。</p><blockquote><p>就是说面向对象的<strong>封装</strong>，数据和操作数据的方法（即类的接口）捆绑在一起，并对外部隐藏对象的内部状态。这样可以确保类的接口有效性和不变性。</p></blockquote><h3 id="C-4-仅当函数需要直接访问类的内部表示时，才把它变成成员"><a href="#C-4-仅当函数需要直接访问类的内部表示时，才把它变成成员" class="headerlink" title="C.4 仅当函数需要直接访问类的内部表示时，才把它变成成员"></a>C.4 仅当函数需要直接访问类的内部表示时，才把它变成成员</h3><p>如果一个函数不需要访问类的内部结构，它就不应该是成员。这样的话，你会得到松耦合，而且类的内部结构的改变不会影响辅助函数。</p><blockquote><p>一个函数不修改类的私有数据成员，它就不该是成员</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Date</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ... 相对小的接口 ...</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//辅助函数</span>Date <span class="token function">next_weekday</span><span class="token punctuation">(</span>Date<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">==</span> <span class="token punctuation">(</span>Date<span class="token punctuation">,</span> Date<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运算符 <code>=</code>、<code>()</code>、<code>[]</code>、<code>-&gt;</code> 必须是类的成员。</p><blockquote><p>事实上这条规则没那么好遵守，有非常多的额外情况，英文原书和我们当前描写的都太少了。可以看<a href="https://link.zhihu.com/?target=https%3A//github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md%23c4-make-a-function-a-member-only-if-it-needs-direct-access-to-the-representation-of-a-class">英文文档</a>，或<a href="https://link.zhihu.com/?target=https%3A//github.com/lynnboy/CppCoreGuidelines-zh-CN/blob/master/CppCoreGuidelines-zh-CN.md%23c4-%E4%BB%85%E5%BD%93%E5%87%BD%E6%95%B0%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E7%B1%BB%E7%9A%84%E5%86%85%E9%83%A8%E8%A1%A8%E7%A4%BA%E6%97%B6%E6%89%8D%E8%AE%A9%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%85%B6%E6%88%90%E5%91%98">国人翻译</a>。</p></blockquote><h3 id="C-5-将辅助函数与它们支持的类放在同一个命名空间中"><a href="#C-5-将辅助函数与它们支持的类放在同一个命名空间中" class="headerlink" title="C.5 将辅助函数与它们支持的类放在同一个命名空间中"></a>C.5 将辅助函数与它们支持的类放在同一个命名空间中</h3><p>辅助函数应该在类的命名空间中，因为它是类的接口的一部分。与成员函数相反，辅助函数不需要直接访问类的内部表示。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">namespace</span> Chrono<span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 在这里放置跟时间有关的服务</span>    <span class="token keyword">class</span> <span class="token class-name">Date</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 辅助函数：</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">==</span> <span class="token punctuation">(</span>Date<span class="token punctuation">,</span> Date<span class="token punctuation">)</span><span class="token punctuation">;</span>    Date <span class="token function">next_weekday</span><span class="token punctuation">(</span>Date<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">if</span> <span class="token punctuation">(</span>date1 <span class="token operator">==</span> date2<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true">//（1）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于有<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/adl">实参依赖查找</a>（argument-dependent lookup，ADL），比较 date1 == date2 将额外查找 Chrono 命名空间中的相等运算符。ADL 对于重载的运算符尤其重要，如输出运算符&lt;&lt;。</p><h3 id="C-7-不要在一条语句里定义类或枚举的同时声明该类型的变量"><a href="#C-7-不要在一条语句里定义类或枚举的同时声明该类型的变量" class="headerlink" title="C.7 不要在一条语句里定义类或枚举的同时声明该类型的变量"></a>C.7 不要在一条语句里定义类或枚举的同时声明该类型的变量</h3><p>若在一条语句里定义类或枚举并同时声明其他类型的变量，会引起混淆，因此应该避免。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 不好</span><span class="token keyword">struct</span> Date <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*...*/</span> <span class="token punctuation">}</span> date <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*...*/</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 好</span><span class="token keyword">struct</span> Date<span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*...*/</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>Date date<span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*...*/</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="C-8-如果有任何非公开成员，就使用-class-而不是-struct"><a href="#C-8-如果有任何非公开成员，就使用-class-而不是-struct" class="headerlink" title="C.8 如果有任何非公开成员，就使用 class 而不是 struct"></a>C.8 如果有任何非公开成员，就使用 class 而不是 struct</h3><p>明确某事被隐藏/抽象。这是一个有用的约定。</p><blockquote><p>除此之外可能还有很多乱七八糟的理由，但总而言之，就是这样，<strong>约定</strong>。</p></blockquote><h3 id="C-9-尽量减少成员的暴露"><a href="#C-9-尽量减少成员的暴露" class="headerlink" title="C.9 尽量减少成员的暴露"></a>C.9 尽量减少成员的暴露</h3><p>数据隐藏和<strong>封装</strong>是面向对象类设计的基石之一：你将类中的成员封装起来，只允许通过公共成员函数进行访问。你的类可能有两种接口：一种是用于外部的 public 接口，一种是用于派生类的 protected 接口。其余成员都应该属于 private。</p><blockquote><p>封装。信息隐藏。最大限度地减少意外访问的机会。这简化了维护。 需要注意的是，也不要什么成员都给封装了，这样会走上 java 的邪路，<code>get</code>、<code>set</code> …</p></blockquote><h3 id="5-2-具体类型"><a href="#5-2-具体类型" class="headerlink" title="5.2 具体类型"></a>5.2 具体类型</h3><p>本节只有两条规则，但引入了具体类型和规范类型这两个术语。 根据 C++ Core Guidelines：</p><p><strong>具体类型是“最简单的一种类”</strong>。它常常被称作值类型，不属于某个类型层次结构的一部分 。</p><p><strong>规范类型是一种“行为类似于 int”的类型</strong>，因此，它必须支持拷贝和赋值、相等比较，以及可交换。更正式的说法是，一个规范类型 X 行为上像 int，支持下列操作。</p><ul><li>默认构造：X()</li><li>拷贝构造：X(const X&amp;)</li><li>拷贝赋值：operator = (const X&amp;)</li><li>移动构造：X(X&amp;&amp;)</li><li>移动赋值：operator = (X&amp;&amp;)</li><li>析构：~X()</li><li>交换操作：swap(X&amp;, X&amp;)</li><li>相等运算符：operator ==(const X&amp;, const X&amp;)</li></ul><h3 id="C-10-优先使用具体类型而不是类层次结构"><a href="#C-10-优先使用具体类型而不是类层次结构" class="headerlink" title="C.10 优先使用具体类型而不是类层次结构"></a>C.10 优先使用具体类型而不是类层次结构</h3><p>如果没有需要类层次结构的用例，就使用具体类型。具体的类型更容易实现，更小，且更快。不必担心继承、虚性、引用或指针，包括内存分配和释放。不会有虚派发，因此也没有运行期开销。</p><p>长话短说：应用 <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/KISS_principle">KISS</a> 原则（“keep it simple,stupid”原则，保持简单，让傻瓜都能理解）。你的类型行为像普通数值一样。</p><h3 id="C-11-让具体类型规范化"><a href="#C-11-让具体类型规范化" class="headerlink" title="C.11 让具体类型规范化"></a>C.11 让具体类型规范化</h3><p>规范类型（如 int）易于理解，它们本身就很直观。这意味着：</p><ul><li>如果你有一个具体类型，可以考虑将它升级为规范类型。</li></ul><p>内置类型（如 int 或 double）是规范类型，而用户定义类型（如 std::string）或容器（std::vector 或 std::unordered_map）也是如此。</p><p>C++20 支持 regular （规范）概念。</p><h3 id="5-3-构造函数、赋值运算符和析构函数"><a href="#5-3-构造函数、赋值运算符和析构函数" class="headerlink" title="5.3 构造函数、赋值运算符和析构函数"></a>5.3 构造函数、赋值运算符和析构函数</h3><p>这一节讨论构造函数、赋值运算符和析构函数，在本章范围内，此类规则的数量是目前为止最多的。它们控制着对象的生命周期：创建、拷贝、移动和销毁。简而言之，我们把它们称为“六大”。下面是这六个特殊的成员函数。</p><ul><li>默认构造函数：X()</li><li>拷贝构造函数：X(const X&amp;)</li><li>拷贝赋值运算符：operator = (const X&amp;)</li><li>移动构造：X(X&amp;&amp;)</li><li>移动赋值运算符：operator = (X&amp;&amp;)</li><li>析构函数：~X()</li></ul><p>编译器可以为这“六大”生成默认实现。本节从有关默认操作的规则开始；接着是有关构造函数、拷贝和移动操作以及析构函数的规则；最后是不属于前四类的其他默认操作的规则。</p><p>根据默认构造函数的声明，你可能有这样的印象：默认构造函数不需要参数。这是不对的。默认构造函数可以在没有参数的情况下被调用，但它可能每个参数都有默认值。</p><h3 id="预置操作"><a href="#预置操作" class="headerlink" title="预置操作"></a>预置操作</h3><p>默认情况下，如果需要，编译器可以生成“六大”。可以定义这六个特殊的成员函数，但也可明确用 = default（预置）来要求编译器提供它们，或者用 = delete（弃置）来删除它们。</p><h3 id="C-20-如果能避免定义默认操作，那么就这么做"><a href="#C-20-如果能避免定义默认操作，那么就这么做" class="headerlink" title="C.20 如果能避免定义默认操作，那么就这么做"></a>C.20 如果能避免定义默认操作，那么就这么做</h3><p>这一规则也被称为“零法则”。这意味着你可以通过使用有合适的拷贝/移动语义的类型，来避免自行编写构造函数、拷贝/移动构造函数、赋值运算符或析构函数。有合适的拷贝/移动语义的类型包括规范类型，如内置类型 bool 或 double，也包括标准模板库（STL）的容器，如 std::vector 或 std::string。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Named_map</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">// ... 没有声明任何默认操作 ...</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>string name<span class="token punctuation">;</span>    std<span class="token operator">::</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> rep<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Named_map mm<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 默认构造</span>Named_map nm2 <span class="token punctuation">{</span>nm<span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 拷贝构造</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认构造和拷贝构造之所以有效，是因为 std::string 和 std::map 已经定义了相应的操作。</p><ul><li><strong>编译器所自动生成的拷贝构造函数会调用当前类所有成员的拷贝构造函数</strong>。</li></ul><blockquote><p>特殊成员函数都是这样，不局限于拷贝构造，这个其实以前在 <strong><a href="https://zhuanlan.zhihu.com/p/662592729/第2章-理念.md">P.9</a></strong> 提起过。（另外强调一下，这些话全说的是类类型）</p></blockquote><h3 id="C-21-如果定义或-delete-了任何默认操作，就对所有默认操作进行定义或-delete"><a href="#C-21-如果定义或-delete-了任何默认操作，就对所有默认操作进行定义或-delete" class="headerlink" title="C.21 如果定义或 =delete 了任何默认操作，就对所有默认操作进行定义或 =delete"></a>C.21 如果定义或 =delete 了任何默认操作，就对所有默认操作进行定义或 =delete</h3><p>“六大”是紧密相关的。由于这种关系，你应该对所有特殊成员函数进行定义或 =delete。因此，这条规则被称为“六法则”。有时你会听到“五法则”，这是因为默认构造函数很特殊，有时会被排除在外</p><ul><li><em>当你定义*</em>任何构造函数*<em>时，默认构造函数就没有了。默认构造函数是可以在没有参数的情况下调用的构造函数</em>。</li><li><em>当你用 =default 或 =delete 定义或删除*</em>默认构造函数*<em>时，其他特殊成员函数都不受影响</em>。</li><li>当你用 =default 或 =delete 定义或删除<strong>析构函数</strong>、<strong>拷贝构造函数</strong>或<strong>拷贝赋值操作符</strong>时，编译器不会生成移动构造函数和移动赋值运算符。这意味着移动构造或移动赋值这样的移动操作会回退到拷贝构造或拷贝赋值。这种回退的自动操作在表格中以深色标出。</li><li>当用 =default 或 =delete 定义或删除<strong>移动构造函数</strong>或<strong>移动赋值运算符</strong>时，只能得到定义的 =default 或 =delete 的移动构造函数或移动赋值运算符。<strong>后果是，拷贝构造函数和拷贝赋值运算符被设置为 =delete[^2]</strong>。因此调用一个拷贝操作，如拷贝构造或拷贝赋值，将导致编译错误。</li></ul><p>当你不遵循这条规则时，你会得到非常不直观的对象。下面是 Guidelines 中的一个直观的例子。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstddef></span></span><span class="token keyword">class</span> <span class="token class-name">BitArray</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">BitArray</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t len<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">len_</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">data_</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">BitArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data_<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>size_t len_<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">*</span> data_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    BitArray <span class="token function">bitArray1</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    BitArray <span class="token function">bitArray2</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    bitArray2 <span class="token operator">=</span> bitArray1<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//（1）</span><span class="token punctuation">}</span>                               <span class="token comment" spellcheck="true">//（2）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为什么这个程序有未定义行为？例子中默认的拷贝赋值操作 bitArray2 = bitArray1（1）拷贝了 bigArray2 的所有成员。拷贝意味着，在目前情况下，被拷贝的是 data 指针，而不是其指向的数据。因此，bigArray1 和 bigArray2 的析构函数被调用（2），由于<strong>重复释放</strong>，我们得到了未定义行为。</p><p>这个例子中不直观的行为是，编译器生成的 BigArray 的拷贝赋值操作符对 BigArray 进行了浅拷贝，但是 BigArray 的显式实现的析构函数假设了数据的所有权。</p><p><a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/5qzoz6qx3">运行效果</a>：</p><pre class="line-numbers language-text"><code class="language-text">double free or corruption (!prev)Program terminated with signal: SIGSEGV<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这篇文章实际上是&lt;a href=&quot;https://zhuanlan.zhihu.com/p/662592729&quot;&gt;C++ Core Guid
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>git如何更新新的个人令牌Tokens</title>
    <link href="https://joytsing.github.io/posts/21341/"/>
    <id>https://joytsing.github.io/posts/21341/</id>
    <published>2023-10-09T08:45:38.000Z</published>
    <updated>2023-10-09T08:59:49.935Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2021年8月13日开始，GitHub在使用Git操作远程仓库时不再支持使用用户名密码形式进行身份验证，需使用个人访问令牌。<br>使用Git操作GitHub仓库时使用用户名密码进行身份验证会报错：</p><p><img src="/posts/21341/9b5b233bb4d94a83aa1a4465e5755bec.png" alt></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>使用token登录的方式，就是把你的密码替换成token即可</p><h3 id="1、创建自己的token"><a href="#1、创建自己的token" class="headerlink" title="1、创建自己的token"></a>1、创建自己的token</h3><p><strong>1.1、登录GitHub，在GitHub右上角点击个人资料头像，点击settings</strong><br><img src="/posts/21341/90c2a62d20bc4065a161b7f5a94e60f9.png" alt><br><strong>1.2、新打开的窗口，左边栏点击选择 Developer settings（开发人员设置）</strong><br><img src="/posts/21341/f4e699246d294cad8a5f6cd300295e09.png" alt><br><strong>1.3、点击Personal access tokens （个人访问令牌）</strong><br>点击Personal access tokens ，选择Tokens(classic)即可，然后点击【Generate new token】（设置新的访问令牌）<br>注意：点击【Generate new token】此处还是有两个选项，选择【Tokens(classic)】<br><img src="/posts/21341/cf8b484f25654d4897453669eec60593.png" alt><br><strong>1.4、添加令牌描述信息（Note），过期时间（Expiration）、作用域（Select scopes）等</strong><br><strong>注意</strong>::作用域，一般勾选<code>repo</code>和<code>delet_repo</code>即可，其他权限，看个人需求。<br>repo：要使用token从命令行访问仓库<br>delete_repo：要使用token从命令行删除仓库<br><img src="/posts/21341/aec0732ccbc94e469d1c24aff707c3f4.png" alt><br><strong>repo</strong><br><img src="/posts/21341/ebcce4033edb4ae98b31c936e4a9f18a.png" alt><br><strong>delete_repo</strong><br><img src="/posts/21341/c60e1d166cfc4ec3ab63de9165af4f97.png" alt><br><strong>1.5、点击【generate token】生成令牌。</strong><br><img src="/posts/21341/c2b8f96c42ce4eac9da3bb7c1ab1371b.png" alt><br><strong>1.6、生成令牌，需要复制并保存好令牌</strong></p><blockquote><p>注意：Github为了安全，<code>关闭页面后将不能再次看到生成的令牌</code>，一定要记得保存令牌。</p></blockquote><p><img src="/posts/21341/935409e69d1b47b9a1d388171980f8b5.png" alt></p><h3 id="2、使用token-classic"><a href="#2、使用token-classic" class="headerlink" title="2、使用token(classic)"></a>2、使用token(classic)</h3><p>使用Git操作GitHub仓库时使用token进行身份验证<br>使用令牌 正常连接github会给你调起登录框 密码框中不在输入密码输入令牌即可</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> add <span class="token keyword">.</span><span class="token function">git</span> commit -m <span class="token string">" "</span><span class="token function">git</span> push orgin master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/posts/21341/dbe5f0f624044205a9b9beca6e34eb0b.png" alt><br><img src="/posts/21341/eefc7a46048b4f529f0aea7ba4c28628.png" alt></p><h3 id="3、使用token-方法二"><a href="#3、使用token-方法二" class="headerlink" title="3、使用token(方法二)"></a>3、使用token(方法二)</h3><p><strong>修改现有项目的url</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> remote set-url origin  https://<span class="token operator">&lt;</span>your_token<span class="token operator">></span>@github.com/<span class="token operator">&lt;</span>USERNAME<span class="token operator">></span>/<span class="token operator">&lt;</span>REPO<span class="token operator">></span>.git将<span class="token operator">&lt;</span>your_token<span class="token operator">></span>换成你自己得到的令牌。<span class="token operator">&lt;</span>USERNAME<span class="token operator">></span>是你自己github的用户名，<span class="token operator">&lt;</span>REPO<span class="token operator">></span>是你的项目名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>比如：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> remote set-url origin  https://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@github.com/nlp-greyfoss/typora_notes.git/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其实上面的报错中就有提示，不需要重新去找：</p><p><strong>fatal: unable to access ‘<a href="https://github.com//.git’；">https://github.com//.git’；</a></strong></p><pre><code>//正确格式：https://你的令牌@github.com/&lt;USERNAME&gt;/&lt;REPO&gt;.git</code></pre><p>然后再执行git pull，世界又恢复原样了。</p><p><strong>从Github下载到本地</strong><br>对于全新版本，克隆的时候也在github.com前面加个令牌就好了。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> clone https://<span class="token operator">&lt;</span>TOKEN<span class="token operator">></span>@github.com/<span class="token operator">&lt;</span>user_name<span class="token operator">></span>/<span class="token operator">&lt;</span>repo_name<span class="token operator">></span>.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="更新Tokens"><a href="#更新Tokens" class="headerlink" title="更新Tokens"></a>更新Tokens</h2><p>因为token的有效期一般就三个月，如果过期了的话需要重新生成，具体操作的话，需要先去github，实际上就是换了个新的token:</p><blockquote><p>生成token：<br>settings -&gt; developer settings -&gt; personal access tokens -&gt; generate new token</p></blockquote><p><strong>注意！:　务必保存一下token的值</strong></p><p>下面是在git上需要替换token的方法。</p><ol><li>git remote -v 查看remote分支</li></ol><pre class="line-numbers language-shell"><code class="language-shell">[wqj@VM-0-15-centos Linux]$ git remote -vorigin    https://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@github.com/wuqiongjin/Linux.git/ (fetch)origin    https://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@github.com/wuqiongjin/Linux.git/ (push)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>中间的<code>ghp_.....</code>到@之前，是过期的token。</p><ol start="2"><li>我们需要删除这个token</li></ol><pre class="line-numbers language-shell"><code class="language-shell">git remote rm origin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>添加新的token，也就是方法二的</li></ol><pre class="line-numbers language-shell"><code class="language-shell">git remote add origin https://新的token@github.com/账号名称/仓库名字.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样就大功告成了! 下次push的时候需要使用<code>git push --set-upstream origin main</code>，如果还有报错类似下面这种：</p><pre class="line-numbers language-shell"><code class="language-shell">fatal: unable to access 'https://github.com********/': OpenSSL SSL_read: Connection was aborted, errno 10053<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>需要再执行</p><pre class="line-numbers language-shell"><code class="language-shell">git config --global http.sslVerify "false"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/weixin_44341110/article/details/120510816">Git使用个人访问令牌提交代码到仓库</a><br><a href="https://blog.csdn.net/wxbug/article/details/126808354">使用git上传代码遇到关于remote: Support for password authentication was removed on August 13, 2021.的问题</a><br><a href="https://blog.csdn.net/u014090429/article/details/126509415">github token个人令牌</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;2021年8月13日开始，GitHub在使用Git操作远程仓库时不再支持使用用户名密码形式进行身份验证，需使用个人访问令牌。&lt;br&gt;使用Gi
      
    
    </summary>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>LaTeX学习资源</title>
    <link href="https://joytsing.github.io/posts/25965/"/>
    <id>https://joytsing.github.io/posts/25965/</id>
    <published>2023-09-26T07:39:08.000Z</published>
    <updated>2023-09-26T07:41:07.364Z</updated>
    
    <content type="html"><![CDATA[<h2 id="入门必读书"><a href="#入门必读书" class="headerlink" title="入门必读书"></a>入门必读书</h2><h3 id="中文入门资料"><a href="#中文入门资料" class="headerlink" title="中文入门资料"></a>中文入门资料</h3><ul><li><p>一份不太简短的 LaTeX2ε 介绍【中文资料】（<a href="http://mirrors.ctan.org/info/lshort/chinese/lshort-zh-cn.pdf">lshort中文版</a>）</p></li><li><p>LaTeX Notes 雷太赫排版系统简介, 包太雷, 2019【中文资料】 （<a href="http://static.latexstudio.net/article/2019/0504/lnotes-master.zip">LaTeX 笔记 v2.56 (PDF 含源码 )</a>）</p></li><li><p>简单粗暴 LaTeX（点击这里下载：<a href="http://www.latexstudio.net/archives/10541.html">http://www.latexstudio.net/archives/10541.html</a>）</p></li><li><p>《LaTeX 入门》 刘海洋, 2013年, 电子工业出版社【中文纸质书籍】<a href="http://www.broadview.com.cn/book/1461">博文视点</a>，适合入门，但要跳着看。</p></li><li><p>LaTeX2e 完全学习手册 (第二版), 胡伟编著, 清华大学出版社, 2013.【中文纸质书籍】 <a href="http://www.tup.tsinghua.edu.cn/booksCenter/book_04015501.html">清华介绍</a>，适合查阅，可以翻着看。</p></li><li><p><a href="http://www.tup.tsinghua.edu.cn/booksCenter/book_07231501.html">LaTeX2e 文类和宏包学习手册</a>，编写 LaTeX2e 宏的用户可翻阅，一部解说 LaTeX 文类和宏包文件编写方法，将 LaTeX 命令集中注释的工具书。</p></li></ul><h3 id="英文入门资料"><a href="#英文入门资料" class="headerlink" title="英文入门资料"></a>英文入门资料</h3><ul><li><p>LaTeX for Complete Novices【英文资料】（<a href="http://www.dickimaw-books.com/latex/novices/novices-report.pdf">pdf</a>, <a href="http://www.dickimaw-books.com/latex/novices/novices-1_4.zip">源代码</a>, <a href="http://www.dickimaw-books.com/latex/novices/">http://www.dickimaw-books.com/latex/novices/</a>）</p></li><li><p>The LaTeX Companion (2nd), M. Goosens 等, 2004. 【英文纸质书籍】</p></li></ul><h2 id="插图使用"><a href="#插图使用" class="headerlink" title="插图使用"></a>插图使用</h2><ul><li>《LaTeX2e 插图指南》中译本第三版，点击<a href="http://www.latexstudio.net/archives/10738">这里</a>下载。</li></ul><h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><ul><li><p><a href="http://www.latexstudio.net/wp-content/uploads/2013/10/Higher-Mathematics-ch8.pdf">Higher-Mathematics-ch8.pdf</a>，The LaTeX Companion (2nd)第八章的内容。简短实用！</p></li><li><p><a href="http://www.latexstudio.net/archives/7395">More Math Into LaTeX</a> (5th), G. Gratzer, 2016.</p></li><li><p><a href="http://www.biwako.shiga-u.ac.jp/sensei/kumazawa/texindex3.html#formula">较全面的 LaTeX 各种数学字体、公式展示和源码</a></p></li></ul><h2 id="符号输入"><a href="#符号输入" class="headerlink" title="符号输入"></a>符号输入</h2><ul><li><p><a href="http://mirrors.ctan.org/info/symbols/comprehensive/symbols-a4.pdf">The Comprehensive LaTeX Symbol List</a>，LaTeX 符号大全，可在命令行中输入：texdoc  symbols-a4</p></li><li><p>手写识别 LaTeX 符号网站，点击<a href="http://detexify.kirelabs.org/classify.html">这里</a></p></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><p><a href="http://www.cs.stir.ac.uk/~kjt/software/latex/showbst.html">http://www.cs.stir.ac.uk/~kjt/software/latex/showbst.html</a> 各种bst类型样例，可以到这里查找。</p></li><li><p>黄正华简易学习 BiBTeX  <a href="http://aff.whu.edu.cn/huangzh/bibTeX%E7%94%9F%E6%88%90%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE.pdf">如何用 BibTeX 生成参考文献</a></p></li></ul><h2 id="PGF-绘图资源"><a href="#PGF-绘图资源" class="headerlink" title="PGF 绘图资源"></a>PGF 绘图资源</h2><p>简易入门中文资料  </p><ul><li><p><a href="http://www.latexstudio.net/archives/1398.html">PGF/TikZ 绘图学习笔记</a> </p></li><li><p><a href="http://www.latexstudio.net/archives/51577.html">[LaTeX 绘图指南 - 001] TikZ 的简介、资源以及学习方法</a></p></li><li><p><a href="http://www.latexstudio.net/archives/11825.html">TiKZ 学习笔记</a></p></li></ul><p>官网学习资料-英文：<a href="http://www.texdoc.net/texmf-dist/doc/generic/pgf/pgfmanual.pdf">pgfmanual.pdf</a> </p><h2 id="演示文稿"><a href="#演示文稿" class="headerlink" title="演示文稿"></a><a href="http://aff.whu.edu.cn/huangzh/bibTeX%E7%94%9F%E6%88%90%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE.pdf">演示文稿</a></h2><ul><li><p>本站整理的 beamer 主题：<a href="http://www.latexstudio.net/archives/category/tex-slides/beamer-theme-template">beamer-theme-template</a>  </p></li><li><p>beamer 主题样式墙：<a href="https://hartwork.org/beamer-theme-matrix">https://hartwork.org/beamer-theme-matrix</a> </p></li><li><p>模板合集（带汉化）：<a href="https://github.com/XiangyunHuang/awesome-beamers">https://github.com/XiangyunHuang/awesome-beamers</a>   </p></li></ul><h2 id="样例模板库"><a href="#样例模板库" class="headerlink" title="样例模板库"></a>样例模板库</h2><ul><li><p><a href="https://github.com/MartinThoma/LaTeX-examples/">MartinThoma’s LaTeX example</a> - GitHub 的大量好用的 LaTeX 例子文档.</p></li><li><p><a href="https://tex.stackexchange.com/questions/1319/showcase-of-beautiful-typography-done-in-tex-friends">showcase-of-beautiful-typography-done-in-tex-friends</a> 超级棒的排版样例.</p></li><li><p><a href="http://www.latextemplates.com/">http://www.latextemplates.com</a> – 各种模板 </p></li><li><p><a href="https://github.com/latexstudio/LaTeXPackages-CN">TeX 常用宏包中文翻译库</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;入门必读书&quot;&gt;&lt;a href=&quot;#入门必读书&quot; class=&quot;headerlink&quot; title=&quot;入门必读书&quot;&gt;&lt;/a&gt;入门必读书&lt;/h2&gt;&lt;h3 id=&quot;中文入门资料&quot;&gt;&lt;a href=&quot;#中文入门资料&quot; class=&quot;headerlink&quot; title=&quot;中
      
    
    </summary>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="LaTeX" scheme="https://JoyTsing.github.io/tags/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title>STL容器速查</title>
    <link href="https://joytsing.github.io/posts/37537/"/>
    <id>https://joytsing.github.io/posts/37537/</id>
    <published>2023-09-26T07:34:14.000Z</published>
    <updated>2023-12-14T07:43:49.322Z</updated>
    
    <content type="html"><![CDATA[<h1 id="容器（containers）"><a href="#容器（containers）" class="headerlink" title="容器（containers）"></a>容器（containers）</h1><h2 id="array"><a href="#array" class="headerlink" title="array"></a><a href="https://github.com/huihut/interview/tree/master/STL#array"></a>array</h2><p>array 是固定大小的顺序容器，它们保存了一个以严格的线性顺序排列的特定数量的元素。</p><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>begin</td><td>返回指向数组容器中第一个元素的迭代器</td></tr><tr><td>end</td><td>返回指向数组容器中最后一个元素之后的理论元素的迭代器</td></tr><tr><td>rbegin</td><td>返回指向数组容器中最后一个元素的反向迭代器</td></tr><tr><td>rend</td><td>返回一个反向迭代器，指向数组中第一个元素之前的理论元素</td></tr><tr><td>cbegin</td><td>返回指向数组容器中第一个元素的常量迭代器（const_iterator）</td></tr><tr><td>cend</td><td>返回指向数组容器中最后一个元素之后的理论元素的常量迭代器（const_iterator）</td></tr><tr><td>crbegin</td><td>返回指向数组容器中最后一个元素的常量反向迭代器（const_reverse_iterator）</td></tr><tr><td>crend</td><td>返回指向数组中第一个元素之前的理论元素的常量反向迭代器（const_reverse_iterator）</td></tr><tr><td>size</td><td>返回数组容器中元素的数量</td></tr><tr><td>max_size</td><td>返回数组容器可容纳的最大元素数</td></tr><tr><td>empty</td><td>返回一个布尔值，指示数组容器是否为空</td></tr><tr><td>operator[]</td><td>返回容器中第 n（参数）个位置的元素的引用</td></tr><tr><td>at</td><td>返回容器中第 n（参数）个位置的元素的引用</td></tr><tr><td>front</td><td>返回对容器中第一个元素的引用</td></tr><tr><td>back</td><td>返回对容器中最后一个元素的引用</td></tr><tr><td>data</td><td>返回指向容器中第一个元素的指针</td></tr><tr><td>fill</td><td>用 val（参数）填充数组所有元素</td></tr><tr><td>swap</td><td>通过 x（参数）的内容交换数组的内容</td></tr><tr><td>get（array）</td><td>形如 <code>std::get&lt;0&gt;(myarray)</code>；传入一个数组容器，返回指定位置元素的引用</td></tr><tr><td>relational operators (array)</td><td>形如 <code>arrayA &gt; arrayB</code>；依此比较数组每个元素的大小关系</td></tr></tbody></table><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a><a href="https://github.com/huihut/interview/tree/master/STL#vector"></a>vector</h2><p>vector 是表示可以改变大小的数组的序列容器。</p><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>vector</td><td>构造函数</td></tr><tr><td>~vector</td><td>析构函数，销毁容器对象</td></tr><tr><td>operator=</td><td>将新内容分配给容器，替换其当前内容，并相应地修改其大小</td></tr><tr><td>begin</td><td>返回指向容器中第一个元素的迭代器</td></tr><tr><td>end</td><td>返回指向容器中最后一个元素之后的理论元素的迭代器</td></tr><tr><td>rbegin</td><td>返回指向容器中最后一个元素的反向迭代器</td></tr><tr><td>rend</td><td>返回一个反向迭代器，指向中第一个元素之前的理论元素</td></tr><tr><td>cbegin</td><td>返回指向容器中第一个元素的常量迭代器（const_iterator）</td></tr><tr><td>cend</td><td>返回指向容器中最后一个元素之后的理论元素的常量迭代器（const_iterator）</td></tr><tr><td>crbegin</td><td>返回指向容器中最后一个元素的常量反向迭代器（const_reverse_iterator）</td></tr><tr><td>crend</td><td>返回指向容器中第一个元素之前的理论元素的常量反向迭代器（const_reverse_iterator）</td></tr><tr><td>size</td><td>返回容器中元素的数量</td></tr><tr><td>max_size</td><td>返回容器可容纳的最大元素数</td></tr><tr><td>resize</td><td>调整容器的大小，使其包含 n（参数）个元素</td></tr><tr><td>capacity</td><td>返回当前为 vector 分配的存储空间（容量）的大小</td></tr><tr><td>empty</td><td>返回 vector 是否为空</td></tr><tr><td>reserve</td><td>请求 vector 容量至少足以包含 n（参数）个元素</td></tr><tr><td>shrink_to_fit</td><td>要求容器减小其 capacity（容量）以适应其 size（元素数量）</td></tr><tr><td>operator[]</td><td>返回容器中第 n（参数）个位置的元素的引用</td></tr><tr><td>at</td><td>返回容器中第 n（参数）个位置的元素的引用</td></tr><tr><td>front</td><td>返回对容器中第一个元素的引用</td></tr><tr><td>back</td><td>返回对容器中最后一个元素的引用</td></tr><tr><td>data</td><td>返回指向容器中第一个元素的指针</td></tr><tr><td>assign</td><td>将新内容分配给 vector，替换其当前内容，并相应地修改其 size</td></tr><tr><td>push_back</td><td>在容器的最后一个元素之后添加一个新元素</td></tr><tr><td>pop_back</td><td>删除容器中的最后一个元素，有效地将容器 size 减少一个</td></tr><tr><td>insert</td><td>通过在指定位置的元素之前插入新元素来扩展该容器，通过插入元素的数量有效地增加容器大小</td></tr><tr><td>erase</td><td>从 vector 中删除单个元素（<code>position</code>）或一系列元素（<code>[first，last)</code>），这有效地减少了被去除的元素的数量，从而破坏了容器的大小</td></tr><tr><td>swap</td><td>通过 x（参数）的内容交换容器的内容，x 是另一个类型相同、size 可能不同的 vector 对象</td></tr><tr><td>clear</td><td>从 vector 中删除所有的元素（被销毁），留下 size 为 0 的容器</td></tr><tr><td>emplace</td><td>通过在 position（参数）位置处插入新元素 args（参数）来扩展容器</td></tr><tr><td>emplace_back</td><td>在 vector 的末尾插入一个新的元素，紧跟在当前的最后一个元素之后</td></tr><tr><td>get_allocator</td><td>返回与vector关联的构造器对象的副本</td></tr><tr><td>swap(vector)</td><td>容器 x（参数）的内容与容器 y（参数）的内容交换。两个容器对象都必须是相同的类型（相同的模板参数），尽管大小可能不同</td></tr><tr><td>relational operators (vector)</td><td>形如 <code>vectorA &gt; vectorB</code>；依此比较每个元素的大小关系</td></tr></tbody></table><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a><a href="https://github.com/huihut/interview/tree/master/STL#deque"></a>deque</h2><p>deque（[‘dek]）（双端队列）是double-ended queue 的一个不规则缩写。deque是具有动态大小的序列容器，可以在两端（前端或后端）扩展或收缩。</p><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>deque</td><td>构造函数</td></tr><tr><td>push_back</td><td>在当前的最后一个元素之后 ，在 deque 容器的末尾添加一个新元素</td></tr><tr><td>push_front</td><td>在 deque 容器的开始位置插入一个新的元素，位于当前的第一个元素之前</td></tr><tr><td>pop_back</td><td>删除 deque 容器中的最后一个元素，有效地将容器大小减少一个</td></tr><tr><td>pop_front</td><td>删除 deque 容器中的第一个元素，有效地减小其大小</td></tr><tr><td>emplace_front</td><td>在 deque 的开头插入一个新的元素，就在其当前的第一个元素之前</td></tr><tr><td>emplace_back</td><td>在 deque 的末尾插入一个新的元素，紧跟在当前的最后一个元素之后</td></tr></tbody></table><h2 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a><a href="https://github.com/huihut/interview/tree/master/STL#forward_list"></a>forward_list</h2><p>forward_list（单向链表）是序列容器，允许在序列中的任何地方进行恒定的时间插入和擦除操作。</p><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>forward_list</td><td>返回指向容器中第一个元素之前的位置的迭代器</td></tr><tr><td>cbefore_begin</td><td>返回指向容器中第一个元素之前的位置的 const_iterator</td></tr></tbody></table><h2 id="list"><a href="#list" class="headerlink" title="list"></a><a href="https://github.com/huihut/interview/tree/master/STL#list"></a>list</h2><p>list，双向链表，是序列容器，允许在序列中的任何地方进行常数时间插入和擦除操作，并在两个方向上进行迭代。</p><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a><a href="https://github.com/huihut/interview/tree/master/STL#stack"></a>stack</h2><p>stack 是一种容器适配器，用于在LIFO（后进先出）的操作，其中元素仅从容器的一端插入和提取。</p><h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a><a href="https://github.com/huihut/interview/tree/master/STL#queue"></a>queue</h2><p>queue 是一种容器适配器，用于在FIFO（先入先出）的操作，其中元素插入到容器的一端并从另一端提取。</p><h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a><a href="https://github.com/huihut/interview/tree/master/STL#priority_queue"></a>priority_queue</h2><h2 id="set"><a href="#set" class="headerlink" title="set"></a><a href="https://github.com/huihut/interview/tree/master/STL#set"></a>set</h2><p>set 是按照特定顺序存储唯一元素的容器。</p><h2 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a><a href="https://github.com/huihut/interview/tree/master/STL#multiset"></a>multiset</h2><h2 id="map"><a href="#map" class="headerlink" title="map"></a><a href="https://github.com/huihut/interview/tree/master/STL#map"></a>map</h2><p>map 是关联容器，按照特定顺序存储由 key value (键值) 和 mapped value (映射值) 组合形成的元素。</p><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>map</td><td>构造函数</td></tr><tr><td>begin</td><td>返回引用容器中第一个元素的迭代器</td></tr><tr><td>key_comp</td><td>返回容器用于比较键的比较对象的副本</td></tr><tr><td>value_comp</td><td>返回可用于比较两个元素的比较对象，以获取第一个元素的键是否在第二个元素之前</td></tr><tr><td>find</td><td>在容器中搜索具有等于 k（参数）的键的元素，如果找到则返回一个迭代器，否则返回 map::end 的迭代器</td></tr><tr><td>count</td><td>在容器中搜索具有等于 k（参数）的键的元素，并返回匹配的数量</td></tr><tr><td>lower_bound</td><td>返回一个非递减序列 <code>[first, last)</code>（参数）中的第一个大于等于值 val（参数）的位置的迭代器</td></tr><tr><td>upper_bound</td><td>返回一个非递减序列 <code>[first, last)</code>（参数）中第一个大于 val（参数）的位置的迭代器</td></tr><tr><td>equal_range</td><td>获取相同元素的范围，返回包含容器中所有具有与 k（参数）等价的键的元素的范围边界（<code>pair&lt; map&lt;char,int&gt;::iterator, map&lt;char,int&gt;::iterator &gt;</code>）</td></tr></tbody></table><h2 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a><a href="https://github.com/huihut/interview/tree/master/STL#multimap"></a>multimap</h2><h2 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a><a href="https://github.com/huihut/interview/tree/master/STL#unordered_set"></a>unordered_set</h2><h2 id="unordered-multiset"><a href="#unordered-multiset" class="headerlink" title="unordered_multiset"></a><a href="https://github.com/huihut/interview/tree/master/STL#unordered_multiset"></a>unordered_multiset</h2><h2 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a><a href="https://github.com/huihut/interview/tree/master/STL#unordered_map"></a>unordered_map</h2><h2 id="unordered-multimap"><a href="#unordered-multimap" class="headerlink" title="unordered_multimap"></a><a href="https://github.com/huihut/interview/tree/master/STL#unordered_multimap"></a>unordered_multimap</h2><h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a><a href="https://github.com/huihut/interview/tree/master/STL#tuple"></a>tuple</h2><p>元组是一个能够容纳元素集合的对象。每个元素可以是不同的类型。</p><h2 id="pair"><a href="#pair" class="headerlink" title="pair"></a><a href="https://github.com/huihut/interview/tree/master/STL#pair"></a>pair</h2><p>这个类把一对值（values）结合在一起，这些值可能是不同的类型（T1 和 T2）。每个值可以被公有的成员变量first、second访问。</p><h1 id="算法（algorithms）"><a href="#算法（algorithms）" class="headerlink" title="算法（algorithms）"></a><a href="https://github.com/huihut/interview/tree/master/STL#%E7%AE%97%E6%B3%95algorithms"></a>算法（algorithms）</h1><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 简单查找算法，要求输入迭代器（input iterator）</span><span class="token function">find</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个迭代器，指向输入序列中第一个等于 val 的元素，未找到返回 end</span><span class="token function">find_if</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> unaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个迭代器，指向第一个满足 unaryPred 的元素，未找到返回 end</span><span class="token function">find_if_not</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> unaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个迭代器，指向第一个令 unaryPred 为 false 的元素，未找到返回 end</span><span class="token function">count</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个计数器，指出 val 出现了多少次</span><span class="token function">count_if</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> unaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 统计有多少个元素满足 unaryPred</span><span class="token function">all_of</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> unaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个 bool 值，判断是否所有元素都满足 unaryPred</span><span class="token function">any_of</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> unaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个 bool 值，判断是否任意（存在）一个元素满足 unaryPred</span><span class="token function">none_of</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> unaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个 bool 值，判断是否所有元素都不满足 unaryPred</span><span class="token comment" spellcheck="true">// 查找重复值的算法，传入向前迭代器（forward iterator）</span><span class="token function">adjacent_find</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回指向第一对相邻重复元素的迭代器，无相邻元素则返回 end</span><span class="token function">adjacent_find</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> binaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回指向第一对相邻重复元素的迭代器，无相邻元素则返回 end</span><span class="token function">search_n</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> count<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个迭代器，从此位置开始有 count 个相等元素，不存在则返回 end</span><span class="token function">search_n</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> count<span class="token punctuation">,</span> val<span class="token punctuation">,</span> binaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个迭代器，从此位置开始有 count 个相等元素，不存在则返回 end</span><span class="token comment" spellcheck="true">// 查找子序列算法，除 find_first_of（前两个输入迭代器，后两个前向迭代器） 外，都要求两个前向迭代器</span><span class="token function">search</span><span class="token punctuation">(</span>beg1<span class="token punctuation">,</span> end1<span class="token punctuation">,</span> beg2<span class="token punctuation">,</span> end2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回第二个输入范围（子序列）在爹一个输入范围中第一次出现的位置，未找到则返回 end1</span><span class="token function">search</span><span class="token punctuation">(</span>beg1<span class="token punctuation">,</span> end1<span class="token punctuation">,</span> beg2<span class="token punctuation">,</span> end2<span class="token punctuation">,</span> binaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回第二个输入范围（子序列）在爹一个输入范围中第一次出现的位置，未找到则返回 end1</span><span class="token function">find_first_of</span><span class="token punctuation">(</span>beg1<span class="token punctuation">,</span> end1<span class="token punctuation">,</span> beg2<span class="token punctuation">,</span> end2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个迭代器，指向第二个输入范围中任意元素在第一个范围中首次出现的位置，未找到则返回end1</span><span class="token function">find_first_of</span><span class="token punctuation">(</span>beg1<span class="token punctuation">,</span> end1<span class="token punctuation">,</span> beg2<span class="token punctuation">,</span> end2<span class="token punctuation">,</span> binaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个迭代器，指向第二个输入范围中任意元素在第一个范围中首次出现的位置，未找到则返回end1</span><span class="token function">find_end</span><span class="token punctuation">(</span>beg1<span class="token punctuation">,</span> end1<span class="token punctuation">,</span> beg2<span class="token punctuation">,</span> end2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 类似 search，但返回的最后一次出现的位置。如果第二个输入范围为空，或者在第一个输入范围为空，或者在第一个输入范围中未找到它，则返回 end1</span><span class="token function">find_end</span><span class="token punctuation">(</span>beg1<span class="token punctuation">,</span> end1<span class="token punctuation">,</span> beg2<span class="token punctuation">,</span> end2<span class="token punctuation">,</span> binaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 类似 search，但返回的最后一次出现的位置。如果第二个输入范围为空，或者在第一个输入范围为空，或者在第一个输入范围中未找到它，则返回 end1</span><span class="token comment" spellcheck="true">// 其他只读算法，传入输入迭代器</span><span class="token function">for_each</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> unaryOp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 对输入序列中的每个元素应用可调用对象 unaryOp，unaryOp 的返回值被忽略</span><span class="token function">mismatch</span><span class="token punctuation">(</span>beg1<span class="token punctuation">,</span> end1<span class="token punctuation">,</span> beg2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 比较两个序列中的元素。返回一个迭代器的 pair，表示两个序列中第一个不匹配的元素</span><span class="token function">mismatch</span><span class="token punctuation">(</span>beg1<span class="token punctuation">,</span> end1<span class="token punctuation">,</span> beg2<span class="token punctuation">,</span> binaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 比较两个序列中的元素。返回一个迭代器的 pair，表示两个序列中第一个不匹配的元素</span><span class="token function">equal</span><span class="token punctuation">(</span>beg1<span class="token punctuation">,</span> end1<span class="token punctuation">,</span> beg2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 比较每个元素，确定两个序列是否相等。</span><span class="token function">equal</span><span class="token punctuation">(</span>beg1<span class="token punctuation">,</span> end1<span class="token punctuation">,</span> beg2<span class="token punctuation">,</span> binaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 比较每个元素，确定两个序列是否相等。</span><span class="token comment" spellcheck="true">// 二分搜索算法，传入前向迭代器或随机访问迭代器（random-access iterator），要求序列中的元素已经是有序的。通过小于运算符（&lt;）或 comp 比较操作实现比较。</span><span class="token function">lower_bound</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个非递减序列 [beg, end) 中的第一个大于等于值 val 的位置的迭代器，不存在则返回 end</span><span class="token function">lower_bound</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> val<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个非递减序列 [beg, end) 中的第一个大于等于值 val 的位置的迭代器，不存在则返回 end</span><span class="token function">upper_bound</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个非递减序列 [beg, end) 中第一个大于 val 的位置的迭代器，不存在则返回 end</span><span class="token function">upper_bound</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> val<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个非递减序列 [beg, end) 中第一个大于 val 的位置的迭代器，不存在则返回 end</span><span class="token function">equal_range</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个 pair，其 first 成员是 lower_bound 返回的迭代器，其 second 成员是 upper_bound 返回的迭代器</span><span class="token function">binary_search</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个 bool 值，指出序列中是否包含等于 val 的元素。对于两个值 x 和 y，当 x 不小于 y 且 y 也不小于 x 时，认为它们相等。</span><span class="token comment" spellcheck="true">// 只写不读算法，要求输出迭代器（output iterator）</span><span class="token function">fill</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将 val 赋予每个元素，返回 void</span><span class="token function">fill_n</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> cnt<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将 val 赋予 cnt 个元素，返回指向写入到输出序列最有一个元素之后位置的迭代器</span><span class="token function">genetate</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> Gen<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 每次调用 Gen() 生成不同的值赋予每个序列，返回 void</span><span class="token function">genetate_n</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> cnt<span class="token punctuation">,</span> Gen<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 每次调用 Gen() 生成不同的值赋予 cnt 个序列，返回指向写入到输出序列最有一个元素之后位置的迭代器</span><span class="token comment" spellcheck="true">// 使用输入迭代器的写算法，读取一个输入序列，将值写入到一个输出序列（dest）中</span><span class="token function">copy</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> dest<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 从输入范围将元素拷贝所有元素到 dest 指定定的目的序列</span><span class="token function">copy_if</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> dest<span class="token punctuation">,</span> unaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 从输入范围将元素拷贝满足 unaryPred 的元素到 dest 指定定的目的序列</span><span class="token function">copy_n</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> n<span class="token punctuation">,</span> dest<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 从输入范围将元素拷贝前 n 个元素到 dest 指定定的目的序列</span><span class="token function">move</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> dest<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 对输入序列中的每个元素调用 std::move，将其移动到迭代器 dest 开始始的序列中</span><span class="token function">transform</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> dest<span class="token punctuation">,</span> unaryOp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用给定操作（一元操作），并将结果写到dest中</span><span class="token function">transform</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> beg2<span class="token punctuation">,</span> dest<span class="token punctuation">,</span> binaryOp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用给定操作（二元操作），并将结果写到dest中</span><span class="token function">replace_copy</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> dest<span class="token punctuation">,</span> old_val<span class="token punctuation">,</span> new_val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将每个元素拷贝到 dest，将等于 old_val 的的元素替换为 new_val</span><span class="token function">replace_copy_if</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> dest<span class="token punctuation">,</span> unaryPred<span class="token punctuation">,</span> new_val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将每个元素拷贝到 dest，将满足 unaryPred 的的元素替换为 new_val</span><span class="token function">merge</span><span class="token punctuation">(</span>beg1<span class="token punctuation">,</span> end1<span class="token punctuation">,</span> beg2<span class="token punctuation">,</span> end2<span class="token punctuation">,</span> dest<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 两个输入序列必须都是有序的，用 &lt; 运算符将合并后的序列写入到 dest 中</span><span class="token function">merge</span><span class="token punctuation">(</span>beg1<span class="token punctuation">,</span> end1<span class="token punctuation">,</span> beg2<span class="token punctuation">,</span> end2<span class="token punctuation">,</span> dest<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 两个输入序列必须都是有序的，使用给定的比较操作（comp）将合并后的序列写入到 dest 中</span><span class="token comment" spellcheck="true">// 使用前向迭代器的写算法，要求前向迭代器</span><span class="token function">iter_swap</span><span class="token punctuation">(</span>iter1<span class="token punctuation">,</span> iter2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 交换 iter1 和 iter2 所表示的元素，返回 void</span><span class="token function">swap_ranges</span><span class="token punctuation">(</span>beg1<span class="token punctuation">,</span> end1<span class="token punctuation">,</span> beg2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将输入范围中所有元素与 beg2 开始的第二个序列中所有元素进行交换。返回递增后的的 beg2，指向最后一个交换元素之后的位置。</span><span class="token function">replace</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> old_val<span class="token punctuation">,</span> new_val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用 new_val 替换等于 old_val 的每个匹配元素</span><span class="token function">replace_if</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> unaryPred<span class="token punctuation">,</span> new_val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用 new_val 替换满足 unaryPred 的每个匹配元素</span><span class="token comment" spellcheck="true">// 使用双向迭代器的写算法，要求双向选代器（bidirectional iterator）</span><span class="token function">copy_backward</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> dest<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 从输入范围中拷贝元素到指定目的位置。如果范围为空,则返回值为 dest；否则，返回值表示从 *beg 中拷贝或移动的元素。</span><span class="token function">move_backward</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> dest<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 从输入范围中移动元素到指定目的位置。如果范围为空,则返回值为 dest；否则,返回值表示从 *beg 中拷贝或移动的元素。</span><span class="token function">inplace_merge</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将同一个序列中的两个有序子序列合并为单一的有序序列。beg 到 mid 间的子序列和 mid 到 end 间的子序列被合并，并被写入到原序列中。使用 &lt; 比较元素。</span><span class="token function">inplace_merge</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> end<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将同一个序列中的两个有序子序列合并为单一的有序序列。beg 到 mid 间的子序列和 mid 到 end 间的子序列被合并，并被写入到原序列中。使用给定的 comp 操作。</span><span class="token comment" spellcheck="true">// 划分算法，要求双向选代器（bidirectional iterator）</span><span class="token function">is_partitioned</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> unaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果所有满足谓词 unaryPred 的元素都在不满足 unarypred 的元素之前，则返回 true。若序列为空，也返回 true</span><span class="token function">partition_copy</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> dest1<span class="token punctuation">,</span> dest2<span class="token punctuation">,</span> unaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将满足 unaryPred 的元素拷贝到到 dest1，并将不满足 unaryPred 的元素拷贝到到 dest2。返回一个迭代器 pair，其 first 成员表示拷贝到 dest1 的的元素的末尾，second 表示拷贝到 dest2 的元素的末尾。</span><span class="token function">partitioned_point</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> unaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输入序列必须是已经用 unaryPred 划分过的。返回满足  unaryPred 的范围的尾后迭代器。如果返回的迭代器不是 end，则它指向的元素及其后的元素必须都不满足 unaryPred</span><span class="token function">stable_partition</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> unaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用 unaryPred 划分输入序列。满足 unaryPred 的元素放置在序列开始，不满足的元素放在序列尾部。返回一个迭代器，指向最后一个满足 unaryPred 的元素之后的位置如果所有元素都不满足 unaryPred，则返回 beg</span><span class="token function">partition</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> unaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用 unaryPred 划分输入序列。满足 unaryPred 的元素放置在序列开始，不满足的元素放在序列尾部。返回一个迭代器，指向最后一个满足 unaryPred 的元素之后的位置如果所有元素都不满足 unaryPred，则返回 beg</span><span class="token comment" spellcheck="true">// 排序算法，要求随机访问迭代器（random-access iterator）</span><span class="token function">sort</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 排序整个范围</span><span class="token function">stable_sort</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 排序整个范围（稳定排序）</span><span class="token function">sort</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 排序整个范围</span><span class="token function">stable_sort</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 排序整个范围（稳定排序）</span><span class="token function">is_sorted</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个 bool 值，指出整个输入序列是否有序</span><span class="token function">is_sorted</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个 bool 值，指出整个输入序列是否有序</span><span class="token function">is_sorted_until</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 在输入序列中査找最长初始有序子序列，并返回子序列的尾后迭代器</span><span class="token function">is_sorted_until</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 在输入序列中査找最长初始有序子序列，并返回子序列的尾后迭代器</span><span class="token function">partial_sort</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 排序 mid-beg 个元素。即，如果 mid-beg 等于 42，则此函数将值最小的 42 个元素有序放在序列前 42 个位置</span><span class="token function">partial_sort</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> end<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 排序 mid-beg 个元素。即，如果 mid-beg 等于 42，则此函数将值最小的 42 个元素有序放在序列前 42 个位置</span><span class="token function">partial_sort_copy</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> destBeg<span class="token punctuation">,</span> destEnd<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 排序输入范围中的元素，并将足够多的已排序元素放到 destBeg 和 destEnd 所指示的序列中</span><span class="token function">partial_sort_copy</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> destBeg<span class="token punctuation">,</span> destEnd<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 排序输入范围中的元素，并将足够多的已排序元素放到 destBeg 和 destEnd 所指示的序列中</span><span class="token function">nth_element</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> nth<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// nth 是一个迭代器，指向输入序列中第 n 大的元素。nth 之前的元素都小于等于它，而之后的元素都大于等于它</span><span class="token function">nth_element</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> nth<span class="token punctuation">,</span> end<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// nth 是一个迭代器，指向输入序列中第 n 大的元素。nth 之前的元素都小于等于它，而之后的元素都大于等于它</span><span class="token comment" spellcheck="true">// 使用前向迭代器的重排算法。普通版本在输入序列自身内部重拍元素，_copy 版本完成重拍后写入到指定目的序列中，而不改变输入序列</span><span class="token function">remove</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过用保留的元素覆盖要删除的元素实现删除 ==val 的元素，返回一个指向最后一个删除元素的尾后位置的迭代器</span><span class="token function">remove_if</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> unaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过用保留的元素覆盖要删除的元素实现删除满足 unaryPred 的元素，返回一个指向最后一个删除元素的尾后位置的迭代器</span><span class="token function">remove_copy</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> dest<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过用保留的元素覆盖要删除的元素实现删除 ==val 的元素，返回一个指向最后一个删除元素的尾后位置的迭代器</span><span class="token function">remove_copy_if</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> dest<span class="token punctuation">,</span> unaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过用保留的元素覆盖要删除的元素实现删除满足 unaryPred 的元素，返回一个指向最后一个删除元素的尾后位置的迭代器</span><span class="token function">unique</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过对覆盖相邻的重复元素（用 == 确定是否相同）实现重排序列。返回一个迭代器，指向不重复元素的尾后位置</span><span class="token function">unique</span> <span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> binaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过对覆盖相邻的重复元素（用 binaryPred 确定是否相同）实现重排序列。返回一个迭代器，指向不重复元素的尾后位置</span><span class="token function">unique_copy</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> dest<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过对覆盖相邻的重复元素（用 == 确定是否相同）实现重排序列。返回一个迭代器，指向不重复元素的尾后位置</span><span class="token function">unique_copy_if</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> dest<span class="token punctuation">,</span> binaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过对覆盖相邻的重复元素（用 binaryPred 确定是否相同）实现重排序列。返回一个迭代器，指向不重复元素的尾后位置</span><span class="token function">rotate</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 围绕 mid 指向的元素进行元素转动。元素 mid 成为为首元素，随后是 mid+1 到到 end 之前的元素，再接着是 beg 到 mid 之前的元素。返回一个迭代器，指向原来在 beg 位置的元素</span><span class="token function">rotate_copy</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> end<span class="token punctuation">,</span> dest<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 围绕 mid 指向的元素进行元素转动。元素 mid 成为为首元素，随后是 mid+1 到到 end 之前的元素，再接着是 beg 到 mid 之前的元素。返回一个迭代器，指向原来在 beg 位置的元素</span><span class="token comment" spellcheck="true">// 使用双向迭代器的重排算法</span><span class="token function">reverse</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 翻转序列中的元素，返回 void</span><span class="token function">reverse_copy</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> dest<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 翻转序列中的元素，返回一个迭代器，指向拷贝到目的序列的元素的尾后位置</span><span class="token comment" spellcheck="true">// 使用随机访问迭代器的重排算法</span><span class="token function">random_shuffle</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 混洗输入序列中的元素，返回 void</span><span class="token function">random_shuffle</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> rand<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 混洗输入序列中的元素，rand 接受一个正整数的随机对象，返回 void</span><span class="token function">shuffle</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> Uniform_rand<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 混洗输入序列中的元素，Uniform_rand 必须满足均匀分布随机数生成器的要求，返回 void</span><span class="token comment" spellcheck="true">// 最小值和最大值，使用 &lt; 运算符或给定的比较操作 comp 进行比较</span><span class="token function">min</span><span class="token punctuation">(</span>val1<span class="token punctuation">,</span> va12<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回 val1 和 val2 中的最小值，两个实参的类型必须完全一致。参数和返回类型都是 const的引引用，意味着对象不会被拷贝。下略</span><span class="token function">min</span><span class="token punctuation">(</span>val1<span class="token punctuation">,</span> val2<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">min</span><span class="token punctuation">(</span>init_list<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">min</span><span class="token punctuation">(</span>init_list<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">max</span><span class="token punctuation">(</span>val1<span class="token punctuation">,</span> val2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">max</span><span class="token punctuation">(</span>val1<span class="token punctuation">,</span> val2<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">max</span><span class="token punctuation">(</span>init_list<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">max</span><span class="token punctuation">(</span>init_list<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">minmax</span><span class="token punctuation">(</span>val1<span class="token punctuation">,</span> val2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个 pair，其 first 成员为提供的值中的较小者，second 成员为较大者。下略</span><span class="token function">minmax</span><span class="token punctuation">(</span>vall<span class="token punctuation">,</span> val2<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">minmax</span><span class="token punctuation">(</span>init_list<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">minmax</span><span class="token punctuation">(</span>init_list<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">min_element</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回指向输入序列中最小元素的迭代器</span><span class="token function">min_element</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回指向输入序列中最小元素的迭代器</span><span class="token function">max_element</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回指向输入序列中最大元素的迭代器</span><span class="token function">max_element</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回指向输入序列中最大元素的迭代器</span><span class="token function">minmax_element</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个 pair，其中 first 成员为最小元素，second 成员为最大元素</span><span class="token function">minmax_element</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个 pair，其中 first 成员为最小元素，second 成员为最大元素</span><span class="token comment" spellcheck="true">// 字典序比较，根据第一对不相等的元素的相对大小来返回结果。如果第一个序列在字典序中小于第二个序列，则返回 true。否则，返回 fa1se。如果个序列比另一个短，且所有元素都与较长序列的对应元素相等，则较短序列在字典序中更小。如果序列长度相等，且对应元素都相等，则在字典序中任何一个都不大于另外一个。</span><span class="token function">lexicographical_compare</span><span class="token punctuation">(</span>beg1<span class="token punctuation">,</span> end1<span class="token punctuation">,</span> beg2<span class="token punctuation">,</span> end2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">lexicographical_compare</span><span class="token punctuation">(</span>beg1<span class="token punctuation">,</span> end1<span class="token punctuation">,</span> beg2<span class="token punctuation">,</span> end2<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p><img src="/posts/37537/image-20230919203531494.png" alt><br><img src="/posts/37537/image-20230919203542561.png" alt></p><h2 id="迭代器算术"><a href="#迭代器算术" class="headerlink" title="迭代器算术"></a>迭代器算术</h2><p>迭代器本质是对象，但使用方法类似于指针<br><img src="/posts/37537/image-20230919203600724.png" alt><br><img src="/posts/37537/image-20230919203606111.png" alt><br><img src="/posts/37537/image-20230919203609563.png" alt><br>把同一个容器的两个迭代器配合使用，可以表示容器元素的一个连续子集。在数学上，迭代器it1和it2所表达的元素范围可以表示成[<strong>it1, it2</strong>) ，这是一个左闭右开的区间，它表示子集中的元素从it1所指向的元素（<strong>包含，左闭</strong>)开始，到it2所指向的元素结束，且<strong>不包含右开</strong>it2所指向的元素。：</p><ul><li>[it1, it2) 表示从A到L的全部元素，请注意it2是尾后迭代器，它指向L的后面一个“元素”。</li><li>[it3, it4) 表示从D到H的元素，即D、E、F、G、H共5个元素。请注意，it4所指向的元素I并未包含。</li><li>[it5, it6) 则表示从L到A的全部元素，请注意it5和it6都是反向迭代器，且it6指向“首前元素”。<br><img src="/posts/37537/image-20230919203947402.png" alt></li></ul><h2 id="容器元素的增加"><a href="#容器元素的增加" class="headerlink" title="容器元素的增加"></a>容器元素的增加</h2><p><img src="/posts/37537/image-20230919204045344.png" alt></p><p><img src="/posts/37537/image-20230919204150799.png" alt></p><h2 id="容器元素的删除"><a href="#容器元素的删除" class="headerlink" title="容器元素的删除"></a>容器元素的删除</h2><p><img src="/posts/37537/image-20230919204217090.png" alt></p><p><img src="/posts/37537/image-20230919204221561.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;容器（containers）&quot;&gt;&lt;a href=&quot;#容器（containers）&quot; class=&quot;headerlink&quot; title=&quot;容器（containers）&quot;&gt;&lt;/a&gt;容器（containers）&lt;/h1&gt;&lt;h2 id=&quot;array&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>EffectiveModernCpp:条款与实践</title>
    <link href="https://joytsing.github.io/posts/46568/"/>
    <id>https://joytsing.github.io/posts/46568/</id>
    <published>2023-09-26T07:25:53.000Z</published>
    <updated>2023-09-26T07:42:08.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章：类型推导"><a href="#第一章：类型推导" class="headerlink" title="第一章：类型推导"></a>第一章：类型推导</h2><h3 id="条款-1：理解模板类型推导"><a href="#条款-1：理解模板类型推导" class="headerlink" title="条款 1：理解模板类型推导"></a>条款 1：理解模板类型推导</h3><p>函数模板大致形如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>ParamType param<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在编译期，编译器会通过表达式推导出两个类型：一个是<code>T</code>的类型，另一个是<code>ParamType</code>的类型，这两个类型往往不一样，<code>ParamType</code>常包含一些饰词，如<code>const</code>或引用符号等限定词。</p><p><strong>情况 1：ParamType 是个指针或引用，但不是个万能引用</strong></p><ol><li>若表达式具有引用类型，则先将引用部分忽略。</li><li>对表达式的类型和<code>ParamType</code>进行匹配来决定<code>T</code>的类型。</li></ol><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> cx <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> rx <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// T 的类型为 int, paramType 为 int&amp;</span><span class="token function">f</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// T 的类型为 const int, paramType 为 const int&amp;</span><span class="token function">f</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// T 的类型为 const int, paramType 为 const int&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若我们假定<code>param</code>具有常引用类型，则<code>T</code>的类型推导结果中也就没必要包含<code>const</code>了：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// T 的类型为 int, paramType 为 int&amp;</span><span class="token function">f</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// T 的类型为 int, paramType 为 const int&amp;</span><span class="token function">f</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// T 的类型为 int, paramType 为 const int&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果<code>param</code>是个指针（或指向 const 对象的指针）而非引用，运作方式本质上并无不同：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">*</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> px <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// T 的类型为 int, paramType 为 int*</span><span class="token function">f</span><span class="token punctuation">(</span>px<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// T 的类型为 const int, paramType 为 const int*</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>情况 2：ParamType 是个万能引用</strong></p><blockquote><p>详细说明请参考<strong>条款 24</strong>。</p></blockquote><ol><li>如果表达式是个左值，则<code>T</code>和<code>ParamType</code>都会被推导为左值引用。</li><li>如果表达式是个右值，则遵循情况 1 中的规则。</li></ol><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> cx <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> rx <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 左值的情况</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// T 的类型为 int&amp;, paramType 为 int&amp;</span><span class="token function">f</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// T 的类型为 const int&amp;, paramType 为 const int&amp;</span><span class="token function">f</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// T 的类型为 const int&amp;, paramType 为 const int&amp;</span><span class="token comment" spellcheck="true">// 右值的情况</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// T 的类型为 int, paramType 为 int&amp;&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>情况 3：ParamType 既非指针也非引用</strong></p><p>这种情况即为按值传递，无论传入的是什么，<code>param</code>都会是它的一个副本。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// T 和 param 的类型均为 int</span><span class="token function">f</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// T 和 param 的类型均为 int</span><span class="token function">f</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// T 和 param 的类型均为 int</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是对于指向 const 对象的 const 指针的传递，仅有指针本身的常量性会被忽略：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> ptr <span class="token operator">=</span> <span class="token string">"Fun with pointers"</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// T 和 param 的类型均为 const char*</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>数组实参：</strong></p><p>按值传递给函数模板的数组类型将退化为指针类型，但按引用传递却能推导出真正的数组类型：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"J. P. Briggs"</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// T 的类型为 const char[13], paramType 为 const char (&amp;)[13]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用声明数组引用这一能力可以创造出一个模板，用来推导出数组含有的元素个数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t N<span class="token operator">></span><span class="token keyword">constexpr</span> std<span class="token operator">::</span>size_t <span class="token function">arraySize</span><span class="token punctuation">(</span><span class="token function">T</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> N<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>函数实参：</strong></p><p>函数类型同样也会退化成函数指针，并且和数组类型的规则类似：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">someFunc</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">f1</span><span class="token punctuation">(</span>someFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// param 被推导为函数指针，具体类型为 void (*)(int, double)</span><span class="token function">f2</span><span class="token punctuation">(</span>someFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// param 被推导为函数引用，具体类型为 void (&amp;)(int, double)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-2：理解-auto-类型推导"><a href="#条款-2：理解-auto-类型推导" class="headerlink" title="条款 2：理解 auto 类型推导"></a>条款 2：理解 auto 类型推导</h3><p><code>auto</code>类型推导除了在一个例外情况下，和模板类型推导的规则一模一样，同样可以分为三种情况：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 情况 3</span><span class="token keyword">auto</span> x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 类型为 int</span><span class="token keyword">const</span> <span class="token keyword">auto</span> cx <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 类型为 const int</span><span class="token comment" spellcheck="true">// 情况 1</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> rx <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 类型为 const int&amp;</span><span class="token comment" spellcheck="true">// 情况 2</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> uref1 <span class="token operator">=</span> x<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 类型为 int&amp;</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> uref2 <span class="token operator">=</span> cx<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 类型为 const int&amp;</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> uref3 <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 类型为 int&amp;&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数组和函数实参的非引用退化规则也同样适用：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"J. P. Briggs"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 类型为 const char[13]</span><span class="token keyword">auto</span> arr1 <span class="token operator">=</span> name<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 类型为 const char*</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> arr2 <span class="token operator">=</span> name<span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// 类型为 const char (&amp;)[13]</span><span class="token keyword">void</span> <span class="token function">someFunc</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 类型为 void(int, double)</span><span class="token keyword">auto</span> func1<span class="token operator">=</span> someFunc<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 类型为 void (*)(int, double)</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> func2<span class="token operator">=</span> someFunc<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 类型为 void (&amp;)(int, double)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面我们将讨论例外情况：<code>auto</code>会假定用大括号括起的初始化表达式代表一个<code>std::initializer_list</code>，但模板类型推导不会。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> x3 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">27</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 类型为 std::initializer_list&lt;int>，值为 { 27 }</span><span class="token keyword">auto</span> x4<span class="token punctuation">{</span> <span class="token number">27</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 同上</span><span class="token keyword">auto</span> x5 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 错误，类型不一致</span>                            <span class="token comment" spellcheck="true">// 无法推导出 std::initializer_list&lt;T> 中的 T</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">9</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 错误</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span>std<span class="token operator">::</span>initializer_list<span class="token operator">&lt;</span>T<span class="token operator">></span> param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">9</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 正确，ParamType 为 std::initializer_list&lt;int></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 C++14 中，允许使用<code>auto</code>来说明函数返回值需要推导，而且 lambda 表达式也会在形参声明中用到<code>auto</code>。然而这些<code>auto</code>用法使用的是模板类型推导而非<code>auto</code>类型推导，因此也不能使用大括号括起的初始化表达式。</p><h3 id="条款-3：理解-decltype"><a href="#条款-3：理解-decltype" class="headerlink" title="条款 3：理解 decltype"></a>条款 3：理解 decltype</h3><p>绝大多数情况下，<code>decltype</code>会得出变量或表达式的类型而不作任何修改。对于类型为<code>T</code>的左值表达式，除非该表达式仅有一个名字，否则<code>decltype</code>总是得出类型<code>T&amp;</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 推导结果为 int</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 推导结果为 int&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在 C++11 中，<code>decltype</code>的主要用途是声明返回值类型依赖于形参类型的函数模板，这需要用到<strong>返回值类型尾置语法（trailing return type syntax）</strong>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Container<span class="token punctuation">,</span> <span class="token keyword">typename</span> Index<span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">authAndAccess</span><span class="token punctuation">(</span>Container<span class="token operator">&amp;</span> c<span class="token punctuation">,</span> Index i<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">authenticateUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++11 允许对单表达式的 lambda 的返回值实施类型推导，而 C++14 将这个允许范围扩张到了一切函数和一切 lambda，包括那些多表达式的。这就意味着在 C++14 中可以去掉返回值类型尾置语法，仅保留前导<code>auto</code>。</p><p>但编译器会为<code>auto</code>指定为返回值类型的函数实施模板类型推导，这样就会留下隐患（例如忽略初始化表达的引用性），使用<code>decltype(auto)</code>来说明我们采用的是<code>decltype</code>的规则，就可以解决这个问题：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Container<span class="token punctuation">,</span> <span class="token keyword">typename</span> Index<span class="token operator">></span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> <span class="token function">authAndAccess</span><span class="token punctuation">(</span>Container<span class="token operator">&amp;</span> c<span class="token punctuation">,</span> Index i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">authenticateUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在初始化表达式处也可以应用<code>decltype</code>类型推导规则：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget w<span class="token punctuation">;</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> cw <span class="token operator">=</span> w<span class="token punctuation">;</span><span class="token keyword">auto</span> myWidget1 <span class="token operator">=</span> cw<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// auto 推导出类型为 Widget</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> myWidget2 <span class="token operator">=</span> cw<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// decltype 推导出类型为 const Widget&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上述情形中，我们无法向函数传递右值容器，若想要采用一种既能绑定到左值也能绑定到右值的引用形参，就需要借助万能引用，并应用<code>std::forward</code>（参考<strong>条款 25</strong>）：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Container<span class="token punctuation">,</span> <span class="token keyword">typename</span> Index<span class="token operator">></span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> <span class="token function">authAndAccess</span><span class="token punctuation">(</span>Container<span class="token operator">&amp;&amp;</span> c<span class="token punctuation">,</span> Index i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">authenticateUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Container<span class="token operator">></span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-4：掌握查看类型推导结果的方法"><a href="#条款-4：掌握查看类型推导结果的方法" class="headerlink" title="条款 4：掌握查看类型推导结果的方法"></a>条款 4：掌握查看类型推导结果的方法</h3><p><strong>1. IDE 编辑器</strong></p><p><strong>2. 编译器诊断信息</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>    <span class="token comment" spellcheck="true">// 只声明 TD 而不定义</span><span class="token keyword">class</span> <span class="token class-name">TD</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// TD 是 “类型显示类”（Type Displayer）的缩写</span>TD<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">></span> xType<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 诱发包括 x 和 y 的类型的错误信息</span>TD<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token operator">></span> yType<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 运行时输出</strong></p><p>针对某个对象调用<code>typeid</code>，可以得到一个<code>std::type_info</code>对象，其拥有一个成员函数<code>name</code>，该函数产生一个代表类型的 C-style 的字符串。</p><p>但遗憾的是，不同编译器对于<code>std::type_info::name</code>的实现各不相同，无法保证完全可靠。并且按照标准，<code>std::type_info::name</code>中处理类型的方式和向函数模板按值传参一样，因此类型的引用性以及<code>const</code>和<code>volatile</code>限定符也将被忽略。</p><p>原书中介绍了 Boost.TypeIndex 第三方库用于代替<code>typeid</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;boost/type_index.hpp></span></span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">using</span> std<span class="token operator">::</span>cout<span class="token punctuation">;</span>    <span class="token keyword">using</span> boost<span class="token operator">::</span>typeindex<span class="token operator">::</span>type_id_with_cvr<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 显示 T 的类型</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"T =          "</span>         <span class="token operator">&lt;&lt;</span> type_id_with_cvr<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pretty_name</span><span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 显示 param 的类型</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"param =          "</span>         <span class="token operator">&lt;&lt;</span> type_id_with_cvr<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pretty_name</span><span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第二章：auto"><a href="#第二章：auto" class="headerlink" title="第二章：auto"></a>第二章：auto</h2><h3 id="条款-5：优先选用-auto，而非显式类型声明"><a href="#条款-5：优先选用-auto，而非显式类型声明" class="headerlink" title="条款 5：优先选用 auto，而非显式类型声明"></a>条款 5：优先选用 auto，而非显式类型声明</h3><p><code>auto</code>变量要求必须初始化，基本上可以避免会导致兼容性和效率问题的类型不匹配现象，还可以简化重构流程，通常也比显式指定类型要少打一些字，但在使用时需要注意<strong>条款 2</strong> 和<strong>条款 6</strong> 中提到的问题。</p><p>使用<code>auto</code>和<code>std::function</code>都可以存储闭包：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// C++14 允许在 lambda 表达式的形参中使用 auto</span><span class="token keyword">auto</span> derefLess <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> p1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> p2<span class="token punctuation">)</span>                  <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span>p1 <span class="token operator">&lt;</span> <span class="token operator">*</span>p2<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token operator">&amp;</span><span class="token punctuation">,</span>                   <span class="token keyword">const</span> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">></span>    derefUPLess <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token operator">&amp;</span> p1<span class="token punctuation">,</span>                     <span class="token keyword">const</span> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token operator">&amp;</span> p2<span class="token punctuation">)</span>                   <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span>p1 <span class="token operator">&lt;</span> <span class="token operator">*</span>p2<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>auto</code>声明的、存储着一个闭包的变量和该闭包是同一类型，从而它要求的内存量也和该闭包相同；而使用<code>std::function</code>声明的、存储着一个闭包的变量是<code>std::function</code>的一个实例，不管给定的签名如何，它都占有固定大小的内存，而这个大小对于其存储的闭包而言并不一定够用，如果是这样，那么<code>std::function</code>的构造函数就会分配堆上的内存来存储该闭包。再有，编译器的细节一般都会限制内联，并会产生间接函数调用。</p><p>综上所述，<code>std::function</code>通常比起<code>auto</code>更大更慢，还可能导致内存消耗异常，因此实际使用时更推荐<code>auto</code>。</p><p>考虑以下代码的隐患：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>unordered_map<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> m<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>pair<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> p <span class="token operator">:</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>std::unordered_map</code>的键值部分是 const 的，所以哈希表中的<code>std::pair</code>类型应为<code>std::pair&lt;const std::string, int&gt;</code>而非<code>std::pair&lt;std::string, int&gt;</code>，类型的不匹配会导致额外的临时对象被复制出来，降低了运行效率。</p><p>使用<code>auto</code>就可以轻松避免这种问题：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> p <span class="token operator">:</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="条款-6：当-auto-推导的类型不符合要求时，使用显式类型初始化惯用法"><a href="#条款-6：当-auto-推导的类型不符合要求时，使用显式类型初始化惯用法" class="headerlink" title="条款 6：当 auto 推导的类型不符合要求时，使用显式类型初始化惯用法"></a>条款 6：当 auto 推导的类型不符合要求时，使用显式类型初始化惯用法</h3><p>“隐形” 的代理类型可以导致<code>auto</code>根据初始化表达式推导出 “错误的” 类型，应该防止写出这样的代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> someVar <span class="token operator">=</span> <span class="token string">" 隐形 "</span> 代理类型表达式<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一个隐形代理类的典型例子是<code>std::vector&lt;bool&gt;</code>，它经过了特化，与一般的<code>std::vector</code>的行为不同，和<code>std::bitset</code>的行为相似，使用一种压缩形式表示其持有的<code>bool</code>元素，每个<code>bool</code>元素用一个比特来表示。因此，<code>std::vector&lt;bool&gt;</code>的<code>operator[]</code>并不会直接返回一个<code>bool&amp;</code>，而是会返回一个具有类似行为的<code>std::vector&lt;bool&gt;::reference</code>类型的对象，并可以隐式转换为<code>bool</code>类型。</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">features</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>Widget w<span class="token punctuation">;</span><span class="token keyword">bool</span> highPriority1 <span class="token operator">=</span> <span class="token function">features</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 得到正确的 bool 变量</span><span class="token keyword">auto</span> highPriority2 <span class="token operator">=</span> <span class="token function">features</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 错误地得到了 std::vector&lt;bool>::reference 对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了<code>std::vector&lt;bool&gt;</code>以外，标准库中的智能指针和另外一些 C++ 库中的类也使用了代理类的设计模式，例如为了提高数值计算代码效率的<strong>表达式模板</strong>技术：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Matrix sum <span class="token operator">=</span> m1 <span class="token operator">+</span> m2 <span class="token operator">+</span> m3 <span class="token operator">+</span> m4<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过使 operator+ 返回结果的代理来提高效率</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>在实际编写代码时，记得通过查看文档或头文件中的函数原型来确认手头上的类是否为代理类。</p></blockquote><p>解决代理类问题的做法是：使用带显式类型的初始值设定项来强制<code>auto</code>推导出你想要的类型。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> highPriority <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token function">features</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这种用法并不仅限于会产生代理类型的初始值设定项，它同样可以应用于你想要强调创建一个类型不同于初始化表达式类型的场合，例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">double</span> <span class="token function">calcEpsilon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">float</span> ep1 <span class="token operator">=</span> <span class="token function">calcEpsilon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">// 进行从 double 到 float 的隐式类型转换</span><span class="token keyword">auto</span> ep2 <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token function">calcEpsilon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 强调了类型转换的存在</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第三章：转向现代-C"><a href="#第三章：转向现代-C" class="headerlink" title="第三章：转向现代 C++"></a>第三章：转向现代 C++</h2><h3 id="条款-7：在创建对象时注意区分-和"><a href="#条款-7：在创建对象时注意区分-和" class="headerlink" title="条款 7：在创建对象时注意区分 () 和 {}"></a>条款 7：在创建对象时注意区分 () 和 {}</h3><p>为了着手解除众多的初始化语法带来的困惑，也为了解决这些语法不能覆盖所有初始化场景的问题，C++11 引入了统一初始化，以<strong>大括号初始化（braced initialize）</strong> 的形式存在：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 下面两种写法等价</span><span class="token keyword">int</span> x<span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>大括号可以用于指定容器的初始内容：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>大括号和等号可以用于为非静态成员指定默认初始化值，而小括号不行：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> x<span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 可行</span>    <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 可行</span>    <span class="token keyword">int</span> <span class="token function">z</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 不可行！</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不可复制的对象可以采用大括号和小括号进行初始化，而不能使用等号：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ai1<span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 可行</span>std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ai2</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 可行</span>std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ai3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 不可行！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>大括号初始化禁止内建类型之间进行<strong>隐式窄化类型转换（narrowing conversion）</strong>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">double</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">;</span><span class="token keyword">int</span> sum1<span class="token punctuation">{</span> x <span class="token operator">+</span> y <span class="token operator">+</span> z <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 错误！double 之和可能无法用 int 表达</span><span class="token keyword">int</span> <span class="token function">sum2</span><span class="token punctuation">(</span>x <span class="token operator">+</span> y <span class="token operator">+</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 正确，表达式的值被截断为 int</span><span class="token keyword">int</span> sum3 <span class="token operator">=</span> x <span class="token operator">+</span> y <span class="token operator">+</span> z<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 同上</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大括号初始化可以避免<strong>最令人烦恼的解析语法（most vexing parse）</strong>：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget <span class="token function">w1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 调用 Widget 构造函数</span>Widget <span class="token function">w2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 声明了一个名为 w2，返回值为 Widget 对象的函数</span>Widget w3<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用没有形参的 Widget 构造函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>大括号初始化也有一些缺点，其中一个是<strong>条款 2</strong> 中提到的 auto 推导问题，另一个则产生于对带有<code>std::initializer_list</code>类型形参的重载版本的强烈偏向性：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">bool</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Widget</span><span class="token punctuation">(</span>std<span class="token operator">::</span>initializer_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">operator</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Widget <span class="token function">w1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 调用第一个构造函数</span>Widget w2<span class="token punctuation">{</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 调用带有 std::initializer_list 形参的构造函数</span>Widget <span class="token function">w3</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 调用第二个构造函数</span>Widget w4<span class="token punctuation">{</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 错误！禁止窄化类型转换</span>Widget <span class="token function">w5</span><span class="token punctuation">(</span>w4<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 调用拷贝构造函数</span>Widget w6<span class="token punctuation">{</span> w4 <span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 将 w4 强制转换为 int 后，调用带有 std::initializer_list 形参的构造函数</span>Widget <span class="token function">w7</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>w4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 调用移动构造函数</span>Widget w8<span class="token punctuation">{</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>w4<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 情况和 w6 相同</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只有在找不到任何办法把大括号初始值设定项中的实参转换为<code>std::initializer_list</code>模板中的类型时，编译器才会退而检查普通的重载决议。</p><p>值得注意的是，一对空大括号代表的意义是 “没有实参”，而非 “空的<code>std::initializer_list</code>”，后者可以用套娃的括号来表示：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget w1<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 调用默认构造函数</span>Widget w2<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 仍然调用默认构造函数</span>Widget <span class="token function">w3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 变成了函数声明语句</span>Widget <span class="token function">w4</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 调用带有 std::initializer_list 形参的构造函数</span>                <span class="token comment" spellcheck="true">// 并传入空的 std::initializer_list</span>Widget w5<span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 同上</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在使用模板进行对象创建时，到底该使用小括号还是大括号会成为一个棘手的问题。举例来说，如果你想以任意数量的实参来创建一个任意类型的对象，那么，一个可变参数模板将会是不错的选择：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">doSomeWork</span><span class="token punctuation">(</span>Ts<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 利用 params 创建 T 类型的局部对象</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>doSomeWork<span class="token operator">&lt;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然而此时，在模板内部创建局部对象时，对小括号和大括号的选择将会影响实际创建出的内容：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 得到一个包含 10 个元素的 std::vector</span>T <span class="token function">localObject</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Ts<span class="token operator">></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 得到一个包含 2 个元素的 std::vector</span>T localObject<span class="token punctuation">{</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Ts<span class="token operator">></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>标准库函数<code>std::make_unique</code>和<code>std::make_shared</code>也面临着这个问题，它们的解决方案是在内部使用小括号，并将这个决定写进文档中，作为其接口的组成部分。</p><h3 id="条款-8：优先选用-nullptr，而非-0-或-NULL"><a href="#条款-8：优先选用-nullptr，而非-0-或-NULL" class="headerlink" title="条款 8：优先选用 nullptr，而非 0 或 NULL"></a>条款 8：优先选用 nullptr，而非 0 或 NULL</h3><p><code>nullptr</code>的实际类型是<code>std::nullptr_t</code>，该类型可以隐式转换到所有的裸指针类型，因此<code>nullptr</code>可以扮演所有类型的指针。与<code>0</code>和<code>NULL</code>不同，<code>nullptr</code>不具备整数类型，因此不具有多义性。</p><p><code>0</code>和<code>NULL</code>导致的重载问题提醒我们应当尽量避免在整型和指针类型之间进行重载：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">bool</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// f 的三个重载版本</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 调用 f(int)</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 可能无法通过编译，但一般会调用 f(int)，绝不会调用 f(void*)</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 调用 f(void*)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>nullptr</code>在有模板的前提下表现最亮眼：模板类型推导会将<code>0</code>和<code>NULL</code>推导成 “错误” 类型（即它们的真实类型，而非空指针这个含义），而使用<code>nullptr</code>的话，模板就不会带来特殊的麻烦。考虑如下情形：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">f1</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> spw<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">double</span> <span class="token function">f2</span><span class="token punctuation">(</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> upw<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">f3</span><span class="token punctuation">(</span>Widget<span class="token operator">*</span> pw<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> FuncType<span class="token punctuation">,</span> <span class="token keyword">typename</span> MuxType<span class="token punctuation">,</span> <span class="token keyword">typename</span> PtrType<span class="token operator">></span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> <span class="token function">lockAndCall</span><span class="token punctuation">(</span>FuncType func<span class="token punctuation">,</span> MuxType<span class="token operator">&amp;</span> mutex<span class="token punctuation">,</span> PtrType ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">g</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>std<span class="token operator">::</span>mutex f1m<span class="token punctuation">,</span> f2m<span class="token punctuation">,</span> f3m<span class="token punctuation">;</span><span class="token keyword">auto</span> result1 <span class="token operator">=</span> <span class="token function">lockAndCall</span><span class="token punctuation">(</span>f1<span class="token punctuation">,</span> f1m<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 错误！</span><span class="token keyword">auto</span> result2 <span class="token operator">=</span> <span class="token function">lockAndCall</span><span class="token punctuation">(</span>f2<span class="token punctuation">,</span> f2m<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 错误！</span><span class="token keyword">auto</span> result3 <span class="token operator">=</span> <span class="token function">lockAndCall</span><span class="token punctuation">(</span>f3<span class="token punctuation">,</span> f3m<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 正确</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-9：优先选用别名声明，而非-typedef"><a href="#条款-9：优先选用别名声明，而非-typedef" class="headerlink" title="条款 9：优先选用别名声明，而非 typedef"></a>条款 9：优先选用别名声明，而非 typedef</h3><p>很多人发现别名声明在处理涉及函数指针的类型时，比<code>typedef</code>更容易理解：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>FP<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>代替为：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> FP <span class="token operator">=</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但别名声明的压倒性优势在于<strong>别名模板（alias template）</strong>，它给予了 C++11 程序员一种直截了当的表达机制，用以表达 C++98 程序员不得不用嵌套在模板化的<code>struct</code>里面的<code>typedef</code>才能硬搞出来的东西。考虑如下情形：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">struct</span> MyAllocList <span class="token punctuation">{</span>    <span class="token keyword">typedef</span> std<span class="token operator">::</span>list<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> MyAlloc<span class="token operator">&lt;</span>T<span class="token operator">>></span> type<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">typename</span> MyAllocList<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>type list<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用别名模板，就可以让整个写法更简洁，并且可以摆脱类型前的<code>typename</code>限定符：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">using</span> MyAllocList <span class="token operator">=</span> std<span class="token operator">::</span>list<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> MyAlloc<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    MyAllocList<span class="token operator">&lt;</span>T<span class="token operator">></span> list<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 C++11 中，标准库的<code>&lt;type_traits&gt;</code>给出了一整套用于进行值类别转换的模板，它们是使用<code>typedef</code>实现的，对于给定待变换类型 T，其结果类型需要通过<code>std::transformation&lt;T&gt;::type</code>的方式获得。而在 C++14 中，所有的值类别转换都加上了对应的别名模板，通过<code>std::transformation_t&lt;T&gt;</code>的方式使用，这显然比<code>typedef</code>实现的版本更加好用。</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>remove_const<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>type          <span class="token comment" spellcheck="true">// C++11: const T -> T</span>std<span class="token operator">::</span>remove_const_t<span class="token operator">&lt;</span>T<span class="token operator">></span>              <span class="token comment" spellcheck="true">// C++14 中的等价物</span>std<span class="token operator">::</span>remove_reference<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>type      <span class="token comment" spellcheck="true">// C++11: T&amp;/T&amp;&amp; -> T</span>std<span class="token operator">::</span>remove_reference_t<span class="token operator">&lt;</span>T<span class="token operator">></span>          <span class="token comment" spellcheck="true">// C++14 中的等价物</span>std<span class="token operator">::</span>add_lvalue_reference<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>type  <span class="token comment" spellcheck="true">// C++11: T -> T&amp;</span>std<span class="token operator">::</span>add_lvalue_reference_t<span class="token operator">&lt;</span>T<span class="token operator">></span>      <span class="token comment" spellcheck="true">// C++14 中的等价物</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-10：优先选用限定作用域的枚举类型，而非不限作用域的枚举类型"><a href="#条款-10：优先选用限定作用域的枚举类型，而非不限作用域的枚举类型" class="headerlink" title="条款 10：优先选用限定作用域的枚举类型，而非不限作用域的枚举类型"></a>条款 10：优先选用限定作用域的枚举类型，而非不限作用域的枚举类型</h3><p>C++98 中的枚举类型被称为不限作用域的枚举类型，与之相对的即是 C++11 中引入的限定作用域的枚举类型，即枚举类<code>enum class</code>，它的优点很明显：不会产生名称污染。</p><p>除此以外，枚举类还是强类型的，而不限范围的枚举类型中的枚举量可以隐式转换到整型（并由此更进一步转换到浮点型）：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">enum</span> Color <span class="token punctuation">{</span> black<span class="token punctuation">,</span> white<span class="token punctuation">,</span> red <span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>size_t<span class="token operator">></span> <span class="token function">primeFactors</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t x<span class="token punctuation">)</span><span class="token punctuation">;</span>Color c <span class="token operator">=</span> red<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">&lt;</span> <span class="token number">14.5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> factors <span class="token operator">=</span> <span class="token function">primeFactors</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>想要用<code>enum class</code>代替<code>enum</code>，对其施以强制类型转换即可，但是无法确保转换的合法性：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Color</span> <span class="token punctuation">{</span> black<span class="token punctuation">,</span> white<span class="token punctuation">,</span> red <span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>size_t<span class="token operator">></span> <span class="token function">primeFactors</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t x<span class="token punctuation">)</span><span class="token punctuation">;</span>Color c <span class="token operator">=</span> Color<span class="token operator">::</span>red<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">14.5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> factors <span class="token operator">=</span> <span class="token function">primeFactors</span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>std<span class="token operator">::</span>size_t<span class="token operator">></span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于不限范围的枚举类型，编译器为了节约使用内存，通常会为枚举类型选用足够表示枚举量取值的最小底层类型。即使在某些情况下，编译器会采取空间换时间的策略，导致放弃选择尺寸最小的类型，然而它仍然需要保留优化空间的能力。因此，在 C++98 中，<code>enum</code>只允许在声明处定义，没有提供对前置声明的支持。</p><p>而在 C++11 中，无论是<code>enum class</code>还是<code>enum</code>都可以进行前置声明，<code>enum class</code>的默认底层类型是<code>int</code>，而<code>enum</code>不具备默认底层类型，只有在指定了的前提下才可以进行前置声明：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Status</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// 底层类型是 int</span><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Status</span> <span class="token operator">:</span> std<span class="token operator">::</span>uint32_t<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 底层类型是 std::uint32_t</span><span class="token keyword">enum</span> Color <span class="token operator">:</span> std<span class="token operator">::</span>uint8_t<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 底层类型是 std::uint8_t</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>底层类型指定同样也可以在定义时进行：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Status</span> <span class="token operator">:</span> std<span class="token operator">::</span>uint32_t <span class="token punctuation">{</span>    good <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>    failed <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>    incomplete <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span>    corrupt <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">,</span>    audited <span class="token operator">=</span> <span class="token number">500</span><span class="token punctuation">,</span>    indetermine <span class="token operator">=</span> <span class="token number">0xFFFFFFFF</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不限范围的枚举类型在你需要更便捷地为数字和名称建立联系时，还是比较好用的，例如在访问元组的元素时，你可以使用枚举量而非直接使用难懂的数字：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> UserInfo <span class="token operator">=</span> std<span class="token operator">::</span>tuple<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> std<span class="token operator">::</span>string<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t<span class="token operator">></span><span class="token punctuation">;</span><span class="token keyword">enum</span> UserInfoFields <span class="token punctuation">{</span> uiName<span class="token punctuation">,</span> uiEmail<span class="token punctuation">,</span> uiReputation <span class="token punctuation">}</span><span class="token punctuation">;</span>UserInfo uInfo<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">auto</span> val <span class="token operator">=</span> std<span class="token operator">::</span>get<span class="token operator">&lt;</span>uiEmail<span class="token operator">></span><span class="token punctuation">(</span>uInfo<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而使用<code>enum class</code>就要啰嗦得多：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> val <span class="token operator">=</span> std<span class="token operator">::</span>get<span class="token operator">&lt;</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>std<span class="token operator">::</span>size_t<span class="token operator">></span><span class="token punctuation">(</span>UserInfoFields<span class="token operator">::</span>uiEmail<span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span>uInfo<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果你实在无法忍受名称污染，执意打算使用<code>enum class</code>，那么可以考虑使用以下辅助类来简化书写：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> E<span class="token operator">></span>    <span class="token comment" spellcheck="true">// C++14</span><span class="token keyword">constexpr</span> <span class="token keyword">auto</span> <span class="token function">toUType</span><span class="token punctuation">(</span>E enumerator<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>std<span class="token operator">::</span>underlying_type_t<span class="token operator">&lt;</span>E<span class="token operator">>></span><span class="token punctuation">(</span>enumerator<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">auto</span> val <span class="token operator">=</span> std<span class="token operator">::</span>get<span class="token operator">&lt;</span><span class="token function">toUType</span><span class="token punctuation">(</span>UserInfoFields<span class="token operator">::</span>uiEmail<span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span>uInfo<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-11：优先选用删除函数，而非-private-未定义函数"><a href="#条款-11：优先选用删除函数，而非-private-未定义函数" class="headerlink" title="条款 11：优先选用删除函数，而非 private 未定义函数"></a>条款 11：优先选用删除函数，而非 private 未定义函数</h3><p>删除函数和将函数声明为 private 看起来只是风格不同的选择，但其实有更多值得思考的微妙之处，例如：被删除的函数无法通过任何方法调用，对于成员和友元函数中的代码也是如此。</p><p>习惯上，删除函数会被声明为 public，而非 private，这样做的理由是：C++ 会先校验可访问性，后校验删除状态，当我们尝试调用某个 private 删除函数时，编译器可能只会提醒函数无法访问，而非更应关心的函数是否被删除。</p><p>以下是 C++11 中<code>std::basic_ios</code>阻止被复制的方法：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">charT</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">traits</span> <span class="token operator">=</span> char_traits<span class="token operator">&lt;</span>charT<span class="token operator">>></span><span class="token keyword">class</span> <span class="token class-name">basic_ios</span> <span class="token operator">:</span> <span class="token keyword">public</span> ios_base <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">basic_ios</span><span class="token punctuation">(</span><span class="token keyword">const</span> basic_ios<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>    basic_ios<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> basic_ios<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>任何函数都能被删除，藉此我们可以过滤掉不想要的函数重载版本：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">isLucky</span><span class="token punctuation">(</span><span class="token keyword">int</span> number<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 原始版本</span><span class="token keyword">bool</span> <span class="token function">isLucky</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 拒绝 char 类型</span><span class="token keyword">bool</span> <span class="token function">isLucky</span><span class="token punctuation">(</span><span class="token keyword">bool</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 拒绝 bool 类型</span><span class="token keyword">bool</span> <span class="token function">isLucky</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 拒绝 double 和 float 类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>float</code>类型的参数会优先转换到<code>double</code>类型，因此传入<code>float</code>时会调用<code>double</code>类型的重载版本，但由于这个重载版本被删除了，所以编译会被阻止。</p><p>删除函数还可以阻止那些不应该进行的模板具现。举例来说，假设你需要一个和内建指针协作的模板，却不想要它对<code>void*</code>和<code>char*</code>指针进行处理，那么可以写出以下代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">processPointer</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">void</span> processPointer<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">void</span> processPointer<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">void</span> processPointer<span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">void</span> processPointer<span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 删去其它版本，如 volatile void* 和 volatile char*</span><span class="token comment" spellcheck="true">// 与其它标准字符类型，如 std::wchar_t, std::char16_t 和 std::char32_t</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>成员函数模板可以在类外被删除：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>    <span class="token keyword">void</span> <span class="token function">processPointer</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">void</span> Widget<span class="token operator">::</span>processPointer<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-12：为意在改写的函数添加-override-声明"><a href="#条款-12：为意在改写的函数添加-override-声明" class="headerlink" title="条款 12：为意在改写的函数添加 override 声明"></a>条款 12：为意在改写的函数添加 override 声明</h3><p>如果要使虚函数重写发生，有一系列要求需要满足：</p><ol><li>基类中的函数必须是虚函数。</li><li>基类和派生类中的<strong>函数名称</strong>必须完全相同（析构函数除外）。</li><li>基类和派生类中的<strong>函数形参类型</strong>必须完全相同。</li><li>基类和派生类中的<strong>函数常量性</strong>必须完全相同。</li><li>基类和派生类中的<strong>函数返回值</strong>和<strong>异常规格</strong>必须兼容。</li><li>基类和派生类的<strong>函数引用限定符</strong>必须完全相同。</li></ol><p>由于对声明派生类中的重写，保证正确性很重要，而出错又很容易，C++11 提供了<code>override</code>声明来显式地标明派生类中的函数是为了重写基类版本：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> override<span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf2</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> override<span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> override<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">mf4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> override<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 加个 "virtual" 没问题，但也没必要</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样做的好处不仅在于让编译器提醒你想要重写的函数实际上并未重写，还可以让你在打算更改基类中虚函数的签名时，衡量一下其所造成的影响。</p><blockquote><p><code>override</code>和<code>final</code>是 C++11 中加入的<strong>语境关键字（contextual keyword）</strong>，它们的特点是仅会在特定语境下才发挥被保留的意义，因此如果你有一些遗留代码，其中已经用过<code>override</code>和<code>final</code>作为名称的话，并不需要为它们改名。</p></blockquote><p><strong>函数引用限定符（reference qualifier）：</strong> 限制成员函数仅用于左值对象或右值对象。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>   <span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 仅在 *this 是左值时调用</span>   <span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 仅在 *this 是右值时调用</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Widget <span class="token function">makeWidget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Widget w<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>w<span class="token punctuation">.</span><span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 以左值调用 Widget::doWork &amp;</span><span class="token function">makeWidget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 以右值调用 Widget::doWork &amp;&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>带引用限定符的成员函数并不常见，但有时也是需要的。举例来说，假设我们的<code>Widget</code>类中有个<code>std::vector</code>类型的数据成员，我们提供一个函数让用户能对这个数据成员直接访问，但对于左值对象和右值对象有不同的行为：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> DataType <span class="token operator">=</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">;</span>    DataType<span class="token operator">&amp;</span> <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>              <span class="token comment" spellcheck="true">// 对于左值 Widget 类型，返回左值</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> values<span class="token punctuation">;</span> <span class="token punctuation">}</span>    DataType <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>              <span class="token comment" spellcheck="true">// 对于右值 Widget 类型，返回右值</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>values<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    DataType values<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Widget <span class="token function">makeWidget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Widget w<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">auto</span> vals1 <span class="token operator">=</span> w<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 调用 Widget::data 的左值重载版本</span>                                    <span class="token comment" spellcheck="true">// vals1 采用拷贝构造完成初始化</span><span class="token keyword">auto</span> vals2 <span class="token operator">=</span> <span class="token function">makeWidget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 调用 Widget::data 的右值重载版本</span>                                    <span class="token comment" spellcheck="true">// vals2 采用移动构造完成初始化</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-13：优先选用-const-iterator，而非-iterator"><a href="#条款-13：优先选用-const-iterator，而非-iterator" class="headerlink" title="条款 13：优先选用 const_iterator，而非 iterator"></a>条款 13：优先选用 const_iterator，而非 iterator</h3><p><code>const_iterator</code>是 STL 中提供的与指向 const 的指针含义相同之物，它们指向不可被修改的值。任何时候只要你需要一个迭代器而其所指向的内容没有修改的必要，那就应该使用 const_iterator。</p><p>但在 C++98 中，<code>const_iterator</code>得到的支持不够全面，想要获取它们就很不容易，而获取到了以后使用它们的方法也很受限。例如在 C++98 中，我们会被迫写出以下代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator IterT<span class="token punctuation">;</span><span class="token keyword">typedef</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>const_iterator ConstIterT<span class="token punctuation">;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> values<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>ConstIterT ci <span class="token operator">=</span>     std<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>ConstIterT<span class="token operator">></span><span class="token punctuation">(</span>values<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>              <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>ConstIterT<span class="token operator">></span><span class="token punctuation">(</span>values<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>              <span class="token number">1983</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// const_iterator 作为参数，返回 const_iterator</span>values<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>IterT<span class="token operator">></span><span class="token punctuation">(</span>ci<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1998</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// C++98 中 insert 只能接受 iterator</span>                                                <span class="token comment" spellcheck="true">// 从 const_iterator 到 iterator 不存在可移植的类型转换</span>                                                <span class="token comment" spellcheck="true">// 可能无法通过编译</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而在 C++11 中，这些现象得到了彻底的改变，获取和使用<code>const_iterator</code>都变得容易了。要把原始的、使用<code>iterator</code>的 C++98 代码修改成使用<code>const_iterator</code>的 C++11 代码也很简单：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> values<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">auto</span> it <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span>values<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> values<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1983</span><span class="token punctuation">)</span><span class="token punctuation">;</span>values<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> <span class="token number">1998</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++11 对于<code>const_iterator</code>支持的唯一缺陷是只为<code>begin</code>和<code>end</code>提供了对应的非成员函数版本，而没有为<code>cbegin</code>、<code>cend</code>、<code>rbegin</code>、<code>cend</code>、<code>crbegin</code>和<code>crend</code>这些返回<code>const_iterator</code>的函数提供对应的非成员函数版本，这个问题在 C++14 中得到了解决。想要自己实现它们也很简单，如下就是非成员函数版本的<code>cbegin</code>的一个实现方式：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token keyword">const</span> C<span class="token operator">&amp;</span> container<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>该模板在传入一个内建数组时也管用，此时<code>container</code>会成为一个 const 数组的引用。</p><blockquote><p>C++11 的非成员函数版本的<code>begin</code>为内建数组提供了一个特化版本，它返回一个指向数组首元素的指针。由于 const 数组的元素都为 const，所以若给<code>begin</code>传入一个 const 数组，则返回的指针是个指向 const 的指针，即数组意义下的 const_iterator。</p></blockquote><p>由于内建数组和第三方库的存在，最通用化的代码往往不会假定成员函数的存在，而是更多地采用非成员函数版本，例如以下<code>findAndInsert</code>模板的通用形式：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> C<span class="token punctuation">,</span> <span class="token keyword">typename</span> V<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">findAndInsert</span><span class="token punctuation">(</span>C<span class="token operator">&amp;</span> container<span class="token punctuation">,</span> <span class="token keyword">const</span> V<span class="token operator">&amp;</span> targetVal<span class="token punctuation">,</span> <span class="token keyword">const</span> V<span class="token operator">&amp;</span> insertVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">using</span> std<span class="token operator">::</span>cbegin<span class="token punctuation">;</span>    <span class="token keyword">using</span> std<span class="token operator">::</span>cend<span class="token punctuation">;</span>    <span class="token keyword">auto</span> it <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token function">cbegin</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cend</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">,</span> targetVal<span class="token punctuation">)</span><span class="token punctuation">;</span>    container<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> insertVal<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-14：只要函数不会抛出异常，就为其加上-noexcept-声明"><a href="#条款-14：只要函数不会抛出异常，就为其加上-noexcept-声明" class="headerlink" title="条款 14：只要函数不会抛出异常，就为其加上 noexcept 声明"></a>条款 14：只要函数不会抛出异常，就为其加上 noexcept 声明</h3><p>在 C++11 中，C++98 风格的异常规范已经被弃用，而转为为不会抛出异常的函数提供<code>noexcept</code>声明，函数是否要加上这个声明，事关接口声明。</p><p>调用方可以查询函数的<code>noexcept</code>状态，而查询结果可能会影响调用代码的异常安全性和运行效率。这么一来，函数是否带有<code>noexcept</code>声明就是和成员函数是否带有 const 声明同等重要的信息。当你明明知道一个函数不会抛出异常却未给它加上<code>noexcept</code>声明的话，就属于接口规格设计缺陷。</p><p>相当于不带<code>noexcept</code>声明的函数，带有<code>noexcept</code>声明的函数有更多机会得到优化：</p><pre class="line-numbers language-cpp"><code class="language-cpp">RetType <span class="token function">function</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 最优化</span>RetType <span class="token function">function</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 优化不足</span>RetType <span class="token function">function</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 优化不足</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在带有<code>noexcept</code>声明的函数中，优化器不需要在异常传出函数的前提下，将运行时栈保持在可展开状态；也不需要在异常逸出函数的前提下，保证所有其中的对象以其被构造顺序的逆序完成析构。而那些以<code>throw()</code>异常规格声明的函数就享受不到这样的优化灵活性，和那些没有加上异常规格的函数一样。</p><p><code>noexcept</code>属性对于移动操作、swap、内存释放函数和析构函数最有价值。C++11 STL 中的大部分函数遵循 “能移动则移动，必须复制才复制” 策略，但这必须保证在使用移动操作代替复制操作后，函数依旧具备强异常安全性。为了得知移动操作会不会产生异常，就需要校验这个操作是否带有<code>noexcept</code>声明。</p><p><code>swap</code>函数是许多 STL 算法实现的核心组件，它的广泛使用昭示着针对其实施<code>noexcept</code>声明带来的收益是可观的。标准库中的<code>swap</code>是否带有<code>noexcept</code>声明，取决于用户定义的<code>swap</code>自身。例如，标准库为数组和<code>std::pair</code>准备的<code>swap</code>函数如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> size_t N<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token function">T</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>          <span class="token function">T</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T2</span><span class="token operator">></span><span class="token keyword">struct</span> pair <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>pair<span class="token operator">&amp;</span> p<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token function">swap</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> p<span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                                <span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token function">swap</span><span class="token punctuation">(</span>second<span class="token punctuation">,</span> p<span class="token punctuation">.</span>second<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些函数带有条件式<code>noexcept</code>声明，它们到底是否具备<code>noexcept</code>属性，取决于它的<code>noexcept</code>分句中的表达式是否结果为<code>noexcept</code>。在此处，数组和<code>std::pair</code>的<code>swap</code>具备<code>noexcept</code>属性的前提是，其每一个元素的<code>swap</code>都具备<code>noexcept</code>属性。</p><p>对于某些函数来说，具备<code>noexcept</code>属性是如此之重要，所以它们默认就是如此。在 C++11 中，内存释放函数和所有的析构函数都默认隐式地具备<code>noexcept</code>属性。析构函数未隐式地具备<code>noexcept</code>属性的唯一情况，就是所有类中有数据成员（包括继承而来的成员，以及在其他数据成员中包含的数据成员）的类型显式地将其析构函数声明为<code>noexcept(false)</code>，即可能抛出异常。</p><blockquote><p>不具备<code>noexcept</code>属性的析构函数很少见，标准库里一个都没有，而如果标准库使用了某个对象，其析构函数抛出了异常，则该行为是未定义的。</p></blockquote><p>大多数函数都是<strong>异常中立（exception-neutral）</strong> 的，不具备<code>noexcept</code>属性。此类函数自身并不抛出异常，但它们调用的函数可能会抛出异常，这些异常会经由异常中立函数传至调用栈的更深一层。</p><p>C++ 允许带有<code>noexcept</code>声明的函数依赖于缺乏<code>noexcept</code>保证的代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>    <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>值得一提的是，有些库的接口设计者会把函数区分为带有<strong>宽松规约（wide constract）</strong> 和带有<strong>狭隘规约（narrow constract）</strong> 的不同种类。带有宽松规约的函数是没有前置条件的，要调用这样的函数也无须关心程序状态；而对于带有狭隘规约的函数，如果前置条件被违反，则结果将成为未定义的。一般而言，我们只会把<code>noexcept</code>声明保留给那些带有宽松规约的函数。</p><h3 id="条款-15：只要有可能使用-constexpr，就使用它"><a href="#条款-15：只要有可能使用-constexpr，就使用它" class="headerlink" title="条款 15：只要有可能使用 constexpr，就使用它"></a>条款 15：只要有可能使用 constexpr，就使用它</h3><p><strong><code>constexpr</code>对象：</strong> 具备 const 属性，并由编译期已知的值完成初始化。</p><p>在编译阶段就已知的值拥有许多特权，它们可能被放置在只读内存里（对于嵌入式开发尤为重要）；在编译阶段就已知的常量整型值可以用在 C++ 要求整型常量表达式的语境中，包括数组的尺寸规格、整型模板实参、枚举量的值、对齐规格等，如下所示：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> sz<span class="token punctuation">;</span>                             <span class="token comment" spellcheck="true">// 非 constexpr 变量</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">const</span> <span class="token keyword">auto</span> arraySize <span class="token operator">=</span> sz<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 正确，arraySize 是 sz 的一个 const 副本</span>std<span class="token operator">::</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> arraySize<span class="token operator">></span> data<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 错误！arraySize 的值非编译期可知</span><span class="token keyword">constexpr</span> <span class="token keyword">auto</span> arraySize1 <span class="token operator">=</span> sz<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 错误！sz 的值在编译期未知</span>std<span class="token operator">::</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> sz<span class="token operator">></span> data1<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 错误！问题同上</span><span class="token keyword">constexpr</span> <span class="token keyword">auto</span> arraySize2 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 正确，10 是编译期常量</span>std<span class="token operator">::</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> arraySize2<span class="token operator">></span> data2<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 正确，arraySize2 是编译期常量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><code>constexpr</code>函数：</strong></p><ul><li><code>constexpr</code>函数可以用在要求编译期常量的语境中。在这种情况下，若传给一个<code>constexpr</code>函数的实参值是在编译期已知的，则结果也会在编译期计算出来；如果任何一个实参值在编译期未知，则代码将无法通过编译。</li><li><code>constexpr</code>函数也可以运用在非编译期常量的语境中，此时传入的值可以有一个或多个在编译期未知。它的运作方式和普通函数无异，同样在运行期完成结果的计算。</li><li>在 C++11 中，<code>constexpr</code>函数不得包含多于一个可执行语句，即一条<code>return</code>语句；而到了 C++14，就没有了这种限制。</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token keyword">int</span> base<span class="token punctuation">,</span> <span class="token keyword">int</span> exp<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// C++11</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>exp <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> base <span class="token operator">*</span> <span class="token function">pow</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> exp <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token keyword">int</span> base<span class="token punctuation">,</span> <span class="token keyword">int</span> exp<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// C++14</span>    <span class="token keyword">auto</span> result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> exp<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> result <span class="token operator">*</span><span class="token operator">=</span> base<span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">constexpr</span> <span class="token keyword">auto</span> numConds <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>std<span class="token operator">::</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> numConds<span class="token punctuation">)</span><span class="token operator">></span> results<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>constexpr</code>函数仅限于传入和返回<strong>字面类型（literal type）</strong>，这些类型能够持有编译期可以决议的值。在 C++11 中，除了<code>void</code>的所有内建类型都是字面类型；此外，我们也可以自定义字面类型，这需要将其构造函数和部分成员函数声明为<code>constexpr</code>函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">constexpr</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">double</span> xVal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">double</span> yVal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token operator">:</span>        <span class="token function">x</span><span class="token punctuation">(</span>xVal<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>yVal<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">constexpr</span> <span class="token keyword">double</span> <span class="token function">xValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">constexpr</span> <span class="token keyword">double</span> <span class="token function">yValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">setX</span><span class="token punctuation">(</span><span class="token keyword">double</span> newX<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> x <span class="token operator">=</span> newX<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">setY</span><span class="token punctuation">(</span><span class="token keyword">double</span> newY<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> y <span class="token operator">=</span> newY<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">double</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">constexpr</span> Point <span class="token function">p1</span><span class="token punctuation">(</span><span class="token number">9.4</span><span class="token punctuation">,</span> <span class="token number">27.7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 在编译期执行 constexpr 构造函数</span><span class="token keyword">constexpr</span> Point <span class="token function">p2</span><span class="token punctuation">(</span><span class="token number">28.8</span><span class="token punctuation">,</span> <span class="token number">5.3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 同上</span><span class="token keyword">constexpr</span> Point <span class="token function">midpoint</span><span class="token punctuation">(</span><span class="token keyword">const</span> Point<span class="token operator">&amp;</span> p1<span class="token punctuation">,</span> <span class="token keyword">const</span> Point<span class="token operator">&amp;</span> p2<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">xValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> p2<span class="token punctuation">.</span><span class="token function">xValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span>             <span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">yValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> p2<span class="token punctuation">.</span><span class="token function">yValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用 constexpr 成员函数</span><span class="token punctuation">}</span><span class="token keyword">constexpr</span> <span class="token keyword">auto</span> mid <span class="token operator">=</span> <span class="token function">midpoint</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 使用 constexpr 函数的返回值来初始化 constexpr 对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 C++14 中，就连返回值类型为<code>void</code>的 setter 函数也可以声明为<code>constexpr</code>函数，这就使以下代码变为可能：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">constexpr</span> <span class="token keyword">void</span> <span class="token function">setX</span><span class="token punctuation">(</span><span class="token keyword">double</span> newX<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> x <span class="token operator">=</span> newX<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">constexpr</span> <span class="token keyword">void</span> <span class="token function">setY</span><span class="token punctuation">(</span><span class="token keyword">double</span> newY<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> y <span class="token operator">=</span> newY<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">constexpr</span> Point <span class="token function">reflection</span><span class="token punctuation">(</span><span class="token keyword">const</span> Point<span class="token operator">&amp;</span> p<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>    Point result<span class="token punctuation">;</span>    result<span class="token punctuation">.</span><span class="token function">setX</span><span class="token punctuation">(</span><span class="token operator">-</span>p<span class="token punctuation">.</span><span class="token function">xValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    result<span class="token punctuation">.</span><span class="token function">setY</span><span class="token punctuation">(</span><span class="token operator">-</span>p<span class="token punctuation">.</span><span class="token function">yValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">constexpr</span> <span class="token keyword">auto</span> reflectionMid <span class="token operator">=</span> <span class="token function">reflection</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，一旦你把一个对象或函数声明成了<code>constexpr</code>，而后来你又感觉对<code>constexpr</code>运用不当，然后进行了移除，那么这会导致非常多客户代码无法通过编译。因此，“只要有可能使用<code>constexpr</code>，就使用它” 这句话中的 “只要有可能” 的含义就是你是否有一个长期的承诺，将由<code>constexpr</code>带来的种种限制施加于相关的函数和对象上。</p><h3 id="条款-16：保证-const-成员函数的线程安全性"><a href="#条款-16：保证-const-成员函数的线程安全性" class="headerlink" title="条款 16：保证 const 成员函数的线程安全性"></a>条款 16：保证 const 成员函数的线程安全性</h3><p>对于 const 成员函数，我们通常认为它代表的是读操作，而多个线程在没有同步的情况下执行读操作应该是安全的。因此，我们需要保证 const 成员函数的线程安全性，除非可以确信它们不会在并发语境中被使用。</p><p>考虑如下情形，我们将计算出的多项式的根存入缓存中，以避免代价高昂的重复计算：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Polynomial</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> RootsType <span class="token operator">=</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">;</span>    RootsType <span class="token function">roots</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rootsAreValid<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// 如果缓存无效</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            rootsAreValid <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 则计算根，并将其存入 rootVals</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> rootsVals<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">mutable</span> <span class="token keyword">bool</span> rootsAreValid<span class="token punctuation">{</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">mutable</span> RootsType rootVals<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于 mutable 成员变量的存在，可能有不同的多个线程通过<code>roots</code>成员函数在没有同步的情况下读写同一块内存，造成<strong>数据竞争（data race）</strong>，这会导致未定义行为的出现。</p><p>有两种方法可以解决这个问题，最简单的方法也是最常见的，引入一个 mutex 互斥量：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Polynomial</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> RootsType <span class="token operator">=</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">;</span>    RootsType <span class="token function">roots</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">g</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 互斥量加锁</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rootsAreValid<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// 如果缓存无效</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            rootsAreValid <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 则计算根，并将其存入 rootVals</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> rootsVals<span class="token punctuation">;</span>    <span class="token punctuation">}</span>                                       <span class="token comment" spellcheck="true">// 互斥量解锁</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">mutable</span> std<span class="token operator">::</span>mutex m<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 添加 mutable 的互斥量</span>    <span class="token keyword">mutable</span> <span class="token keyword">bool</span> rootsAreValid<span class="token punctuation">{</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">mutable</span> RootsType rootVals<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一种方法是使用<code>std::atomic</code>类型的变量，这会比使用互斥量提供更好的性能，但更适用于对单个变量或内存区域的操作。以下情况更适合使用<code>std::atomic</code>来确保线程安全性：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">double</span> <span class="token function">distanceFromOrigin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>        <span class="token operator">++</span>callCount<span class="token punctuation">;</span>                                <span class="token comment" spellcheck="true">// 带原子性的自增操作</span>        <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">*</span> x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>y <span class="token operator">*</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">mutable</span> std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">unsigned</span><span class="token operator">></span> callCount<span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 存储调用次数</span>    <span class="token keyword">double</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>无论是<code>std::mutex</code>还是<code>std::atomic</code>都是只移类型，无法进行复制，因此加入它们都会使类失去可复制性，但仍然可以移动。</p><h3 id="条款-17：理解特殊成员函数的生成机制"><a href="#条款-17：理解特殊成员函数的生成机制" class="headerlink" title="条款 17：理解特殊成员函数的生成机制"></a>条款 17：理解特殊成员函数的生成机制</h3><p>在 C++11 中，支配特殊成员函数的机制如下（所有生成的默认特殊函数都是 inline 的，且具有 public 访问权限）：</p><ul><li><strong>默认构造函数：</strong> 与 C++98 的机制相同。仅当类中不包含用户声明的构造函数时才生成。</li><li><strong>析构函数：</strong> 与 C++98 的机制基本相同，唯一的区别在于析构函数默认为 noexcept（参考<strong>条款 14</strong>）。仅当基类的析构函数为虚时，派生类的析构函数才为虚。</li><li><strong>拷贝构造函数：</strong> 运行期行为与 C++98 相同：<strong>按成员</strong>进行<strong>非静态</strong>数据成员的拷贝构造。仅当类中不包含用户声明的拷贝构造函数时才生成。如果该类声明了移动操作，则拷贝构造函数将被删除。在已经存在拷贝赋值运算符或析构函数的情况下，仍然生成拷贝构造函数已经成为了被废弃的行为（但未被禁止），原因见三者法则。</li><li><strong>拷贝赋值运算符：</strong> 运行期行为与 C++98 相同：<strong>按成员</strong>进行<strong>非静态</strong>数据成员的拷贝赋值。仅当类中不包含用户声明的拷贝赋值运算符时才生成。如果该类声明了移动操作，则拷贝赋值运算符将被删除。在已经存在拷贝构造函数或析构函数的情况下，仍然生成拷贝构造函数已经成为了被废弃的行为（但未被禁止），原因见三者法则。</li></ul><blockquote><p><strong>三者法则（Rule of Three）：</strong> 如果你声明了拷贝构造函数、拷贝赋值运算符或析构函数中的任何一个，你就得同时声明所有这三个。<br>三者法则根植于这样的思想：如果有改写拷贝操作的需求，往往意味着该类需要执行某种资源管理，而这就意味着：  </p><ol><li>在一种拷贝操作中进行的任何资源管理，也极有可能在另一种拷贝操作中也需要进行。  </li><li>该类的析构函数也会参与到该资源的管理中（通常是对资源进行释放）。<br>三者法则对移动操作也同样成立。</li></ol></blockquote><ul><li><strong>移动构造函数和移动赋值运算符：</strong> 都<strong>按成员</strong>进行<strong>非静态</strong>数据成员的移动操作。仅当类中不包含用户声明的拷贝操作、移动操作和析构函数时才生成。声明一个移动构造函数会阻止编译器生成移动赋值运算符，而声明一个移动赋值运算符也会阻止编译器生成移动构造函数。</li></ul><blockquote><p>声明拷贝操作（无论是拷贝构造还是拷贝赋值）的行为表明了对象的常规拷贝方式（按成员拷贝）对于该类并不适用，那么编译器就会认为按成员移动极有可能也不适用于移动操作。因此，一旦显式声明了拷贝操作，编译器就不再会为其生成移动操作，反之亦然。</p></blockquote><p>如果你有一些代码依赖于编译器自动生成的特殊函数，并且你确信这些函数会正确执行，那么可以用<code>=default</code>显式指定让它们生成：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 使析构函数成为虚的</span>    <span class="token function">Base</span><span class="token punctuation">(</span>Base<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// 提供移动操作的支持</span>    Base<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Base<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">const</span> Base<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 提供拷贝操作的支持</span>    Base<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Base<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>成员函数模板在任何情况下都不会抑制特殊成员函数的生成，例如下面这个类：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>    <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 以任意类型构造 Widget</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>    Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 以任意类型对 Widget 赋值</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译器会始终生成<code>Widget</code>的拷贝和移动操作，即使这些模板的具现化生成了拷贝构造函数和拷贝赋值运算符的函数签名。</p><h2 id="第四章：智能指针"><a href="#第四章：智能指针" class="headerlink" title="第四章：智能指针"></a>第四章：智能指针</h2><p>以下理由使得裸指针不受欢迎：</p><ol><li>裸指针没有在声明中指出，其指向的内容是单个对象还是数组。</li><li>裸指针没有在声明中指出，是否该在其指向的对象使用完后进行析构。</li><li>无法得知怎样析构裸指针才是适当的，是使用<code>delete</code>运算符，还是有专门用于析构的函数。</li><li>在已知使用<code>delete</code>的情况下，难以确定该用<code>delete</code>还是<code>delete[]</code>。</li><li>很难保证对指针所指向对象的析构，在所有代码路径上只执行一次。</li><li>没有正规的方式来检测指针是否空悬（dangle）。</li></ol><p>因此，在大多数时候，应该优先选用智能指针。<code>std::auto_ptr</code>是从 C++98 中残留下来的弃用特性，应该被 C++11 中的 <code>std::unique_ptr</code>所替代。</p><h3 id="条款-18：使用-std-unique-ptr-管理具备专属所有权的资源"><a href="#条款-18：使用-std-unique-ptr-管理具备专属所有权的资源" class="headerlink" title="条款 18：使用 std::unique_ptr 管理具备专属所有权的资源"></a>条款 18：使用 std::unique_ptr 管理具备专属所有权的资源</h3><p><code>std::unique_ptr</code>是小巧、高速的、具备只移类型的智能指针，对于托管的指针实施专属所有权语义。它和裸指针所占大小相同，并且不允许被拷贝，在执行析构操作时，同时析构其所管理的资源。</p><p><code>std::unique_ptr</code>的一个常见用法是在继承体系中，作为工厂函数的返回值类型：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Investment</span> <span class="token punctuation">{</span>     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Investment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 必备的虚析构函数！</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Stock</span> <span class="token operator">:</span> <span class="token keyword">public</span> Investment <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Bond</span> <span class="token operator">:</span> <span class="token keyword">public</span> Investment <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">RealEstate</span> <span class="token operator">:</span> <span class="token keyword">public</span> Investment <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Investment<span class="token operator">></span> <span class="token function">makeInvestment</span><span class="token punctuation">(</span>Ts<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回 std::unique_ptr</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">auto</span> pInvestment <span class="token operator">=</span> <span class="token function">makeInvestment</span><span class="token punctuation">(</span> arguments <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// *pInvestment 在此处析构</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认地，资源析构采用<code>delete</code>运算符来完成，但也可以指定自定义删除器，并且删除器将会被视作<code>std::unique_ptr</code>类型的一部分。下面的例子中使用了 lambda 表达式作为自定义删除器，并在删除时写入一条日志：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> delInvmt <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Investment<span class="token operator">*</span> pInvestment<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">makeLogEntry</span><span class="token punctuation">(</span>pInvestment<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> pInvestment<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Investment<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>delInvmt<span class="token punctuation">)</span><span class="token operator">></span> <span class="token function">makeInvestment</span><span class="token punctuation">(</span>Ts<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 改进后的返回值类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 C++14 中，由于有了函数返回值类型推导（参考<strong>条款 3</strong>），<code>makeInvestment</code>可以用更加简单的、封装性更好的方法实现，自定义删除器也可以放在函数内部，完整的代码演示如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">makeInvestment</span><span class="token punctuation">(</span>Ts<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 现在自定义删除器位于函数内部</span>    <span class="token keyword">auto</span> delInvmt <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Investment<span class="token operator">*</span> pInvestment<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">makeLogEntry</span><span class="token punctuation">(</span>pInvestment<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">delete</span> pInvestment<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Investment<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>delInvmt<span class="token punctuation">)</span><span class="token operator">></span> <span class="token function">pInv</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">,</span> delInvmt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 待返回的指针</span>    <span class="token comment" spellcheck="true">// 使用 reset 来让 pInv 获取 new 产生的对象的所有权</span>    <span class="token comment" spellcheck="true">// 对每一次 new 的调用结果，都使用 std::forward 对实参进行完美转发（参考条款 25）</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token comment" spellcheck="true">/* 应创建一个 Stock 类型的对象 */</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        pInv<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Stock</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Ts<span class="token operator">></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token comment" spellcheck="true">/* 应创建一个 Bond 类型的对象 */</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        pInv<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Bond</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Ts<span class="token operator">></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token comment" spellcheck="true">/* 应创建一个 RealEstate 类型的对象 */</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        pInv<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">RealEstate</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Ts<span class="token operator">></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> pInv<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在使用自定义删除器后，<code>std::unique_ptr</code>的大小可能不再和裸指针相同：有状态的删除器和采用函数指针的删除器会增加<code>std::unique_ptr</code>类型的对象尺寸大小。无状态的函数对象（例如无捕获的 lambda 表达式）不会浪费任何存储内存，而函数指针通常会使<code>std::unique_ptr</code>的大小增加一到两个字长（word），这意味着无捕获的 lambda 表达式往往是用作删除器的最佳选择。</p><p><code>std::unique_ptr</code>提供了两种形式，一种是单个对象（<code>std::unique_ptr&lt;T&gt;</code>），另一种是数组（<code>std::unique_ptr&lt;T[]&gt;</code>）。为了避免二义性，单个对象形式不提供索引运算符（<code>operator[]</code>），而数组形式不提供解引用运算符（<code>operator*</code>和<code>operator-&gt;</code>）。但实际上，数组形式用到的场合非常少，唯一的应用场合大概是在使用 C 风格 API 时，它返回了存放在堆上的裸指针；大部分时候我们会优先考虑<code>std::array</code>、<code>std::vector</code>和<code>std::string</code>这些数据结构。</p><p><code>std::unique_ptr</code>可以方便高效地转换为<code>std::shared_ptr</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Investment<span class="token operator">></span> sp <span class="token operator">=</span> <span class="token function">makeInvestment</span><span class="token punctuation">(</span> arguments <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="条款-19：使用-std-shared-ptr-管理具备共享所有权的资源"><a href="#条款-19：使用-std-shared-ptr-管理具备共享所有权的资源" class="headerlink" title="条款 19：使用 std::shared_ptr 管理具备共享所有权的资源"></a>条款 19：使用 std::shared_ptr 管理具备共享所有权的资源</h3><p><code>std::shared_ptr</code>提供了方便的手段，实现了任意资源在共享所有权语义下进行生命周期管理的垃圾回收。与<code>std::unique_ptr</code>相比，<code>std::shared_ptr</code>所占大小通常是裸指针的两倍，它还会带来控制块的开销，并且要求成本高昂的原子化的引用计数操作。</p><p>默认的资源析构通过<code>delete</code>运算符来完成，但同时也支持自定义删除器。与<code>std::unique_ptr</code>不同的是，删除器的类型对<code>std::shared_ptr</code>的类型没有影响，也不会影响<code>std::shared_ptr</code>的尺寸大小：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> loggingDel <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Widget<span class="token operator">*</span> pw<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">makeLogEntry</span><span class="token punctuation">(</span>pw<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> pw<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>loggingDel<span class="token punctuation">)</span><span class="token operator">></span> <span class="token function">upw</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> loggingDel<span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span>                       <span class="token function">spw</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> loggingDel<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这使得<code>std::shared_ptr</code>的设计更具弹性，拥有不同类型自定义删除器的<code>std::shared_ptr</code>也可以被放在同一个容器中：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> customDeleter1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Widget<span class="token operator">*</span> pw<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 自定义删除器</span><span class="token keyword">auto</span> customDeleter2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Widget<span class="token operator">*</span> pw<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 各有不同的类型</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">pw1</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> customDeleter1<span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">pw2</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> customDeleter2<span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">>></span> vpw<span class="token punctuation">{</span> pw1<span class="token punctuation">,</span> pw2 <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>控制块（control block）：</strong> 每一个由<code>std::shared_ptr</code>管理的对象都拥有一个控制块，它的内存被动态分配在堆上，除了包含引用计数以外，还包含作用于<code>std::weak_ptr</code>的弱计数（参考<strong>条款 20</strong>），自定义删除器以及从分配器等内容。</p><p>一个对象的控制块应该在创建首个指向该对象的<code>std::shared_ptr</code>时确定，因此，控制块的创建遵循以下规则：</p><ol><li>使用<code>std::make_shared</code>（参考<strong>条款 21</strong>）总是会创建一个控制块。</li><li>从具备专属所有权的指针（<code>std::unique_ptr</code>或<code>std::auto_ptr</code>）出发构造一个<code>std::shared_ptr</code>时，会创建一个控制块。</li><li>用裸指针作为实参调用<code>std::shared_ptr</code>的构造函数时，会创建一个控制块。</li></ol><p>由以上规则我们可以得出，应该避免使用裸指针类型的变量来创建<code>std::shared_ptr</code>。用同一个裸指针构造出不止一个<code>std::shared_ptr</code>将会使对象拥有多重的控制块，这会导致对资源的多次析构，产生未定义行为，如下所示：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> pw <span class="token operator">=</span> <span class="token keyword">new</span> Widget<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// pw 是个裸指针</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw1</span><span class="token punctuation">(</span>pw<span class="token punctuation">,</span> loggingDel<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw2</span><span class="token punctuation">(</span>pw<span class="token punctuation">,</span> loggingDel<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>应该改为：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw1</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> loggingDel<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw2</span><span class="token punctuation">(</span>spw1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当你希望一个托管到<code>std::shared_ptr</code>的类能够安全地由<code>this</code>指针创建一个<code>std::shared_ptr</code>时，应该使该类继承自<code>std::enable_shared_from_this</code>，如下所示：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token operator">:</span> <span class="token keyword">public</span> std<span class="token operator">::</span>enable_shared_from_this<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>std::enable_shared_from_this</code>定义了一个成员函数<code>std::shared_from_this</code>，它会创建一个<code>std::shared_ptr</code>指向当前对象，但不会重复创建控制块：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">>></span> processedWidget<span class="token punctuation">;</span><span class="token keyword">void</span> Widget<span class="token operator">::</span><span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 处理对象本身</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 将指向当前对象的 std::shared_ptr 加入 processedWidget</span>    processedWidget<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了避免用户在<code>std::shared_ptr</code>指向该对象前就调用了<code>std::shared_from_this</code>（这会导致其无法查询到对象拥有的控制块，产生未定义行为），继承自<code>std::enable_shared_from_this</code>的类通常会将其构造函数声明为 private，并且只允许通过调用返回<code>std::shared_ptr</code>的工厂函数来创建对象。例如，以下是<code>Widget</code>类的一个可能实现：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token operator">:</span> <span class="token keyword">public</span> std<span class="token operator">::</span>enable_shared_from_this<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">// 将实参完美转发给 private 构造函数的工厂函数</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span>    <span class="token keyword">static</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">create</span><span class="token punctuation">(</span>Ts<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token function">Widget</span><span class="token punctuation">(</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 构造函数</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>std::unique_ptr</code>可以轻易转换为<code>std::shared_ptr</code>，反之却并不成立，一旦资源的生存期被托管给了<code>std::shared_ptr</code>，就不能回收该资源的所有权，并让一个<code>std::unique_ptr</code>来托管它。并且和<code>std::unique_ptr</code>不同，<code>std::shared_ptr</code>直到 C++17 才拥有处理数组的能力（<code>std::shared_ptr&lt;T[]&gt;</code>），在 C++11/14 中，它的 API 仅被设计用来处理指向单个对象的指针。</p><h3 id="条款-20：对于类似-std-shared-ptr-但有可能空悬的指针使用-std-weak-ptr"><a href="#条款-20：对于类似-std-shared-ptr-但有可能空悬的指针使用-std-weak-ptr" class="headerlink" title="条款 20：对于类似 std::shared_ptr 但有可能空悬的指针使用 std::weak_ptr"></a>条款 20：对于类似 std::shared_ptr 但有可能空悬的指针使用 std::weak_ptr</h3><p><code>std::weak_ptr</code>并不是一种独立的智能指针，而是<code>std::shared_ptr</code>的一种扩充。它一般是通过<code>std::shared_ptr</code>来创建的，两者会指向相同位置，但<code>std::weak_ptr</code>并不影响所指向对象的引用计数，而是会影响控制块中的弱计数。</p><p>使用<code>expired</code>函数来检测<code>std::weak_ptr</code>的空悬：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> spw <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">wpw</span><span class="token punctuation">(</span>spw<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>spw <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// Widget 对象被析构，wpw 空悬</span><span class="token keyword">if</span> <span class="token punctuation">(</span>wpw<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 若 wpw 不再指向任何对象</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过<code>std::weak_ptr</code>创建<code>std::shared_ptr</code>，可以在未失效情况下提供对资源的访问：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 使用 lock 函数时，若 wpw 失效，则 spw1 和 spw2 为空</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> spw1 <span class="token operator">=</span> wpw<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> spw2 <span class="token operator">=</span> wpw<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 直接构造时，若 wpw 失效，则抛出 std::bad_weak_ptr 类型的异常</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw3</span><span class="token punctuation">(</span>wpw<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>std::weak_ptr</code>有以下可能的用武之地：</p><ul><li>创建带缓存的工厂函数：</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">const</span> Widget<span class="token operator">></span> <span class="token function">fastLoadWidget</span><span class="token punctuation">(</span>WidgetID id<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> std<span class="token operator">::</span>unordered_map<span class="token operator">&lt;</span>WidgetID<span class="token punctuation">,</span> std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span><span class="token keyword">const</span> Widget<span class="token operator">>></span> cache<span class="token punctuation">;</span>    <span class="token keyword">auto</span> objPtr <span class="token operator">=</span> cache<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果对象不在缓存中，则返回空指针</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>objPtr<span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token comment" spellcheck="true">// 加载并缓存对象</span>        objPtr <span class="token operator">=</span> <span class="token function">loadWidget</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        cache<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> objPtr<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> objPtr<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>观察者设计模式（Observer design pattern）：多个观察者（observer）对象同时监听一个主题（subject）对象，主题对象会在其发生状态改变时发出通知。主题对象不会控制其观察者的生存期，但需要确认当一个观察者对象被析构后，主题对象不会再访问它。一种合理的设计就是让每个主题对象持有指向其观察者对象的<code>std::weak_ptr</code>，以便在使用之前确认它是否空悬。</li><li>避免<code>std::shared_ptr</code>循环引用：</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>B<span class="token operator">></span> pb<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">></span> pa<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">auto</span> pa <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>A<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> pb <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>B<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pa<span class="token operator">-</span><span class="token operator">></span>pb <span class="token operator">=</span> pb<span class="token punctuation">;</span>pb<span class="token operator">-</span><span class="token operator">></span>pa <span class="token operator">=</span> pa<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这种情况下，<code>A</code>和<code>B</code>互相保存着指向对方的<code>std::shared_ptr</code>，产生了循环引用，两者会永久保持彼此的引用计数至少为一，这会阻止<code>A</code>和<code>B</code>被析构，实际上产生了内存泄漏。</p><p>将其中一者改为<code>std::weak_ptr</code>可以避免循环的产生：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>B<span class="token operator">></span> pb<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span>A<span class="token operator">></span> pa<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-21：优先选用-std-make-unique-和-std-make-shared，而非直接使用-new"><a href="#条款-21：优先选用-std-make-unique-和-std-make-shared，而非直接使用-new" class="headerlink" title="条款 21：优先选用 std::make_unique 和 std::make_shared，而非直接使用 new"></a>条款 21：优先选用 std::make_unique 和 std::make_shared，而非直接使用 new</h3><p><code>std::make_shared</code>是 C++11 的一部分，但<code>std::make_unique</code>到了 C++14 才被加入标准库，不过要写出一个基础版本的<code>std::make_unique</code>非常容易：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">make_unique</span><span class="token punctuation">(</span>Ts<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">T</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Ts<span class="token operator">></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>相对于直接使用<code>new</code>运算符，make 函数有以下优势：</p><ul><li>消除重复代码：</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> <span class="token function">upw1</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 使用 make 函数</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">upw2</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 不使用 make 函数</span><span class="token keyword">auto</span> <span class="token function">spw1</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 使用 make 函数</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw2</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 不使用 make 函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>改进了异常安全性：</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">processWidget</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">computePriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 有潜在的内存泄漏风险</span><span class="token function">processWidget</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">computePriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 不具有潜在的内存泄漏风险</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在直接使用<code>new</code>运算符的情况下，由于分配<code>Widget</code>对象、执行<code>std::shared_ptr</code>构造函数、执行<code>computePriority</code>函数三者并不存在固定顺序，<code>computePriority</code>函数可能会晚于<code>Widget</code>对象的分配，先于<code>std::shared_ptr</code>的构造函数执行，此时若<code>computePriority</code>产生异常，那么分配的<code>Widget</code>内存就会发生泄漏。使用<code>std::make_shared</code>则不会产生这个问题。</p><ul><li>使用<code>std::make_shared</code>和<code>std::allocate_shared</code>有助于生成的尺寸更小、速度更快的目标代码。</li></ul><blockquote><p><code>std::make_shared</code>会将指向的对象和与其相关联的控制块分配在单块内存中，这种优化减少了程序的静态尺寸，并且因为只进行一次内存分配，还可以加块代码的运行速度。使用<code>std::make_shared</code>还可以减少对控制块一些簿记信息（bookkeeping information）的需要，潜在地减少了程序的内存占用量（memory footprint）。<code>std::allocate_shared</code>也是同理。</p></blockquote><p>虽然有着如此多的优势，但还是有一些情形下，不能或者不应该使用 make 函数：</p><ul><li>使用 make 函数无法自定义删除器，以及直接传递大括号内的初始值设定项：</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 想要自定义删除器，就只能使用 new 运算符</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>widgetDeleter<span class="token punctuation">)</span><span class="token operator">></span> <span class="token function">upw</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> widgetDeleter<span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span>                          <span class="token function">spw</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> widgetDeleter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 只能间接传递初始化列表给 make 函数</span><span class="token keyword">auto</span> initList <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">auto</span> spv <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">(</span>initList<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>不建议对自定义内存管理方式的类使用 make 函数：通常情况下，类自定义的<code>operator new</code>和<code>operator delete</code>被设计成用来分配和释放能精确容纳该类大小的内存块，但<code>std::allocate_shared</code>所要求的内存大小并不等于动态分配对象的大小，而是在其基础上加上控制块的大小。因此，使用 make 函数去创建重载了<code>operator new</code>和<code>operator delete</code>类的对象，通常并不是个好主意。</li><li>当处于特别关注内存的系统中时，若存在非常大的对象和比相应的<code>std::shared_ptr</code>生存期更久的<code>std::weak_ptr</code>，不建议使用 make 函数：这会导致对象的析构和内存的释放之间产生延迟，而若直接使用<code>new</code>运算符，内存的释放就不必等待<code>std::weak_ptr</code>的析构。</li></ul><p>如果你发现自己处于不应该使用<code>std::make_shared</code>的情形下，又不想受到之前所述异常安全问题的影响。最好的方法是确保在直接使用<code>new</code>时，立即将结果传递给智能指针的构造函数，并且在这条语句中不做其它任何事：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> cusDel<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">processWidget</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>spw<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">computePriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="条款-22：使用-Pimpl-惯用法时，将特殊成员函数的定义放到实现文件中"><a href="#条款-22：使用-Pimpl-惯用法时，将特殊成员函数的定义放到实现文件中" class="headerlink" title="条款 22：使用 Pimpl 惯用法时，将特殊成员函数的定义放到实现文件中"></a>条款 22：使用 Pimpl 惯用法时，将特殊成员函数的定义放到实现文件中</h3><p>Pimpl 惯用法的第一部分，是声明一个指针类型的数据成员，指向一个非完整类型：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>    <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">struct</span> Impl<span class="token punctuation">;</span>    Impl<span class="token operator">*</span> pImpl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二部分是动态分配和回收持有原始类中数据成员的对象，而分配和回收的代码被放在实现文件中：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Widget<span class="token operator">::</span>Impl <span class="token punctuation">{</span>                   <span class="token comment" spellcheck="true">// Widget::Impl 的实现</span>    std<span class="token operator">::</span>string name<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 包含在原始 Widget 类中的数据成员</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> data<span class="token punctuation">;</span>    Gadget g1<span class="token punctuation">,</span> g2<span class="token punctuation">,</span> g3<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Widget<span class="token operator">::</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">pImpl</span><span class="token punctuation">(</span><span class="token keyword">new</span> Impl<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// 为 Widget 对象分配数据成员所需内存</span>Widget<span class="token operator">::</span><span class="token operator">~</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">delete</span> pImpl<span class="token punctuation">;</span> <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">// 为 Widget 对象析构数据成员</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面展示的是 C++98 的写法，使用了裸指针、裸<code>new</code>运算符和裸<code>delete</code>运算符。而到了 C++11，使用<code>std::unique_ptr</code>替代指向<code>Impl</code>的裸指针成为了首选：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 声明代码位于头文件 widget.h 内</span><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>    <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">struct</span> Impl<span class="token punctuation">;</span>    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Impl<span class="token operator">></span> pImpl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 实现代码位于实现文件 widget.cpp 内</span><span class="token keyword">struct</span> Widget<span class="token operator">::</span>Impl <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 同前</span>    std<span class="token operator">::</span>string name<span class="token punctuation">;</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> data<span class="token punctuation">;</span>    Gadget g1<span class="token punctuation">,</span> g2<span class="token punctuation">,</span> g3<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Widget<span class="token operator">::</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">pImpl</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Impl<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>遗憾的是，这段代码本身能通过编译，但在创建对象时却会报错。因为编译器自动生成的析构函数默认是<code>inline</code>的，而<code>std::unique_ptr</code>的默认删除器要求其指向完整类型，所以即使默认特殊函数的实现有着正确行为，我们仍必须将其声明和实现分离：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 声明代码位于头文件 widget.h 内</span><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>    <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">struct</span> Impl<span class="token punctuation">;</span>    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Impl<span class="token operator">></span> pImpl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 实现代码位于实现文件 widget.cpp 内</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Widget<span class="token operator">::</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">pImpl</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Impl<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>Widget<span class="token operator">::</span><span class="token operator">~</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 写成 Widget::~Widget() = default; 效果相同</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<strong>条款 17</strong> 中我们提到，声明析构函数会阻止编译器生成移动操作，所以假如你需要支持移动操作，也必须采用声明和实现分离的方法：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 声明代码位于头文件 widget.h 内</span><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">Widget</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 实现代码位于实现文件 widget.cpp 内</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Widget<span class="token operator">::</span><span class="token function">Widget</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>Widget<span class="token operator">&amp;</span> Widget<span class="token operator">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译器不会为带有<code>std::unique_ptr</code>这种只移类型的类生成拷贝操作，假如你需要支持拷贝操作，则需要自行编写执行深拷贝的函数实现，并且同样需要遵守前面所说的规则：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 声明代码位于头文件 widget.h 内</span><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 实现代码位于实现文件 widget.cpp 内</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Widget<span class="token operator">::</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>    <span class="token operator">:</span> <span class="token function">pImpl</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Impl<span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">*</span>rhs<span class="token punctuation">.</span>pImpl<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>Widget<span class="token operator">&amp;</span> Widget<span class="token operator">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">*</span>pImpl <span class="token operator">=</span> <span class="token operator">*</span>rhs<span class="token punctuation">.</span>pImpl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述建议仅仅适用于<code>std::unique_ptr</code>，而不适用于<code>std::shared_ptr</code>。对于<code>std::shared_ptr</code>而言，删除器类型并非智能指针类型的一部分，这就会导致更大的运行时数据结构以及更慢的目标代码，但在使用编译器生成的特殊函数时，并不要求其指向完整类型。以下代码并不会产生问题：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>    <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token comment" spellcheck="true">// 不再需要析构函数或移动操作的声明</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">struct</span> Impl<span class="token punctuation">;</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Impl<span class="token operator">></span> pImpl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>就 Pimpl 惯用法而言，并不需要在<code>std::unique_ptr</code>和<code>std::shared_ptr</code>的特性之间作出权衡，因为<code>Widget</code>和<code>Impl</code>之间的关系是专属所有权，所以在此处<code>std::unique_ptr</code>就是完成任务的合适工具。</p><h2 id="第五章：右值引用、移动语义和完美转发"><a href="#第五章：右值引用、移动语义和完美转发" class="headerlink" title="第五章：右值引用、移动语义和完美转发"></a>第五章：右值引用、移动语义和完美转发</h2><p>在阅读本章中的条款时，需要铭记一点：形参总是左值，即使其类型是右值引用。例如给定函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>尽管形参<code>w</code>的类型是指向<code>Widget</code>对象的右值引用，可以传入绑定到右值的实参，但它仍然是个左值。</p><h3 id="条款-23：理解-std-move-和-std-forward"><a href="#条款-23：理解-std-move-和-std-forward" class="headerlink" title="条款 23：理解 std::move 和 std::forward"></a>条款 23：理解 std::move 和 std::forward</h3><p><code>std::move</code>执行的是向右值的无条件强制类型转换，就其自身而言，它不会移动任何东西。它的基本实现大致是这样的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// C++11 版本</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">typename</span> remove_reference<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">&amp;&amp;</span> <span class="token function">move</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">using</span> ReturnType <span class="token operator">=</span> <span class="token keyword">typename</span> remove_reference<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">&amp;&amp;</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>ReturnType<span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// C++14 版本</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> <span class="token function">move</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">using</span> ReturnType <span class="token operator">=</span> remove_reference_t<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;&amp;</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>ReturnType<span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>std::move</code>并不改变常量性，也不保证经过其强制类型转换后的对象可被移动，针对常量对象执行的移动操作可能会悄无声息地转化为拷贝操作，如下所示：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Annotation</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">explicit</span> <span class="token function">Annotation</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string text<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">value</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 想要将 text “移动入” value</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                     <span class="token comment" spellcheck="true">// 但实际上执行了 std::string 的拷贝构造函数</span>                                            <span class="token comment" spellcheck="true">// 而非移动构造函数 string(string&amp;&amp;)</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>string value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此，如果想要取得对某个对象执行移动操作的能力，就不要将其声明为常量。</p><p>与<code>std::move</code>不同，<code>std::forward</code>是有条件的。仅当传入的实参被绑定到右值时，<code>std::forward</code>才会针对该实参执行向右值的强制类型转换，它同样不会转发任何东西。</p><p><code>std::forward</code>的一个典型应用场景，是某个函数模板使用万能引用作为形参，随后将其传递给另一个函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> lvalArg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 处理左值</span><span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> rvalArg<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 处理右值</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">logAndProcess</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// 使用万能引用作为实参</span>    <span class="token keyword">auto</span> now <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>system_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">makeLogEntry</span><span class="token punctuation">(</span><span class="token string">"Calling 'process'"</span><span class="token punctuation">,</span> now<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">process</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若在调用<code>logAndProcess</code>时传入左值，那么该左值自然会传递给处理左值版本的<code>process</code>函数；若在调用<code>logAndProcess</code>时传入右值，由于函数形参皆为左值，必须要通过<code>std::forward</code>将<code>param</code>强制转换为右值类型，才能得以正确调用处理右值版本的<code>process</code>函数。<code>std::forward</code>会通过模板类型<code>T</code>来判断是否该对<code>param</code>进行强制类型转换，具体的原理细节参考<strong>条款 28</strong>。</p><p>尽管<code>std::move</code>和<code>std::forward</code>归根结底都是强制类型转换，但两者的行为具有本质上的不同：前者用于为移动操作进行铺垫，而后者仅仅用于转发一个对象到另一个函数，在此过程中该对象仍保持原来的左值性或右值性。</p><blockquote><p>需要注意的是，在运行期，<code>std::move</code>和<code>std::forward</code>都不会做任何操作。</p></blockquote><h3 id="条款-24：区分万能引用和右值引用"><a href="#条款-24：区分万能引用和右值引用" class="headerlink" title="条款 24：区分万能引用和右值引用"></a>条款 24：区分万能引用和右值引用</h3><p>如果函数模板形参的类型为<code>T&amp;&amp;</code>，并且 T 的类型需要推导得到，或一个对象使用<code>auto&amp;&amp;</code>声明其类型，则此处的<code>T&amp;&amp;</code>和<code>auto&amp;&amp;</code>表示<strong>万能引用（universal reference）</strong>；如果类型声明不是标准的<code>type&amp;&amp;</code>形式，或者并未发生类型推导，则此处的<code>type&amp;&amp;</code>表示右值引用。</p><p>符合万能引用的情形如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> var2 <span class="token operator">=</span> var1<span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Allocator</span> <span class="token operator">=</span> allocator<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token keyword">class</span> <span class="token class-name">vector</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span>    <span class="token keyword">void</span> <span class="token function">emplace_back</span><span class="token punctuation">(</span>Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">auto</span> timeFuncInvocation <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> func<span class="token punctuation">,</span> <span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// C++14</span>    std<span class="token operator">::</span>forward<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span>                         <span class="token comment" spellcheck="true">// 调用 func</span>        std<span class="token operator">::</span>forward<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>               <span class="token comment" spellcheck="true">// 取用 params</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类型声明不是标准<code>type&amp;&amp;</code>的情形如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// param 是右值引用</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// param 是右值引用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类型是<code>T&amp;&amp;</code>，但并未发生类型推导的情形如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Allocator</span> <span class="token operator">=</span> allocator<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token keyword">class</span> <span class="token class-name">vector</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// x 是右值引用</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若使用右值来初始化万能引用，就会得到一个右值引用；同理，若使用左值来初始化万能引用，就会得到一个左值引用。如下所示：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// param 是万能引用</span>Widget w<span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 左值被传递给 f，param 的类型为 Widget&amp;</span><span class="token function">f</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 右值被传递给 f，param 的类型为 Widget&amp;&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-25：针对右值引用实施-std-move，针对万能引用实施-std-forward"><a href="#条款-25：针对右值引用实施-std-move，针对万能引用实施-std-forward" class="headerlink" title="条款 25：针对右值引用实施 std::move，针对万能引用实施 std::forward"></a>条款 25：针对右值引用实施 std::move，针对万能引用实施 std::forward</h3><p>右值引用一定会被绑定到右值，因此当转发右值引用给其他函数时，应当通过<code>std::move</code>对其实施向右值的无条件强制类型转换：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Widget</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>          <span class="token function">p</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>string name<span class="token punctuation">;</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>SomeDataStructure<span class="token operator">></span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而万能引用不一定会被绑定到右值，因此当转发万能引用时，应当通过<code>std::forward</code>对其实施向右值的有条件强制类型转换：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>    <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> newName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        name <span class="token operator">=</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然针对右值引用实施<code>std::forward</code>也能硬弄出正确行为，但代码啰嗦、易错，且不符合习惯用法；而针对万能引用实施<code>std::move</code>会造成更加严重的后果，这会导致某些左值遭受意外的改动：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>    <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> newName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        name <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>string name<span class="token punctuation">;</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>SomeDataStructure<span class="token operator">></span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span>string <span class="token function">getWidgetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 工厂函数</span>Widget w<span class="token punctuation">;</span><span class="token keyword">auto</span> n <span class="token operator">=</span> <span class="token function">getWidgetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>w<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 将 n 移入 w</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                         <span class="token comment" spellcheck="true">// n 的值变为未知</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一种手法是将万能引用的版本改成对左值和右值分别进行重载：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> newName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        name <span class="token operator">=</span> newName<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string<span class="token operator">&amp;&amp;</span> newName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        name <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种手法虽然看似可以解决问题，但是拥有更大的缺点：第一，需要编写和维护更多源码；第二，效率会大打折扣（产生额外的临时对象）；第三，可扩展性太差。因此，正确地使用万能引用才是问题的唯一解决之道。</p><p>在有些情况下，你可能想在函数内将某个对象不止一次地绑定到右值引用或万能引用，并且想保证在完成对该对象地其它所有操作之前，其值不会发生移动，那么就得仅在最后一次使用该引用时，对其实施<code>std::move</code>或<code>std::forward</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">setSignText</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> text<span class="token punctuation">)</span> <span class="token punctuation">{</span>    sign<span class="token punctuation">.</span><span class="token function">setText</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment" spellcheck="true">// 使用 text，但不修改其值</span>    <span class="token keyword">auto</span> now <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>system_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    signHistory<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>now<span class="token punctuation">,</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>now<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 有条件地将 text 强制转换为右值</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在极少数的情况下，你需要用<code>std::move_if_noexcept</code>来代替<code>std::move</code>。</p><blockquote><p><code>std::move_if_noexcept</code>是<code>std::move</code>的一个变体，它是否会将对象强制转换为右值，取决于其类型的移动构造函数是否带有 noexcept 声明。</p></blockquote><p>在按值返回的函数中，如果返回的是绑定到右值引用或万能引用的对象，则当你返回该引用时，应当对其实施<code>std::move</code>或<code>std::forward</code>，这样可以避免编译器将其视作左值，从而消除拷贝左值进入返回值存储位置的额外开销：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 按值返回右值引用形参</span>Matrix <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span>Matrix<span class="token operator">&amp;&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Matrix<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    lhs <span class="token operator">+</span><span class="token operator">=</span> rhs<span class="token punctuation">;</span>    <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>lhs<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 按值返回万能引用形参</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>Fraction <span class="token function">reduceAndCopy</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> frac<span class="token punctuation">)</span> <span class="token punctuation">{</span>    frac<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>frac<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是若局部对象可能适用于<strong>返回值优化（return value optimization，RVO）</strong>，则请勿对其实施<code>std::move</code>或<code>std::forward</code>。这是因为当 RVO 的前提条件得到满足时，要么发生<strong>拷贝省略（copy elision）</strong>，要么<code>std::move</code>会隐式地被实施于返回的局部对象上；而人为地添加<code>std::move</code>或<code>std::forward</code>，会导致编译器失去执行 RVO 的能力。</p><p>下面的<code>makeWidget</code>函数满足 RVO 的两个前提条件：局部对象类型和函数返回值类型相同，且返回的就是局部对象本身：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget <span class="token function">makeWidget</span><span class="token punctuation">(</span>Widget w<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">return</span> w<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但由于函数形参不适合实施拷贝省略，所以编译器必须处理以上代码，使其与以下代码等价：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget <span class="token function">makeWidget</span><span class="token punctuation">(</span>Widget w<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-26：避免对万能引用类型进行重载"><a href="#条款-26：避免对万能引用类型进行重载" class="headerlink" title="条款 26：避免对万能引用类型进行重载"></a>条款 26：避免对万能引用类型进行重载</h3><p>形参为万能引用的函数是 C++ 中最贪婪的，它们会在具现过程中和几乎所有实参类型产生精确匹配（极少的不适用实参将在<strong>条款 30</strong> 中介绍），这就是为何把重载和万能引用两者结合通常不会达到预期效果。考虑如下情形：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">logAndAdd</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> now <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>system_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">log</span><span class="token punctuation">(</span>now<span class="token punctuation">,</span> <span class="token string">"logAndAdd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    names<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>std<span class="token operator">::</span>string <span class="token function">nameFromIdx</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">logAndAdd</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> now <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>system_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">log</span><span class="token punctuation">(</span>now<span class="token punctuation">,</span> <span class="token string">"logAndAdd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    names<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span><span class="token function">nameFromIdx</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">short</span> nameIdx<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 用 short 类型持有索引值</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">logAndAdd</span><span class="token punctuation">(</span>nameIdx<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用的却是万能引用版本</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>logAndAdd</code>有两个重载版本，形参类型为万能引用的版本可以将<code>T</code>推导为<code>short</code>，从而产生精确匹配；而形参类型为<code>int</code>的版本却只能在类型提升后才可以匹配到<code>short</code>类型的实参。因此，形参类型为万能引用的版本才是被优先调用的版本。</p><p>当完美转发出现在类的构造函数中时，情况会变得更加复杂：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>        <span class="token comment" spellcheck="true">// 完美转发构造函数</span>    <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> n<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 形参为 int 的构造函数</span>    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">const</span> Person<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 拷贝构造函数（由编译器生成）</span>    <span class="token function">Person</span><span class="token punctuation">(</span>Person<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 移动构造函数（由编译器生成）</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>string name<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于非常量的左值类型，完美转发构造函数一般都会优先于拷贝构造函数形成匹配；而对于常量左值类型，完美转发构造函数和拷贝构造函数具有相等的匹配程度，此时由于非函数模板会优先于函数模板被匹配，编译器才会转向调用拷贝构造函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Person <span class="token function">p</span><span class="token punctuation">(</span><span class="token string">"Nancy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> <span class="token function">cloneOfP</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 调用完美转发构造函数，无法通过编译</span><span class="token keyword">const</span> Person <span class="token function">cp</span><span class="token punctuation">(</span><span class="token string">"Nancy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 对象成为了常量</span><span class="token keyword">auto</span> <span class="token function">cloneOfCp</span><span class="token punctuation">(</span>cp<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 会正确调用拷贝构造函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完美转发构造函数还会劫持派生类中对基类的拷贝和移动构造函数的调用：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">SpecialPerson</span> <span class="token operator">:</span> <span class="token keyword">public</span> Person <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">SpecialPerson</span><span class="token punctuation">(</span><span class="token keyword">const</span> SpecialPerson<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 拷贝构造函数</span>        <span class="token operator">:</span> <span class="token function">Person</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">// 调用的是基类的完美转发构造函数！</span>    <span class="token function">SpecialPerson</span><span class="token punctuation">(</span>SpecialPerson<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// 移动构造函数</span>        <span class="token operator">:</span> <span class="token function">Person</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>         <span class="token comment" spellcheck="true">// 调用的是基类的完美转发构造函数！</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-27：熟悉对万能引用类型进行重载的替代方案"><a href="#条款-27：熟悉对万能引用类型进行重载的替代方案" class="headerlink" title="条款 27：熟悉对万能引用类型进行重载的替代方案"></a>条款 27：熟悉对万能引用类型进行重载的替代方案</h3><p><strong>1. 放弃重载</strong></p><p><strong>2. 传递<code>const T&amp;</code>类型的形参</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">logAndAdd</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> now <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>system_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">log</span><span class="token punctuation">(</span>now<span class="token punctuation">,</span> <span class="token string">"logAndAdd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    names<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种做法可以避免重载万能引用带来的不良影响，但会舍弃一些性能。</p><p><strong>3. 传值</strong></p><p>把传递的形参从引用类型换成值类型，是一种经常能够提升性能，却不会增加任何复杂性的方法，尽管这有些反直觉。这种设计遵循了<strong>条款 41</strong> 的建议——当你知道肯定需要复制形参时，考虑按值传递对象：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string n<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 替换掉 T&amp;&amp; 类型的构造函数</span>        <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 同前</span>        <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token function">nameFromIdx</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>string name<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4. 使用标签分派（tag dispatch）</strong></p><p>在这个方案中，我们将实际重载和实现功能的函数改为<code>logAndAddImpl</code>，而<code>logAndAdd</code>仅仅用于执行完美转发和标签分派：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">logAndAdd</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">logAndAddImpl</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span>        std<span class="token operator">::</span>is_integral<span class="token operator">&lt;</span><span class="token keyword">typename</span> std<span class="token operator">::</span>remove_reference<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// C++14 可以使用 std::remove_reference_t</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>针对<code>std::is_integral</code>产生的布尔值，我们可以写出两个<code>logAndAddImpl</code>重载版本，用于区分它们的类型<code>std::false_type</code>和<code>std::true_type</code>就是所谓 “标签”。具体实现代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">logAndAddImpl</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> name<span class="token punctuation">,</span> std<span class="token operator">::</span>false_type<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 非整型实参</span>    <span class="token keyword">auto</span> now <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>system_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">log</span><span class="token punctuation">(</span>now<span class="token punctuation">,</span> <span class="token string">"logAndAdd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    names<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>std<span class="token operator">::</span>string <span class="token function">nameFromIdx</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">logAndAddImpl</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">,</span> std<span class="token operator">::</span>true_type<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 整型实参</span>    <span class="token function">logAndAdd</span><span class="token punctuation">(</span><span class="token function">nameFromIdx</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>5. 对接受万能引用的模板施加限制</strong></p><p>通过 SFINAE 技术和<code>std::enable_if</code>，我们可以让一些模板在满足了指定条件的情况下才被启用，它的使用方式大致如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span>             <span class="token keyword">typename</span> <span class="token operator">=</span> <span class="token keyword">typename</span> std<span class="token operator">::</span>enable_if<span class="token operator">&lt;</span>condition<span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">></span>    <span class="token comment" spellcheck="true">// C++14 可以使用 std::enable_if_t</span>    <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此处我们想要<code>T</code>是<code>Person</code>以外的类型时，才启用该模板构造函数，则我们可以写下面这样的条件：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token operator">!</span>std<span class="token operator">::</span>is_same<span class="token operator">&lt;</span>Person<span class="token punctuation">,</span> <span class="token keyword">typename</span> std<span class="token operator">::</span>decay<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">></span><span class="token operator">::</span>value  <span class="token comment" spellcheck="true">// C++17 可以使用 std::is_same_v</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>std::decay</code>用于使类型完全退化，在此处用来移除<code>T</code>的引用和 cv 限定符（即<code>const</code>或<code>volatile</code>限定符），使我们可以更加纯粹地关注类型本身。<code>std::decay</code>还可以用于把数组和函数类型强制转换为指针类型（参考<strong>条款 1</strong>），它当然也拥有更易用的 C++14 版本，即<code>std::decay_t</code>。</p><p>写出这个条件并不意味着完成，<strong>条款 26</strong> 中还提到了在派生类中调用基类的拷贝和移动构造函数时，错误调用完美转发构造函数的问题。因此，我们想要的是为<code>Person</code>和继承自<code>Person</code>的类型都不一样的实参类型启用模板构造函数。标准库中的<code>std::is_base_of</code>用于判断一个类型是否由另一个类型派生而来，用它代替<code>std::is_same</code>就可以得到我们想要的东西（C++17 可以使用<code>std::is_base_of_v</code>）：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span>        <span class="token keyword">typename</span> T<span class="token punctuation">,</span>        <span class="token keyword">typename</span> <span class="token operator">=</span> <span class="token keyword">typename</span> std<span class="token operator">::</span>enable_if<span class="token operator">&lt;</span>                       <span class="token operator">!</span>std<span class="token operator">::</span>is_base_of<span class="token operator">&lt;</span>Person<span class="token punctuation">,</span>                                         <span class="token keyword">typename</span> std<span class="token operator">::</span>decay<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>type                                       <span class="token operator">></span><span class="token operator">::</span>value                   <span class="token operator">></span><span class="token operator">::</span>type    <span class="token operator">></span>    <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再加上处理整型实参的构造函数重载版本，并进一步限制模板构造函数，禁止其接受整型实参，我们得到的完美的<code>Person</code>类代码如下所示：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span>        <span class="token keyword">typename</span> T<span class="token punctuation">,</span>        <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token operator">::</span>enable_if_t<span class="token operator">&lt;</span>            <span class="token operator">!</span>std<span class="token operator">::</span>is_base_of<span class="token operator">&lt;</span>Person<span class="token punctuation">,</span> std<span class="token operator">::</span>decay_t<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token operator">::</span>value            <span class="token operator">&amp;&amp;</span>            <span class="token operator">!</span>std<span class="token operator">::</span>is_integral<span class="token operator">&lt;</span>std<span class="token operator">::</span>remove_reference_t<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token operator">::</span>value        <span class="token operator">></span>    <span class="token operator">></span>    <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> n<span class="token punctuation">)</span>              <span class="token comment" spellcheck="true">// 接受 std::string 类型以及可以强制转换为 </span>    <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// std::string 类型的实参的构造函数</span>    <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 接受整型实参的构造函数</span>    <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token function">nameFromIdx</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                 <span class="token comment" spellcheck="true">// 拷贝和移动构造函数等</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>string name<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>权衡</strong></p><p>本条款讨论的前三种方案（舍弃重载，传递<code>const T&amp;</code>类型的形参和传值）都需要对待调用的函数形参逐一指定类型，而后两种方案（使用标签分派和对接受万能引用的模板施加限制）则使用了完美转发，因此无需指定形参类型。</p><p>按照常理，完美转发的效率更高，因为它将类型保持和形参声明时完全一致，所以会避免创建临时对象。但完美转发也有一些不足：首先是针对某些类型无法实现完美转发（参考<strong>条款 30</strong>），其次是完美转发会使得在传递非法形参时，出现更难理解的错误信息。</p><p><code>std::is_constructible</code>这个类型特征（type trait）可以在编译期判断某个类型的对象是否可以用另一类型的对象（或不同类型的多个对象）来构造，我们可以用它来验证转发函数的万能引用形参是否合法。下面是增加了<code>static_assert</code>后的<code>Person</code>类，它可以产生更明确的报错信息：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token operator">::</span>enable_if_t<span class="token operator">&lt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">>></span>  <span class="token comment" spellcheck="true">// 同前</span>    <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> n<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 断言可以用 T 类型的对象构造 std::string</span>        <span class="token keyword">static_assert</span><span class="token punctuation">(</span>            std<span class="token operator">::</span>is_constructible<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> T<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">// C++17 可以使用 std::is_constructible_v</span>            <span class="token string">"Parameter n can't be used to construct a std::string"</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true">// 构造函数通常要完成的工作</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-28：理解引用折叠"><a href="#条款-28：理解引用折叠" class="headerlink" title="条款 28：理解引用折叠"></a>条款 28：理解引用折叠</h3><p>在<strong>条款 24</strong> 中我们了解了万能引用和右值引用的区别，但实际上万能引用并非一种新的引用类型，其实它就是在满足下面两个条件的语境中的右值引用：</p><ol><li>类型推导的过程中会区分左值和右值；</li><li>会发生<strong>引用折叠（reference collapsing）</strong>。</li></ol><p>C++ 标准禁止直接声明 “引用的引用” ，但引用折叠不受此限制。当左值被传递给接受万能引用的函数模板时，会发生下面这样的状况：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">func</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用 func 并传入左值，T 推导出的类型为 Widget&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>代入<code>T</code>的推导类型，我们可以得到下面这样的具现化模板：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;</span> <span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>出现了引用的引用！然而这并不违规，引用折叠的规则会把双重引用折叠成单个引用，规则如下：</p><blockquote><p>如果任一引用为左值引用，则结果为左值引用，否则（即两个皆为右值引用），结果为右值引用。</p></blockquote><p>所以实际上的函数签名为：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>引用折叠是使<code>std::forward</code>得以运作的关键，也是将左值或右值信息编码到万能引用形参<code>T</code>中的实现途径。<code>std::forward</code>的任务是，当且仅当编码在<code>T</code>中的信息表明传递的实参是右值，即<code>T</code>推导出的类型是个非引用类型时，对左值形参实施到右值的强制类型转换。它的基本实现大致是这样的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// C++11 版本</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>T<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span><span class="token keyword">typename</span> remove_reference<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>T<span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// C++14 版本</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>T<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span>remove_reference_t<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>T<span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假设传递给函数<code>forward</code>的实参类型是左值<code>Widget</code>，则模板的具现化结果可以写成：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget<span class="token operator">&amp;</span> <span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span>remove_reference_t<span class="token operator">&lt;</span>Widget<span class="token operator">&amp;</span><span class="token operator">></span><span class="token operator">&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Widget<span class="token operator">&amp;</span> <span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>发生引用折叠后，生成的最终结果如下，可以看出左值类型并不会发生改变：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget<span class="token operator">&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Widget<span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>假设传递给函数<code>forward</code>的实参类型是右值<code>Widget</code>，则模板的具现化结果可以写成：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span>remove_reference_t<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token operator">&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Widget<span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>发生引用折叠后，生成的最终结果如下，显然左值类型的形参会被强制转换为右值：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Widget<span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>引用折叠会在四种语境中出现：模板具现化，<code>auto</code>类型推断，创建和使用<code>typedef</code>和别名声明，以及<code>decltype</code>。</p><p><code>auto</code>类型推断中发生的引用折叠：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget w<span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">// 变量（左值）</span>Widget <span class="token function">widgetFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 返回右值的函数</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> w1 <span class="token operator">=</span> w<span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// 推导出 Widget&amp; &amp;&amp; w1，引用折叠后为 Widget&amp; w1</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> w2 <span class="token operator">=</span> <span class="token function">widgetFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 推导出 Widget&amp;&amp; w1，不会发生引用折叠</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建和使用<code>typedef</code>中发生的引用折叠：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> T<span class="token operator">&amp;&amp;</span> RvalueRefToT<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Widget<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token operator">></span> w<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用左值引用类型来具现化 Widget 模板</span><span class="token comment" spellcheck="true">// 具现化后得到 typedef int&amp; &amp;&amp; RvalueRefToT</span><span class="token comment" spellcheck="true">// 引用折叠后为 typedef int&amp; RvalueRefToT</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后一种会发生引用折叠的语境在<code>decltype</code>的运用中：如果在分析一个涉及<code>decltype</code>的类型时出现了引用的引用，则引用折叠会介入并将其消灭。</p><h3 id="条款-29：假定移动操作不存在、成本高、未被使用"><a href="#条款-29：假定移动操作不存在、成本高、未被使用" class="headerlink" title="条款 29：假定移动操作不存在、成本高、未被使用"></a>条款 29：假定移动操作不存在、成本高、未被使用</h3><p>在下面几个情形下，C++11 的移动语义不会给你带来什么好处：</p><ul><li><strong>没有移动操作：</strong> 待移动的对象未能提供移动操作。因此，移动请求就变成了拷贝请求。</li><li><strong>移动未能更快：</strong> 待移动的对象虽然有移动操作，但并不比其拷贝操作更快。</li></ul><blockquote><p>移动操作不比拷贝操作更快的例子：<code>std::array</code>将数据直接存储在对象内，移动<code>std::array</code>需要逐个移动容器内的每个元素；开启了<strong>短字符串优化（small string optimization，SSO）</strong> 的<code>std::string</code>，它会将字符串存储在<code>std::string</code>对象的某个缓冲区内，而非使用堆上的内存。</p></blockquote><ul><li><strong>移动不可用：</strong> 移动本可以发生的情况下，要求移动操作不会抛出异常，但该操作未加上<code>noexcept</code>声明。</li><li><strong>源对象是左值：</strong> 只有右值可以作为移动操作的源。</li></ul><p>因此，我们应该为通用的代码假定移动操作不存在、成本高且未被使用。然而，对于已知的类型或支持移动语义的代码中，就不需要作上述假定，在你知道移动操作成本低廉的情况下，可以放心大胆地将拷贝操作替换为相对不那么昂贵的移动操作。</p><h3 id="条款-30：熟悉完美转发的失败情形"><a href="#条款-30：熟悉完美转发的失败情形" class="headerlink" title="条款 30：熟悉完美转发的失败情形"></a>条款 30：熟悉完美转发的失败情形</h3><p>完美转发的含义是我们不仅转发对象，还转发其特征：类型，是左值还是右值，以及是否带有<code>const</code>和<code>volatile</code>限定符。出于此目的，我们会运用万能引用来将左、右值信息编码到类型中，而用于转发的函数自然也该是泛型的，它的标准形式如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">fwd</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>为了使转发函数能接受任意数量的形参，使用可变参数模板也在我们的考虑范围内：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">fwd</span><span class="token punctuation">(</span>Ts<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Ts<span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>若用相同实参调用<code>f</code>和<code>fwd</code>会执行不同的操作，则称<code>fwd</code>将实参完美转发到<code>f</code>失败。完美转发的失败情形源于模板类型推导失败，或推导出错误的类型。下面我们将了解会造成完美转发失败的典型例子。</p><p><strong>大括号初始值设定项（Braced initializers）</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// “{ 1, 2, 3 }” 会隐式转换为 std::vector&lt;int></span><span class="token function">fwd</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 无法通过编译！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>由于<code>fwd</code>的形参为被声明为<code>std::initializer_list</code>，编译器就会被禁止在<code>fwd</code>的调用过程中从表达式<code>{ 1, 2, 3 }</code>出发来推导类型。既然无法推导出形参的类型，那么编译器也只能拒绝对<code>fwd</code>的调用。</p><p>我们可以通过先用<code>auto</code>声明一个局部变量，再传递给<code>fwd</code>来避免这个问题：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> il <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// il 的类型被推导为 std::initializer_list&lt;int></span><span class="token function">fwd</span><span class="token punctuation">(</span>il<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 没问题，将 il 完美转发给 f</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>0 和 NULL 作空指针</strong></p><p><strong>条款 8</strong> 中曾经说明过，当你试图将<code>0</code>或<code>NULL</code>作为空指针传递给模板时，类型推导就会发生错误，将实参推导为一个整型而非指针类型，结果不管是<code>0</code>还是<code>NULL</code>都不会作为空指针被完美转发。解决方法非常简单，传一个<code>nullptr</code>而不是<code>0</code>或<code>NULL</code>。</p><p><strong>仅有声明的整型<code>static const</code>成员变量</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> std<span class="token operator">::</span>size_t MinVals <span class="token operator">=</span> <span class="token number">28</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 仅提供 MinVals 的声明</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                                          <span class="token comment" spellcheck="true">// 未给出 MinVals 的定义</span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span>Widget<span class="token operator">::</span>MinVals<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment" spellcheck="true">// 没问题，当作 “f(28)” 处理</span><span class="token function">fwd</span><span class="token punctuation">(</span>Widget<span class="token operator">::</span>MinVals<span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">// 可能无法通过链接</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般而言，编译器会绕过<code>MinVals</code>缺少定义的事实，并用其值替换所有涉及到<code>MinVals</code>的地方，但并不会为其实际分配存储空间。这就导致如果我们尝试对<code>MinVals</code>实施取地址或对它进行引用，就会导致链接无法通过，这也就是为何不能将<code>Widget::MinVals</code>作为实参传递给<code>fwd</code>。</p><p>按照标准，按引用传递<code>MinVals</code>时要求<code>MinVals</code>有定义。然而并不是所有实现都遵循了这个规定，对于一些编译器和链接器，你会发现将<code>MinVals</code>用于完美转发并不会产生错误，甚至对它取地址也不会。但为了代码的可移植性，还是应当重视此处所讲的规则，为<code>static const</code>成员变量提供定义：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const</span> std<span class="token operator">::</span>size_t Widget<span class="token operator">::</span>MinVals<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 在 Widget 的 .cpp 文件中</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>重载函数的名称和模板名称</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 或者 void f(int pf(int))</span><span class="token keyword">int</span> <span class="token function">processVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">processVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">,</span> <span class="token keyword">int</span> priority<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span>processVal<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 没问题</span><span class="token function">fwd</span><span class="token punctuation">(</span>processVal<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 错误！无法确定是哪个重载版本</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>T <span class="token function">workOnVal</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token function">fwd</span><span class="token punctuation">(</span>workOnVal<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 错误！无法确定是 workOnVal 的哪个实例</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当我们将<code>processVal</code>传递给<code>f</code>时，由于<code>f</code>的形参类型是已知的，编译器自然也知道它需要的是<code>processVal</code>的哪个重载版本；但纯粹的函数名称<code>processVal</code>并不包含类型信息，类型推导更是无从谈起，将它传递给<code>fwd</code>只会造成完美转发失败而已。</p><p>要让<code>fwd</code>接受重载函数的名称或模板名称，只能手动指定需要转发的哪个重载版本或模板实例。例如下面的做法就是合理的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> ProcessFuncType <span class="token operator">=</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ProcessFuncType processValPtr <span class="token operator">=</span> processVal<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 指定了需要的 processVal 签名</span><span class="token function">fwd</span><span class="token punctuation">(</span>processValPtr<span class="token punctuation">)</span><span class="token punctuation">;</span>                             <span class="token comment" spellcheck="true">// 没问题</span><span class="token function">fwd</span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>ProcessFuncType<span class="token operator">></span><span class="token punctuation">(</span>workOnVal<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 也没问题</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>位域</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> IPv4Header <span class="token punctuation">{</span>                 <span class="token comment" spellcheck="true">// 用于表示 IPv4 头部的模型</span>    std<span class="token operator">::</span>uint32_t version<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">,</span>                  IHL<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">,</span>                  DSCP<span class="token operator">:</span><span class="token number">6</span><span class="token punctuation">,</span>                  ECN<span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">,</span>                  totalLength<span class="token operator">:</span><span class="token number">16</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t sz<span class="token punctuation">)</span><span class="token punctuation">;</span>IPv4Header h<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>totalLength<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 没问题</span><span class="token function">fwd</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>totalLength<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// 错误！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++ 标准规定：非常引用不得绑定到位域。位域是由机器字的若干任意部分组成的，但这样的实体是无法对其直接取地址的，无法将指针指向它，因此也无法对其进行引用。</p><blockquote><p>实际上常引用也不可能绑定到位域，它们绑定到的是 “常规” 对象（某种标准整型，例如<code>int</code>），其中拷贝了位域的值。</p></blockquote><p>将位域传递给转发函数的可能途径是制作一个副本，并以该副本调用转发函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 拷贝位域值，使用的初始化形式参考条款 6</span><span class="token keyword">auto</span> length <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>std<span class="token operator">::</span>uint16_t<span class="token operator">></span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>totalLength<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fwd</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 转发该副本</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第六章：lambda-表达式"><a href="#第六章：lambda-表达式" class="headerlink" title="第六章：lambda 表达式"></a>第六章：lambda 表达式</h2><p>在开始本章之前，需要理解几个基本的概念：</p><ul><li><strong>lambda 表达式（lambda expression）：</strong> 表达式的一种，它的基本写法如下所示：</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">0</span> <span class="token operator">&lt;</span> val <span class="token operator">&amp;&amp;</span> val <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>闭包（closure）：</strong> lambda 所创建的运行期对象，根据不同的捕获模式，闭包会持有数据的副本或引用。</li><li><strong>闭包类（closure class）：</strong> 实例化闭包的类，每个 lambda 都会使编译器生成唯一的闭包类。lambda 中的语句会成为其闭包类的成员函数中的可执行指令。</li></ul><blockquote><p>lambda 表达式和闭包类存在于编译期，而闭包存在于运行期。</p></blockquote><h3 id="条款-31：避免默认捕获模式"><a href="#条款-31：避免默认捕获模式" class="headerlink" title="条款 31：避免默认捕获模式"></a>条款 31：避免默认捕获模式</h3><p>C++11 中有两种默认捕获模式：按引用或按值。按引用捕获会导致闭包内包含指向局部变量的引用，或指向定义 lambda 的作用域内形参的引用，一旦由 lambda 所创建的闭包越过了该局部变量或形参的生命周期，那么闭包内的引用就会发生空悬：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> FilterContainer <span class="token operator">=</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token punctuation">;</span>FilterContainer filters<span class="token punctuation">;</span>                                <span class="token comment" spellcheck="true">// 元素为筛选函数的容器</span><span class="token keyword">void</span> <span class="token function">addDivisorFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> calc1 <span class="token operator">=</span> <span class="token function">computeSomeValue1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> calc2 <span class="token operator">=</span> <span class="token function">computeSomeValue2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> divisor <span class="token operator">=</span> <span class="token function">computeDivisor</span><span class="token punctuation">(</span>calc1<span class="token punctuation">,</span> calc2<span class="token punctuation">)</span><span class="token punctuation">;</span>    filters<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>        <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> value <span class="token operator">%</span> divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 危险！指向 divisor 的引用可能空悬</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>换作用显式方式按引用捕获<code>divisor</code>，问题依旧会发生，但更容易看出 lambda 依赖于<code>divisor</code>的生命周期这一问题：</p><pre class="line-numbers language-cpp"><code class="language-cpp">filters<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>    <span class="token punctuation">[</span><span class="token operator">&amp;</span>divisor<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> value <span class="token operator">%</span> divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一种权宜之计是不使用容器来存放筛选函数，转而使用 C++11 的<code>std::all_of</code>对每个元素逐一进行判断。但如果将该 lambda 拷贝到其它闭包比<code>divisor</code>生命周期更长的语境中，则空悬引用的问题仍会发生：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> C<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">workWithContainer</span><span class="token punctuation">(</span><span class="token keyword">const</span> C<span class="token operator">&amp;</span> container<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> calc1 <span class="token operator">=</span> <span class="token function">computeSomeValue1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> calc2 <span class="token operator">=</span> <span class="token function">computeSomeValue2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> divisor <span class="token operator">=</span> <span class="token function">computeDivisor</span><span class="token punctuation">(</span>calc1<span class="token punctuation">,</span> calc2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">using</span> ContElemT <span class="token operator">=</span> <span class="token keyword">typename</span> C<span class="token operator">::</span>value_type<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 取得容器中的元素类型（参考条款 13）</span>    <span class="token keyword">using</span> std<span class="token operator">::</span>begin<span class="token punctuation">;</span>    <span class="token keyword">using</span> std<span class="token operator">::</span>end<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">all_of</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">// 判断是否所有元素都是 divisor 的倍数</span>        <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> ContElemT<span class="token operator">&amp;</span> value<span class="token punctuation">)</span>                     <span class="token comment" spellcheck="true">// C++14 可以直接写成 const auto&amp; value</span>        <span class="token punctuation">{</span> <span class="token keyword">return</span> value <span class="token operator">%</span> divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在本例中，使用默认的按值捕获模式就足以解决问题：</p><pre class="line-numbers language-cpp"><code class="language-cpp">filters<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>    <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> value <span class="token operator">%</span> divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>但是默认的按值捕获模式也有其问题：默认的按值捕获极易受到空悬指针的影响（尤其是<code>this</code>指针），并且会误导人们认为 lambda 是独立的。考虑如下情形：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">void</span> <span class="token function">addFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> divisor<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 用于 Widget 的 filters</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> Widget<span class="token operator">::</span><span class="token function">addFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>    filters<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>        <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> value <span class="token operator">%</span> divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于此处的 lambda 而言，<code>divisor</code>既不是局部变量，也不是形参，按理来讲是压根无法被捕获的。事实也确实如此，被捕获的实际上是<code>Widget</code>的<code>this</code>指针，而不是<code>divisor</code>。对于编译器来说，<code>addFilter</code>的代码相当于：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> Widget<span class="token operator">::</span><span class="token function">addFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> currentObjectPtr <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    filters<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>        <span class="token punctuation">[</span>currentObjectPtr<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span>        <span class="token punctuation">{</span> <span class="token keyword">return</span> value <span class="token operator">%</span> currentObjectPtr<span class="token operator">-</span><span class="token operator">></span>divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>理解了这一点，也就能理解 lambda 闭包的存活依赖于它含有的<code>this</code>指针副本所指向的<code>Widget</code>对象的生命周期。假如面临以下代码，空悬指针的问题将出现在我们的眼前：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> FilterContainer <span class="token operator">=</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token punctuation">;</span>FilterContainer filters<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 同前</span><span class="token keyword">void</span> <span class="token function">doSomeWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> pw <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 创建 Widget，std::make_unique 的使用参考条款 21</span>    pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">addFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 添加使用了 Widget::divisor 的筛选函数</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>                                           <span class="token comment" spellcheck="true">// Widget 被销毁，filters 现在持有空悬指针！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一种解决方法是将你想捕获的成员变量拷贝至局部变量中，之后再捕获该副本局部变量：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> Widget<span class="token operator">::</span><span class="token function">addFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> divisorCopy <span class="token operator">=</span> divisor<span class="token punctuation">;</span>    filters<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>        <span class="token punctuation">[</span>divisorCopy<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> value <span class="token operator">%</span> divisorCopy <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 C++14 中，捕获成员变量的一种更好的方法是使用<strong>广义 lambda 捕获（generalized lambda capture，参考条款 32）</strong>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> Widget<span class="token operator">::</span><span class="token function">addFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>    filters<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>        <span class="token punctuation">[</span>divisor <span class="token operator">=</span> divisor<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// C++14: 将 divisor 拷贝入闭包并使用副本</span>        <span class="token punctuation">{</span> <span class="token keyword">return</span> value <span class="token operator">%</span> divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认的按值捕获模式的另一个缺点是，它会使人们误认为闭包是独立的，与闭包外的数据变化相隔绝。但实际上并非如此，lambda 可能不仅依赖于局部变量和形参，还会依赖于<strong>静态存储期（static storage duration）对象</strong>，这样的对象可以在 lambda 中使用，但却无法被捕获。下面这个例子足以体现这一点会造成的问题：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">addDivisorFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">auto</span> calc1 <span class="token operator">=</span> <span class="token function">computeSomeValue1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">auto</span> calc2 <span class="token operator">=</span> <span class="token function">computeSomeValue2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">auto</span> divisor <span class="token operator">=</span> <span class="token function">computeDivisor</span><span class="token punctuation">(</span>calc1<span class="token punctuation">,</span> calc2<span class="token punctuation">)</span><span class="token punctuation">;</span>    filters<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>        <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span>                      <span class="token comment" spellcheck="true">// 未捕获任何东西！</span>        <span class="token punctuation">{</span> <span class="token keyword">return</span> value <span class="token operator">%</span> divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 引用上面的 static 对象</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">++</span>divisor<span class="token punctuation">;</span>                              <span class="token comment" spellcheck="true">// 意外修改了 divisor</span>                                            <span class="token comment" spellcheck="true">// 导致每个 lambda 都出现新的行为</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-32：使用初始化捕获将对象移入闭包"><a href="#条款-32：使用初始化捕获将对象移入闭包" class="headerlink" title="条款 32：使用初始化捕获将对象移入闭包"></a>条款 32：使用初始化捕获将对象移入闭包</h3><p>C++14 中新增的<strong>初始化捕获（init capture，又称广义 lambda 捕获）</strong>，可以让你指定：</p><ol><li>由 lambda 生成的闭包类中成员变量的名字。</li><li>一个用于初始化该成员变量的表达式。</li></ol><p>下面演示了如何使用初始化捕获将<code>std::unique_ptr</code>移入闭包内：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isValidated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token keyword">bool</span> <span class="token function">isProcessed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token keyword">bool</span> <span class="token function">isArchived</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">auto</span> pw <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 创建 Widget，std::make_unique 的使用参考条款 21</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                     <span class="token comment" spellcheck="true">// 配置 *pw</span><span class="token keyword">auto</span> func <span class="token operator">=</span> <span class="token punctuation">[</span>pw <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>pw<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true">// 使用 std::move(pw) 初始化闭包类的数据成员</span>            <span class="token punctuation">{</span> <span class="token keyword">return</span> pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">isValidated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">isArchived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果经由<code>std::make_unique</code>创建的对象已具备被 lambda 捕获的合适状态，则闭包类成原对象可以直接由<code>std::make_unique</code>完成初始化：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> func <span class="token operator">=</span> <span class="token punctuation">[</span>pw <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>            <span class="token punctuation">{</span> <span class="token keyword">return</span> pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">isValidated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">isArchived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在初始化捕获的代码中，位于<code>=</code>左侧的是所指定的闭包类成员变量的名称，右侧的则是其初始化表达式。值得一提的是，<code>=</code>的左右两侧位于不同的作用域，左侧作用域就是闭包的作用域，而右侧作用域则与 lambda 定义所在的作用域相同。</p><p>在 C++11 中，我们虽然无法使用初始化捕获，但是可以依靠原理相同的手写类达到目的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">IsValAndArch</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> DataType <span class="token operator">=</span> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">;</span>    <span class="token keyword">explicit</span> <span class="token function">IsValAndArch</span><span class="token punctuation">(</span>DataType<span class="token operator">&amp;&amp;</span> ptr<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// std::move 的使用参考条款 25</span>        <span class="token operator">:</span> <span class="token function">pw</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">// 编写仿函数</span>        <span class="token keyword">return</span> pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">isValidated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">isArchived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    DataType pw<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">auto</span> func <span class="token operator">=</span> <span class="token function">IsValAndArch</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你非要使用 lambda，按移动捕获也可以通过以下方法模拟：</p><ol><li>将需要捕获的对象移至<code>std::bind</code>所产生的函数对象中。</li><li>给予 lambda 一个指向想要 “捕获” 的对象的引用。</li></ol><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> data<span class="token punctuation">;</span><span class="token keyword">auto</span> func <span class="token operator">=</span>    std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token operator">&amp;</span> data<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// C++11 模拟初始化捕获</span>              <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* 使用 data */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>              std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>std::bind</code>的第一个实参是个可调用对象，接下来的所有实参表示传给该对象的值。和 lambda 表达式类似，<code>std::bind</code>也会生成函数对象（原书中称其为<strong>绑定对象，bind object</strong>），其中含有传递给<code>std::bind</code>的所有实参的副本，其中左值实参执行的是拷贝构造，而右值实参执行的则是移动构造。因此，在此处用<code>std::move(data)</code>作为实参可以让<code>data</code>被移入绑定对象中，被 lambda 的左值引用形参所接受。</p><p>默认情况下，lambda 生成的闭包类中的<code>operator()</code>成员函数会带有<code>const</code>限定符，它会导致是闭包类里的所有成员变量在 lambda 的函数体内都会带有<code>const</code>限定符。但是，绑定对象里通过移动构造得到的<code>data</code>副本却并不带有<code>const</code>限定符。因此，为了防止该<code>data</code>副本在 lambda 中被意外修改，我们会将其形参声明为常引用。但如果 lambda 在声明时带有<code>mutable</code>限定符，则闭包里的<code>operator()</code>就不再会带有<code>const</code>限定符，也不必再将形参声明为常引用：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> func <span class="token operator">=</span>    std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token operator">&amp;</span> data<span class="token punctuation">)</span> <span class="token keyword">mutable</span>              <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* 使用 data */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>              std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>回到之前的例子，使用 C++14 在闭包内创建<code>std::unique_ptr</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> func <span class="token operator">=</span> <span class="token punctuation">[</span>pw <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>            <span class="token punctuation">{</span> <span class="token keyword">return</span> pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">isValidated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">isArchived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>它在 C++11 中的模拟代码可以这样编写：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> func <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token operator">&amp;</span> pw<span class="token punctuation">)</span>                      <span class="token punctuation">{</span> <span class="token keyword">return</span> pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">isValidated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">isArchived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>                      std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="条款-33：对-auto-amp-amp-类型的形参使用-decltype-以对其实施-std-forward"><a href="#条款-33：对-auto-amp-amp-类型的形参使用-decltype-以对其实施-std-forward" class="headerlink" title="条款 33：对 auto&amp;&amp; 类型的形参使用 decltype 以对其实施 std::forward"></a>条款 33：对 auto&amp;&amp; 类型的形参使用 decltype 以对其实施 std::forward</h3><p>C++14 支持<strong>泛型 lambda（generic lambda）</strong>，可以在声明形参时使用<code>auto</code>，即闭包类中的<code>operator()</code>可以用模板实现。例如，给定以下 lambda：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token function">normalize</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>则闭包类的<code>operator()</code>实现大致如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">SomeCompilerGeneratedClassName</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>    <span class="token keyword">auto</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>T x<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// auto 类型的返回值，参考条款 3</span>        <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token function">normalize</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在此处，lambda 总会传递左值给<code>normalize</code>，这对于一个会区别对待左、右值的<code>normalize</code>显然是不行的。如果想要保留实参的左、右值性，就需要将形参声明为万能引用（参考<strong>条款 24</strong>），并使用<code>std::forward</code>将其转发给<code>normalize</code>（参考<strong>条款 25</strong>）。这样的改造十分简单，唯一的问题是在 lambda 中，我们并没有可用的模板形参<code>T</code>，只能对要转发的形参使用<code>decltype</code>，以取得其类型：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token function">normalize</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>条款 28</strong> 说明了，使用<code>std::forward</code>的惯例是：用左值引用类型的模板形参来表明想要返回左值，用非引用类型的模板形参来表明想要返回右值。而在此处，如果<code>param</code>是左值，则<code>decltype(param)</code>会产生左值引用类型，这符合惯例；但如果<code>param</code>是右值，则<code>decltype(param)</code>会产生右值引用类型，不符合惯例的非引用，在这种情况下，<code>std::forward</code>将被具现化为：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget<span class="token operator">&amp;&amp;</span> <span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span>remove_reference_t<span class="token operator">&lt;</span>Widget<span class="token operator">&amp;</span><span class="token operator">></span><span class="token operator">&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Widget<span class="token operator">&amp;&amp;</span> <span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>由于引用折叠的存在，<code>Widget&amp;&amp; &amp;&amp;</code>将被折叠为<code>Widget&amp;&amp;</code>，所以实际上生成的代码和使用非引用类型作为模板形参生成的版本并没有什么区别。综上所述，在此处使用<code>decltype(param)</code>并不会产生任何问题，这是个非常不错的结果。</p><p>C++14 的 lambda 也支持可变参数，只需稍加改动，就可以得到能接受多个参数的完美转发 lambda 版本：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token function">normalize</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="条款-34：优先选用-lambda，而非-std-bind"><a href="#条款-34：优先选用-lambda，而非-std-bind" class="headerlink" title="条款 34：优先选用 lambda，而非 std::bind"></a>条款 34：优先选用 lambda，而非 std::bind</h3><p>之所以优先选用 lambda 而非 std::bind，最主要的原因是 lambda 具有更高的可读性。举个例子，假设我们有个函数用来设置警报声：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 表示时刻的类型</span><span class="token keyword">using</span> Time <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>steady_clock<span class="token operator">::</span>time_point<span class="token punctuation">;</span><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Sound</span> <span class="token punctuation">{</span> Beep<span class="token punctuation">,</span> Siren<span class="token punctuation">,</span> Whistle <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 表示时长的类型</span><span class="token keyword">using</span> Duration <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>steady_clock<span class="token operator">::</span>duration<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 在时刻 t，发出声音 s，持续时长 d</span><span class="token keyword">void</span> <span class="token function">setAlarm</span><span class="token punctuation">(</span>Time t<span class="token punctuation">,</span> Sound s<span class="token punctuation">,</span> Duration d<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以编写一个 lambda，设置在一小时后发出警报并持续 30 秒，同时提供接口，以指定发出的声音：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> setSoundL <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Sound s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token operator">::</span>chrono<span class="token punctuation">;</span>    <span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token operator">::</span>literals<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 引入 C++14 中的字面量后缀</span>    <span class="token function">setAlarm</span><span class="token punctuation">(</span>steady_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> 1h<span class="token punctuation">,</span> s<span class="token punctuation">,</span> 30s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// C++11 需要用 hours 和 seconds 代替后缀</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来我们将尝试使用<code>std::bind</code>来编写相应的代码。下面的这段代码并不正确，但足以让我们发现<code>std::bind</code>的难用之处：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token operator">::</span>chrono<span class="token punctuation">;</span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token operator">::</span>literals<span class="token punctuation">;</span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token operator">::</span>placeholders<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 引入占位符</span><span class="token keyword">auto</span> setSoundB <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>setAlarm<span class="token punctuation">,</span>                           steady_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> 1h<span class="token punctuation">,</span>                           _1<span class="token punctuation">,</span>                           30s<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>占位符<code>_1</code>表示它在<code>std::bind</code>形参列表中的映射位置，在此处表示调用<code>setSoundB</code>时传入的第一个实参，会作为第二个实参传递给<code>setAlarm</code>。这显然已经不如 lambda 直观。</p><p>更重要的是上述代码所隐含的问题：调用时间的错误。在<code>std::bind</code>的调用中，<code>steady_clock::now() + 1h</code>作为实参被传递给了<code>std::bind</code>，而非<code>setAlarm</code>，这意味着该表达式会在调用<code>std::bind</code>的时刻计算出具体值，而非调用<code>setAlarm</code>的时刻，这与我们的意图显然不符。想要解决这个问题，就要嵌套第二层<code>std::bind</code>的调用：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> setSoundB <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>setAlarm<span class="token punctuation">,</span>                           std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>std<span class="token operator">::</span>plus<span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// C++11 无法省略 std::plus&lt;steady_clock::time_point>()</span>                                     steady_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                     1h<span class="token punctuation">)</span><span class="token punctuation">,</span>                           _1<span class="token punctuation">,</span>                           30s<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一个<code>std::bind</code>不如 lambda 的例子是重载。假如有个重载版本会接受第四个形参，用于指定警报的音量：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Volume</span> <span class="token punctuation">{</span> Normal<span class="token punctuation">,</span> Loud<span class="token punctuation">,</span> LoudPlusPlus <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">setAlarm</span><span class="token punctuation">(</span>Time t<span class="token punctuation">,</span> Sound s<span class="token punctuation">,</span> Duration d<span class="token punctuation">,</span> Volume v<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>原来的 lambda 仍会正常运作，而<code>std::bind</code>会立刻发生错误，因为它只有函数名，并不知道要调用哪个重载版本的函数。为使得<code>std::bind</code>的调用能通过编译，必须将<code>setAlarm</code>强制转换到适当的函数指针类型：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> SetAlarm3ParamType <span class="token operator">=</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Time t<span class="token punctuation">,</span> Sound s<span class="token punctuation">,</span> Duration d<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> setSoundB <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>SetAlarm3ParamType<span class="token operator">></span><span class="token punctuation">(</span>setAlarm<span class="token punctuation">)</span><span class="token punctuation">,</span>                           std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>std<span class="token operator">::</span>plus<span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> steady_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 1h<span class="token punctuation">)</span><span class="token punctuation">,</span>                           _1<span class="token punctuation">,</span>                           30s<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是一个更极端的例子，演示了<code>std::bind</code>到底有多晦涩：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// lambda 版本（C++14）</span><span class="token keyword">auto</span> betweenL <span class="token operator">=</span> <span class="token punctuation">[</span>lowVal<span class="token punctuation">,</span> highVal<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> lowVal <span class="token operator">&lt;=</span> val <span class="token operator">&amp;&amp;</span> val <span class="token operator">&lt;=</span> highVal<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// std::bind 版本（C++14）</span><span class="token keyword">auto</span> betweenB <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>std<span class="token operator">::</span>logical_and<span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                          std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>std<span class="token operator">::</span>less_equal<span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lowVal<span class="token punctuation">,</span> std<span class="token operator">::</span>placeholders<span class="token operator">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">,</span>                          std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>std<span class="token operator">::</span>less_equal<span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>placeholders<span class="token operator">::</span>_1<span class="token punctuation">,</span> highVal<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>std::bind</code>总是拷贝其实参，调用时需要借助<code>std::ref</code>来达到按引用存储实参的目的，这一点同样也不如 lambda 来得明确：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> compressRateL <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>w<span class="token punctuation">]</span><span class="token punctuation">(</span>CompLevel lev<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">compress</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> lev<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">auto</span> compressRateB <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>compress<span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">ref</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>placeholders<span class="token operator">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>除了可读性以外，编译器通常能更好地以内联优化 lambda 所调用的函数，而对于使用函数指针的<code>std::bind</code>则很难做到，这会导致使用 lambda 有可能会生成比使用<code>std::bind</code>运行得更快的代码。</p><p>在 C++11 中，<code>std::bind</code>仅在两个受限的场合还有使用的理由：</p><ol><li>移动捕获（参考<strong>条款 32</strong>）；</li><li>多态函数对象（这在 C++14 中可以被泛型 lambda 轻易实现）：</li></ol><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">PolyWidget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>PolyWidget pw<span class="token punctuation">;</span><span class="token keyword">auto</span> boundPW <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>pw<span class="token punctuation">,</span> std<span class="token operator">::</span>placeholders<span class="token operator">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 可以用不同类型的实参调用 PolyWidget::operator()</span><span class="token function">boundPW</span><span class="token punctuation">(</span><span class="token number">1930</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">boundPW</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">boundPW</span><span class="token punctuation">(</span><span class="token string">"Rosebud"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 原书作者玩的《公民凯恩》梗（应该是吧）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第七章：并发-API"><a href="#第七章：并发-API" class="headerlink" title="第七章：并发 API"></a>第七章：并发 API</h2><h3 id="条款-35：优先选用基于任务而非基于线程的程序设计"><a href="#条款-35：优先选用基于任务而非基于线程的程序设计" class="headerlink" title="条款 35：优先选用基于任务而非基于线程的程序设计"></a>条款 35：优先选用基于任务而非基于线程的程序设计</h3><p>如果你想以异步方式执行函数<code>doAsyncWork</code>，你可以选择<strong>基于线程（thread-based）</strong> 的方式：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">doAsyncWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span>doAsyncWork<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>也可以将<code>doAsyncWork</code>传递给<code>std::async</code>，这是<strong>基于任务（task-based）</strong> 的方式：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> fut <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span>doAsyncWork<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 需要 #include &lt;future></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>“线程” 在带有并发的 C++ 软件中有三重含义：</p><ul><li><strong>硬件线程（hardware threads）</strong> 是实际执行计算的线程。现代计算机架构会为每个 CPU 内核提供一个或多个硬件线程。</li><li><strong>软件线程（software threads，也称系统线程）</strong> 是操作系统（或嵌入式系统）用于实现跨进程的管理，以及进行硬件线程调度的线程。通常，能够创建的软件线程比硬件线程要多，因为当一个软件线程被阻塞时，运行其它未阻塞线程能够提高吞吐率。</li><li><strong><code>std::thread</code></strong> 是 C++ 进程中的对象，用作底层软件线程的句柄。有些<code>std::thread</code>对象表现为 “null” 句柄，表示其无软件线程，可能的原因有：处于默认构造状态（没有要执行的函数），被移动了（被移动的目标对象成为了该软件线程的句柄），被联结（join）了（函数已执行结束），被分离（detach）了（与其软件线程的连接被切断）。</li></ul><p>软件线程和硬件线程都是有限的。如果你试图创建多于系统能提供的数量的线程，就会抛出<code>std::system_error</code>异常，即使待执行的函数带有<code>noexcept</code>限定符也一样。如果非阻塞的软件线程数量超过了硬件线程数量，就会产生<strong>资源超额（oversubscription）</strong> 问题，此时线程调度器会将软件线程的 CPU 时间切片，分配到硬件线程之上。当一个软件线程的时间片执行结束，就会让给另一个软件线程，并产生上下文切换。在这种情况下，新的软件线程几乎不能命中 CPU 缓存，同时还会污染为旧线程所准备的数据（旧线程很可能还会再被调度到同一内核上运行），这会造成高昂的线程管理开销。</p><blockquote><p>避免资源超额很困难，因为软件线程和硬件线程的最佳比例取决于软件线程的执行频率，那是动态改变的，例如一个程序从 IO 密集型变成计算密集型，会使执行频率发生改变。而且该比例还依赖于上下文切换的开销以及软件线程对于 CPU 缓存的使用效率。计算机本身的架构也会对其具体细节产生很大的影响。</p></blockquote><p>比起基于线程，基于任务的设计能够减轻手动管理线程的艰难，而且它提供了一种很自然的方式（藉由<code>get</code>函数），让你检查异步执行函数的结果（即返回值或异常）。</p><p>虽然说了这么多，但仍有以下几种情况，直接使用线程会更合适：</p><ul><li><strong>你需要访问非常底层的线程 API。</strong> C++ 并发 API 通常会采用特定平台的低级 API 来实现，例如 pthread 和 Windows 线程库，它们提高的 API 比 C++ 更丰富。为了访问底层的线程 API，<code>std::thread</code>通常会提供<code>native_handle</code>成员函数，而<code>std::async</code>的返回值<code>std::future</code>则没有该功能。</li><li><strong>你需要且有能力为你的应用优化线程的使用。</strong> 例如在完成性能分析的情况下为专一硬件平台开发应用。</li><li><strong>你需要实现实现超越 C++ 并发 API 的线程技术。</strong> 例如为 C++ 未提供线程池的平台实现线程池。</li></ul><h3 id="条款-36：如果异步是必要的，则指定-std-launch-async"><a href="#条款-36：如果异步是必要的，则指定-std-launch-async" class="headerlink" title="条款 36：如果异步是必要的，则指定 std::launch::async"></a>条款 36：如果异步是必要的，则指定 std::launch::async</h3><p>在调用<code>std::async</code>时，有以下两种启动策略可以选择：</p><ul><li><code>std::launch::async</code>启动策略意味着函数必须以异步方式在另一条线程上执行。</li><li><code>std::launch::deferred</code>启动策略意味着函数会被推迟到<code>std::async</code>所返回的<code>std::future</code>的<code>get</code>或<code>wait</code>函数得到调用时才执行（这是个简化说法，关键点其实是<code>std::future</code>引用的共享状态，参考<strong>条款 38</strong>）。在那之后，调用<code>get</code>或<code>wait</code>的线程将会被阻塞，直至函数执行结束为止。如果<code>get</code>或<code>wait</code>都没得到调用，则函数将不会被执行。</li></ul><p><code>std::async</code>的默认启动策略既允许任务以异步方式执行，也允许任务以同步方式执行，即下面两个调用是等价的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> fut1 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> fut2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span>std<span class="token operator">::</span>launch<span class="token operator">::</span>async <span class="token operator">|</span> std<span class="token operator">::</span>launch<span class="token operator">::</span>deferred<span class="token punctuation">,</span>                       f<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这种弹性使得<code>std::async</code>和标准库的线程管理组件能够承担起线程的创建和销毁，避免资源超额，以及负载均衡的责任。但也会带来一些意料之外的问题：</p><ul><li>无法预知<code>f</code>是否会与调用<code>std::async</code>的线程并发执行，它也可能会被推迟执行。</li><li>无法预知<code>f</code>是否会在与调用<code>get</code>和<code>wait</code>函数的线程不同的线程上执行。</li><li>无法预知<code>f</code>在读或写此<strong>线程本地存储（thread-local，TLS）</strong> 时，会在哪个线程的本地存储上完成操作，这会影响到<code>thread_local</code>变量的使用。</li><li>就连<code>f</code>是否会被执行这种基本的事情都无法预知。</li></ul><p>延迟启动策略还会影响以超时为条件的基于 wait 的循环：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token operator">::</span>literals<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>1s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">auto</span> fut <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>fut<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>100ms<span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token operator">::</span>future_status<span class="token operator">::</span>ready<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 循环至 f 完成执行</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 若 f 被推迟执行，则 fut.wait_for 返回 std::future_status::deferred</span>    <span class="token comment" spellcheck="true">// 循环永远不会被终止！</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决这个问题的方法很简单，只需要确认任务是否被推迟，可以通过调用一个基于超时的函数（例如<code>wait_for</code>）并检查其返回值来实现：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> fut <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fut<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>0s<span class="token punctuation">)</span> <span class="token operator">==</span> std<span class="token operator">::</span>future_status<span class="token operator">::</span>deferred<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果任务被推迟了</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true">// 调用 fut 的 wait 或 get，以同步方式执行 f</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>                                                  <span class="token comment" spellcheck="true">// 如果任务未被推迟</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>fut<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>100ms<span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token operator">::</span>future_status<span class="token operator">::</span>ready<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true">// 不断去做并发任务，直至 f 完成执行</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true">// fut 已经就绪</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>综上所述，如果需要执行的任务满足以下条件，就可以使用<code>std::async</code>的默认启动策略：</p><ol><li>任务不需要与调用<code>get</code>或<code>wait</code>的线程并发执行。</li><li>读或写哪个线程的<code>thread_local</code>变量并无影响。</li><li>保证在<code>std::async</code>返回的<code>std::future</code>对象上调用<code>get</code>或<code>wait</code>，或者可以接受任务可能永不执行。</li><li>使用<code>wait_for</code>或<code>wait_until</code>的代码会考虑到任务被推迟的可能性。</li></ol><p>如果其中任何一个条件不满足，就需要确保任务以异步方式执行：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> fut <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span>std<span class="token operator">::</span>launch<span class="token operator">::</span>async<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以编写一个辅助函数来自动执行<code>std::async</code>的异步启动策略：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> F<span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span><span class="token keyword">inline</span> std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token keyword">typename</span> std<span class="token operator">::</span>result_of<span class="token operator">&lt;</span><span class="token function">F</span><span class="token punctuation">(</span>Ts<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">></span> <span class="token comment" spellcheck="true">// C++14 可以直接用 auto 推导返回值类型</span><span class="token function">reallyAsync</span><span class="token punctuation">(</span>F<span class="token operator">&amp;&amp;</span> f<span class="token punctuation">,</span> Ts<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span>std<span class="token operator">::</span>launch<span class="token operator">::</span>async<span class="token punctuation">,</span>                      std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>F<span class="token operator">></span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">,</span>                      std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Ts<span class="token operator">></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>用于获取可调用对象返回值类型的<code>std::result_of</code>在 C++17 后被弃用，其替代品为<code>std::invoke_result</code>。</p></blockquote><h3 id="条款-37：使-std-thread-对象在所有路径皆不可联结"><a href="#条款-37：使-std-thread-对象在所有路径皆不可联结" class="headerlink" title="条款 37：使 std::thread 对象在所有路径皆不可联结"></a>条款 37：使 std::thread 对象在所有路径皆不可联结</h3><p>当<code>std::thread</code>处于可联结的状态时，它对应于正在运行或可能将要运行的底层执行线程，这包括正在等待调度的或者被阻塞的线程，以及运行结束的线程。</p><p>以下几种<code>std::thread</code>对象处于不可联结的状态：</p><ul><li>默认构造的<code>std::thread</code>。</li><li>已移动的<code>std::thread</code>。</li><li>已联结（join）的<code>std::thread</code>。</li><li>已分离（detach）的<code>std::thread</code>。</li></ul><p>当<code>std::thread</code>执行析构时，若其处于可联结状态，就会导致程序终止运行（通常会调用<code>std::abort</code>）。考虑以下代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">auto</span> tenMillion <span class="token operator">=</span> <span class="token number">10</span><span class="token string">'000'</span><span class="token number">000</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// C++14 的单引号数字分隔符</span><span class="token keyword">bool</span> <span class="token function">doWork</span><span class="token punctuation">(</span>std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> filter<span class="token punctuation">,</span> <span class="token keyword">int</span> maxVal <span class="token operator">=</span> tenMillion<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> goodVals<span class="token punctuation">;</span>    std<span class="token operator">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span>filter<span class="token punctuation">,</span> maxVal<span class="token punctuation">,</span> <span class="token operator">&amp;</span>goodVals<span class="token punctuation">]</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 遍历 goodVals</span>                      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> maxVal<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>                      <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">filter</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> goodVals<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>                  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> nh <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">native_handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 使用 t 的原生句柄来设定线程的优先级</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">conditionAreSatisfied</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                   <span class="token comment" spellcheck="true">// 让 t 结束运行</span>        <span class="token function">performComputation</span><span class="token punctuation">(</span>goodVals<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                                <span class="token comment" spellcheck="true">// 计算已实施</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                                   <span class="token comment" spellcheck="true">// 计算未实施</span><span class="token punctuation">}</span>                                                   <span class="token comment" spellcheck="true">// 此处析构 std::thread 会导致程序终止</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>标准委员会并没有选择让<code>std::thread</code>在销毁时，隐式执行<code>join</code>或<code>detach</code>，因为这带来的问题会比直接让程序终止运行还要严重：</p><ul><li><strong>隐式<code>join</code></strong> 会使<code>std::thread</code>的析构函数等待底层异步线程执行完毕。这听上去很合理，但却可能导致难以追踪的性能异常。例如，即使<code>conditionAreSatisfied</code>已经返回<code>false</code>了，<code>doWork</code>仍然会继续执行遍历操作，这是违反直觉的。</li><li><strong>隐式<code>detach</code></strong> 会使<code>std::thread</code>的析构函数分离<code>std::thread</code>对象和底层执行线程之间的连接，而该底层执行线程会继续运行。这会导致更要命的调试问题。假如<code>conditionAreSatisfied</code>返回了<code>false</code>，则<code>doWork</code>也会直接返回，同时销毁局部变量并弹出栈帧。但线程仍然在<code>doWork</code>的调用点继续运行，并导致栈帧上的内存被意外修改，</li></ul><p>我们可以编写一个 RAII 类，并让调用者自行选择在销毁时为<code>std::thread</code>调用<code>join</code>还是<code>detach</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">ThreadRAII</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">DtorAction</span> <span class="token punctuation">{</span> join<span class="token punctuation">,</span> detach <span class="token punctuation">}</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 关于枚举类，参考条款 20</span>    <span class="token function">ThreadRAII</span><span class="token punctuation">(</span>std<span class="token operator">::</span>thread<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">,</span> DtorAction a<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// 对 t 执行操作 a</span>        <span class="token operator">:</span> <span class="token function">action</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">t</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">ThreadRAII</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 先校验 t 是否处于可联结状态</span>        <span class="token comment" spellcheck="true">// 对不可联结的 std::thread 调用 join 或 detach 是未定义行为</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>action <span class="token operator">==</span> DtorAction<span class="token operator">::</span>join<span class="token punctuation">)</span> <span class="token punctuation">{</span>                t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span>                t<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">ThreadRAII</span><span class="token punctuation">(</span>ThreadRAII<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 支持移动操作</span>    ThreadRAII<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>ThreadRAII<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>thread<span class="token operator">&amp;</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> t<span class="token punctuation">;</span> <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 返回底层的 std::thread 对象</span><span class="token keyword">private</span><span class="token operator">:</span>    DtorAction action<span class="token punctuation">;</span>    std<span class="token operator">::</span>thread t<span class="token punctuation">;</span>                              <span class="token comment" spellcheck="true">// 使 t 最后被初始化，确保它可以安全访问其它成员</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>不需要担心在<code>t.joinable()</code>的执行和<code>join</code>或<code>detach</code>的调用之间，有另一个线程会让<code>t</code>变得不可联结。因为<code>std::thread</code>对象只能通过调用成员函数来从可联结状态转换为不可联结状态，而当<code>ThreadRAII</code>对象的析构函数被调用时，不应该有其它线程调用该对象的成员函数。一般地，若要在一个对象上同时调用两个成员函数，只有当所有这些函数都带有<code>const</code>限定符时才安全（参考<strong>条款 16</strong>）。</p></blockquote><p>在<code>doWork</code>函数的代码中，可以这样使用<code>ThreadRAII</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">doWork</span><span class="token punctuation">(</span>std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> filter<span class="token punctuation">,</span> <span class="token keyword">int</span> maxVal <span class="token operator">=</span> tenMillion<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> goodVals<span class="token punctuation">;</span>    ThreadRAII <span class="token function">t</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span>filter<span class="token punctuation">,</span> maxVal<span class="token punctuation">,</span> <span class="token operator">&amp;</span>goodVals<span class="token punctuation">]</span> <span class="token punctuation">{</span>                                 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> maxVal<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>                                 <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">filter</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> goodVals<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>                             <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                 ThreadRAII<span class="token operator">::</span>DtorAction<span class="token operator">::</span>join<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> nh <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">native_handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">conditionAreSatisfied</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        t<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">performComputation</span><span class="token punctuation">(</span>goodVals<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-38：注意不同线程句柄的析构行为"><a href="#条款-38：注意不同线程句柄的析构行为" class="headerlink" title="条款 38：注意不同线程句柄的析构行为"></a>条款 38：注意不同线程句柄的析构行为</h3><p>future 位于通信信道的一端，被调用者通过该信道将结果发送给调用者。被调用者（通常以异步方式运行）将其计算所得的结果写入信道（通常经过<code>std::promise</code>对象），而调用者则使用 future 来读取该结果。</p><p>但被调用者的结果要存储在哪里呢？既不能存储在被调用者的<code>std::promise</code>对象中，因为它是个局部对象，在被调用者执行结束后会被销毁；也不能存储在调用者的 future 中，因为<code>std::future</code>可能会被用来创建<code>std::shared_future</code>，而后者会导致原始<code>std::future</code>析构之后被多次拷贝，但被调用者的结果并不能保证一定可以被拷贝，很难做到使它与最后一个指向它的 future 生命周期一样长。</p><p>因此该结果会被存储在位于两者外部的某个位置，这个位置称为<strong>共享状态（shared state）</strong>，通常用堆上的对象来表示，但是其类型、接口和实现皆未在标准中指定。我们可以把调用者，被调用者以及共享状态之间的关系用下图来表示：</p><p><img src="https://pic2.zhimg.com/80/v2-006b36a9b3ae2533a73d8c1646d49511_720w.webp" alt></p><p>共享状态的存在非常重要，因为 future 对象的析构行为取决于与其关联的共享状态。具体来说就是：</p><ul><li>常规的 future 对象在析构时仅会析构该 future 的成员变量。这相当于对底层执行线程执行了隐式<code>detach</code>。</li><li>引用了共享状态（使用<code>std::async</code>启动未延迟任务时创建的）的最后一个 future 对象的析构函数将会被阻塞住，直至该任务结束。这相当于对正在运行<code>std::async</code>所创建任务的线程执行了隐式<code>join</code>。</li></ul><p>也就是说，只有在满足下列条件时，future 的非常规析构行为才会被触发：</p><ol><li>future 所引用的共享状态是在调用<code>std::async</code>时创建的；</li><li>该任务执行异步启动策略，即<code>std::launch::async</code>（参考<strong>条款 36</strong>）；</li><li>该 future 是最后一个引用了该共享状态的 future。</li></ol><p>future 的 API 没有提供任何办法判断它引用的共享状态是否诞生于<code>std::async</code>的调用，因此任意给定一个 future 对象，我们没有办法判断它是否会在析构函数中阻塞。这可能会导致一些意外的情况：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 该容器的析构函数可能会发生阻塞</span><span class="token comment" spellcheck="true">// 因为它持有 future 可能会有一个或多个</span><span class="token comment" spellcheck="true">// 满足触发非常规析构行为的条件</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">>></span> futs<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 关于 std::future&lt;void>，参考条款 39</span><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>                          <span class="token comment" spellcheck="true">// Widget 对象的析构函数可能会发生阻塞</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>shared_future<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> fut<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>std::packaged_task</code>也能创建出共享对象，但是其衍生的 future 都会执行常规的析构行为：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">calcValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>packaged_task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span>       <span class="token comment" spellcheck="true">// 给 calcValue 加上包装</span>    <span class="token function">pt</span><span class="token punctuation">(</span>calcValue<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// 使之能以异步方式执行</span>    <span class="token keyword">auto</span> fut <span class="token operator">=</span> pt<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 取得 pt 的 future</span>    std<span class="token operator">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>pt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// std::packaged_task 是只移类型</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                             <span class="token comment" spellcheck="true">// 析构 std::thread（参考条款 37）</span><span class="token punctuation">}</span>                                   <span class="token comment" spellcheck="true">// 以常规方式析构 future 对象 fut</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-39：考虑对一次性事件通信使用-void-的-futures"><a href="#条款-39：考虑对一次性事件通信使用-void-的-futures" class="headerlink" title="条款 39：考虑对一次性事件通信使用 void 的 futures"></a>条款 39：考虑对一次性事件通信使用 void 的 futures</h3><p>有的时候，让一个任务能够在发生了特定事件后，通知另一个异步运行的任务，会是很有用的。为了实现这种简单的事件通信，使用条件变量会是一个显而易见的做法：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>condition_variable cv<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 事件的条件变量</span>std<span class="token operator">::</span>mutex m<span class="token punctuation">;</span>                           <span class="token comment" spellcheck="true">// 配合 cv 使用的互斥量</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                     <span class="token comment" spellcheck="true">// 检测事件</span>cv<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 通知反应任务，对多个任务使用 notify_all</span><span class="token comment" spellcheck="true">// 反应任务的代码</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                     <span class="token comment" spellcheck="true">// 准备作出反应</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lk</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 为互斥量加锁</span>    cv<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lk<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 等待通知到来</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                 <span class="token comment" spellcheck="true">// 针对事件作出反应</span><span class="token punctuation">}</span>                                       <span class="token comment" spellcheck="true">// 通过 lk 的析构函数为 m 解锁</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                     <span class="token comment" spellcheck="true">// 继续等待反应</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种途径会导致以下几个问题：</p><ul><li><strong>代码异味（code smell）：</strong> 虽然代码能够运行，但总感觉哪里不太对劲。此处对互斥量的使用似乎有些多余，互斥量是用于控制共享数据访问的，但检测和反应任务之间大可以根本不需要这种介质。</li><li>如果检测任务在反应任务调用<code>wait</code>之前就通知了条件变量，则反应任务将会失去响应。</li><li>反应任务的<code>wait</code>语句无法应对<strong>虚假唤醒（spurious wakeups）</strong>，即使条件变量没有得到通知，针对该条件变量等待的代码也有可能被唤醒。如果反应线程可以确认它所等待的事件是否已经发生，那么我们可以通过将 lambda 传递给<code>wait</code>来处理这种情况：</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp">cv<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lk<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> 事件是否真的已经发生<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>基于 flag 的设计可以避免上述问题，但这一设计基于轮询而非阻塞，会对 CPU 核心产生额外的性能消耗：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">flag</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 共享的 bool flag</span>                                <span class="token comment" spellcheck="true">// 关于 std::atomic，参考条款 40</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                             <span class="token comment" spellcheck="true">// 检测事件</span>flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 通知反应任务</span><span class="token comment" spellcheck="true">// 反应任务的代码</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                             <span class="token comment" spellcheck="true">// 准备作出反应</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// 等待事件</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                             <span class="token comment" spellcheck="true">// 针对事件作出反应</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>条件变量可以和 flag 一起使用，但这样的通信机制设计看起来不太自然：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>condition_variable cv<span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// 同前</span>std<span class="token operator">::</span>mutex m<span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">flag</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                           <span class="token comment" spellcheck="true">// 非 std::atomic 对象</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                         <span class="token comment" spellcheck="true">// 检测事件</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">g</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 为 m 加锁</span>    flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// 通知反应任务（第一部分）</span><span class="token punctuation">}</span>cv<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// 通知反应任务（第二部分）</span><span class="token comment" spellcheck="true">// 反应任务的代码</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                         <span class="token comment" spellcheck="true">// 准备作出反应</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lk</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 同前</span>    cv<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lk<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>flag<span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> flag<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 使用 lambda 应对虚假唤醒</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                     <span class="token comment" spellcheck="true">// 针对事件作出反应</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                         <span class="token comment" spellcheck="true">// 继续等待反应</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外一种方法是摆脱条件变量，互斥量和 flag，让反应任务去等待检测任务设置的 future。这种设计简单易行，检测任务有一个<code>std::promise</code>对象，反应任务有对应的 future。当检测任务发现它查找的事件已经发生时，它会设置<code>std::promise</code>对象；与此同时，反应任务调用<code>wait</code>以等待它的 future。由于在此处我们并不会真正向信道发送任何数据，所以对于<code>std::promise</code>、<code>std::future</code>和<code>std::shared_future</code>的模板类型形参，都只需使用<code>void</code>即可：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>promise<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span> p<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                     <span class="token comment" spellcheck="true">// 检测事件</span>p<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 通知反应任务</span><span class="token comment" spellcheck="true">// 反应任务的代码</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                     <span class="token comment" spellcheck="true">// 准备作出反应</span>p<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 等待 p 对应的 future</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                     <span class="token comment" spellcheck="true">// 针对事件作出反应</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种手法有两个最大的局限性：</p><ul><li><code>std::promise</code>和 future 之间依赖共享状态，而共享状态会带来在堆上分配和回收空间的成本。</li><li><code>std::promise</code>对象只能设置一次，这意味着该手法只能应用于一次性通信的情况。</li></ul><p>假如你想创建多个能暂停一次的线程，使用<code>void</code> future 手法就是合理的选择。代码演示如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>promise<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span> p<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">detect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> sf <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">share</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// sf 的类型是 std::shared_future&lt;void></span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>thread<span class="token operator">></span> vt<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 反应任务的容器</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threadsToRun<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vt<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token punctuation">[</span>sf<span class="token punctuation">]</span> <span class="token punctuation">{</span> sf<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">react</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// sf 局部副本之上的 wait</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                                 <span class="token comment" spellcheck="true">// 若在此处抛出异常，则 detect 会失去响应！</span>    p<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                      <span class="token comment" spellcheck="true">// 让所有线程取消暂停</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                                 <span class="token comment" spellcheck="true">// 完成其它工作</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> t <span class="token operator">:</span> vt<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                <span class="token comment" spellcheck="true">// 把所有线程设为不可联结的状态</span>        t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-40：对并发使用-std-atomic，对特殊内存使用-volatile"><a href="#条款-40：对并发使用-std-atomic，对特殊内存使用-volatile" class="headerlink" title="条款 40：对并发使用 std::atomic，对特殊内存使用 volatile"></a>条款 40：对并发使用 std::atomic，对特殊内存使用 volatile</h3><p><code>std::atomic</code>可以保证它提供的操作被其它线程视为具有原子性，它产生的效果和受到互斥锁保护的操作类似，但是通常<code>std::atomic</code>的原子操作是通过特定的机器指令实现的，这比锁的实现更高效。考虑以下应用了<code>std::atomic</code>的代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ai</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将 ai 初始化为 0</span>ai <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 原子地将 ai 设为 10</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> ai<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 原子地读取 ai 地值</span><span class="token operator">++</span>ai<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 原子地将 ai 自增为 11</span><span class="token operator">--</span>ai<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 原子地将 ai 自减为 10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，在<code>std::cout &lt;&lt; ai</code>语句中，<code>std::atomic</code>仅能保证对于<code>ai</code>的读取操作具有原子性，而不能保证整条语句都具有原子性，在读取<code>ai</code>的值和调用<code>operator&lt;&lt;</code>之间，可能会有别的线程修改了<code>ai</code>的值，但这对使用按值传参的<code>operator&lt;&lt;</code>并没有什么影响。</p><p><code>ai</code>的自增和自减操作是<strong>读取-修改-写入（read-modify-write，RWM）</strong> 操作，<code>std::atomic</code>能确保它们整体以原子方式执行。这是<code>std::atomic</code>最重要的特性之一：<code>std::atomic</code>对象之上的所有成员函数都能被其它线程视为原子性的。</p><p><code>std::atomic</code>在 RWM 上具有的优势与<code>volatile</code>相比十分明显：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ac</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// atomic counter</span><span class="token keyword">volatile</span> <span class="token keyword">int</span> <span class="token function">vc</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// volatile counter</span><span class="token comment" spellcheck="true">/* 在两个同时运行的线程中各自执行自增操作 */</span><span class="token comment" spellcheck="true">// 线程 1</span><span class="token operator">++</span>ac<span class="token punctuation">;</span><span class="token operator">++</span>vc<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 线程 2</span><span class="token operator">++</span>ac<span class="token punctuation">;</span><span class="token operator">++</span>vc<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在两个执行结束后，<code>ac</code>的值一定为 2，而<code>vc</code>却不一定，数据竞争导致它的最终结果实际上是无法预测的，下面是一种可能的情况：</p><ol><li>线程 1 读取<code>vc</code>的值为 0；</li><li>线程 2 读取<code>vc</code>的值仍为 0；</li><li>线程 1 将读取的值 0 自增为 1，写入<code>vc</code>；</li><li>线程 2 也将读取的值 0 自增为 1，写入<code>vc</code>；</li><li><code>vc</code>最终的值为 1。</li></ol><p>除了 RWM 以外，<code>std::atomic</code>还在确保<strong>顺序一致性（sequential consistency）</strong> 上具有优势，这种一致性是它默认采用的（尽管 C++ 还支持其它的一致性模型，但它们的安全性无法得到保证），它规定：在源代码中，<strong>任何位于<code>std::atomic</code>变量的写入操作之前的代码不得发生于写入操作之后</strong>。使用<code>std::atomic</code>可以保证以下代码中的赋值语句不会进行重新排序：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">valAvailable</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> imptValue <span class="token operator">=</span> <span class="token function">computeImportantValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 计算出值</span>valAvailable <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 通知其它任务，值已可用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果不使用<code>std::atomic</code>，语句的顺序可能会被编译器或底层硬件重新排列，以使得代码运行得更快：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 重新排序后的结果</span>valAvailable <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">auto</span> imptValue <span class="token operator">=</span> <span class="token function">computeImportantValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>std::atomic</code>是只移类型，因此以下代码无法通过编译：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span>y <span class="token operator">=</span> x<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>正确的方式是调用<code>std::atomic</code>的成员函数<code>load</code>和<code>store</code>来以原子方式读取和写入：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">y</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>y<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>尽管在很多时候<code>load</code>和<code>store</code>并不是必要的，但是有些开发者还是很喜欢使用它们，因为这样做可以在代码中明确强调所使用的变量并非常规。这在很大程度上是一个代码风格的问题。</p><p><code>volatile</code>是用来处理特殊内存的工具，它会被用在读写操作不应该被优化的内存上。一般来讲，编译器会为常规内存的冗余读取和写入自动执行优化，例如以下代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 读取 x</span>y <span class="token operator">=</span> x<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 再次读取 x</span>x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 写入 x</span>x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 再次写入 x</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在经过优化后就能变成十分精简的版本：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 读取 x</span>x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 写入 x</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>但对于特殊内存，我们可能不想要编译器去执行这种优化。例如用于内存映射 I/O 的内存，这种内存的位置实际上会被用于与外部设备通信，而非用于读取或写入常规内存。这时，<code>volatile</code>就能派上用场：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">volatile</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 以 volatile 声明 x</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>             <span class="token comment" spellcheck="true">// 初始化 x</span><span class="token keyword">auto</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 读取 x</span>y <span class="token operator">=</span> x<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 再次读取 x（不会被优化掉）</span>x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 写入 x（不会被优化掉）</span>x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 再次写入 x</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>std::atomic</code>和<code>volatile</code>用于不同的目的，它们甚至可以一起使用：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">volatile</span> std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vai<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 针对 vai 的操作具有原子性</span>                                <span class="token comment" spellcheck="true">// 并且不会被优化掉</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="第八章：微调"><a href="#第八章：微调" class="headerlink" title="第八章：微调"></a>第八章：微调</h2><h3 id="条款-41：对于移动成本低且总是被拷贝的可拷贝形参，考虑将其按值传递"><a href="#条款-41：对于移动成本低且总是被拷贝的可拷贝形参，考虑将其按值传递" class="headerlink" title="条款 41：对于移动成本低且总是被拷贝的可拷贝形参，考虑将其按值传递"></a>条款 41：对于移动成本低且总是被拷贝的可拷贝形参，考虑将其按值传递</h3><p>为了实现对传入函数的左值实参执行拷贝，对右值实参执行移动，我们一共有以下三种方法：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>                                  <span class="token comment" spellcheck="true">// 方法一：</span><span class="token keyword">public</span><span class="token operator">:</span>                                         <span class="token comment" spellcheck="true">// 对左值和右值分别重载</span>    <span class="token keyword">void</span> <span class="token function">addName</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> newName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        names<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">addName</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string<span class="token operator">&amp;&amp;</span> newName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        names<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> names<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>                                  <span class="token comment" spellcheck="true">// 方法二：</span><span class="token keyword">public</span><span class="token operator">:</span>                                         <span class="token comment" spellcheck="true">// 使用万能引用</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>    <span class="token keyword">void</span> <span class="token function">addName</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> newName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        names<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>                                  <span class="token comment" spellcheck="true">// 方法三：</span><span class="token keyword">public</span><span class="token operator">:</span>                                         <span class="token comment" spellcheck="true">// 按值传递参数</span>    <span class="token keyword">void</span> <span class="token function">addName</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string newName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        names<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 C++98 中，按值传递的形参总会通过拷贝构造函数创建，但在 C++11 后，形参仅在传入左值时才会被拷贝构造，而如果传入的是个右值，它会被移动构造。</p><p>对于可拷贝的，移动开销低的，并且总是会被拷贝的形参而言，按值传递和按引用传递的效率很接近，而且按值传递更容易实现，还可能会生成更少的目标代码。</p><p>对于不可拷贝的形参，由于它的拷贝构造函数已被禁用，我们也不需要为其左值类型的实参提供支持，只需要编写一个接受右值引用的版本就行了。考虑一个类，它含有一个<code>std::unique_ptr</code>类型的数据成员和对应的 setter，而<code>std::unique_ptr</code>是个只移类型，所以我们只需要编写单个函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">void</span> <span class="token function">setPtr</span><span class="token punctuation">(</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token operator">&amp;&amp;</span> ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        p <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Widget w<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>w<span class="token punctuation">.</span><span class="token function">setPtr</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"Modern C++"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用按值传参的前提是形参移动的成本足够低廉，因为按值传参会比按引用传参多一次额外的移动操作，如果这个前提不成立，那么执行不必要的移动就与执行不必要的拷贝没有什么区别。另外，你应当只对一定会被拷贝的形参考虑使用按值传参，以下代码就是一个反例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">addName</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string newName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newName<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> minLen<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span>newName<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> maxLen<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            names<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> names<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>即使没有向<code>names</code>添加任何内容，该函数也会造成构造和析构<code>newName</code>的开销，而如果使用按引用传参，就可以避免这笔开销。</p><p>通过构造拷贝形参的开销可能会比通过赋值拷贝形参要大得多。考虑以下代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Password</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">explicit</span> <span class="token function">Password</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string pwd<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 按值传参</span>        <span class="token operator">:</span> <span class="token function">text</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>pwd<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">// 对 text 进行构造</span>    <span class="token keyword">void</span> <span class="token function">changeTo</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string newPwd<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 按值传参</span>        text <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>newPwd<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 对 text 进行赋值</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>string text<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 表示密码</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>std<span class="token operator">::</span>string <span class="token function">initPwd</span><span class="token punctuation">(</span><span class="token string">"Supercalifragilisticexpialidocious"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 旧密码</span>Password <span class="token function">p</span><span class="token punctuation">(</span>initPwd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>std<span class="token operator">::</span>string newPassword <span class="token operator">=</span> <span class="token string">"Beware the Jabberwock"</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 新密码</span>p<span class="token punctuation">.</span><span class="token function">changeTo</span><span class="token punctuation">(</span>newPassword<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在此处，旧密码比新密码更长，因此不需要进行任何内存分配和回收。如果采用重载的方式，可能就不会发生任何动态内存管理操作：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Password</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">void</span> <span class="token function">changeTo</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string<span class="token operator">&amp;</span> newPwd<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 对左值的重载</span>        text <span class="token operator">=</span> newPwd<span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">// 若 text.capacity() >= newPwd.size()</span>                                            <span class="token comment" spellcheck="true">// 则可以复用 text 的内存</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在此情形下，使用按值传参就会造成额外的内存分配和回收的开销，这可能会比移动<code>std::string</code>的开销高出几个数量级。</p><p>综上所述，通过赋值拷贝一个形参进行按值传参所造成的额外开销，取决于传参的类型，左值和右值的比例，这个类型是否需要动态分配内存，以及，如果需要分配内存的话，赋值操作符的具体实现，还有赋值目标所占的内存是否至少和赋值源所占的内存一样大。对于<code>std::string</code>来说，开销还取决于实现是否使用了 SSO（参考<strong>条款 29</strong>），如果是，那么要赋的值是否匹配 SSO 缓冲区。</p><p>最后要注意的一点是，按值传参肯定会导致<strong>对象切片（object slicing）</strong> 的问题，所以基类类型不适合用于按值传递：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>                           <span class="token comment" spellcheck="true">//基类</span><span class="token keyword">class</span> <span class="token class-name">SpecialWidget</span> <span class="token operator">:</span> <span class="token keyword">public</span> Widget <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//派生类</span><span class="token keyword">void</span> <span class="token function">processWidget</span><span class="token punctuation">(</span>Widget w<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 针对任意类型的 Widget 的函数</span>                                                <span class="token comment" spellcheck="true">// 包括派生类型</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> SpecialWidget sw<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">processWidget</span><span class="token punctuation">(</span>sw<span class="token punctuation">)</span><span class="token punctuation">;</span>                              <span class="token comment" spellcheck="true">// 发生对象切片，processWidget 只能看到 Widget</span>                                                <span class="token comment" spellcheck="true">// 而非 SpecialWidget</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-42：考虑置入而非插入"><a href="#条款-42：考虑置入而非插入" class="headerlink" title="条款 42：考虑置入而非插入"></a>条款 42：考虑置入而非插入</h3><p>假如你想向 STL 容器中添加新元素，<strong>插入函数（insertion function）</strong> 通常是合乎逻辑的选择，但对于性能狂人而言，其背后所隐含的临时对象带来的开销是难以忍受的。考虑以下代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> vs<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 持有 std::string 对象的容器</span>vs<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">"xyzzy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 添加字符串字面量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此处添加的字符串字面量和<code>std::string</code>类型并不匹配，因此需要先创建一个<code>std::string</code>类型的临时对象，然后再将其绑定到<code>push_back</code>函数的右值引用形参。换句话说，你可以把这句调用看作下面这样：</p><pre class="line-numbers language-cpp"><code class="language-cpp">vs<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"xyzzy"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这之后，<code>push_back</code>会在<code>std::vector</code>中构造出一个形参的副本，这个过程是通过调用移动构造函数来完成的（这已经是第二次调用构造函数了）。在<code>push_back</code>返回后，临时对象将立刻被销毁，这又调用了<code>std::string</code>的析构函数。</p><p>从原理上来说，<strong>置入函数（emplacement function）</strong> 在大部分时候应该比插入函数更高效，而且不会有更低效的可能性。<code>emplace_back</code>函数使用了完美转发，因此调用它不会带来任何的临时对象：</p><pre class="line-numbers language-cpp"><code class="language-cpp">vs<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token string">"xyzzy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但令人遗憾的是，插入函数还是有可能比置入函数更快的，这取决于传递的实参类型，使用的容器种类，置入或插入到容器中的位置，容器中类型的构造函数的异常安全性，和对于禁止重复值的容器（<code>std::set</code>，<code>std::map</code>，<code>std::unordered_set</code>和<code>set::unordered_map</code>）而言，要添加的值是否已经在容器中。不过在以下这些情况，置入函数很有可能会运行得更快：</p><ul><li>待添加的值是通过构造而非赋值方式加入容器。一个反例是向<code>std::vector</code>中已经被占据的位置置入对象：</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> vs<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                 <span class="token comment" spellcheck="true">// 向 vs 中添加元素</span>vs<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>vs<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"xyzzy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 向 vs 的开头添加元素，该位置已经存在对象</span>                                    <span class="token comment" spellcheck="true">// 使用的是赋值而非构造方式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>基于节点的容器一般都使用构造来添加新元素，而大多数标准库容器都是基于节点的，除了<code>std::vector</code>，<code>std::deque</code>和<code>std::string</code>等（<code>std::array</code>也不是基于节点的，但是它不支持置入和插入，所以和我们的讨论无关）。在不是基于节点的容器中，你可以确信<code>emplace_back</code>是使用构造来向容器添加元素的，这对于<code>std::deque</code>的<code>emplace_front</code>也同样成立。</p></blockquote><ul><li>传递的实参类型和容器所持有的类型不同。</li><li>容器不会因为存在重复值而拒绝待添加的值。</li></ul><p>在面对<code>new Widget</code>这样的表达式时，置入函数也没有什么优势。考虑以下两种向<code>std::shared_ptr</code>容器中添加新元素的方式：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">killWidget</span><span class="token punctuation">(</span>Widget<span class="token operator">*</span> pWidget<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 自定义删除器</span>ptrs<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> killWidget<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 和 ptrs.push_back({ new Widget, killWidget }) 等价</span>ptrs<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> killWidget<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此处使用<code>push_back</code>仍然会创建出<code>std::shared_ptr</code>类型的临时对象，但该临时对象却拥有了正面意义，如果在为链表节点分配内存时抛出了内存不足的异常，那么该<code>std::shared_ptr</code>临时对象可以自动调用<code>killWidget</code>来释放<code>Widget</code>的内存；但在使用<code>emplace_back</code>的情况下，起到保障作用的<code>std::shared_ptr</code>临时对象将不再存在，如果发生同样的异常，那么<code>Widget</code>的内存将不可避免地被泄漏。</p><p>如果你参考<strong>条款 21</strong> 所述，使用独立语句将<code>new Widget</code>产生的指针转交给资源管理对象，那么使用置入函数和插入函数的效果也是差不多的：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> killWidget<span class="token punctuation">)</span><span class="token punctuation">;</span>ptrs<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>spw<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 或 ptrs.emplace_back(std::move(spw))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>最后需要注意的一点是，置入函数可能会执行在插入函数中会被拒绝的类型转换。这是因为置入函数使用的是直接初始化，而插入函数使用的是拷贝初始化，只有直接初始化会将带有<code>explicit</code>限定符的构造函数纳入考虑范围。因此在使用置入函数时，要特别关注是否传递了正确的实参：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>regex<span class="token operator">></span> regexes<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// C++11 提供了对正则表达式的支持</span>regexes<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 无法通过编译！</span>regexes<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 能通过编译，但会产生未定义行为</span>                                    <span class="token comment" spellcheck="true">// 相当于执行 std::regex(nullptr)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一章：类型推导&quot;&gt;&lt;a href=&quot;#第一章：类型推导&quot; class=&quot;headerlink&quot; title=&quot;第一章：类型推导&quot;&gt;&lt;/a&gt;第一章：类型推导&lt;/h2&gt;&lt;h3 id=&quot;条款-1：理解模板类型推导&quot;&gt;&lt;a href=&quot;#条款-1：理解模板类型推导&quot; c
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>ModernCpp快速教程</title>
    <link href="https://joytsing.github.io/posts/35627/"/>
    <id>https://joytsing.github.io/posts/35627/</id>
    <published>2023-09-26T07:14:00.000Z</published>
    <updated>2023-09-26T11:47:56.722Z</updated>
    
    <content type="html"><![CDATA[<p>这篇笔记是<a href="https://changkun.de/modern-cpp/zh-cn/00-preface/">现代C++教材：告诉上手C++11/14/17/20</a>的学习记录，目的是为了让cmu15445做的不那么痛苦，因为对于该实验来说，由于 Bustub 是在 C++17 下实现的数据库，因此所有学生都需要在正式开始之前，完成 Project #0 来检测对C++，尤其是 C++ 现代语法的熟悉程度，对于选这门课的学生所有没有以满分通关这个 Project 的同学都会被要求 drop 掉这门课。</p><h2 id="第-1-章-迈向现代C"><a href="#第-1-章-迈向现代C" class="headerlink" title="第 1 章 迈向现代C++"></a>第 1 章 迈向现代C++</h2><ul><li><strong><code>auto_ptr</code> 被弃用，应使用 <code>unique_ptr</code>。</strong></li><li><strong>C 语言风格的类型转换被弃用（即在变量前使用 <code>(convert_type)</code>），应该使用 <code>static_cast</code>、<code>reinterpret_cast</code>、<code>const_cast</code> 来进行类型转换。</strong><br>在编写 C++ 时，也应该尽可能的避免使用诸如 <code>void*</code> 之类的程序风格。而在不得不使用 C 时，应该注意使用 <code>extern &quot;C&quot;</code> 这种特性，将 C 语言的代码与 C++代码进行分离编译，再统一链接这种做法，例如：</li></ul><h2 id="第-2-章-语言可用性的强化"><a href="#第-2-章-语言可用性的强化" class="headerlink" title="第 2 章 语言可用性的强化"></a>第 2 章 语言可用性的强化</h2><h3 id="2-1-常量"><a href="#2-1-常量" class="headerlink" title="2.1 常量"></a>2.1 常量</h3><h4 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h4><p><code>nullptr</code> 出现的目的是为了替代 <code>NULL</code>。在某种意义上来说，传统 C++ 会把 <code>NULL</code>、<code>0</code> 视为同一种东西，这取决于编译器如何定义 <code>NULL</code>，有些编译器会将 <code>NULL</code> 定义为 <code>((void*)0)</code>，有些则会直接将其定义为 <code>0</code>。</p><p>C++ <strong>不允许</strong>直接将 <code>void *</code> 隐式转换到其他类型。但如果编译器尝试把 <code>NULL</code> 定义为 <code>((void*)0)</code>，那么在下面这句代码中：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span>ch <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>没有了 <code>void *</code> 隐式转换的 C++ 只好将 <code>NULL</code> 定义为 <code>0</code>。而这依然会产生新的问题，将 <code>NULL</code> 定义成 <code>0</code> 将导致 <code>C++</code> 中重载特性发生混乱。考虑下面这两个 <code>foo</code> 函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>那么 <code>foo(NULL);</code> 这个语句将会去调用 <code>foo(int)</code>，从而导致代码违反直觉。</p><p>为了解决这个问题，C++11 引入了 <code>nullptr</code> 关键字，专门用来区分空指针、<code>0</code>。而 <code>nullptr</code> 的类型为 <code>nullptr_t</code>，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较。</p><p><code>NULL</code> 不同于 <code>0</code> 与 <code>nullptr</code>。所以，请养成直接使用 <code>nullptr</code>的习惯。</p><p><code>decltype</code> 和 <code>std::is_same</code> 这两个属于现代 C++ 的语法，简单来说，<code>decltype</code> 用于类型推导，而 <code>std::is_same</code> 用于比较两个类型是否相同。</p><h4 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h4><p>C++ 本身已经具备了常量表达式的概念，比如 <code>1+2</code>, <code>3*4</code> 这种表达式总是会产生相同的结果并且没有任何副作用。如果编译器能够在编译时就把这些表达式直接优化并植入到程序运行时，将能增加程序的性能。一个非常明显的例子就是在数组的定义阶段：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>  </span><span class="token macro property">#<span class="token directive keyword">define</span> LEN 10  </span><span class="token keyword">int</span> <span class="token function">len_foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> i<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">len_foo_constexpr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token number">5</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">fibonacci</span><span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">char</span> arr_1<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">// 合法  </span>    <span class="token keyword">char</span> arr_2<span class="token punctuation">[</span>LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">// 合法  </span>    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// char arr_3[len];                  // 非法  </span>    <span class="token keyword">const</span> <span class="token keyword">int</span> len_2 <span class="token operator">=</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token keyword">constexpr</span> <span class="token keyword">int</span> len_2_constexpr <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// char arr_4[len_2];                // 非法  </span>    <span class="token keyword">char</span> arr_4<span class="token punctuation">[</span>len_2_constexpr<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 合法  </span>    <span class="token comment" spellcheck="true">// char arr_5[len_foo()+5];          // 非法  </span>    <span class="token keyword">char</span> arr_6<span class="token punctuation">[</span><span class="token function">len_foo_constexpr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 合法  </span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 1, 1, 2, 3, 5, 8, 13, 21, 34, 55  </span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的例子中，<code>char arr_4[len_2]</code> 可能比较令人困惑，因为 <code>len_2</code> 已经被定义为了常量。为什么 <code>char arr_4[len_2]</code> 仍然是非法的呢？这是因为 C++ 标准中数组的长度必须是一个常量表达式，而对于 <code>len_2</code> 而言，这是一个 <code>const</code> 常数，而不是一个常量表达式，因此（即便这种行为在大部分编译器中都支持，但是）它是一个非法的行为，我们需要使用接下来即将介绍的 C++11 引入的 <code>constexpr</code> 特性来解决这个问题；而对于 <code>arr_5</code> 来说，C++98 之前的编译器无法得知 <code>len_foo()</code> 在运行期实际上是返回一个常数，这也就导致了非法的产生。</p><blockquote><p>注意，现在大部分编译器其实都带有自身编译优化，很多非法行为在编译器优化的加持下会变得合法，若需重现编译报错的现象需要使用老版本的编译器。</p></blockquote><p>C++11 提供了 <code>constexpr</code> 让用户显式的声明函数或对象构造函数在编译期会成为常量表达式，这个关键字明确的告诉编译器应该去验证 <code>len_foo</code> 在编译期就应该是一个常量表达式。</p><p>此外，<code>constexpr</code> 修饰的函数可以使用递归：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">fibonacci</span><span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>从 C++14 开始，<code>constexpr</code> 函数可以在内部使用局部变量、循环和分支等简单语句，但是对于C++11来说则需要简化到如上述代码才行，因为无法使用分支语句。</p><h3 id="2-2-变量及其初始化"><a href="#2-2-变量及其初始化" class="headerlink" title="2.2 变量及其初始化"></a>2.2 变量及其初始化</h3><h4 id="if-switch变量声明强化"><a href="#if-switch变量声明强化" class="headerlink" title="if/switch变量声明强化"></a>if/switch变量声明强化</h4><p>在传统 C++ 中，变量的声明虽然能够位于任何位置，甚至于 <code>for</code> 语句内能够声明一个临时变量 <code>int</code>，但始终没有办法在 <code>if</code> 和 <code>switch</code> 语句中声明一个临时的变量。也就是需要在全局声明后才能在局部代码域内使用，比如：</p><pre class="line-numbers language-cpp"><code class="language-cpp">    <span class="token comment" spellcheck="true">// 在 c++17 之前  </span>    <span class="token keyword">const</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator itr <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>itr <span class="token operator">!=</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token operator">*</span>itr <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>itr</code> 这一变量是定义在整个 <code>main()</code> 的作用域内的，这导致当我们需要再次遍历整个 <code>std::vector</code> 时，需要重新命名另一个变量(因为容器已经更改了迭代器失效)。C++17 消除了这一限制，使得我们可以在 <code>if</code>（或 <code>switch</code>）中完成这一操作：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 将临时变量放到 if 语句内  </span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator itr <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      itr <span class="token operator">!=</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token operator">*</span>itr <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><p>初始化是一个非常重要的语言特性，最常见的就是在对象进行初始化时进行使用。 在传统 C++ 中，不同的对象有着不同的初始化方法，例如普通数组、 POD （<strong>P</strong>lain <strong>O</strong>ld <strong>D</strong>ata，即没有构造、析构和虚函数的类或结构体） 类型都可以使用 <code>{}</code> 进行初始化，也就是我们所说的初始化列表。 而对于类对象的初始化，要么需要通过拷贝构造、要么就需要使用 <code>()</code> 进行。 这些不同方法都针对各自对象，不能通用。</p><p>比如最常见的：<br><img src="/posts/35627/image-20230919213531943.png" alt></p><p>为解决这个问题，C++11 首先把初始化列表的概念绑定到类型上，称其为 <code>std::initializer_list</code>，允许构造函数或其他函数像参数一样使用初始化列表，这就为类对象的初始化与普通数组和 POD 的初始化方法提供了统一的桥梁:</p><p><img src="/posts/35627/image-20230919213518078.png" alt><br>出现这个的原因是在C++中，当创建一个对象时，编译器要保证调用了所有子对象的构造函数，这是C++强制要求的，也是它的一个机制。而在一些自定义类中没有定义默认构造函数，只定义了一个有整型参数的构造函数，因此编译器并不会再去生成一个默认的构造函数，而BaseChild继承Base时，又没有显式地指定Base的构造函数，所以编译报错。</p><p>如果不修改Base，那么，我们用什么办法不去调用默认构造函数，而是显式的调用Base带参构造函数呢。答案就是初始化列表。</p><h4 id="结构化绑定"><a href="#结构化绑定" class="headerlink" title="结构化绑定"></a>结构化绑定</h4><p>结构化绑定提供了类似其他语言中提供的多返回值的功能。在容器一章中，我们会学到 C++11 新增了 <code>std::tuple</code> 容器用于构造一个元组，进而囊括多个返回值。但缺陷是，C++11/14 并没有提供一种简单的方法直接从元组中拿到并定义元组中的元素，尽管我们可以使用 <code>std::tie</code> 对元组进行拆包，但我们依然必须非常清楚这个元组包含多少个对象，各个对象是什么类型，非常麻烦。</p><p>C++17 完善了这一设定，给出的结构化绑定可以让我们写出这样的代码：</p><p><img src="/posts/35627/image-20230919215615980.png" alt></p><p>换句话说就是例如：返回一个结构体函数</p><pre class="line-numbers language-cpp"><code class="language-cpp">MyStruct <span class="token function">getStruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> MyStruct<span class="token punctuation">{</span><span class="token number">42</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时我们可以直接通过结构化绑定拿到结构体的成员。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> <span class="token punctuation">[</span>id<span class="token punctuation">,</span> val<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">getStruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>另一个比较有意思的使用地方在于可以增加代码可读性，例如输出map中所有的键值对。map如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> std<span class="token operator">::</span>string<span class="token operator">></span> mymap <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"el"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"tom"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"nic"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结构化绑定之前我们遍历给定的是无意义的elem。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> elem <span class="token operator">:</span> mymap<span class="token punctuation">)</span> <span class="token punctuation">{</span>  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> elem<span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span>  <span class="token operator">&lt;&lt;</span> elem<span class="token punctuation">.</span>second <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>有了结构体绑定之后，我们只需要<code>[key, val]</code>。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span> val<span class="token punctuation">]</span> <span class="token operator">:</span> mymap<span class="token punctuation">)</span> <span class="token punctuation">{</span>  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> key <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> val <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="左值引用限定符"><a href="#左值引用限定符" class="headerlink" title="左值引用限定符"></a>左值引用限定符</h4><p>刚才我们见到的结构化绑定都有一个复制的过程，会产生一个匿名对象。有时候复制的开销会比较大，我们当然想避免不必要的复制。于是我们可以为结构化绑定添加一个引用限定符，以引用的方式绑定到相应的对象上。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>还记得刚刚说过结构化绑定过程中的匿名变量吗？它再一次派上大用场了。如果结构化绑定声明中包含引用限定符，那么这个引入的匿名变量就是一个引用！</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span><span class="token operator">&amp;</span> _unnamed_ <span class="token operator">=</span> arr<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>a <span class="token operator">=</span> _unnamed_<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>b <span class="token operator">=</span> _unnamed_<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>c <span class="token operator">=</span> _unnamed_<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>引用 <code>_unnamed_</code> 绑定到 <code>arr</code>，而 <code>a</code> 又绑定到 <code>_unnamed_[0]</code>，也就是说 <code>a</code> 直接绑定到了 <code>arr[0]</code> 上。<code>b</code> 和 <code>c</code> 同理。再一次强调，即使添加了引用限定符，结构化绑定也不是引用，<code>decltype(a)</code> 仍然是 <code>int</code> 而不是 <code>int&amp;</code>。这里的引用只是为了表达绑定关系。</p><p>定义引用不会产生可观察的副作用，我们也就无法直接证明这个匿名变量确实是引用。当然我们还是可以从侧面来应证它，比如说左值引用不能绑定到右值。</p><pre class="line-numbers language-cpp"><code class="language-cpp">B <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> B<span class="token punctuation">{</span><span class="token number">114</span><span class="token punctuation">,</span> <span class="token number">514</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Error，按值返回的函数调用是右值表达式</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="右值引用限定符"><a href="#右值引用限定符" class="headerlink" title="右值引用限定符"></a>右值引用限定符</h4><p>如果你要绑定右值表达式，自然可以用右值引用。实际上在结构化绑定中说“右值引用”限定符并不准确，毕竟前面还有一个 <code>auto</code> 占位符。<code>auto&amp;&amp;</code> 是不是右值引用可就说不准了，让我们来复习一下。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Error，右值引用不能绑定左值</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> rref <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// OK，auto&amp;&amp;会进行推导</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> lref <span class="token operator">=</span> i<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的示例代码中，<code>auto&amp;&amp; lref = i</code> 会进行类型推导，由于初始化器<code>i</code>是个左值，推导出 <code>auto -&gt; int&amp;</code> 再经过引用折叠 <code>int&amp; &amp;&amp; -&gt; int&amp;</code> 最终得到 <code>lref</code> 是个左值引用。</p><p>结构化绑定引入的匿名变量也是如此，如果引用限定符是 <code>&amp;&amp;</code> 那么匿名变量的类型就会根据这一规则自动推导，这也是 <code>auto&amp;&amp;</code> 被称为万能引用的原因。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">;</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> _unnamed_ <span class="token operator">=</span> arr<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 经过推导得到左值引用：</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>_unnamed_<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-类型推断"><a href="#2-3-类型推断" class="headerlink" title="2.3 类型推断"></a>2.3 类型推断</h3><p>C++11 引入了 <code>auto</code> 和 <code>decltype</code> 这两个关键字实现了类型推导，让编译器来操心变量的类型。这使得 C++ 也具有了和其他现代编程语言一样，某种意义上提供了无需操心变量类型的使用习惯。</p><h4 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h4><p>使用 <code>auto</code> 进行类型推导的一个最为常见而且显著的例子就是迭代器。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 在 C++11 之前  </span><span class="token comment" spellcheck="true">// 由于 cbegin() 将返回 vector&lt;int>::const_iterator  </span><span class="token comment" spellcheck="true">// 所以 it 也应该是 vector&lt;int>::const_iterator 类型  </span><span class="token keyword">for</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>const_iterator it <span class="token operator">=</span> vec<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> vec<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>而有了 <code>auto</code> 之后可以：</p><pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token comment" spellcheck="true">// 从 C++11 起, 使用 auto 关键字进行类型推导  </span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> list<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span> <span class="token punctuation">{</span>              vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：<code>auto</code> 还不能用于推导数组类型：</p><h4 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h4><p><code>decltype</code> 关键字是为了解决 <code>auto</code> 关键字只能对变量进行类型推导的缺陷而出现的。它的用法和 <code>typeof</code> 很相似：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">decltype</span><span class="token punctuation">(</span>表达式<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>有时候，我们可能需要计算某个表达式的类型，例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">auto</span> y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>x<span class="token operator">+</span>y<span class="token punctuation">)</span> z<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="尾返回类型"><a href="#尾返回类型" class="headerlink" title="尾返回类型"></a>尾返回类型</h4><p>在介绍 <code>auto</code> 时，我们已经提过 <code>auto</code> 不能用于函数形参进行类型推导，那么 <code>auto</code> 能不能用于推导函数的返回类型呢？还是考虑一个加法函数的例子，在传统 C++ 中我们必须这么写：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> R<span class="token punctuation">,</span> <span class="token keyword">typename</span> T<span class="token punctuation">,</span> <span class="token keyword">typename</span> U<span class="token operator">></span>R <span class="token function">add</span><span class="token punctuation">(</span>T x<span class="token punctuation">,</span> U y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> x<span class="token operator">+</span>y<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用 <code>decltype</code> 推导 <code>x+y</code> 的类型，写出这样的代码:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">decltype</span><span class="token punctuation">(</span>x<span class="token operator">+</span>y<span class="token punctuation">)</span> <span class="token function">add</span><span class="token punctuation">(</span>T x<span class="token punctuation">,</span> U y<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是因为在编译器读到 decltype(x+y) 时，<code>x</code> 和 <code>y</code> 尚未被定义。为了解决这个问题，C++11 还引入了一个叫做尾返回类型（trailing return type），利用 <code>auto</code> 关键字将返回类型后置：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> <span class="token keyword">typename</span> U<span class="token operator">></span>  <span class="token keyword">auto</span> <span class="token function">add2</span><span class="token punctuation">(</span>T x<span class="token punctuation">,</span> U y<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>x<span class="token operator">+</span>y<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>从 C++14 开始是可以直接让普通函数具备返回值推导,也就是无需再使用decltype而是直接用auto关键字即可。</p><h4 id="decltype-auto"><a href="#decltype-auto" class="headerlink" title="decltype(auto)"></a>decltype(auto)</h4><p><code>decltype(auto)</code> 是 C++14 开始提供的一个略微复杂的用法。简单来说，<code>decltype(auto)</code> 主要用于对转发函数或封装的返回类型进行推导，它使我们无需显式的指定 <code>decltype</code> 的参数表达式。考虑看下面的例子，当我们需要对下面两个函数进行封装时:</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>string  <span class="token function">lookup1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&lt;</span>br<span class="token operator">></span>std<span class="token operator">::</span>string<span class="token operator">&amp;</span> <span class="token function">lookup2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 C++11 中，封装实现是如下形式：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>string <span class="token function">look_up_a_string_1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token function">lookup1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  std<span class="token operator">::</span>string<span class="token operator">&amp;</span> <span class="token function">look_up_a_string_2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token function">lookup2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而有了 <code>decltype(auto)</code>，我们可以让编译器完成这一件烦人的参数转发：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> <span class="token function">look_up_a_string_1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token function">lookup1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> <span class="token function">look_up_a_string_2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token function">lookup2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-控制流"><a href="#2-4-控制流" class="headerlink" title="2.4 控制流"></a>2.4 控制流</h3><p>正如本章开头出，我们知道了 C++11 引入了 <code>constexpr</code> 关键字，它将表达式或函数编译为常量结果。一个很自然的想法是，如果我们把这一特性引入到条件判断中去，让代码在编译时就完成分支判断，岂不是能让程序效率更高？C++17 将 <code>constexpr</code> 这个关键字引入到 <code>if</code> 语句中，允许在代码中声明常量表达式的判断条件，考虑下面的代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>  </span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>  <span class="token keyword">auto</span> <span class="token function">print_type_info</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>is_integral<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> t <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> t <span class="token operator">+</span> <span class="token number">0.001</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">print_type_info</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">print_type_info</span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在编译时，实际代码就会表现为如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">print_type_info</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> t <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">double</span> <span class="token function">print_type_info</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">double</span><span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> t <span class="token operator">+</span> <span class="token number">0.001</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">print_type_info</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">print_type_info</span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="区间for迭代"><a href="#区间for迭代" class="headerlink" title="区间for迭代"></a>区间for迭代</h4><p>C++11 引入了基于范围的迭代写法，我们拥有了能够写出像 Python 一样简洁的循环语句，我们可以进一步简化前面的例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span>  </span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vec <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> itr <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> itr <span class="token operator">!=</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span>itr <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> element <span class="token operator">:</span> vec<span class="token punctuation">)</span>          std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> element <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// read only  </span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>element <span class="token operator">:</span> vec<span class="token punctuation">)</span> <span class="token punctuation">{</span>          element <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">// writeable  </span>    <span class="token punctuation">}</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> element <span class="token operator">:</span> vec<span class="token punctuation">)</span>          std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> element <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// read only  </span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以配合结构化绑定查看插入是否成功：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 优雅地检查map的插入操作是否成功</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token punctuation">[</span>iter<span class="token punctuation">,</span> ok<span class="token punctuation">]</span> <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">42</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ok<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">auto</span> <span class="token punctuation">[</span>k<span class="token punctuation">,</span> v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">*</span>iter<span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nnew item: { %d: %d }\n"</span><span class="token punctuation">,</span> k<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">auto</span> <span class="token punctuation">[</span>k<span class="token punctuation">,</span> v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">*</span>iter<span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nkey exsists: { %d: %d }\n"</span><span class="token punctuation">,</span> k<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-5-模板"><a href="#2-5-模板" class="headerlink" title="2.5 模板"></a>2.5 模板</h3><p>模板的哲学在于将一切能够在编译期处理的问题丢到编译期进行处理，仅在运行时处理那些最核心的动态服务，进而大幅优化运行期的性能。</p><h4 id="外部模板"><a href="#外部模板" class="headerlink" title="外部模板"></a>外部模板</h4><p>传统 C++ 中，模板只有在使用时才会被编译器实例化。换句话说，只要在每个编译单元（文件）中编译的代码中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致的编译时间的增加。并且，我们没有办法通知编译器不要触发模板的实例化。</p><p>为此，C++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使我们能够显式的通知编译器何时进行模板的实例化：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token keyword">class</span> <span class="token class-name">std</span><span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 强行实例化</span><span class="token keyword">extern</span> <span class="token keyword">template</span> <span class="token keyword">class</span> <span class="token class-name">std</span><span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不在该当前编译文件中实例化模板</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="类型别名模板"><a href="#类型别名模板" class="headerlink" title="类型别名模板"></a>类型别名模板</h4><p>在了解类型别名模板之前，需要理解『模板』和『类型』之间的不同。仔细体会这句话：<strong>模板是用来产生类型的。</strong> 在传统 C++ 中，<code>typedef</code> 可以为类型定义一个新的名称，但是却没有办法为模板定义一个新的名称。因为，模板不是类型。例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 不合法</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">typedef</span> MagicType<span class="token operator">&lt;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">,</span> std<span class="token operator">::</span>string<span class="token operator">></span> FakeDarkMagic<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>C++11 使用 <code>using</code> 引入了下面这种形式的写法，并且同时支持对传统 <code>typedef</code> 相同的功效：<br><strong>通常我们使用 <code>typedef</code> 定义别名的语法是：<code>typedef 原名称 新名称;</code>，但是对函数指针等别名的定义语法却不相同，这通常给直接阅读造成了一定程度的困难。</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>process<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">using</span> NewProcess <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">using</span> TrueDarkMagic <span class="token operator">=</span> MagicType<span class="token operator">&lt;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">,</span> std<span class="token operator">::</span>string<span class="token operator">></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="变长参数模板"><a href="#变长参数模板" class="headerlink" title="变长参数模板"></a>变长参数模板</h4><p> 在 C++11 之前，无论是类模板还是函数模板，都只能按其指定的样子， 接受一组固定数量的模板参数；而 C++11 加入了新的表示方法， 允许任意个数、任意类别的模板参数，同时也不需要在定义时将参数的个数固定。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Magic</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>模板类 Magic 的对象，能够接受不受限制个数的 typename 作为模板的形式参数，例如下面的定义：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Magic</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span>              std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span>              std<span class="token operator">::</span>map<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span>              std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">></span> darkMagic<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>既然是任意形式，所以个数为 <code>0</code> 的模板参数也是可以的：<code>class Magic&lt;&gt; nothing;</code>。如果不希望产生的模板参数个数为 <code>0</code>，可以手动的定义至少一个模板参数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Require<span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Magic</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>变长参数模板也能被直接调整到到模板函数上。传统 C 中的 <code>printf</code> 函数， 虽然也能达成不定个数的形参的调用，但其并非类别安全。 而 C++11 除了能定义类别安全的变长参数函数外， 还可以使类似 <code>printf</code> 的函数能自然地处理非自带类别的对象。 除了在模板参数中能使用 <code>...</code> 表示不定长模板参数外， 函数参数也使用同样的表示法代表不定长参数， 这也就为我们简单编写变长参数函数提供了便捷的手段，例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>str<span class="token punctuation">,</span> Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么我们定义了变长的模板参数，如何对参数进行解包呢？</p><p><strong>!!!!</strong> <strong>首先</strong>，我们可以使用 <code>sizeof...</code> 来计算参数的个数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">magic</span><span class="token punctuation">(</span>Ts<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其次，对参数进行解包，到目前为止还没有一种简单的方法能够处理参数包，但有两种经典的处理手法：</p><h5 id="1-递归模板函数"><a href="#1-递归模板函数" class="headerlink" title="1.递归模板函数"></a>1.递归模板函数</h5><p>递归是非常容易想到的一种手段，也是最经典的处理方法。这种方法不断递归地向函数传递模板参数，进而达到递归遍历所有模板参数的目的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>  </span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T0<span class="token operator">></span>  <span class="token keyword">void</span> <span class="token function">printf1</span><span class="token punctuation">(</span>T0 value<span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span>  <span class="token keyword">void</span> <span class="token function">printf1</span><span class="token punctuation">(</span>T value<span class="token punctuation">,</span> Ts<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>      <span class="token function">printf1</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">printf1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"123"</span><span class="token punctuation">,</span> <span class="token number">1.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-变参模板展开"><a href="#2-变参模板展开" class="headerlink" title="2.变参模板展开"></a>2.变参模板展开</h5><p>在 C++17 中增加了变参模板展开的支持，于是你可以在一个函数中完成 <code>printf</code> 的编写：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T0<span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">printf2</span><span class="token punctuation">(</span>T0 t0<span class="token punctuation">,</span> T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> t0 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">printf2</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>事实上，有时候我们虽然使用了变参模板，却不一定需要对参数做逐个遍历，我们可以利用 <code>std::bind</code> 及完美转发等特性实现对函数和参数的绑定，从而达到成功调用的目的。</p><h4 id="非类型模板参数推导"><a href="#非类型模板参数推导" class="headerlink" title="非类型模板参数推导"></a>非类型模板参数推导</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> <span class="token keyword">int</span> BufSize<span class="token operator">></span>  <span class="token keyword">class</span> <span class="token class-name">buffer_t</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span><span class="token operator">:</span>      T<span class="token operator">&amp;</span> <span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">void</span> <span class="token function">free</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">private</span><span class="token operator">:</span>      T data<span class="token punctuation">[</span>BufSize<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  buffer_t<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token operator">></span> buf<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 100 作为模板参数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这种模板参数形式下，我们可以将 <code>100</code> 作为模板的参数进行传递。 在 C++11 引入了类型推导这一特性后，我们会很自然的问，既然此处的模板参数 以具体的字面量进行传递，能否让编译器辅助我们进行类型推导， 通过使用占位符 <code>auto</code> 从而不再需要明确指明类型？ 幸运的是，C++17 引入了这一特性，我们的确可以 <code>auto</code> 关键字，让编译器辅助完成具体类型的推导， 例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">auto</span> value<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      foo<span class="token operator">&lt;</span><span class="token number">10</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// value 被推导为 int 类型  </span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-6-面向对象"><a href="#2-6-面向对象" class="headerlink" title="2.6 面向对象"></a>2.6 面向对象</h3><h4 id="委托构造"><a href="#委托构造" class="headerlink" title="委托构造"></a>委托构造</h4><p>C++11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>  </span><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span><span class="token operator">:</span>      <span class="token keyword">int</span> value1<span class="token punctuation">;</span>      <span class="token keyword">int</span> value2<span class="token punctuation">;</span>      <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          value1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 委托 Base() 构造函数  </span>        value2 <span class="token operator">=</span> value<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      Base <span class="token function">b</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> b<span class="token punctuation">.</span>value1 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> b<span class="token punctuation">.</span>value2 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="继承构造"><a href="#继承构造" class="headerlink" title="继承构造"></a>继承构造</h4><p>在传统 C++ 中，构造函数如果需要继承是需要将参数一一传递的，这将导致效率低下。C++11 利用关键字 <code>using</code> 引入了继承构造函数的概念：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> value1<span class="token punctuation">;</span>    <span class="token keyword">int</span> value2<span class="token punctuation">;</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        value1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 委托 Base() 构造函数</span>        value2 <span class="token operator">=</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Subclass</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> Base<span class="token operator">::</span>Base<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 继承构造</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Subclass <span class="token class-name">s</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span>value1 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span>value2 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="显式虚函数重载"><a href="#显式虚函数重载" class="headerlink" title="显式虚函数重载"></a>显式虚函数重载</h4><p>在传统 C++ 中，经常容易发生意外重载虚函数的事情。例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Base <span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> SubClass<span class="token operator">:</span> Base <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>SubClass::foo</code> 可能并不是程序员尝试重载虚函数，只是恰好加入了一个具有相同名字的函数。另一个可能的情形是，当基类的虚函数被删除后，子类拥有旧的函数就不再重载该虚拟函数并摇身一变成为了一个普通的类方法，这将造成灾难性的后果。</p><p>C++11 引入了 <code>override</code> 和 <code>final</code> 这两个关键字来防止上述情形的发生。</p><h5 id="override"><a href="#override" class="headerlink" title="override"></a>override</h5><p>当重载虚函数时，引入 <code>override</code> 关键字将显式的告知编译器进行重载，编译器将检查基函数是否存在这样的其函数签名一致的虚函数，否则将无法通过编译：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Base <span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> SubClass<span class="token operator">:</span> Base <span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> override<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 合法</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span> override<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 非法, 父类没有此虚函数</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="final"><a href="#final" class="headerlink" title="final"></a>final</h5><p><code>final</code> 则是为了防止类被继续继承以及终止虚函数继续重载引入的。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Base <span class="token punctuation">{</span>      <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> final<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">struct</span> SubClass1 final<span class="token operator">:</span> Base <span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 合法  </span><span class="token keyword">struct</span> SubClass2 <span class="token operator">:</span> SubClass1 <span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 非法, SubClass1 已 final  </span><span class="token keyword">struct</span> SubClass3<span class="token operator">:</span> Base <span class="token punctuation">{</span>      <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 非法, foo 已 final  </span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="显式禁用默认函数"><a href="#显式禁用默认函数" class="headerlink" title="显式禁用默认函数"></a>显式禁用默认函数</h4><p>在传统 C++ 中，如果程序员没有提供，编译器会默认为对象生成默认构造函数、 复制构造、赋值算符以及析构函数。 另外，C++ 也为所有类定义了诸如 <code>new</code> <code>delete</code> 这样的运算符。 当程序员有需要时，可以重载这部分函数。</p><p>这就引发了一些需求：无法精确控制默认函数的生成行为。 例如禁止类的拷贝时，必须将复制构造函数与赋值算符声明为 <code>private</code>。 尝试使用这些未定义的函数将导致编译或链接错误，则是一种非常不优雅的方式。</p><p>并且，编译器产生的默认构造函数与用户定义的构造函数无法同时存在。 若用户定义了任何构造函数，编译器将不再生成默认构造函数， 但有时候我们却希望同时拥有这两种构造函数，这就造成了尴尬。</p><p>C++11 提供了上述需求的解决方案，允许显式的声明采用或拒绝编译器自带的函数。 例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Magic</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Magic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 显式声明使用编译器生成的构造</span>    Magic<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Magic<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 显式声明拒绝编译器生成构造</span>    <span class="token function">Magic</span><span class="token punctuation">(</span><span class="token keyword">int</span> magic_number<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="强类型枚举"><a href="#强类型枚举" class="headerlink" title="强类型枚举"></a>强类型枚举</h4><p>在传统 C++中，枚举类型并非类型安全，枚举类型会被视作整数，则会让两种完全不同的枚举类型可以进行直接的比较（虽然编译器给出了检查，但并非所有），<strong>甚至同一个命名空间中的不同枚举类型的枚举值名字不能相同</strong>，这通常不是我们希望看到的结果。</p><p>C++11 引入了枚举类（enumeration class），并使用 <code>enum class</code> 的语法进行声明：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">new_enum</span> <span class="token operator">:</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token punctuation">{</span>      value1<span class="token punctuation">,</span>      value2<span class="token punctuation">,</span>      value3 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span>      value4 <span class="token operator">=</span> <span class="token number">100</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样定义的枚举实现了类型安全，首先他不能够被隐式的转换为整数，同时也不能够将其与整数数字进行比较， 更不可能对不同的枚举类型的枚举值进行比较。但相同枚举值之间如果指定的值相同，那么可以进行比较，如上述的value3和value4可以比较。</p><p>而我们希望获得枚举值的值时，将必须显式的进行类型转换，不过我们可以通过重载 <code>&lt;&lt;</code> 这个算符来进行输出，可以收藏下面这个代码段：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>    <span class="token keyword">typename</span> std<span class="token operator">::</span>enable_if<span class="token operator">&lt;</span>std<span class="token operator">::</span>is_enum<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">,</span>        std<span class="token operator">::</span>ostream<span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">&amp;</span> stream<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> stream <span class="token operator">&lt;&lt;</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> std<span class="token operator">::</span>underlying_type<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第-3-章-语言运行期的强化"><a href="#第-3-章-语言运行期的强化" class="headerlink" title="第 3 章 语言运行期的强化"></a>第 3 章 语言运行期的强化</h2><h3 id="3-1-Lambda表达式"><a href="#3-1-Lambda表达式" class="headerlink" title="3.1 Lambda表达式"></a>3.1 Lambda表达式</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p>Lambda 表达式的基本语法如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">[</span>捕获列表<span class="token punctuation">]</span><span class="token punctuation">(</span>参数列表<span class="token punctuation">)</span> <span class="token keyword">mutable</span><span class="token punctuation">(</span>可选<span class="token punctuation">)</span> 异常属性 <span class="token operator">-</span><span class="token operator">></span> 返回类型 <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 函数体  </span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面的语法规则除了 <code>[捕获列表]</code> 内的东西外，其他部分都很好理解，只是一般函数的函数名被略去， 返回值使用了一个 <code>-&gt;</code> 的形式进行（我们在上一节前面的尾返回类型已经提到过这种写法了）。</p><p>所谓捕获列表，其实可以理解为参数的一种类型，Lambda 表达式内部函数体在默认情况下是不能够使用函数体外部的变量的， 这时候捕获列表可以起到传递外部数据的作用。根据传递的行为，捕获列表也分为以下几种：</p><h5 id="1-值捕获"><a href="#1-值捕获" class="headerlink" title="1. 值捕获"></a>1. 值捕获</h5><p>与参数传值类似，值捕获的前提是变量可以拷贝，不同之处则在于，被捕获的变量在 Lambda 表达式被创建时拷贝， 而非调用时才拷贝：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">lambda_value_capture</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> copy_value <span class="token operator">=</span> <span class="token punctuation">[</span>value<span class="token punctuation">]</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    value <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> stored_value <span class="token operator">=</span> <span class="token function">copy_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stored_value = "</span> <span class="token operator">&lt;&lt;</span> stored_value <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这时, stored_value == 1, 而 value == 100.</span>    <span class="token comment" spellcheck="true">// 因为 copy_value 在创建时就保存了一份 value 的拷贝</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-引用捕获"><a href="#2-引用捕获" class="headerlink" title="2. 引用捕获"></a>2. 引用捕获</h5><p>与引用传参类似，引用捕获保存的是引用，值会发生变化。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">lambda_reference_capture</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> copy_value <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>value<span class="token punctuation">]</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    value <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> stored_value <span class="token operator">=</span> <span class="token function">copy_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stored_value = "</span> <span class="token operator">&lt;&lt;</span> stored_value <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这时, stored_value == 100, value == 100.</span>    <span class="token comment" spellcheck="true">// 因为 copy_value 保存的是引用</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-隐式捕获"><a href="#3-隐式捕获" class="headerlink" title="3. 隐式捕获"></a>3. 隐式捕获</h5><p>手动书写捕获列表有时候是非常复杂的，这种机械性的工作可以交给编译器来处理，这时候可以在捕获列表中写一个 <code>&amp;</code> 或 <code>=</code> 向编译器声明采用引用捕获或者值捕获.</p><p>总结一下，捕获提供了 Lambda 表达式对外部值进行使用的功能，捕获列表的最常用的四种形式可以是：</p><ul><li>[] 空捕获列表</li><li>[name1, name2, …] 捕获一系列变量</li><li>[&amp;]引用捕获, 让编译器自行推导引用列表</li><li>[= ]值捕获, 让编译器自行推导值捕获列表</li></ul><h5 id="4-表达式捕获"><a href="#4-表达式捕获" class="headerlink" title="4. 表达式捕获"></a>4. 表达式捕获</h5><p>上面提到的值捕获、引用捕获都是已经在外层作用域声明的变量，因此这些捕获方式捕获的均为左值，而不能捕获右值。</p><p>C++14 给与了我们方便，允许捕获的成员用任意的表达式进行初始化，这就允许了右值的捕获， 被声明的捕获变量类型会根据表达式进行判断，判断方式与使用 <code>auto</code> 本质上是相同的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span>  </span><span class="token comment" spellcheck="true">// std::make_unique</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;utility></span> </span><span class="token comment" spellcheck="true">// std::move</span><span class="token keyword">void</span> <span class="token function">lambda_expression_capture</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> important <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> add <span class="token operator">=</span> <span class="token punctuation">[</span>v1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> v2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>important<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">int</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> x<span class="token operator">+</span>y<span class="token operator">+</span>v1<span class="token operator">+</span><span class="token punctuation">(</span><span class="token operator">*</span>v2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的代码中，important 是一个独占指针，是不能够被 “=” 值捕获到，这时候我们可以将其转移为右值，在表达式中初始化。</p><h3 id="3-2-函数对象包装器"><a href="#3-2-函数对象包装器" class="headerlink" title="3.2 函数对象包装器"></a>3.2 函数对象包装器</h3><h4 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a>std::function</h4><p>Lambda 表达式的本质是一个和函数对象类型相似的类类型（称为闭包类型）的对象（称为闭包对象）， 当 Lambda 表达式的捕获列表为空时，闭包对象还能够转换为函数指针值进行传递，例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>  </span><span class="token keyword">using</span> foo <span class="token operator">=</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 定义函数类型, using 的使用见上一节中的别名语法  </span><span class="token keyword">void</span> <span class="token function">functional</span><span class="token punctuation">(</span>foo f<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 参数列表中定义的函数类型 foo 被视为退化后的函数指针类型 foo*  </span>    <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过函数指针调用函数  </span><span class="token punctuation">}</span>  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>          std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token function">functional</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 传递闭包对象，隐式转换为 foo* 类型的函数指针值  </span>    <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// lambda 表达式调用  </span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码给出了两种不同的调用形式，一种是将 Lambda 作为函数类型传递进行调用， 而另一种则是直接调用 Lambda 表达式，在 C++11 中，统一了这些概念，将能够被调用的对象的类型， 统一称之为可调用类型。而这种类型，便是通过 <code>std::function</code> 引入的。</p><p>C++11 <code>std::function</code> 是一种通用、多态的函数封装， 它的实例可以对任何可以调用的目标实体进行存储、复制和调用操作， 它也是对 C++ 中现有的可调用实体的一种类型安全的包裹（相对来说，函数指针的调用不是类型安全的）， 换句话说，就是函数的容器。当我们有了函数的容器之后便能够更加方便的将函数、函数指针作为对象进行处理。 例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;functional></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>  </span><span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> para<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> para<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// std::function 包装了一个返回值为 int, 参数为 int 的函数  </span>    std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> func <span class="token operator">=</span> foo<span class="token punctuation">;</span>      <span class="token keyword">int</span> important <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>      std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> func2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">int</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">+</span>value<span class="token operator">+</span>important<span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">;</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="std-bind-和-std-placeholder"><a href="#std-bind-和-std-placeholder" class="headerlink" title="std::bind 和 std::placeholder"></a>std::bind 和 std::placeholder</h4><p>而 std::bind 则是用来绑定函数调用的参数的，它解决的需求是我们有时候可能并不一定能够一次性获得调用某个函数的全部参数，通过这个函数， 我们可以将部分调用参数提前绑定到函数身上成为一个新的对象，然后在参数齐全后，完成调用。 例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 将参数1,2绑定到函数 foo 上，</span>    <span class="token comment" spellcheck="true">// 但使用 std::placeholders::_1 来对第一个参数进行占位</span>    <span class="token keyword">auto</span> bindFoo <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> std<span class="token operator">::</span>placeholders<span class="token operator">::</span>_1<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这时调用 bindFoo 时，只需要提供第一个参数即可</span>    <span class="token function">bindFoo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-右值引用"><a href="#3-3-右值引用" class="headerlink" title="3.3 右值引用"></a>3.3 右值引用</h3><h4 id="左值、右值的纯右值、将亡值、右值"><a href="#左值、右值的纯右值、将亡值、右值" class="headerlink" title="左值、右值的纯右值、将亡值、右值"></a>左值、右值的纯右值、将亡值、右值</h4><p>要弄明白右值引用到底是怎么一回事，必须要对左值和右值做一个明确的理解。</p><p><strong>左值 (lvalue, left value)</strong>，顾名思义就是赋值符号左边的值。准确来说， 左值是表达式（不一定是赋值表达式）后依然存在的持久对象。</p><p><strong>右值 (rvalue, right value)</strong>，右边的值，是指表达式结束后就不再存在的<code>临时对象</code>。</p><p>而 C++11 中为了引入强大的右值引用，将右值的概念进行了进一步的划分，分为：纯右值、将亡值。</p><p><strong>纯右值 (prvalue, pure rvalue)</strong>，纯粹的右值，要么是纯粹的字面量，例如 10, true； 要么是求值结果相当于字面量或匿名临时对象，例如 1+2。非引用返回的临时变量、运算表达式产生的临时变量、 原始字面量、Lambda 表达式都属于纯右值。</p><p>需要注意的是，字面量除了字符串字面量以外，均为纯右值。而字符串字面量是一个左值，类型为 const char 数组。例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;type_traits></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 正确，"01234" 类型为 const char [6]，因此是左值</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>left<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"01234"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 断言正确，确实是 const char [6] 类型，注意 decltype(expr) 在 expr 是左值</span>    <span class="token comment" spellcheck="true">// 且非无括号包裹的 id 表达式与类成员表达式时，会返回左值引用</span>    <span class="token keyword">static_assert</span><span class="token punctuation">(</span>std<span class="token operator">::</span>is_same<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token string">"01234"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 错误，"01234" 是左值，不可被右值引用</span>    <span class="token comment" spellcheck="true">// const char (&amp;&amp;right)[6] = "01234";</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是注意，数组可以被隐式转换成相对应的指针类型，而转换表达式的结果（如果不是左值引用）则一定是个右值（右值引用为将亡值，否则为纯右值）。例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span>   p   <span class="token operator">=</span> <span class="token string">"01234"</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 正确，"01234" 被隐式转换为 const char*</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">&amp;&amp;</span> pr  <span class="token operator">=</span> <span class="token string">"01234"</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 正确，"01234" 被隐式转换为 const char*，该转换的结果是纯右值</span><span class="token comment" spellcheck="true">// const char*&amp; pl = "01234"; // 错误，此处不存在 const char* 类型的左值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>将亡值</strong> (xvalue, expiring value)，是 C++11 为了引入右值引用而提出的概念（因此在传统 C++ 中， 纯右值和右值是同一个概念），也就是即将被销毁、却能够被移动的值。</p><p>将亡值可能稍有些难以理解，我们来看这样的代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> temp <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> temp<span class="token punctuation">;</span><span class="token punctuation">}</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这样的代码中，就传统的理解而言，函数 <code>foo</code> 的返回值 <code>temp</code> 在内部创建然后被赋值给 <code>v</code>， 然而 <code>v</code> 获得这个对象时，会将整个 <code>temp</code> 拷贝一份，然后把 <code>temp</code> 销毁，如果这个 <code>temp</code> 非常大， 这将造成大量额外的开销（这也就是传统 C++ 一直被诟病的问题）。</p><p>在最后一行中，<code>v</code> 是左值、 <code>foo()</code> 返回的值就是右值（也是纯右值）。但是，<code>v</code> 可以被别的变量捕获到， 而 <code>foo()</code> 产生的那个返回值作为一个临时值，一旦被 <code>v</code> 复制后，将立即被销毁，无法获取、也不能修改。 而将亡值就定义了这样一种行为：临时的值能够被识别、同时又能够被移动。</p><p>在 C++11 之后，编译器为我们做了一些工作，此处的左值 <code>temp</code> 会被进行此隐式右值转换， 等价于 <code>static_cast&lt;std::vector&lt;int&gt; &amp;&amp;&gt;(temp)</code>，进而此处的 <code>v</code> 会将 <code>foo</code> 局部返回的值进行移动。 也就是后面我们将会提到的移动语义。</p><h4 id="右值引用和左值引用"><a href="#右值引用和左值引用" class="headerlink" title="右值引用和左值引用"></a>右值引用和左值引用</h4><p>要拿到一个将亡值，就需要用到右值引用：T &amp;&amp;，其中 T 是类型。 右值引用的声明让这个临时值的生命周期得以延长、只要变量还活着，那么将亡值将继续存活。</p><p><strong>C++11 提供了 <code>std::move</code> 这个方法将左值参数无条件的转换为右值， 有了它我们就能够方便的获得一个右值临时对象</strong>，例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span>  </span><span class="token keyword">void</span> <span class="token function">reference</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"左值"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">reference</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string<span class="token operator">&amp;&amp;</span> str<span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"右值"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      std<span class="token operator">::</span>string lv1 <span class="token operator">=</span> <span class="token string">"string,"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// lv1 是一个左值  </span>    <span class="token comment" spellcheck="true">// std::string&amp;&amp; r1 = lv1; // 非法, 右值引用不能引用左值  </span>    std<span class="token operator">::</span>string<span class="token operator">&amp;&amp;</span> rv1 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>lv1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 合法, std::move可以将左值转移为右值  </span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> rv1 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// string,  </span>    <span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> lv2 <span class="token operator">=</span> lv1 <span class="token operator">+</span> lv1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 合法, 常量左值引用能够延长临时变量的生命周期  </span>    <span class="token comment" spellcheck="true">// lv2 += "Test"; // 非法, 常量引用无法被修改  </span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> lv2 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// string,string,  </span>    std<span class="token operator">::</span>string<span class="token operator">&amp;&amp;</span> rv2 <span class="token operator">=</span> lv1 <span class="token operator">+</span> lv2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 合法, 右值引用延长临时对象生命周期  </span>    rv2 <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">"Test"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 合法, 非常量引用能够修改临时变量  </span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> rv2 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// string,string,string,Test  </span>    <span class="token function">reference</span><span class="token punctuation">(</span>rv2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出左值  </span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>rv2</code> 虽然引用了一个右值，但由于它是一个引用，所以 <code>rv2</code> 依然是一个左值。注意，这里有一个很有趣的历史遗留问题，我们先看下面的代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>  </span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// int &amp;a = std::move(1);    // 不合法，非常量左引用无法引用右值  </span>    <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>b <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 合法, 常量左引用允许引用右值  </span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一个问题，为什么不允许非常量引用绑定到非左值？这是因为这种做法存在逻辑错误：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">increase</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>    v<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">double</span> s <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">increase</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于 <code>int&amp;</code> 不能引用 <code>double</code> 类型的参数，因此必须产生一个临时值来保存 <code>s</code> 的值， 从而当 <code>increase()</code> 修改这个临时值时，调用完成后 <code>s</code> 本身并没有被修改。</p><p>第二个问题，为什么常量引用允许绑定到非左值？原因很简单，因为 Fortran 需要。</p><h4 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h4><p>传统 C++ 通过拷贝构造函数和赋值操作符为类对象设计了拷贝/复制的概念，但为了实现对资源的移动操作， 调用者必须使用先复制、再析构的方式，否则就需要自己实现移动对象的接口。 试想，搬家的时候是把家里的东西直接搬到新家去，而不是将所有东西复制一份（重买）再放到新家、 再把原来的东西全部扔掉（销毁），这是非常反人类的一件事情。</p><p>传统的 C++ 没有区分『移动』和『拷贝』的概念，造成了大量的数据拷贝，浪费时间和空间。 右值引用的出现恰好就解决了这两个概念的混淆问题，例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token operator">*</span>pointer<span class="token punctuation">;</span>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">pointer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"构造"</span> <span class="token operator">&lt;&lt;</span> pointer <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">A</span><span class="token punctuation">(</span>A<span class="token operator">&amp;</span> a<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">pointer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">.</span>pointer<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"拷贝"</span> <span class="token operator">&lt;&lt;</span> pointer <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 无意义的对象拷贝</span>    <span class="token function">A</span><span class="token punctuation">(</span>A<span class="token operator">&amp;&amp;</span> a<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">pointer</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>pointer<span class="token punctuation">)</span> <span class="token punctuation">{</span>        a<span class="token punctuation">.</span>pointer <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"移动"</span> <span class="token operator">&lt;&lt;</span> pointer <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"析构"</span> <span class="token operator">&lt;&lt;</span> pointer <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token keyword">delete</span> pointer<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 防止编译器优化</span>A <span class="token function">return_rvalue</span><span class="token punctuation">(</span><span class="token keyword">bool</span> test<span class="token punctuation">)</span> <span class="token punctuation">{</span>    A a<span class="token punctuation">,</span>b<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span> <span class="token keyword">return</span> a<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 等价于 static_cast&lt;A&amp;&amp;>(a);</span>    <span class="token keyword">else</span> <span class="token keyword">return</span> b<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 等价于 static_cast&lt;A&amp;&amp;>(b);</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    A obj <span class="token operator">=</span> <span class="token function">return_rvalue</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"obj:"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> obj<span class="token punctuation">.</span>pointer <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>obj<span class="token punctuation">.</span>pointer <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的代码中：</p><ol><li>首先会在 <code>return_rvalue</code> 内部构造两个 <code>A</code> 对象，于是获得两个构造函数的输出；</li><li>函数返回后，产生一个将亡值，被 <code>A</code> 的移动构造（<code>A(A&amp;&amp;)</code>）引用，从而延长生命周期，并将这个右值中的指针拿到，保存到了 <code>obj</code> 中，而将亡值的指针被设置为 <code>nullptr</code>，防止了这块内存区域被销毁。</li></ol><p>从而避免了无意义的拷贝构造，加强了性能。再来看看涉及标准库的例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span> </span><span class="token comment" spellcheck="true">// std::cout</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;utility></span> </span><span class="token comment" spellcheck="true">// std::move</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span> </span><span class="token comment" spellcheck="true">// std::vector</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span> </span><span class="token comment" spellcheck="true">// std::string</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>string str <span class="token operator">=</span> <span class="token string">"Hello world."</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> v<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将使用 push_back(const T&amp;), 即产生拷贝行为</span>    v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将输出 "str: Hello world."</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"str: "</span> <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将使用 push_back(const T&amp;&amp;), 不会出现拷贝行为</span>    <span class="token comment" spellcheck="true">// 而整个字符串会被移动到 vector 中，所以有时候 std::move 会用来减少拷贝出现的开销</span>    <span class="token comment" spellcheck="true">// 这步操作后, str 中的值会变为空</span>    v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将输出 "str: "</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"str: "</span> <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h4><p>前面我们提到了，一个声明的右值引用其实是一个左值。这就为我们进行参数转发（传递）造成了问题：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">reference</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"左值"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">reference</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"右值"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">pass</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"普通传参:"</span><span class="token punctuation">;</span>    <span class="token function">reference</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 始终调用 reference(int&amp;)</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"传递右值:"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token function">pass</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1是右值, 但输出是左值</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"传递左值:"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">pass</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// l 是左值, 输出左值</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于 <code>pass(1)</code> 来说，虽然传递的是右值，但由于 <code>v</code> 是一个引用，所以同时也是左值。 因此 <code>reference(v)</code> 会调用 <code>reference(int&amp;)</code>，输出『左值』。 而对于<code>pass(l)</code>而言，<code>l</code>是一个左值，为什么会成功传递给 <code>pass(T&amp;&amp;)</code> 呢？</p><p>这是基于<strong>引用坍缩规则</strong>的：在传统 C++ 中，我们不能够对一个引用类型继续进行引用， 但 C++ 由于右值引用的出现而放宽了这一做法，从而产生了引用坍缩规则，允许我们对引用进行引用， 既能左引用，又能右引用。但是却遵循如下规则：</p><table><thead><tr><th align="center">函数形参类型</th><th align="center">实参参数类型</th><th align="center">推导后函数形参类型</th></tr></thead><tbody><tr><td align="center">T&amp;</td><td align="center">左引用</td><td align="center">T&amp;</td></tr><tr><td align="center">T&amp;</td><td align="center">右引用</td><td align="center">T&amp;</td></tr><tr><td align="center">T&amp;&amp;</td><td align="center">左引用</td><td align="center">T&amp;</td></tr><tr><td align="center">T&amp;&amp;</td><td align="center">右引用</td><td align="center">T&amp;&amp;</td></tr></tbody></table><p>因此，模板函数中使用 <code>T&amp;&amp;</code> 不一定能进行右值引用，当传入左值时，此函数的引用将被推导为左值。 更准确的讲，<strong>无论模板参数是什么类型的引用，当且仅当实参类型为右引用时，模板参数才能被推导为右引用类型</strong>。 这才使得 <code>v</code> 作为左值的成功传递。</p><p>完美转发就是基于上述规律产生的。所谓完美转发，就是为了让我们在传递参数的时候， 保持原来的参数类型（左引用保持左引用，右引用保持右引用）。 为了解决这个问题，我们应该使用 <code>std::forward</code> 来进行参数的转发（传递）：</p><pre class="line-numbers language-cpp"><code class="language-cpp">include <span class="token operator">&lt;</span>iostream<span class="token operator">></span>  <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;utility></span>  </span><span class="token keyword">void</span> <span class="token function">reference</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"左值引用"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">reference</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"右值引用"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>  <span class="token keyword">void</span> <span class="token function">pass</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"              普通传参: "</span><span class="token punctuation">;</span>      <span class="token function">reference</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"       std::move 传参: "</span><span class="token punctuation">;</span>      <span class="token function">reference</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"    std::forward 传参: "</span><span class="token punctuation">;</span>      <span class="token function">reference</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"static_cast&lt;T&amp;&amp;> 传参: "</span><span class="token punctuation">;</span>      <span class="token function">reference</span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>T<span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"传递右值:"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>      <span class="token function">pass</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"传递左值:"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>      <span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token function">pass</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>传递右值:              普通传参: 左值引用       std::move 传参: 右值引用    std::forward 传参: 右值引用static_cast&lt;T&amp;&amp;&gt; 传参: 右值引用传递左值:              普通传参: 左值引用       std::move 传参: 右值引用    std::forward 传参: 左值引用static_cast&lt;T&amp;&amp;&gt; 传参: 左值引用</code></pre><p>无论传递参数为左值还是右值，普通传参都会将参数作为左值进行转发； 由于类似的原因，<code>std::move</code> 总会接受到一个左值，从而转发调用了<code>reference(int&amp;&amp;)</code> 输出右值引用。</p><p>唯独 <code>std::forward</code> 即没有造成任何多余的拷贝，同时<strong>完美转发</strong>(传递)了函数的实参给了内部调用的其他函数。</p><p><code>std::forward</code> 和 <code>std::move</code> 一样，没有做任何事情，<code>std::move</code> 单纯的将左值转化为右值， <code>std::forward</code> 也只是单纯的将参数做了一个类型的转换，从现象上来看， <code>std::forward&lt;T&gt;(v)</code> 和 <code>static_cast&lt;T&amp;&amp;&gt;(v)</code> 是完全一样的。</p><p>当 <code>std::forward</code> 接受左值时，<code>_Tp</code> 被推导为左值，所以返回值为左值；而当其接受右值时， <code>_Tp</code> 被推导为 右值引用，则基于坍缩规则，返回值便成为了 <code>&amp;&amp; + &amp;&amp;</code> 的右值。 可见 <code>std::forward</code> 的原理在于巧妙的利用了模板类型推导中产生的差异。</p><p>这时我们能回答这样一个问题：为什么在使用循环语句的过程中，<code>auto&amp;&amp;</code> 是最安全的方式？ 因为当 <code>auto</code> 被推导为不同的左右引用时，与 <code>&amp;&amp;</code> 的坍缩组合是完美转发。</p><h2 id="第-4-章-容器"><a href="#第-4-章-容器" class="headerlink" title="第 4 章 容器"></a>第 4 章 容器</h2><h3 id="4-1-线性容器"><a href="#4-1-线性容器" class="headerlink" title="4.1 线性容器"></a>4.1 线性容器</h3><h4 id="std-array"><a href="#std-array" class="headerlink" title="std::array"></a>std::array</h4><p>看到这个容器的时候肯定会出现这样的问题：为什么要引入 std::array 而不是直接使用 std::vector？已经有了传统数组，为什么要用 std::array?</p><p>先回答第一个问题，与 <code>std::vector</code> 不同，<code>std::array</code> 对象的大小是固定的，如果容器大小是固定的，那么可以优先考虑使用 <code>std::array</code> 容器。 另外由于 <code>std::vector</code> 是自动扩容的，当存入大量的数据后，并且对容器进行了删除操作， 容器并不会自动归还被删除元素相应的内存，这时候就需要手动运行 <code>shrink_to_fit()</code> 释放这部分内存。</p><p>而第二个问题就更加简单，使用 <code>std::array</code> 能够让代码变得更加“现代化”，而且封装了一些操作函数，比如获取数组大小以及检查是否非空，同时还能够友好的使用标准库中的容器算法，比如 <code>std::sort</code>。</p><p>当我们开始用上了 <code>std::array</code> 时，难免会遇到要将其兼容 C 风格的接口，这里有三种做法：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span>std<span class="token operator">::</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token operator">></span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// C 风格接口传参</span><span class="token comment" spellcheck="true">// foo(arr, arr.size()); // 非法, 无法隐式转换</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">foo</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用 `std::sort`</span>std<span class="token operator">::</span><span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="std-forward-list"><a href="#std-forward-list" class="headerlink" title="std::forward_list"></a>std::forward_list</h4><p><code>std::forward_list</code> 是一个列表容器，使用方法和 <code>std::list</code> 基本类似，因此我们就不花费篇幅进行介绍了。</p><p>需要知道的是，和 <code>std::list</code> 的双向链表的实现不同，<code>std::forward_list</code> 使用单向链表进行实现， 提供了 <code>O(1)</code> 复杂度的元素插入，不支持快速随机访问（这也是链表的特点）， 也是标准库容器中唯一一个不提供 <code>size()</code> 方法的容器。当不需要双向迭代时，具有比 <code>std::list</code> 更高的空间利用率。</p><h3 id="4-2-无序容器"><a href="#4-2-无序容器" class="headerlink" title="4.2 无序容器"></a>4.2 无序容器</h3><p>我们已经熟知了传统 C++ 中的有序容器 <code>std::map</code>/<code>std::set</code>，这些元素内部通过红黑树进行实现， 插入和搜索的平均复杂度均为 <code>O(log(size))</code>。在插入元素时候，会根据 <code>&lt;</code> 操作符比较元素大小并判断元素是否相同， 并选择合适的位置插入到容器中。当对这个容器中的元素进行遍历时，输出结果会按照 <code>&lt;</code> 操作符的顺序来逐个遍历。</p><p>而无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的平均复杂度为 <code>O(constant)</code>， 在不关心容器内部元素顺序时，能够获得显著的性能提升。</p><p>C++11 引入了的两组无序容器分别是：<code>std::unordered_map</code>/<code>std::unordered_multimap</code> 和 <code>std::unordered_set</code>/<code>std::unordered_multiset</code>。</p><p>它们的用法和原有的 <code>std::map</code>/<code>std::multimap</code>/<code>std::set</code>/<code>set::multiset</code> 基本类似。</p><h3 id="4-3-元组"><a href="#4-3-元组" class="headerlink" title="4.3 元组"></a>4.3 元组</h3><p>了解过 Python 的程序员应该知道元组的概念，纵观传统 C++ 中的容器，除了 <code>std::pair</code> 外， 似乎没有现成的结构能够用来存放不同类型的数据（通常我们会自己定义结构）。 但 <code>std::pair</code> 的缺陷是显而易见的，只能保存两个元素。</p><h4 id="元组基本操作"><a href="#元组基本操作" class="headerlink" title="元组基本操作"></a>元组基本操作</h4><p>关于元组的使用有三个核心的函数：</p><ol><li><code>std::make_tuple</code>: 构造元组</li><li><code>std::get</code>: 获得元组某个位置的值</li><li><code>std::tie</code>: 元组拆包</li></ol><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;tuple></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">auto</span> <span class="token function">get_student</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 返回类型被推断为 std::tuple&lt;double, char, std::string></span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>id <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">make_tuple</span><span class="token punctuation">(</span><span class="token number">3.8</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>id <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">make_tuple</span><span class="token punctuation">(</span><span class="token number">2.9</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>id <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">make_tuple</span><span class="token punctuation">(</span><span class="token number">1.7</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">,</span> <span class="token string">"王五"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">make_tuple</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">,</span> <span class="token string">"null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果只写 0 会出现推断错误, 编译失败</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">auto</span> student <span class="token operator">=</span> <span class="token function">get_student</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ID: 0, "</span>    <span class="token operator">&lt;&lt;</span> <span class="token string">"GPA: "</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>get<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">></span><span class="token punctuation">(</span>student<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span>    <span class="token operator">&lt;&lt;</span> <span class="token string">"成绩: "</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>get<span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">></span><span class="token punctuation">(</span>student<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span>    <span class="token operator">&lt;&lt;</span> <span class="token string">"姓名: "</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>get<span class="token operator">&lt;</span><span class="token number">2</span><span class="token operator">></span><span class="token punctuation">(</span>student<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> gpa<span class="token punctuation">;</span>    <span class="token keyword">char</span> grade<span class="token punctuation">;</span>    std<span class="token operator">::</span>string name<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 元组进行拆包</span>    std<span class="token operator">::</span><span class="token function">tie</span><span class="token punctuation">(</span>gpa<span class="token punctuation">,</span> grade<span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">get_student</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ID: 1, "</span>    <span class="token operator">&lt;&lt;</span> <span class="token string">"GPA: "</span> <span class="token operator">&lt;&lt;</span> gpa <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span>    <span class="token operator">&lt;&lt;</span> <span class="token string">"成绩: "</span> <span class="token operator">&lt;&lt;</span> grade <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span>    <span class="token operator">&lt;&lt;</span> <span class="token string">"姓名: "</span> <span class="token operator">&lt;&lt;</span> name <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>std::get</code> 除了使用常量获取元组对象外，C++14 增加了使用类型来获取元组中的对象：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>tuple<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> <span class="token function">t</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">,</span> <span class="token number">4.5</span><span class="token punctuation">,</span> <span class="token number">6.7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>get<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>get<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 非法, 引发编译期错误</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>get<span class="token operator">&lt;</span><span class="token number">3</span><span class="token operator">></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行期索引"><a href="#运行期索引" class="headerlink" title="运行期索引"></a>运行期索引</h4><p>如果你仔细思考一下可能就会发现上面代码的问题，<code>std::get&lt;&gt;</code> 依赖一个编译期的常量，所以下面的方式是不合法的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>std<span class="token operator">::</span>get<span class="token operator">&lt;</span>index<span class="token operator">></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>那么要怎么处理？答案是，使用 <code>std::variant&lt;&gt;</code>（C++ 17 引入），提供给 <code>variant&lt;&gt;</code> 的类型模板参数 可以让一个 <code>variant&lt;&gt;</code> 从而容纳提供的几种类型的变量,这是 C++ 中的语法糖，它可以简化代码的编写，提高程序的可读性和可维护性。</p><p>在之前的版本中，C++ 可以使用 <code>union</code> 来存储不同类型的数据，但是 <code>union</code> 存在一些限制，比如不能存储非 POD 类型和类对象。而 <code>std::variant</code> 可以存储任意类型，包括非 POD 类型和类对象。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;variant></span></span><span class="token keyword">template</span> <span class="token operator">&lt;</span>size_t n<span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> T<span class="token operator">></span><span class="token keyword">constexpr</span> std<span class="token operator">::</span>variant<span class="token operator">&lt;</span>T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span> <span class="token function">_tuple_index</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>tuple<span class="token operator">&lt;</span>T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span><span class="token operator">&amp;</span> tpl<span class="token punctuation">,</span> size_t i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span>n <span class="token operator">>=</span> <span class="token keyword">sizeof</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">out_of_range</span><span class="token punctuation">(</span><span class="token string">"越界."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> n<span class="token punctuation">)</span>        <span class="token keyword">return</span> std<span class="token operator">::</span>variant<span class="token operator">&lt;</span>T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span><span class="token punctuation">{</span> std<span class="token operator">::</span>in_place_index<span class="token operator">&lt;</span>n<span class="token operator">></span><span class="token punctuation">,</span> std<span class="token operator">::</span>get<span class="token operator">&lt;</span>n<span class="token operator">></span><span class="token punctuation">(</span>tpl<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> _tuple_index<span class="token operator">&lt;</span><span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">?</span> n<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span>tpl<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> T<span class="token operator">></span><span class="token keyword">constexpr</span> std<span class="token operator">::</span>variant<span class="token operator">&lt;</span>T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span> <span class="token function">tuple_index</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>tuple<span class="token operator">&lt;</span>T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span><span class="token operator">&amp;</span> tpl<span class="token punctuation">,</span> size_t i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> _tuple_index<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">></span><span class="token punctuation">(</span>tpl<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T0<span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span>std<span class="token operator">::</span>ostream <span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>ostream <span class="token operator">&amp;</span> s<span class="token punctuation">,</span> std<span class="token operator">::</span>variant<span class="token operator">&lt;</span>T0<span class="token punctuation">,</span> Ts<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span> <span class="token keyword">const</span> <span class="token operator">&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>     std<span class="token operator">::</span><span class="token function">visit</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;&amp;</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span> s <span class="token operator">&lt;&lt;</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> s<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样我们就能：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">tuple_index</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="元组合并与遍历"><a href="#元组合并与遍历" class="headerlink" title="元组合并与遍历"></a>元组合并与遍历</h5><p>还有一个常见的需求就是合并两个元组，这可以通过 std::tuple_cat 来实现：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> new_tuple <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">tuple_cat</span><span class="token punctuation">(</span><span class="token function">get_student</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>马上就能够发现，应该如何快速遍历一个元组？但是我们刚才介绍了如何在运行期通过非常数索引一个 <code>tuple</code> 那么遍历就变得简单了， 首先我们需要知道一个元组的长度，可以：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>  <span class="token keyword">auto</span> <span class="token function">tuple_len</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span>tpl<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> std<span class="token operator">::</span>tuple_size<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样就能够对元组进行迭代了：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 迭代</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token function">tuple_len</span><span class="token punctuation">(</span>new_tuple<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 运行期索引</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">tuple_index</span><span class="token punctuation">(</span>new_tuple<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第-5-章-智能指针与内存管理"><a href="#第-5-章-智能指针与内存管理" class="headerlink" title="第 5 章 智能指针与内存管理"></a>第 5 章 智能指针与内存管理</h2><h3 id="5-1-RAII与引用计数"><a href="#5-1-RAII与引用计数" class="headerlink" title="5.1 RAII与引用计数"></a>5.1 RAII与引用计数</h3><p>在传统 C++ 中，『记得』手动释放资源，总不是最佳实践。因为我们很有可能就忘记了去释放资源而导致泄露。 所以通常的做法是对于一个对象而言，我们在构造函数的时候申请空间，而在析构函数（在离开作用域时调用）的时候释放空间， 也就是我们常说的 RAII 资源获取即初始化技术。</p><p>凡事都有例外，我们总会有需要将对象在自由存储上分配的需求，在传统 C++ 里我们只好使用 <code>new</code> 和 <code>delete</code> 去 『记得』对资源进行释放。而 C++11 引入了智能指针的概念，使用了引用计数的想法，让程序员不再需要关心手动释放内存。 这些智能指针包括 <code>std::shared_ptr</code>/<code>std::unique_ptr</code>/<code>std::weak_ptr</code>，使用它们需要包含头文件 <code>&lt;memory&gt;</code>。</p><blockquote><p>注意：引用计数不是垃圾回收，引用计数能够尽快收回不再被使用的对象，同时在回收的过程中也不会造成长时间的等待， 更能够清晰明确的表明资源的生命周期。</p></blockquote><h3 id="5-2-std-shared-ptr"><a href="#5-2-std-shared-ptr" class="headerlink" title="5.2 std::shared_ptr"></a>5.2 std::shared_ptr</h3><p><code>std::shared_ptr</code> 是一种智能指针，它能够记录多少个 <code>shared_ptr</code> 共同指向一个对象，从而消除显式的调用 <code>delete</code>，当引用计数变为零的时候就会将对象自动删除。</p><p>但还不够，因为使用 <code>std::shared_ptr</code> 仍然需要使用 <code>new</code> 来调用，这使得代码出现了某种程度上的不对称。</p><p><code>std::make_shared</code> 就能够用来消除显式的使用 <code>new</code>，所以<code>std::make_shared</code> 会分配创建传入参数中的对象， 并返回这个对象类型的<code>std::shared_ptr</code>指针。例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">(</span><span class="token operator">*</span>i<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// auto pointer = new int(10); // illegal, no direct assignment</span>    <span class="token comment" spellcheck="true">// Constructed a std::shared_ptr</span>    <span class="token keyword">auto</span> pointer <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">foo</span><span class="token punctuation">(</span>pointer<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>pointer <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 11</span>    <span class="token comment" spellcheck="true">// The shared_ptr will be destructed before leaving the scope</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>std::shared_ptr</code> 可以通过 <code>get()</code> 方法来获取原始指针，通过 <code>reset()</code> 来减少一个引用计数， 并通过<code>use_count()</code>来查看一个对象的引用计数。例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> pointer <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">auto</span> pointer2 <span class="token operator">=</span> pointer<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 引用计数+1  </span><span class="token keyword">auto</span> pointer3 <span class="token operator">=</span> pointer<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 引用计数+1  </span><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> pointer<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这样不会增加引用计数  </span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"pointer.use_count() = "</span> <span class="token operator">&lt;&lt;</span> pointer<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3  </span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"pointer2.use_count() = "</span> <span class="token operator">&lt;&lt;</span> pointer2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3  </span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"pointer3.use_count() = "</span> <span class="token operator">&lt;&lt;</span> pointer3<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3  </span>pointer2<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"reset pointer2:"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"pointer.use_count() = "</span> <span class="token operator">&lt;&lt;</span> pointer<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2  </span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"pointer2.use_count() = "</span>  <span class="token operator">&lt;&lt;</span> pointer2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// pointer2 已 reset; 0  </span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"pointer3.use_count() = "</span> <span class="token operator">&lt;&lt;</span> pointer3<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2  </span>pointer3<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"reset pointer3:"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"pointer.use_count() = "</span> <span class="token operator">&lt;&lt;</span> pointer<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1  </span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"pointer2.use_count() = "</span> <span class="token operator">&lt;&lt;</span> pointer2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0  </span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"pointer3.use_count() = "</span>  <span class="token operator">&lt;&lt;</span> pointer3<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// pointer3 已 reset; 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-std-unique-ptr"><a href="#5-3-std-unique-ptr" class="headerlink" title="5.3 std::unique_ptr"></a>5.3 std::unique_ptr</h3><p><code>std::unique_ptr</code> 是一种独占的智能指针，它禁止其他智能指针与其共享同一个对象，从而保证代码的安全：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> pointer <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// make_unique 从 C++14 引入</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> pointer2 <span class="token operator">=</span> pointer<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 非法</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>make_unique</code> 并不复杂，C++11 没有提供 <code>std::make_unique</code>，可以自行实现：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token operator">></span>  std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">make_unique</span><span class="token punctuation">(</span> Args<span class="token operator">&amp;&amp;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span> <span class="token keyword">new</span> <span class="token function">T</span><span class="token punctuation">(</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Args<span class="token operator">></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>既然是独占，换句话说就是不可复制。但是，我们可以利用 <code>std::move</code> 将其转移给其他的 <code>unique_ptr</code>，例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token keyword">struct</span> Foo <span class="token punctuation">{</span>    <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Foo::Foo"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Foo::~Foo"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Foo::foo"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> Foo <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f(const Foo&amp;)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Foo<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// p1 不空, 输出</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p1<span class="token punctuation">)</span> p1<span class="token operator">-</span><span class="token operator">></span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// p2 不空, 输出</span>        <span class="token function">f</span><span class="token punctuation">(</span><span class="token operator">*</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// p2 不空, 输出</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span> p2<span class="token operator">-</span><span class="token operator">></span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// p1 为空, 无输出</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span> p1<span class="token operator">-</span><span class="token operator">></span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p1 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// p2 为空, 无输出</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span> p2<span class="token operator">-</span><span class="token operator">></span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"p2 被销毁"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// p1 不空, 输出</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p1<span class="token punctuation">)</span> p1<span class="token operator">-</span><span class="token operator">></span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Foo 的实例会在离开作用域时被销毁</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-4-std-weak-ptr"><a href="#5-4-std-weak-ptr" class="headerlink" title="5.4 std::weak_ptr"></a>5.4 std::weak_ptr</h3><p>如果你仔细思考 std::shared_ptr 就会发现依然存在着资源无法释放的问题。看下面这个例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> A<span class="token punctuation">;</span><span class="token keyword">struct</span> B<span class="token punctuation">;</span><span class="token keyword">struct</span> A <span class="token punctuation">{</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>B<span class="token operator">></span> pointer<span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A 被销毁"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> B <span class="token punctuation">{</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">></span> pointer<span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B 被销毁"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> a <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>A<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> b <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>B<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    a<span class="token operator">-</span><span class="token operator">></span>pointer <span class="token operator">=</span> b<span class="token punctuation">;</span>    b<span class="token operator">-</span><span class="token operator">></span>pointer <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果是 A, B 都不会被销毁，这是因为 a,b 内部的 pointer 同时又引用了 <code>a,b</code>，这使得 <code>a,b</code> 的引用计数均变为了 2，而离开作用域时，<code>a,b</code> 智能指针被析构，却只能造成这块区域的引用计数减一，这样就导致了 <code>a,b</code> 对象指向的内存区域引用计数不为零，而外部已经没有办法找到这块区域了，也就造成了内存泄露:</p><p><img src="/posts/35627/image-20230920211900775.png" alt></p><p>解决这个问题的办法就是使用弱引用指针 <code>std::weak_ptr</code>，<code>std::weak_ptr</code>是一种弱引用（相比较而言 <code>std::shared_ptr</code> 就是一种强引用）。弱引用不会引起引用计数增加，当换用弱引用时候，最终的释放流程如图所示：</p><p><img src="/posts/35627/image-20230920211910262.png" alt></p><p>在上图中，最后一步只剩下 B，而 B 并没有任何智能指针引用它，因此这块内存资源也会被释放。</p><p><code>std::weak_ptr</code> 没有 <code>*</code> 运算符和 <code>-&gt;</code> 运算符，所以不能够对资源进行操作，它可以用于检查 <code>std::shared_ptr</code> 是否存在，其 <code>expired()</code> 方法能在资源未被释放时，会返回 <code>false</code>，否则返回 <code>true</code>；除此之外，它也可以用于获取指向原始对象的 <code>std::shared_ptr</code> 指针，其 <code>lock()</code> 方法在原始对象未被释放时，返回一个指向原始对象的 <code>std::shared_ptr</code> 指针，进而访问原始对象的资源，否则返回<code>nullptr</code>。</p><h2 id="第-6-章-正则表达式"><a href="#第-6-章-正则表达式" class="headerlink" title="第 6 章 正则表达式"></a>第 6 章 正则表达式</h2><h3 id="6-1-正则表达式简介"><a href="#6-1-正则表达式简介" class="headerlink" title="6.1 正则表达式简介"></a>6.1 正则表达式简介</h3><h4 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h4><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。</p><h4 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h4><p>特殊字符是正则表达式里有特殊含义的字符，也是正则表达式的核心匹配语法。参见下表：</p><table><thead><tr><th align="center">特别字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center"><code>$</code></td><td align="left">匹配输入字符串的结尾位置。</td></tr><tr><td align="center"><code>(</code>,<code>)</code></td><td align="left">标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。</td></tr><tr><td align="center"><code>*</code></td><td align="left">匹配前面的子表达式零次或多次。</td></tr><tr><td align="center"><code>+</code></td><td align="left">匹配前面的子表达式一次或多次。</td></tr><tr><td align="center"><code>.</code></td><td align="left">匹配除换行符 <code>\n</code> 之外的任何单字符。</td></tr><tr><td align="center"><code>[</code></td><td align="left">标记一个中括号表达式的开始。</td></tr><tr><td align="center"><code>?</code></td><td align="left">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。</td></tr><tr><td align="center"><code>\</code></td><td align="left">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， <code>n</code> 匹配字符 <code>n</code>。<code>\n</code> 匹配换行符。序列 <code>\\</code> 匹配 <code>&#39;\&#39;</code> 字符，而 <code>\(</code> 则匹配 <code>&#39;(&#39;</code> 字符。</td></tr><tr><td align="center"><code>^</code></td><td align="left">匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。</td></tr><tr><td align="center"><code>{</code></td><td align="left">标记限定符表达式的开始。</td></tr><tr><td align="center"><code>|</code></td><td align="left">指明两项之间的一个选择。</td></tr></tbody></table><h4 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h4><p>限定符用来指定正则表达式的一个给定的组件必须要出现多少次才能满足匹配。见下表：</p><table><thead><tr><th align="center">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center"><code>*</code></td><td align="left">匹配前面的子表达式零次或多次。例如，<code>foo*</code> 能匹配 <code>fo</code> 以及 <code>foooo</code>。<code>*</code> 等价于<code>{0,}</code>。</td></tr><tr><td align="center"><code>+</code></td><td align="left">匹配前面的子表达式一次或多次。例如，<code>foo+</code> 能匹配 <code>foo</code> 以及 <code>foooo</code>，但不能匹配 <code>fo</code>。<code>+</code> 等价于 <code>{1,}</code>。</td></tr><tr><td align="center"><code>?</code></td><td align="left">匹配前面的子表达式零次或一次。例如，<code>Your(s)?</code> 可以匹配 <code>Your</code> 或 <code>Yours</code> 中的<code>Your</code> 。<code>?</code> 等价于 <code>{0,1}</code>。</td></tr><tr><td align="center"><code>{n}</code></td><td align="left"><code>n</code> 是一个非负整数。匹配确定的 <code>n</code> 次。例如，<code>o{2}</code> 不能匹配 <code>for</code> 中的 <code>o</code>，但是能匹配 <code>foo</code> 中的两个 <code>o</code>。</td></tr><tr><td align="center"><code>{n,}</code></td><td align="left"><code>n</code> 是一个非负整数。至少匹配 <code>n</code> 次。例如，<code>o{2,}</code> 不能匹配 <code>for</code> 中的 <code>o</code>，但能匹配 <code>foooooo</code> 中的所有 <code>o</code>。<code>o{1,}</code> 等价于 <code>o+</code>。<code>o{0,}</code> 则等价于 <code>o*</code>。</td></tr><tr><td align="center"><code>{n,m}</code></td><td align="left"><code>m</code> 和 <code>n</code> 均为非负整数，其中 <code>n</code> 小于等于 <code>m</code>。最少匹配 <code>n</code> 次且最多匹配 <code>m</code> 次。例如，<code>o{1,3}</code> 将匹配 <code>foooooo</code> 中的前三个 <code>o</code>。<code>o{0,1}</code> 等价于 <code>o?</code>。注意，在逗号和两个数之间不能有空格。</td></tr></tbody></table><h3 id="6-2-std-regex-及其相关"><a href="#6-2-std-regex-及其相关" class="headerlink" title="6.2 std::regex 及其相关"></a>6.2 std::regex 及其相关</h3><p>C++11 提供的正则表达式库操作 <code>std::string</code> 对象， 模式 <code>std::regex</code> (本质是 <code>std::basic_regex</code>)进行初始化， 通过 <code>std::regex_match</code> 进行匹配， 从而产生 <code>std::smatch</code> （本质是 <code>std::match_results</code> 对象）。</p><p>我们通过一个简单的例子来简单介绍这个库的使用。考虑下面的正则表达式:</p><ul><li><code>[a-z]+\.txt</code>: 在这个正则表达式中, <code>[a-z]</code> 表示匹配一个小写字母, <code>+</code> 可以使前面的表达式匹配多次， 因此 <code>[a-z]+</code> 能够匹配一个小写字母组成的字符串。 在正则表达式中一个 <code>.</code> 表示匹配任意字符，而 <code>\.</code> 则表示匹配字符 <code>.</code>， 最后的 <code>txt</code> 表示严格匹配 <code>txt</code> 则三个字母。因此这个正则表达式的所要匹配的内容就是由纯小写字母组成的文本文件。</li></ul><p><code>std::regex_match</code> 用于匹配字符串和正则表达式，有很多不同的重载形式。 最简单的一个形式就是传入 <code>std::string</code> 以及一个 <code>std::regex</code> 进行匹配， 当匹配成功时，会返回 <code>true</code>，否则返回 <code>false</code>。例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;regex></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>string fnames<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"foo.txt"</span><span class="token punctuation">,</span> <span class="token string">"bar.txt"</span><span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">,</span> <span class="token string">"a0.txt"</span><span class="token punctuation">,</span> <span class="token string">"AAA.txt"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 在 C++ 中 \ 会被作为字符串内的转义符，</span>    <span class="token comment" spellcheck="true">// 为使 \. 作为正则表达式传递进去生效，需要对 \ 进行二次转义，从而有 \\.</span>    std<span class="token operator">::</span>regex <span class="token function">txt_regex</span><span class="token punctuation">(</span><span class="token string">"[a-z]+\\.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>fname<span class="token operator">:</span> fnames<span class="token punctuation">)</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> fname <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span><span class="token function">regex_match</span><span class="token punctuation">(</span>fname<span class="token punctuation">,</span> txt_regex<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一种常用的形式就是依次传入 <code>std::string</code>/<code>std::smatch</code>/<code>std::regex</code> 三个参数， 其中 <code>std::smatch</code> 的本质其实是 <code>std::match_results</code>。 故而在标准库的实现中， <code>std::smatch</code> 被定义为了 <code>std::match_results&lt;std::string::const_iterator&gt;</code>， 也就是一个子串迭代器类型的 <code>match_results</code>。 使用 <code>std::smatch</code> 可以方便的对匹配的结果进行获取，例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>regex <span class="token function">base_regex</span><span class="token punctuation">(</span><span class="token string">"([a-z]+)\\.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>smatch base_match<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>fname<span class="token operator">:</span> fnames<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">regex_match</span><span class="token punctuation">(</span>fname<span class="token punctuation">,</span> base_match<span class="token punctuation">,</span> base_regex<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// std::smatch 的第一个元素匹配整个字符串</span>        <span class="token comment" spellcheck="true">// std::smatch 的第二个元素匹配了第一个括号表达式</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>base_match<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            std<span class="token operator">::</span>string base <span class="token operator">=</span> base_match<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sub-match[0]: "</span> <span class="token operator">&lt;&lt;</span> base_match<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>            std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> fname <span class="token operator">&lt;&lt;</span> <span class="token string">" sub-match[1]: "</span> <span class="token operator">&lt;&lt;</span> base <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上两个代码段的输出结果为：</p><pre><code>foo.txt: 1bar.txt: 1test: 0a0.txt: 0AAA.txt: 0sub-match[0]: foo.txtfoo.txt sub-match[1]: foosub-match[0]: bar.txtbar.txt sub-match[1]: bar</code></pre><h2 id="第-7-章-并行与并发"><a href="#第-7-章-并行与并发" class="headerlink" title="第 7 章 并行与并发"></a>第 7 章 并行与并发</h2><h3 id="7-1-并行基础"><a href="#7-1-并行基础" class="headerlink" title="7.1 并行基础"></a>7.1 并行基础</h3><p><code>std::thread</code> 用于创建一个执行的线程实例，所以它是一切并发编程的基础，使用时需要包含 <code>&lt;thread&gt;</code> 头文件， 它提供了很多基本的线程操作，例如 <code>get_id()</code> 来获取所创建线程的线程 ID，使用 <code>join()</code> 来等待一个线程结束（与该线程汇合）等等，例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello world."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-2-互斥量与临界区"><a href="#7-2-互斥量与临界区" class="headerlink" title="7.2 互斥量与临界区"></a>7.2 互斥量与临界区</h3><p>我们在操作系统、亦或是数据库的相关知识中已经了解过了有关并发技术的基本知识，<code>mutex</code> 就是其中的核心之一。 C++11 引入了 <code>mutex</code> 相关的类，其所有相关的函数都放在 <code>&lt;mutex&gt;</code> 头文件中。</p><p><code>std::mutex</code> 是 C++11 中最基本的 <code>mutex</code> 类，通过实例化 <code>std::mutex</code> 可以创建互斥量， 而通过其成员函数 <code>lock()</code> 可以进行上锁，<code>unlock()</code> 可以进行解锁。 但是在实际编写代码的过程中，最好不去直接调用成员函数， 因为调用成员函数就需要在每个临界区的出口处调用 <code>unlock()</code>，当然，还包括异常。 这时候 C++11 还为互斥量提供了一个 RAII 语法的模板类 <code>std::lock_guard</code>。 RAII 在不失代码简洁性的同时，很好的保证了代码的异常安全性。</p><p>在 RAII 用法下，对于临界区的互斥量的创建只需要在作用域的开始部分，例如:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;mutex></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span>  </span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">critical_section</span><span class="token punctuation">(</span><span class="token keyword">int</span> change_v<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">static</span> std<span class="token operator">::</span>mutex mtx<span class="token punctuation">;</span>      std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 执行竞争操作  </span>    v <span class="token operator">=</span> change_v<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 离开此作用域后 mtx 会被释放  </span><span class="token punctuation">}</span>  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token operator">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>critical_section<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">t2</span><span class="token punctuation">(</span>critical_section<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> v <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于 C++ 保证了所有栈对象在生命周期结束时会被销毁，所以这样的代码也是异常安全的。 无论 <code>critical_section()</code> 正常返回、还是在中途抛出异常，都会引发堆栈回退，也就自动调用了 <code>unlock()</code>。</p><p>而 <code>std::unique_lock</code> 则是相对于 <code>std::lock_guard</code> 出现的，<code>std::unique_lock</code> 更加灵活， <code>std::unique_lock</code> 的对象会以独占所有权（没有其他的 <code>unique_lock</code> 对象同时拥有某个 <code>mutex</code> 对象的所有权） 的方式管理 <code>mutex</code> 对象上的上锁和解锁的操作。所以在并发编程中，推荐使用 <code>std::unique_lock</code>。</p><p><code>std::lock_guard</code> 不能显式的调用 <code>lock</code> 和 <code>unlock</code>， 而 <code>std::unique_lock</code> 可以在声明后的任意位置调用， 可以缩小锁的作用范围，提供更高的并发度。</p><p>如果你用到了条件变量 <code>std::condition_variable::wait</code> 则必须使用 <code>std::unique_lock</code> 作为参数。</p><p>例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;mutex></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span>  </span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">critical_section</span><span class="token punctuation">(</span><span class="token keyword">int</span> change_v<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">static</span> std<span class="token operator">::</span>mutex mtx<span class="token punctuation">;</span>      std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 执行竞争操作  </span>    v <span class="token operator">=</span> change_v<span class="token punctuation">;</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> v <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 将锁进行释放  </span>    lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 在此期间，任何人都可以抢夺 v 的持有权  </span>    <span class="token comment" spellcheck="true">// 开始另一组竞争操作，再次加锁  </span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      v <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> v <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token operator">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>critical_section<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">t2</span><span class="token punctuation">(</span>critical_section<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-3-期物"><a href="#7-3-期物" class="headerlink" title="7.3 期物"></a>7.3 期物</h3><p>期物（Future）表现为 <code>std::future</code>，它提供了一个访问异步操作结果的途径，这句话很不好理解。 为了理解这个特性，我们需要先理解一下在 C++11 之前的多线程行为。</p><p>试想，如果我们的主线程 A 希望新开辟一个线程 B 去执行某个我们预期的任务，并返回我一个结果。 而这时候，线程 A 可能正在忙其他的事情，无暇顾及 B 的结果， 所以我们会很自然的希望能够在某个特定的时间获得线程 B 的结果。</p><p>在 C++11 的 <code>std::future</code> 被引入之前，通常的做法是： 创建一个线程 A，在线程 A 里启动任务 B，当准备完毕后发送一个事件，并将结果保存在全局变量中。 而主函数线程 A 里正在做其他的事情，当需要结果的时候，调用一个线程等待函数来获得执行的结果。</p><p>而 C++11 提供的 <code>std::future</code> 简化了这个流程，可以用来获取异步任务的结果。 自然地，我们很容易能够想象到把它作为一种简单的线程同步手段，即屏障（barrier）。</p><p>为了看一个例子，我们这里额外使用 <code>std::packaged_task</code>，它可以用来封装任何可以调用的目标，从而用于实现异步的调用。 举例来说：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;future></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 将一个返回值为7的 lambda 表达式封装到 task 中</span>    <span class="token comment" spellcheck="true">// std::packaged_task 的模板参数为要封装函数的类型</span>    std<span class="token operator">::</span>packaged_task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> <span class="token function">task</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token number">7</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获得 task 的期物</span>    std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> result <span class="token operator">=</span> task<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 在一个线程中执行 task</span>    std<span class="token operator">::</span><span class="token function">thread</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"waiting..."</span><span class="token punctuation">;</span>    result<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 在此设置屏障，阻塞到期物的完成</span>    <span class="token comment" spellcheck="true">// 输出执行结果</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"done!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span> endl <span class="token operator">&lt;&lt;</span> <span class="token string">"future result is "</span>              <span class="token operator">&lt;&lt;</span> result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在封装好要调用的目标后，可以使用 <code>get_future()</code> 来获得一个 <code>std::future</code> 对象，以便之后实施线程同步。</p><h3 id="7-4-条件变量"><a href="#7-4-条件变量" class="headerlink" title="7.4 条件变量"></a>7.4 条件变量</h3><p>条件变量 <code>std::condition_variable</code> 是为了解决死锁而生，当互斥操作不够用而引入的。 比如，线程可能需要等待某个条件为真才能继续执行， 而一个忙等待循环中可能会导致所有其他线程都无法进入临界区使得条件为真时，就会发生死锁。 所以，<code>condition_variable</code> 实例被创建出现主要就是用于唤醒等待线程从而避免死锁。 <code>std::condition_variable</code>的 <code>notify_one()</code> 用于唤醒一个线程； <code>notify_all()</code> 则是通知所有线程。下面是一个生产者和消费者模型的例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;chrono></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;mutex></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;condition_variable></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> produced_nums<span class="token punctuation">;</span>    std<span class="token operator">::</span>mutex mtx<span class="token punctuation">;</span>    std<span class="token operator">::</span>condition_variable cv<span class="token punctuation">;</span>    <span class="token keyword">bool</span> notified <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 通知信号</span>    <span class="token comment" spellcheck="true">// 生产者</span>    <span class="token keyword">auto</span> producer <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">milliseconds</span><span class="token punctuation">(</span><span class="token number">900</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span>            std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"producing "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>            produced_nums<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            notified <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            cv<span class="token punctuation">.</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 此处也可以使用 notify_one</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 消费者</span>    <span class="token keyword">auto</span> consumer <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>notified<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 避免虚假唤醒</span>                cv<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 短暂取消锁，使得生产者有机会在消费者消费空前继续生产</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 消费者慢于生产者</span>            std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">milliseconds</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>produced_nums<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"consuming "</span> <span class="token operator">&lt;&lt;</span> produced_nums<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>                produced_nums<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            notified <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 分别在不同的线程中运行</span>    std<span class="token operator">::</span>thread <span class="token function">p</span><span class="token punctuation">(</span>producer<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>thread cs<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">thread</span><span class="token punctuation">(</span>consumer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    p<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在生产者中我们虽然可以使用 <code>notify_one()</code>，但实际上并不建议在此处使用， 因为在多消费者的情况下，我们的消费者实现中简单放弃了锁的持有，这使得可能让其他消费者争夺此锁，从而更好的利用多个消费者之间的并发。话虽如此，但实际上因为 <code>std::mutex</code> 的排他性， 我们根本无法期待多个消费者能真正意义上的并行消费队列的中生产的内容，我们仍需要粒度更细的手段。</p><h3 id="7-5-原子操作与内存模型"><a href="#7-5-原子操作与内存模型" class="headerlink" title="7.5 原子操作与内存模型"></a>7.5 原子操作与内存模型</h3><p>细心的读者可能会对前一小节中生产者消费者模型的例子可能存在编译器优化导致程序出错的情况产生疑惑。例如，布尔值 <code>notified</code> 没有被 <code>volatile</code> 修饰，编译器可能对此变量存在优化，例如将其作为一个寄存器的值， 从而导致消费者线程永远无法观察到此值的变化。这是一个好问题，为了解释清楚这个问题，我们需要进一步讨论 从 C++ 11 起引入的内存模型这一概念。我们首先来看一个问题，下面这段代码输出结果是多少？</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>  </span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      std<span class="token operator">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">while</span> <span class="token punctuation">(</span>flag <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">int</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>          std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"b = "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      std<span class="token operator">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>          flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从直观上看，<code>t2</code> 中 <code>a = 5;</code> 这一条语句似乎总在 <code>flag = 1;</code> 之前得到执行，而 <code>t1</code> 中 <code>while (flag != 1)</code> 似乎保证了 <code>std::cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; std::endl;</code> 不会再标记被改变前执行。从逻辑上看，似乎 <code>b</code> 的值应该等于 5。 但实际情况远比此复杂得多，或者说这段代码本身属于未定义的行为，因为对于 <code>a</code> 和 <code>flag</code> 而言，他们在两个并行的线程中被读写， 出现了竞争。除此之外，即便我们忽略竞争读写，仍然可能受 CPU 的乱序执行，编译器对指令的重排的影响， 导致 <code>a = 5</code> 发生在 <code>flag = 1</code> 之后。从而 <code>b</code> 可能输出 0。</p><h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h4><p><code>std::mutex</code> 可以解决上面出现的并发读写的问题，但互斥锁是操作系统级的功能， 这是因为一个互斥锁的实现通常包含两条基本原理：</p><ol><li>提供线程间自动的状态转换，即『锁住』这个状态</li><li>保障在互斥锁操作期间，所操作变量的内存与临界区外进行隔离</li></ol><p>这是一组非常强的同步条件，换句话说当最终编译为 CPU 指令时会表现为非常多的指令（我们之后再来看如何实现一个简单的互斥锁）。 这对于一个仅需原子级操作（没有中间态）的变量，似乎太苛刻了。</p><p>关于同步条件的研究有着非常久远的历史，我们在这里不进行赘述。读者应该明白，现代 CPU 体系结构提供了 CPU 指令级的原子操作， 因此在 C++11 中多线程下共享变量的读写这一问题上，还引入了 <code>std::atomic</code> 模板，使得我们实例化一个原子类型，将一个 原子类型读写操作从一组指令，最小化到单个 CPU 指令。例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> counter<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>并为整数或浮点数的原子类型提供了基本的数值成员函数，举例来说， 包括 <code>fetch_add</code>, <code>fetch_sub</code> 等，同时通过重载方便的提供了对应的 <code>+</code>，<code>-</code> 版本。 比如下面的例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;atomic></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>  </span>std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> count <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token operator">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          count<span class="token punctuation">.</span><span class="token function">fetch_add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      std<span class="token operator">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 等价于 fetch_add  </span>        count <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 等价于 fetch_add  </span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，并非所有的类型都能提供原子操作，这是因为原子操作的可行性取决于具体的 CPU 架构，以及所实例化的类型结构是否能够满足该 CPU 架构对内存对齐 条件的要求，因而我们总是可以通过 <code>std::atomic&lt;T&gt;::is_lock_free</code> 来检查该原子类型是否需支持原子操作，例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;atomic></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>  </span><span class="token keyword">struct</span> A <span class="token punctuation">{</span>      <span class="token keyword">float</span> x<span class="token punctuation">;</span>      <span class="token keyword">int</span> y<span class="token punctuation">;</span>      <span class="token keyword">long</span> <span class="token keyword">long</span> z<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span>A<span class="token operator">></span> a<span class="token punctuation">;</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>boolalpha <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">.</span><span class="token function">is_lock_free</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="一致性模型"><a href="#一致性模型" class="headerlink" title="一致性模型"></a>一致性模型</h4><p>并行执行的多个线程，从某种宏观层面上讨论，可以粗略的视为一种分布式系统。 在分布式系统中，任何通信乃至本地操作都需要消耗一定时间，甚至出现不可靠的通信。</p><p>如果我们强行将一个变量 <code>v</code> 在多个线程之间的操作设为原子操作，即任何一个线程在操作完 <code>v</code> 后， 其他线程均能<strong>同步</strong>感知到 <code>v</code> 的变化，则对于变量 <code>v</code> 而言，表现为顺序执行的程序，它并没有由于引入多线程 而得到任何效率上的收益。对此有什么办法能够适当的加速呢？答案便是削弱原子操作的在进程间的同步条件。</p><p>从原理上看，每个线程可以对应为一个集群节点，而线程间的通信也几乎等价于集群节点间的通信。 削弱进程间的同步条件，通常我们会考虑四种不同的一致性模型：</p><ol><li><strong>线性一致性：又称强一致性或原子一致性。它要求任何一次读操作都能读到某个数据的最近一次写的数据，并且所有线程的操作顺序与全局时钟下的顺序是一致的。</strong></li></ol><pre><code>        x.store(1)      x.load()T1 ---------+----------------+------&gt;T2 -------------------+-------------&gt;                x.store(2)</code></pre><ol start="2"><li><strong>顺序一致性：同样要求任何一次读操作都能读到数据最近一次写入的数据，但未要求与全局时钟的顺序一致。</strong></li></ol><pre><code>       x.store(1)  x.store(3)   x.load()  T1 ---------+-----------+----------+-----&gt;  T2 ---------------+----------------------&gt;                x.store(2)  或者          x.store(1)  x.store(3)   x.load()  T1 ---------+-----------+----------+-----&gt;  T2 ------+-------------------------------&gt;        x.store(2)</code></pre><p>在顺序一致性的要求下，<code>x.load()</code> 必须读到最近一次写入的数据，因此 <code>x.store(2)</code> 与 <code>x.store(1)</code> 并无任何先后保障，即 只要 <code>T2</code> 的 <code>x.store(2)</code> 发生在 <code>x.store(3)</code> 之前即可。</p><ol start="3"><li><strong>因果一致性：它的要求进一步降低，只需要有因果关系的操作顺序得到保障，而非因果关系的操作顺序则不做要求。</strong></li></ol><pre><code>      a = 1      b = 2T1 ----+-----------+----------------------------&gt;T2 ------+--------------------+--------+--------&gt;      x.store(3)         c = a + b    y.load()或者      a = 1      b = 2T1 ----+-----------+----------------------------&gt;T2 ------+--------------------+--------+--------&gt;      x.store(3)          y.load()   c = a + b亦或者     b = 2       a = 1T1 ----+-----------+----------------------------&gt;T2 ------+--------------------+--------+--------&gt;      y.load()            c = a + b  x.store(3)</code></pre><p>上面给出的三种例子都是属于因果一致的，因为整个过程中，只有 <code>c</code> 对 <code>a</code> 和 <code>b</code> 产生依赖，而 <code>x</code> 和 <code>y</code> 在此例子中表现为没有关系（但实际情况中我们需要更详细的信息才能确定 <code>x</code> 与 <code>y</code> 确实无关）</p><ol start="4"><li><strong>最终一致性：是最弱的一致性要求，它只保障某个操作在未来的某个时间节点上会被观察到，但并未要求被观察到的时间。因此我们甚至可以对此条件稍作加强，例如规定某个操作被观察到的时间总是有界的。当然这已经不在我们的讨论范围之内了。</strong></li></ol><pre><code>    x.store(3)  x.store(4)  T1 ----+-----------+--------------------------------------------&gt;  T2 ---------+------------+--------------------+--------+--------&gt;           x.read      x.read()           x.read()   x.read()</code></pre><p>在上面的情况中，如果我们假设 x 的初始值为 0，则 <code>T2</code> 中四次 <code>x.read()</code> 结果可能但不限于以下情况：</p><pre><code>3 4 4 4 // x 的写操作被很快观察到  0 3 3 4 // x 的写操作被观察到的时间存在一定延迟  0 0 0 4 // 最后一次读操作读到了 x 的最终值，但此前的变化并未观察到  0 0 0 0 // 在当前时间段内 x 的写操作均未被观察到，          // 但未来某个时间点上一定能观察到 x 为 4 的情况</code></pre><h4 id="内存顺序"><a href="#内存顺序" class="headerlink" title="内存顺序"></a>内存顺序</h4><p>为了追求极致的性能，实现各种强度要求的一致性，C++11 为原子操作定义了六种不同的内存顺序 <code>std::memory_order</code> 的选项，表达了四种多线程间的同步模型：</p><ol><li><strong>宽松模型：在此模型下，单个线程内的原子操作都是顺序执行的，不允许指令重排，但不同线程间原子操作的顺序是任意的。类型通过 <code>std::memory_order_relaxed</code> 指定。我们来看一个例子：</strong></li></ol><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> counter <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>thread<span class="token operator">></span> vt<span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      vt<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          counter<span class="token punctuation">.</span><span class="token function">fetch_add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> std<span class="token operator">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> t <span class="token operator">:</span> vt<span class="token punctuation">)</span> <span class="token punctuation">{</span>      t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"current counter:"</span> <span class="token operator">&lt;&lt;</span> counter <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><strong>释放/消费模型：在此模型中，我们开始限制进程间的操作顺序，如果某个线程需要修改某个值，但另一个线程会对该值的某次操作产生依赖，即后者依赖前者。具体而言，线程 A 完成了三次对 <code>x</code> 的写操作，线程 <code>B</code> 仅依赖其中第三次 <code>x</code> 的写操作，与 <code>x</code> 的前两次写行为无关，则当 <code>A</code> 主动 <code>x.release()</code> 时候（即使用 <code>std::memory_order_release</code>），选项 <code>std::memory_order_consume</code> 能够确保 <code>B</code> 在调用 <code>x.load()</code> 时候观察到 <code>A</code> 中第三次对 <code>x</code> 的写操作。我们来看一个例子：</strong></li></ol><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 初始化为 nullptr 防止 consumer 线程从野指针进行读取</span>std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">></span> <span class="token function">ptr</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> v<span class="token punctuation">;</span>std<span class="token operator">::</span>thread <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    v <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>    ptr<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> std<span class="token operator">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>thread <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>p <span class="token operator">=</span> ptr<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token operator">::</span>memory_order_consume<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"p: "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"v: "</span> <span class="token operator">&lt;&lt;</span> v <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>producer<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>consumer<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 释放/获取模型：在此模型下，我们可以进一步加紧对不同线程间原子操作的顺序的限制，在释放 <code>std::memory_order_release</code> 和获取 <code>std::memory_order_acquire</code> 之间规定时序，即发生在释放（release）操作之前的</strong>所有<strong>写操作，对其他线程的任何获取（acquire）操作都是可见的，亦即发生顺序（happens-before）。</strong></p><blockquote><p>可以看到，<code>std::memory_order_release</code> 确保了它之前的写操作不会发生在释放操作之后，是一个向后的屏障（backward），而 <code>std::memory_order_acquire</code> 确保了它之前的写行为不会发生在该获取操作之后，是一个向前的屏障（forward）。对于选项 <code>std::memory_order_acq_rel</code> 而言，则结合了这两者的特点，唯一确定了一个内存屏障，使得当前线程对内存的读写不会被重排并越过此操作的前后：</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">;</span>std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> flag <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span>thread <span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    flag<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> std<span class="token operator">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>thread <span class="token function">acqrel</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> expected <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// must before compare_exchange_strong</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">.</span><span class="token function">compare_exchange_strong</span><span class="token punctuation">(</span>expected<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> std<span class="token operator">::</span>memory_order_acq_rel<span class="token punctuation">)</span><span class="token punctuation">)</span>        expected <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// must after compare_exchange_strong</span>    <span class="token comment" spellcheck="true">// flag has changed to 2</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>thread <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token operator">::</span>memory_order_acquire<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// must be 42</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>release<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>acqrel<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>acquire<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在此例中我们使用了 <code>compare_exchange_strong</code> 比较交换原语（Compare-and-swap primitive），它有一个更弱的版本，即 <code>compare_exchange_weak</code>，它允许即便交换成功，也仍然返回 <code>false</code> 失败。其原因是因为在某些平台上虚假故障导致的，具体而言，当 CPU 进行上下文切换时，另一线程加载同一地址产生的不一致。除此之外，<code>compare_exchange_strong</code> 的性能可能稍差于 <code>compare_exchange_weak</code>，但大部分情况下，鉴于其使用的复杂度而言，<code>compare_exchange_weak</code> 应该被有限考虑。</p><p><strong>4. 顺序一致模型：在此模型下，原子操作满足顺序一致性，进而可能对性能产生损耗。可显式的通过 <code>std::memory_order_seq_cst</code> 进行指定。最后来看一个例子：</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> counter <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>thread<span class="token operator">></span> vt<span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      vt<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          counter<span class="token punctuation">.</span><span class="token function">fetch_add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> std<span class="token operator">::</span>memory_order_seq_cst<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> t <span class="token operator">:</span> vt<span class="token punctuation">)</span> <span class="token punctuation">{</span>      t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"current counter:"</span> <span class="token operator">&lt;&lt;</span> counter <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个例子与第一个宽松模型的例子本质上没有区别，仅仅只是将原子操作的内存顺序修改为了 <code>memory_order_seq_cst</code>，有兴趣的读者可以自行编写程序测量这两种不同内存顺序导致的性能差异。</p><h2 id="其他杂项"><a href="#其他杂项" class="headerlink" title="其他杂项"></a>其他杂项</h2><h3 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h3><p>C++ 11 引入了两个新的关键字 <code>alignof</code> 和 <code>alignas</code> 来支持对内存对齐进行控制。 <code>alignof</code> 关键字能够获得一个与平台相关的 <code>std::size_t</code> 类型的值，用于查询该平台的对齐方式。 当然我们有时候并不满足于此，甚至希望自定定义结构的对齐方式，同样，C++ 11 还引入了 <code>alignas</code> 来重新修饰某个结构的对齐方式。我们来看两个例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">struct</span> Storage <span class="token punctuation">{</span>    <span class="token keyword">char</span>      a<span class="token punctuation">;</span>    <span class="token keyword">int</span>       b<span class="token punctuation">;</span>    <span class="token keyword">double</span>    c<span class="token punctuation">;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> d<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token keyword">alignas</span><span class="token punctuation">(</span>std<span class="token operator">::</span>max_align_t<span class="token punctuation">)</span> AlignasStorage <span class="token punctuation">{</span>    <span class="token keyword">char</span>      a<span class="token punctuation">;</span>    <span class="token keyword">int</span>       b<span class="token punctuation">;</span>    <span class="token keyword">double</span>    c<span class="token punctuation">;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> d<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">alignof</span><span class="token punctuation">(</span>Storage<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">alignof</span><span class="token punctuation">(</span>AlignasStorage<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 <code>std::max_align_t</code> 要求每个标量类型的对齐方式严格一样，因此它几乎是最大标量没有差异， 进而大部分平台上得到的结果为 <code>long double</code>，因此我们这里得到的 <code>AlignasStorage</code> 的对齐要求是 8 或 16。</p><h3 id="noexcept-的修饰和操作"><a href="#noexcept-的修饰和操作" class="headerlink" title="noexcept 的修饰和操作"></a>noexcept 的修饰和操作</h3><p>C++ 相比于 C 的一大优势就在于 C++ 本身就定义了一套完整的异常处理机制。 然而在 C++11 之前，几乎没有人去使用在函数名后书写异常声明表达式， 从 C++11 开始，这套机制被弃用，所以我们不去讨论也不去介绍以前这套机制是如何工作如何使用， 你更不应该主动去了解它。</p><p>C++11 将异常的声明简化为以下两种情况：</p><ol><li>函数可能抛出任何异常</li><li>函数不能抛出任何异常</li></ol><p>并使用 <code>noexcept</code> 对这两种行为进行限制，例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">may_throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 可能抛出异常</span><span class="token keyword">void</span> <span class="token function">no_throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不可能抛出异常</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用 <code>noexcept</code> 修饰过的函数如果抛出异常，编译器会使用 <code>std::terminate()</code> 来立即终止程序运行。</p><p><code>noexcept</code> 还能够做操作符，用于操作一个表达式，当表达式无异常时，返回 <code>true</code>，否则返回 <code>false</code>。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">void</span> <span class="token function">may_throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">auto</span> non_block_throw <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>    <span class="token function">may_throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">no_throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">auto</span> block_throw <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>    <span class="token function">no_throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>boolalpha        <span class="token operator">&lt;&lt;</span> <span class="token string">"may_throw() noexcept? "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token function">may_throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl        <span class="token operator">&lt;&lt;</span> <span class="token string">"no_throw() noexcept? "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token function">no_throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl        <span class="token operator">&lt;&lt;</span> <span class="token string">"lmay_throw() noexcept? "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token function">non_block_throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl        <span class="token operator">&lt;&lt;</span> <span class="token string">"lno_throw() noexcept? "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token function">block_throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>noexcept</code> 修饰完一个函数之后能够起到封锁异常扩散的功效，如果内部产生异常，外部也不会触发。例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token function">may_throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"捕获异常, 来自 may_throw()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token function">non_block_throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"捕获异常, 来自 non_block_throw()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token function">block_throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"捕获异常, 来自 block_throw()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终输出为：</p><pre class="line-numbers language-cpp"><code class="language-cpp">捕获异常<span class="token punctuation">,</span> 来自 <span class="token function">may_throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span>捕获异常<span class="token punctuation">,</span> 来自 <span class="token function">non_block_throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>好了，你已经完全掌握modern cpp了，快去使用吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇笔记是&lt;a href=&quot;https://changkun.de/modern-cpp/zh-cn/00-preface/&quot;&gt;现代C++教材：告诉上手C++11/14/17/20&lt;/a&gt;的学习记录，目的是为了让cmu15445做的不那么痛苦，因为对于该实验来说，由于 Bu
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>CMU15445 2023spring环境准备</title>
    <link href="https://joytsing.github.io/posts/40555/"/>
    <id>https://joytsing.github.io/posts/40555/</id>
    <published>2023-09-26T06:59:39.000Z</published>
    <updated>2023-12-14T07:44:46.490Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>最近在做CMU15445，其实最痛苦的就是配环境，众所周知，VSCode的C/C++插件功能虽然全但是速度不怎么理想，写一点东西反应半天，非常之不友好。我们希望换到更加快速，提示更加智能的clangd上。</p><p>之前在网上看到了一大堆关于怎么配置LLVM家族的C/C++环境的教程，其中往往充斥着各种神鬼莫名的配置参数，对新手的劝退作用立竿见影。我理想的所谓新手教程应该是这样的：</p><ul><li>可控性高：偏好GUI &gt; 命令行 &gt; config</li><li>上下文完整：一步解决一个特定问题，不引入额外的负担</li><li>可复现性强：每个步骤应该立刻有可供检查的结果，易于排查错误</li></ul><p>好吧说来说去其实说的就是那些上来咣咣贴个config.json走人的。总之，今天我重走长征路，试图提出一个基本不使用配置文件的、绝对新手友好的入门教程。</p><h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a><strong>环境要求</strong></h2><p>本教程基于WSL Ubuntu 20.04，理论上在其它Linux发行版以及MacOS中也是通用的。至于Windows？不想麻烦事的话就用宇宙IDE吧，反正有免费版。</p><p><img src="/posts/40555/v2-0115e06acc09c8c186b58255e2f37382_720w.png" alt></p><p>依赖的软件包，基本上就是LLVM全家桶+<code>cmake</code>：</p><ul><li><code>clang</code>：我们使用的编译器，拥有更加人性化的报错</li><li><code>clangd</code>：一个C/C++的Language Sever后端，薄纱C/C++ Tools</li><li><code>lldb</code>：调试工具，一家人就要整整齐齐</li><li><code>cmake</code>：构造工具，因为<code>clangd</code>需要读取<code>compile_commands.json</code>才能提供服务</li></ul><p>Ubuntu使用下面的指令进行安装，homebrew或者pacman同理（这也要教？）</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> apt <span class="token function">install</span> clang clangd lldb cmake<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后是VSCode中需要的插件：</p><p><img src="/posts/40555/v2-a50a07d13b0b666be35a638121a7f1bf_720w.png" alt></p><p>只需要这四个就可以了。其中<code>CodeLLDB</code>需要下载一个文件，几乎是一定会下载失败的。</p><p><img src="/posts/40555/v2-af9c9b58664856fd4ac9a61b6e707603_720w.png" alt></p><p>超时之后点击弹出来的消息，手动下载，然后再手动进行安装。</p><p><img src="/posts/40555/v2-2005e8f7f9c0d2d39143ae7a9814719f_720w.png" alt></p><p>在弹出菜单里选择你下载的那个（后缀为<code>.vsix</code>）即可。注意在WSL环境下你可以从<code>/mnt</code>文件夹下访问Windows文件，假如你直接下载在系统自带的下载文件夹里，那就是在<code>/mnt/c/Users/&lt;Username&gt;/Downloads/</code>里。装好了之后会弹出重载VSCode的窗口。</p><p><img src="/posts/40555/v2-f3c1c939f7620be1322847fe47419fff_720w.png" alt></p><p>到这里前期准备就结束啦。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a><strong>开始</strong></h2><p>随便找一个空文件夹打开，然后<code>Ctrl+Shift+P</code>或者你自定义的快捷键打开下拉菜单，搜索<code>cmake</code>，选择<code>Quick Start</code>：</p><p><img src="/posts/40555/v2-b4fa8e897c842aa3fc2fd275413a6116_720w.png" alt></p><p>给你的项目起个名字，类型选择<code>Executable</code>，第一次打开<code>cmake</code>可能还会问你一些编译套件的选择问题，选择<code>clang</code>即可，记得看清楚后缀免得用错。</p><p><img src="/posts/40555/v2-bc8f336ea7a344bc166e004c7017b23b_720w.png" alt></p><p>打开自动生成的<code>main.cpp</code>，发现<code>clangd</code>已经在运行了，就是这么简单。</p><p><img src="/posts/40555/v2-be076afa271b04531e49b4b2ceb8bd2e_720w.png" alt></p><p>打开<code>clangd</code>输出，看看<code>clangd</code>是否真的如此智能。</p><p><img src="/posts/40555/v2-b54764533865e5799920dbc5c94e788b_720w.png" alt></p><p>并没有，<code>clangd</code>抱怨说找不到编译数据库！那么这个所谓的编译数据库在哪里呢？其实就在<code>cmake</code>生成的<code>build</code>文件夹里：</p><p><img src="/posts/40555/v2-a03d685dde417dbd8bdbb754c2542f8e_720w.png" alt></p><p>我们要让<code>clangd</code>识别项目的编译数据库，于是终于到了我们第一次和配置文件的交锋。打开设置，搜索<code>clangd</code>，在<code>Arguments</code>配置项中输入参数<code>--compile-commands-dir=${workspaceFolder}/build</code>，然后点确定。</p><p><img src="/posts/40555/v2-82f2855bc27c062759338252fe69535c_720w.png" alt></p><p>这个参数相当直观，就是告知<code>clangd</code>我们的编译数据库在工作区根目录的<code>build</code>文件夹下。</p><p>重启VSCode，再次查看<code>clangd</code>输出，发现成功读入了参数，并且没有报错信息，同时能够使用<code>cmake</code>输入的编译指令即为配置成功。</p><p><img src="/posts/40555/v2-8084835575154df8603eee77c0c8982b_720w.webp" alt></p><h3 id="额外补充"><a href="#额外补充" class="headerlink" title="额外补充"></a>额外补充</h3><p>值得一提的是，在很多教程里面没有提到如果你下载了CMake language support这个软件，那么会需要一个.net运行环境依赖，这个依赖如果你只靠vscode同样是不能下载下来的，需要<code>apt install dotnet</code>的运行环境（或者连sdk一起下载），除此之外，如果你在vscode输出这栏打开CMake/Build这插件的输出，大概率会看见说build失败，缺乏ninja(然而实际上是构建成功的，只不过是原生cmake构建)，当然也可以不用管，但是我非常推荐安装ninja，它类似于CMake但速度比CMake快了一个数量级，并且安装并不麻烦。</p><pre class="line-numbers language-sh"><code class="language-sh">sudo apt-get install ninja-buildninja --version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>同时还推荐下载<code>github copilot</code>，感受人工智能帮你补充代码和注释（前提已经弄好了github pro），接下来就可以正式开始了。</p><h2 id="运行与调试"><a href="#运行与调试" class="headerlink" title="运行与调试"></a><strong>运行与调试</strong></h2><p>按一下底部菜单中的<code>build</code>键，看看我们生成的可执行文件在哪里（一般就在<code>build</code>下面）：</p><p><img src="/posts/40555/v2-27523b009d10182419ae5ac3d3549cce_720w.png" alt></p><p>按<code>F5</code>键，VSCode会报错，同时在根目录下生成一个<code>.vscode</code>文件夹以及<code>launch.json</code>。打开这个json文件，将其中唯一一个需要我们配置的（也是本文第二次跟配置文件打交道）<code>program</code>项改为<code>cmake</code>生成的可执行文件的位置（按照惯例，根目录的名字和项目的名字应该是同一个，否则就需要手动指定）。</p><p><img src="/posts/40555/v2-853b8410f04d1e7570ecb9014026d6fc_720w.png" alt></p><p>再按一次<code>F5</code>，终端返回了一句亲切的<code>Hello World</code>。</p><p><img src="/posts/40555/v2-8905258989ea496e490ea8249830d89d_720w.png" alt></p><p>上个断点试试：</p><p><img src="/posts/40555/v2-0b1065976f31d39fa3e850c1897fa0ba_720w.webp" alt></p><p>完美，到这里就算搞定了，同理在win10下也一样。</p><p>再附上一些常用的的CMakeLists：</p><h2 id="多源文件配置头文件的搜索路径"><a href="#多源文件配置头文件的搜索路径" class="headerlink" title="多源文件配置头文件的搜索路径"></a>多源文件配置头文件的搜索路径</h2><pre class="line-numbers language-cmake"><code class="language-cmake">include_directories(${PROJECT_SOURCE_DIR}/include)include_directories(${PROJECT_SOURCE_DIR}/include/server)include_directories(${PROJECT_SOURSE_DIR}/thirdparty)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/posts/40555/image-20230918211340720-1695711789505-33.png" alt></p><p>同样需要告诉编辑器怎么去寻找执行文件，对于.vscode来说则是：</p><pre class="line-numbers language-json"><code class="language-json">            <span class="token property">"program"</span><span class="token operator">:</span> <span class="token string">"${workspaceFolder}/build/${fileBasenameNoExtension}"</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对于该种工程结构：<br>├── <strong>build</strong><br>├── CMakeLists.txt<br>├── <strong>include</strong><br>│   └── sayHello.h<br>├── main.cpp<br>└── <strong>src</strong><br>│   └── sayHello.cpp</p><p>对应的cmake添加：</p><blockquote><p>include_directories(include)<br>add_executable(main main.cpp src/atmp.cpp)</p></blockquote><p>对应的头文件如atmp.h和atmp.cpp分别在include和src里面，则只需要下面即可：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">ifndef</span> _ATMP_H</span><span class="token macro property">#<span class="token directive keyword">define</span> _ATMP_H</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>atmp.cpp</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">"atmp.h"</span></span><span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>main.cpp</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"atmp.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>即可成功编译运行。</p><h2 id="VPN的使用"><a href="#VPN的使用" class="headerlink" title="VPN的使用"></a>VPN的使用</h2><p><img src="/posts/40555/wsl-1695711915507-35.png" alt></p><p><img src="/posts/40555/QY_7NET0QO29D%7BYR4WC%7B$G-1695711922336-37.png" alt></p><p><a href="https://zhuanlan.zhihu.com/p/153124468">知乎有对应的脚本来开启vpn</a>，但有些细节没有说清楚。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>host_ip<span class="token operator">=</span><span class="token punctuation">$(</span>cat /etc/resolv.conf <span class="token operator">|</span><span class="token function">grep</span> <span class="token string">"nameserver"</span> <span class="token operator">|</span><span class="token function">cut</span> -f 2 -d <span class="token string">" "</span><span class="token punctuation">)</span><span class="token function">export</span> ALL_PROXY<span class="token operator">=</span><span class="token string">"http://<span class="token variable">$host_ip</span>:7890"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当你做完这些，<strong>一定要在对应的.zsh文件里面最后对端口配置文件进行source</strong>，不然无法生效。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;最近在做CMU15445，其实最痛苦的就是配环境，众所周知，VSCode的C/C++插件功能虽然全但是速度
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://JoyTsing.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="数据库" scheme="https://JoyTsing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>好久不见</title>
    <link href="https://joytsing.github.io/posts/62537/"/>
    <id>https://joytsing.github.io/posts/62537/</id>
    <published>2023-09-25T12:59:48.000Z</published>
    <updated>2023-09-25T13:35:59.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="首先，日安"><a href="#首先，日安" class="headerlink" title="首先，日安"></a>首先，日安</h2><p>好久不见，距离上次更新竟然已经过了两年之久，很惭愧一直都没有更新，这两年发生了很多东西，一件一件来说吧。</p><h3 id="关于未来"><a href="#关于未来" class="headerlink" title="关于未来"></a>关于未来</h3><p>怎么说呢，我从小一直对研究生有个渴望，但我上本科四年期间我一直没有想过能够通过这么曲折的方式拿到一个保研名额，相信愿意进来这的人都知道我本人是谁（我也不喜欢隐藏自己），这个故事我也讲过太多次了，也就不再这累述了，在这大学四年我感受到了许多也体会到了许多，特别是从18年开始混迹老乡群，给各位无偿解答了四年，认识了很多很棒的人，也认识了很多优秀的学弟学妹。</p><p>其实我也不知道为什么，各位学弟学妹都挺相信我的，不胜荣幸，其实说实话我感觉我读了四年书，其实除了最后摸了个保研名额（还去西电了）也没什么特别出众的。大学四年基本上是徘徊迷茫的四年，但感谢在我最迷茫的时光遇到了张，关，杨三位学长，也遇到了后面一直跟我联系的舍友和刘，感谢你们在我人生最重要的阶段能够彼此相识。</p><h2 id="其次，晚安"><a href="#其次，晚安" class="headerlink" title="其次，晚安"></a>其次，晚安</h2><p>往事涌上心中，在后面会更新稍稍多一点，这里给各位推荐<strong>obsidian</strong>这个软件来管理自己的学习笔记。</p><p>另外，给老乡群们答应的<code>UESTCer生存指南lite</code>后面也会更新,虽然可能会有点慢，但希望能对各位大学生生活能有微薄的帮助。</p><p>大学四年，有快乐又不快乐，在那时候总是抱怨，但真回头心中还是怀念那段时间，那么就这样，晚安。</p><p><img src="/posts/62537/1.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;首先，日安&quot;&gt;&lt;a href=&quot;#首先，日安&quot; class=&quot;headerlink&quot; title=&quot;首先，日安&quot;&gt;&lt;/a&gt;首先，日安&lt;/h2&gt;&lt;p&gt;好久不见，距离上次更新竟然已经过了两年之久，很惭愧一直都没有更新，这两年发生了很多东西，一件一件来说吧。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Scheme入门教程</title>
    <link href="https://joytsing.github.io/posts/56075/"/>
    <id>https://joytsing.github.io/posts/56075/</id>
    <published>2021-03-05T12:46:36.000Z</published>
    <updated>2023-09-26T07:43:11.653Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>虽然目前因为scheme过时，最新的SICP已经采用python作为系列语言，但是通过前两章的学习，可以说，Scheme（lisp方言）是一门充满魅力的语言，而且在之前有过关于用C设计lisp语言的学习，都用C写出来了lisp结果不熟悉lisp未免来说过于尴尬，因此决定恶补一下scheme。</p><h2 id="四种基本算术操作"><a href="#四种基本算术操作" class="headerlink" title="四种基本算术操作"></a>四种基本算术操作</h2><p>Scheme（以及大多数Lisp方言）都可以处理分数。</p><p>函数<code>exact-&gt;inexact</code> 用于把分数转换为浮点数。Scheme也可以处理复数。复数是形如<code>a+bi</code>的数，此处<code>a</code>称为实部，<code>b</code>称为虚部。<code>+</code>、<code>-</code>、<code>*</code>和<code>/</code>分别代表加、减、乘、除。这些函数都接受任意多的参数。</p><p>例：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token operator">-</span> <span class="token number">10</span> <span class="token number">3</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">;→ 7</span><span class="token punctuation">(</span><span class="token operator">-</span> <span class="token number">10</span> <span class="token number">3</span> <span class="token number">5</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">;→ 2</span><span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">;→ 6</span><span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">;→ 24</span><span class="token punctuation">(</span><span class="token operator">/</span> <span class="token number">29</span> <span class="token number">3</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">;→ 29/3</span><span class="token punctuation">(</span><span class="token operator">/</span> <span class="token number">29</span> <span class="token number">3</span> <span class="token number">7</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">;→ 29/21</span><span class="token punctuation">(</span><span class="token operator">/</span> <span class="token number">9</span> <span class="token number">6</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">;→ 3/2</span><span class="token punctuation">(</span><span class="token function">exact->inexact</span> <span class="token punctuation">(</span><span class="token operator">/</span> <span class="token number">29</span> <span class="token number">3</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;→ 1.380952380952381</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>括号可以像下面这样嵌套：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">-</span> <span class="token number">5</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;→ 10</span><span class="token punctuation">(</span><span class="token operator">/</span> <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">9</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;→ 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>形如这些由<strong>括号</strong>、<strong>标记（token）</strong>以及<strong>分隔符</strong>组成的式子，被称为<strong>S-表达式</strong>。</p><h3 id="其它算术操作"><a href="#其它算术操作" class="headerlink" title="其它算术操作"></a>其它算术操作</h3><h3 id="quotient，remainder，modulo和sqrt"><a href="#quotient，remainder，modulo和sqrt" class="headerlink" title="quotient，remainder，modulo和sqrt"></a>quotient，remainder，modulo和sqrt</h3><ul><li>函数<code>quotient</code>用于求<strong>商数（quotient）</strong>。</li><li>函数<code>remainder</code>和<code>modulo</code>用于求<strong>余数（remainder）</strong>。</li><li>函数<code>sqrt</code>用于求参数的<strong>平方根（square root）</strong>。</li></ul><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">quotient</span> <span class="token number">7</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;→ 2</span><span class="token punctuation">(</span><span class="token function">modulo</span> <span class="token number">7</span> <span class="token number">3</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">;→ 1</span><span class="token punctuation">(</span><span class="token function">sqrt</span> <span class="token number">8</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true">;→ 2.8284271247461903</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><p>数学上的三角函数，诸如<code>sin</code>，<code>cos</code>，<code>tan</code>，<code>asin</code>，<code>acos</code>和<code>atan</code>都可以在Scheme中使用。<code>atan</code>接受1个或2个参数。如果<code>atan</code>的参数为<code>1/2 π</code>，那么就要使用两个参数来计算。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">atan</span> <span class="token number">1</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">;→ 0.7853981633974483</span><span class="token punctuation">(</span><span class="token function">atan</span> <span class="token number">1</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;→ 1.5707963267948966</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="指数和对数"><a href="#指数和对数" class="headerlink" title="指数和对数"></a>指数和对数</h3><p>指数通过<code>exp</code>函数运算，对数通过<code>log</code>函数运算。<code>a</code>的<code>b</code>次幂可以通过<code>(expt a b)</code>来计算。</p><h2 id="生成表"><a href="#生成表" class="headerlink" title="生成表"></a>生成表</h2><p>作为Lisp语言大家族的一员，Scheme同样擅长于处理表。表在在后面章节中的递归函数和高阶函数中扮演重要角色。在本章中会讲解基本的表操作，例如<code>cons</code>，<code>car</code>，<code>cdr</code>，<code>list</code>和<code>quote</code>。</p><h3 id="Cons单元和表"><a href="#Cons单元和表" class="headerlink" title="Cons单元和表"></a>Cons单元和表</h3><h4 id="Cons单元"><a href="#Cons单元" class="headerlink" title="Cons单元"></a>Cons单元</h4><p>首先，让我解释一下表的元素：<strong>Cons单元（Cons cells）</strong>。Cons单元是一个存放了两个地址的内存空间。Cons单元可用函数<code>cons</code>生成。</p><p>在前端输入<code>(cons 1 2)</code></p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>系统返回<code>(1 . 2)</code>。如图一所示，函数<code>cons</code>给两个地址分配了内存空间，并把存放指向<code>1</code>的地址放在一个空间，把存放指向<code>2</code>的地址放在另一个空间。存放指向<code>1</code>的地址的内存空间被称作<code>car</code>部分，对应的，存放指向<code>2</code>的地址的内存空间被称作<code>cdr</code>部分。<code>car</code>和<code>cdr</code>分别是<strong>寄存器地址部分（Contents of the Address part of the Register）</strong>和<strong>寄存器减量部分（Contents of the Decrement part of the Register）</strong>的简称。这些名字最初来源于Lisp首次被实现所使用的硬件环境中内存空间的名字。这些名字同时也表明Cons单元的本质就是一个内存空间。<code>cons</code>这个名字是术语<strong>构造（construction）</strong>的简称。</p><p><img src="http://deathking.github.io/yast-cn/contents/figures/cons2.png" alt></p><p>Cons单元也可以被串起来。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这种情况的内存空间如图2所示。</p><p><img src="http://deathking.github.io/yast-cn/contents/figures/conss2.png" alt></p><p>Cons单元可以存放不同类型的数据也可以嵌套。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token builtin">cons</span> #\a <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token number">3</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 17: (#\a 3 . "hello")</span><span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token number">0</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 23: ((0 . 1) 2 . 3)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是因为Scheme可以通过地址操作所有的数据。（<code>#\c</code>代表了一个字符<code>c</code>。例如，<code>#\a</code>就代表字符<code>a</code>）</p><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><p>表是Cons单元通过用<code>cdr</code>部分连接到下一个<code>Cons</code>单元的开头实现的。表中包含的<code>’()</code>被称作空表。就算数据仅由一个Cons单元组成，只要它的<code>cdr</code>单元是<code>’()</code>，那它就是一个表。图3展示了表<code>(1 2 3)</code>的内存结构。</p><p><img src="http://deathking.github.io/yast-cn/contents/figures/list2.png" alt></p><p>事实上，表可以像下面这样递归地定义：</p><ol><li><code>‘()</code>是一个表</li><li>如果<code>ls</code>是一个表且<code>obj</code>是某种类型的数据，那么<code>(cons obj ls)</code>也是一个表 正因为表是一种被递归定义的数据结构，将它用在递归的函数中显然是合理的。</li></ol><p>###原子</p><p>不使用Cons单元的数据结构称为<strong>原子（atom）</strong>。数字，字符，字符串，向量和空表<code>’()</code>都是原子。<code>’()</code>既是原子，又是表。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>所有的记号都会依据Scheme的求值规则求值：所有记号都会从最内层的括号依次向外层括号求值，且最外层括号返回的值将作为S-表达式的值。一个被称为<strong>引用（quote）</strong>的形式可以用来阻止记号被求值。它是用来将符号或者表原封不动地传递给程序，而不是求值后变成其它的东西。</p><p>例如，<code>(+ 2 3)</code>会被求值为<code>5</code>，然而<code>(quote (+ 2 3))</code>则向程序返回<code>(+ 2 3)</code>本身。因为<code>quote</code>的使用频率很高，他被简写为<code>’</code>。</p><p>比如：</p><ul><li><code>’(+ 2 3)</code>代表列表<code>(+ 2 3)</code>本身；</li><li><code>’+</code>代表符号<code>+</code>本身；</li></ul><p>实际上，<code>’()</code>是对空表的引用，也就是说，尽管解释器返回<code>()</code>代表空表，你也应该用<code>’()</code>来表示空表。</p><h3 id="特殊形式"><a href="#特殊形式" class="headerlink" title="特殊形式"></a>特殊形式</h3><p>Scheme有两种不同类型的操作符：其一是函数。函数会对所有的参数求值并返回值。另一种操作符则是特殊形式。特殊形式不会对所有的参数求值。除了<code>quote</code>，<code>lambda</code>，<code>define</code>，<code>if</code>，<code>set!</code>，等都是特殊形式。</p><h3 id="car函数和cdr函数"><a href="#car函数和cdr函数" class="headerlink" title="car函数和cdr函数"></a>car函数和cdr函数</h3><p>返回一个Cons单元的<code>car</code>部分和<code>cdr</code>部分的函数分别是<code>car</code>和<code>cdr</code>函数。如果<code>cdr</code>部分串连着Cons单元，解释器会打印出整个<code>cdr</code>部分。如果Cons单元的<code>cdr</code>部分不是<code>’()</code>，那么其值稍后亦会被展示。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token builtin">car</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 1</span><span class="token punctuation">(</span><span class="token builtin">cdr</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 18: (2 3 4)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="list函数"><a href="#list函数" class="headerlink" title="list函数"></a>list函数</h3><p><code>list</code>函数使得我们可以构建包含数个元素的表。函数<code>list</code>有任意个数的参数，且返回由这些参数构成的表。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: ()</span><span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 24: (1)</span><span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">3</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 25: ((1 2) (3 4))</span><span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 26: (0)</span><span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 27: (1 2)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p>由于Sheme是函数式编程语言，你需要通过编写小型函数来构造程序。因此，明白如何构造并组合这些函数对掌握Scheme尤为关键。</p><p>你可以使用<code>define</code>来将一个符号与一个值绑定。你可以通过这个操作符定义例如数、字符、表、函数等任何类型的全局参数。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token comment" spellcheck="true">; Hello world as a variable</span><span class="token punctuation">(</span><span class="token keyword">define</span> vhello <span class="token string">"Hello world"</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">;1</span><span class="token comment" spellcheck="true">; Hello world as a function</span><span class="token punctuation">(</span><span class="token keyword">define</span> fhello <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token comment" spellcheck="true">;2</span>         <span class="token string">"Hello world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>操作符<code>define</code>用于声明变量，它接受两个参数。<code>define</code>运算符会使用第一个参数作为全局参数，并将其与第二个参数绑定起来。因此，代码片段1的第1行中，我们声明了一个全局参数<code>vhello</code>，并将其与<code>&quot;Hello，World&quot;</code>绑定起来。</p><p>紧接着，在第2行声明了一个返回<code>“Hello World”</code>的过程。</p><p>特殊形式<code>lambda</code>用于定义过程。<code>lambda</code>需要至少一个的参数，第一个参数是由定义的过程所需的参数组成的表。因为本例<code>fhello</code>没有参数，所以参数表是空表。</p><p>在解释器中输入<code>vhello</code>，解释器返回“Hello，World”。如果你在解释器中输入<code>fhello</code>，它也会返回像下面这样的值：<code>#[compound-procedure 16 fhello]</code>，这说明了Scheme解释器把过程和常规数据类型用同样的方式对待。正如我们在前面章节中讲解的那样，Scheme解释器通过内存空间中的数据地址操作所有的数据，因此，所有存在于内存空间中的对象都以同样的方式处理。</p><p>如果把<code>fhello</code>当过程对待，你应该用括号括住这些符号，比如<code>(fhello)</code>。</p><p>然后解释器会按照第二章讲述的规则那样对它求值，并返回“Hello World”。</p><h3 id="定义有参数的函数"><a href="#定义有参数的函数" class="headerlink" title="定义有参数的函数"></a>定义有参数的函数</h3><p>可以通过在<code>lambda</code>后放一个参数表来定义有参数的函数。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token comment" spellcheck="true">; hello with name</span><span class="token punctuation">(</span><span class="token keyword">define</span> hello  <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token function">string-append</span> <span class="token string">"Hello "</span> name <span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">; sum of three numbers</span><span class="token punctuation">(</span><span class="token keyword">define</span> sum3  <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token function">a</span> b c<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token operator">+</span> a b c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数<code>hello</code>有一个参数<code>(name)</code>，并会把<code>“Hello”</code>、<code>name的值</code>、和<code>&quot;!&quot;</code>连结在一起并返回。</p><p>预定义函数<code>string-append</code>可以接受任意多个数的参数，并返回将这些参数连结在一起后的字符串。</p><p><code>sum3</code>：此函数有三个参数并返回这三个参数的和。</p><h3 id="一种函数定义的短形式"><a href="#一种函数定义的短形式" class="headerlink" title="一种函数定义的短形式"></a>一种函数定义的短形式</h3><p>用<code>lambda</code>定义函数是一种规范的方法，但你也可以使用类似于代码片段3中展示的短形式。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token comment" spellcheck="true">; hello with name</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">hello</span> name<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">string-append</span> <span class="token string">"Hello "</span> name <span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">; sum of three numbers</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">sum3</span> a b c<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token operator">+</span> a b c<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这种形式中，函数按照它们被调用的形式被定义。代码片段2和代码片段3都是相同的。有些人不喜欢这种短形式的函数定义，但是在教程中使用这种形式，因为它可以使代码更短小。</p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>本章会讲解如何通过条件编写过程。这个是编写使用程序很重要的一步。</p><h3 id="if表达式"><a href="#if表达式" class="headerlink" title="if表达式"></a>if表达式</h3><p><code>if</code>表达式将过程分为两个部分。<code>if</code>的格式如下：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">if</span> predicate then_value else_value<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果<code>predicate</code>部分为真，那么<code>then_value</code>部分被求值，否则<code>else_value</code>部分被求值，并且求得的值会返回给<code>if</code>语句的括号外。<code>true</code>是除<code>false</code>以外的任意值，<code>true</code>使用<code>#t</code>表示，<code>false</code>用<code>#f</code>表示。</p><p>在R5RS中，<code>false</code>（<code>#f</code>）和空表<code>（’()）</code>是两个不同的对象。然而，在MIT-Scheme中，这两个为同一对象。这个不同可能是历史遗留问题，在以前的标准——R4RS中，<code>#f</code>和<code>’()</code>被定义为同一对象。</p><p>因此，从兼容性角度考虑，你不应该使用表目录作为谓词。使用函数<code>null?</code>来判断表是否为空。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token builtin">null?</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token builtin">null?</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">a</span> b c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: ()   ;#f</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数<code>not</code>可用于对谓词取反。此函数只有一个参数且如果参数值为<code>#f</code>则返回<code>#t</code>，反之，参数值为<code>#t</code>则返回<code>#f</code>。<code>if</code>表达式是一个特殊形式，因为它不对所有的参数求值。因为如果<code>predicate</code>为真，则只有<code>then_value</code>部分被求值。另一方面，如果<code>predicate</code>为假，只有<code>else_value</code>部分被求值。</p><p>例：首项为<code>a0</code>，增长率<code>r</code>，项数为<code>n</code>的几何增长（geometric progression）数列之和</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">sum-gp</span> a0 r n<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token operator">*</span> a0     <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> r <span class="token number">1</span><span class="token punctuation">)</span>         n         <span class="token punctuation">(</span><span class="token operator">/</span> <span class="token punctuation">(</span><span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">(</span><span class="token function">expt</span> r n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">-</span> <span class="token number">1</span> r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">; !!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通常来说，几何增长数列的求和公式如下：</p><pre><code>a0 * (1 - r^n) / (1 - r)                      (r ≠ 1)a0 * n                                        (r = 1)</code></pre><p>如果<code>if</code>表达式对所有参数求值的话，那么有<code>;!!</code>注释的那行就算在<code>r=1</code>时也会被求值，这将导致产生一个“除数为0”的错误。</p><p>你也可以省去<code>else_value</code>项。这样的话，当<code>predicate</code>为假时，返回值就没有被指定。如果你希望当<code>predicate</code>为假时返回<code>#f</code>，那么就要明确地将它写出来。</p><p><code>then_value</code>和<code>else_value</code>都应该是S-表达式。如果你需要副作用，那么就应该使用<code>begin</code>表达式。我们将在下一章讨论<code>begin</code>表达式。</p><h3 id="and和or"><a href="#and和or" class="headerlink" title="and和or"></a>and和or</h3><p><code>and</code>和<code>or</code>是用于组合条件的两个特殊形式。Scheme中的<code>and</code>和<code>or</code>不同于C语言中的约定。它们不返回一个布尔值（<code>#t</code>或<code>#f</code>），而是返回给定的参数之一。<code>and</code>和<code>or</code>可以使你的代码更加短小。</p><h4 id="and"><a href="#and" class="headerlink" title="and"></a>and</h4><p><code>and</code>具有任意个数的参数，并从左到右对它们求值。如果某一参数为<code>#f</code>，那么它就返回<code>#f</code>，而不对剩余参数求值。反过来说，如果所有的参数都不是<code>#f</code>，那么就返回最后一个参数的值。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">and</span> <span class="token boolean">#f</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: ()</span><span class="token punctuation">(</span><span class="token function">and</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 3</span><span class="token punctuation">(</span><span class="token function">and</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token boolean">#f</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: ()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="or"><a href="#or" class="headerlink" title="or"></a>or</h4><p><code>or</code>具有可变个数的参数，并从左到右对它们求值。它返回第一个不是值<code>#f</code>的参数，而余下的参数不会被求值。如果所有的参数的值都是<code>#f</code>的话，则返回最后一个参数的值。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">or</span> <span class="token boolean">#f</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 0</span><span class="token punctuation">(</span><span class="token function">or</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 1</span><span class="token punctuation">(</span><span class="token function">or</span> <span class="token boolean">#f</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 1</span><span class="token punctuation">(</span><span class="token function">or</span> <span class="token boolean">#f</span> <span class="token boolean">#f</span> <span class="token boolean">#f</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: ()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="cond表达式"><a href="#cond表达式" class="headerlink" title="cond表达式"></a>cond表达式</h3><p>尽管所有的分支都可以用<code>if</code>表达式表达，但当条件有更多的可能性时，你就需要使用嵌套的<code>if</code>表达式了，这将使代码变得复杂。处理这种情况可以使用<code>cond</code>表达式。<code>cond</code>表达式的格式如下：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">cond</span>  <span class="token punctuation">(</span><span class="token function">predicate_1</span> clauses_1<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">predicate_2</span> clauses_2<span class="token punctuation">)</span>    ......  <span class="token punctuation">(</span><span class="token function">predicate_n</span> clauses_n<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">else</span>        clauses_else<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>cond</code>表达式中，<code>predicates_i</code>是按照从上到下的顺序求值，而当<code>predicates_i</code>为真时，<code>clause_i</code>会被求值并返回。<code>i</code>之后的<code>predicates</code>和<code>clauses</code>不会被求值。如果所有的<code>predicates_i</code>都是假的话，则返回<code>cluase_else</code>。在一个子句中，你可以写数条S-表达式，而<code>clause</code>的值是最后一条S-表达式。</p><blockquote><p>例：城市游泳池的收费。</p><p>Foo市的城市游泳池按照顾客的年龄收费：</p><p>如果 age ≤ 3 或者 age ≥ 65 则 免费；<br>如果 介于 4 ≤ age ≤ 6 则 0.5美元；<br>如果 介于 7 ≤ age ≤ 12 则 1.0美元；<br>如果 介于 13 ≤ age ≤ 15 则 1.5美元；<br>如果 介于 16 ≤ age ≤ 18 则 1.8美元；<br>其它 则 2.0美元；</p><p>那么，一个返回城市游泳池收费的函数如下：</p></blockquote><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">fee</span> age<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">cond</span>   <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">or</span> <span class="token punctuation">(</span><span class="token operator">&lt;=</span> age <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">>=</span> age <span class="token number">65</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">0</span><span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&lt;=</span> <span class="token number">4</span> age <span class="token number">6</span><span class="token punctuation">)</span> <span class="token number">0.5</span><span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&lt;=</span> <span class="token number">7</span> age <span class="token number">12</span><span class="token punctuation">)</span> <span class="token number">1.0</span><span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&lt;=</span> <span class="token number">13</span> age <span class="token number">15</span><span class="token punctuation">)</span> <span class="token number">1.5</span><span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&lt;=</span> <span class="token number">16</span> age <span class="token number">18</span><span class="token punctuation">)</span> <span class="token number">1.8</span><span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token keyword">else</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="做出判断的函数"><a href="#做出判断的函数" class="headerlink" title="做出判断的函数"></a>做出判断的函数</h3><p>将介绍一些用于做判断的函数。这些函数的名字都以<code>&#39;?&#39;</code>结尾。</p><h3 id="eq-、eqv-和equal"><a href="#eq-、eqv-和equal" class="headerlink" title="eq?、eqv?和equal?"></a>eq?、eqv?和equal?</h3><p>基本函数<code>eq?</code>、<code>eqv?</code>、<code>equal?</code>具有两个参数，用于检查这两个参数是否“一致”。这三个函数之间略微有些区别。</p><blockquote><p><code>eq?</code><br>该函数比较两个对象的地址，如果相同的话就返回<code>#t</code>。例如，<code>(eq? str str)</code>返回<code>#t</code>，因为<code>str</code>本身的地址是一致的。与此相对的，因为字符串<code>”hello”</code>和<code>”hello”</code>被储存在了不同的地址中，函数将返回<code>#f</code>。不要使用<code>eq?</code>来比较数字，因为不仅在R5RS中，甚至在MIT-Scheme实现中，它都没有指定返回值。使用<code>eqv?</code>或者<code>=</code>替代。</p></blockquote><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> str <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: str</span><span class="token punctuation">(</span><span class="token function">eq?</span> str str<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token function">eq?</span> <span class="token string">"hello"</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: ()             ← It should be #f in R5RS </span><span class="token comment" spellcheck="true">;;; comparing numbers depends on implementations</span><span class="token punctuation">(</span><span class="token function">eq?</span> <span class="token number">1</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token function">eq?</span> <span class="token number">1.0</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: ()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>eqv?</code><br>该函数比较两个存储在内存中的对象的类型和值。如果类型和值都一致的话就返回<code>#t</code>。对于过程（<code>lambda</code>表达式）的比较依赖于具体的实现。这个函数不能用于类似于表和字符串一类的序列比较，因为尽管这些序列看起来是一致的，但它们的值是存储在不同的地址中。</p></blockquote><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">eqv?</span> <span class="token number">1.0</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token function">eqv?</span> <span class="token number">1</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: ()</span><span class="token comment" spellcheck="true">;;; don't use it to compare sequences</span><span class="token punctuation">(</span><span class="token function">eqv?</span> <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: ()</span><span class="token punctuation">(</span><span class="token function">eqv?</span> <span class="token string">"hello"</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: ()</span><span class="token comment" spellcheck="true">;;; the following depends on implementations</span><span class="token punctuation">(</span><span class="token function">eqv?</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: ()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>equal?</code><br>该函数用于比较类似于表或者字符串一类的序列。</p></blockquote><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">equal?</span> <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token function">equal?</span> <span class="token string">"hello"</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="用于检查数据类型的函数"><a href="#用于检查数据类型的函数" class="headerlink" title="用于检查数据类型的函数"></a>用于检查数据类型的函数</h3><p>下面列举了几个用于检查类型的函数。这些函数都只有一个参数。</p><ul><li><code>pair?</code> 如果对象为序对则返回<code>#t</code>；</li><li><code>list?</code> 如果对象是一个表则返回<code>#t</code>。要小心的是空表<code>’()</code>是一个表但是不是一个序对。</li><li><code>null?</code> 如果对象是空表’()的话就返回#t。</li><li><code>symbol?</code> 如果对象是一个符号则返回#t。</li><li><code>char?</code> 如果对象是一个字符则返回#t。</li><li><code>string?</code> 如果对象是一个字符串则返回#t。</li><li><code>number?</code> 如果对象是一个数字则返回#t。</li><li><code>complex?</code> 如果对象是一个复数则返回#t。</li><li><code>real?</code> 如果对象是一个实数则返回#t。</li><li><code>rational?</code> 如果对象是一个有理数则返回#t。</li><li><code>integer?</code> 如果对象是一个整数则返回#t。</li><li><code>exact?</code> 如果对象不是一个浮点数的话则返回#t。</li><li><code>inexact?</code> 如果对象是一个浮点数的话则返回#t。</li></ul><h3 id="用于比较数的函数"><a href="#用于比较数的函数" class="headerlink" title="用于比较数的函数"></a>用于比较数的函数</h3><blockquote><p><code>=</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;=</code><br>这些函数都有任意个数的参数。如果参数是按照这些函数的名字排序的话，函数就返回<code>#t</code>。</p></blockquote><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token operator">=</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token operator">=</span> <span class="token number">2</span> <span class="token number">2</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">3.1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token operator">></span> <span class="token number">4</span> <span class="token number">1</span> <span class="token number">-0.2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">1.1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token operator">>=</span> <span class="token number">2</span> <span class="token number">1</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token operator">&lt;</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">3.9</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: ()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>odd?</code>、<code>even?</code>、<code>positive?</code>、<code>negative?</code>、<code>zero?</code><br>这些函数仅有一个参数，如果这些参数满足函数名所指示的条件话就返回<code>#t</code>。</p></blockquote><h3 id="用于比较符号的函数"><a href="#用于比较符号的函数" class="headerlink" title="用于比较符号的函数"></a>用于比较符号的函数</h3><p>在比较字符的时候可以使用<code>char=?</code>、<code>char&lt;?</code>、<code>char&gt;?</code>、<code>char&lt;=?</code>以及<code>char&gt;=?</code>函数。具体的细节请参见R5RS。</p><h3 id="用于比较字符串的函数"><a href="#用于比较字符串的函数" class="headerlink" title="用于比较字符串的函数"></a>用于比较字符串的函数</h3><p>比较字符串时，可以使用<code>string=?</code>和<code>string-ci=?</code>等函数。具体细节请参见R5RS。</p><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><h3 id="let表达式"><a href="#let表达式" class="headerlink" title="let表达式"></a>let表达式</h3><p>使用<code>let</code>表达式可以定义局部变量。格式如下：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">let</span> binds body<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>变量在<code>binds</code>定义的形式中被声明并初始化。<code>body</code>由任意多个S-表达式构成。<code>binds</code>的格式如下：</p><pre><code>[binds] → ((p1 v1) (p2 v2) ...)</code></pre><p>声明了变量<code>p1</code>、<code>p2</code>，并分别为它们赋初值<code>v1</code>、<code>v2</code>。变量的<strong>作用域（Scope）</strong>为<code>body</code>体，也就是说变量只在<code>body</code>中有效。</p><blockquote><p>例1：声明局部变量<code>i</code>和<code>j</code>，将它们与<code>1</code>、<code>2</code>绑定，然后求二者的和。</p></blockquote><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">j</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token operator">+</span> i j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>let</code>表达式可以嵌套使用。</p><blockquote><p>例2：声明局部变量<code>i</code>和<code>j</code>，并将分别将它们与<code>1</code>和<code>i+2</code>绑定，然后求它们的乘积。</p></blockquote><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">j</span> <span class="token punctuation">(</span><span class="token operator">+</span> i <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token operator">*</span> i j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>由于变量的作用域仅在<code>body</code>中，下列代码会产生错误，因为在变量<code>j</code>的作用域中没有变量<code>i</code>的定义。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">j</span> <span class="token punctuation">(</span><span class="token operator">+</span> i <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token operator">*</span> i j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Error</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>let*</code>表达式可以用于引用定义在同一个绑定中的变量。实际上，<code>let*</code>只是嵌套的<code>let</code>表达式的语法糖而已。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">let*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">j</span> <span class="token punctuation">(</span><span class="token operator">+</span> i <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token operator">*</span> i j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>例3：函数<code>quadric-equation</code>用于计算二次方程。它需要三个代表系数的参数：<code>a</code>、<code>b</code>、<code>c</code> （<code>ax^2 + bx + c = 0</code>），返回一个存放答案的实数表。通过逐步地使用<code>let</code>表达式，可以避免不必要的计算。</p></blockquote><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token comment" spellcheck="true">;;;The scopes of variables d,e, and f are the regions with the same background colors.</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">quadric-equation</span> a b c<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">zero?</span> a<span class="token punctuation">)</span>            <span class="token string">'error</span>                                      <span class="token comment" spellcheck="true">; 1</span>      <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">d</span> <span class="token punctuation">(</span><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token operator">*</span> b b<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">4</span> a c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">; 2</span>        <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">negative?</span> d<span class="token punctuation">)</span>            <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                                      <span class="token comment" spellcheck="true">; 3</span>            <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">e</span> <span class="token punctuation">(</span><span class="token operator">/</span> b a <span class="token number">-2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">; 4</span>              <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">zero?</span> d<span class="token punctuation">)</span>              <span class="token punctuation">(</span><span class="token builtin">list</span> e<span class="token punctuation">)</span>              <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">f</span> <span class="token punctuation">(</span><span class="token operator">/</span> <span class="token punctuation">(</span><span class="token function">sqrt</span> d<span class="token punctuation">)</span> a <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">; 5</span>                <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token punctuation">(</span><span class="token operator">+</span> e f<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">-</span> e f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">quadric-equation</span> <span class="token number">3</span> <span class="token number">5</span> <span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">; solution of 3x^2+5x+2=0</span><span class="token comment" spellcheck="true">;Value 12: (-2/3 -1)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上，<code>let</code>表达式只是<code>lambda</code>表达式的一个语法糖：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">p1</span> v1<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">p2</span> v2<span class="token punctuation">)</span> ...<span class="token punctuation">)</span> exp1 exp2 ...<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token function">p1</span> p2 ...<span class="token punctuation">)</span>    exp1 exp2 ...<span class="token punctuation">)</span> v1 v2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这是因为<code>lambda</code>表达式用于定义函数，它为变量建立了一个作用域。也就是闭包的概念</p><h2 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Scheme中通常通过递归实现重复，而不是循环。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>在自己的定义中调用自己的函数叫做<strong>递归函数（Recursive Function）</strong>。虽然这听起来很奇怪，但是循环的常见方法。如果你把函数类比为机器的话，递归似乎毫无道理。然而，正因为函数是过程，函数调用自己是有意义的。比如说，让我们来考察一下文献调研吧。你可能需要去阅读你正在阅读的文献所引用的文献（cited-1）。进一步，你可能还需要去阅读文件（cite-1）所引用的其它文献。这样，文献调研就是一个递归的过程，你也可以重复这个调研过程直到满足了特定条件（比如说，你累了）。这样，将程序设计语言中的函数类比为人类活动（比如文献调研）将有助于理解递归函数。</p><p>我们通常使用计算阶乘来解释递归。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">fact</span> n<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> n <span class="token number">1</span><span class="token punctuation">)</span>      <span class="token number">1</span>      <span class="token punctuation">(</span><span class="token operator">*</span> n <span class="token punctuation">(</span><span class="token function">fact</span> <span class="token punctuation">(</span><span class="token operator">-</span> n <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>(fact 5)</code>的计算过程如下：</p><pre><code>(fact 5)⇒ 5 * (fact 4)⇒ 5 * 4 * (fact 3)⇒ 5 * 4 * 3 * (fact 2)⇒ 5 * 4 * 3 * 2 * (fact 1)⇒ 5 * 4 * 3 * 2 * 1⇒ 5 * 4 * 3 * 2⇒ 5 * 4 * 6⇒ 5 * 24⇒ 120</code></pre><p><code>(fact 5)</code>调用<code>(fact 4)</code>，<code>(fact 4)</code>调用<code>(fact 3)</code>，最后<code>(fact 1)</code>被调用。<code>(fact 5)</code>，<code>(fact 4)</code>……以及<code>(fact 1)</code>都被分配了不同的存储空间，直到<code>(fact (- i 1))</code>返回一个值之前，<code>(fact i)</code>都会保留在内存中，由于存在函数调用的开销，这通常会占用更多地内存空间和计算时间。</p><p>然而，递归函数可以以一种简单的方式表达重复。表是被递归定义的，进而表和递归函数可以很好地配合。例如，一个让表中所有元素翻倍的函数可以像下面这样写。如果参数是空表，那么函数应该停止计算并返回一个空表。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token builtin">list</span>*2 ls<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">null?</span> ls<span class="token punctuation">)</span>      <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">2</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token punctuation">(</span><span class="token builtin">list</span>*2 <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><p>普通的递归调用并不高效因为它既浪费存储空间又具有函数调用开销。与之相反，尾递归函数包含了计算结果，当计算结束时直接将其返回。特别地，由于Scheme规范要求尾递归调用转化为循环，因此尾递归调用就不存在函数调用开销。</p><p>[代码片段2]展示了[代码片段1]中函数<code>fact</code>的尾递归版本。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">fact-tail</span> n<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">fact-rec</span> n n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">fact-rec</span> n p<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> n <span class="token number">1</span><span class="token punctuation">)</span>      p      <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">m</span> <span class="token punctuation">(</span><span class="token operator">-</span> n <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token function">fact-rec</span> m <span class="token punctuation">(</span><span class="token operator">*</span> p m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>fact-tail</code>计算阶乘的过程像这样：</p><pre><code>(fact-tail 5)⇒ (fact-rec 5 5)⇒ (fact-rec 4 20)⇒ (fact-rec 3 60)⇒ (fact-rec 2 120)⇒ (fact-rec 1 120)⇒ 120</code></pre><p>因为<code>fact-rec</code>并不等待其它函数的计算结果，因此当它计算结束时即从内存中释放。计算通过修改<code>fact-rec</code>的参数来演进，这基本上等同于循环。如上文所述，Scheme将尾递归转化为循环，Scheme就无需提供循环的语法来实现重复。</p><h3 id="命名let"><a href="#命名let" class="headerlink" title="命名let"></a>命名let</h3><p>命名<code>let</code>（<strong>named let</strong>）可以用来表达循环。[代码片段3]中的函数<code>fact-let</code>展示了如何使用命名<code>let</code>来计算阶乘。<code>fact-let</code>函数使用了一个<strong>命名<code>let</code>表达式</strong><code>(loop)</code>，这与在[代码片段2]中展示的<code>fact-rec</code>函数是不同的。在被注释为<code>;1</code>的那行，代码将参数<code>n1</code>和<code>p</code>都初始化为<code>n</code>。再每次循环后，参数在被注释为<code>;2</code>的那行更新：将<code>n1</code>减1，而将<code>p</code>乘以<code>(n1 - 1)</code>。</p><p>在Scheme中，用命名<code>let</code>来表达循环是俗成的方法。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">fact-let</span> n<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">let</span> loop<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">n1</span> n<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">p</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span>           <span class="token comment" spellcheck="true">; 1</span>    <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> n1 <span class="token number">1</span><span class="token punctuation">)</span>                        p    <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">m</span> <span class="token punctuation">(</span><span class="token operator">-</span> n1 <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token function">loop</span> m <span class="token punctuation">(</span><span class="token operator">*</span> p m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">; 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="letrec"><a href="#letrec" class="headerlink" title="letrec"></a>letrec</h3><p><code>letrec</code>类似于<code>let</code>，但它允许一个名字递归地调用它自己。语法<code>letrec</code>通常用于定义复杂的递归函数。[代码片段4]展示了<code>fact</code>函数的<code>letrec</code>版本。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">fact-letrec</span> n<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">letrec</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">iter</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token function">n1</span> p<span class="token punctuation">)</span>           <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> n1 <span class="token number">1</span><span class="token punctuation">)</span>               p               <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">m</span> <span class="token punctuation">(</span><span class="token operator">-</span> n1 <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token punctuation">(</span><span class="token function">iter</span> m <span class="token punctuation">(</span><span class="token operator">*</span> p m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">; *</span>    <span class="token punctuation">(</span><span class="token function">iter</span> n n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正如被注释为<code>;*</code>的那行代码所示，局部变量<code>iter</code>可以在它的定义里面引用它自己。语法<code>letrec</code>是定义局部变量的俗成方式。</p><h3 id="do表达式"><a href="#do表达式" class="headerlink" title="do表达式"></a>do表达式</h3><p>虽然并不常见，但语法<code>do</code>也可用于表达重复。它的格式如下：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">do</span> binds <span class="token punctuation">(</span><span class="token function">predicate</span> value<span class="token punctuation">)</span>    body<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>变量在<code>binds</code>部分被绑定，而如果<code>predicate</code>被求值为真，则函数从循环中<strong>逃逸（escape）</strong>出来，并返回值<code>value</code>，否则循环继续进行。</p><p><code>binds</code>部分的格式如下所示：</p><pre><code>[binds] → ((p1 i1 u1) (p2 i2 u2) ... )</code></pre><p>变量<code>p1</code>，<code>p2</code>，…被分别初始化为<code>i1</code>，<code>i2</code>，…并在循环后分别被更新为<code>u1</code>，<code>u2</code>，…。</p><p>[代码片段5]演示了<code>fact</code>的<code>do</code>表达式版本。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">fact-do</span> n<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">do</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">n1</span> n <span class="token punctuation">(</span><span class="token operator">-</span> n1 <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">p</span> n <span class="token punctuation">(</span><span class="token operator">*</span> p <span class="token punctuation">(</span><span class="token operator">-</span> n1 <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">=</span> n1 <span class="token number">1</span><span class="token punctuation">)</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>变量<code>n1</code>和<code>p</code>分别被初始化为<code>n</code>和<code>n</code>，在每次循环后分别被减去1和乘以<code>(n1 - 1)</code>。当<code>n1</code>变为<code>1</code>时，函数返回<code>p</code>。</p><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p><strong>高阶函数（Higher Order Function）</strong>是一种以函数为参数的函数。它们都被用于<strong>映射（mapping）</strong>、<strong>过滤（filtering）</strong>、<strong>归档（folding）</strong>和<strong>排序（sorting）</strong>表。高阶函数提高了程序的模块性。编写对各种情况都适用的高阶函数与为单一情况编写递归函数相比，可以使程序更具可读性。比如说，使用一个高阶函数来实现排序可以使得我们使用不同的条件来排序，这就将排序条件和排序过程清楚地划分开来。函数<code>sort</code>具有两个参数，其一是一个待排序的表，其二是<strong>定序（Ordering）</strong>函数。下面展示了按照大小将一个整数表正序排序。<code>&lt;</code>函数就是（本例中的）两数的定序函数。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">sort</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">7883</span> <span class="token number">9099</span> <span class="token number">6729</span> <span class="token number">2828</span> <span class="token number">7754</span> <span class="token number">4179</span> <span class="token number">5340</span> <span class="token number">2644</span> <span class="token number">2958</span> <span class="token number">2239</span><span class="token punctuation">)</span> &lt;<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒  (2239 2644 2828 2958 4179 5340 6729 7754 7883 9099)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>另一方面，按照每个数末两位的大小排序可以按下面的方式实现：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">sort</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">7883</span> <span class="token number">9099</span> <span class="token number">6729</span> <span class="token number">2828</span> <span class="token number">7754</span> <span class="token number">4179</span> <span class="token number">5340</span> <span class="token number">2644</span> <span class="token number">2958</span> <span class="token number">2239</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token function">x</span> y<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token function">modulo</span> x <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">modulo</span> y <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒  (2828 6729 2239 5340 2644 7754 2958 4179 7883 9099)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>正如这里所演示的，像<strong>快速排序（Quick Sort）</strong>、<strong>归并排序（Merge Sort）</strong>等排序过程，将定序函数完全分离开来提高了代码的复用性。</p><p>在本节中，将讲解预定义的高阶函数，然后介绍如何定义高阶函数。由于Scheme并不区别过程和其它的数据结构，因此你可以通过将函数当作参数传递轻松的定义自己的高阶函数。</p><p>实际上，Scheme中预定义函数的本质就是高阶函数，因为Scheme并没有定义块结构的语法，因此使用<code>lambda</code>表达式作为一个块。</p><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>映射是将同样的行为应用于表所有元素的过程。R5RS定义了两个映射过程：其一为返回转化后的表的<code>map</code>过程，另一为注重副作用的<code>for-each</code>过程。</p><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p><code>map</code>过程的格式如下：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">map</span> procedure list1 list2 ...<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>procedure</code>是个与某个过程或<code>lambda</code>表达式相绑定的符号。作为参数的表的个数视<code>procedure</code>需要的参数而定。</p><p>例：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token comment" spellcheck="true">; Adding each item of '(1 2 3) and '(4 5 6).</span><span class="token punctuation">(</span><span class="token function">map</span> + <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">4</span> <span class="token number">5</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒  (5 7 9)</span><span class="token comment" spellcheck="true">; Squaring each item of '(1 2 3)</span><span class="token punctuation">(</span><span class="token function">map</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span> x x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒  (1 4 9)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="for-each"><a href="#for-each" class="headerlink" title="for-each"></a>for-each</h3><p><code>for-each</code>的格式与<code>map</code>一致。但<code>for-each</code>并不返回一个具体的值，只是用于副作用。</p><p>例：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> sum <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">for-each</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">set!</span> sum <span class="token punctuation">(</span><span class="token operator">+</span> sum x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>sum<span class="token comment" spellcheck="true">;⇒  10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><p>尽管过滤函数并没有在R5RS中定义，但MIT-Scheme实现提供了<code>keep-matching-items</code>和<code>delete-matching-item</code>两个函数。其它实现中应该有类似的函数。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">keep-matching-items</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">-3</span> <span class="token number">-4</span> <span class="token number">5</span><span class="token punctuation">)</span> positive?<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒  (1 2 5)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="归档"><a href="#归档" class="headerlink" title="归档"></a>归档</h3><p>尽管在R5RS中没有定义归档函数，但MIT-Scheme提供了<code>reduce</code>等函数。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">reduce</span> + <span class="token number">0</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                 <span class="token comment" spellcheck="true">;⇒  10</span><span class="token punctuation">(</span><span class="token function">reduce</span> + <span class="token number">0</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                     <span class="token comment" spellcheck="true">;⇒  3</span><span class="token punctuation">(</span><span class="token function">reduce</span> + <span class="token number">0</span> <span class="token string">'</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">)</span>                       <span class="token comment" spellcheck="true">;⇒  1</span><span class="token punctuation">(</span><span class="token function">reduce</span> + <span class="token number">0</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                        <span class="token comment" spellcheck="true">;⇒  0</span><span class="token punctuation">(</span><span class="token function">reduce</span> + <span class="token number">0</span> <span class="token string">'</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">)</span>                     <span class="token comment" spellcheck="true">;⇒  foo</span><span class="token punctuation">(</span><span class="token function">reduce</span> list <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">;⇒  (((1 2) 3) 4)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>尽管R5RS中没有定义排序函数，但MIT-Scheme提供了<code>sort</code>（实为<code>merge-sort</code>实现）和<code>quick-sort</code>函数。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">sort</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">3</span> <span class="token number">5</span> <span class="token number">1</span> <span class="token number">4</span> <span class="token number">-1</span><span class="token punctuation">)</span> &lt;<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒  (-1 1 3 4 5)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="apply函数"><a href="#apply函数" class="headerlink" title="apply函数"></a>apply函数</h3><p><code>apply</code>函数是将一个过程应用于一个表（译注：将表展开，作为过程的参数）。此函数具有任意多个参数，但首参数和末参数分别应该是一个过程和一个表。虽然乍看之下不然，但这个函数的确非常方便。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token builtin">apply</span> max <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">3</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">;⇒   3</span><span class="token punctuation">(</span><span class="token builtin">apply</span> + <span class="token number">1</span> <span class="token number">2</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">3</span> <span class="token number">4</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">;⇒  15</span><span class="token punctuation">(</span><span class="token builtin">apply</span> - <span class="token number">100</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">5</span> <span class="token number">12</span> <span class="token number">17</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">;⇒  66</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="编写高阶函数"><a href="#编写高阶函数" class="headerlink" title="编写高阶函数"></a>编写高阶函数</h3><p>自己编写高阶函数非常容易。这里用<code>member-if</code>、<code>member</code>演示。</p><h3 id="member-if和member"><a href="#member-if和member" class="headerlink" title="member-if和member"></a>member-if和member</h3><p><code>member-if</code>函数使用一个谓词和一个表作为参数，返回一个子表，该子表的<code>car</code>部分即是原列表中首个满足该谓词的元素。<code>member-if</code>函数可以像下面这样定义：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">member-if</span> proc ls<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">cond</span>   <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">null?</span> ls<span class="token punctuation">)</span> <span class="token boolean">#f</span><span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">proc</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span> ls<span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token keyword">else</span> <span class="token punctuation">(</span><span class="token function">member-if</span> proc <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">member-if</span> positive? <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">0</span> <span class="token number">-1</span> <span class="token number">-2</span> <span class="token number">3</span> <span class="token number">5</span> <span class="token number">-7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒  (3 5 -7)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，<code>member</code>函数检查特定元素是否在表中，该函数编写如下。函数需要三个参数，其一为用于比较的函数，其二为特定项，其三为待查找表。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">member</span> proc obj ls<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">cond</span>   <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">null?</span> ls<span class="token punctuation">)</span> <span class="token boolean">#f</span><span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">proc</span> obj <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span> ls<span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token keyword">else</span> <span class="token punctuation">(</span><span class="token function">member</span> proc obj <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">member</span> string=? <span class="token string">"hello"</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token string">"hi"</span> <span class="token string">"guys"</span> <span class="token string">"bye"</span> <span class="token string">"hello"</span> <span class="token string">"see you"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒  ("hello" "see you")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="输入-输出"><a href="#输入-输出" class="headerlink" title="输入/输出"></a>输入/输出</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>通过前面章节的学习，你已经可以在Scheme的交互式前端中编写并执行程序了。在本章中，我讲介绍如何输入和输出。使用这个特性，你可以从文件中读取数据或向文件中写入数据。</p><h2 id="从文件输入"><a href="#从文件输入" class="headerlink" title="从文件输入"></a>从文件输入</h2><h3 id="open-input-file，read-char和eof-object"><a href="#open-input-file，read-char和eof-object" class="headerlink" title="open-input-file，read-char和eof-object?"></a>open-input-file，read-char和eof-object?</h3><p>函数<code>(open-input-file filename)</code>可以用于打开一个文件。此函数返回一个用于输入的端口。函数<code>(read-char port)</code>用于从端口中读取一个字符。当读取到<strong>文件结尾（EOF）</strong>时，此函数返回<code>eof-object</code>，你可以使用<code>eof-object?</code>来检查。函数<code>(close-input-port port)</code>用于关闭输入端口。[代码片段1]展示了一个函数，该函数以字符串形式返回了文件内容。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">read-file</span> file-name<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">p</span> <span class="token punctuation">(</span><span class="token function">open-input-file</span> file-name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">let</span> loop<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">ls1</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">c</span> <span class="token punctuation">(</span><span class="token function">read-char</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">eof-object?</span> c<span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token keyword">begin</span>        <span class="token punctuation">(</span><span class="token function">close-input-port</span> p<span class="token punctuation">)</span>        <span class="token punctuation">(</span><span class="token builtin">list</span>->string <span class="token punctuation">(</span><span class="token function">reverse</span> ls1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> c ls1<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">read-char</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比如，在[范例1]中展示的结果就是将[代码片段1]应用于文件hello.txt。由于换行符是由<code>&#39;\n&#39;</code>表示的，这就很容易阅读。然而，像格式化输出[范例2]，我们也可使用<code>display</code>函数。</p><pre><code>Hello world!Scheme is an elegant programming language.</code></pre><h3 id="语法call-with-input-file和with-input-from-file"><a href="#语法call-with-input-file和with-input-from-file" class="headerlink" title="语法call-with-input-file和with-input-from-file"></a>语法call-with-input-file和with-input-from-file</h3><p>你通过使用语法<code>call-with-input-file</code>和<code>with-input-from-file</code>来打开文件以供读取输入。这些语法是非常方便的，因为它们要处理错误。</p><blockquote><pre><code>(call-with-input-file filename procedure)</code></pre><p>该函数将名为<code>filename</code>的文件打开以供读取输入。函数<code>procedure</code>接受一个输入端口作为参数。文件有可能再次使用，因此当<code>procedure</code>结束时文件不会自动关闭，文件应该显式地关闭。[代码片段1]可以按照[代码片段2]那样用<code>call-with-input-file</code>编写。</p></blockquote><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">read-file</span> file-name<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">call-with-input-file</span> file-name    <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token keyword">let</span> loop<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">ls1</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">c</span> <span class="token punctuation">(</span><span class="token function">read-char</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">eof-object?</span> c<span class="token punctuation">)</span>        <span class="token punctuation">(</span><span class="token keyword">begin</span>          <span class="token punctuation">(</span><span class="token function">close-input-port</span> p<span class="token punctuation">)</span>          <span class="token punctuation">(</span><span class="token builtin">list</span>->string <span class="token punctuation">(</span><span class="token function">reverse</span> ls1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> c ls1<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">read-char</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>(with-input-from-file filename procedure)</code> 该函数将名为<code>filename</code>的文件作为标准输入打开。函数<code>procedure</code>不接受任何参数。当<code>procedure</code>退出时，文件自动被关闭。[代码片段3]展示了如何用<code>with-input-from-file</code>来重写[代码片段1]。</p></blockquote><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">read-file</span> file-name<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">with-input-from-file</span> file-name    <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token keyword">let</span> loop<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">ls1</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">c</span> <span class="token punctuation">(</span>read-char<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">eof-object?</span> c<span class="token punctuation">)</span>        <span class="token punctuation">(</span><span class="token builtin">list</span>->string <span class="token punctuation">(</span><span class="token function">reverse</span> ls1<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> c ls1<span class="token punctuation">)</span> <span class="token punctuation">(</span>read-char<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3><p>函数<code>(read port)</code>从端口<code>port</code>中读入一个S-表达式。用它来读诸如”paren.txt”中带括号的内容就很方便。</p><pre><code>&#39;(Hello world!Scheme is an elegant programming language.)&#39;(Lisp is a programming language ready to evolve.)(define (s-read file-name)  (with-input-from-file file-name    (lambda ()      (let loop ((ls1 &#39;()) (s (read)))    (if (eof-object? s)        (reverse ls1)        (loop (cons s ls1) (read)))))))</code></pre><p>下面展示了用<code>s-read</code>读取”paren.txt”的结果。</p><pre><code>(s-read &quot;paren.txt&quot;)⇒ ((quote (hello world! scheme is an elegant programming language.))(quote (lisp is a programming language ready to evolve.)))</code></pre><h3 id="输出至文件"><a href="#输出至文件" class="headerlink" title="输出至文件"></a>输出至文件</h3><h4 id="打开一个用于输出的port"><a href="#打开一个用于输出的port" class="headerlink" title="打开一个用于输出的port"></a>打开一个用于输出的port</h4><p>输出有和输入类似的函数，比如：</p><p><strong>(open-output-file filename)</strong></p><p>该函数打开一个文件用作输出，放回该输出端口。</p><p><strong>(close-output-port port)</strong></p><p>关闭用于输出的端口。</p><p><strong>(call-with-output-file filename procedure)</strong></p><p>打开文件<code>filename</code>用于输出，并调用过程<code>procedure</code>。该函数以输出端口为参数。</p><p><strong>(with-output-to-file filename procedure)</strong></p><p>打开文件<code>filename</code>作为标准输出，并调用过程<code>procedure</code>。该过程没有参数。当控制权从过程<code>procedure</code>中返回时，文件被关闭。</p><h3 id="用于输出的函数"><a href="#用于输出的函数" class="headerlink" title="用于输出的函数"></a>用于输出的函数</h3><p>下面的函数可用于输出。如果参数<code>port</code>被省略的话，则输出至标准输出。</p><p><strong>(write obj port)</strong></p><p>该函数将<code>obj</code>输出至<code>port</code>。字符串被双引号括起而字符具有前缀<code>#\</code>。</p><p><strong>(display obj port)</strong></p><p>该函数将<code>obj</code>输出至<code>port</code>。字符串<em>不被</em>双引号括起而字符<em>不</em>具有前缀<code>#\</code>。</p><p><strong>(newline port)</strong></p><p>向 <code>port</code> 输出一个换行符。</p><p><strong>(write-char char port)</strong></p><p>该函数向<code>port</code>写入一个字符。</p><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p>因为Scheme是函数式语言，通常来说，你可以编写不使用赋值的语句。然而，如果使用赋值的话，有些算法就可以轻易实现了。尤其是内部状态和<strong>继续（continuations ）</strong>需要赋值。</p><p>尽管赋值非常习见并且易于理解，但它有一些本质上的缺陷。参见《计算机程序的构造和解释》的第三章第一节“赋值和局部状态”以及《为什么函数式编程如此重要》。</p><p>R5RS中规定的用于赋值的特殊形式是<code>set!</code>、<code>set-car!</code>、<code>set-cdr!</code>、<code>string-set!</code>、<code>vector-set!</code>等。除此之外，有些实现也依赖于赋值。由于赋值改变了参数的值，因此它具有<strong>破坏性（destructive）</strong>。Scheme中，具有破坏性的方法都以<code>!</code>结尾，以警示程序员。</p><h3 id="set"><a href="#set" class="headerlink" title="set!"></a>set!</h3><p><code>set!</code>可以为一个参数赋值。与Common Lisp不同，<code>set!</code>无法给一个S-表达式赋值。</p><p>赋值前参数应被定义。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> var <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">set!</span> var <span class="token punctuation">(</span><span class="token operator">*</span> var <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>var ⇒ <span class="token number">10</span><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">set!</span> i <span class="token punctuation">(</span><span class="token operator">+</span> i <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    i<span class="token punctuation">)</span>⇒ <span class="token number">4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="赋值和内部状态"><a href="#赋值和内部状态" class="headerlink" title="赋值和内部状态"></a>赋值和内部状态</h3><h4 id="静态作用域（词法闭包）"><a href="#静态作用域（词法闭包）" class="headerlink" title="静态作用域（词法闭包）"></a>静态作用域（词法闭包）</h4><p>Scheme中变量的作用域被限定在了源码中定义其的那个括号里。作用域与源代码书写方式一致的作用域称为<strong>“词法闭包（Lexical closure）”</strong>或<strong>“静态作用域（Static scope）”</strong>。采用静态作用域减轻了程序员的负担，因为它已经在代码中体现了，因此你可以很容易理解。另一方面，还有一种被称为<strong>“动态作用域（Dynamic scope）”</strong>的作用域。这种作用域仅在程序运行时确定。由于会在调试时带来种种问题，这种作用域现在已经不再使用。</p><p>特殊形式<code>let</code>、<code>lambda</code>、<code>letrec</code>生成闭包。lambda表达式的参数仅在函数定义内部有效。<code>let</code>只是<code>lambda</code>的语法糖，因此二者无异。</p><h4 id="使用赋值和词法闭包来实现内部状态"><a href="#使用赋值和词法闭包来实现内部状态" class="headerlink" title="使用赋值和词法闭包来实现内部状态"></a>使用赋值和词法闭包来实现内部状态</h4><p>你可以使用词法闭包来实现带有内部状态的过程。例如，用于模拟银行账户的过程可以按如下的方式编写：初始资金是10美元。函数接收一个整形参数。正数表示存入，负数表示取出。为了简单起见，这里允许存款为负数。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> bank-account  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">balance</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token keyword">set!</span> balance <span class="token punctuation">(</span><span class="token operator">+</span> balance n<span class="token punctuation">)</span><span class="token punctuation">)</span>      balance<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该过程将存款赋值为<code>(+ balance n)</code>。下面是调用这个过程的结果。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">bank-account</span> <span class="token number">20</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">; donating 20 dollars </span><span class="token comment" spellcheck="true">;Value: 30</span><span class="token punctuation">(</span><span class="token function">bank-account</span> <span class="token number">-25</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">; withdrawing 25 dollars</span><span class="token comment" spellcheck="true">;Value: 5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为在Scheme中，你可以编写返回过程的过程，因此你可以编写一个创建银行账户的函数。这个例子喻示着使用函数式程序设计语言可以很容易实现面向对象程序设计语言。实际上，只需要在这个基础上再加一点东西就可以实现一门面向对象程序设计语言了。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">make-bank-account</span> balance<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">set!</span> balance <span class="token punctuation">(</span><span class="token operator">+</span> balance n<span class="token punctuation">)</span><span class="token punctuation">)</span>    balance<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> gates-bank-account <span class="token punctuation">(</span><span class="token function">make-bank-account</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">; Gates makes a bank account by donating  10 dollars</span><span class="token comment" spellcheck="true">;Value: gates-bank-account</span><span class="token punctuation">(</span><span class="token function">gates-bank-account</span> <span class="token number">50</span><span class="token punctuation">)</span>                              <span class="token comment" spellcheck="true">; donating 50 dollars</span><span class="token comment" spellcheck="true">;Value: 60</span><span class="token punctuation">(</span><span class="token function">gates-bank-account</span> <span class="token number">-55</span><span class="token punctuation">)</span>                             <span class="token comment" spellcheck="true">; withdrawing 55 dollars</span><span class="token comment" spellcheck="true">;Value: 5</span><span class="token punctuation">(</span><span class="token keyword">define</span> torvalds-bank-account <span class="token punctuation">(</span><span class="token function">make-bank-account</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">; Torvalds makes a bank account by donating 100 dollars</span><span class="token comment" spellcheck="true">;Value: torvalds-bank-account</span><span class="token punctuation">(</span><span class="token function">torvalds-bank-account</span> <span class="token number">-70</span><span class="token punctuation">)</span>                             <span class="token comment" spellcheck="true">; withdrawing 70 dollars</span><span class="token comment" spellcheck="true">;Value: 30</span><span class="token punctuation">(</span><span class="token function">torvalds-bank-account</span> <span class="token number">300</span><span class="token punctuation">)</span>                             <span class="token comment" spellcheck="true">; donating 300 dollars</span><span class="token comment" spellcheck="true">;Value: 330</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h3><p>Scheme过程的主要目的是返回一个值，而另一个目的则称为<strong>副作用（Side Effect）</strong>。赋值和IO操作就是副作用。</p><h3 id="表的破坏性操作（set-car-，set-cdr-）"><a href="#表的破坏性操作（set-car-，set-cdr-）" class="headerlink" title="表的破坏性操作（set-car!，set-cdr!）"></a>表的破坏性操作（set-car!，set-cdr!）</h3><p>函数<code>set-car!</code>和<code>set-cdr!</code>分别为一个cons单元的car部分和cdr部分赋新值。和<code>set!</code>不同，这两个操作可以为S-表达式赋值。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> tree <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">3</span> <span class="token number">4</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">set-car!</span> <span class="token punctuation">(</span><span class="token builtin">car</span> tree<span class="token punctuation">)</span> <span class="token number">100</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">; changing 1 to 100 </span>tree <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">100</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">3</span> <span class="token number">4</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">set-cdr!</span> <span class="token punctuation">(</span><span class="token function">third</span> tree<span class="token punctuation">)</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">a</span> b c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">; changing  '(7 8 9) to '(a b c) </span>tree⇒ <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">100</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">3</span> <span class="token number">4</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">6</span> a b c<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列可以用<code>set-car!</code>和<code>set-cdr!</code>实现。队列是一种<strong>先进先出(First in first out, FIFO)</strong>的数据结构，表则是<strong>先进后出(First in last out，FILO)</strong>。图表1展示了队列的结构。<code>cons-cell-top</code>的car部分指向表（头），而（<code>cons-cell-top</code>的）cdr部分指向表末的cons单元（表尾）。</p><p>入队操作按如下步骤进行：</p><ol><li>将当前最末的cons单元（可以通过<code>cons-cell-top</code>取得）的cdr部分重定向到新的元素。</li><li>将<code>cons-cell-top</code>的cdr部分重定向到新的元素</li></ol><p>出队操作按如下步骤进行:</p><ol><li>将队首元素存放在一个局部变量里。</li><li>将<code>cons-cell-top</code>的car部分重定向到表的第二个元素</li></ol><p>[代码片段1]展示了如何实现队列。函数<code>enqueue!</code>返回将元素<code>obj</code>添加进队列<code>queue</code>后的队列。函数<code>dequeue!</code>将队列的首元素移出队列并将该元素的值作为返回值。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>make-queue<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">enqueue!</span> queue obj<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">lobj</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> obj <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">null?</span> <span class="token punctuation">(</span><span class="token builtin">car</span> queue<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">begin</span>      <span class="token punctuation">(</span><span class="token function">set-car!</span> queue lobj<span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token function">set-cdr!</span> queue lobj<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">begin</span>      <span class="token punctuation">(</span><span class="token function">set-cdr!</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> queue<span class="token punctuation">)</span> lobj<span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token function">set-cdr!</span> queue lobj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token builtin">car</span> queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">dequeue!</span> queue<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">obj</span> <span class="token punctuation">(</span><span class="token builtin">car</span> <span class="token punctuation">(</span><span class="token builtin">car</span> queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token function">set-car!</span> queue <span class="token punctuation">(</span><span class="token builtin">cdr</span> <span class="token punctuation">(</span><span class="token builtin">car</span> queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> q <span class="token punctuation">(</span>make-queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: q</span><span class="token punctuation">(</span><span class="token function">enqueue!</span> q <span class="token string">'a)</span><span class="token comment" spellcheck="true">;Value 12: (a)</span><span class="token punctuation">(</span><span class="token function">enqueue!</span> q <span class="token string">'b)</span><span class="token comment" spellcheck="true">;Value 12: (a b)</span><span class="token punctuation">(</span><span class="token function">enqueue!</span> q <span class="token string">'c)</span><span class="token comment" spellcheck="true">;Value 12: (a b c)</span><span class="token punctuation">(</span><span class="token function">dequeue!</span> q<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: a</span>q<span class="token comment" spellcheck="true">;Value 13: ((b c) c)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="字符与字符串"><a href="#字符与字符串" class="headerlink" title="字符与字符串"></a>字符与字符串</h2><h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h3><p>Scheme也有像<strong>字符（Character）</strong>、<strong>字符串（String）</strong>、<strong>符号（Symbol）</strong>、<strong>向量（Vector）</strong>等的其它数据类型。</p><h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><p>在某个字符前添加<code>#\</code>来表明该物是一个字符。例如，<code>#\a</code>表示字符a。字符<code>#\Space</code>、<code>#\Tab</code>、<code>#\Linefeed</code>和<code>#\Return</code>分别代表空格（Space）、制表符（Tab），Linefeed和返回（Return）。R5RS中定义了下面的与字符相关的函数。</p><p><strong>(char? obj)</strong></p><p>如果<code>obj</code>是一个字符则返回<code>#t</code>。</p><p><strong>(char=? c1 c2)</strong></p><p>如果<code>c1</code>和<code>c2</code>是同一个字符的话则返回<code>#t</code>。</p><p><strong>(char-&gt;integer c)</strong></p><p>将<code>c</code>转化为对应的整数（字符代码，character code）。</p><p>示例：<code>(char-&gt;integer #\a) =&gt; 97</code></p><p><strong>(integer-&gt;char n)</strong></p><p>该函数将一个整数转化为对应的字符。</p><p><strong>(char&lt;? c1 c2)</strong>，</p><p><strong>(char&lt;= c1 c2)</strong>，</p><p><strong>(char&gt; c1 c2)</strong>，</p><p><strong>(char&gt;= c1 c2)</strong></p><p>这些函数用于比较字符。实际上，这些函数比较的是字符代码的大小。</p><p>例如，<code>(char&lt;? c1 c2)</code>等同于<code>(&lt; (char-&gt;integer c1) (char-&gt;integer c2))</code></p><p><strong>(char-ci=? c1 c2)</strong>，</p><p><strong>(char-ci&lt;? c1 c2)</strong>，</p><p><strong>(char-ci&lt;=? c1 c2)</strong>，</p><p><strong>(char-ci&gt;? c1 c2)</strong>，</p><p><strong>(char-ci&gt;=? c1 c2)</strong></p><p>这些比较函数对大小写不敏感。</p><p><strong>(char-alphabetic? c)</strong>，</p><p><strong>(char-numeric? c)</strong>，</p><p><strong>(char-whitespace? c)</strong>，</p><p><strong>(char-upper-case? c)</strong>，</p><p><strong>(char-lower-case? c)</strong></p><p>这些函数分别用于检测字符<code>c</code>是否为字母、数字、空白符、大写字母或小写字母。</p><p><strong>(char-upcase c)</strong>，</p><p><strong>(char-downcase c)</strong></p><p>这些函数分别返回字符C对应的大写或小写。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串通过两个闭合的双引号表示。例如，<code>&quot;abc&quot;</code>表示字符串<code>abc</code>。R5RS定义了下面的函数。</p><p><strong>(string? s)</strong></p><p>如果<code>s</code>是一个字符则返回<code>#t</code>。</p><p><strong>(make-string n c)</strong></p><p>返回由<code>n</code>个字符<code>c</code>组成的字符串。参数<code>c</code>可选。</p><p><strong>(string-length s)</strong></p><p>返回字符串<code>s</code>的长度。</p><p><strong>(string=? s1 s2)</strong></p><p>如果字符串<code>s1</code>和<code>s2</code>相同的话则返回<code>#t</code>。</p><p><strong>(string-ref s idx)</strong></p><p>返回字符串<code>s</code>中索引为<code>idx</code>的字符（索引从0开始计数）。</p><p><strong>(string-set! s idx c)</strong></p><p>将字符串<code>s</code>中索引为<code>idx</code>的字符设置为<code>c</code>。</p><p><strong>(substring s start end)</strong></p><p>返回字符串<code>s</code>从<code>start</code>开始到<code>end-1</code>处的子串。例如<code>(substring &quot;abcdefg&quot; 1 4) =&gt; &quot;b c d&quot;</code></p><p><strong>(string-append s1 s2 …)</strong></p><p>连接两个字符串<code>s1</code>和<code>s2</code></p><p><strong>(string-&gt;list s)</strong></p><p>将字符串<code>s</code>转换为由字符构成的表。</p><p><strong>(list-&gt;string ls)</strong></p><p>将一个由字符构成的表转换为字符串。</p><p><strong>(string-copy s)</strong></p><p>复制字符串<code>s</code>。</p><h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><h3 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h3><p>我会在本章讲解在Lisp/Scheme程序设计语言中极具特色的数据类型——符号。符号是一种通过地址管理字符串的数据。符号可以被如<code>eq?</code>这样运行迅速地函数处理，而纯字符串需要被更慢的<code>equal?</code>处理。由于符号可以被快速比较，它们被用于做关联表和哈希表的键。</p><h3 id="有关符号的基本函数"><a href="#有关符号的基本函数" class="headerlink" title="有关符号的基本函数"></a>有关符号的基本函数</h3><p>下列都是有关符号的基本函数。</p><p><strong>(symbol? x)</strong></p><p>如果<code>x</code>是一个符号则返回#t。</p><p><strong>(string-&gt;symbol str)</strong></p><p>将<code>str</code>转换为符号。<code>str</code>应该都是小写的，否则地址系统可能无法正常工作。在MIT-Scheme中，<code>(string-&gt;symbol &quot;Hello&quot;)</code>和<code>&#39;Hello</code>是不同的。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">eq?</span> <span class="token punctuation">(</span><span class="token function">string->symbol</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span> <span class="token string">'Hello)</span><span class="token comment" spellcheck="true">;Value: ()</span><span class="token punctuation">(</span><span class="token function">eq?</span> <span class="token punctuation">(</span><span class="token function">string->symbol</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">string->symbol</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token function">symbol->string</span>  <span class="token punctuation">(</span><span class="token function">string->symbol</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 15: "Hello"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(symbol-&gt;string sym)</strong></p><p>将<code>sym</code>转换为字符。</p><h3 id="统计文本中的单词"><a href="#统计文本中的单词" class="headerlink" title="统计文本中的单词"></a>统计文本中的单词</h3><p>下面的代码是一段统计文本中单词个数的程序，这也是被经常用作演示如何使用符号的例子。该程序使用了<strong>哈希表（Hash table）</strong>和<strong>关联表（Association list）</strong>，这些都将在下一章中讲解。</p><pre class="line-numbers language-scheme"><code class="language-scheme">    <span class="token comment" spellcheck="true">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>     <span class="token comment" spellcheck="true">;;;   wc.scm</span>     <span class="token comment" spellcheck="true">;;;   a scheme word-count program</span>     <span class="token comment" spellcheck="true">;;;</span>     <span class="token comment" spellcheck="true">;;;    by T.Shido</span>     <span class="token comment" spellcheck="true">;;;    on August 19, 2005</span>     <span class="token comment" spellcheck="true">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token builtin">list</span>->symbol ls0<span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token function">string->symbol</span> <span class="token punctuation">(</span><span class="token builtin">list</span>->string <span class="token punctuation">(</span><span class="token function">reverse!</span> ls0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">char-in</span> c . ls<span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token keyword">let</span> loop<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">ls0</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">null?</span> ls0<span class="token punctuation">)</span>             <span class="token boolean">#f</span>           <span class="token punctuation">(</span><span class="token function">or</span> <span class="token punctuation">(</span><span class="token function">char=?</span> c <span class="token punctuation">(</span><span class="token builtin">car</span> ls0<span class="token punctuation">)</span><span class="token punctuation">)</span>               <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">read-words</span> fname<span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token function">with-input-from-file</span> fname         <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>           <span class="token punctuation">(</span><span class="token keyword">let</span> loop<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">w</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">wls</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">c</span> <span class="token punctuation">(</span>read-char<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>           <span class="token punctuation">(</span><span class="token keyword">cond</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">eof-object?</span> c<span class="token punctuation">)</span>                 <span class="token punctuation">(</span><span class="token function">reverse!</span> <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">pair?</span> w<span class="token punctuation">)</span>                               <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token punctuation">(</span><span class="token builtin">list</span>->symbol w<span class="token punctuation">)</span> wls<span class="token punctuation">)</span>                             wls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">char-in</span> c #\Space #\Linefeed #\Tab #\, #\.  #\ #\<span class="token punctuation">(</span><span class="token function"></span> #\<span class="token punctuation">)</span> #\= #\? #\! #\<span class="token comment" spellcheck="true">; #\:)</span>                 <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">pair?</span> w<span class="token punctuation">)</span>                               <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token punctuation">(</span><span class="token builtin">list</span>->symbol w<span class="token punctuation">)</span> wls<span class="token punctuation">)</span>                             wls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">(</span><span class="token keyword">else</span>             <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token punctuation">(</span><span class="token function">char-downcase</span> c<span class="token punctuation">)</span> w<span class="token punctuation">)</span> wls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">sort-by-frequency</span> al<span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token function">sort</span> al <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token function">x</span> y<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">wc</span> fname<span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">wh</span> <span class="token punctuation">(</span>make-eq-hash-table<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token punctuation">(</span><span class="token keyword">let</span> loop<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">ls</span> <span class="token punctuation">(</span><span class="token function">read-words</span> fname<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>           <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">null?</span> ls<span class="token punctuation">)</span>               <span class="token punctuation">(</span><span class="token function">sort-by-frequency</span> <span class="token punctuation">(</span><span class="token function">hash-table->alist</span> wh<span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token punctuation">(</span><span class="token keyword">begin</span>             <span class="token punctuation">(</span><span class="token function">hash-table/put!</span> wh <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">1+</span> <span class="token punctuation">(</span><span class="token function">hash-table/get</span> wh <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>              <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">wc</span> <span class="token string">"opensource.txt"</span><span class="token punctuation">)</span>⇒<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">the</span> . <span class="token number">208</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">to</span> . <span class="token number">142</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">a</span> . <span class="token number">104</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">of</span> . <span class="token number">103</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">and</span> . <span class="token number">83</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">that</span> . <span class="token number">75</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">is</span> . <span class="token number">73</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">in</span> . <span class="token number">65</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">i</span> . <span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">you</span> . <span class="token number">55</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">it</span> . <span class="token number">54</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">they</span> . <span class="token number">48</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">for</span> . <span class="token number">46</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">what</span> . <span class="token number">38</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">work</span> . <span class="token number">37</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">but</span> . <span class="token number">35</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">have</span> . <span class="token number">32</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">on</span> . <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">people</span> . <span class="token number">32</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">are</span> . <span class="token number">30</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">be</span> . <span class="token number">29</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">do</span> . <span class="token number">29</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">from</span> . <span class="token number">27</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">so</span> . <span class="token number">26</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">like</span> . <span class="token number">25</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">as</span> . <span class="token number">25</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">by</span> . <span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">source</span> . <span class="token number">24</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">not</span> . <span class="token number">23</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">open</span> . <span class="token number">23</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">can</span> . <span class="token number">23</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">we</span> . <span class="token number">22</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">was</span> . <span class="token number">22</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">one</span> . <span class="token number">22</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>it<span class="token string">'s</span> . <span class="token number">22</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">an</span> . <span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">this</span> . <span class="token number">20</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">about</span> . <span class="token number">20</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">business</span> . <span class="token number">18</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">working</span> . <span class="token number">18</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">most</span> . <span class="token number">17</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">there</span> . <span class="token number">17</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">at</span> . <span class="token number">17</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">with</span> . <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">(</span>don<span class="token string">'t</span> . <span class="token number">16</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">just</span> . <span class="token number">16</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">their</span> . <span class="token number">16</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">something</span> . <span class="token number">15</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">than</span> . <span class="token number">15</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">has</span> . <span class="token number">15</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">if</span> . <span class="token number">15</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">when</span> . <span class="token number">14</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">because</span> . <span class="token number">14</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">more</span> . <span class="token number">14</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">were</span> . <span class="token number">13</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">office</span> . <span class="token number">13</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">own</span> . <span class="token number">13</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">or</span> . <span class="token number">12</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">online</span> . <span class="token number">12</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">now</span> . <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">blogging</span> . <span class="token number">12</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">how</span> . <span class="token number">12</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">employees</span> . <span class="token number">11</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">them</span> . <span class="token number">11</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">think</span> . <span class="token number">11</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">time</span> . <span class="token number">11</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">company</span> . <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">lot</span> . <span class="token number">11</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">want</span> . <span class="token number">11</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">companies</span> . <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">could</span> . <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">know</span> . <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">get</span> . <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">learn</span> . <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">better</span> . <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">some</span> . <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">who</span> . <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">even</span> . <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">thing</span> . <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">much</span> . <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">no</span> . <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">make</span> . <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">up</span> . <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">being</span> . <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">money</span> . <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">relationship</span> . <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>that<span class="token string">'s</span> . <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">us</span> . <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">anyone</span> . <span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">average</span> . <span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">bad</span> . <span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">same</span> . <span class="token number">8</span><span class="token punctuation">)</span>..........<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><p><strong>(list-&gt;symbo <code>ls0</code>)</strong></p><p>将一个由字符构成的列表（<code>ls0</code>）转换为一个符号。</p><p><strong>(char-in <code>c</code> . <code>ls</code>)</strong></p><p>检查字符（<code>c</code>）是否存在表（<code>ls</code>）。如果存在返回#t，不存在返回#f。</p><p><strong>(read-words <code>fname</code>)</strong></p><p>读取一个名为<code>fname</code>的文件，并返回一个符号列表。函数将大写转换为小写，将字符表（<code>w</code>）转换为一个字符，将<code>it</code>添加到符号表（<code>wls</code>）中。</p><p><strong>(sort-by-frequency <code>al</code>)</strong></p><p>以出现频率降序排序关联表（<code>al</code>）。</p><p><strong>(wc <code>fname</code>)</strong></p><p>读取名为<code>fname</code>的文件，并返回一个以出现频率降序排序关联表。因为函数使用了符号，<code>eq-hash-table</code>是适用的，它使用执行速度很快地<code>eq?</code>比较键（第40行）。函数统计由<code>read-words</code>创建的单词表里各单词的数量，并将其存储在一个哈希表（第44-46行）。在统计完成时（第43行），将哈希表转换为关联表。</p><h2 id="关联表和哈希表"><a href="#关联表和哈希表" class="headerlink" title="关联表和哈希表"></a>关联表和哈希表</h2><h3 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h3><p>本章中，我会讲解用于表示数据关联的关联表和哈希表。关联的数据是由键和值组成的序对，值由键唯一确定的。表1显示了书和作者构成的配对。书籍可以确定作者，反之由作者确定书籍则不可，这是因为一个作者可能会写很多本书。表1中，由于P. Graham和L.Carroll分别写了两本书，因此他们的书无法被作者的名字唯一确定。</p><p>表1：作者和书</p><table><thead><tr><th align="left">Author</th><th align="left">Book</th></tr></thead><tbody><tr><td align="left">P. Graham</td><td align="left">On Lisp</td></tr><tr><td align="left">P. Graham</td><td align="left">ANSI Common Lisp</td></tr><tr><td align="left">E. S. Raymond</td><td align="left">The Cathedral and the Bazaar</td></tr><tr><td align="left">K. Dybvig</td><td align="left">The Scheme Programming Language</td></tr><tr><td align="left">F. P. Brooks, Jr.</td><td align="left">The Mythical Man-Month</td></tr><tr><td align="left">L. Carroll</td><td align="left">Alice’s Adventures in Wonderland</td></tr><tr><td align="left">L. Carroll</td><td align="left">Through the Looking-Glass, and What Alice Found There</td></tr></tbody></table><p>R5RS定义了关联表，因此它在所有Scheme实现中都可用。但是使用关联表搜索速度较慢（O(n)的时间复杂度）。使用哈希表在速度方面更好一些（O(1)的时间复杂度），但是哈希表并未在R5RS中定义而是依赖于相关实现。MIT-Scheme实现了哈希表。如果你喜欢的Scheme实现没有哈希表，你可以自己实现一个（见 <a href="http://www.math.grin.edu/~stone/events/scheme-workshop/hash-tables.html）。">http://www.math.grin.edu/~stone/events/scheme-workshop/hash-tables.html）。</a></p><h3 id="关联表"><a href="#关联表" class="headerlink" title="关联表"></a>关联表</h3><p>关联表是一个由序对组成的表，它是一个用于表达关联的基本数据类型。符号，字符，和数字常被作为键使用，因为它们可以使用诸如<code>eq?</code>或者<code>eqv?</code>的快速比较函数被比较。在作为键被使用前，字符串应该被转换为符号，从而获得更好的性能。</p><p>下面是一个关联表的例子。关联表应该要么由点序对要么由普通表组成。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">hi</span> . <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">everybody</span> . <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">nice</span> . <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">to</span> . <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">meet</span> . <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">you</span> . <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">4</span> <span class="token number">5</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">7</span> <span class="token number">8</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>函数<code>assq</code>，<code>assv</code>，和<code>assoc</code>从关联表中搜寻一个项。这些函数从开始一步步搜索关联表。如果它们找到序对的<code>car</code>等于给定的<code>key</code>，就返回该序对。如果找不到函数返回<code>#f</code>。这些函数分别使用<code>eq?</code>，<code>eqv?</code>，和<code>equal?</code>比较键，这意味着<code>assq</code>最快，<code>assoc</code>最慢。这表示作为键的话，字符串，向量和表应该转化为符号或者数字（如果可能的话）以提高性能。</p><p>一般来说，<a href="http://www.shido.info/lisp/scheme_ah_e.html#hash">哈希表</a>在大量数据中搜索表现得更好一些。</p><p>下面展示在关联表中进行搜索的例子。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> wc <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">hi</span> . <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">everybody</span> . <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">nice</span> . <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">to</span> . <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">meet</span> . <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">you</span> . <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>⇒ wc<span class="token punctuation">(</span><span class="token function">assq</span> <span class="token string">'hi</span> wc<span class="token punctuation">)</span>⇒  <span class="token punctuation">(</span><span class="token function">hi</span> . <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">assq</span> <span class="token string">'you</span> wc<span class="token punctuation">)</span>⇒  <span class="token punctuation">(</span><span class="token function">you</span> . <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">assq</span> <span class="token string">'i</span> wc<span class="token punctuation">)</span>⇒  <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> n <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">4</span> <span class="token number">5</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">7</span> <span class="token number">8</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>⇒  n<span class="token punctuation">(</span><span class="token function">assv</span> <span class="token number">1</span> n<span class="token punctuation">)</span>⇒  <span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">assv</span> <span class="token number">8</span> n<span class="token punctuation">)</span>⇒  <span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p><a href="http://en.wikipedia.org/wiki/Hash-table">哈希表</a>是一种数据类型，它使用哈希函数将键转化为整数，并将值存储在由该整数所指示的位置。当表足够稀疏时，搜索，插入，更新都能以O(1)完成。下面展示了MIT-Scheme里哈希表的一些基本函数。查询<a href="http://www.swiss.ai.mit.edu/projects/scheme/documentation/scheme_12.html#SEC119">MIT-Scheme Manul</a>获取更详细的信息。</p><p><strong>(make-eq-hash-table size),</strong></p><p><strong>(make-eqv-hash-table size),</strong></p><p><strong>(make-equal-hash-table size),</strong></p><p><strong>(make-string-hash-table size)</strong></p><p>这些函数创建哈希表。这些函数分别使用<code>eq?</code>，<code>eqv?</code>，<code>equal?</code>，和<code>string=?</code>比较键的值。哈希表的初始大小（<code>size</code>）可以选择性指定（optional）。由于只比较键的地址，所以<code>eq-hash-table</code>是最快的。由于键是序列，所以<code>equal-hash-table</code>和<code>string-hash-table</code>比较慢。</p><p><strong>(hash-table/put! hash-table key datum)</strong></p><p>将<code>hash-table</code>中<code>key</code>对应的值设为<code>datum</code>。</p><p><strong>(hash-table/get hash-table key default)</strong></p><p>返回<code>hash-table</code>中的<code>key</code>对应的值。如果<code>key</code>不存在于<code>hash-table</code>中，返回<code>default</code>。</p><p><strong>(hash-table-&gt;alist hash-table)</strong></p><p>将<code>hash-table</code>转换为关联表。</p><h3 id="生成密码"><a href="#生成密码" class="headerlink" title="生成密码"></a>生成密码</h3><p>让我们写一个密码创建程序作为关联表和哈希表的例子。</p><p>从字典里得到的密码很容易被破解，但另一方面，完全随机的密码又很难记忆和输入。程序使用无规则的拼写创建10个密码。密码应该尽可能频繁更改，但是我懒于自己创建密码。使用这个程序，我可以简单地改变密码。</p><p>程序由两部分构成。一部分用于创建连续字符出现频率的数据（stat-spell.scm），另一个用于基于这个数据创建密码（make-pw.scm）。</p><h3 id="stat-spell-scm"><a href="#stat-spell-scm" class="headerlink" title="stat-spell.scm"></a>stat-spell.scm</h3><p>这个程序可以阅读英语句子，数据存在哈希表里，并转换为关联表输出到一个文件（stat-spell.data）。[代码1]显示了源代码。</p><p>[代码1]</p><pre class="line-numbers language-scheme"><code class="language-scheme">01:     <span class="token comment" spellcheck="true">;;; make an alist of probable spelling from a given English text</span><span class="token number">02</span>:     <span class="token number">03</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">skip-char?</span> c<span class="token punctuation">)</span><span class="token number">04</span>:       <span class="token punctuation">(</span><span class="token function">or</span> <span class="token punctuation">(</span><span class="token function">not</span> <span class="token punctuation">(</span><span class="token function">char-graphic?</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">memv</span> c <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">#\:</span> #\<span class="token comment" spellcheck="true">; #\' #\" #\`))))</span><span class="token number">05</span>:     <span class="token number">06</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">ss-make-alist</span> c alist<span class="token punctuation">)</span><span class="token number">07</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">p</span> <span class="token punctuation">(</span><span class="token function">assv</span> c alist<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">08</span>:         <span class="token punctuation">(</span><span class="token keyword">if</span> p<span class="token number">09</span>:             <span class="token punctuation">(</span><span class="token keyword">begin</span><span class="token number">10</span>:              <span class="token punctuation">(</span><span class="token function">set-cdr!</span> p <span class="token punctuation">(</span><span class="token function">1+</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">11</span>:              alist<span class="token punctuation">)</span><span class="token number">12</span>:           <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> c <span class="token number">1</span><span class="token punctuation">)</span> alist<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">13</span>:     <span class="token number">14</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">ss-make-dat</span> filename<span class="token punctuation">)</span><span class="token number">15</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">char-hash</span> <span class="token punctuation">(</span>make-eqv-hash-table<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">16</span>:         <span class="token punctuation">(</span><span class="token function">with-input-from-file</span> filename<span class="token number">17</span>:           <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">18</span>:         <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">c</span> #\Space<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">19</span>:           <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">c1</span> <span class="token punctuation">(</span>read-char<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">20</span>:                      <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">not</span> <span class="token punctuation">(</span><span class="token builtin">eof-object?</span> c1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">21</span>:                          <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">skip-char?</span> c1<span class="token punctuation">)</span><span class="token number">22</span>:                              <span class="token punctuation">(</span><span class="token function">loop</span> c<span class="token punctuation">)</span><span class="token number">23</span>:                              <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">c1</span> <span class="token punctuation">(</span><span class="token function">char-downcase</span> c1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">24</span>:                    <span class="token punctuation">(</span><span class="token function">hash-table/put!</span> char-hash c<span class="token number">25</span>:                             <span class="token punctuation">(</span><span class="token function">ss-make-alist</span> c1 <span class="token punctuation">(</span><span class="token function">hash-table/get</span> char-hash c <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">26</span>:                    <span class="token punctuation">(</span><span class="token function">loop</span> c1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">27</span>:         <span class="token punctuation">(</span><span class="token function">with-output-to-file</span> <span class="token string">"stat-spell.dat"</span><span class="token number">28</span>:           <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">29</span>:         <span class="token punctuation">(</span><span class="token function">display</span> <span class="token string">"(define *stat-spell* \'("</span><span class="token punctuation">)</span><span class="token number">30</span>:         <span class="token punctuation">(</span>newline<span class="token punctuation">)</span><span class="token number">31</span>:         <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">alst</span> <span class="token punctuation">(</span><span class="token function">sort</span> <span class="token punctuation">(</span><span class="token function">hash-table->alist</span> char-hash<span class="token punctuation">)</span> <span class="token number">32</span>:                        <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token function">x</span> y<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">char33:</span>           <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">pair?</span> alst<span class="token punctuation">)</span><span class="token number">34</span>:               <span class="token punctuation">(</span><span class="token keyword">begin</span><span class="token number">35</span>:             <span class="token punctuation">(</span><span class="token function">write</span> <span class="token punctuation">(</span><span class="token builtin">car</span> alst<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">36</span>:             <span class="token punctuation">(</span>newline<span class="token punctuation">)</span><span class="token number">37</span>:             <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> alst<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">38</span>:             <span class="token punctuation">(</span><span class="token function">display</span> <span class="token string">"))"</span><span class="token punctuation">)</span><span class="token number">39</span>:             <span class="token punctuation">(</span>newline<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(skip-char? c)</strong></p><p>如果<code>c</code>不是图像字符或者<code>c</code>是 #:, #;, #&#39;, or #&quot;，就返回#t。读取文本时，这些字符会被跳过。</p><p><strong>(ss-make-alist c alist)</strong></p><p>有两个参数；字符的频率的关联表（<code>alist</code>）和字符（<code>c</code>）。如果<code>c</code>在<code>alist</code>中，在序对的cdr部分增加一。如果不在，返回 (cons (cons c 1) alist)。这个函数使用了set-cdr!。</p><p><strong>(ss-make-dat filename)</strong></p><p>从名为<code>filename</code>的文件中读取字符，并使用跟随字符的频率的关联表来关联这些读出的字符。结果以关联表形式存储在文件<a href="http://www.shido.info/lisp/stat-spell.dat">stat-spell.dat</a>。在34和35行，它在哈希表中更新了频率的关联表。存储在stat-spell.dat的最终数据是一个关联表的关联表。例如：</p><p>(#\v (#\y . 1) (#\a . 3) (#\o . 7) (#\e . 51) (#\i . 15))</p><p>表示 #\y, #\a, #\o, #\e, 和 #\i 跟随 #\v 之后出现的次数分别是1, 3, 7, 51, 和15次。</p><h3 id="make-pw-scm"><a href="#make-pw-scm" class="headerlink" title="make-pw.scm"></a>make-pw.scm</h3><p>基于 stat-spell.dat 创建十个密码。过程如下：</p><ol><li>基于频率数据创建由9到13个随机字符组成字符串表。字符 #\Space 被添加在表结尾。</li><li>添加一个00到99之间的随机数在随机选取的字符串表的结尾。</li><li>随机地将 #\Space 转换为 #-, #_, #/, #\Space, #., 或者 #,。</li><li>随机地将30%的字母字符变为大写。</li></ol><pre class="line-numbers language-scheme"><code class="language-scheme">01:     <span class="token comment" spellcheck="true">;;; make password from the alist of probable spelling</span><span class="token number">02</span>:     <span class="token number">03</span>:     <span class="token punctuation">(</span><span class="token function">load</span> <span class="token string">"stat-spell.dat"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">; *stat-spell* (alist for following characters) is in.</span><span class="token number">04</span>:     <span class="token number">05</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">alist->hash</span> al mode<span class="token punctuation">)</span><span class="token number">06</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">h</span> <span class="token punctuation">(</span><span class="token function">case</span> mode<span class="token number">07</span>:                  <span class="token punctuation">(</span><span class="token punctuation">(</span>eq<span class="token punctuation">)</span> <span class="token punctuation">(</span>make-eq-hash-table<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">08</span>:                  <span class="token punctuation">(</span><span class="token punctuation">(</span>eqv<span class="token punctuation">)</span> <span class="token punctuation">(</span>make-eqv-hash-table<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">09</span>:                  <span class="token punctuation">(</span><span class="token punctuation">(</span>equal<span class="token punctuation">)</span> <span class="token punctuation">(</span>make-equal-hash-table<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">10</span>:                  <span class="token punctuation">(</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span> <span class="token punctuation">(</span>make-string-hash-table<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">11</span>:         <span class="token punctuation">(</span><span class="token function">for-each</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token number">12</span>:                     <span class="token punctuation">(</span><span class="token function">hash-table/put!</span> h <span class="token punctuation">(</span><span class="token builtin">car</span> p<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">13</span>:                   al<span class="token punctuation">)</span><span class="token number">14</span>:         h<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">15</span>:     <span class="token number">16</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> *stat-spell-hash* <span class="token punctuation">(</span><span class="token function">alist->hash</span> *stat-spell* <span class="token string">'eqv))</span><span class="token number">17</span>:     <span class="token number">18</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">pw-random-select</span> vec<span class="token punctuation">)</span><span class="token number">19</span>:       <span class="token punctuation">(</span><span class="token function">vector-ref</span> vec <span class="token punctuation">(</span><span class="token function">random</span> <span class="token punctuation">(</span><span class="token function">vector-length</span> vec<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">20</span>:     <span class="token number">21</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>random00<span class="token punctuation">)</span><span class="token number">22</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">acc</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">23</span>:         <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> i <span class="token number">2</span><span class="token punctuation">)</span><span class="token number">24</span>:             <span class="token punctuation">(</span><span class="token builtin">list</span>->string acc<span class="token punctuation">)</span><span class="token number">25</span>:           <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token function">1+</span> i<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token punctuation">(</span><span class="token function">pw-random-select</span> <span class="token string">'#</span><span class="token punctuation">(</span><span class="token function">#\0</span> #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9<span class="token punctuation">)</span><span class="token punctuation">)</span> acc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">26</span>:     <span class="token number">27</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">occasional-upcase</span> c<span class="token punctuation">)</span><span class="token number">28</span>:       <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token function">random</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token number">29</span>:           <span class="token punctuation">(</span><span class="token function">char-upcase</span> c<span class="token punctuation">)</span><span class="token number">30</span>:         c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">31</span>:     <span class="token number">32</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">pw-enhance</span> ls<span class="token punctuation">)</span><span class="token number">33</span>:       <span class="token punctuation">(</span><span class="token builtin">list</span>->string<span class="token number">34</span>:        <span class="token punctuation">(</span><span class="token function">map</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token number">35</span>:               <span class="token punctuation">(</span><span class="token keyword">cond</span><span class="token number">36</span>:                <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">char=?</span> c #\Space<span class="token punctuation">)</span><span class="token number">37</span>:                 <span class="token punctuation">(</span><span class="token function">pw-random-select</span>  <span class="token string">'#</span><span class="token punctuation">(</span><span class="token function">#\-</span> #\_ #\/  #\Space  #\. #\, #\@ #\? #\<span class="token punctuation">(</span><span class="token function"></span> #\<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">38</span>:                <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">char-alphabetic?</span> c<span class="token punctuation">)</span><span class="token number">39</span>:                 <span class="token punctuation">(</span><span class="token function">occasional-upcase</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">40</span>:                <span class="token punctuation">(</span><span class="token keyword">else</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">41</span>:             <span class="token punctuation">(</span><span class="token builtin">cdr</span> <span class="token punctuation">(</span><span class="token function">reverse!</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">42</span>:         <span class="token number">43</span>:     <span class="token number">44</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">random-following</span> alist<span class="token punctuation">)</span><span class="token number">45</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">n</span> <span class="token punctuation">(</span><span class="token function">random</span> <span class="token punctuation">(</span><span class="token builtin">apply</span> + <span class="token punctuation">(</span><span class="token function">map</span> cdr alist<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">46</span>:         <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">j</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">alist</span> alist<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">47</span>:           <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">pair?</span> alist<span class="token punctuation">)</span><span class="token number">48</span>:           <span class="token punctuation">(</span><span class="token keyword">let*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">pair</span> <span class="token punctuation">(</span><span class="token builtin">car</span> alist<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">49</span>:              <span class="token punctuation">(</span><span class="token function">k</span> <span class="token punctuation">(</span><span class="token operator">+</span> j <span class="token punctuation">(</span><span class="token builtin">cdr</span> pair<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">50</span>:             <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">></span> k n<span class="token punctuation">)</span><span class="token number">51</span>:             <span class="token punctuation">(</span><span class="token builtin">car</span> pair<span class="token punctuation">)</span><span class="token number">52</span>:             <span class="token punctuation">(</span><span class="token function">loop</span> k <span class="token punctuation">(</span><span class="token builtin">cdr</span> alist<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">53</span>:     <span class="token number">54</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">make-pw</span> h n<span class="token punctuation">)</span><span class="token number">55</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">c</span> #\Space<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">acc</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">56</span>:         <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> i n<span class="token punctuation">)</span><span class="token number">57</span>:             <span class="token punctuation">(</span><span class="token function">string-append</span><span class="token number">58</span>:              <span class="token punctuation">(</span><span class="token function">pw-enhance</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> #\Space <span class="token punctuation">(</span><span class="token builtin">cons</span> c acc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">59</span>:              <span class="token punctuation">(</span>random00<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">60</span>:           <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token function">1+</span> i<span class="token punctuation">)</span><span class="token number">61</span>:             <span class="token punctuation">(</span><span class="token function">random-following</span> <span class="token punctuation">(</span><span class="token function">hash-table/get</span> h c <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">#\Space</span> . <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">62</span>:             <span class="token punctuation">(</span><span class="token builtin">cons</span> c acc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">63</span>:         <span class="token number">64</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>pw-candidates<span class="token punctuation">)</span><span class="token number">65</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">66</span>:         <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> i <span class="token number">10</span><span class="token punctuation">)</span><span class="token number">67</span>:             <span class="token punctuation">(</span><span class="token keyword">begin</span><span class="token number">68</span>:              <span class="token punctuation">(</span><span class="token function">display</span> i<span class="token punctuation">)</span><span class="token number">69</span>:              <span class="token punctuation">(</span><span class="token function">display</span> <span class="token string">": "</span><span class="token punctuation">)</span><span class="token number">70</span>:              <span class="token punctuation">(</span><span class="token function">write</span> <span class="token punctuation">(</span><span class="token function">make-pw</span> *stat-spell-hash* <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">9</span> <span class="token punctuation">(</span><span class="token function">random</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">71</span>:              <span class="token punctuation">(</span>newline<span class="token punctuation">)</span><span class="token number">72</span>:              <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token function">1+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">73</span>:           <span class="token string">'done)))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="向量和结构体"><a href="#向量和结构体" class="headerlink" title="向量和结构体"></a>向量和结构体</h2><h3 id="简介-8"><a href="#简介-8" class="headerlink" title="简介"></a>简介</h3><p>本章中，我将讲解向量和结构体。</p><p>向量是一组通过整数索引的数据。与C语言中的数组不同，一个向量可以储存不同类型的数据。与表相比，向量更加紧凑且存取时间更短。但从另外一方面来说，向量是通过副作用来操作的，这样会造成负担。</p><p>Scheme中的结构体与C语言中的结构体类似。但Scheme中的结构体比C语言中的更容易使用，因为Scheme为结构体自动创建了读取函数和写入函数，这受益于Lisp/Scheme中的宏。</p><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><h4 id="字面值"><a href="#字面值" class="headerlink" title="字面值"></a>字面值</h4><p>向量通过闭合的<code>#(</code>和<code>)</code>表示，例如<code>#(1 2 3)</code>。作为字面值（literals）时，它们应该被引用（be quoted），例如：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token string">'#</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span>             <span class="token comment" spellcheck="true">; 整数向量</span><span class="token string">'#</span><span class="token punctuation">(</span><span class="token function">a</span> <span class="token number">0</span> #\a<span class="token punctuation">)</span>           <span class="token comment" spellcheck="true">; 由符号、整数和字符构成的向量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="向量函数"><a href="#向量函数" class="headerlink" title="向量函数"></a>向量函数</h4><p>下面的函数都是R5RS规定的函数：</p><p><strong>(vector? obj)</strong></p><p>如果obj是一个向量则返回#t。</p><p><strong>(make-vector k)</strong></p><p><strong>(make-vector k fill)</strong></p><p>返回有<code>k</code>个元素的向量。如果指定了第二个参数(<code>fill</code>)，那么所有的元素都会被初始化为<code>fill</code>。</p><p><strong>(vector obj …)</strong></p><p>返回由参数列表构成的向量。</p><p><strong>(vector-length vector)</strong></p><p>返回向量<code>vector</code>的长度。</p><p><strong>(vector-ref vector k)</strong></p><p>返回向量<code>vector</code>的索引为<code>k</code>的元素。（译注：和C语言类似，向量从0开始索引。）</p><p><strong>(vector-set! vector k obj)</strong></p><p>将向量<code>vector</code>的索引为<code>k</code>的元素修改为<code>obj</code>。</p><p><strong>(vector-&gt;list vector)</strong></p><p>将<code>vector</code>转换为表。</p><p><strong>(list-&gt;vector list)</strong></p><p>将<code>list</code>转换为向量。</p><p><strong>(vector-fill! vector fill)</strong></p><p>将向量<code>vector</code>的所有元素设置为<code>fill</code>。</p><p>例：一个对向量中元素求和的函数。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">vector-add</span> v1 v2<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">lenv1</span> <span class="token punctuation">(</span><span class="token function">vector-length</span> v1<span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token punctuation">(</span><span class="token function">lenv2</span> <span class="token punctuation">(</span><span class="token function">vector-length</span> v2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> lenv1 lenv2<span class="token punctuation">)</span>          <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">v</span> <span class="token punctuation">(</span><span class="token function">make-vector</span> lenv1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>              <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> i lenv1<span class="token punctuation">)</span>                    v                    <span class="token punctuation">(</span><span class="token keyword">begin</span>                      <span class="token punctuation">(</span><span class="token function">vector-set!</span> v i <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token punctuation">(</span><span class="token function">vector-ref</span> v1 i<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">vector-ref</span> v2 i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                      <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">1</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">(</span><span class="token function">error</span> <span class="token string">"different dimensions."</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>练习1</p><p>编写一个用于计算两向量内积的函数。</p></blockquote><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="大体功能"><a href="#大体功能" class="headerlink" title="大体功能"></a>大体功能</h3><p>虽然R5RS中没有定义结构体，但是在很多Scheme实现中，都实现了类似于Common Lisp中的结构体。</p><p>这些结构体本质上来说都是向量。每一个槽（slot）都通过使用一个宏来命名，我将会在下一章（十五章）中讲解这个问题。结构体通过不同的属性清楚地表示数据。定义结构体的宏自动为结构体创建<strong>取值器（accessor）</strong>和<strong>赋值器（setter）</strong>。你可以通过“程序”来写程序，这被认为是Lisp/Scheme最好之处之一。通过这个功能，你可以很快写出漂亮的程序。</p><h3 id="MIT-Scheme中的结构体"><a href="#MIT-Scheme中的结构体" class="headerlink" title="MIT-Scheme中的结构体"></a>MIT-Scheme中的结构体</h3><p>在MIT-Scheme中，结构体通过函数<code>define-structure</code>来定义。为了使你更加容易理解，我会用一个实例来讲解。请考虑书籍。书籍都有下列属性：</p><ul><li>标题</li><li>作者</li><li>出版商</li><li>出版年份</li><li>ISBN号</li></ul><p>因此结构体book就可以像下面这样定义：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span>-structure book title authors publisher year isbn<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面演示了如何注册<a href="http://www.oreilly.com/catalog/cathbazpaper/">“大教堂与市集（The Cathedral and Bazaar）”</a>。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> bazaar   <span class="token punctuation">(</span><span class="token function">make-book</span>    <span class="token string">"The Cathedral and the Bazaar"</span>   <span class="token string">"Eric S. Raymond"</span>   <span class="token string">"O'Reilly"</span>   <span class="token number">1999</span>   <span class="token number">0596001088</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然而，这样做多少有点不便，因为属性与值的关联并不清楚。参量<code>keyword-constructor</code>可以用于解决这个问题。下面的代码就是使用这个参量的重写版，这个版本中，属性与值的关联就非常清楚了。此外，制定这个参量后，参数的顺序就不重要了。参量<code>copier</code>可用于为结构体创建一个拷贝（copier）函数。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span>-structure <span class="token punctuation">(</span><span class="token function">book</span> keyword-constructor copier<span class="token punctuation">)</span>   title authors publisher year isbn<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> bazaar   <span class="token punctuation">(</span><span class="token function">make-book</span>    <span class="token string">'title</span> <span class="token string">"The Cathedral and the Bazaar"</span>   <span class="token string">'authors</span> <span class="token string">"Eric S. Raymond"</span>   <span class="token string">'publisher</span> <span class="token string">"O'Reilly"</span>   <span class="token string">'year</span> <span class="token number">1999</span>       <span class="token string">'isbn</span> <span class="token number">0596001088</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>一个名字形如<code>[the name of structure]?</code>的函数用于检查某对象是否为特定结构体。例如，可使用函数<code>book?</code>来检查<code>bazaar</code>是否为<code>book</code>结构体的一个实例。</li></ul><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">book?</span> bazaar<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>一个名字形如<code>copy-[structure name]</code>的函数用于拷贝结构体。例如，下面的代码演示了将<code>bazaar</code>拷贝到<code>cathedral</code>。</li></ul><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> cathedral <span class="token punctuation">(</span><span class="token function">copy-book</span> bazaar<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>一个名字形如<code>[structure name]-[attribute name]</code>的函数用于读取结构体某属性的值。例如，下面的代码演示了如何读取<code>bazaar</code>的<code>title</code>属性。</li></ul><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">book-title</span> bazaar<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 18: "The Cathedral and the Bazaar"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>一个名字形如<code>set-[结构体名称]-[属性名称]!</code>用于将某属性设定为特定值。下面的代码演示了如何将<code>bazaar</code>的<code>year</code>字段更新到2001（《大教堂与市集》2001年再版）。</li></ul><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">set-book-year!</span> bazaar <span class="token number">2001</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Unspecified return value</span><span class="token punctuation">(</span><span class="token function">book-year</span> bazaar<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 2001</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请参阅<a href="http://deathking.github.io/yast-cn/contents/www.gnu.org/software/mit-scheme/documentation/scheme_3.html#SEC41">MIT/GNU Scheme Reference: 2.10 Structure Definitions</a>以获得关于结构体的跟多信息。</p><h3 id="The-Mastermind-—-一个简单的密码破解游戏"><a href="#The-Mastermind-—-一个简单的密码破解游戏" class="headerlink" title="The Mastermind — 一个简单的密码破解游戏"></a>The Mastermind — 一个简单的密码破解游戏</h3><p>作为向量的示例，我会演示一个简单的密码破解游戏。这是一个猜对手密码的游戏。密码是由0到9中四个不同的数组成的四位数。对手要通过使用<code>bulls</code>和<code>cows</code>的数量告知猜谜者猜测的准确程度。</p><ol><li>bull的数量（Nbull）是指值和位置都正确的数字的数量。</li><li>cow的数量（Ncow）是指值正确但位置错误的数字的数量。</li></ol><p>例如，密码是5601，猜测是1685，那么<code>bull</code>和<code>cow</code>和数分别是1和2。</p><p>计算机和用户相互猜测对方的密码。更少尝试次数的选手为胜利者。如果用户和电脑在相同的尝试次数中破解了密码就是平局。</p><h3 id="表示四个数字"><a href="#表示四个数字" class="headerlink" title="表示四个数字"></a>表示四个数字</h3><p>四位数字可以通过向量和计算<code>bull</code>以及<code>cow</code>的数量高效地表示。这种表达方法需要构成密码的数字都不相同。</p><p>创建长度为10的向量，每个索引（<code>k</code>）的值被设为<code>k</code>在密码中的数位。四个数位从低到高被计为1，2，3和4。如果数字没有出现，索引的值为0。例如，5601和1685可以表示如下：</p><pre><code>5601 → #(2 1 0 0 0 4 3 0 0 0)1685 → #(0 4 0 0 0 1 3 0 2 0)</code></pre><p>5601这个例子中，数字0，1，5，和6分别出现在第2，第1，第4和第3位，那么在这个密码的向量表达式里索引0，1，5，6的值分别2是2，1，4和3，其他索引位都是0。</p><p>这种表达可以快速比较两个数字。如果两个向量的相同索引位的值都是正数情况下，如果值相等，就计为<code>bull</code>，如果值不相等，就计为<code>cow</code>。5601和1685这个例子的情况下，索引位6的值都为3，索引位1和索引位5的值都是正数，<code>bull</code>和<code>cow</code>的值为1和2。</p><h3 id="程序的设计"><a href="#程序的设计" class="headerlink" title="程序的设计"></a>程序的设计</h3><p>程序的设计如下：</p><ol><li>程序生成一个表，该表包含了所有不同四位数的向量表示。</li><li>程序从表中随机选取一个数字。</li><li>重洗步骤（1）产生的表。</li><li>程序首次猜用户的密码，用户给出bull和cow的数量。然后用户猜程序的密码，程序给出Nnull和Ncow。</li><li>重复步骤（3）直到电脑或者程序的bull数量变为4为止。如果在同一次双方的数量都变为4，就是平局。</li></ol><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><p>[代码1]展示了源代码。代码很长但并不十分复杂。游戏由一个递归函数<code>mastermind-rec</code>执行。</p><p>[代码1]</p><pre class="line-numbers language-scheme"><code class="language-scheme"> <span class="token number">01</span>:     <span class="token comment" spellcheck="true">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span> <span class="token number">02</span>:     <span class="token comment" spellcheck="true">;;;</span> <span class="token number">03</span>:     <span class="token comment" spellcheck="true">;;; mastermind.scm</span> <span class="token number">04</span>:     <span class="token comment" spellcheck="true">;;; by T.Shido</span> <span class="token number">05</span>:     <span class="token comment" spellcheck="true">;;;</span> <span class="token number">06</span>:     <span class="token comment" spellcheck="true">;;; User and computer try to locate the four-digit integer set by the opponents each other.</span> <span class="token number">07</span>:     <span class="token comment" spellcheck="true">;;; One who locates the integer with fewer question is the winner.</span> <span class="token number">08</span>:     <span class="token comment" spellcheck="true">;;; The four-digit integer contains four of numerals 0--9, like 0123, 3749 etc.</span> <span class="token number">09</span>:     <span class="token comment" spellcheck="true">;;; The opponents should tell the guesser</span> <span class="token number">10</span>:     <span class="token comment" spellcheck="true">;;; (1) number of numerals that are shared by the guessed and set numbers</span> <span class="token number">11</span>:     <span class="token comment" spellcheck="true">;;; at wrong position (cows)</span> <span class="token number">12</span>:     <span class="token comment" spellcheck="true">;;; and (2) number of numerals at collect position (bulls).</span> <span class="token number">13</span>:     <span class="token comment" spellcheck="true">;;; </span> <span class="token number">14</span>:     <span class="token comment" spellcheck="true">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span> <span class="token number">15</span>:     <span class="token comment" spellcheck="true">;;;</span> <span class="token number">16</span>:     <span class="token comment" spellcheck="true">;;; The four-digit integers are represented by 10-cell vectors in the program</span> <span class="token number">17</span>:     <span class="token comment" spellcheck="true">;;; The value of n-th cell is the number of column that n appears in the integer.</span> <span class="token number">18</span>:     <span class="token comment" spellcheck="true">;;; in n is not appears the value is 0.</span> <span class="token number">19</span>:     <span class="token comment" spellcheck="true">;;; for example, 1234 is represented as #(0 4 3 2 1 0 0 0 0 0) and</span> <span class="token number">20</span>:     <span class="token comment" spellcheck="true">;;; 3916 as #(0 2 0 4 0 0 1 0 0 3).</span> <span class="token number">21</span>:     <span class="token comment" spellcheck="true">;;; With this inner representation, the score of the guess can be calculated faster.</span> <span class="token number">22</span>:     <span class="token comment" spellcheck="true">;;;</span> <span class="token number">23</span>:     <span class="token comment" spellcheck="true">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span> <span class="token number">24</span>:      <span class="token number">25</span>:      <span class="token number">26</span>:     <span class="token comment" spellcheck="true">;;;</span> <span class="token number">27</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">1-</span> x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">-</span> x <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">28</span>:      <span class="token number">29</span>:     <span class="token comment" spellcheck="true">;;;</span> <span class="token number">30</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">char2int</span> c<span class="token punctuation">)</span> <span class="token number">31</span>:       <span class="token punctuation">(</span><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token function">char->integer</span> c<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">char->integer</span> #\0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">32</span>:      <span class="token number">33</span>:     <span class="token comment" spellcheck="true">;;; converting a list of 4 numbers to the vector notation</span> <span class="token number">34</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">ls2nvec</span> ls<span class="token punctuation">)</span> <span class="token number">35</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">vec</span> <span class="token punctuation">(</span><span class="token function">make-vector</span> <span class="token number">10</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">36</span>:         <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token punctuation">(</span><span class="token function">length</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">ls</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">37</span>:           <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">></span> i <span class="token number">0</span><span class="token punctuation">)</span> <span class="token number">38</span>:           <span class="token punctuation">(</span><span class="token keyword">begin</span> <span class="token number">39</span>:                <span class="token punctuation">(</span><span class="token function">vector-set!</span> vec <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span> i<span class="token punctuation">)</span> <span class="token number">40</span>:                <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token function">1-</span> i<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">41</span>:             vec<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">42</span>:      <span class="token number">43</span>:     <span class="token comment" spellcheck="true">;;; converting the vector notation to string</span> <span class="token number">44</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">nvec2int</span> vec<span class="token punctuation">)</span> <span class="token number">45</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">n</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">46</span>:         <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> i <span class="token number">10</span><span class="token punctuation">)</span> <span class="token number">47</span>:             n <span class="token number">48</span>:         <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">j</span> <span class="token punctuation">(</span><span class="token function">vector-ref</span> vec i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">49</span>:           <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token function">1+</span> i<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">+</span> n <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">></span> j <span class="token number">0</span><span class="token punctuation">)</span> <span class="token number">50</span>:                                     <span class="token punctuation">(</span><span class="token operator">*</span> i <span class="token punctuation">(</span><span class="token function">expt</span> <span class="token number">10</span> <span class="token punctuation">(</span><span class="token function">1-</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">51</span>:                                   <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">52</span>:      <span class="token number">53</span>:     <span class="token comment" spellcheck="true">;;;</span> <span class="token number">54</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">int2str</span> i<span class="token punctuation">)</span> <span class="token number">55</span>:       <span class="token punctuation">(</span><span class="token function">string-append</span> <span class="token number">56</span>:        <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> i <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token string">"0"</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token number">57</span>:        <span class="token punctuation">(</span><span class="token function">number->string</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">58</span>:      <span class="token number">59</span>:     <span class="token comment" spellcheck="true">;;; reading integer from stdin</span> <span class="token number">60</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">read-integer</span> str<span class="token punctuation">)</span> <span class="token number">61</span>:       <span class="token punctuation">(</span><span class="token function">string->number</span> <span class="token punctuation">(</span><span class="token function">read-from-stdin</span> str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">62</span>:      <span class="token number">63</span>:     <span class="token comment" spellcheck="true">;;;</span> <span class="token number">64</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">read-from-stdin</span> str<span class="token punctuation">)</span> <span class="token number">65</span>:       <span class="token punctuation">(</span><span class="token function">display</span> str<span class="token punctuation">)</span> <span class="token number">66</span>:       <span class="token punctuation">(</span>newline<span class="token punctuation">)</span> <span class="token number">67</span>:       <span class="token punctuation">(</span>read-line<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">68</span>:      <span class="token number">69</span>:     <span class="token comment" spellcheck="true">;;;</span> <span class="token number">70</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">write-to-stdout</span> . ls<span class="token punctuation">)</span> <span class="token number">71</span>:       <span class="token punctuation">(</span><span class="token function">for-each</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">display</span> obj<span class="token punctuation">)</span><span class="token punctuation">)</span> ls<span class="token punctuation">)</span> <span class="token number">72</span>:       <span class="token punctuation">(</span>newline<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">73</span>:      <span class="token number">74</span>:     <span class="token comment" spellcheck="true">;;; convert numeral string to the vector representation.</span> <span class="token number">75</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">str2nvec</span> str<span class="token punctuation">)</span> <span class="token number">76</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">vec</span> <span class="token punctuation">(</span><span class="token function">make-vector</span> <span class="token number">10</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">77</span>:         <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token punctuation">(</span><span class="token function">string-length</span> str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">ls</span> <span class="token punctuation">(</span><span class="token function">string->list</span> str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">78</span>:           <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">pair?</span> ls<span class="token punctuation">)</span> <span class="token number">79</span>:           <span class="token punctuation">(</span><span class="token keyword">begin</span> <span class="token number">80</span>:                <span class="token punctuation">(</span><span class="token function">vector-set!</span> vec <span class="token punctuation">(</span><span class="token function">char2int</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span> i<span class="token punctuation">)</span> <span class="token number">81</span>:                <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token function">1-</span> i<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">82</span>:             vec<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">83</span>:      <span class="token number">84</span>:     <span class="token comment" spellcheck="true">;;; calculating the score of guess</span> <span class="token number">85</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">scoring</span> vec0 vec1<span class="token punctuation">)</span> <span class="token number">86</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">n</span> <span class="token punctuation">(</span><span class="token function">vector-length</span> vec0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">87</span>:         <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">score</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">88</span>:           <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> i n<span class="token punctuation">)</span> <span class="token number">89</span>:           <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">d0</span> <span class="token punctuation">(</span><span class="token function">vector-ref</span> vec0 i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">90</span>:                    <span class="token punctuation">(</span><span class="token function">d1</span> <span class="token punctuation">(</span><span class="token function">vector-ref</span> vec1 i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">91</span>:                 <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token function">1+</span> i<span class="token punctuation">)</span> <span class="token number">92</span>:               <span class="token punctuation">(</span><span class="token operator">+</span> score <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">and</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> <span class="token number">0</span> d0<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> <span class="token number">0</span> d1<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">93</span>:                                    <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> d0 d1<span class="token punctuation">)</span> <span class="token number">5</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">94</span>:                                    <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">95</span>:             score<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">96</span>:      <span class="token number">97</span>:     <span class="token comment" spellcheck="true">;;; show bulls and cows calculated from the score of user's guess</span> <span class="token number">98</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">show-user-score</span> score<span class="token punctuation">)</span> <span class="token number">99</span>:       <span class="token punctuation">(</span><span class="token function">write-to-stdout</span> <span class="token string">"Number of bulls and cows in your guess:"</span> <span class="token punctuation">)</span><span class="token number">100</span>:       <span class="token punctuation">(</span><span class="token function">write-to-stdout</span> <span class="token string">"bulls: "</span> <span class="token punctuation">(</span><span class="token function">quotient</span> score <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">101</span>:       <span class="token punctuation">(</span><span class="token function">write-to-stdout</span> <span class="token string">"cows: "</span> <span class="token punctuation">(</span><span class="token function">modulo</span> score <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">102</span>:       <span class="token punctuation">(</span>newline<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">103</span>:     <span class="token number">104</span>:     <span class="token comment" spellcheck="true">;;; calculating the score of computer's guess from bulls and cows</span><span class="token number">105</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">read-my-score</span> gu0<span class="token punctuation">)</span><span class="token number">106</span>:       <span class="token punctuation">(</span><span class="token function">write-to-stdout</span> <span class="token string">"My guess is: "</span> <span class="token punctuation">(</span><span class="token function">int2str</span> <span class="token punctuation">(</span><span class="token function">nvec2int</span> gu0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">107</span>:       <span class="token punctuation">(</span><span class="token function">write-to-stdout</span> <span class="token string">"Give number of bulls and cows in my guess."</span> <span class="token punctuation">)</span><span class="token number">108</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">na5</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">5</span> <span class="token punctuation">(</span><span class="token function">read-integer</span> <span class="token string">"bulls: "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">109</span>:         <span class="token punctuation">(</span><span class="token operator">+</span> na5 <span class="token punctuation">(</span><span class="token function">read-integer</span> <span class="token string">"cows: "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">; the score is calculated by (5 * bull + cow)</span><span class="token number">110</span>:     <span class="token number">111</span>:     <span class="token comment" spellcheck="true">;;; reading the user guess</span><span class="token number">112</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>read-user-guess<span class="token punctuation">)</span><span class="token number">113</span>:       <span class="token punctuation">(</span>newline<span class="token punctuation">)</span><span class="token number">114</span>:       <span class="token punctuation">(</span><span class="token function">str2nvec</span> <span class="token punctuation">(</span><span class="token function">read-from-stdin</span> <span class="token string">"Give your guess."</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">115</span>:     <span class="token number">116</span>:     <span class="token comment" spellcheck="true">;;; shuffling the list of four-digit numbers</span><span class="token number">117</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">shuffle-numbers</span> ls0<span class="token punctuation">)</span><span class="token number">118</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">vec</span> <span class="token punctuation">(</span><span class="token builtin">list</span>->vector ls0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">119</span>:         <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">n</span> <span class="token punctuation">(</span><span class="token function">vector-length</span> vec<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">ls1</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">120</span>:           <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> n <span class="token number">0</span><span class="token punctuation">)</span><span class="token number">121</span>:               ls1<span class="token number">122</span>:           <span class="token punctuation">(</span><span class="token keyword">let*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">r</span> <span class="token punctuation">(</span><span class="token function">random</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">123</span>:              <span class="token punctuation">(</span><span class="token function">v</span> <span class="token punctuation">(</span><span class="token function">vector-ref</span> vec r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">124</span>:             <span class="token punctuation">(</span><span class="token function">vector-set!</span> vec r <span class="token punctuation">(</span><span class="token function">vector-ref</span> vec <span class="token punctuation">(</span><span class="token function">1-</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">125</span>:             <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token function">1-</span> n<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> v ls1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">126</span>:     <span class="token number">127</span>:     <span class="token comment" spellcheck="true">;;; making a list of four-digit numbers in which numeral 0--9 appear once</span><span class="token number">128</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>make-numbers<span class="token punctuation">)</span><span class="token number">129</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">ls1</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">130</span>:         <span class="token punctuation">(</span><span class="token keyword">letrec</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">rec</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token function">i</span> num ls<span class="token punctuation">)</span><span class="token number">131</span>:                 <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> i <span class="token number">4</span><span class="token punctuation">)</span><span class="token number">132</span>:                 <span class="token punctuation">(</span><span class="token keyword">set!</span> ls1 <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token punctuation">(</span><span class="token function">ls2nvec</span> ls<span class="token punctuation">)</span> ls1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">133</span>:                 <span class="token punctuation">(</span><span class="token function">for-each</span> <span class="token number">134</span>:                  <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token number">135</span>:                    <span class="token punctuation">(</span><span class="token function">rec</span> <span class="token punctuation">(</span><span class="token function">1+</span> i<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">delv</span> n num<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> n ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">136</span>:                  num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">137</span>:           <span class="token punctuation">(</span><span class="token function">rec</span> <span class="token number">0</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">138</span>:         ls1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">139</span>:     <span class="token number">140</span>:     <span class="token comment" spellcheck="true">;;;</span><span class="token number">141</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">game-over</span> sc0 sc1<span class="token punctuation">)</span><span class="token number">142</span>:       <span class="token punctuation">(</span><span class="token function">write-to-stdout</span><span class="token number">143</span>:        <span class="token punctuation">(</span><span class="token keyword">cond</span><span class="token number">144</span>:         <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">=</span> sc0 sc1<span class="token punctuation">)</span> <span class="token string">"Draw"</span><span class="token punctuation">)</span><span class="token number">145</span>:         <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">></span> sc0 sc1<span class="token punctuation">)</span> <span class="token string">"I won."</span><span class="token punctuation">)</span><span class="token number">146</span>:         <span class="token punctuation">(</span><span class="token keyword">else</span> <span class="token string">"You won."</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">147</span>:       <span class="token string">'game-over)</span><span class="token number">148</span>:     <span class="token number">149</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">scoring-user-guess</span> an0 gu1<span class="token punctuation">)</span><span class="token number">150</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">sc1</span> <span class="token punctuation">(</span><span class="token function">scoring</span> an0 gu1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">151</span>:         <span class="token punctuation">(</span><span class="token function">show-user-score</span> sc1<span class="token punctuation">)</span><span class="token number">152</span>:         sc1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">153</span>:     <span class="token number">154</span>:     <span class="token comment" spellcheck="true">;;; Practical main function. tail recursive.</span><span class="token number">155</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">mastermind-rec</span> an0 candidates<span class="token punctuation">)</span><span class="token number">156</span>:       <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">null?</span> candidates<span class="token punctuation">)</span><span class="token number">157</span>:           <span class="token punctuation">(</span><span class="token function">error</span> <span class="token string">"Error. You gave wrong score for my guess, probably."</span><span class="token punctuation">)</span><span class="token number">158</span>:           <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">gu0</span> <span class="token punctuation">(</span><span class="token builtin">car</span> candidates<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">159</span>:         <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">sc1</span> <span class="token punctuation">(</span><span class="token function">scoring-user-guess</span> an0 <span class="token punctuation">(</span>read-user-guess<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">160</span>:               <span class="token punctuation">(</span><span class="token function">sc0</span> <span class="token punctuation">(</span><span class="token function">read-my-score</span> gu0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">161</span>:           <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">or</span> <span class="token punctuation">(</span><span class="token operator">=</span> sc0 <span class="token number">20</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">=</span> sc1 <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">162</span>:               <span class="token punctuation">(</span><span class="token function">game-over</span> sc0 sc1<span class="token punctuation">)</span><span class="token number">163</span>:               <span class="token punctuation">(</span><span class="token function">mastermind-rec</span> an0 <span class="token number">164</span>:                    <span class="token punctuation">(</span><span class="token function">keep-matching-items</span> <span class="token number">165</span>:                     <span class="token punctuation">(</span><span class="token builtin">cdr</span> candidates<span class="token punctuation">)</span><span class="token number">166</span>:                     <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">scoring</span> gu0 x<span class="token punctuation">)</span> sc0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">167</span>:     <span class="token number">168</span>:     <span class="token comment" spellcheck="true">;;; The main function called from the top-level</span><span class="token number">169</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>mastermind<span class="token punctuation">)</span><span class="token number">170</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">ls0</span> <span class="token punctuation">(</span>make-numbers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">171</span>:         <span class="token punctuation">(</span><span class="token function">mastermind-rec</span> <span class="token punctuation">(</span><span class="token builtin">list</span>-ref ls0 <span class="token punctuation">(</span><span class="token function">random</span> <span class="token punctuation">(</span><span class="token function">length</span> ls0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">shuffle-numbers</span> ls0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="left">行数</th><th align="left">函数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">27</td><td align="left"><code>(1- x)</code></td><td align="left"><code>x</code>减一</td></tr><tr><td align="left">30</td><td align="left"><code>(char2int c)</code></td><td align="left">将字符<code>c</code>(#\0 – #\9)转换为整数（0 – 9）。</td></tr><tr><td align="left">34</td><td align="left"><code>(ls2nvec ls)</code></td><td align="left">将四个数字的表（<code>ls</code>）转换为向量表达式。<code>&#39;(5 3 6 0)-&gt;#(1 0 0 3 0 4 2 0 0 0)</code></td></tr><tr><td align="left">44</td><td align="left"><code>(nvec2int vec)</code></td><td align="left">将向量表达式<code>vec</code>转换为普通整数。</td></tr><tr><td align="left">54</td><td align="left"><code>(int2str i)</code></td><td align="left">将一个四位数<code>i</code>转换为字符串。如果<code>i</code>小于1000，’0’被置于高位。</td></tr><tr><td align="left">64</td><td align="left"><code>(read-from-stdin str)</code></td><td align="left">将<code>str</code>显示于标准输出，并返回用户从标准输入输入的字符串。</td></tr><tr><td align="left">70</td><td align="left"><code>(write-to-stdout . ls)</code></td><td align="left">将<code>ls</code>的每个元素都输出到标准输出，并在行尾插入行结束符。</td></tr><tr><td align="left">75</td><td align="left"><code>(str2nvec str)</code></td><td align="left">将用户输入的表示四位数的字符串<code>str</code>转换为向量表达式。</td></tr><tr><td align="left">86</td><td align="left"><code>(scoring vec0 vec1)</code></td><td align="left">以（5*Nnull + Ncow）计算两个整数（向量表达式）<code>vec0</code>和<code>vec1</code>的相似程度。</td></tr><tr><td align="left">98</td><td align="left"><code>(show-user-score score)</code></td><td align="left">通过相似度<code>score</code>计算Nbull和Ncow，并将它们显示在标准输出。</td></tr><tr><td align="left">105</td><td align="left"><code>(read-my-score gu0)</code></td><td align="left">显示计算机的猜测（gu0），让用户输入Nnull和Ncow，返回相似度score。</td></tr><tr><td align="left">112</td><td align="left"><code>(read-user-guess)</code></td><td align="left">返回用户猜测的向量表达式。</td></tr><tr><td align="left">116</td><td align="left"><code>(shuffle-numbers ls0)</code></td><td align="left">随机排序<code>ls0</code>。由于有随机读取的需求，将<code>ls0</code>转换为向量，然后随机读取向量的元素，以创建一个重排过的表。</td></tr><tr><td align="left">128</td><td align="left"><code>(make-numbers)</code></td><td align="left">返回由所有不同四位数构成的表。</td></tr><tr><td align="left">141</td><td align="left"><code>(game-over sc0 sc1)</code></td><td align="left">通过比较计算机的得分（sc0）和用户的得分(sc1)确定胜利者。</td></tr><tr><td align="left">149</td><td align="left"><code>(scoring-user-guess an0 gu1)</code></td><td align="left">计算计算机的密码（an0）和用户的猜测（gu1）的相似度，使用show-uuser-score输出Nbull和Ncow。</td></tr><tr><td align="left">155</td><td align="left"><code>(mastermind-rec an0 candidates)</code></td><td align="left">实际的主程序，它有两个参数；计算机密码（an0）和 猜测的表（candidate）。它计算计算机的得分（sc0）和用户的得分（sc1），如果<code>sc0</code>或者<code>sc1</code>为20，调用 (game-over sc0 sc1)。如果没有值为20，它根据<code>sc0</code>过滤猜测的表（candidate），并继续游戏。</td></tr><tr><td align="left">169</td><td align="left"><code>(mastermind)</code></td><td align="left">在控制台调用该函数以开始游戏。</td></tr></tbody></table><h3 id="如何玩"><a href="#如何玩" class="headerlink" title="如何玩"></a>如何玩</h3><p>输入如下代码启动游戏。最好在玩之前编译（你需要编译一次）。即使程序很简单，也很难取胜。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">compile-file</span> <span class="token string">"mastermind.scm"</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">load</span> <span class="token string">"mastermind"</span><span class="token punctuation">)</span><span class="token punctuation">(</span>mastermind<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这一章，我通过玩<code>mastermind</code>游戏讲解了向量和结构体。附上<a href="http://www.shido.info/lisp/scheme_vec.zip"><code>mastermind</code>的源代码</a>。</p><p>我将在下一章讲自定义语法。自定义语法是Lisp/Scheme的一个优点。</p><h2 id="定义语法"><a href="#定义语法" class="headerlink" title="定义语法"></a>定义语法</h2><h3 id="简介-9"><a href="#简介-9" class="headerlink" title="简介"></a>简介</h3><p>本章中，我会讲解如何自定义语法。用户定义语法称作<strong>宏（Macro）</strong>。Lisp/Scheme中的宏比C语言中的宏更加强大。宏可以使你的程序优美而紧凑。</p><p><strong>宏是代码的变换</strong>。代码在被求值或编译前进行变换，程序会继续执行就像变换后的代码一开始就写好了一样。</p><p>你可以在Scheme中通过用符合R5RS规范的<code>syntax-rules</code>轻易地定义简单宏，相比之下，在Common Lisp中自定义语法就复杂多了。使用<code>syntax-rules</code>可以直接定义宏而不用担心<strong>变量捕获（Variable Capture）</strong>。另一方面，Scheme中定义那些无法用<code>syntax-rules</code>定义的复杂的宏就比Common Lisp要困难。</p><h3 id="简单宏的实例"><a href="#简单宏的实例" class="headerlink" title="简单宏的实例"></a>简单宏的实例</h3><p>我将以一个简单的宏作为例子。</p><p>[代码1]一个将变量赋值为<code>&#39;()</code>的宏。</p><p>[代码1]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> nil!  <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> x<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">set!</span> x <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>syntax-reuls</code>的第二个参数是变换前和变化后的表达式的序对所构成的表。<code>_</code>代表宏的名字。简言之，[代码1]表示表达式<code>(nil! x)</code>会变换为<code>(set! x &#39;())</code>.</p><p>这类程序不能通过函数来实现，这是因为由于闭包性，函数不能影响外部变量。让我们来用函数版本来实现[代码1]，并观察效果。</p><p>[代码’1]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">f-nil!</span> x<span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token keyword">set!</span> x <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> a <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: a</span><span class="token punctuation">(</span><span class="token function">f-nil!</span> a<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 1</span>a<span class="token comment" spellcheck="true">;Value: 1           ; the value of a dose not change</span><span class="token punctuation">(</span><span class="token function">nil!</span> a<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 1</span>a<span class="token comment" spellcheck="true">;Value: ()          ; a becomes '()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我会演示另外一个例子。我们编写宏<code>when</code>，其语义为：当谓词求值为真时，求值相应语句。</p><p>[代码2]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> when  <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> pred b1 ...<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">if</span> pred <span class="token punctuation">(</span><span class="token keyword">begin</span> b1 ...<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>[代码2]中的<code>...</code>代表了任意多个数的表达式（包括0个表达式）。[代码2]揭示了表达式<code>(when pred b1 ...)</code>变换为<code>(if pred (begin b1 ...))</code>。</p><p>由于这个宏是将表达式变换为<code>if</code>特殊形式，因此它不能使用函数来实现。下面的例子演示了如何使用<code>when</code>。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">when</span> <span class="token punctuation">(</span><span class="token operator">=</span> i <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token function">display</span> <span class="token string">"i == 0"</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span>newline<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>i == <span class="token number">0</span><span class="token comment" spellcheck="true">;Unspecified return value</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我会演示两个实际的宏：<code>while</code>和<code>for</code>（已在Scheme中实现）。只要谓词部分求值为真，<code>while</code>就会对语句体求值。而数字在指定的范围中，<code>for</code>就会对语句体求值。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> while  <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> pred b1 ...<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">when</span> pred b1 ... <span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> for  <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> <span class="token punctuation">(</span><span class="token function">i</span> from to<span class="token punctuation">)</span> b1 ...<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">let</span> loop<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> from<span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token function">when</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> i to<span class="token punctuation">)</span>      b1 ...      <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token function">1+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面演示了如何使用它们：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">while</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> i <span class="token number">10</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token function">display</span> i<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token function">display</span> #\Space<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">set!</span> i <span class="token punctuation">(</span><span class="token operator">+</span> i <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span> <span class="token comment" spellcheck="true">;Unspecified return value</span><span class="token punctuation">(</span><span class="token function">for</span> <span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">0</span> <span class="token number">10</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">display</span> i<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">display</span> #\Space<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span> <span class="token comment" spellcheck="true">;Unspecified return value</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="syntax-rule的更多细节"><a href="#syntax-rule的更多细节" class="headerlink" title="syntax-rule的更多细节"></a>syntax-rule的更多细节</h3><h4 id="多个定义模式"><a href="#多个定义模式" class="headerlink" title="多个定义模式"></a>多个定义模式</h4><p><code>syntax-rule</code>可以定义一系列模式。比如，一个让变量增加的宏，如果给定了变量名，那么宏<code>incf</code>使该变量增加1。可以通过编写如[代码4]这样的模式转换来实现宏<code>incf</code>。</p><p>[代码4]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> incf  <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">begin</span> <span class="token punctuation">(</span><span class="token keyword">set!</span> x <span class="token punctuation">(</span><span class="token operator">+</span> x <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> x i<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">begin</span> <span class="token punctuation">(</span><span class="token keyword">set!</span> x <span class="token punctuation">(</span><span class="token operator">+</span> x i<span class="token punctuation">)</span><span class="token punctuation">)</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">j</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">incf</span> i<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">incf</span> j <span class="token number">3</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">display</span> <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token string">'i</span> <span class="token string">'=</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span>newline<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">display</span> <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token string">'j</span> <span class="token string">'=</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">i</span> = <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">j</span> = <span class="token number">3</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Unspecified return value</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="宏的递归定义"><a href="#宏的递归定义" class="headerlink" title="宏的递归定义"></a>宏的递归定义</h4><p>代码形式<code>or</code>和<code>and</code>是通过像下面这样递归定义的宏：</p><p>[代码5]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> my-and  <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token boolean">#t</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> e<span class="token punctuation">)</span> e<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> e1 e2 ...<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">if</span> e1     <span class="token punctuation">(</span><span class="token function">my-and</span> e2 ...<span class="token punctuation">)</span>     <span class="token boolean">#f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> my-or  <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token boolean">#f</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> e<span class="token punctuation">)</span> e<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> e1 e2 ...<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">t</span> e1<span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token keyword">if</span> t t <span class="token punctuation">(</span><span class="token function">my-or</span> e2 ...<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以使用递归定义来编写复杂的宏。</p><h4 id="使用保留字"><a href="#使用保留字" class="headerlink" title="使用保留字"></a>使用保留字</h4><p><code>syntax-rule</code>的第一个参数是保留字的表。比如，<code>cond</code>的定义如[代码6]所示，其中，<code>else</code>是保留字。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> my-cond  <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token keyword">else</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> <span class="token punctuation">(</span><span class="token keyword">else</span> e1 ...<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">begin</span> e1 ...<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> <span class="token punctuation">(</span><span class="token function">e1</span> e2 ...<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token function">when</span> e1 e2 ...<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> <span class="token punctuation">(</span><span class="token function">e1</span> e2 ...<span class="token punctuation">)</span> c1 ...<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">if</span> e1      <span class="token punctuation">(</span><span class="token keyword">begin</span> e2 ...<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">cond</span> c1 ...<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="局部语法"><a href="#局部语法" class="headerlink" title="局部语法"></a>局部语法</h3><p>在Scheme中，可以使用<code>let-syntax</code>和<code>letrec-syntax</code>来定义<strong>局部语法（Local Syntax）</strong>。这种形式的用法和<code>define-syntax</code>是相似的。</p><h3 id="取决于宏定义的实现"><a href="#取决于宏定义的实现" class="headerlink" title="取决于宏定义的实现"></a>取决于宏定义的实现</h3><p>有些宏无法使用<code>syntax-rules</code>来定义。定义这些宏的实现方法已经在Scheme实现中准备好了。由于这种行为严重依赖于实现，因此你可以跳过此节。</p><p>在MIT-Scheme中，<code>sc-macro-transformer</code>就可用于这种情况，它允许用户用与Common Lisp中相似的方式来编写宏。关于<code>,</code>、<code>,@</code>的介绍，请参见<a href="http://deathking.github.io/yast-cn/contents/www.lispworks.com/documentation/HyperSpec/Body/02_df.htm">The Common Lisp HyperSpec</a>。关于<code>sc-macro-transformer</code>和<code>make-syntactic-closuer</code>请参见MIT-Scheme手册。[代码7]演示了一个简单的例子。</p><p>[代码 7]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> show-vars  <span class="token punctuation">(</span><span class="token function">sc-macro-transformer</span>    <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token function">exp</span> env<span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">vars</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> exp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>           `<span class="token punctuation">(</span><span class="token keyword">begin</span>              <span class="token punctuation">(</span><span class="token function">display</span>                <span class="token punctuation">(</span><span class="token builtin">list</span>                  ,@<span class="token punctuation">(</span><span class="token function">map</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>v<span class="token punctuation">)</span>                            <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">w</span> <span class="token punctuation">(</span><span class="token function">make-syntactic-closure</span> env <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span> v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                 `<span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token string">',w</span> ,w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                          vars<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span>newline<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> random-choice  <span class="token punctuation">(</span><span class="token function">sc-macro-transformer</span>   <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token function">exp</span> env<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       `<span class="token punctuation">(</span><span class="token function">case</span> <span class="token punctuation">(</span><span class="token function">random</span> ,<span class="token punctuation">(</span><span class="token function">length</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> exp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      ,@<span class="token punctuation">(</span><span class="token function">map</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span>           `<span class="token punctuation">(</span><span class="token punctuation">(</span>,<span class="token punctuation">(</span><span class="token function">incf</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> ,<span class="token punctuation">(</span><span class="token function">make-syntactic-closure</span> env <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token punctuation">(</span><span class="token builtin">cdr</span> exp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> aif  <span class="token punctuation">(</span><span class="token function">sc-macro-transformer</span>   <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token function">exp</span> env<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">test</span> <span class="token punctuation">(</span><span class="token function">make-syntactic-closure</span> env <span class="token string">'</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">second</span> exp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token function">cthen</span> <span class="token punctuation">(</span><span class="token function">make-syntactic-closure</span> env <span class="token string">'</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">third</span> exp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token function">celse</span> <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">pair?</span> <span class="token punctuation">(</span><span class="token function">cdddr</span> exp<span class="token punctuation">)</span><span class="token punctuation">)</span>              <span class="token punctuation">(</span><span class="token function">make-syntactic-closure</span> env <span class="token string">'</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">fourth</span> exp<span class="token punctuation">)</span><span class="token punctuation">)</span>              <span class="token boolean">#f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       `<span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">it</span> ,test<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token keyword">if</span> it ,cthen ,celse<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一个宏<code>show-vars</code>用于显示变量的值。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">j</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">show-vars</span> i j k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">j</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Unspecified return value</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>代码形式<code>(show-vars i j k)</code>被展开成下面这样。因为宏只能返回一个表达式，所以需要用<code>begin</code>返回表达式的集合。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">begin</span>  <span class="token punctuation">(</span><span class="token function">display</span>   <span class="token punctuation">(</span><span class="token builtin">list</span>    <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token string">'i</span> i<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token string">'j</span> j<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token string">'k</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span>newline<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二个宏<code>random-choice</code>被用于从参数中随机选择一个值或者过程。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>turn-right<span class="token punctuation">)</span> <span class="token string">'right)</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>turn-left<span class="token punctuation">)</span> <span class="token string">'left)</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>go-ahead<span class="token punctuation">)</span> <span class="token string">'straight)</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>stop<span class="token punctuation">)</span> <span class="token string">'stop)</span><span class="token punctuation">(</span><span class="token function">random-choice</span> <span class="token punctuation">(</span>turn-right<span class="token punctuation">)</span> <span class="token punctuation">(</span>turn-left<span class="token punctuation">)</span> <span class="token punctuation">(</span>go-ahead<span class="token punctuation">)</span> <span class="token punctuation">(</span>stop<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: right</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码形式被展开如下：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">case</span> <span class="token punctuation">(</span><span class="token function">random</span> <span class="token number">4</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token punctuation">(</span>0<span class="token punctuation">)</span> <span class="token punctuation">(</span>turn-right<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span> <span class="token punctuation">(</span>turn-left<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token punctuation">(</span>2<span class="token punctuation">)</span> <span class="token punctuation">(</span>go-ahead<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token punctuation">(</span>3<span class="token punctuation">)</span> <span class="token punctuation">(</span>stop<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第三个宏<code>aif</code>是一个回指宏（ anaphoric macro）。谓词的结果可以被指为<code>it</code>。变量<code>it</code>被捕获，以使得第二个参数<code>make-syntactic-closure</code>变为<code>&#39;(it)</code>。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">aif</span> <span class="token punctuation">(</span><span class="token function">memv</span> i <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">2</span> <span class="token number">4</span> <span class="token number">6</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token builtin">car</span> it<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>下面显示了扩展结果。</p><p>````scheme<br>(let ((it (memv i ‘(2 4 6 8))))<br>  (if it<br>      (car it)<br>      #f))</p><pre><code>### 结构体的原始实现结构体（structure）可以通过[代码8]中的简单宏实现。这里定义的结构体的本质是一个向量（vector）和由宏自动创建的取值以及赋值函数。如果你喜欢的Scheme版本没有结构体的实现，你可以自己实现它们。[代码8]```scheme01:     ;;; simple structure definition02:     03:     ;;; lists of symbols -&gt; string04:     (define (append-symbol . ls)05:       (let loop ((ls (cdr ls)) (str (symbol-&gt;string (car ls))))06:         (if (null? ls)07:         str08:         (loop (cdr ls) (string-append str &quot;-&quot; (symbol-&gt;string (car ls)))))))09:     10:     ;;; obj -&gt; ls -&gt; integer11:     ;;; returns position of obj in ls12:     (define (position obj ls)13:       (letrec ((iter (lambda (i ls)14:                (cond15:                 ((null? ls) #f)16:                 ((eq? obj (car ls)) i)17:                 (else (iter (1+ i) (cdr ls)))))))18:         (iter 0 ls)))19:                          20:     21:     ;;; list -&gt; integer -&gt; list22:     ;;; enumerate list items23:     (define (slot-enumerate ls i)24:       (if (null? ls)25:           &#39;()26:         (cons `((,(car ls)) ,i) (slot-enumerate (cdr ls) (1+ i)))))27:     28:     ;;; define simple structure 29:     (define-syntax defstruct30:       (sc-macro-transformer31:        (lambda (exp env)32:          (let ((struct (second exp))33:                (slots  (map (lambda (x) (if (pair? x) (car x) x)) (cddr exp)))34:            (veclen (- (length exp) 1)))35:            36:            `(begin   37:           (define ,(string-&gt;symbol (append-symbol &#39;make struct))   ; making instance38:             (lambda ls39:                   (let ((vec (vector &#39;,struct ,@(map (lambda (x) (if (pair? x) (second x) #f)) (cddr exp)))))40:             (let loop ((ls ls))41:               (if (null? ls)42:                   vec43:                   (begin44:                            (vector-set! vec (case (first ls) ,@(slot-enumerate slots 1)) (second ls))45:                 (loop (cddr ls))))))))46:     47:           (define ,(string-&gt;symbol (string-append (symbol-&gt;string struct) &quot;?&quot;))  ; predicate48:             (lambda (obj)49:               (and50:                (vector? obj)51:                (eq? (vector-ref obj 0) &#39;,struct))))52:     53:           ,@(map54:              (lambda (slot)55:                (let ((p (1+ (position slot slots))))56:              `(begin57:                 (define ,(string-&gt;symbol (append-symbol struct slot))    ; accessors58:                   (lambda (vec)59:                 (vector-ref vec ,p)))60:     61:                 (define-syntax ,(string-&gt;symbol                           ; modifier62:                          (string-append63:                           (append-symbol &#39;set struct slot) &quot;!&quot;))64:                   (syntax-rules ()65:                 ((_ s v) (vector-set! s ,p v)))))))66:              slots)67:     68:           (define ,(string-&gt;symbol (append-symbol &#39;copy struct))      ; copier69:             (lambda (vec)70:               (let ((vec1 (make-vector ,veclen)))71:             (let loop ((i 0))72:               (if (= i ,veclen)73:                   vec174:                   (begin75:                 (vector-set! vec1 i (vector-ref vec i))76:                 (loop (1+ i)))))))))))))</code></pre><p>下面演示了如何使用：</p><p>你可以定义一个结构体，要么只给出槽（slot）的名字，要么给出槽（slot）的名字和缺省值。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token comment" spellcheck="true">;;; Defining a structure point having 3 slots whose defaults are 0.0.</span><span class="token punctuation">(</span><span class="token function">defstruct</span> point <span class="token punctuation">(</span><span class="token function">x</span> <span class="token number">0.0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">y</span> <span class="token number">0.0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">z</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Unspecified return value</span><span class="token punctuation">(</span><span class="token keyword">define</span> p1 <span class="token punctuation">(</span><span class="token function">make-point</span> <span class="token string">'x</span> <span class="token number">10</span> <span class="token string">'y</span> <span class="token number">20</span> <span class="token string">'z</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: p1</span><span class="token punctuation">(</span><span class="token function">point?</span> p1<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token function">point-x</span> p1<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 10</span><span class="token comment" spellcheck="true">;;; Default values are used for unspecified values when an instance is made.</span><span class="token punctuation">(</span><span class="token keyword">define</span> p2 <span class="token punctuation">(</span><span class="token function">make-point</span> <span class="token string">'z</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: p2</span><span class="token punctuation">(</span><span class="token function">point-x</span> p2<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 0.</span><span class="token punctuation">(</span><span class="token function">point-z</span> p2<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 20</span><span class="token comment" spellcheck="true">;;; Changing a slot value</span><span class="token punctuation">(</span><span class="token function">set-point-y!</span> p2 <span class="token number">12</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Unspecified return value</span><span class="token comment" spellcheck="true">;;; The reality of the structure definde by [code 8] is a vector</span>p2<span class="token comment" spellcheck="true">;Value 14: #(point 0. 12 20)</span><span class="token comment" spellcheck="true">;;; Defining a structure 'book' with no default values.</span><span class="token punctuation">(</span><span class="token function">defstruct</span> book title authors publisher year isbn<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Unspecified return value</span><span class="token punctuation">(</span><span class="token keyword">define</span> mon-month   <span class="token punctuation">(</span><span class="token function">make-book</span> <span class="token string">'title</span>           <span class="token string">"The Mythical Man-Month: Essays on Software Engineering"</span>         <span class="token string">'authors</span>         <span class="token string">"F.Brooks"</span>         <span class="token string">'publisher</span>         <span class="token string">"Addison-Wesley"</span>         <span class="token string">'year</span>         <span class="token number">1995</span>         <span class="token string">'isbn</span>         <span class="token number">0201835959</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: mon-month</span>mon-month<span class="token comment" spellcheck="true">;Value 15: #(book </span><span class="token string">"The Mythical Man-Month: Essays on Software Engineering"</span> <span class="token string">"F.Brooks"</span> <span class="token string">"Addison-Wesley"</span> <span class="token number">1995</span> <span class="token number">201835959</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">book-title</span> mon-month<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 13: "The Mythical Man-Month: Essays on Software Engineering"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>我简要介绍了Scheme里的宏。宏可以使你的代码更优雅。</p><p><code>syntax-rules</code>使得编写宏很容易。另一方面，编写Common Lisp的宏，则要求特点的技巧。</p><h2 id="继续"><a href="#继续" class="headerlink" title="继续"></a>继续</h2><h3 id="简介-10"><a href="#简介-10" class="headerlink" title="简介"></a>简介</h3><p>本章介绍的是Scheme中特有的数据类型——<strong>继续（Continuation）</strong>。由于其他程序设计语言并没有这种数据类型，因此它难于理解。当下，你并不需要彻底理解清楚，只需要大致了解。</p><p>我会讲解广义的继续和简短地介绍<strong>Continuation-Passing-Style(CPS)</strong>，然后再讲解Scheme中的继续。我认为通过这种方式理解继续会比较容易。</p><h3 id="广义继续"><a href="#广义继续" class="headerlink" title="广义继续"></a>广义继续</h3><p>继续是在返回到<strong>顶层（Top level）</strong>之前所需要执行的计算。实际上，继续存在于计算的每时每刻。以<code>(* 3 (+ 1 2))</code>为例，在求值完<code>(+ 1 2)</code>后，应该计算<code>{ (* 3 []) }</code>乘以3。然而，大多数语言都不显式地这么做，程序员对此并不熟悉。</p><h3 id="Continuation-Passing-Style-CPS"><a href="#Continuation-Passing-Style-CPS" class="headerlink" title="Continuation-Passing-Style(CPS)"></a>Continuation-Passing-Style(CPS)</h3><h4 id="简单的CPS"><a href="#简单的CPS" class="headerlink" title="简单的CPS"></a>简单的CPS</h4><p>CPS是一种编程风格，在这种风格中，把依赖于当前函数结果的后续函数作为参数传递给当前函数。[代码1]展示了以CPS编写的加法和乘法。在<code>k+</code>和<code>k*</code>中，<code>k</code>是后续函数。</p><p>[代码1]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">return</span> x<span class="token punctuation">)</span>  x<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">k+</span> a b k<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">k</span> <span class="token punctuation">(</span><span class="token operator">+</span> a b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">k*</span> a b k<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">k</span> <span class="token punctuation">(</span><span class="token operator">*</span> a b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[例1]演示了如何使用CPS计算<code>(* 3 (+ 1 2))</code>。</p><p>[例1]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">k+</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k*</span> x <span class="token number">3</span> return<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Scheme的普通形式中，值在括号内被计算并向括号外传递。与此相反，CPS中，值向括号内传递。如[例1]中，<code>k+</code>把<code>(+ 1 2)</code>的值传递给<code>(lambda (x) (k* x 3 return))</code>，而<code>k*</code>把<code>(* (+ 1 2) 3)</code>的结果传给<code>return</code>。</p><h4 id="以CPS编写递归函数"><a href="#以CPS编写递归函数" class="headerlink" title="以CPS编写递归函数"></a>以CPS编写递归函数</h4><p>递归函数同样可以以CPS编写。[代码2]展示了计算阶乘的函数如何用普通方式编写（<code>fact</code>）和以CPS编写(<code>kfact</code>)。</p><p>[代码2]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token comment" spellcheck="true">;;; normal factorial</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">fact</span> n<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> n <span class="token number">1</span><span class="token punctuation">)</span>       <span class="token number">1</span>      <span class="token punctuation">(</span><span class="token operator">*</span> n <span class="token punctuation">(</span><span class="token function">fact</span> <span class="token punctuation">(</span><span class="token operator">-</span> n <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;;; CPS factorial</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">kfact</span> n k<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> n <span class="token number">1</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token function">k</span> <span class="token number">1</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token function">kfact</span> <span class="token punctuation">(</span><span class="token operator">-</span> n <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k</span> <span class="token punctuation">(</span><span class="token operator">*</span> n x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[例2]将3与4的阶乘相加。</p><p>[例2]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token comment" spellcheck="true">;;; normal</span><span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token function">fact</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;;; CPS</span><span class="token punctuation">(</span><span class="token function">kfact</span> <span class="token number">4</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k+</span> x <span class="token number">3</span> return<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[代码3]演示了如何分别用普通方式和CPS编写计算表中元素之积的函数。在CPS函数中，后继函数存储在局部变量<code>break</code>中，因此当元素乘以0时，可以立即退出。</p><p>[代码3]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token comment" spellcheck="true">;;; normal</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">product</span> ls<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">ls</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">acc</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">cond</span>     <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">null?</span> ls<span class="token punctuation">)</span> acc<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">zero?</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">0</span><span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">else</span> <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span> acc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;;; CPS</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">kproduct</span> ls k<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">break</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">ls</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token keyword">cond</span>       <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">null?</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">zero?</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">break</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token keyword">else</span> <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[例3]将100与<code>&#39;(2 4 7)</code>的积相加。</p><p>[例3]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token comment" spellcheck="true">;;; normal</span><span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">100</span> <span class="token punctuation">(</span><span class="token function">product</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">2</span> <span class="token number">4</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;;; CPS</span><span class="token punctuation">(</span><span class="token function">kproduct</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">2</span> <span class="token number">4</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k+</span> x <span class="token number">100</span> return<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>尽管CPS在这样简单的情况中并不实用，但在一些像是自然语言解析和逻辑编程等复杂程序中非常有用，因为与通常的编程风格相比，CPS可以更灵活地改变后续过程。</p><p><strong>异常处理（Exception handling）</strong>就是这种情况的简单例子。[代码4]演示了<code>kproduct</code>的错误处理版本，程序中当非数字值出现在输入表中，在其被打印时，计算就会终止。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">non-number-value-error</span> x<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">display</span> <span class="token string">"Value error: "</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">display</span>  x<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">display</span> <span class="token string">" is not number."</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span>newline<span class="token punctuation">)</span>  <span class="token string">'error)</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">kproduct</span> ls k k-value-error<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">break</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">ls</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token keyword">cond</span>       <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">null?</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">not</span> <span class="token punctuation">(</span><span class="token builtin">number?</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k-value-error</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">zero?</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">break</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token keyword">else</span> <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;;; valid</span><span class="token punctuation">(</span><span class="token function">kproduct</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">2</span> <span class="token number">4</span> <span class="token number">7</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k+</span> x <span class="token number">100</span> return<span class="token punctuation">)</span><span class="token punctuation">)</span>       non-number-value-error<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 156</span><span class="token comment" spellcheck="true">;;; invalid</span><span class="token punctuation">(</span><span class="token function">kproduct</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">2</span> <span class="token number">4</span> <span class="token number">7</span> hoge<span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k+</span> x <span class="token number">100</span> return<span class="token punctuation">)</span><span class="token punctuation">)</span>       non-number-value-error<span class="token punctuation">)</span>Value error: hoge is not number.<span class="token comment" spellcheck="true">;Value: error</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Scheme中的继续"><a href="#Scheme中的继续" class="headerlink" title="Scheme中的继续"></a>Scheme中的继续</h3><p>通过上面的讲解，你应该掌握了继续（continuation）。继续有下面的性质：</p><ol><li>存在于整个计算过程中；</li><li>函数式程序设计语言和CPS可以显式地处理它。</li></ol><p>另外，上面例子展示的是<strong>闭包链（Chain of closure）</strong>。</p><p>然而，阅读和编写CPS程序是痛苦的，以常规方式来处理继续会更方便一点。</p><p>因此，Scheme中将继续实现为<strong>一级对象（first class object）</strong>（这意味这Scheme中的继续是个普通数据类型），任何时候都可以通过名为<code>call-with-current-continuation</code>来调用。由于继续是普通数据类型，你可以随心所欲地重用。考虑到<code>call-with-current-continuation</code>名字过长，通常使用其缩略名<code>call/cc</code>。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> call/cc call-with-current-continuation<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>函数<code>call-with-current-continuation (call/cc)</code>接受一个参数。该参数是一个函数，函数的参数接收当前继续。</p><p>下面是例子：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token builtin">call/cc</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">;⇒ 9      ; [1]</span><span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token builtin">call/cc</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">(</span><span class="token function">k</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;⇒ 6      ; [2]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在<strong>情况[1]</strong>中，继续并没有被调用，语句的行为与普通S-表达式相同。另一方面，在<strong>情况[2]</strong>中，继续以2作为参数被调用。在这种情况中，继续的参数跳过了<code>call/cc</code>的处理，并逃逸至<code>call/cc</code>的外部。这种情况中，<code>k</code>是一个一元函数，等价于<code>(lambda (x) (* 3 x))</code>。</p><p>大体来说，当前继续存储了从<code>call/cc</code>调用点到顶层的处理过程。当前继续可以像其它数据类型那样被存储起来，并随心所欲地重用。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> cc<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token builtin">call/cc</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>k<span class="token punctuation">)</span>                  <span class="token punctuation">(</span><span class="token keyword">set!</span> cc k<span class="token punctuation">)</span>                  <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>由于当前继续是回到顶层的处理过程，它的返回会忽略周围的S-表达式。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">100</span> <span class="token punctuation">(</span><span class="token function">cc</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">;⇒ 9 </span><span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">100</span> <span class="token punctuation">(</span><span class="token function">cc</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;⇒ 30</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="使用call-cc抛出值"><a href="#使用call-cc抛出值" class="headerlink" title="使用call/cc抛出值"></a>使用<code>call/cc</code>抛出值</h4><p>从一个计算过程中逃逸出来，是使用当前继续的最容易的方法。[代码5]演示了搜索树（嵌套表）的函数。如果函数在树中找到<code>obj</code>，那么它返回该对象，否则返回<code>#f</code>。一旦找到<code>obj</code>，函数直接将其抛出至最外部。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">find-leaf</span> obj tree<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token builtin">call/cc</span>    <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>cc<span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token keyword">letrec</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">iter</span>                   <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>tree<span class="token punctuation">)</span>                      <span class="token punctuation">(</span><span class="token keyword">cond</span>                        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">null?</span>  tree<span class="token punctuation">)</span> <span class="token boolean">#f</span><span class="token punctuation">)</span>                        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">pair?</span> tree<span class="token punctuation">)</span>                           <span class="token punctuation">(</span><span class="token function">iter</span> <span class="token punctuation">(</span><span class="token builtin">car</span> tree<span class="token punctuation">)</span><span class="token punctuation">)</span>                           <span class="token punctuation">(</span><span class="token function">iter</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> tree<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                        <span class="token punctuation">(</span><span class="token keyword">else</span>                          <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">eqv?</span> obj tree<span class="token punctuation">)</span>                            <span class="token punctuation">(</span><span class="token function">cc</span> obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token punctuation">(</span><span class="token function">iter</span> tree<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">find-leaf</span> <span class="token number">7</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token punctuation">(</span><span class="token function">2</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token number">4</span> <span class="token punctuation">(</span><span class="token function">5</span> <span class="token punctuation">(</span><span class="token function">6</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒ 7</span><span class="token punctuation">(</span><span class="token function">find-leaf</span> <span class="token number">8</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token punctuation">(</span><span class="token function">2</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token number">4</span> <span class="token punctuation">(</span><span class="token function">5</span> <span class="token punctuation">(</span><span class="token function">6</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒ ()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[例6]演示了一个支持抛出的语法<code>block</code>。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> block  <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> tag e1 ...<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token builtin">call-with-current-continuation</span>       <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>tag<span class="token punctuation">)</span>          e1 ...<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[例7]演示了如何使用它。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">block</span> break   <span class="token punctuation">(</span><span class="token function">map</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span>           <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">positive?</span> x<span class="token punctuation">)</span>           <span class="token punctuation">(</span><span class="token function">sqrt</span> x<span class="token punctuation">)</span>           <span class="token punctuation">(</span><span class="token function">break</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒ (1 1.4142135623730951 1.7320508075688772)</span><span class="token punctuation">(</span><span class="token function">block</span> break   <span class="token punctuation">(</span><span class="token function">map</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span>           <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">positive?</span> x<span class="token punctuation">)</span>           <span class="token punctuation">(</span><span class="token function">sqrt</span> x<span class="token punctuation">)</span>           <span class="token punctuation">(</span><span class="token function">break</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">-2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒ -2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>我会讲解如何用<code>call/cc</code>实现一个树匹配的生成器。生成器以一个树为参数返回一个函数，每次调用这个返回的函数时，它会返回后续的叶子。你可以在<a href="http://ds26gte.github.io/tyscheme/index-Z-H-15.html#node_sec_13.3">Teach Yourself Scheme in Fixnum Days的第13.3节</a>中找到这个函数的原始版本。生成器的使用方法如下：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> tr <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">3</span> <span class="token punctuation">(</span><span class="token function">4</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> p <span class="token punctuation">(</span><span class="token function">leaf-generator</span> tr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;=> 1</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;=> 2</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;=> 3</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;=> 4</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;=> 5</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;=> ()  ; finally it returns '()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[代码6]给出了生成器的定义。这个和原始版本基本上相同，但有略微的修改。</p><p>[代码6]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">leaf-generator</span> tree<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">return</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                               <span class="token comment" spellcheck="true">; 1</span>    <span class="token punctuation">(</span><span class="token keyword">letrec</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">continue</span>                                              <span class="token comment" spellcheck="true">; 2</span>      <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">(</span><span class="token keyword">let</span> rec <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">tree</span> tree<span class="token punctuation">)</span><span class="token punctuation">)</span>                                      <span class="token comment" spellcheck="true">; 3</span>          <span class="token punctuation">(</span><span class="token keyword">cond</span>                                                     <span class="token comment" spellcheck="true">; 4</span>           <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">null?</span> tree<span class="token punctuation">)</span> <span class="token string">'skip)</span>                                     <span class="token comment" spellcheck="true">; 5</span>           <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">pair?</span> tree<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">rec</span> <span class="token punctuation">(</span><span class="token builtin">car</span> tree<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">rec</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> tree<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token comment" spellcheck="true">; 6</span>           <span class="token punctuation">(</span><span class="token keyword">else</span>                                                    <span class="token comment" spellcheck="true">; 7</span>            <span class="token punctuation">(</span><span class="token builtin">call/cc</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>lap-to-go<span class="token punctuation">)</span>                            <span class="token comment" spellcheck="true">; 8</span>                   <span class="token punctuation">(</span><span class="token keyword">set!</span> continue <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">lap-to-go</span> <span class="token string">'restart)))</span> <span class="token comment" spellcheck="true">; 9</span>                   <span class="token punctuation">(</span><span class="token function">return</span> tree<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                               <span class="token comment" spellcheck="true">;10</span>        <span class="token punctuation">(</span><span class="token function">return</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                             <span class="token comment" spellcheck="true">;11</span>    <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>                                                  <span class="token comment" spellcheck="true">;12</span>      <span class="token punctuation">(</span><span class="token builtin">call/cc</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>where-to-go<span class="token punctuation">)</span>                            <span class="token comment" spellcheck="true">;13</span>                 <span class="token punctuation">(</span><span class="token keyword">set!</span> return where-to-go<span class="token punctuation">)</span>                      <span class="token comment" spellcheck="true">;14</span>                 <span class="token punctuation">(</span>continue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(译者注：原文中05，08行中命名let中的<code>rec</code>被写为<code>loop</code>，结合上下文，改为<code>rec</code>)</p><p>注释解释</p><p>编号 解释</p><ul><li>1.定义本地变量<code>return</code>。</li><li>2.使用<code>letrec</code>定义<code>continue</code>。<code>continue</code>将当前叶子返回到前面，将当前继续赋给<code>continue</code>，并停止。</li><li>3.用<code>rec</code>定义命名let。</li><li>4.使用<code>cond</code>实现分支</li><li>5.如果是空表，什么也不做</li><li>6.如果是序对，递归地将序对的car和cdr应用于rec。</li><li>7.如果是叶子，</li><li>8.调用<code>call/cc</code>以获取当前状态(lap-to-go)</li><li>9.接着将当前状态赋给<code>continue</code>。所以除了原有的<code>continue</code>，<code>lap-to-go</code>也包含了当前状态。简而言之，它可以被如下的S-表达式中的<strong>[ ]</strong>表示。</li></ul><pre class="line-numbers language-Scheme"><code class="language-Scheme">(lambda ()   (let rec ((tree tree0))        (cond                          ((null? tree) '())             ((pair? tree) (rec (car tree)) (rec (cdr tree)))          (else                                                       [ ]    (return '()))))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用<code>lap-to-go</code>意味着<code>(car tree)</code>是叶子，且过程结束了，<code>(rec (cdr tree))</code>在下一次函数调用时开始运行。如果过程在<strong>[ ]</strong>之后结束，继续的参数将不起作用。</p><ul><li>10.接着函数将找到的叶子返回到函数的调用处。<code>(return tree)</code>应该在<code>call/cc</code>中以重启过程。</li><li>11.在搜索了全部叶子之后返回空表。</li><li>12.这是一个返回叶子生成器的生成器。</li><li>13.首次调用<code>call/cc</code></li><li>14.将表示返回值的当前状态赋给<code>return</code>。</li><li>15.然后调用<code>continue</code>。</li></ul><p>由<code>leaf-generator</code>生成的函数的行为可以通过函数<code>tree-traverse</code>的行为来估计。过程停止在轨迹的’*’的注释处，并使得过程存储在<code>continue</code>。</p><p>一个常规的遍历函数：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> tree-traverse  <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>tree<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">cond</span>     <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">null?</span> tree<span class="token punctuation">)</span> <span class="token string">'_)</span>     <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">pair?</span> tree<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">tree-traverse</span> <span class="token punctuation">(</span><span class="token builtin">car</span> tree<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">tree-traverse</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> tree<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">else</span>      <span class="token punctuation">(</span><span class="token function">write</span> tree<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当树为<code>&#39;((1 2) 3)</code>时，<code>tree-traverse</code>的轨迹。</p><pre><code>&gt; (tree-traverse &#39;((1 2) 3))|(tree-traverse ((1 2) 3))| (tree-traverse (1 2))| |(tree-traverse 1)           1| |#&lt; void&gt;               ; *| (tree-traverse (2))| |(tree-traverse 2)           2| |&lt; void&gt;                ; *| (tree-traverse &#39;())| _|(tree-traverse (3))| (tree-traverse 3)            3| #&lt; void&gt;                ; *|(tree-traverse &#39;())|__</code></pre><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>因为继续记录了后续计算过程，因此，用于多任务同时执行的<strong>协程（Coroutine）</strong>可以使用继续来实现。</p><p><strong>代码片段7</strong>展示了一段交替打印数字和字母的程序。5 - 22行是队列的实现。<code>(enqueue! queue obj)</code>将一个<code>obj</code>添加在队列的末尾。<code>(dequeue! queue)</code>返回队列第一个元素并将它删除。</p><p>26 - 38行是协程的实现。</p><p><strong>process-queue</strong></p><p>过程的队列。</p><p><strong>(coroutine thunk)</strong></p><p>在<code>process-queue</code>末尾添加<code>thunk</code>。</p><p><strong>(start)</strong></p><p>取得<code>process-queue</code>的第一个过程并执行它。</p><p><strong>(pause)</strong></p><p>将当前继续添加到<code>process-queue</code>的末尾并执行队列里的第一个过程。这个函数将控制权交给另外一个协程。</p><p>42 - 61行显示如何使用它。一个显示数字例程和一个显示字母例程相互调用对方，结果显示在<strong>例7</strong></p><pre class="line-numbers language-scheme"><code class="language-scheme">01:     <span class="token comment" spellcheck="true">;;; abbreviation</span><span class="token number">02</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> call/cc call-with-current-continuation<span class="token punctuation">)</span><span class="token number">03</span>:     <span class="token number">04</span>:     <span class="token comment" spellcheck="true">;;; queue</span><span class="token number">05</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>make-queue<span class="token punctuation">)</span><span class="token number">06</span>:       <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">07</span>:     <span class="token number">08</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">enqueue!</span> queue obj<span class="token punctuation">)</span><span class="token number">09</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">lobj</span> <span class="token punctuation">(</span><span class="token builtin">list</span> obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">10</span>:         <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">null?</span> <span class="token punctuation">(</span><span class="token builtin">car</span> queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">11</span>:         <span class="token punctuation">(</span><span class="token keyword">begin</span><span class="token number">12</span>:           <span class="token punctuation">(</span><span class="token function">set-car!</span> queue lobj<span class="token punctuation">)</span><span class="token number">13</span>:           <span class="token punctuation">(</span><span class="token function">set-cdr!</span> queue lobj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">14</span>:         <span class="token punctuation">(</span><span class="token keyword">begin</span><span class="token number">15</span>:           <span class="token punctuation">(</span><span class="token function">set-cdr!</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> queue<span class="token punctuation">)</span> lobj<span class="token punctuation">)</span><span class="token number">16</span>:           <span class="token punctuation">(</span><span class="token function">set-cdr!</span> queue lobj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">17</span>:         <span class="token punctuation">(</span><span class="token builtin">car</span> queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">18</span>:     <span class="token number">19</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">dequeue!</span> queue<span class="token punctuation">)</span><span class="token number">20</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">obj</span> <span class="token punctuation">(</span><span class="token builtin">car</span> <span class="token punctuation">(</span><span class="token builtin">car</span> queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">21</span>:         <span class="token punctuation">(</span><span class="token function">set-car!</span> queue <span class="token punctuation">(</span><span class="token builtin">cdr</span> <span class="token punctuation">(</span><span class="token builtin">car</span> queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">22</span>:         obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">23</span>:     <span class="token number">24</span>:     <span class="token number">25</span>:     <span class="token comment" spellcheck="true">;;; coroutine   </span><span class="token number">26</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> process-queue <span class="token punctuation">(</span>make-queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">27</span>:     <span class="token number">28</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">coroutine</span> thunk<span class="token punctuation">)</span><span class="token number">29</span>:       <span class="token punctuation">(</span><span class="token function">enqueue!</span> process-queue thunk<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">30</span>:     <span class="token number">31</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token number">32</span>:        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">dequeue!</span> process-queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">33</span>:        <span class="token number">34</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>pause<span class="token punctuation">)</span><span class="token number">35</span>:       <span class="token punctuation">(</span><span class="token builtin">call/cc</span><span class="token number">36</span>:        <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token number">37</span>:          <span class="token punctuation">(</span><span class="token function">coroutine</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k</span> <span class="token boolean">#f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">38</span>:          <span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">39</span>:     <span class="token number">40</span>:     <span class="token number">41</span>:     <span class="token comment" spellcheck="true">;;; example</span><span class="token number">42</span>:     <span class="token punctuation">(</span><span class="token function">coroutine</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">43</span>:              <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">44</span>:                <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> i <span class="token number">10</span><span class="token punctuation">)</span><span class="token number">45</span>:                <span class="token punctuation">(</span><span class="token keyword">begin</span><span class="token number">46</span>:                  <span class="token punctuation">(</span><span class="token function">display</span> <span class="token punctuation">(</span><span class="token function">1+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">47</span>:                  <span class="token punctuation">(</span><span class="token function">display</span> <span class="token string">" "</span><span class="token punctuation">)</span> <span class="token number">48</span>:                  <span class="token punctuation">(</span>pause<span class="token punctuation">)</span> <span class="token number">49</span>:                  <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token function">1+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">50</span>:                <span class="token number">51</span>:     <span class="token punctuation">(</span><span class="token function">coroutine</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">52</span>:              <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">53</span>:                <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> i <span class="token number">10</span><span class="token punctuation">)</span><span class="token number">54</span>:                <span class="token punctuation">(</span><span class="token keyword">begin</span><span class="token number">55</span>:                  <span class="token punctuation">(</span><span class="token function">display</span> <span class="token punctuation">(</span><span class="token function">integer->char</span> <span class="token punctuation">(</span><span class="token operator">+</span> i <span class="token number">97</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">56</span>:                  <span class="token punctuation">(</span><span class="token function">display</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token number">57</span>:                  <span class="token punctuation">(</span>pause<span class="token punctuation">)</span> <span class="token number">58</span>:                  <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token function">1+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">59</span>:     <span class="token number">60</span>:     <span class="token punctuation">(</span>newline<span class="token punctuation">)</span><span class="token number">61</span>:     <span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">load</span> <span class="token string">"cor2.scm"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Loading "cor2.scm"</span><span class="token number">1</span> a <span class="token number">2</span> b <span class="token number">3</span> c <span class="token number">4</span> d <span class="token number">5</span> e <span class="token number">6</span> f <span class="token number">7</span> g <span class="token number">8</span> h <span class="token number">9</span> i <span class="token number">10</span> j  -- done<span class="token comment" spellcheck="true">;Unspecified return value</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>本章中，我讲解了继续。</p><p>理解这些概念可能比较困难。但不要担心，有朝一日你终会明白。</p><p>下一章中，我将介绍惰性求值。</p><h2 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h2><h3 id="简介-11"><a href="#简介-11" class="headerlink" title="简介"></a>简介</h3><p>惰性求值（Lazy evaluation）是在需要时才进行求值的计算方式。惰性求值自然地在数据结构中包含递归，可以以简单的方式表示无限的概念，这种方式有利于程序的模块化。</p><p>你可以从<a href="http://deathking.github.io/yast-cn/contents/www.md.chalmers.se/~rjmh/Papers/whyfp.html">《Why Functional Programming Matters》</a>中知晓惰性计算可以带来哪些好处。</p><p><a href="http://deathking.github.io/yast-cn/contents/www.haskell.org">Haskell</a>语言以采用惰性求值而广为人熟知。Scheme也部分采用了惰性求值。</p><h3 id="用于惰性求值的函数"><a href="#用于惰性求值的函数" class="headerlink" title="用于惰性求值的函数"></a>用于惰性求值的函数</h3><p>下面这些用于处理惰性求值的函数是在R5RS中定义的。中间状态被称为延时对象（<code>promise</code>），它表示求值方法已经定义好了，但求值还未执行。最终的值通过对延时对象（<code>promise</code>）调用force被计算出来。</p><p><strong>(delay <code>proc</code>)</strong></p><p>以<code>proc</code>创建一个延时对象（<code>promise</code>）。</p><p><strong>(promise? <code>obj</code>)</strong></p><p>如果<code>obj</code>是一个延时对象就返回 #t。</p><p><strong>(force <code>promise</code>)</strong></p><p>对延时对象求值，执行求值操作。</p><h3 id="惰性求值的简单例子"><a href="#惰性求值的简单例子" class="headerlink" title="惰性求值的简单例子"></a>惰性求值的简单例子</h3><p>[例1]展示一个惰性求值的简单例子。在这个例子中，延时对象（<code>promise</code>）通过对(1 + 2)调用<code>delay</code>产生，然后通过函数<code>force</code>对延时对象求值。</p><p>[例1]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> laz <span class="token punctuation">(</span><span class="token keyword">delay</span> <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: laz</span>laz<span class="token comment" spellcheck="true">;Value 11: #[promise 11]</span><span class="token punctuation">(</span><span class="token function">promise?</span> laz<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token function">force</span> laz<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 3</span><span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">10</span> <span class="token punctuation">(</span><span class="token function">force</span> laz<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 30</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意延时对象并没有被<code>force</code>消费掉，这意味着函数<code>force</code>没有副作用。因此，你可以重复使用延时对象。</p><h3 id="使用惰性求值表示无限序列"><a href="#使用惰性求值表示无限序列" class="headerlink" title="使用惰性求值表示无限序列"></a>使用惰性求值表示无限序列</h3><p>现在，让我们使用惰性求值创建无限序列。首先，我将定义一些用于处理无限序列的基本函数。然后，我会使用这些函数创建无限序列，并将无限序列用于数值计算。</p><p>无限序列可以用如表达式（1）的cons单元（cons cell）的嵌套结构表示。cons单元的<code>car</code>和<code>cdr</code>分别是最终值和延时对象（promise）。另一个表达式（1）结构的cons单元通过强制求值<code>cdr</code>部分产生，你可以无限重复这个过程，就像图 1。这个和cons单元的嵌套结构和普通表类似，只是使用延时对象作为<code>cdr</code>部分使其可以表示无限序列。</p><pre><code>    (&lt;val&gt; . &lt;promise&gt;)    (1)</code></pre><p><img src="http://deathking.github.io/yast-cn/contents/figures/lazy_fig_1.png" alt="infiity sequence"></p><p>图 1. 无限序列的实现，使用了<code>car</code>和<code>cdr</code>分别为最终值和延时对象的cons单元。</p><h3 id="无限序列的基本函数和宏"><a href="#无限序列的基本函数和宏" class="headerlink" title="无限序列的基本函数和宏"></a>无限序列的基本函数和宏</h3><p>[代码 1]展示了无限序列的基本函数和宏。其中最重要的是<code>lazy-map</code>，被用于操作无限序列。</p><p>由于<code>lazy-map</code>包含一个特殊delay构造用于延迟求值，所以它需要被定义为宏。</p><p>[代码 1]</p><pre class="line-numbers language-scheme"><code class="language-scheme">01:     <span class="token comment" spellcheck="true">;;;;; basic functions and a macro</span><span class="token number">02</span>:     <span class="token number">03</span>:     <span class="token comment" spellcheck="true">;;; car for lazy evaluation</span><span class="token number">04</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> lazy-car car<span class="token punctuation">)</span><span class="token number">05</span>:     <span class="token number">06</span>:     <span class="token comment" spellcheck="true">;;; cdr for lazy evaluation</span><span class="token number">07</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">lazy-cdr</span> ls<span class="token punctuation">)</span><span class="token number">08</span>:       <span class="token punctuation">(</span><span class="token function">force</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">09</span>:     <span class="token number">10</span>:     <span class="token comment" spellcheck="true">;;; lazy cons</span><span class="token number">11</span>:     <span class="token punctuation">(</span><span class="token keyword">define-syntax</span> lazy-cons<span class="token number">12</span>:        <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">13</span>:           <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> a b<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> a <span class="token punctuation">(</span><span class="token keyword">delay</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">14</span>:     <span class="token number">15</span>:     <span class="token comment" spellcheck="true">;;; lazy map</span><span class="token number">16</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">lazy-map</span> fn . lss<span class="token punctuation">)</span><span class="token number">17</span>:       <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">memq</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span> lss<span class="token punctuation">)</span><span class="token number">18</span>:           <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">19</span>:         <span class="token punctuation">(</span><span class="token function">lazy-cons</span> <span class="token punctuation">(</span><span class="token builtin">apply</span> fn <span class="token punctuation">(</span><span class="token function">map</span> lazy-car lss<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">20</span>:                    <span class="token punctuation">(</span><span class="token builtin">apply</span> lazy-map fn <span class="token punctuation">(</span><span class="token function">map</span> lazy-cdr lss<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">21</span>:     <span class="token number">22</span>:     <span class="token comment" spellcheck="true">;;; lazy filter</span><span class="token number">23</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">lazy-filter</span> pred ls<span class="token punctuation">)</span><span class="token number">24</span>:       <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">null?</span> ls<span class="token punctuation">)</span><span class="token number">25</span>:           <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">26</span>:         <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">obj</span> <span class="token punctuation">(</span><span class="token function">lazy-car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">27</span>:           <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pred</span> obj<span class="token punctuation">)</span><span class="token number">28</span>:               <span class="token punctuation">(</span><span class="token function">lazy-cons</span> obj  <span class="token punctuation">(</span><span class="token function">lazy-filter</span> pred <span class="token punctuation">(</span><span class="token function">lazy-cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">29</span>:             <span class="token punctuation">(</span><span class="token function">lazy-filter</span> pred <span class="token punctuation">(</span><span class="token function">lazy-cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">30</span>:     <span class="token number">31</span>:     <span class="token comment" spellcheck="true">;;; returns n-th item of the lazy list</span><span class="token number">32</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">lazy-ref</span> ls n<span class="token punctuation">)</span><span class="token number">33</span>:       <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> n <span class="token number">0</span><span class="token punctuation">)</span><span class="token number">34</span>:           <span class="token punctuation">(</span><span class="token function">lazy-car</span> ls<span class="token punctuation">)</span><span class="token number">35</span>:         <span class="token punctuation">(</span><span class="token function">lazy-ref</span> <span class="token punctuation">(</span><span class="token function">lazy-cdr</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">-</span> n <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">36</span>:     <span class="token number">37</span>:     <span class="token comment" spellcheck="true">;;; returns first n items of the ls</span><span class="token number">38</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">head</span> ls n<span class="token punctuation">)</span><span class="token number">39</span>:       <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> n <span class="token number">0</span><span class="token punctuation">)</span><span class="token number">40</span>:           <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">41</span>:          <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token punctuation">(</span><span class="token function">lazy-car</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">head</span> <span class="token punctuation">(</span><span class="token function">lazy-cdr</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">-</span> n <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(lazy-car ls)</strong></p><p>和<code>(car ls)</code>一样，因为<code>car</code>部分是最终值。</p><p><strong>(lazy-cdr ls)</strong></p><p>计算<code>ls</code>的<code>cdr</code>部分（延时对象）的‘最终’值。</p><p><strong>(lazy-cons a b)</strong></p><p>这是一个扩展了<code>(cons a (delay b))</code>的宏。如果这个操作被定义为一个函数，<code>b</code>将立刻求值，这样delay就没有任何意义了。</p><p><strong>(lazy-map fn . lss)</strong></p><p>这是一个惰性求值的<code>map</code>函数，是在[代码 1]中最重要的函数。注意它返回一个包含最终值（<code>car</code>部分）和延时对象（<code>cdr</code>部分）的cons单元。</p><p><strong>(lazy-filter pred ls)</strong></p><p>这是一个惰性求值的<code>filter</code>函数。它过滤<code>ls</code>并返回一个由包含满足<code>pred</code>条件的元素组成的‘无限序列’。</p><p><strong>(lazy-ref ls n)</strong></p><p>返回‘无限序列’<code>ls</code>的第n个元素。</p><p><strong>(head ls n)</strong></p><p>返回<code>ls</code>（惰性求值表）的前n个元素。</p><h3 id="无限序列"><a href="#无限序列" class="headerlink" title="无限序列"></a>无限序列</h3><p>无限序列可以简洁地用<code>lazy-cons</code>和<code>lazy-map</code>表示。我会展示两个例子：</p><ul><li>下一项由前一项定义的序列，如等差数列和等比数列。</li><li>菲波那契数列。</li></ul><h4 id="下一个项由前一项定义的序列"><a href="#下一个项由前一项定义的序列" class="headerlink" title="下一个项由前一项定义的序列"></a>下一个项由前一项定义的序列</h4><p>下一个项由前一项定义的序列可以有如下形式的函数（f）定义：</p><p>[{a}_{i+1} = f({a}_i) ]</p><p>可以表示为[代码2]里的<code>(inf-seq a0 f)</code>，<code>a0</code>和<code>f</code>分别是初始项和用于计算随后项的函数。</p><p><code>(inf-seq a0 f)</code>是递归定义的，它的定义清晰表明初始项是a0，第二项是<code>(f a0)</code>，<code>(n+1)</code>项由<code>(f an)</code>表示。</p><p>等差和等比数列分别被定义为<code>(ari a0 d)</code>和<code>(geo a0 r)</code>，其中<code>a0</code>，<code>d</code>和<code>r</code>分别是初始值，公差，公比。这些函数使用函数<code>inf-seq</code>定义。</p><p>[代码2]</p><pre class="line-numbers language-scheme"><code class="language-scheme">01:     <span class="token comment" spellcheck="true">;;;;  sequences</span><span class="token number">02</span>:     <span class="token number">03</span>:     <span class="token comment" spellcheck="true">;;; infinite sequences represented by a_(n+1) = f(a_n)</span><span class="token number">04</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">inf-seq</span> a0 f<span class="token punctuation">)</span><span class="token number">05</span>:       <span class="token punctuation">(</span><span class="token function">lazy-cons</span> a0 <span class="token punctuation">(</span><span class="token function">inf-seq</span> <span class="token punctuation">(</span><span class="token function">f</span> a0<span class="token punctuation">)</span> f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">06</span>:     <span class="token number">07</span>:     <span class="token comment" spellcheck="true">;;; arithmetic sequence</span><span class="token number">08</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">ari</span> a0 d<span class="token punctuation">)</span><span class="token number">09</span>:       <span class="token punctuation">(</span><span class="token function">inf-seq</span> a0 <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">+</span> x d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">10</span>:     <span class="token number">11</span>:     <span class="token comment" spellcheck="true">;;; geometric sequence</span><span class="token number">12</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">geo</span> a0 r<span class="token punctuation">)</span><span class="token number">13</span>:       <span class="token punctuation">(</span><span class="token function">inf-seq</span> a0 <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span> x r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>让我们检查一下<code>inf-seq</code>所产生的无限序列（例2）。创建两个等比数列：</p><ol><li><code>g1</code>，初始值1，公比为2。</li><li><code>g2</code>，初始值1，公比为1/2。</li></ol><p>然后使用<code>head</code>求值前10项。你将看到正确产生了两个等比数列。</p><p>接下来，使用<code>lazy-map</code>计算<code>g1</code>和<code>g2</code>的乘积，并使用<code>head</code>求值前10项。你将看到一个全是1的序列，这表明计算被正确地执行了。</p><p>现在，让我们用等差数列和<code>lazy-filter</code>娱乐一番。首先，用<code>(ari 1 1)</code>创建一个等比数列<code>ar1</code>。<code>(head ar1 10)</code>的结果显示等比数列 <code>(1 2 3 ....)</code> 是由 <code>(ari 1 1)</code> 产生的。然后使用<code>lazy-filter</code>取出<code>ar1</code>里的偶数，并使用<code>head</code>求值前10项。你将看到<code>(2 4 6 8 10 12 14 16 18 20)</code>，这表明<code>lazy-filter</code>正常工作。</p><p>[例2]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> g1 <span class="token punctuation">(</span><span class="token function">geo</span> <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: g1</span><span class="token punctuation">(</span><span class="token keyword">define</span> g2 <span class="token punctuation">(</span><span class="token function">geo</span> <span class="token number">1</span> <span class="token punctuation">(</span><span class="token operator">/</span> <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: g2</span><span class="token punctuation">(</span><span class="token function">head</span> g1 <span class="token number">10</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 12: (1 2 4 8 16 32 64 128 256 512)</span><span class="token punctuation">(</span><span class="token function">head</span> g2 <span class="token number">10</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 13: (1 1/2 1/4 1/8 1/16 1/32 1/64 1/128 1/256 1/512)</span><span class="token punctuation">(</span><span class="token function">head</span> <span class="token punctuation">(</span><span class="token function">lazy-map</span> * g1 g2<span class="token punctuation">)</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 14: (1 1 1 1 1 1 1 1 1 1)</span><span class="token punctuation">(</span><span class="token keyword">define</span> ar1 <span class="token punctuation">(</span><span class="token function">ari</span> <span class="token number">1</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;;Value: ar1</span><span class="token punctuation">(</span><span class="token function">head</span> ar1 <span class="token number">10</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;;Value 15: (1 2 3 4 5 6 7 8 9 10)</span><span class="token punctuation">(</span><span class="token function">head</span> <span class="token punctuation">(</span><span class="token function">lazy-filter</span> even? ar1<span class="token punctuation">)</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;;Value 16: (2 4 6 8 10 12 14 16 18 20)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="菲波那切数列"><a href="#菲波那切数列" class="headerlink" title="菲波那切数列"></a>菲波那切数列</h4><p>菲波那切数列定义如下：</p><pre><code>fib(1) = 1fib(2) = 1fib(n+1) = fib(n) + fib(n-1)</code></pre><p>代码3展示了Scheme实现的菲波那切数列，用到了<code>lazy-cons</code>和<code>lazy-map</code>。如代码所示，Scheme里的定义和数学上的定义很相似。此外，各个项的计算的复杂度为<em>O(n)</em>。</p><p>[例3]中，值被立刻计算出来了。</p><p>[代码 3]</p><pre class="line-numbers language-scheme"><code class="language-scheme">01:     <span class="token punctuation">(</span><span class="token keyword">define</span> fib<span class="token number">02</span>:       <span class="token punctuation">(</span><span class="token function">lazy-cons</span> <span class="token number">1</span><span class="token number">03</span>:                  <span class="token punctuation">(</span><span class="token function">lazy-cons</span> <span class="token number">1</span><span class="token number">04</span>:                             <span class="token punctuation">(</span><span class="token function">lazy-map</span> + fib <span class="token punctuation">(</span><span class="token function">lazy-cdr</span> fib<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>[例 3]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">head</span> fib <span class="token number">20</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 12: (1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765)</span><span class="token punctuation">(</span><span class="token function">lazy-ref</span> fib <span class="token number">100</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 573147844013817084101</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="将惰性求值用于数值计算"><a href="#将惰性求值用于数值计算" class="headerlink" title="将惰性求值用于数值计算"></a>将惰性求值用于数值计算</h3><p>下面是<a href="http://deathking.github.io/yast-cn/contents/www.md.chalmers.se/~rjmh/Papers/whyfp.html">《Why Functional Programming Matters》</a>里相关代码的Schme版本。也可以查看<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%_sec_3.5">SICP 3.5. Stream</a>惰性计算在数值计算中的应用。</p><h4 id="牛顿-拉夫逊法求平方根"><a href="#牛顿-拉夫逊法求平方根" class="headerlink" title="牛顿-拉夫逊法求平方根"></a>牛顿-拉夫逊法求平方根</h4><p>牛顿-拉夫逊法可以使用初始值a0和等式（2）计算N的平方根。</p><pre><code>     a(n+1) =  (a(n) + N/a(n)) / 2                   (2)</code></pre><p>如果等式（2）收敛到最终值 a，</p><pre><code>      a =  (a +  N/a) / 2⇒      2a = a +  N/a      a =  N/a      a*a = N      a =  √N</code></pre><p>，这表明最终值a是N的平方根。序列的下一项是前一项的函数（如等式（2）所示），这些序列可用<code>inf-seq</code>表示。</p><p>代码4展示了一个计算平方根的程序。在代码4中，初始值被定为1，由于序列收敛很快，所以这没问题。</p><p>[代码4]</p><pre class="line-numbers language-scheme"><code class="language-scheme">01:     <span class="token comment" spellcheck="true">;;; Newton-Raphson method</span><span class="token number">02</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">newton-raphson</span> n<span class="token punctuation">)</span><span class="token number">03</span>:       <span class="token punctuation">(</span><span class="token function">inf-seq</span> <span class="token number">1</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">/</span> <span class="token punctuation">(</span><span class="token operator">+</span> x <span class="token punctuation">(</span><span class="token operator">/</span> n x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">04</span>:     <span class="token number">05</span>:     <span class="token comment" spellcheck="true">;;; returning a reasonable answer.</span><span class="token number">06</span>:     <span class="token comment" spellcheck="true">;;; If the ratio of successive terms is in (1 - eps) and (1 + eps),</span><span class="token number">07</span>:     <span class="token comment" spellcheck="true">;;; or the following term is zero,</span><span class="token number">08</span>:     <span class="token comment" spellcheck="true">;;; the function returns it.</span><span class="token number">09</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">lazylist->answer</span> ls eps<span class="token punctuation">)</span><span class="token number">10</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">e1</span> <span class="token punctuation">(</span><span class="token operator">-</span> <span class="token number">1.0</span> eps<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">11</span>:             <span class="token punctuation">(</span><span class="token function">e2</span> <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">1.0</span> eps<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">12</span>:         <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">val</span> <span class="token punctuation">(</span><span class="token function">lazy-car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">13</span>:                    <span class="token punctuation">(</span><span class="token function">ls1</span> <span class="token punctuation">(</span><span class="token function">lazy-cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">14</span>:           <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">val2</span> <span class="token punctuation">(</span><span class="token function">lazy-car</span> ls1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">15</span>:             <span class="token punctuation">(</span><span class="token keyword">if</span>  <span class="token punctuation">(</span><span class="token function">or</span> <span class="token punctuation">(</span><span class="token function">zero?</span> val2<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> e1 <span class="token punctuation">(</span><span class="token operator">/</span> val val2<span class="token punctuation">)</span> e2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">16</span>:                 <span class="token punctuation">(</span><span class="token function">exact->inexact</span> val2<span class="token punctuation">)</span><span class="token number">17</span>:               <span class="token punctuation">(</span><span class="token function">loop</span> val2 <span class="token punctuation">(</span><span class="token function">lazy-cdr</span> ls1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">18</span>:     <span class="token number">19</span>:     <span class="token comment" spellcheck="true">;;;</span><span class="token number">20</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">my-sqrt</span> n eps<span class="token punctuation">)</span><span class="token number">21</span>:       <span class="token punctuation">(</span><span class="token function">lazylist->answer</span> <span class="token punctuation">(</span><span class="token function">newton-raphson</span> n<span class="token punctuation">)</span> eps<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(newton-raphson n)</strong></p><p>一个函数，创建平方根近似值的表。</p><p><strong>(lazylist-&gt;answer ls eps)</strong></p><p>检查收敛是否满足条件了。如果是的，返回数值计算的结果。</p><p>如果<code>(1 - eps) &lt; t2/t1 &lt; (1 + eps)</code> 或者 <code>t2 = 0</code>，函数返回 <code>ls</code> 的后续项（即 <code>t1</code> 和 <code>t2</code>）的第二项。</p><p><strong>(my-sqrt n eps)</strong></p><p>在相对误差eps下，计算n的平方根。</p><pre><code>(my-sqrt 9 0.0000001);Value: 3.</code></pre><h4 id="数值微分"><a href="#数值微分" class="headerlink" title="数值微分"></a>数值微分</h4><p>[代码5]中的<code>easydiff</code>是一种计算数字积分的简单方式，其中<code>f</code>，<code>x</code>，和<code>h</code>分别是被积分的函数，x值，和Δx。理论上，如果<code>h</code>越趋于0，获得的近似值越好。但在实践中，由于数值在计算机里的精度是有限的，微小的<code>h</code>值会导致错误。</p><p>为了解决这个问题，我们用<code>lazylist-diff</code>创建<code>h</code>的惰性表。这个惰性表是初始值为<code>h0</code>，公比为0.5的等比数列。然后我们创建一个对应于<code>h</code>的惰性表的近似值的惰性表。</p><p>可以通过如下代码加快收敛速度，更快得到答案：</p><pre><code>(lazylist-&gt;answer (lazylist-diff h0 f x) eps)</code></pre><p>函数<code>super</code>是收敛加速函数。可以查看<a href="http://deathking.github.io/yast-cn/contents/www.md.chalmers.se/~rjmh/Papers/whyfp.html">《Why Functional Programming Matters》</a>的关于加速技术部分。如果你使用了传统编程语言，加速计算会相当复杂。相反，使用惰性求值可以以简单的方式实现。此外，因为高度的模块化，你可以在其他问题中复用代码，例如数值积分（4.3.3节）。代码6复用了代码5中的加速函数。</p><p>[代码5]</p><pre class="line-numbers language-scheme"><code class="language-scheme">01:     <span class="token comment" spellcheck="true">;;; differentiation</span><span class="token number">02</span>:     <span class="token number">03</span>:     <span class="token comment" spellcheck="true">;;; primitive function for differentiation</span><span class="token number">04</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">easydiff</span> f x h<span class="token punctuation">)</span><span class="token number">05</span>:       <span class="token punctuation">(</span><span class="token operator">/</span> <span class="token punctuation">(</span><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token function">f</span> <span class="token punctuation">(</span><span class="token operator">+</span> x h<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">f</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span> h<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">06</span>:     <span class="token number">07</span>:     <span class="token comment" spellcheck="true">;;; create a lazy list of approximation for differentiation</span><span class="token number">08</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">lazylist-diff</span> h0 f x<span class="token punctuation">)</span><span class="token number">09</span>:       <span class="token punctuation">(</span><span class="token function">lazy-map</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">easydiff</span> f x h<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">geo</span> h0 <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">10</span>:     <span class="token number">11</span>:     <span class="token comment" spellcheck="true">;;; eliminate error from the approximation</span><span class="token number">12</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">elimerror</span> n ls<span class="token punctuation">)</span><span class="token number">13</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">a</span> <span class="token punctuation">(</span><span class="token function">lazy-car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">14</span>:             <span class="token punctuation">(</span><span class="token function">b</span> <span class="token punctuation">(</span><span class="token function">lazy-second</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">15</span>:             <span class="token punctuation">(</span><span class="token function">c</span> <span class="token punctuation">(</span><span class="token function">fix:lsh</span> <span class="token number">1</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">; (expt 2 n)</span><span class="token number">16</span>:         <span class="token punctuation">(</span><span class="token function">lazy-cons</span><span class="token number">17</span>:          <span class="token punctuation">(</span><span class="token operator">/</span> <span class="token punctuation">(</span><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token operator">*</span> b c<span class="token punctuation">)</span> a<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">-</span> c <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">18</span>:          <span class="token punctuation">(</span><span class="token function">elimerror</span> n <span class="token punctuation">(</span><span class="token function">lazy-cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">19</span>:     <span class="token number">20</span>:     <span class="token comment" spellcheck="true">;;; estimate `n' in elimerror</span><span class="token number">21</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">order</span> ls<span class="token punctuation">)</span><span class="token number">22</span>:       <span class="token punctuation">(</span><span class="token keyword">let*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">a</span> <span class="token punctuation">(</span><span class="token function">lazy-car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">23</span>:              <span class="token punctuation">(</span><span class="token function">b</span> <span class="token punctuation">(</span><span class="token function">lazy-second</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">24</span>:              <span class="token punctuation">(</span><span class="token function">c</span> <span class="token punctuation">(</span><span class="token function">lazy-ref</span> ls <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">25</span>:              <span class="token punctuation">(</span><span class="token function">d</span> <span class="token punctuation">(</span><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token operator">/</span> <span class="token punctuation">(</span><span class="token operator">-</span> a c<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">-</span> b c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">26</span>:         <span class="token punctuation">(</span><span class="token keyword">cond</span><span class="token number">27</span>:          <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&lt;</span> d <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token number">28</span>:          <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&lt;=</span> <span class="token number">2</span> d <span class="token number">16</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">inexact->exact</span> <span class="token punctuation">(</span><span class="token function">round</span> <span class="token punctuation">(</span><span class="token function">log2</span> d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">29</span>:          <span class="token punctuation">(</span><span class="token keyword">else</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">30</span>:     <span class="token number">31</span>:     <span class="token comment" spellcheck="true">;;;</span><span class="token number">32</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">log2</span> x<span class="token punctuation">)</span><span class="token number">33</span>:       <span class="token punctuation">(</span><span class="token operator">/</span> <span class="token punctuation">(</span><span class="token function">log</span> x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">log</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">34</span>:     <span class="token number">35</span>:     <span class="token comment" spellcheck="true">;;; improve convergence of the lazy list of the approximation</span><span class="token number">36</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">improve</span> ls<span class="token punctuation">)</span><span class="token number">37</span>:       <span class="token punctuation">(</span><span class="token function">elimerror</span> <span class="token punctuation">(</span><span class="token function">order</span> ls<span class="token punctuation">)</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">38</span>:     <span class="token number">39</span>:     <span class="token comment" spellcheck="true">;;; return the second value of the lazy list</span><span class="token number">40</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">lazy-second</span> ls<span class="token punctuation">)</span><span class="token number">41</span>:       <span class="token punctuation">(</span><span class="token function">lazy-car</span> <span class="token punctuation">(</span><span class="token function">lazy-cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">42</span>:     <span class="token number">43</span>:     <span class="token comment" spellcheck="true">;;; further improve the convergence of the list</span><span class="token number">44</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">super</span> ls<span class="token punctuation">)</span><span class="token number">45</span>:       <span class="token punctuation">(</span><span class="token function">lazy-map</span> lazy-second <span class="token punctuation">(</span><span class="token function">inf-seq</span> ls improve<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">46</span>:                 <span class="token number">47</span>:     <span class="token number">48</span>:     <span class="token comment" spellcheck="true">;;; calculate the differentiation of function `f' at x within error eps</span><span class="token number">49</span>:     <span class="token comment" spellcheck="true">;;; h0 is initial window width</span><span class="token number">50</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">diff</span> f x h0 eps<span class="token punctuation">)</span><span class="token number">51</span>:       <span class="token punctuation">(</span><span class="token function">lazylist->answer</span> <span class="token punctuation">(</span><span class="token function">super</span> <span class="token punctuation">(</span><span class="token function">lazylist-diff</span> h0 f x<span class="token punctuation">)</span><span class="token punctuation">)</span> eps<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">diff</span> sin <span class="token number">0.0</span> <span class="token number">0.1</span> <span class="token number">0.0000001</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: .9999999999999516</span><span class="token punctuation">(</span><span class="token function">diff</span> exp <span class="token number">0.0</span> <span class="token number">0.1</span> <span class="token number">0.000001</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: .9999999991733471</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数值积分"><a href="#数值积分" class="headerlink" title="数值积分"></a>数值积分</h4><p>收敛加速函数无需任何修改即可被用于数值积分。最开始，我们使用<code>easyintegrate</code>创建一个粗略的近似。函数<code>lazylist-integrate</code>使用惰性表，通过递归地调用<code>easyintegrate</code>在中间点切分区间，来改进近似值。函数可以用lazy-map以简单的方式定义。最终，收敛被加速，收敛值由函数<code>integrate</code>返回。</p><p>[代码6]</p><pre class="line-numbers language-scheme"><code class="language-scheme">01:     <span class="token comment" spellcheck="true">;;; integration</span><span class="token number">02</span>:     <span class="token number">03</span>:     <span class="token comment" spellcheck="true">;;; primitive integration</span><span class="token number">04</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">easyintegrate</span> f a b<span class="token punctuation">)</span><span class="token number">05</span>:       <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">/</span> <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token punctuation">(</span><span class="token function">f</span> a<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">f</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">-</span> b a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">06</span>:     <span class="token number">07</span>:     <span class="token comment" spellcheck="true">;;; create the lazy list of approximation for integration</span><span class="token number">08</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">lazylist-integrate</span> f a b<span class="token punctuation">)</span><span class="token number">09</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">mid</span> <span class="token punctuation">(</span><span class="token operator">/</span> <span class="token punctuation">(</span><span class="token operator">+</span> a b<span class="token punctuation">)</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">10</span>:         <span class="token punctuation">(</span><span class="token function">lazy-cons</span> <span class="token punctuation">(</span><span class="token function">easyintegrate</span> f a b<span class="token punctuation">)</span><span class="token number">11</span>:                    <span class="token punctuation">(</span><span class="token function">lazy-map</span> + <span class="token punctuation">(</span><span class="token function">lazylist-integrate</span> f a mid<span class="token punctuation">)</span><span class="token number">12</span>:                                <span class="token punctuation">(</span><span class="token function">lazylist-integrate</span> f mid b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">13</span>:     <span class="token number">14</span>:     <span class="token comment" spellcheck="true">;;; integrate function `f' in a range of `a' and `b' within error `eps'</span><span class="token number">15</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">integrate</span> f a b eps<span class="token punctuation">)</span><span class="token number">16</span>:       <span class="token punctuation">(</span><span class="token function">lazylist->answer</span> <span class="token punctuation">(</span><span class="token function">super</span> <span class="token punctuation">(</span><span class="token function">lazylist-integrate</span> f a b<span class="token punctuation">)</span><span class="token punctuation">)</span> eps<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> pi <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">4</span> <span class="token punctuation">(</span><span class="token function">atan</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: pi</span><span class="token punctuation">(</span><span class="token function">integrate</span> sin <span class="token number">0</span> pi <span class="token number">0.0000001</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 2.000000002272428</span><span class="token punctuation">(</span><span class="token function">integrate</span> exp <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0.0000001</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 1.7182818277724858</span><span class="token punctuation">(</span><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token function">exp</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 1.718281828459045</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>惰性求值允许我们以简洁的方式将重复包含在数据结构中。这个功能有利于程序的模块化，可使代码更为紧凑。</p><p>查看网页<a href="http://www.haskell.org/haskellwiki/Haskell">Haskell</a>可以了解更多关于惰性求值的内容。</p><p>你可以在<a href="http://www.shido.info/lisp/scheme_lazy.zip">这儿</a>下载本页中出现代码。</p><h2 id="非确定性"><a href="#非确定性" class="headerlink" title="非确定性"></a>非确定性</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>非确定性是一种通过仅定义问题来解决问题的算法。非确定性程序自动选择符合条件的选项。这项技术很适合逻辑编程。</p><p>例如，以下代码返回一对数，其和是一个质数。其中一个数从<code>&#39;(4 6 7)</code>选取，另一个从<code>&#39;(5 8 11)</code>选取。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token punctuation">(</span><span class="token function">amb</span> <span class="token number">4</span> <span class="token number">6</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token function">j</span> <span class="token punctuation">(</span><span class="token function">amb</span> <span class="token number">5</span> <span class="token number">8</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">prime?</span> <span class="token punctuation">(</span><span class="token operator">+</span> i j<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token builtin">list</span> i j<span class="token punctuation">)</span>      <span class="token punctuation">(</span>amb<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 23: (6 5)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>(amb 4 6 7)</code> 从4，6和7中返回一个合适的数，<code>(amb 5 8 11)</code>从5，8和11中返回一个合适的数。如果没有选出合适的值，(amb)返回假。</p><p>实际上，amb做了深度优先搜索。<code>(amb c1 c2 c3 ...)</code>创建了搜索路径依次检查<code>c1</code>，<code>c2</code>，<code>c3</code>，…并回溯。因此，非确定性是一种帮程序隐藏搜索的抽象。一旦我们有了amb，我们可以很容易地编写程序而无需思考计算机做了什么。</p><h3 id="非确定性的实现"><a href="#非确定性的实现" class="headerlink" title="非确定性的实现"></a>非确定性的实现</h3><p>使用在非确定性中的回溯被实现为连接到继续（continuation）的闭包链。这个链被一个全局参数<code>fail</code>表示，该参数是一个复写自己的函数。</p><h4 id="函数实现"><a href="#函数实现" class="headerlink" title="函数实现"></a>函数实现</h4><p>第一步，我使用函数（名为<code>choose</code>）实现非确定性，演示于[代码1]。我首先定义一个全局参数<code>fail</code>，它的初始值是一个将返回<code>no-choice</code>到顶层的函数（22-26行）。然后通过在函数choose中重新定义<code>fail</code>实现闭包链。回溯通过调用之前的<code>fail</code>实现。</p><p>函数<code>choose</code>有如下行为：</p><ol><li>如果没有选项，调用(fail)。</li><li>如果有任何选项，<ol><li>将fail储存为fail0，并调用当前继续（continuation）。</li><li>在继续（continuation）中重新定义fail。fail重新被赋值回存在fail0里的原值，并对余下的选项应用（apply）choose。</li><li>返回第一个选项到继续（continuation）外面。</li></ol></li></ol><p>[代码1]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token comment" spellcheck="true">;;; abbreviation for call-with-current-continuation</span><span class="token punctuation">(</span><span class="token keyword">define</span> call/cc call-with-current-continuation<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;;; This function is re-assigned in `choose` and `fail` itself.</span><span class="token punctuation">(</span><span class="token keyword">define</span> fail <span class="token boolean">#f</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;;; function for nondeterminism</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">choose</span> . ls<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">null?</span> ls<span class="token punctuation">)</span>     <span class="token punctuation">(</span>fail<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">fail0</span> fail<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token builtin">call/cc</span>        <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>cc<span class="token punctuation">)</span>          <span class="token punctuation">(</span><span class="token keyword">set!</span> fail <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>                       <span class="token punctuation">(</span><span class="token keyword">set!</span> fail fail0<span class="token punctuation">)</span>                       <span class="token punctuation">(</span><span class="token function">cc</span> <span class="token punctuation">(</span><span class="token builtin">apply</span> choose <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token punctuation">(</span><span class="token function">cc</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;;; write following at the end of file</span><span class="token comment" spellcheck="true">;;; initial value for fail</span><span class="token punctuation">(</span><span class="token builtin">call/cc</span>   <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>cc<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">set!</span> fail <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>                 <span class="token punctuation">(</span><span class="token function">cc</span> <span class="token string">'no-choice)))))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>让我们看看<code>choose</code>是否可以找到毕达哥拉斯三元组。函数<code>pythag</code>用于寻找三元组。如果找到了，它返回一个表。如果没有找到，调用无参数的<code>choose</code>，以回溯。</p><p>[例1]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">sq</span> x<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token operator">*</span> x x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: sq</span><span class="token comment" spellcheck="true">;;; Pythagorean triples</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">pythag</span> a b c<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token punctuation">(</span><span class="token function">sq</span> a<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">sq</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">sq</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token builtin">list</span> a b c<span class="token punctuation">)</span>      <span class="token punctuation">(</span>choose<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: pythag</span><span class="token punctuation">(</span><span class="token function">pythag</span> <span class="token punctuation">(</span><span class="token function">choose</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">choose</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">choose</span>  <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 16: (3 4 5)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="宏实现"><a href="#宏实现" class="headerlink" title="宏实现"></a>宏实现</h4><p>为了对S-表达式使用非确定性操作，必须把操作定义为宏。例如，[例2]中所示函数<code>an-integer-starting-from</code>应该返回一个大于或等于<code>n</code>的整数，但是如果<code>choose</code>被以函数形式定义，它将不能正常工作，因为参数会立即求值。</p><p>[例2]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">an-integer-starting-from</span> n<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">choose</span> n <span class="token punctuation">(</span><span class="token function">an-integer-starting-from</span> <span class="token punctuation">(</span><span class="token function">1+</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: an-integer-starting-from</span><span class="token punctuation">(</span><span class="token function">an-integer-starting-from</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Aborting!: maximum recursion depth exceeded</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了解决这一点，我们定义了一个和[代码1]中定义一致但使用非确定性宏<code>amb</code>实现的<code>choose</code>。这个宏<code>amb</code>有和<code>choose</code>一样的递归调用自己的结构。</p><p>[代码1]中的1-5行和20-26行在下面的代码中得以重用。</p><p>[代码2]使用MIT-Scheme编译时，编译器给出如下警告：</p><pre><code>;Warning: Possible inapplicable operator ()</code></pre><p>但是代码可以正常工作。这些代码在<a href="http://www.scheme.com/petitechezscheme.html">Petite Chez Scheme</a>下也可以运行。即使我没有试过其他Scheme实现，我认为<code>amb</code>的定义可以工作，只要它们遵守R5RS。你可以在<a href="http://www.shido.info/lisp/scheme_amb.zip">这里</a>下载一个为MIT-Scheme做的专门实现。MIT-Scheme编译器不会对这个专门实现提出警告。</p><p>[代码2]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token comment" spellcheck="true">;;; nondeterminism macro operator</span><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> amb  <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token punctuation">(</span>fail<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> a<span class="token punctuation">)</span> a<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> a b ...<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">fail0</span> fail<span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token builtin">call/cc</span>    <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>cc<span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token keyword">set!</span> fail        <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token punctuation">(</span><span class="token keyword">set!</span> fail fail0<span class="token punctuation">)</span>          <span class="token punctuation">(</span><span class="token function">cc</span> <span class="token punctuation">(</span><span class="token function">amb</span> b ...<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token function">cc</span> a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>宏定义，<code>amb</code>，在参数为S-表达式时也和其他值一样正常工作。</p><p>[例3]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">an-integer-starting-from</span> n<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">amb</span> n <span class="token punctuation">(</span><span class="token function">an-integer-starting-from</span> <span class="token punctuation">(</span><span class="token function">1+</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: an-integer-starting-from</span><span class="token punctuation">(</span><span class="token function">an-integer-starting-from</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 1</span><span class="token punctuation">(</span>amb<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 2</span><span class="token punctuation">(</span>amb<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<a href="http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme-Z-H-16.html#node_sec_14.2">Teach Yourself Scheme in Fixnum Days</a> 和<a href="http://www.ccs.neu.edu/home/dherman/code/amb.ss">Dave Hername Code</a>中的amb实现使用<code>&#39;,@(map ...)&#39;</code>展开参数。即使它们是直截了当的定义，但由于使用了两次<code>call/cc</code>，它们某种程度上仍很复杂。[代码2]所示的递归定义更简单，即使展开的S-表达式会很复杂。</p><h4 id="应用于逻辑编程，使程序更简洁"><a href="#应用于逻辑编程，使程序更简洁" class="headerlink" title="应用于逻辑编程，使程序更简洁"></a>应用于逻辑编程，使程序更简洁</h4><p>[代码3]演示了非确定性应用逻辑编程，使得程序更简洁</p><p>[代码3]</p><pre class="line-numbers language-scheme"><code class="language-scheme">01:     <span class="token comment" spellcheck="true">;;; returning all possibilities</span><span class="token number">02</span>:     <span class="token punctuation">(</span><span class="token keyword">define-syntax</span> set-of<span class="token number">03</span>:       <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token number">04</span>:         <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> s<span class="token punctuation">)</span> <span class="token number">05</span>:           <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">acc</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">06</span>:             <span class="token punctuation">(</span><span class="token function">amb</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">v</span> s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">07</span>:                    <span class="token punctuation">(</span><span class="token keyword">set!</span> acc <span class="token punctuation">(</span><span class="token builtin">cons</span> v acc<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">08</span>:                    <span class="token punctuation">(</span>fail<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">09</span>:                  <span class="token punctuation">(</span><span class="token function">reverse!</span> acc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">10</span>:     <span class="token number">11</span>:     <span class="token comment" spellcheck="true">;;; if not pred backtrack</span><span class="token number">12</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">assert</span> pred<span class="token punctuation">)</span><span class="token number">13</span>:       <span class="token punctuation">(</span><span class="token function">or</span> pred <span class="token punctuation">(</span>amb<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">14</span>:     <span class="token number">15</span>:     <span class="token comment" spellcheck="true">;;; returns arbitrary number larger or equal to n</span><span class="token number">16</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">an-integer-starting-from</span> n<span class="token punctuation">)</span><span class="token number">17</span>:       <span class="token punctuation">(</span><span class="token function">amb</span> n <span class="token punctuation">(</span><span class="token function">an-integer-starting-from</span> <span class="token punctuation">(</span><span class="token function">1+</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">18</span>:     <span class="token number">19</span>:     <span class="token comment" spellcheck="true">;;; returns arbitrary number between a and b</span><span class="token number">20</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">number-between</span> a b<span class="token punctuation">)</span><span class="token number">21</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">22</span>:         <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">></span> i b<span class="token punctuation">)</span><span class="token number">23</span>:             <span class="token punctuation">(</span>amb<span class="token punctuation">)</span><span class="token number">24</span>:           <span class="token punctuation">(</span><span class="token function">amb</span> i <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token function">1+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(set-of <code>s</code>)</strong></p><p>返回满足<code>s</code>的所有可能性。宏的行为如下：</p><ol><li>（第5行）一个表（acc）被定义，它有所欲哦满足<code>s</code>的结果。</li><li>（第6行）<code>s</code>的结果被赋给<code>v</code>，并加入到<code>acc</code>。如果结果没有带上<code>v</code>而直接被加入（如 (set! acc (cons s acc))），则会因为<code>s</code>使用了继续（continuation）而只在acc中存储了最后一个值。<code>s</code>改了了fail的值。</li><li>（第7，8行）在这之后，调用fail回溯。因为使用了继续（continuation），函数fail行为就像在第6行被调用。</li><li>（第9行）当所有可能的选项被找到时，调用<code>(reverse! acc)</code>并返回所有的可能选项。</li></ol><p>定义假设amb从最左边参数开始搜索。</p><p><strong>(assert <code>pred</code>)</strong></p><p>如果谓词为假,就回溯。</p><p><strong>(an-integer-starting-from <code>n</code>)</strong></p><p>非确定性地返回从<code>n</code>开始的整数。</p><p><strong>(number-between <code>a</code> <code>b</code>)</strong></p><p>非确定性地返回<code>a</code>和<code>b</code>之间的整数</p><p>[例4]演示了如何使用<code>set-of</code>。得到了所有小于20的质数。</p><p>[例4]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">prime?</span> n<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">m</span> <span class="token punctuation">(</span><span class="token function">sqrt</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token function">or</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> m i<span class="token punctuation">)</span>          <span class="token punctuation">(</span><span class="token function">and</span> <span class="token punctuation">(</span><span class="token function">not</span> <span class="token punctuation">(</span><span class="token function">zero?</span> <span class="token punctuation">(</span><span class="token function">modulo</span> n i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>               <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token operator">+</span> i <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> i <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">gen-prime</span> n<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token punctuation">(</span><span class="token function">number-between</span>  <span class="token number">2</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">prime?</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span>    i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">set-of</span> <span class="token punctuation">(</span><span class="token function">gen-prime</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 12: (2 3 5 7 11 13 17 19)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="逻辑编程的例子"><a href="#逻辑编程的例子" class="headerlink" title="逻辑编程的例子"></a>逻辑编程的例子</h3><p>让我们来解决<a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_sec_4.3.2">SICP中的习题4.42</a>作为例子。问题如下：</p><p>五位女同学参加一场考试。她们的家长对考试结果过分关心。为此她们约定，在给家里写信谈到考试时，每个姑娘都要写一句真话和一句假话。下面是从她们的信中摘出的句子：</p><p>贝蒂：“凯迪考第二，我只考了第三。” 艾赛尔：“你们应该高兴地听到我考了第一，琼第二。” 琼：“我考第三，可怜的艾赛尔考得最差。” 凯蒂：“我第二，玛丽只考了第四。” 玛丽：“我是第四，贝蒂的成绩最高。”</p><p>这五位姑娘的实际排名是什么？</p><p>[代码4]给出了这个问题的解法。</p><p>[代码4]</p><pre class="line-numbers language-scheme"><code class="language-scheme">01:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">xor</span> a b<span class="token punctuation">)</span><span class="token number">02</span>:       <span class="token punctuation">(</span><span class="token keyword">if</span> a <span class="token punctuation">(</span><span class="token function">not</span> b<span class="token punctuation">)</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">03</span>:     <span class="token number">04</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">all-different?</span> . ls<span class="token punctuation">)</span><span class="token number">05</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">obj</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">ls</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">06</span>:         <span class="token punctuation">(</span><span class="token function">or</span> <span class="token punctuation">(</span><span class="token builtin">null?</span> ls<span class="token punctuation">)</span><span class="token number">07</span>:             <span class="token punctuation">(</span><span class="token function">and</span> <span class="token punctuation">(</span><span class="token function">not</span> <span class="token punctuation">(</span><span class="token function">memv</span> obj ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">08</span>:                  <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">09</span>:     <span class="token number">10</span>:     <span class="token comment" spellcheck="true">;;; SICP Exercise 4.42</span><span class="token number">11</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>girls-exam<span class="token punctuation">)</span><span class="token number">12</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">kitty</span> <span class="token punctuation">(</span><span class="token function">number-between</span> <span class="token number">1</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">13</span>:             <span class="token punctuation">(</span><span class="token function">betty</span> <span class="token punctuation">(</span><span class="token function">number-between</span> <span class="token number">1</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">14</span>:         <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">xor</span> <span class="token punctuation">(</span><span class="token operator">=</span> kitty <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">=</span> betty <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">15</span>:         <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">mary</span> <span class="token punctuation">(</span><span class="token function">number-between</span> <span class="token number">1</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">16</span>:           <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">xor</span> <span class="token punctuation">(</span><span class="token operator">=</span> kitty <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">=</span> mary <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">17</span>:           <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">xor</span> <span class="token punctuation">(</span><span class="token operator">=</span> mary <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">=</span> betty <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">18</span>:           <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">ethel</span> <span class="token punctuation">(</span><span class="token function">number-between</span> <span class="token number">1</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">19</span>:                 <span class="token punctuation">(</span><span class="token function">joan</span> <span class="token punctuation">(</span><span class="token function">number-between</span> <span class="token number">1</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">20</span>:             <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">xor</span> <span class="token punctuation">(</span><span class="token operator">=</span> ethel <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">=</span> joan <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">21</span>:             <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">xor</span> <span class="token punctuation">(</span><span class="token operator">=</span> joan <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">=</span> ethel <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">22</span>:             <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">all-different?</span> kitty betty ethel joan mary<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">23</span>:             <span class="token punctuation">(</span><span class="token function">map</span> list <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">kitty</span> betty ethel joan mary<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">list</span> kitty betty ethel joan mary<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">24</span>:     <span class="token number">25</span>:     <span class="token comment" spellcheck="true">;;; Bad answer for ex 4.42</span><span class="token number">26</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>girls-exam-x<span class="token punctuation">)</span><span class="token number">27</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">kitty</span> <span class="token punctuation">(</span><span class="token function">number-between</span> <span class="token number">1</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">28</span>:             <span class="token punctuation">(</span><span class="token function">betty</span> <span class="token punctuation">(</span><span class="token function">number-between</span> <span class="token number">1</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">29</span>:             <span class="token punctuation">(</span><span class="token function">mary</span> <span class="token punctuation">(</span><span class="token function">number-between</span> <span class="token number">1</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">30</span>:             <span class="token punctuation">(</span><span class="token function">ethel</span> <span class="token punctuation">(</span><span class="token function">number-between</span> <span class="token number">1</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">31</span>:             <span class="token punctuation">(</span><span class="token function">joan</span> <span class="token punctuation">(</span><span class="token function">number-between</span> <span class="token number">1</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">32</span>:         <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">xor</span> <span class="token punctuation">(</span><span class="token operator">=</span> kitty <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">=</span> betty <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">33</span>:         <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">xor</span> <span class="token punctuation">(</span><span class="token operator">=</span> kitty <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">=</span> mary <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">34</span>:         <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">xor</span> <span class="token punctuation">(</span><span class="token operator">=</span> mary <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">=</span> betty <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">35</span>:         <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">xor</span> <span class="token punctuation">(</span><span class="token operator">=</span> ethel <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">=</span> joan <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">36</span>:         <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">xor</span> <span class="token punctuation">(</span><span class="token operator">=</span> joan <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">=</span> ethel <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">37</span>:         <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">all-different?</span> kitty betty ethel joan mary<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">38</span>:         <span class="token punctuation">(</span><span class="token function">map</span> list <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">kitty</span> betty ethel joan mary<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">list</span> kitty betty ethel joan mary<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(xor a b)</strong>以下条件满足，返回#t:</p><ul><li>a是#t，b是#f，或者</li><li>a是#f，b是#t。</li></ul><p><strong>(all-different? , ls)</strong></p><p>当<code>ls</code>的所有元素都不相同时，返回#t。</p><p><strong>(girls-exam)</strong></p><p>是解决谜题的主要函数。它返回名字和排名的表。每次参数赋值后都调用了<code>assert</code>是为了有效地减少死分支的运行时间。<code>(girls-exam-x)</code>则是一个坏例子。它在为所有参数赋值之后调用<code>assert</code>。这种情况下，无谓地搜索了大量的死分支。[例5]显示<code>(girl-exam-x)</code>的运行时间是<code>(girl-exam)</code>的10倍。</p><p>[例5]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> cpu-time/sec  <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> s<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token function">with-timings</span>     <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> s<span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token function">run-time</span> gc-time real-time<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token function">write</span> <span class="token punctuation">(</span><span class="token function">internal-time/ticks->seconds</span> run-time<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token function">write-char</span> #\space<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token function">write</span> <span class="token punctuation">(</span><span class="token function">internal-time/ticks->seconds</span> gc-time<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token function">write-char</span> #\space<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token function">write</span> <span class="token punctuation">(</span><span class="token function">internal-time/ticks->seconds</span> real-time<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">(</span>newline<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: cpu-time/sec</span><span class="token punctuation">(</span><span class="token function">cpu-time/sec</span> <span class="token punctuation">(</span>girls-exam<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">.03</span> <span class="token number">0</span>. <span class="token number">.03</span><span class="token comment" spellcheck="true">;Value 14: ((kitty 1) (betty 3) (ethel 5) (joan 2) (mary 4))</span><span class="token punctuation">(</span><span class="token function">cpu-time/sec</span> <span class="token punctuation">(</span>girls-exam-x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">.341</span> <span class="token number">.29</span> <span class="token number">.631</span><span class="token comment" spellcheck="true">;Value 15: ((kitty 1) (betty 3) (ethel 5) (joan 2) (mary 4))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>当你使用了非确定性和用于逻辑编程分析技术时，你就可以写出看起来具有先见之明的程序。注意如果搜索路径里有循环我们就不能使用本章的代码。关于这一点，查看<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_sec_4.3">SICP 4.3</a>以获取更多信息。</p><p>写这一章时，我参考了<a href="http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme-Z-H-16.html">Teach Yourself Scheme in Fixnum Days</a>。</p><p>你可以在<a href="http://www.shido.info/lisp/scheme_amb.zip">这儿</a>下载本章代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;虽然目前因为scheme过时，最新的SICP已经采用python作为系列语言，但是通过前两章的学习，可以说，Scheme（lisp方言）是一
      
    
    </summary>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="Scheme" scheme="https://JoyTsing.github.io/tags/Scheme/"/>
    
  </entry>
  
</feed>
