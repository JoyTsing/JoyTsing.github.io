<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JoyTsing</title>
  
  <subtitle>深海</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://joytsing.github.io/"/>
  <updated>2024-03-21T15:43:59.259Z</updated>
  <id>https://joytsing.github.io/</id>
  
  <author>
    <name>JoyTsing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Cpp20-STL-Cookbook速查</title>
    <link href="https://joytsing.github.io/posts/13644/"/>
    <id>https://joytsing.github.io/posts/13644/</id>
    <published>2024-03-21T15:41:57.000Z</published>
    <updated>2024-03-21T15:43:59.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>阅读时请配合cpp reference使用，同时请确保编译器支持C++20。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;阅读时请配合cpp reference使用，同时请确保编译器支持C++20。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://JoyTsing.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="读书笔记" scheme="https://JoyTsing.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>spdlog库源码阅读</title>
    <link href="https://joytsing.github.io/posts/38320/"/>
    <id>https://joytsing.github.io/posts/38320/</id>
    <published>2024-03-21T15:36:29.000Z</published>
    <updated>2024-03-21T15:44:10.049Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>阅读源码是学习进阶必须越过的一步，同时也要学习其他人阅读源码的方式和经验，本文内容不全是个人做的<del>比如图就是从网上偷来的</del>，站在巨人肩膀上才能更好地让自己看到更多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;阅读源码是学习进阶必须越过的一步，同时也要学习其他人阅读源码的方式和经验，本文内容不全是个人做的&lt;del&gt;比如图就是从网上偷来的&lt;/del&gt;
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="源码阅读" scheme="https://JoyTsing.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>CMake实战</title>
    <link href="https://joytsing.github.io/posts/64584/"/>
    <id>https://joytsing.github.io/posts/64584/</id>
    <published>2024-03-21T13:52:37.000Z</published>
    <updated>2024-03-21T14:34:54.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文是知乎上HAN Bing写的CMake实战指南，加上一部分个人的理解和实践。</p><h2 id="使用find-package引入外部依赖包"><a href="#使用find-package引入外部依赖包" class="headerlink" title="使用find_package引入外部依赖包"></a>使用find_package引入外部依赖包</h2><h3 id="通过Cmake内置模块引入依赖包"><a href="#通过Cmake内置模块引入依赖包" class="headerlink" title="通过Cmake内置模块引入依赖包"></a>通过Cmake内置模块引入依赖包</h3><p>为了方便我们在项目中引入外部依赖包，cmake官方为我们预定义了许多寻找依赖包的Module，他们存储在path_to_your_cmake/share/cmake-&lt;version&gt;/Modules目录下。每个以Find.cmake命名的文件都可以帮我们找到一个包。我们也可以在官方文档中查看到哪些库官方已经为我们定义好了，我们可以直接使用find_package函数进行引用<a href="https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html">官方文档：Find Modules</a>。</p><p>以curl库为例，假设我们项目需要引入这个库，从网站中请求网页到本地，我们看到官方已经定义好了FindCURL.cmake。所以我们在CMakeLists.txt中可以直接用find_pakcage进行引用。</p><pre class="line-numbers language-cmake"><code class="language-cmake">find_package(CURL)add_executable(curltest curltest.cc)if(CURL_FOUND)    target_include_directories(clib PRIVATE ${CURL_INCLUDE_DIR})    target_link_libraries(curltest ${CURL_LIBRARY})else(CURL_FOUND)    message(FATAL_ERROR ”CURL library not found”)endif(CURL_FOUND)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于系统预定义的 <code>Find&lt;LibaryName&gt;.cmake</code> 模块，使用方法一般如上例所示。</p><p>每一个模块都会定义以下几个变量</p><ul><li><code>&lt;LibaryName&gt;_FOUND</code></li><li><code>&lt;LibaryName&gt;_INCLUDE_DIR or &lt;LibaryName&gt;_INCLUDES</code></li><li><code>&lt;LibaryName&gt;_LIBRARY or &lt;LibaryName&gt;_LIBRARIES</code></li></ul><p>你可以通过<code>&lt;LibaryName&gt;_FOUND</code> 来判断模块是否被找到，如果没有找到，按照工程的需要关闭 某些特性、给出提醒或者中止编译，上面的例子就是报出致命错误并终止构建。 如果<code>&lt;LibaryName&gt;_FOUND</code> 为真，则将<code>&lt;LibaryName&gt;_INCLUDE_DIR</code> 加入 INCLUDE_DIRECTORIES，</p><h3 id="通过find-package引入非官方的库（该方式只对支持cmake编译安装的库有效）"><a href="#通过find-package引入非官方的库（该方式只对支持cmake编译安装的库有效）" class="headerlink" title="通过find_package引入非官方的库（该方式只对支持cmake编译安装的库有效）"></a>通过find_package引入非官方的库（该方式只对支持cmake编译安装的库有效）</h3><p>假设此时我们需要引入glog库来进行日志的记录，我们在Module目录下并没有找到 FindGlog.cmake。所以我们需要自行安装glog库，再进行引用。</p><p>安装</p><pre class="line-numbers language-sh"><code class="language-sh"># clone该项目git clone https://github.com/google/glog.git # 切换到需要的版本 cd gloggit checkout v0.40  # 根据官网的指南进行安装cmake -H. -Bbuild -G "Unix Makefiles"cmake --build buildcmake --build build --target install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时我们便可以通过与引入curl库一样的方式引入glog库了</p><pre class="line-numbers language-cmake"><code class="language-cmake">find_package(glog)add_executable(glogtest glogtest.cc)if(GLOG_FOUND)    # 由于glog在连接时将头文件直接链接到了库里面，所以这里不用显示调用target_include_directories    target_link_libraries(glogtest glog::glog)else(GLOG_FOUND)    message(FATAL_ERROR ”glog library not found”)endif(GLOG_FOUND)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Module模式与Config模式"><a href="#Module模式与Config模式" class="headerlink" title="Module模式与Config模式"></a>Module模式与Config模式</h3><p>通过上文我们了解了通过Cmake引入依赖库的基本用法。知其然也要知其所以然，find_package对我们来说是一个黑盒子，那么它是具体通过什么方式来查找到我们依赖的库文件的路径的呢。到这里我们就不得不聊到find_package的两种模式，一种是Module模式，也就是我们引入curl库的方式。另一种叫做Config模式，也就是引入glog库的模式。下面我们来详细介绍着两种方式的运行机制。</p><p>在Module模式中，cmake需要找到一个叫做<code>Find&lt;LibraryName&gt;.cmake</code>的文件。这个文件负责找到库所在的路径，为我们的项目引入头文件路径和库文件路径。cmake搜索这个文件的路径有两个，一个是上文提到的cmake安装目录下的<code>share/cmake-&lt;version&gt;/Modules</code>目录，另一个使我们指定的<code>CMAKE_MODULE_PATH</code>的所在目录。</p><p>如果Module模式搜索失败，没有找到对应的<code>Find&lt;LibraryName&gt;.cmake</code>文件，则转入Config模式进行搜索。它主要通过<code>&lt;LibraryName&gt;Config.cmake</code> or <code>&lt;lower-case-package-name&gt;-config.cmake</code>这两个文件来引入我们需要的库。以我们刚刚安装的glog库为例，在我们安装之后，它在<code>/usr/local/lib/cmake/glog/</code>目录下生成了<code>glog-config.cmake</code>文件，而<code>/usr/local/lib/cmake/&lt;LibraryName&gt;/</code>正是find_package函数的搜索路径之一。（find_package的搜索路径是一系列的集合，而且在linux，windows，mac上都会有所区别，需要的可以参考官方文档<a href="https://cmake.org/cmake/help/latest/command/find_package.html">find_package</a>）</p><p>由以上的例子可以看到，对于原生支持Cmake编译和安装的库通常会安装Config模式的配置文件到对应目录，这个配置文件直接配置了头文件库文件的路径以及各种cmake变量供find_package使用。而对于非由cmake编译的项目，我们通常会编写一个<code>Find&lt;LibraryName&gt;.cmake</code>，通过脚本来获取头文件、库文件等信息。通常，原生支持cmake的项目库安装时会拷贝一份XXXConfig.cmake到系统目录中，因此在没有显式指定搜索路径时也可以顺利找到。</p><h3 id="编写自己的Find-lt-LibraryName-gt-cmake模块"><a href="#编写自己的Find-lt-LibraryName-gt-cmake模块" class="headerlink" title="编写自己的Find&lt;LibraryName&gt;.cmake模块"></a>编写自己的<code>Find&lt;LibraryName&gt;.cmake</code>模块</h3><p>假设我们编写了一个新的函数库，我们希望别的项目可以通过find_package对它进行引用我们应该怎么办呢。</p><p>我们在当前目录下新建一个<code>ModuleMode</code>的文件夹，在里面我们编写一个计算两个整数之和的一个简单的函数库。库函数以手工编写Makefile的方式进行安装，库文件安装在/usr/lib目录下，头文件放在/usr/include目录下。其中的Makefile文件如下：</p><pre class="line-numbers language-Makefile"><code class="language-Makefile"># 1、准备工作，编译方式、目标文件名、依赖库路径的定义。CC = g++CFLAGS  := -Wall -O3 -std=c++11 OBJS = libadd.o #.o文件与.cpp文件同名LIB = libadd.so # 目标文件名INCLUDE = ./ # 头文件目录HEADER = libadd.h # 头文件all : $(LIB)# 2. 生成.o文件 $(OBJS) : libadd.cc    $(CC) $(CFLAGS) -I ./ -fpic -c $< -o $@# 3. 生成动态库文件$(LIB) : $(OBJS)    rm -f $@    g++ $(OBJS) -shared -o $@     rm -f $(OBJS)# 4. 删除中间过程生成的文件 clean:    rm -f $(OBJS) $(TARGET) $(LIB)# 5.安装文件install:    cp $(LIB) /usr/lib    cp $(HEADER) /usr/include<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译安装</p><pre class="line-numbers language-sh"><code class="language-sh">makesudo make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>接下来我们回到我们的Cmake项目中来，在<code>cmake</code>文件夹下新建一个FindAdd.cmake的文件。我们的目标是找到库的头文件所在目录和共享库文件的所在位置。</p><pre class="line-numbers language-cmake"><code class="language-cmake"># 在指定目录下寻找头文件和动态库文件的位置，可以指定多个目标路径find_path(ADD_INCLUDE_DIR libadd.h /usr/include/ /usr/local/include ${CMAKE_SOURCE_DIR}/ModuleMode)find_library(ADD_LIBRARY NAMES add PATHS /usr/lib/add /usr/local/lib/add ${CMAKE_SOURCE_DIR}/ModuleMode)if (ADD_INCLUDE_DIR AND ADD_LIBRARY)    set(ADD_FOUND TRUE)endif (ADD_INCLUDE_DIR AND ADD_LIBRARY)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这时我们便可以像引用curl一样引入我们自定义的库了。</p><p>在CMakeLists.txt中添加</p><pre class="line-numbers language-cmake"><code class="language-cmake"># 将项目目录下的cmake文件夹加入到CMAKE_MODULE_PATH中，让find_pakcage能够找到我们自定义的函数库set(CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/cmake;${CMAKE_MODULE_PATH}")add_executable(addtest addtest.cc)find_package(ADD)if(ADD_FOUND)    target_include_directories(addtest PRIVATE ${ADD_INCLUDE_DIR})    target_link_libraries(addtest ${ADD_LIBRARY})else(ADD_FOUND)    message(FATAL_ERROR "ADD library not found")endif(ADD_FOUND)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="引入外部项目"><a href="#引入外部项目" class="headerlink" title="引入外部项目"></a>引入外部项目</h2><p>本节主要介绍如何引入外部项目源码作为自己项目的Library，与FindPackage引入头文件编译好的库不同的是，本节介绍的方法直接将第三方库源码引入到项目中，编译自己的项目时也会连同第三方库的源码一同编译。特别是当我们使用git等工具引入代码时，我们可以很方便地控制第三方代码的版本，防止本地安装的库文件版本与项目存在冲突。</p><h3 id="通过Submodle的方式引入"><a href="#通过Submodle的方式引入" class="headerlink" title="通过Submodle的方式引入"></a>通过Submodle的方式引入</h3><p>克隆spdlog作为项目的子项目</p><pre class="line-numbers language-sh"><code class="language-sh">git submodule add https://github.com/gabime/spdlog.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>本项目已经添加了submodule，所以在项目根目录执行以下命令初始化</p><pre class="line-numbers language-sh"><code class="language-sh">git submodule initgit submodule update<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>切换到我们需要的版本</p><pre class="line-numbers language-sh"><code class="language-sh">git checkout v1.4.2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们已经clone好了，现在只需要将spdlog作为subdirectory加入CMakeLists.txt当中就行了</p><pre class="line-numbers language-cmake"><code class="language-cmake">project(ImportExternalProject)cmake_minimum_required(VERSION 3.5)add_definitions(-std=c++11)  # 指定采用c++11进行编译（spdlog需要c++11）add_subdirectory(spdlog)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用FetchContent-CMake-3-11"><a href="#使用FetchContent-CMake-3-11" class="headerlink" title="使用FetchContent (CMake 3.11+)"></a>使用FetchContent (CMake 3.11+)</h3><p>使用FetchContent的步骤总结起来就是:</p><ul><li>使用FetchContent_Declare(MyName) 获取项目。可以是一个URL也可以是一个Git仓库。</li><li>使用FetchContent_GetProperties(MyName) 获取我们需要的变量MyName_*。</li><li>使用add_subdirectory(${MyName_SOURCE_DIR} ${MyName_BINARY_DIR})引入项目。</li></ul><p>在cmake3.14版本，官方又为我们提供了更方便的FetchContent_MakeAvailable方法，将步骤2，3集成在了一起。为了兼容3.11版本，我们可以把它封装成一个宏，这样我们就可以统一使用FetchContent_MakeAvailable方法了。</p><pre class="line-numbers language-cmake"><code class="language-cmake"># Campatible with cmake 3.11 and above.macro(FetchContent_MakeAvailable NAME)FetchContent_GetProperties(${NAME})if(NOT ${NAME}_POPULATED)    FetchContent_Populate(${NAME})    add_subdirectory(${${NAME}_SOURCE_DIR} ${${NAME}_BINARY_DIR})endif()endmacro()macro(FetchContent_MakeAvailable NAME)    FetchContent_GetProperties(${NAME})    if(NOT ${NAME}_POPULATED)        FetchContent_Populate(${NAME})        add_subdirectory(${${NAME}_SOURCE_DIR} ${${NAME}_BINARY_DIR})    endif()endmacro()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而后的第三方库cmake目录可以这么写：</p><pre class="line-numbers language-cmake"><code class="language-cmake"># 添加第三方依赖包include(FetchContent)# FetchContent_MakeAvailable was not added until CMake 3.14if(${CMAKE_VERSION} VERSION_LESS 3.14)    include(add_FetchContent_MakeAvailable.cmake)endif()set(SPDLOG_GIT_TAG  v1.4.1)  # 指定版本set(SPDLOG_GIT_URL  https://github.com/gabime/spdlog.git)  # 指定git仓库地址FetchContent_Declare(  spdlog  GIT_REPOSITORY    ${SPDLOG_GIT_URL}  GIT_TAG           ${SPDLOG_GIT_TAG})FetchContent_MakeAvailable(spdlog)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在CMakeLists.txt中，包含对应的第三方cmake，便可将spdlog作为library来使用了</p><pre class="line-numbers language-cmake"><code class="language-cmake">project(ImportExternalProject)cmake_minimum_required(VERSION 3.14)add_definitions(-std=c++11)  # 指定采用c++11进行编译（spdlog需要c++11）add_executable(test_spdlog testspdlog.cc)set(CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/cmake;${CMAKE_MODULE_PATH}")include(spdlog2)target_link_libraries(test_spdlog PRIVATE spdlog)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>本节主要介绍如何将项目生成的库文件、头文件、可执行文件或相关文件等安装到指定位置（系统目录，或发行包目录）。在cmake中，这主要是通过<code>install</code>方法在CMakeLists.txt中配置，<code>make install</code>命令安装相关文件来实现的。</p><h3 id="编写一个简单的库"><a href="#编写一个简单的库" class="headerlink" title="编写一个简单的库"></a>编写一个简单的库</h3><p>编写一个计算整数和浮点数之和的库函数mymath</p><p>mymath.h</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">ifndef</span> MYMATH_H</span><span class="token macro property">#<span class="token directive keyword">define</span> MYMATH_H</span><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">double</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>mymath.cpp</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"mymath.h"</span></span><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">double</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">double</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可执行程序mymathApp.cpp</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"mymath.h"</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">double</span> a <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1.1</span><span class="token punctuation">,</span> <span class="token number">1.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"1.1加1.1等于"</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"1加1等于"</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="编写CMakeLists"><a href="#编写CMakeLists" class="headerlink" title="编写CMakeLists"></a>编写CMakeLists</h3><p>在CMakeLists中添加配置</p><pre class="line-numbers language-cmake"><code class="language-cmake">cmake_minimum_required(VERSION 3.0)project(Installation VERSION 1.0)# 如果想生成静态库，使用下面的语句# add_library(mymath mymath.cc)# target_include_directories(mymath PUBLIC ${CMAKE_SOURCE_DIR}/include)# 如果想生成动态库，使用下面的语句add_library(mymath SHARED mymath.cc)target_include_directories(mymath PRIVATE  ${CMAKE_SOURCE_DIR}/include)set_target_properties(mymath PROPERTIES PUBLIC_HEADER ${CMAKE_SOURCE_DIR}/include/mymath.h)# 生成可执行文件add_executable(mymathapp mymathApp.cc)target_link_libraries(mymathapp mymath)target_include_directories(mymathapp PRIVATE ${CMAKE_SOURCE_DIR}/include)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来我们为生成的target配置安装目录。<code>install</code>方法的基础用法如下</p><pre class="line-numbers language-cmake"><code class="language-cmake">install(TARGETS MyLib        EXPORT MyLibTargets         LIBRARY DESTINATION lib  # 动态库安装路径        ARCHIVE DESTINATION lib  # 静态库安装路径        RUNTIME DESTINATION bin  # 可执行文件安装路径        PUBLIC_HEADER DESTINATION include  # 头文件安装路径        )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>LIBRARY, ARCHIVE, RUNTIME, PUBLIC_HEADER是可选的，可以根据需要进行选择。 DESTINATION后面的路径可以自行制定，根目录默认为<code>CMAKE_INSTALL_PREFIX</code>,可以试用<code>set</code>方法进行指定，如果使用默认值的话，Unix系统的默认值为 <code>/usr/local</code>, Windows的默认值为 <code>c:/Program Files/${PROJECT_NAME}</code>。比如字linux系统下若LIBRARY的安装路径指定为<code>lib</code>,即为<code>/usr/local/lib</code>。所以要安装<code>mymath mymathapp</code>我们可以这样写</p><pre class="line-numbers language-cmake"><code class="language-cmake"># 将库文件，可执行文件，头文件安装到指定目录install(TARGETS mymath mymathapp        EXPORT MyMathTargets        LIBRARY DESTINATION lib        ARCHIVE DESTINATION lib        RUNTIME DESTINATION bin        PUBLIC_HEADER DESTINATION include        )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>他人如果使用我们编写的函数库，安装完成后，希望可以通过<code>find_package</code>方法进行引用，这时我们需要怎么做呢。</p><p>首先我们需要生成一个<code>MyMathConfigVersion.cmake</code>的文件来声明版本信息</p><pre class="line-numbers language-cmake"><code class="language-cmake"># 写入库的版本信息include(CMakePackageConfigHelpers)write_basic_package_version_file(        MyMathConfigVersion.cmake        VERSION ${PACKAGE_VERSION}        COMPATIBILITY AnyNewerVersion  # 表示该函数库向下兼容        )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中<code>PACKAGE_VERSION</code>便是我们在<code>CMakeLists.txt</code>开头<code>project(Installation VERSION 1.0)</code>中声明的版本号</p><p>第二步我们将前面<code>EXPORT MyMathTargets</code>的信息写入到<code>MyLibTargets.cmake</code>文件中, 该文件存放目录为<code>${CMAKE_INSTALL_PREFIX}/lib/cmake/MyMath</code></p><pre class="line-numbers language-cmake"><code class="language-cmake">install(EXPORT MyMathTargets        FILE MyLibTargets.cmake        NAMESPACE MyMath::        DESTINATION lib/cmake/MyLib        )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后我们在源代码目录新建一个<code>MyMathConfig.cmake.in</code>文件,用于获取配置过程中的变量，并寻找项目依赖包。如果不一来外部项目的话，可以直接include <code>MyMathTargets.cmake</code>文件</p><pre class="line-numbers language-cmake"><code class="language-cmake">include(CMakeFindDependencyMacro)# 如果想要获取Config阶段的变量，可以使用这个# set(my-config-var @my-config-var@)# 如果你的项目需要依赖其他的库，可以使用下面语句，用法与find_package相同# find_dependency(MYDEP REQUIRED)# Any extra setup# Add the targets fileinclude("${CMAKE_CURRENT_LIST_DIR}/MyMathTargets.cmake")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后在CMakeLists.txt文件中，配置生成<code>MyMathTargets.cmake</code>文件，并一同安装到<code>${CMAKE_INSTALL_PREFIX}/lib/cmake/MyMath</code>目录中。</p><pre class="line-numbers language-cmake"><code class="language-cmake">configure_file(MyMathConfig.cmake.in MyMathConfig.cmake @ONLY)install(FILES "${CMAKE_CURRENT_BINARY_DIR}/MyMathConfig.cmake"                "${CMAKE_CURRENT_BINARY_DIR}/MyMathConfigVersion.cmake"        DESTINATION lib/cmake/MyMath        )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后我们在其他项目中，就可以使用</p><pre class="line-numbers language-cmake"><code class="language-cmake">find_package(MyMath 1.0)target_linked_library(otherapp MyMath::mymath)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>来引用我们的函数库了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;本文是知乎上HAN Bing写的CMake实战指南，加上一部分个人的理解和实践。&lt;/p&gt;
&lt;h2 id=&quot;使用find-package引入外
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="CMake" scheme="https://JoyTsing.github.io/tags/CMake/"/>
    
      <category term="Tool" scheme="https://JoyTsing.github.io/tags/Tool/"/>
    
  </entry>
  
  <entry>
    <title>MySQL技术内幕-InnoDB存储引擎</title>
    <link href="https://joytsing.github.io/posts/9398/"/>
    <id>https://joytsing.github.io/posts/9398/</id>
    <published>2024-03-20T15:46:10.000Z</published>
    <updated>2024-03-20T16:22:52.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这是一份读书笔记，之前一直写在本地没有上传到博客上，同步一下也方便自己。</p><h2 id="第1章-MYSQL体系结构和存储引擎"><a href="#第1章-MYSQL体系结构和存储引擎" class="headerlink" title="第1章 MYSQL体系结构和存储引擎"></a>第1章 MYSQL体系结构和存储引擎</h2><p><strong>数据库</strong>和<strong>实例</strong>：</p><blockquote><p><code>数据库</code>：物理操作系统文件或者其他形式文件类型的集合。在Mysql中，<strong>数据库文件可以是frm、ibd、MYD等形式的文件。</strong><br><code>实例</code>：<strong>Mysql数据库由后台线程以及一个共享内存区组成</strong>，而共享内存区可以被运行的后台线程共享。（数据库实例才是真正用于操作数据库文件的角色）<br>从概念上来说，数据库是文件的集合；数据库实例则是程序，是位于用户与操作系统之间的一层数据管理软件，所有对数据库的操作都要通过这层抽象层进行</p></blockquote><p>MySQL数据库实例在系统上的表现就是一个进程，<strong>用户对数据库数据的任何操作</strong>，包括数据库定义、数据查询、数据维护、数据库运行控制等<strong>都是在数据库实例下进行的</strong>，<strong>应用程序只有通过数据库实例才能和数据库打交道。</strong></p><p>MySQL具体的体系结构可以分为下面几种：</p><ol><li><strong>连接池</strong>：管理、缓冲用户的连接，线程处理等需要缓存的需求。</li><li><strong>管理服务和工具组件</strong>：系统管理和控制工具，例如备份恢复、Mysql复制、集群等 。</li><li><strong>sql接口</strong>：接受用户的SQL命令，并且返回用户需要查询的结果。</li><li><strong>查询解析器</strong>：SQL命令传递到解析器的时候会被解析器验证和解析。(权限、语法结构)</li><li><strong>查询优化器</strong>：SQL语句在查询之前会使用查询优化器对查询进行优化。</li><li><strong>缓存</strong>：如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。</li><li><strong>插入式存储引擎</strong>：存储引擎说白了就是如何管理操作数据（存储数据、如何更新、查询数据等）的一种方法。因为在关系数据库中数据的存储是以表的形式存储的，所以存储引擎也可以称为表类型。（即存储和操作此表的类型）</li><li><strong>物理文件</strong></li></ol><p>MySQL区别于其他数据的<strong>最重要的特点就是其插件式的表存储引擎</strong>，这个表存储引擎是基于表，而不是数据库，即进行存储操作等都是通过record等来进行操作。在你实际使用的过程中，存储引擎是透明的。</p><h3 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a>InnoDB引擎</h3><p>InnoDB是第一个完整支持ACID事务的Mysql存储引擎（DBD是第一个支持事务的InnoDB存储引擎，但是注意前面还带了个ACID！别搞混了）</p><ol><li><strong>InnoDB存储引擎支持事务</strong>，其特点是<strong>行锁设计、支持外键</strong>、支持非锁定锁（即默认读取操作不会产生锁）。并且Mysql5.5.8版本起，默认的存储引擎就是InnoDB了。</li><li>InnoDB通过<strong>使用多版本并发控制MVCC来获得高并发性，并且实现了SQL标准的4种隔离级别</strong>，默认是Repeatable级别（重复读）。</li><li><strong>使用一种被称为next-key的连接锁策略来避免幻读的产生</strong>。</li><li>InnoDB还<strong>提供了插入缓冲、二次写、自定义哈希索引、预读等4大特性</strong>。</li><li>InnoDB引擎采用了聚集的方式，因此每张表的存储都是按照主键的顺序进行存放。</li><li>如果没有显式的在表中定义主键，那么InnoDB会为每一行生成一个6字节大小的RowId，并以此为主键。（换句话说，无论咋样，一张表必有主键）</li></ol><p>拓展：</p><blockquote><p><code>那么Mysql的事务是怎么实现的？</code><br>Mysql的事务的实现即为ACID的实现：<br><strong>第一：事务的原子性是通过undo log来实现，也就是所谓的回滚操作。</strong> undo log记录了数据被修改之前的信息以及新增、删除的信息。undo log就是通过生成操作相反的sql语句来实现，举几个栗子🌰：<br>   1.若undo log中有新增记录，则生成删除该记录的sql。<br>   2.若undo log中有删除记录，则生成生成该记录的sql。<br>   3.若undo log中有修改记录，则生成修改至原先语句的sql。<br>因此，所谓的回滚操作就是根据undo log做一个逆向操作。<br><strong>第二：事务的持久性</strong>（这里就说几个重要的点，因为说白了，持久性跟存储有关）：<br>   1.<strong>redolog在提交commit前会写一次数据</strong>，顺序存储。<br>   2.InnoDB的二次写以及自带的buffer pool。<br><strong>第三：事务的隔离性则通过4种隔离级别来实现。</strong><br><strong>第四：事务的一致性：其实现依赖于以上3个特性的实现、即回滚、恢复、隔离机制。</strong></p></blockquote><h4 id="（1）存储策略和存储大小"><a href="#（1）存储策略和存储大小" class="headerlink" title="（1）存储策略和存储大小"></a>（1）存储策略和存储大小</h4><p>InnoDB存储数据的策略有两种：</p><ol><li>共享表空间存储方式。</li></ol><blockquote><p><strong>InnoDB的所有数据保存在一个单独的表空间里面</strong>，而这个表空间可以由很多歌文件组成，一个表可以跨多个文件存在，所以其大小限制不再是文件大小的限制，而是其自身的限制，<strong>官方指出InnoDB表空间的最大限制是64TB。</strong></p></blockquote><ol start="2"><li>独享表空间存储方式。</li></ol><blockquote><p>每个表的数据以一个单独的文件来存放，此时的单表限制，就变成文件系统的大小限制了。</p></blockquote><h4 id="（2）MVCC和隔离级别"><a href="#（2）MVCC和隔离级别" class="headerlink" title="（2）MVCC和隔离级别"></a>（2）MVCC和隔离级别</h4><p>上文提到了InnoDB通过使用多版本并发控制MVCC来获得高并发性，并且实现了SQL标准的4种隔离级别，那接下来就对这两点来进行阐述。</p><p>首先MVCC，全名多版本并发控制（Multi-Version Concurrency Control），是Mysql的InnoDB存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。</p><p><strong>基本思想：</strong> <strong>利用多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系。</strong>（在MVCC中事务的修改操作，delete、insert、update这3个操作会为数据行新增一个版本快照）。</p><p>接下来先把4个事务隔离级别的基本概念说清楚（等级从小到大依次排序）：</p><blockquote><ol><li>Read uncommitted（读未提交）：避免了更新丢失，却可能出现脏读。（<strong>表现：读写并行</strong>）</li><li>Read committed（读提交）：避免了脏读，但是可能出现不可重复度。（<strong>表现：MVCC、读写分离</strong>）</li><li>Repeatable read（重复读）：避免了不可重复读和脏读，但是有可能出现幻读。（默认的隔离级别，<strong>表现：读写锁、MVCC</strong>）</li><li>Serializable（序列化，也叫串行化）：事务只能一个接着一个的执行，不能并发执行，可以解决幻读问题。</li></ol><p>概念解释：<br><code>脏读</code></p><ol><li>A进行了一条数据操作，但是没有提交事务，如果此时B进行这条数据的查询，是可以查到A的数据操作结果的。  </li><li>后来A还没有提交事务，反而不提交了或者进行了事务回滚，那么B查询到的数据就是脏数据。<br><code>不可重复读（侧重于修改）</code><br>事务A多次读取到同一个数据，而B在A多次读取的过程中，对数据进行了修改，导致事务A多次多去同一个数据的时候，结果不一致。<br><code>幻读（侧重于增加或者删除）</code><br>再一次事务里面，多次查询之后，结果集的个数不一致的情况叫做幻读。而多或者少的那一行数据叫做幻行。</li></ol></blockquote><h4 id="（3）Next-Key-Locks"><a href="#（3）Next-Key-Locks" class="headerlink" title="（3）Next-Key Locks"></a>（3）Next-Key Locks</h4><p>MVCC不能解决幻读的问题，而Next-Key Locks就是为了解决这个问题而存在的。<strong>在可重复读级别下，使用MVCC+Next-Key Locks可以解决幻读问题。</strong></p><p><strong>一：Record Locks</strong>：<br><strong>锁定一个记录上的索引，而不是记录本身</strong>，如果表没有设置索引，由于InnoDB会自动加一个隐藏的主键，因此Record Locks依然可以使用。<br>记录锁其实很好理解，对表中的记录加锁，叫做记录锁，简称行锁。比如</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token punctuation">`</span>test<span class="token punctuation">`</span> <span class="token keyword">WHERE</span> <span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它会在 id=1 的记录上加上记录锁，以阻止其他事务插入，更新，删除 id=1 这一行。</p><p>需要注意的是：</p><ul><li><strong>id 列必须为唯一索引列或主键列</strong>，否则上述语句加的锁就会变成临键锁(有关临键锁下面会讲)。</li><li><strong>同时查询语句必须为精准匹配（=）</strong>，不能为 &gt;、&lt;、like等，否则也会退化成临键锁。</li></ul><p>其他实现比如，在通过 <strong>主键索引</strong> 与 <strong>唯一索引</strong> 对数据行进行 UPDATE 操作时，也会对该行数据加记录锁：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- id 列为主键列或唯一索引列 </span><span class="token keyword">UPDATE</span> <span class="token keyword">SET</span> age <span class="token operator">=</span> <span class="token number">50</span> <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>记录锁是锁住记录，锁住索引记录，而不是真正的数据记录</strong>.如果要锁的列没有索引，则会进行全表记录加锁，同时<code>记录锁也是排它(X)锁</code>,所以会阻塞其他事务对其<strong>插入、更新、删除</strong>。</p><p><strong>二：Gap Locks：</strong><br>锁定索引之间的间隙，但是不包含索引本身。间隙锁是Innodb在RR(可重复读) 隔离级别下为了解决<code>幻读问题</code>时引入的锁机制。<strong>间隙锁是innodb中行锁的一种</strong>。使用间隙锁锁住的是一个<strong>区间</strong>，而<strong>不仅仅是这个区间中的每一条数据</strong>。</p><p>举例来说，假如emp表中只有101条记录，其empid的值分别是1,2,…,100,101，下面的SQL：</p><pre class="line-numbers language-sql"><code class="language-sql">  <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> emp <span class="token keyword">WHERE</span> empid <span class="token operator">></span> <span class="token number">100</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当我们用条件检索数据，并请求共享或排他锁时，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。这个时候如果你插入empid等于102的数据的，如果那边事物还没有提交，那你就会处于等待状态，无法插入数据。</p><p><strong>三：临键锁</strong>：</p><p><strong>Next-key锁是记录锁和间隙锁的组合，它指的是加在某条记录以及这条记录前面间隙上的锁</strong>。即不仅锁定一个记录上的索引，也锁定索引之间的缝隙。他锁定一个前开后闭的区间，例如一个索引包含以下值：10，11，13，20，那么就会锁定这么几个区间：</p><blockquote><p>(-∞，10]，(10,11]，(11,13]，(13,20]，(20,+∞)</p></blockquote><p>也可以理解为一种特殊的<strong>间隙锁</strong>。通过<strong>临建锁</strong>可以解决<code>幻读</code>的问题。 每个数据行上的<strong>非唯一索引列</strong>上都会存在一把<strong>临键锁</strong>，当某个事务持有该数据行的<strong>临键锁</strong>时，会锁住一段<strong>左开右闭区间</strong>的数据。</p><p>需要强调的一点是，InnoDB 中<strong>行级锁</strong>是基于索引实现的，<strong>临键锁</strong>只与<strong>非唯一索引列</strong>有关，在<code>唯一索引列（包括主键列）上不存在临键锁</code>。</p><p><strong>四：总结：</strong></p><p>这里对 <strong>记录锁</strong>、<strong>间隙锁</strong>、<strong>临键锁</strong> 做一个总结</p><ul><li><strong>InnoDB</strong> 中的<strong>行锁</strong>的实现依赖于<strong>索引</strong>，一旦某个加锁操作没有使用到索引，那么该锁就会退化为<code>表锁</code>。</li><li><strong>记录锁</strong>存在于包括<strong>主键索引</strong>在内的<strong>唯一索引</strong>中，锁定单条索引记录。</li><li><strong>间隙锁</strong>存在于<strong>非唯一索引</strong>中，锁定<strong>开区间</strong>范围内的一段间隔，它是基于<strong>临键锁</strong>实现的。</li><li><strong>临键锁</strong>存在于<strong>非唯一索引</strong>中，该类型的每条记录的索引上都存在这种锁，它是一种特殊的<strong>间隙锁</strong>，锁定一段<strong>左开右闭</strong>的索引区间</li></ul><h4 id="（4）InnoDB的4大特性"><a href="#（4）InnoDB的4大特性" class="headerlink" title="（4）InnoDB的4大特性"></a>（4）InnoDB的4大特性</h4><ol><li><strong>插入缓冲</strong>（insert buffer）：对于非聚簇类索引的插入和更新操作，如果该索引页在缓存中，那么直接插入，先插入到缓冲区中，再以一定的频率和索引页合并。</li><li><strong>二次写</strong>（double write）：写数据前，将数据线写入一块独立的物理文件位置（ibdata）然后再写入数据页中。</li><li><strong>自定义哈希索引</strong>（ahi）：自定义哈希索引即将字典类型的索引通过哈希函数映射于一张表，让查询的时候更加迅速。</li><li><strong>预读</strong>（read ahead）：InnoDB在IO的优化上做出了预读机制，就是发起一个IO请求，异步地在缓冲池中预先回迁若干页面，预计把可能用到的数据页返回。</li></ol><h3 id="MyISAM引擎（了解）"><a href="#MyISAM引擎（了解）" class="headerlink" title="MyISAM引擎（了解）"></a>MyISAM引擎（了解）</h3><p>和InnoDB引擎相比，MyISAM不支持事务、表锁设计，但是<strong>支持全文索引</strong>。MyISAM存储引擎的<strong>另一个与众不同的地方是他的缓冲池只缓存索引文件而不缓存数据文件。</strong> 另外，还记得上文提到，InnoDB的最大存储限度有一个64TB，Mysql5以上的时候，<strong>如果用的是MyISAM引擎，那么支持256TB的单表数据。</strong> 并且使用MyISAM存储引擎表，MySQL只缓存索引文件，数据文件缓存则是交给操作系统。</p><h5 id="MyISAM和InnoDB的区别"><a href="#MyISAM和InnoDB的区别" class="headerlink" title="MyISAM和InnoDB的区别"></a>MyISAM和InnoDB的区别</h5><table><thead><tr><th>比较内容</th><th>MyISAM</th><th>InnoDB</th><th></th></tr></thead><tbody><tr><td>构成上的区别</td><td>每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。</td><td>基于磁盘的资源是InnoDB表空间数据文件和它的日志文件，InnoDB 表的大小只受限于操作系统文件的大小，一般为 2GB</td><td></td></tr><tr><td>是否支持事务</td><td>不支持</td><td>支持</td><td></td></tr><tr><td>支持的锁</td><td>行锁</td><td>表锁</td><td></td></tr><tr><td>是否有MVCC</td><td>不支持</td><td>支持</td><td></td></tr><tr><td>是否支持外键</td><td>不支持</td><td>支持</td><td></td></tr><tr><td>是否支持全文索引</td><td>支持</td><td>不支持</td><td></td></tr><tr><td>操作的速度</td><td>建议如果执行大量的select语句，使用MyISAM</td><td>如果数据执行大量的insert和update操作，出于性能考虑，使用InnoDB表</td><td></td></tr><tr><td>表的具体行数</td><td>MyISAM会保存好表中的行数，因此对于count操作很快</td><td>InnoDB则没有，需要扫描一遍全表计算</td><td></td></tr></tbody></table><p>一个极具迷惑性的提问：当表的数据量大于1000万时候MySQL的性能会急剧下降吗？</p><blockquote><p>MySQL是数据库，不是文件，随着数据行数增加性能必然会下降，但这些下降不是线性的，如果在对应业务情况下使用合适的存储引擎与配置，那么这些数据量是能承受住的。如在官方手册上所说的InnoDB 1TB数据。</p></blockquote><h2 id="第2章-InnoDB存储引擎"><a href="#第2章-InnoDB存储引擎" class="headerlink" title="第2章 InnoDB存储引擎"></a>第2章 InnoDB存储引擎</h2><h3 id="InnoDB体系架构"><a href="#InnoDB体系架构" class="headerlink" title="InnoDB体系架构"></a>InnoDB体系架构</h3><p>InnoDB内有多个内存块，这些内存块组成一个大的内存池，负责维护数据的写、访问以及日记的记录，这些内存块由多个后台线程负责处理，来适应不同的任务。</p><p>这些后台线程的任务主要用来：</p><p>（1）Master Thread</p><ul><li>负责将缓冲池的数据异步刷新到磁盘</li><li>保证数据一致性：包括脏页的刷新、合并插入缓冲池、undo页的回收<br>在后续的更新里，Innodb 1.2.x把刷新脏页从主线程里面分离到了PageCleanerTherad线程中</li></ul><p>Master Thread内部由多个循环loop组成，并且在多个循环状态之间切换。</p><ul><li>主循环（loop）</li><li>后台循环（background loop）</li><li>刷新循环（flush loop）</li><li>暂停循环（suspend loop）</li></ul><p>大部分操作在主循环中，分为每秒的操作和每十秒的操作，每秒的操作包括：</p><blockquote><p>1.日志缓冲刷新到磁盘，即使这个事务还没有提交。（总是）<br>2.合并插入缓冲。（可能）<br>3.最多刷新100个InnoDB的缓冲池中的脏页到磁盘。（可能）<br>4.如果当前没有用户活动，则切换到background loop后台循环。（可能）<br>——-background loop执行的操作：<br>——-1.删除无用的Undo页。（总是）<br>——-2.合并20个插入缓冲。（总是）<br>——-3.跳回到主循环。（总是）<br>——-4.不断刷新100个页直到符合条件。（可能）</p></blockquote><p>每十秒的操作包括：</p><blockquote><p>1.刷新100个脏页到磁盘。（可能）<br>2.合并最多5个插入缓冲（总是）<br>3.将日志缓冲刷新到磁盘。（总是）<br>4.删除无用的Undo页。（总是）<br>5.刷新100个或者10个脏页到磁盘。（总是）</p></blockquote><p>（2） IO Thread<br>InnoDB中使用了大量的<strong>AIO来处理写IO请求</strong>，以便提高数据库的性能，<strong>而IO Thread的工作就是负责这些IO请求的回调处理。</strong> 其中比较重要的几个线程为write IO Thread（默认4个）、read IO Thread（默认4个）、insert buffer IO Thread、log IO Thread</p><p>（3)）Purge Thread<br>事务被提交后，其所用的undolog可能不再需要，那么则需要一个线程去回收已经使用并分配的undo页。而做这份工作的线程就叫做Purge Thread。</p><p>（4）Page Cleaner Thread<br>Page Cleaner Thread的作用<strong>是将之前版本中脏页的刷新操作都放入到单独的线程中去完成。</strong> 其目的：减轻原Mster Thread的工作及对于用户查询线程的阻塞，进一步提高InnoDB的性能。</p><h3 id="Innodb内存"><a href="#Innodb内存" class="headerlink" title="Innodb内存"></a>Innodb内存</h3><h4 id="（1）缓冲池"><a href="#（1）缓冲池" class="headerlink" title="（1）缓冲池"></a>（1）缓冲池</h4><p><img src="/posts/9398/image-20231109162323130.png" alt></p><p><strong>InnoDB存储引擎是基于磁盘存储的，并且将其中的记录按照页的方式进行管理。</strong> 而基于磁盘的数据库系统，因为存储设备速率的差距，通常需要使用缓冲池技术来提高数据库的整体性能，从上图可以看到，缓冲池并不是简单的一个k-v map。</p><p>缓冲池作为内存中最大的一块，也包含了很多数据页类型：索引页、数据页、undo页、插入缓冲、自定义哈希索引、锁信息、数据字典信息等。同时InnoDB存储引擎还<strong>允许有多个缓冲池实例，</strong> 相当于自适应哈希索引中的多个哈希桶。</p><h4 id="（2）InnoDB的LRU算法"><a href="#（2）InnoDB的LRU算法" class="headerlink" title="（2）InnoDB的LRU算法"></a>（2）InnoDB的LRU算法</h4><p>InnoDB存储引擎则使用了<strong>一种经过优化的LRU算法</strong>来堆缓冲池进行管理，即在LRU的基础上增加了一个<code>midpoint</code>的位置，新读取到的页并不会直接放入到LRU列表的首部，而是放到LRU列表的<code>midpoint</code>位置。默认情况下，这个位置在LRU列表长度的5/8处。即新读取的页给放在LRU列表尾端3/8的位置，midpoint之后的为old列表，之前的为new列表，new列表为频繁访问的数据。</p><p>问题1：<strong>为什么不采用普通的LRU算法，直接将读取的页放入到LRU列表的首部呢？</strong></p><blockquote><p> 如果直接吧读取到的页放入到LRU列表的首部，那么某些SQL操作可能会使缓冲池中的页被刷新出，从而影响缓冲池的效率。</p></blockquote><p>问题2：<strong>所谓的会将缓冲池中的页刷新出的SQL某些操作是什么？为什么会影响呢？</strong></p><blockquote><p>1.如索引或者数据的扫描操作。<br>2.比如全表扫描，需要访问到表中的全部页，<strong>问题是缓冲池的大小是有限的，那么我这次全表扫描，如果全部放入到LRU列表的首部，那么非常可能会将比较重要的热点数据页从LRU列表中移出</strong>，当下一次需要读取热点数据的时候，又得去访问磁盘。<br>3.此外，InnoDB还引入一个时间参数<strong>innodb_old_blocks_time</strong>来保证：页读取到mid位置后需要等待多久会被加入到LRU列表的热端（new部分），以尽可能的让LRU列表中热点数据不被移出。</p></blockquote><p>InnoDB引擎在1.0.x版本就开始支持页的压缩功能了。原本页的大小是16K，现在可以压缩为1、2、4、8KB，而这些非16KB的页，通过unzip_LRU列表来管理。</p><p>unzip_LRU列表对不同压缩页大小的页进行分别管理，例如需要从缓冲池中申请页为4KB的大小，过程如下：</p><ol><li>检查4KB的unzip_LRU列表,检查是否有可用的空闲页。</li><li>如果有，直接使用。</li><li>如果没有，检查8KB的unzip_LRU列表。</li><li>如果能够得到空闲页，将页分成2个4KB页，存放到4KB的unzip_LRU列表。</li><li>如果不能得到空闲页，从LRU列表中申请一个16KB的页，将页分为1个8KB的页、2个4KB的页，分别存放到对应的unzip_LRU列表中。</li></ol><p><strong>在LRU列表中的页如果被修改了，那么这种页叫做脏页。</strong> 即缓冲池中的页he磁盘上的页的数据产生了不一致，而<strong>这个时候数据库会通过Checkpoint机制将脏页刷新到磁盘，而Flush列表中的页即为脏页列表。</strong></p><p><strong>注意：</strong></p><ul><li><strong>脏页既存在于LRU列表，也存在与Flush列表中。</strong></li><li><strong>LRU列表用来管理缓冲池中页的可用性，Flush列表用来管理将页刷新到磁盘，两者是独立的互相不影响的。</strong></li></ul><h4 id="（3）重做日志缓冲"><a href="#（3）重做日志缓冲" class="headerlink" title="（3）重做日志缓冲"></a>（3）重做日志缓冲</h4><p>InnoDB存储引擎的内存区域除了有缓冲池外，还有重做日志缓冲（redo log buffer）。<strong>InnoDB存储引擎首先将重做日志信息放到该缓冲区中，然后按照一定的频率将其刷新到重做日志文件中，默认重做日志缓冲的大小为8MB，参数由innodb_log_buffer_size控制</strong></p><p>缓冲刷新至文件的3种时机：</p><ul><li>Master Thread每秒将重做日志缓冲刷新到重做日志文件。</li><li>每个事务提交的时候会将重做日志缓冲刷新到重做日志文件。</li><li>当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件。</li></ul><h4 id="（4）额外内存池"><a href="#（4）额外内存池" class="headerlink" title="（4）额外内存池"></a>（4）额外内存池</h4><p>在InnoDB存储引擎中，<strong>堆内存的管理是通过一种称为内存堆的方式进行的</strong>。在对一些数据结构本身的内存进行分配的时候，<strong>需要从额外的内存池中进行申请，当该区域的内存不够的时候，才会从缓冲池进行申请。</strong></p><h3 id="Checkpoint"><a href="#Checkpoint" class="headerlink" title="Checkpoint"></a>Checkpoint</h3><p>为了避免数据库发生数据丢失，当前事务数据库系统普遍采用了一种策略叫做：<strong>Write Ahead Log策略。</strong> <strong>即事务提交的时候，先写重做日志，再修改页</strong>。而发生宕机而导致数据丢失的时候，就可以通过重做日志来完成数据的恢复。</p><p>Checkpoint技术的目的就是解决以下几个问题：</p><ol><li>缩短数据库的恢复时间。</li><li>缓冲池不够用，将脏页刷新到磁盘。</li><li>重做日志不可用时，刷新脏页。</li></ol><blockquote><p>重做日志出现不可用的原因？<br>回答：<br>因为当前事务数据库系统对重做日志的设计都是循环使用的，并不是让日志无限增大，重做日志可以被重用的部分是指这些日志已经不再需要了，那么这部分就可以被覆盖。但是万一覆盖之后，之前的部分又需要使用了，那么必须强制产生Checkpoint，将缓冲池中的页至少刷新到当前重做日志的位置。</p></blockquote><p>此外，当数据库发生宕机需要恢复的时候，不需要重做所有的日志，<strong>因为Checkpoint之前的页已经能保证刷新到磁盘中了，所以数据库只需要对之后的重做日志进行恢复即可</strong>，这样大大缩短了恢复的时间。并且，当缓冲池不够用的时候，根据LRU算法会把最近最少使用的页给移除，如果该页为脏页，那么需要强制执行Checkpoint，将脏页刷回磁盘。</p><p>InnoDB存储引擎内部有两种Checkpoint：</p><ul><li><p>Sharp Checkpoint：<strong>发生在数据库关闭时，将所有的脏页刷新到磁盘，默认工作方式。</strong> 通过参数<code>innodb_fast_shutdown=1</code>实现</p></li><li><p>Fuzzy Checkpoint：<strong>只刷新一部分脏页。</strong> 使用Fuzzy Checkpoint的情况：</p></li><li><p>Master Thread Checkpoint</p></li></ul><blockquote><p>以每秒或者每十秒的速度从缓冲池的脏页列表中刷新一定比例的页回到磁盘。</p></blockquote><ul><li>FLUSH_LRU_LIST Checkpoint</li></ul><blockquote><p><strong>因为InnoDB引擎需要保证LRU列表中需要有差不多100个空闲页可供使用，所以如果没有足够的空闲页，那么InnoDB引擎会将LRU列表尾端的页移除，那如果有脏页，则进行Checkpoint。</strong> 通过参数innodb_lru_scan_depth指定，默认1024</p></blockquote><ul><li>Async/Sync Flush Checkpoint</li></ul><blockquote><p>指的是重做日志文件不可用的情况，这时候需要强制将一些页刷新到磁盘，为了保证重做日志的循环使用。</p></blockquote><ul><li>Dirty Page too much Checkpoint</li></ul><blockquote><p>当脏页的数量太多，导致InnoDB存储引擎强制进行Checkpoint，目的是为了保证缓冲池中有足够的可用的页。通过参数innodb_max_dirty_pages_pct控制</p></blockquote><p>默认大小75%，即缓冲池中脏页数量占据75%时候，强制进行Checkpoint，刷新一部分的脏页到磁盘。</p><h3 id="InnoDB关键特性"><a href="#InnoDB关键特性" class="headerlink" title="InnoDB关键特性"></a>InnoDB关键特性</h3><h4 id="插入缓冲"><a href="#插入缓冲" class="headerlink" title="插入缓冲"></a>插入缓冲</h4><h5 id="Insert-Buffer"><a href="#Insert-Buffer" class="headerlink" title="Insert Buffer"></a>Insert Buffer</h5><p>在InnoDB存储引擎中，主键是行唯一的标识符大家都知道，<strong>通常应用程序中行记录的插入顺序是按照主键递增的顺序进行插入的。</strong> 也因此，插入聚簇索引一般是顺序的，不需要磁盘的随机读取。 </p><p>问题来了：一张表一般除了一个主键，还有多个非聚簇索引，我这里假设一张表中的聚簇索引为a，非聚簇索引为b，如：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> t<span class="token punctuation">(</span><span class="token number">a</span> <span class="token keyword">int</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span> <span class="token number">b</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span><span class="token number">a</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span><span class="token number">b</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>那么这张表在进行插入操作的时候，页的存放还是按照主键a进行顺序存放的，但是对于非聚簇索引b的叶子节点的插入不再是顺序的了，这时候需要离散的访问非聚簇索引页，即随机读取。（B+树的特性决定了非聚簇索引插入的离散型）。</strong></p><p>那么，InnoDB存储引擎开创了Insert Buffer的目的是啥呢？</p><blockquote><p>对于非聚簇索引的插入或者更新操作，不是每一次都直接插入到索引页中，<strong>而是先判断插入的非聚簇索引页是否在缓冲池中。</strong><br>如果在——&gt;直接插入。<br><strong>如果不在——&gt;先放入到Insert Buffer对象中，然后再以一定的频率将Insert Buffer和辅助索引页子节点进行合并操作。</strong><br>那么这时候能够将多个插入合并到一个操作中，就大大提高了对于非聚簇索引插入的性能。</p></blockquote><p>那么以我的理解：</p><ol><li>把Insert Buffer<strong>看做是一个大容器</strong>，把每次非聚簇索引的插入当做一次任务。</li><li><strong>因为非聚簇索引的插入具有离散型，那么如果把多个非聚簇索引的插入绑定在一块</strong>，形成一个大的插入事件，提高插入性能。</li></ol><p>使用Insert Buffer需要满足的条件，有俩：</p><ol><li>索引是辅助索引（非聚簇）。</li><li>索引不是唯一的（unique）。</li></ol><h5 id="Change-Buffer"><a href="#Change-Buffer" class="headerlink" title="Change Buffer"></a>Change Buffer</h5><p>前面的Insert Buffer可以说是针对非聚簇索引的插入操作，那么自从InnoDB1.0.x版本后，引入了Insert Buffer的升级版：Change Buffer，可以对DML操作（insert，update，delete）都进行缓冲，这里分别对应了Insert Buffer、Purge Buffer、Delete Buffer，使用参数<code>innodb_change_buffering</code>来开启各种Buffer选项。（默认是all，即全开启）</p><p>值得注意的是，因为Change Buffer是升级版，所以它适用的对象依然是非唯一的辅助索引，比如对一条记录进行update操作可以分为2个过程：</p><ol><li>将记录标记为已删除。（对应Delete Buffer）</li><li>真正将记录删除。（对应Purge Buffer）</li></ol><h5 id="Insert-Buffer的内部实现原理"><a href="#Insert-Buffer的内部实现原理" class="headerlink" title="Insert Buffer的内部实现原理"></a>Insert Buffer的内部实现原理</h5><p><strong>Insert Buffer的数据结构是一颗B+树。</strong> 目前版本全局只有一颗Insert Buffer B+树，<strong>负责对所有的表的辅助索引进行Insert Buffer。这颗B+树存放在共享表空间中，默认是ibdata1中，其非叶子节点存放的是查询的search key（键值）</strong></p><p>search key的结构：<br><img src="/posts/9398/image-20231109210839840.png" alt></p><ol><li>space（4字节）：待插入记录所在表的表空间id（唯一），可以通过该id得知哪张表。</li><li>marker（1字节）：兼容老版本的Insert Buffer。</li><li>offset（4字节）：页所在的偏移量</li></ol><p><strong>插入原理：</strong><br>当一个辅助索引需要插入到页中的时候，<strong>如果这个也不在缓冲池中，那么InnoDB存储引擎首先会根据上述的数据结构构造一个search key</strong>，接下来查询Insert Buffer这颗B+树，然后江浙条记录插入到其叶子节点中。</p><p><strong>插入后的结构：</strong><br>如图：Insert Buffer叶子节点中的记录，相比之前，多了一个metadata<br><img src="/posts/9398/4.png" alt><br>其中metadata的存储内容包括（4字节）：<br><img src="/posts/9398/5.png" alt><br><strong>其中IBUF_REC_OFFSET_COUNT用来排序每个记录进入Insert Buffer的顺序。</strong> 并且这里大家可以看出，Insert Buffer的B+树存储叶子节点，需要额外的13字节的开销（9字节的search key和4字节的metadata），后续的列表就是记录的实际字段了。</p><h4 id="Merge-Insert-Buffer"><a href="#Merge-Insert-Buffer" class="headerlink" title="Merge Insert Buffer"></a>Merge Insert Buffer</h4><p>插入缓冲的时候，如果插入记录的辅助索引页不在缓冲池中，记录将插入到Insert Buffer B+树中。<strong>那么什么时候把Insert Buffer的记录合并到真正的辅助索引中呢？</strong> </p><p>直接总的来说，Merge Insert Buffer的时机有这么3种：</p><ol><li>辅助索引页被读取到缓冲池。</li></ol><blockquote><p>比如执行select操作，这时候需要先检查Insert Buffer Bitmap页，确认该辅助索引页是否有记录存放在Insert Buffer B+树中，如果有，则把树中的记录插入到辅助索引页中。<br><strong>注意，注意：大家可以理解为，Insert Buffer B+树只是一个中间件，缓存记录的地方，而辅助索引页是辅助索引记录的最终归宿。</strong></p></blockquote><ol start="2"><li>Insert Buffer Bitmap页追踪到该辅助索引页已经没有可用空间的时候。</li></ol><blockquote><p>若插入辅助索引记录时检测到插入记录后辅助索引页的可用空间小于1/32，那么这个时候会强制进行Merge Insert Buffer。</p></blockquote><ol start="3"><li>Master Thread。</li></ol><blockquote><p>每秒或者每十秒会进行一次Merge Insert Buffer操作。</p></blockquote><p>上文多次提到了Insert Buffer Bitmap，这里来稍微解释下是个啥东西：<br><strong>为了保证每次Merge Insert Buffer页必须成功，需要一个特殊的页来标记每个辅助索引页的可用空间，而这个也的类型为Insert Buffer Bitmap。</strong></p><p>其结构：<br><img src="/posts/9398/20201209145959330.png" alt></p><h4 id="二次写"><a href="#二次写" class="headerlink" title="二次写"></a>二次写</h4><p><strong>Insert Buffer带给InnoDB存储引擎的是性能上的提升，而二次写（doublewrite）带给他的是数据页的可靠性。</strong></p><p>再讲二次写之前，先给解释两个专有名词：<strong>写失效</strong></p><blockquote><p>当发生数据库宕机的时候，可能InnoDB存储引擎正在写入某个页到表中，而这个页中只写了一部分，比如一共16KB的页，只写了前4KB，之后发生了宕机，那么这种情况称之为写失效。</p></blockquote><p>虽然发生写失效的时候，可以通过重做日志来进行恢复，<strong>但是重做日志中记录的是对页的物理操作，如果这个页本身发生了损坏，那么重做是没有意义的。</strong> 因此，我们需要在重做日志前，用户需要一个页的副本，当写入失效发生的时候，<strong>先通过页的副本来还原，再进行重做，这就是二次写。</strong></p><p>doublewrite的结构如下，由两个部分组成：</p><ul><li>一部分是内存中的doublewrite buffer，大小为2MB。</li><li>一部分是物理磁盘上共享表空间中连续的128个页，大小为2MB。</li></ul><p><img src="/posts/9398/6.png" alt></p><p><strong>工作原理：</strong></p><ol><li>在对缓冲池的脏页进行刷新时，并不直接写磁盘，而是通过memcpy函数将脏页<strong>先复制到内存当中的doublewrite buffer。</strong></li><li>之后通过doublewrite buffer分两次操作，每次1MB，<strong>顺序的写入共享表空间的物理磁盘上。</strong></li><li><strong>调用fsync函数，同步磁盘</strong>，避免缓冲写带来的问题。</li><li>完成doublewrite页的写入后，<strong>再将doublewrite buffer中的页写入各个表空间文件中。</strong></li></ol><p>问题：如果操作系统在将页写入磁盘的过程中发生了崩溃，怎么办？</p><blockquote><p>回答：<br>恢复过程中，InnoDB存储引擎可以<strong>从共享表空间中的doublewrite中找到该页的一个副本，将其复制到表空间文件中，再应用重做日志进行恢复。</strong></p></blockquote><h4 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h4><p>首先大家应该知道一点，哈希是一种非常快的查找方法，一般时间复杂度为O（1），B+树的查找次数，取决于B+树的高度。<strong>InnoDB会监控表上各个索引页的查询，如果说观察到建立哈希索引可以带来速度提升，那么会建立一个哈希索引，也就是自适应哈希索引（Adaptive Hash Index ，AHI）。</strong></p><p><strong>AHI是通过缓冲池的B+树页构造而来</strong>，因此建立的速度很快，<strong>InnoDB会自动根据访问的频率和模式来自动的为某一些热点页建立哈希索引，并且默认AHI功能默认开启。</strong></p><h4 id="异步IO和刷新邻接页"><a href="#异步IO和刷新邻接页" class="headerlink" title="异步IO和刷新邻接页"></a>异步IO和刷新邻接页</h4><p>首先说下<strong>异步IO</strong>：<br>很简单，就是用户发起一个IO请求后立即在发送一个IO请求，当所有IO请求发送完毕后，等待所有IO操作的完成，<strong>核心是无需等待第一个IO请求的返回结果。</strong></p><p>AIO的另一个优势就是可以进行IO Merge操作，也就是将多个IO操作合并为1个IO，这样可以提高IOPS（可以视为是每秒的读写次数）的性能。这里举一个书中的例子：</p><blockquote><p>例如用户需要访问页的（space，page_no）为：(8,6)，(8,7)，(8,8)<br>那么每个页的大小为16KB，那么同步IO需要进行3次IO操作，而AIO会判断到这3个页是连续的，因此AIO底层会发送一个IO请求，从（8，6）开始，一次性读取48KB的页。</p></blockquote><p>再来说下<strong>刷新邻接页</strong>：<br>InnoDB存储引擎提供了刷新邻接页（Flush Neighbor Page）的特性，其工作原理为：</p><ol><li>当刷新一个脏页的时候，InnoDB存储引擎<strong>会检测到该页所在区的所有页</strong>。</li><li><strong>如果是脏页，那么一个区的所有页一起进行刷新</strong>。</li></ol><p>通过AIO可以将多个IO写入操作合并为一个IO操作，那么该工作机制在传统的机械硬盘下肯定是有显著的优势，但是也产生了俩问题：</p><ul><li>如果将不怎么脏的页进行了写入，但是之后页又很快变成了脏页咋办？</li><li>固态硬盘有着较高的IOPS，是否还需要这个特性？</li></ul><h2 id="第3章-文件"><a href="#第3章-文件" class="headerlink" title="第3章 文件"></a>第3章 文件</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;这是一份读书笔记，之前一直写在本地没有上传到博客上，同步一下也方便自己。&lt;/p&gt;
&lt;h2 id=&quot;第1章-MYSQL体系结构和存储引擎&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://JoyTsing.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
      <category term="读书笔记" scheme="https://JoyTsing.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="MySql" scheme="https://JoyTsing.github.io/tags/MySql/"/>
    
      <category term="数据库" scheme="https://JoyTsing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>如何用lambda表达式快速刷题</title>
    <link href="https://joytsing.github.io/posts/34936/"/>
    <id>https://joytsing.github.io/posts/34936/</id>
    <published>2024-03-20T08:50:48.000Z</published>
    <updated>2024-03-20T09:14:37.148Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>好吧，我承认文章题目有点标题党了，总的来说就是用lambda表达式让你能够在一个函数之内解决战斗(本人很不喜欢刷题的时候拆开写函数)，只要用到递归的地方都能够使用。</p><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>什么是函数式编程就不展开说了，这里主要用到Lambda演算理论中的<code>Y Combinator</code>，通过它我们可以实现匿名的递归调用函数。关于它的解释，一般是所谓的“懂的都懂”，感兴趣的可以去了解一下，这里只讲怎么用。具体来说，就是在c++中，如果你想在lambda表达式中递归调用自己是不行的(当然后面能够做到，不然也就没这篇文章了)，编译器会提示你此时还未定义，那么怎么做呢，就是通过<code>Y Combinator</code>，这也不卖关子了，其实就是把函数自身当成参数传进去即可，这样就可以调用了是不是？</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="/posts/34936/image-20240320170607932.png" alt></p><p>具体怎么写递归不在这篇文章的范围，如果我们想用lambda表达式的话我们应该怎么写？实际上看下面的代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">auto</span> func<span class="token operator">=</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> func<span class="token punctuation">,</span>Node<span class="token operator">*</span> node<span class="token punctuation">,</span><span class="token keyword">int</span> depth<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>depth<span class="token punctuation">)</span><span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            res<span class="token punctuation">[</span>depth<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> child<span class="token operator">:</span>node<span class="token operator">-</span><span class="token operator">></span>children<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">func</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span>child<span class="token punctuation">,</span>depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token function">func</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span>root<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>lambda表达的第一个参数不一定要和定义的lambda变量重名，可以叫别的名字(通常起名为self)，这样写的目的是方便直观的调用，比如下面这样：</p><p><img src="/posts/34936/image-20240320171019481.png" alt></p><p>代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>TreeNode <span class="token operator">*</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> dfs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> self<span class="token punctuation">,</span> TreeNode <span class="token operator">*</span>root<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">int</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">self</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token function">self</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">max</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>dfs<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>细心的可能发现了为什么第一种写法的参数需要用<code>&amp;&amp;</code>而第二个不需要，感兴趣的话可以在下面评论区留言。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>其实一切的起因还是归咎于本人懒，加上代码能力一般实在不想背非递归调用的板子，还是觉得在能保证正确的情况下行数越少逻辑越清晰越好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;好吧，我承认文章题目有点标题党了，总的来说就是用lambda表达式让你能够在一个函数之内解决战斗(本人很不喜欢刷题的时候拆开写函数)，只要用
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="Leetcode" scheme="https://JoyTsing.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Cpp对象模型</title>
    <link href="https://joytsing.github.io/posts/28140/"/>
    <id>https://joytsing.github.io/posts/28140/</id>
    <published>2024-03-15T07:51:17.000Z</published>
    <updated>2024-03-20T16:24:32.801Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>C++对象模型，启动！</p><h2 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h2><ul><li>简单对象模型(A Simple Object Model)</li></ul><p>对象保存成员的指针，成员实际存放在其他区域.</p><p>这种模型保证了成员中每个元素需要的内存空间都是一样的, 不论元素是何种类型, 访问时只需要确定成员的index和对象首地址即可. 坏处是访问成员时需要多进行一次内存访问, 并且占用了更多的内存空间.</p><ul><li>表格驱动对象模型(A Table-driven Object Model)</li></ul><p>将对象中的数据成员和函数成员分别组织, 放在不同的内存区域, 对象中保存了指向这两个内存区域的指针.</p><p>这种模型保证了不同类型的对象具有相同的内存布局,</p><h2 id="C-对象模型"><a href="#C-对象模型" class="headerlink" title="C++对象模型"></a>C++对象模型</h2><p>每个有虚函数的类产生一个virtual table, 保存所有虚函数的指针, 对象在所在内存开始位置保存指向 vtable 的指针 vptr. 在调用类的虚函数时, 会沿着虚函数表搜索, 第一个满足条件的就是要调用的函数. 在调用类的构造函数, 复制构造函数等时这些函数会自动处理类的vptr. 比如下面的代码中, 假设类Base 是Derived的父类, 二者都定义了函数f(), 那么自然就有vptr. 在第二行中, 调用了Base的复制构造函数, 对象d会被截断, 并且b的vptr会在复制构造函数中设置, 因此第三行中b调用的是Base中的f(). 另外一个值得注意的是, 运行时多态只能通过指针和引用来实现.</p><pre class="line-numbers language-cpp"><code class="language-cpp">Derived d<span class="token punctuation">;</span>Base b <span class="token operator">=</span> b<span class="token punctuation">;</span>b<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>单继承且无继承时, 每个对象只有一个vptr, 而当存在虚继承时, 虚继承的直接子类还会产生一个附加的 vptr, 指向自身的virtual table. 当存在多继承时, 会为每个父类产生一个vptr. 下面针对这些情况 详细举例说明.</p><ul><li>单继承, 无虚继承时的对象模型</li></ul><p>这是最简单的情况, 在对象的开始处保存一个vptr指针, 指向一个虚函数指针数组, 非静态数据成员按继承, 声明的顺序排列.</p><ul><li>单继承, 有虚继承时的对象模型</li></ul><p>采用虚继承的类会在产生多个vptr, 对象开始处是父类的vptr, 父类成员之后, 子类成员之前保存子类的vptr. 如下:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">BB</span><span class="token punctuation">{</span>    int64_t m_bb<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B1</span> <span class="token operator">:</span> <span class="token keyword">public</span> <span class="token keyword">virtual</span> BB<span class="token punctuation">{</span>    int64_t m_b1<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">DD</span> <span class="token operator">:</span> <span class="token keyword">public</span> B1<span class="token punctuation">{</span>    int64_t m_dd<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">D1</span> <span class="token operator">:</span> <span class="token keyword">public</span> DD<span class="token punctuation">{</span>    int64_t m_d1<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// D1对象的结构, gcc 8.2.0, GNU gdb 8.1.1</span><span class="token comment" spellcheck="true">// 注意, 这是在gdb中查看的结果, 并不代表真正的对象内存布局. 比如多继承, 有虚继承的情况.</span><span class="token punctuation">{</span>    <span class="token operator">&lt;</span>DD<span class="token operator">></span> <span class="token operator">=</span>    <span class="token punctuation">{</span>        <span class="token operator">&lt;</span>B1<span class="token operator">></span> <span class="token operator">=</span>        <span class="token punctuation">{</span>            <span class="token operator">&lt;</span>BB<span class="token operator">></span> <span class="token operator">=</span>            <span class="token punctuation">{</span>                _vptr<span class="token punctuation">.</span>BB <span class="token operator">=</span> <span class="token operator">&lt;</span>vtable <span class="token keyword">for</span> D1<span class="token operator">+</span><span class="token number">112</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 父类的vptr</span>                m_bb            <span class="token punctuation">}</span><span class="token punctuation">,</span>            _vptr<span class="token punctuation">.</span>B1 <span class="token operator">=</span> <span class="token operator">&lt;</span>vtable <span class="token keyword">for</span> D1<span class="token operator">+</span><span class="token number">24</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 虚继承子类B1的vptr</span>            m_b1        <span class="token punctuation">}</span><span class="token punctuation">,</span>        m_dd    <span class="token punctuation">}</span><span class="token punctuation">,</span>    m_d1 <span class="token comment" spellcheck="true">// 没有采用虚继承, 因此与基类BB共用vptr.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>继承, 无虚继承时的对象模型</li></ul><p>保留多个父类的vptr.</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">BB</span><span class="token punctuation">{</span>    int64_t m_bb<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B1</span> <span class="token operator">:</span> <span class="token keyword">public</span> BB<span class="token punctuation">{</span>    int64_t m_b1<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B2</span> <span class="token operator">:</span> <span class="token keyword">public</span> BB<span class="token punctuation">{</span>    int64_t m_b2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">DD</span> <span class="token operator">:</span> <span class="token keyword">public</span> B1<span class="token punctuation">,</span> B2<span class="token punctuation">{</span>    int64_t m_dd<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// DD对象的结构, gcc 8.2.0, GNU gdb 8.1.1</span><span class="token punctuation">{</span>    <span class="token operator">&lt;</span>B1<span class="token operator">></span> <span class="token operator">=</span>    <span class="token punctuation">{</span>        <span class="token operator">&lt;</span>BB<span class="token operator">></span> <span class="token operator">=</span>        <span class="token punctuation">{</span>            _vptr<span class="token punctuation">.</span>BB <span class="token operator">=</span> <span class="token operator">&lt;</span>vtable <span class="token keyword">for</span> DD<span class="token operator">+</span><span class="token number">16</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// B1的vptr</span>            m_bb        <span class="token punctuation">}</span><span class="token punctuation">,</span>        m_b1    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token operator">&lt;</span>B2<span class="token operator">></span> <span class="token operator">=</span>    <span class="token punctuation">{</span>        <span class="token operator">&lt;</span>BB<span class="token operator">></span> <span class="token operator">=</span>        <span class="token punctuation">{</span>            _vptr<span class="token punctuation">.</span>BB <span class="token operator">=</span> <span class="token operator">&lt;</span>vtable <span class="token keyword">for</span> DD<span class="token operator">+</span><span class="token number">80</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// B2的vptr</span>            m_bb        <span class="token punctuation">}</span><span class="token punctuation">,</span>        m_b2    <span class="token punctuation">}</span><span class="token punctuation">,</span>    m_dd <span class="token comment" spellcheck="true">// 与基类B1共用vptr.</span><span class="token punctuation">}</span>BB <span class="token operator">*</span>bp <span class="token operator">=</span> <span class="token keyword">new</span> DD<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 错误, 有歧义</span>BB <span class="token operator">*</span>bp1 <span class="token operator">=</span> <span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span>B1<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> DD<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正确, bp1指向DD中的B1部分.</span>BB <span class="token operator">*</span>bp2 <span class="token operator">=</span> <span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span>B2<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> DD<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正确, bp2指向DD中的B2部分.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很自然地, 当用BB类型的指针/引用保存DD对象时, 就会出现歧义, 编译器无法确定采用B1中的BB还是B2中BB. 可以使用 dynamic_cast 进行干预, 以达到预期目的.</p><ul><li>多继承, 有虚继承时的对象模型<br>有了上面的结论, 就不难推测这种情况下的对象模型了.</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">BB</span><span class="token punctuation">{</span>    int64_t m_bb<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B1</span> <span class="token operator">:</span> <span class="token keyword">virtual</span> <span class="token keyword">public</span> BB<span class="token punctuation">{</span>    int64_t m_b1<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B2</span> <span class="token operator">:</span> <span class="token keyword">virtual</span> <span class="token keyword">public</span> BB<span class="token punctuation">{</span>    int64_t m_b2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">DD</span> <span class="token operator">:</span> <span class="token keyword">public</span> B1<span class="token punctuation">,</span> B2<span class="token punctuation">{</span>    int64_t m_dd<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// DD对象的结构, gcc 8.2.0, GNU gdb 8.1.1</span><span class="token punctuation">{</span>    <span class="token operator">&lt;</span>B1<span class="token operator">></span> <span class="token operator">=</span>    <span class="token punctuation">{</span>        <span class="token operator">&lt;</span>BB<span class="token operator">></span> <span class="token operator">=</span>        <span class="token punctuation">{</span>            _vptr<span class="token punctuation">.</span>BB <span class="token operator">=</span> <span class="token operator">&lt;</span>vtable <span class="token keyword">for</span> DD<span class="token operator">+</span><span class="token number">160</span><span class="token operator">></span><span class="token punctuation">,</span>            m_bb <span class="token operator">=</span> <span class="token number">1</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        _vptr<span class="token punctuation">.</span>B1 <span class="token operator">=</span> <span class="token operator">&lt;</span>vtable <span class="token keyword">for</span> DD<span class="token operator">+</span><span class="token number">24</span><span class="token operator">></span><span class="token punctuation">,</span>        m_b1    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token operator">&lt;</span>B2<span class="token operator">></span> <span class="token operator">=</span>    <span class="token punctuation">{</span>        _vptr<span class="token punctuation">.</span>B2 <span class="token operator">=</span> <span class="token operator">&lt;</span>vtable <span class="token keyword">for</span> DD<span class="token operator">+</span><span class="token number">88</span><span class="token operator">></span><span class="token punctuation">,</span>        m_b2    <span class="token punctuation">}</span><span class="token punctuation">,</span>    m_dd<span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 实际内存布局可能是:</span><span class="token punctuation">{</span>    <span class="token operator">&lt;</span>B1<span class="token operator">></span> <span class="token operator">=</span>    <span class="token punctuation">{</span>        vptr<span class="token punctuation">.</span>B1<span class="token punctuation">,</span>        m_b1    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token operator">&lt;</span>B2<span class="token operator">></span> <span class="token operator">=</span>    <span class="token punctuation">{</span>        vptr<span class="token punctuation">.</span>B2<span class="token punctuation">,</span>        m_b2    <span class="token punctuation">}</span>    m_dd<span class="token punctuation">,</span>    <span class="token operator">&lt;</span>BB<span class="token operator">></span> <span class="token operator">=</span>    <span class="token punctuation">{</span>        vptr<span class="token punctuation">.</span>BB<span class="token punctuation">,</span>        m_bb    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="关键字class和struct的区别"><a href="#关键字class和struct的区别" class="headerlink" title="关键字class和struct的区别"></a>关键字class和struct的区别</h2><p>二者在绝大多数情况下是完全相同的, 可以互换, 只有几点不同.</p><p>class可以用于模板声明, struct不可以. C++引入class关键字, 保留struct的一个原因是为了体现OO, 并且兼容C, 而C中不需要模板, 也就不需要保证struct可以用于模板.</p><p>另外, 当用于声明类类型时二者略有差别:</p><ul><li>用class声明的类的成员的默认访问级别是private, 用struct声明的类的成员的默认访问级别是public.</li><li>有继承时, 用class声明的类的默认继承方式是private, 用struct声明的类的默认继承方式是public. 这里的class, struct是指用于子类, 父类的声明方式不影响默认方式. 如下代码:</li></ul><pre class="line-numbers language-text"><code class="language-text">class BB {};class D1 : BB {}; // private继承struct D2 : BB {}; // public继承 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="运行时多态必须通过public继承实现"><a href="#运行时多态必须通过public继承实现" class="headerlink" title="运行时多态必须通过public继承实现"></a>运行时多态必须通过public继承实现</h2><p>这个设计是符合逻辑的. 可以设想, 如果使用其他继承方式, 那么从逻辑上说, 在类外不应该能访问父类成 员. 但是要实现运行时多态, 正常做法是将子类指针/引用赋值给一个父类类型的指针/引用(设为bp), 一旦复制成功, 我们就可以通过bp访问父类的public成员, 这显然与前面的逻辑要求矛盾. 所以, 在C++中, 前面说得”赋值”是违法的. 而没有这个”赋值”操作, 也就无法实现运行时多态, 因此必须通过public继承实现运行时多态.</p><h2 id="Default-Constructor的构造操作"><a href="#Default-Constructor的构造操作" class="headerlink" title="Default Constructor的构造操作"></a>Default Constructor的构造操作</h2><p><strong>默认构造函数(default constructor)的定义</strong>:</p><blockquote><p>一个可以以空参数列表调用的构造函数称为默认构造函数, 这有两种情形, 一种是构造函数参数列表为空, 另一种是每个参数都在声明中给出了默认值.</p></blockquote><p>默认构造函数可以是自己定义的, 也可以由编译器自动生成. 当用户没有定义任何构造函数时, 编译器就会为用户生成一个参数列表为空的默认构造函数.</p><p><strong>trivial default constructor(无用默认构造函数)</strong></p><blockquote><p>满足下面所有的条件时, 一个默认构造函数是trivial的: - 不是由用户提供的, 即是由编译器生成的或者声明为default. - 类没有虚成员函数 - 类没有虚基类 - 类没有默认初始化的非静态成员 - 直接基类有trivial default constructor - 非静态类成员有trivial default constructor<br>显然, trivial default constructor不进行任何操作. 所有与C语言兼容的数据类型(POD类型)都具有trivial default constructor.</p></blockquote><h3 id="带有default-constructor的member-class-object"><a href="#带有default-constructor的member-class-object" class="headerlink" title="带有default constructor的member class object"></a>带有default constructor的member class object</h3><p>编译器会为没有定义构造函数的类合成默认构造函数, 但是这个合成操作只有在构造函数真正需要被调用时才会发生.</p><p>那么在C++不同编译模块中, 编译器怎么避免生成多个默认构造函数呢? 解决方法是把合成的默认构造函数, 复制构造函数, 析构函数, 赋值运算符都作为inline, 而inline函数是静态链接(static linkage)的, 不会被编译模块(即文件)以外的看到. 如果函数太复杂, 作为inline不合适, 就会合成一个显式non-inline静态(explicit non-inline static)实例.</p><p>我们知道, 类对象是必须要初始化的, 当一个类的成员有其他类对象时, 就必须在构造函数中对类成员进行初始化. 如果是编译器合成的默认构造函数, 就在合成的默认构造函数中按类成员声明顺序调用它们的默认构造函数(当然, 如果没有就会引起错误). 注意一点, 对于显式定义的构造函数函数, 如果没有对部分类成员对象的初始化, 编译器会自动插入一些代码, 使得用户代码被执行之前, 先调用必要的默认构造函数, 调用顺序与它们的声明相同. 但是如果有的对象显式调用了构造函数, 有的没有, 顺序是如何确定的呢? 仍然按照它们的声明顺序调用.</p><h3 id="“带有default-constructor”的Base-Class"><a href="#“带有default-constructor”的Base-Class" class="headerlink" title="“带有default constructor”的Base Class"></a>“带有default constructor”的Base Class</h3><p>如果一个子类的基类带有默认构造函数, 那么在合成子类的构造函数时, 会在其中插入对基类的默认构造函 数会的调用代码, 这个代码在成员的默认构造函数调用代码之前. 即先初始化基类, 再按声明顺序初始化子 类成员.</p><h3 id="“带有一个Virtual-Function”的Class"><a href="#“带有一个Virtual-Function”的Class" class="headerlink" title="“带有一个Virtual Function”的Class"></a>“带有一个Virtual Function”的Class</h3><p>对于带有虚函数的类, 不论是直接声明的还是直接/间接继承而来的, 都有虚函数表, 对应对象有虚函数表指 针(vptr)作为数据成员. 那么vptr是如何确定的呢? 显然, 虚函数表是在编译阶段就可以确定的, 因此由 编译器合成. 但是vptr的确定就要分情况讨论了:</p><ul><li>对于静态初始化的对象, vptr由编译器初始化.</li><li>对于动态初始化的对象, <strong>vptr由构造函数初始化</strong>. 因此编译器会在所有的构造函数中插入一些代码来完成这个任务.</li></ul><h3 id="“带有一个Virtual-Base-Class”的Class"><a href="#“带有一个Virtual-Base-Class”的Class" class="headerlink" title="“带有一个Virtual Base Class”的Class"></a>“带有一个Virtual Base Class”的Class</h3><p>当存在虚基类时, 通过虚基类指针/引用访问其非虚函数, 数据成员时, 应该是不属于多态的, 但是仍然在 运行时才能决定. 指针所指对象的实际类型很多时候是未知的, 在不同类型中, 由于采用了虚继承, 同一变 量偏移可能不一样(这是由实现决定的), 简而言之就是编译器不知道成员在指针所指对象的什么位置. 因此, 存在虚基类时, 就需要提供某种方法, 使我们能够通过虚基类指针访问虚基类的非虚函数和数据成员. 一种 方法是在子类中插入一个指向虚基类的指针, 将原始的通过虚基类指针访问那些成员的代码替换为先访问这个 指针, 再访问成员的代码. 如下所示:</p><pre class="line-numbers language-cpp"><code class="language-cpp">virtualBasePointer<span class="token operator">-</span><span class="token operator">></span>virtualBaseData<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 原始代码</span>virtualBasePointer<span class="token operator">-</span><span class="token operator">></span>virtualBaseVptr<span class="token operator">-</span><span class="token operator">></span>virtualBaseData<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 编译器替换后的代码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>而这个<strong>虚基类指针的初始化</strong>就是由构造函数完成的.</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li>类的默认构造函数只有真正需要时才会被合成, 而不是没有定义构造函数时就会合成.</li><li>对于一个类的所有类成员对象, 如果没有显式初始化, 编译器会对其进行默认初始化. 但是对于内置类型, 例如int, 指针类型等, 不会进行初始化, 这是程序员的工作.</li></ol><h2 id="Copy-Constructor的构造操作"><a href="#Copy-Constructor的构造操作" class="headerlink" title="Copy Constructor的构造操作"></a>Copy Constructor的构造操作</h2><p>3种情况下会调用复制构造函数:</p><ol><li>用一个对象作为参数初始化另一个对象时.</li><li>对象作为函数参数时, 会用参数对象在函数作用域构造一个新的对象.</li><li>对象作为返回值时, 会用函数内部的对象在返回值所在作用域构造一个新的对象.</li></ol><p>注意, 2, 3不一定会发生, 因为可能会存在右值参数, 返回值优化等, 具体情况不做详述.</p><p>如果不显式定义复制构造函数, 编译器有两种复制对象的方法: bitwise copy和default memberwise copy, 区别如下:</p><ul><li>bitwise copy并不调用复制构造函数, 可能的实现方式如利用memcpy等, 因此效率更高, 复制出的对象和原对象完全相同.</li><li>default memberwise copy就如同对每个成员分别赋值一样, 对于内置类型, 直接初始化, 对于类类型, 递归调用其默认复制构造函数来初始化. 默认构造函数是由编译器合成的, 或者被声明为default. 其产生的新对象的用户定义的数据成员与原对象是一样的, 但是隐式的成员(如vptr), 内存布局(子类初始化父类)等不一定相同.</li></ul><blockquote><p><strong>注意:</strong><br>bitwise copy和浅复制(shallow copy)是不同的, 浅复制更侧重于当在类内部保存指针成员, 用指针指向实际数据的时候, 复制时仅仅复制指针的值. 这种情况包含在bitwise copy中.</p></blockquote><p>那么在没有定义复制构造函数的时候, 编译器在什么情况下采用bitwise copy, 在什么情况下合成默认复制构造函数(即采用default memberwise copy)? 下面四种情况, 会采用后者, 其他情况采用前者.</p><ol><li>当类含有类对象成员, 且这个成员含有复制构造函数时(不论是编译器合成的还是显式定义的).</li><li>当类继承自一个基类, 并且基类含有复制构造函数时(不论是编译器合成的还是显式定义的).</li><li>当类含有虚函数时.</li><li>当类有虚基类时.</li></ol><p>上面的情况很容易理解. 对于1和2, 由于复制对象时, 要复制数据成员和基类, 既然它们提供了复制构造函数, 就可以认为需要在它们的复制构造函数中进行某些bitwise copy无法实现的操作, 因此不能采用bitwise copy. 对于3, 由于含有虚函数, 所以需要初始化对象的vtpr, 而vptr的值显然不一定等于参数对象的值, 例如用子类对象初始化父类对象时. 所以bitwise不能满足需求. 对于4, 由于含有虚基类, 父子基类的内存布局可能存在区别, 更不能采用bitwise copy.</p><p>当合成/用户定义的复制构造函数的语意和bitwise copy相同时, 是否应该用bitwise copy替换复制构造函数?</p><h2 id="程序转化语意学-Program-Transformation-Semantics"><a href="#程序转化语意学-Program-Transformation-Semantics" class="headerlink" title="程序转化语意学(Program Transformation Semantics)"></a>程序转化语意学(Program Transformation Semantics)</h2><p>尽管在程序中可以使用不同的形式来初始化一个类对象, 但在编译阶段都会被转化成相同的形式. 例如:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">X</span><span class="token punctuation">;</span>X <span class="token function">x0</span><span class="token punctuation">(</span>paras<span class="token punctuation">)</span><span class="token punctuation">;</span>X x1 <span class="token operator">=</span> <span class="token function">X</span><span class="token punctuation">(</span>paras<span class="token punctuation">)</span><span class="token punctuation">;</span>X <span class="token function">x2</span><span class="token punctuation">(</span>x0<span class="token punctuation">)</span><span class="token punctuation">;</span>X x3 <span class="token operator">=</span> x0<span class="token punctuation">;</span>X x4 <span class="token operator">=</span> <span class="token function">X</span><span class="token punctuation">(</span>x0<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>会被转化为:</p><pre class="line-numbers language-cpp"><code class="language-cpp">X x0<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 声明但不初始化</span>X x1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 声明但不初始化</span>X x2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 声明但不初始化</span>X x3<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 声明但不初始化</span>X x4<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 声明但不初始化</span><span class="token comment" spellcheck="true">// 调用构造函数初始化对象</span>x0<span class="token punctuation">.</span>X<span class="token operator">::</span><span class="token function">X</span><span class="token punctuation">(</span>paras<span class="token punctuation">)</span>x1<span class="token punctuation">.</span>X<span class="token operator">::</span><span class="token function">X</span><span class="token punctuation">(</span>paras<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 调用复制构造函数初始化对象</span>x2<span class="token punctuation">.</span>X<span class="token operator">::</span><span class="token function">X</span><span class="token punctuation">(</span>x0<span class="token punctuation">)</span>x3<span class="token punctuation">.</span>X<span class="token operator">::</span><span class="token function">X</span><span class="token punctuation">(</span>x0<span class="token punctuation">)</span>x4<span class="token punctuation">.</span>X<span class="token operator">::</span><span class="token function">X</span><span class="token punctuation">(</span>x0<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数复制优化和返回值优化(都是指省略不必要的复制构造函数的调用, 后面统称为复制优化或copy elision)</p><p>从C++17开始, 标准规定了必须进行copy elision的情况:</p><ul><li>类似下面的情形:</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp">T t <span class="token operator">=</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token function">T</span><span class="token punctuation">(</span><span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 只会调用一次默认构造函数, 要求类型相同(不考虑cv).</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>在返回类对象时, 如果直接在return语句中创建对象, 并且该对象与函数返回值类型一致(不考虑cv)时, 一般称这个优化为RVO(return value optimization)(注意, RVO在C++17之前都不是强制的, 从C++17开始才规定为mandatory的.), 如下例子:</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp">T <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">return</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>T t <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 只会调用一次默认构造函数.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样也规定了可以实施copy elision, 但不强制的情况, 比如NRVO(named return value optimization), 是指函数返回一个具名对象, 该对象是函数体内部定义的自动存储期变量, 并且是non-volatile的, 与函数返回值具有相同类型(不考虑cv). 具体可以参考<a href="https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/language/copy_elision">copy elision</a></p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ol><li>只有当存在复制构造函数(不论是显式定义的还是编译器生成的)时, 编译器才有可能实施复制优化.</li><li>谨慎对待copy elision, 因为类设计者可能需要在复制/移动构造函数中进行某些特殊操作, 省略了之后可能带来难以调试的错误.</li></ol><h2 id="成员初始化列表-Member-Initialization-List"><a href="#成员初始化列表-Member-Initialization-List" class="headerlink" title="成员初始化列表(Member Initialization List)"></a>成员初始化列表(Member Initialization List)</h2><p>应该用成员初始化列表来初始化变量的情况:</p><ol><li>初始化一个引用时.</li><li>初始化一个常量成员时.</li><li>调用基类的构造函数, 并且这个构造函数有一组参数时.</li><li>调用类成员的构造函数, 并且这个构造函数有一组参数时.</li></ol><p>类成员的初始化顺序与初始化列表的顺序无关, 而是与成员在类声明中的顺序一致. 所以, 尽量使初始化列表的顺序与声明顺序一致, 最好不要用一个成员来初始化另一个成员. 在编译阶段, 会将初始化列表转化为成员的初始化代码, 并置于构造函数体内的代码之前.</p><p>注意一点, 用成员函数的返回值来作为初始化列表的参数语法上是没有问题的, 但是需要保证这个成员函数不依赖于成员的数据对象, 因为很可能这个在调用此函数时还没有初始化其依赖的数据成员, 这就会引起难以发现的错误. 另外, 最好不要将其用于初始化基类成员, 详情见后面的讨论.</p><h2 id="不含数据成员的类对象"><a href="#不含数据成员的类对象" class="headerlink" title="不含数据成员的类对象"></a>不含数据成员的类对象</h2><p>对于不存在继承和虚函数的类, 没有数据成员时, 其大小至少是1 byte, 以保证变量有唯一的地址. 当加上虚函数后, 由于有虚函数指针, 对象大小等于一个指针的大小, 32位系统中是4 bytes, 64位系统中是8 bytes. 看下面的代码:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Empty <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> VirtualEmpty<span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Empty a<span class="token punctuation">;</span>Empty b<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Empty<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出为1</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>VirtualEmpty<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出为8</span>cout<span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>a<span class="token operator">&lt;&lt;</span><span class="token string">' '</span><span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>b<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 在输出中可以看到b的地址比a的地址大一.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是, 当其作为基类时, 在某些情况下则不必遵循上面的要求, 可以在子类中将其优化掉, 节省所占空间. 例如下面的情况:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Base <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> Derived <span class="token operator">:</span> Base<span class="token punctuation">{</span>    int64_t i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Base<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出为1</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Derived<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl <span class="token comment" spellcheck="true">// 输出为8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显然这里没有必要保留额外空间来表示基类对象. 上面说过, 为空对象保留空间的原因是保证其有唯一地址, 避免出现不同对象的地址相同的情形. 但是在这里, 子类地址就可以作为父类地址, 不会出现不同对象地址相同的情形. 但是即使是继承, 也有不能进行优化的情况:</p><ul><li>子类的第一个非静态数据成员的类型和空基类相同.</li><li>子类的第一个非静态数据成员的基类类型和空基类相同.</li></ul><p>不难看出, 这两种情况下, 会有两个空基类对象(父类对象和子类数据成员对象)连续出现, 如果优化掉, 将不能区别二者. 示例如下:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Base <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> Derived1 <span class="token operator">:</span> Base <span class="token comment" spellcheck="true">// 情况一</span><span class="token punctuation">{</span>    Base b<span class="token punctuation">;</span>    int64_t i<span class="token punctuation">;</span><span class="token punctuation">}</span>d1<span class="token punctuation">;</span><span class="token keyword">struct</span> Derived2<span class="token punctuation">{</span>    Base b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> Derived3 <span class="token operator">:</span> Base<span class="token punctuation">{</span>    Derived2 d2<span class="token punctuation">;</span>    int64_t i<span class="token punctuation">;</span><span class="token punctuation">}</span>d3<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Derived1<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出为16, 基类对象和成员b各占1 byte, 由于内存对齐补齐8 bytes</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Derived2<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出为1</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Derived3<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出为16, 基类对象和成员d2各占1 byte, 由于内存对齐补齐8 bytes</span>cout<span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>d1<span class="token operator">&lt;&lt;</span><span class="token string">' '</span><span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>d1<span class="token punctuation">.</span>b<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 前者(基类对象地址)比后者小1</span>cout<span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>d3<span class="token operator">&lt;&lt;</span><span class="token string">' '</span><span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>d3<span class="token punctuation">.</span>d2<span class="token punctuation">.</span>b<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 前者(基类对象地址)比后者小1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于空类作为虚基类的情况, 同样可以进行优化. 例如下面的代码:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Base <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> Derived1 <span class="token operator">:</span> <span class="token keyword">virtual</span> Base <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> Derived2 <span class="token operator">:</span> <span class="token keyword">virtual</span> Base <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> Derived3 <span class="token operator">:</span> Derived1<span class="token punctuation">,</span> Derived1 <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> Derived4 <span class="token operator">:</span> Derived1<span class="token punctuation">,</span> Derived1<span class="token punctuation">{</span>    Base b<span class="token punctuation">;</span><span class="token punctuation">}</span>d4<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Derived3<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出为16</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Derived4<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出为24</span>cout<span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>d4<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出为0x55c6986ffe70</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span>Base<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d4<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出为0x55c6986ffe70</span>cout<span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>d4<span class="token operator">-</span><span class="token operator">></span>b<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出为0x55c6986ffe80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了实现虚继承, 类Derived1和Derived2包含一个指针. 而虚基类Base被优化掉了, 因此Derived3大小为16 bytes. 而Derived4中由于包含类型是Base的非静态成员, 需要占据8 bytes, 即Derived4大小为24 bytes. 注意这里基类被优化了, 子类数据成员没有被优化. 测试显示, 即使这个成员不是第一个或最后一个, 编译器仍然不会优化.</p><p>虽然标准没有规定非静态数据成员在内存中的排列顺序, 但是一般实现都是按照声明顺序排列. 而由于内存对齐的要求, 仅仅改变成员的声明顺序可能产生不同大小的对象, 例如下面的声明:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Test1 <span class="token comment" spellcheck="true">// 大小为16 bytes</span><span class="token punctuation">{</span>    int64_t i1<span class="token punctuation">;</span>    <span class="token keyword">char</span> c1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// c1 和 c2 被放置在一个字(16 bytes)中</span>    <span class="token keyword">char</span> c2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> Test2 <span class="token comment" spellcheck="true">// 大小为24 bytes</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> c1<span class="token punctuation">;</span>    int64_t i1<span class="token punctuation">;</span>    <span class="token keyword">char</span> c2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> Test3 <span class="token comment" spellcheck="true">// 大小为16 bytes</span><span class="token punctuation">{</span>    int64_t i1<span class="token punctuation">;</span>    int32_t i2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// i2,c1,c2 被放置在一个字(16 bytes)中</span>    <span class="token keyword">char</span> c1<span class="token punctuation">;</span>    <span class="token keyword">char</span> c2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于计算机是以字(32位机为4 bytes, 64位机为8 bytes)为单位来读写, 因此内存对齐可以加快存取操作. 否则当一个变量跨字时, 读取这个变量就需要两次内存读. 但是这可能会增加需要的内存空间, 这就需要程序员仔细安排变量顺序, 以保证获得最佳的空间利用率.</p><p>而对于普通类的静态数据成员, 则具有独立于对象的静态生存期, 保存在全局数据段中. 模板类的静态数据成员如果没有被显式特化或实例化, 则在使用时会被隐式特化, 只有当特化/实例化后才是有效定义的. 有下面几种情况, 而这几种都可以归到C++14引入的 <em>variable template</em>(变量模板), 参考<a href="https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/language/variable_template">cppreference</a>.</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Test1<span class="token punctuation">{</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span> <span class="token keyword">static</span> T val<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 非模板类的模板静态成员.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span> T Test1<span class="token operator">::</span>val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">struct</span> Test2<span class="token punctuation">{</span>    <span class="token keyword">static</span> T val<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 模板类的非模板静态成员.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span> T Test2<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token operator">></span><span class="token keyword">struct</span> Test3<span class="token punctuation">{</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T2<span class="token operator">></span> <span class="token keyword">static</span> std<span class="token operator">::</span>pair<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token operator">></span> val<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 模板类的模板静态成员.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token operator">></span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T2<span class="token operator">></span>std<span class="token operator">::</span>pair<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token operator">></span> Test2<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token operator">::</span>val <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token function">T1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">T2</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> var <span class="token operator">=</span> Test3<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>val<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 即pair&lt;int, float>(1, 2)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数据成员的存取"><a href="#数据成员的存取" class="headerlink" title="数据成员的存取"></a>数据成员的存取</h2><h3 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h3><p>对静态成员, 通过对象或对象指针访问和通过类名访问没有区别, 编译器一般会将二者统一为相同形式. 类成员指针不能指向静态成员, 因为对静态成员取地址得到的是一个该成员的指针. 如:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>A<span class="token operator">::</span>x<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 其类型是 int*</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为类静态成员都是保存在全局数据段中, 如果不同类具有相同名字的静态成员, 就需要保证不会发生名称冲突. 编译器的解决方法是对每个静态数据成员编码(这种操作称为name-mangling), 以得到一个独一无二的名称.</p><h3 id="非静态数据成员"><a href="#非静态数据成员" class="headerlink" title="非静态数据成员"></a>非静态数据成员</h3><p>不存在虚基类时, 通过对象名或对象指针访问非静态数据成员没有区别. 存在虚基类时, 通过对象指针访问非静态数据成员需要在运行时才能确定, 因为无法确定指针所指对象的实际类型, 也就不能判断对象的内存布局, 也就不知道对象中该数据成员的偏移. 普通继承和虚继承的这个区别的原因在于, 普通继承的类对象的内存布局在编译时就可以决定, 而存在虚继承时则需要在运行时决定, 详情见下文虚继承对内存布局的影响的讨论.</p><h2 id="继承对对象布局的影响"><a href="#继承对对象布局的影响" class="headerlink" title="继承对对象布局的影响"></a>继承对对象布局的影响</h2><h3 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h3><p>最简单的一种情况, 单继承不会修改父类的内存布局, 例如父类由于内存对齐产生的额外空间在子类中不会被消除, 而是保持原样. 所以下面的代码中, 子类大小是24 bytes, 而不是16 bytes.</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Base <span class="token comment" spellcheck="true">// 16 bytes</span><span class="token punctuation">{</span>    int64_t i1<span class="token punctuation">;</span>    <span class="token keyword">char</span> c1<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> Derived <span class="token operator">:</span> Base <span class="token comment" spellcheck="true">// 24 bytes</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> c2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其原因是如果消除了这些额外空间, 将子类对象赋值给父类对象时就可能会在父类对象的额外空间位置赋值, 这改变了程序的语义, 显然是不合适的.</p><h3 id="加上多态"><a href="#加上多态" class="headerlink" title="加上多态"></a>加上多态</h3><p>为了支持动态绑定, 编译器需要在对象中添加虚表指针(vptr), 指向虚表. 虚表中包含类的类型信息和虚函数指针, 值得注意的是, vptr并不是指向虚表的起始地址, 很多时候该地址之前会保存着对象的类型信息, 程序通过此类型信息实现RTTI. 而vptr初值的设置和其所占空间的回收, 则分别由构造函数和析构函数负责, 编译器自动在其中插入相应代码. 这是多态带来的空间负担和时间负担.</p><p>那么vptr放在什么位置呢? 这是由编译器决定的, gcc将其放在对象头部, 这导致对象不能兼容C语言中的struct, 但是在多重继承中, 通过类成员指针访问虚函数会更容易实现. 如果放在对象末尾则可以保证兼容性, 但是就需要在执行期间获得各个vptr在对象中的偏移, 在多重继承中尤其会增加额外负担.</p><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>标准并没有规定不同基类在布局中的顺序, 但是大多数实现按照继承声明顺序安排. 多重继承给程序带来了这些负担:</p><ul><li>将子类地址赋值给基类指针变量时, 如果是声明中的第一个基类, 二者地址相等, 可以直接赋值. 否则, 需要加上一个偏移量, 已获得对应对象的地址.</li><li>上面的直接加偏移并不能保证正确性, 设想子类指针值为0, 直接加上偏移后指向的是一个内容未知的地址. 正确做法应该是将0值赋给基类指针变量. 因此, 需要先判断基类指针是否为0, 再做处理. 而对于引用, 虽然其底层是指针, 但是不需要检查是否为0, 因为引用必须要绑定到一个有效地址, 不可能为0.</li></ul><h3 id="虚拟继承"><a href="#虚拟继承" class="headerlink" title="虚拟继承"></a>虚拟继承</h3><p>主要问题是如何实现只有一个虚拟基类. 主流方案是将虚拟基类作为共享部分, 其他类通过指针等方式指向虚拟基类, 访问时需要通过指针或其他方式获得虚拟基类的地址. gcc的做法是将虚基类放在对象末尾, 在虚表中添加一项, 记录基类对象在对象中的偏移, 从而获得其地址. 我们可以通过gdb调试来看看具体情况.</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> B<span class="token punctuation">{</span>    int64_t i1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">"B::f() called\n"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> D1 <span class="token operator">:</span> <span class="token keyword">virtual</span> B<span class="token punctuation">{</span>    int64_t i2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> D2 <span class="token operator">:</span> <span class="token keyword">virtual</span> B<span class="token punctuation">{</span>    int64_t i3 <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> D3 <span class="token operator">:</span> D1<span class="token punctuation">,</span> D2<span class="token punctuation">{</span>    int64_t i4 <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token punctuation">}</span>d3<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>d3<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">8</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"d3["</span><span class="token operator">&lt;&lt;</span>i<span class="token operator">&lt;&lt;</span><span class="token string">"] = 0x"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>hex<span class="token operator">&lt;&lt;</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>int64_t<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>d3 <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先用g++编译, 载入gdb中</p><pre class="line-numbers language-shell"><code class="language-shell"># g++ main.cc -g# gdb a.out<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>之后, 设置断点, 运行程序, 再通过下面的命令查看对象d3的虚表.</p><pre class="line-numbers language-assembly"><code class="language-assembly">(gdb) p d3$2 = {<D1> = {<B> = {_vptr.B = 0x555555557c58 <vtable for D3+72>, i1 = 1}, _vptr.D1 = 0x555555557c28 <vtable for D3+24>, i2 = 2}, <D2> = { _vptr.D2 = 0x555555557c40 <vtable for D3+48>, i3 = 3}, i4 = 4}(gdb) p /a *((void**)0x555555557c28-3)@10$4 = {0x28,      0x0,      0x555555557d20 <_ZTI2D3>,      0x18,      0xfffffffffffffff0,      0x555555557d20 <_ZTI2D3>,      0x0,      0xffffffffffffffd8,      0x555555557d20 <_ZTI2D3>,      0x555555555446 <B::f()>}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现, _vptr.D1等于<em>(int64_t *)&amp;d3, _vptr.D2等于</em>((int64_t <em>)&amp;d3 + 2), _vptr.B等于</em>((int64_t *)&amp;d3 + 5). 显然分别是各个对象的vptr的值. gdb的第二个命令是打印部分虚表内容, -3指定起始位置, 10指定长度. 可见_vptr.D1指向输出的第四个, _vptr.D2指向输出的第七个, 二者指向位置的地址减3即为对应对象和基类对象的偏移. 同样可以看到前一个是当前对象的类型信息. 如果在C++中直接访问虚表, 可以用下面的代码, 这和上面用gdb打印虚表等效:</p><pre class="line-numbers language-cpp"><code class="language-cpp">int64_t <span class="token operator">*</span>vptr <span class="token operator">=</span> <span class="token punctuation">(</span>int64_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>int64_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>d3<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// D1的虚表地址.</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">7</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"_vptr.D1["</span><span class="token operator">&lt;&lt;</span>i<span class="token operator">&lt;&lt;</span><span class="token string">"] = 0x"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>hex<span class="token operator">&lt;&lt;</span><span class="token operator">*</span><span class="token punctuation">(</span>vptr<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="成员函数的调用"><a href="#成员函数的调用" class="headerlink" title="成员函数的调用"></a>成员函数的调用</h2><h3 id="普通非静态成员函数"><a href="#普通非静态成员函数" class="headerlink" title="普通非静态成员函数"></a>普通非静态成员函数</h3><blockquote><p>C++的设计准则之一就是: nonstatic member function至少必须和一般的nonmember funciton有相同的效率.</p></blockquote><p>为了保证类成员函数的效率, 编译器将对普通非静态成员函数的调用转换为对普通函数的调用. 步骤如下:</p><ol><li>修改函数签名, 添加一个额外的参数(作为第一个参数), 称为this指针. 由此将函数和对象关联起来.</li><li>将函数中对非静态成员的访问改为经过this指针访问.</li><li>将成员函数重写为一个外部函数, 生成一个独一无二的名字(name mangling).</li></ol><h3 id="虚成员函数"><a href="#虚成员函数" class="headerlink" title="虚成员函数"></a>虚成员函数</h3><p>编译器将对虚成员函数的调用转化为通过vptr调用函数. 在虚继承体系下, 任何含有某一虚函数的类, 该函数在虚表中的偏移都是固定的, 因此编译器可以根据函数名在编译期确定函数指针在虚表中的下标. 所以, 虚函数带来的额外负担就是增加一个内存访问.</p><pre class="line-numbers language-cpp"><code class="language-cpp">p<span class="token operator">-</span><span class="token operator">></span><span class="token function">func</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 设其在虚表中的下标为index.</span><span class="token comment" spellcheck="true">// 上面的语句将被转化为</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">></span>vptr<span class="token punctuation">)</span><span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> param<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 这里p等于this指针, 所以将其作为第一个参数.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><p>对静态成员函数的访问将被转化为对普通函数的访问, 由于静态成员不能访问非静态数据成员, 因此不需要添加this指针. 静态函数有下面几个特点:</p><ul><li>不能直接访问类对象的非静态成员.</li><li>不能被声明为const, volatile, virtual.</li><li>可以通过类对象和类名来调用.</li></ul><p>注意一点, 当通过类对象来调用静态成员函数, 并且这个对象是由一个表达式得到时, 虽然不需要执行表达式就能直接调用函数, 但是表达式仍然会被执行(evaluate), 因为此表达式可能会有副作用, 不能被忽略. 例如:</p><pre class="line-numbers language-cpp"><code class="language-cpp">Object <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">static_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// func()仍然会被先执行, func()中可能会有某些不可省略的操作.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="虚成员函数的实现"><a href="#虚成员函数的实现" class="headerlink" title="虚成员函数的实现"></a>虚成员函数的实现</h2><h3 id="单继承-1"><a href="#单继承-1" class="headerlink" title="单继承"></a>单继承</h3><p>前文提到的虚成员函数实现是单继承下的模型, 下面具体说明其实现(注意下面提到的函数都指的是虚函数). 首先, 我们知道每个类都只有一个虚表(多继承和虚继承的类对象有多个vtpr, 指向不同的虚表, 但是实际上这些虚表是一个, vptr只是指向虚表的不同偏移位置), 也就是说相同类型的对象的vptr值是相同的. 当单继承发生时, 子类不仅继承了父类的数据成员, 还继承了函数成员, 前者体现在类对象布局上, 而后者体现在虚表上. 虚表继承的步骤可能包含下面几步:</p><ol><li>将父类虚表中的虚函数指针拷贝到子类虚表的相同下标位置.</li><li>如果子类重写了父类的虚函数, 就将被重写的虚函数的指针修改为对应函数的地址.</li><li>如果子类加入新的虚函数, 就增加虚表容量, 在后面添加新的函数指针.</li></ol><p>从上面可以看到, 单继承下的虚函数效率高, 实现简单, 但是多继承和虚拟继承则要复杂很多.</p><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>多继承的复杂性在于下面几个问题:</p><ul><li>通过第2,3,…个父类的指针访问子类的虚函数.</li><li>通过子类指针访问第2,3,…个父类的虚函数.</li><li>重写的虚函数的返回类型可能和父类的被重写函数的返回类型不一样, 这是标准允许的.</li></ul><p>在讨论上面的问题之前, 先复习一下C++中虚函数相关的知识.</p><p>首先, 明确虚函数重写的概念. 父类声明了一个虚函数, 如果其(直接或间接)子类定义了函数, 与父类虚函数具有相同的:</p><ul><li>名字</li><li>参数类型列表(不包含返回值)</li><li>const/volatile类型, 参考 <a href="https://zhuanlan.zhihu.com/p/61610818/edit#1">[1]</a></li><li>引用类型(三种: 无引用符号, &amp;, &amp;&amp;), 参考 <a href="https://zhuanlan.zhihu.com/p/61610818/edit#1">[1]</a></li></ul><p>则子类函数为虚函数(无论是否声明为virtual), 并且重写了父类的虚函数.</p><p>第二点, 多继承时, 我们通过子类指针可以访问所有父类的函数, 这一点很明确. 但是不能通过一个父类的指针访问其他父类的函数. 看下面的例子:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> B1<span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> B2<span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> D<span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>B1 <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token keyword">new</span> D<span class="token punctuation">;</span>p1<span class="token operator">-</span><span class="token operator">></span><span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// illegal</span>B2 <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token keyword">new</span> D<span class="token punctuation">;</span>p2<span class="token operator">-</span><span class="token operator">></span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// illegal</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也就是说, 通过一个类对象指针调用函数时, 这个函数必须要在这个类或其父类中声明过.</p><p>下面举例说明上面问题的复杂性.(调用虚函数时一定是通过指针或引用, 由于引用本质上是指针, 下面只讨论指针.)</p><p>对于第一个问题, 通过父类指针直接调用子类定义的函数时有两种情况:</p><ul><li>通过第一个基类指针访问时, 直接将指针值作为this指针值传给函数.</li><li>通过第2,3,…个基类指针访问时, 需要调整指针值, 加上/减去一个偏移, 再作为this指针传给函数.</li></ul><p>显然第二种情况下需要<strong>在运行时调整this指针的值</strong>, 因为编译时无法确定指针所指对象的实际类型.</p><p>除此之外, 再考虑一种特殊情况(间接调用子类虚函数):</p><ul><li>对一个父类指针调用delete.</li></ul><p>如果析构函数被声明为virtual, 那么程序将根据指针所指对象的实际类型决定调用哪个析构函数. 这就需要<strong>在运行时需要调整指针的值</strong>, 以保证能够访问正确的vptr, 从而获得对应的析构函数.</p><p>上面两个例子说明第一个问题的复杂性在于需要在运行时根据指针所指对象的实际类型来调整指针的值, 使之指向子类对象. 其他两个问题复杂性的根源也来自于此, 不(会)做详述.</p><p>问题明确了, 解决办法呢? 老实说没怎么看懂, 就不瞎说了, 等以后看明白了再补.</p><h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>其复杂性同样在于指针值的运行时修改, 书中建议不要在虚基类中声明非静态的函数.</p><h2 id="成员函数指针"><a href="#成员函数指针" class="headerlink" title="成员函数指针"></a>成员函数指针</h2><p>成员函数指针只能指向类的非静态成员函数, 使用方法如下:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> C<span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token punctuation">(</span>C<span class="token operator">::</span><span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>C<span class="token operator">::</span>f<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// pointer to member function</span>C c<span class="token punctuation">,</span> <span class="token operator">*</span>cp <span class="token operator">=</span> <span class="token operator">&amp;</span>c<span class="token punctuation">;</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过对象调用函数f</span><span class="token punctuation">(</span>cp<span class="token operator">-</span><span class="token operator">></span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过对象指针调用函数f</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>父类成员函数指针可以直接赋值给子类成员函数指针, 如下面的例子:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> B<span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> D <span class="token operator">:</span> B<span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token punctuation">(</span>B<span class="token operator">::</span><span class="token operator">*</span> bf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>B<span class="token operator">::</span>f<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token punctuation">(</span>D<span class="token operator">::</span><span class="token operator">*</span> df<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> bf<span class="token punctuation">;</span>B bp <span class="token operator">=</span> <span class="token keyword">new</span> D<span class="token punctuation">;</span><span class="token punctuation">(</span>bp<span class="token punctuation">.</span><span class="token operator">*</span>bf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用D::f()</span><span class="token punctuation">(</span>bp<span class="token punctuation">.</span><span class="token operator">*</span>df<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用D::f()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而子类的成员函数指针可以通过static_cast或C风格的类型转换将其转换为父类的成员函数指针.</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token punctuation">(</span>D<span class="token operator">::</span><span class="token operator">*</span> df<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>D<span class="token operator">::</span>f<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token punctuation">(</span>B<span class="token operator">::</span><span class="token operator">*</span> bf1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">void</span> <span class="token punctuation">(</span>B<span class="token operator">::</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span>df<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token punctuation">(</span>B<span class="token operator">::</span><span class="token operator">*</span> bf2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span>B<span class="token operator">::</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>df<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>从上面的例子中可以看到, 成员函数指针仍然支持虚函数机制. 下面看看编译器是如何支持各种虚拟机制的.</p><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>成员函数指针可以指向一个普通函数, 此时她可以是函数地址. 如果指向一个虚函数, 她可以是该函数在虚表中的偏移. 这两种值可以保存在相同类型的变量中, 但是如何区分她们呢? 早期C++限制最多有128个虚函数(应该是限制虚表长度为128吧), 所以偏移值最大为127. 而程序空间起始地址必定大于127, 因此可以通过将指针值和127做”&amp;”(按位与)运算来判断是偏移还是函数地址.</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>pmf<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token number">127</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token operator">*</span>pmf<span class="token punctuation">)</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token operator">-</span><span class="token operator">></span>vptr<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>pmf<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="多继承和虚继承"><a href="#多继承和虚继承" class="headerlink" title="多继承和虚继承"></a>多继承和虚继承</h3><p>支持这些机制的方法就更加复杂了. Stroustrup提出的一种方式是将成员函数指针定义为一个结构体, 包含this指针偏移, 虚基类指针偏移等等. 不过因为对不需要如此复杂机制的函数调用带来额外负担而受到批评. 有的实现对成员函数指针有多种实现方式, 以减少不必要的负担. 比如微软, 对单继承, 多继承, 虚继承就采用不同的方式来实现. 这个地方感觉还是不够具体, 坑先留着, 以后再填.</p><h3 id="inline函数"><a href="#inline函数" class="headerlink" title="inline函数"></a>inline函数</h3><p>在下面的情况下, 一个函数是inline函数:</p><ul><li>声明中包含inline关键字的函数</li><li>当一个函数(成员函数或非成员友元函数)的定义在类内部时</li><li>被声明为constexpr的函数(since C++11)</li></ul><p>inline函数只是一种建议, 建议编译器将对inline函数的调用转换, 但是编译器并不一定会接受该建议, 而且非inline函数也有可能被转换, 这依赖于具体实现. 使用inline函数时要注意下面几点:</p><ul><li><p>inline函数可能会增加生成的文件的大小.</p></li><li><p>inline函数尽可能简单. 减少不必要的局部变量, 否则可能会在结果中产生大量的局部变量.(现在的编译器应该可以优化这个了吧)</p></li><li><p>赋值运算符.</p></li><li><p>显式定义复制赋值运算符,</p></li><li><p>拒绝赋值行为.</p></li></ul><p>对于第三点, C++11之前需要将<em>operator =</em>声明为private, 并且不提供其定义. 而C++11之后, 可以用下面的语句实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp">ClassName<span class="token operator">&amp;</span> ClassName<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> ClassName<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>另外C++11提供的一个语法是可以将其显式声明为default, 虽然用户显式声明之, 但是定义是由编译器隐式生成的.</p><pre class="line-numbers language-cpp"><code class="language-cpp">ClassName<span class="token operator">&amp;</span> ClassName<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> ClassName<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当不需要拒绝赋值时, 就需要考虑是不是显式提供一个<em>operator =</em>. 一个原则是:</p><blockquote><p><strong>只有在默认复制赋值运算符的行为不安全或不正确时, 才需要显式定义复制赋值运算符</strong>.</p></blockquote><p>那么问题来了, 默认复制赋值运算符的行为是什么?</p><h3 id="Trivial-copy-assignment-operator"><a href="#Trivial-copy-assignment-operator" class="headerlink" title="Trivial copy assignment operator"></a>Trivial copy assignment operator</h3><p>当复制赋值运算符满足下面的条件是, 她就是tirivial的:</p><ul><li>不是用户提供的(隐式定义的或声明为default).</li><li>类没有虚函数.</li><li>类没有虚基类.</li><li>直接基类的复制赋值运算符都是trivial的.</li><li>非静态成员的复制赋值运算符是tirvial的.</li></ul><p>满足这个条件的对象的赋值行为是bitwise的, 就如同调用std::memmove一样. 所有与C语言兼容的数据类型都满足此条件. 不满足上面的的条件时, 就采用member-wise复制赋值行为. 以上的bitwise和member-wise就是默认复制赋值运算符的行为.</p><p>另一个问题是存在虚基类时复制赋值运算符可能会多次对基类子对象调用<em>operator =</em>, gcc-8就是如此. 一般含有虚基类的子类的复制赋值运算符定义如下:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> A <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*...*/</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> B <span class="token operator">:</span> <span class="token keyword">virtual</span> A <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*...*/</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> C <span class="token operator">:</span> <span class="token keyword">virtual</span> A <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*...*/</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> D <span class="token operator">:</span> B<span class="token punctuation">,</span> C <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*...*/</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>A<span class="token operator">&amp;</span> A<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*    ... // member copy assignment    */</span><span class="token punctuation">}</span>B<span class="token operator">&amp;</span> B<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>A<span class="token operator">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 直接调用 A::operator =</span>    <span class="token comment" spellcheck="true">/*    ... // member copy assignment    */</span><span class="token punctuation">}</span>C<span class="token operator">&amp;</span> C<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> C<span class="token operator">&amp;</span> c<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>A<span class="token operator">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 直接调用 A::operator =</span>    <span class="token comment" spellcheck="true">/*    ... // member copy assignment    */</span><span class="token punctuation">}</span>D<span class="token operator">&amp;</span> D<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> D<span class="token operator">&amp;</span> d<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>A<span class="token operator">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 直接调用 A::operator =</span>    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>B<span class="token operator">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 间接调用 A::operator =</span>    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>C<span class="token operator">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 间接调用 A::operator =</span>    <span class="token comment" spellcheck="true">/*    ... // member copy assignment    */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++并没有提供类似复制构造函数的语法来保证虚基类只会被复制一次. 所以, 书中建议将虚基类的复制赋值运算符声明为delete, 甚至不要再虚基类中声明数据成员.</p><h2 id="对象析构"><a href="#对象析构" class="headerlink" title="对象析构"></a>对象析构</h2><p>书中提到一个值得注意的问题, 并不是定义了构造函数就需要定义析构函数, 这种”对称”是无意义的. 只有当需要一个析构函数时, 我们才应该显式定义之. 那么什么时候需要呢? 首先要搞清楚析构函数的作用, 她是对象的生命周期的终结, 而函数体内执行的主要是是对对象持有的资源的释放, 例如在构造函数中动态申请的空间. 析构函数的操作与构造函数类似, 但是顺序相反.</p><h3 id="Trivial-destructor"><a href="#Trivial-destructor" class="headerlink" title="Trivial destructor"></a>Trivial destructor</h3><p>类T的析构函数如果满足下面的条件, 就是trivial的:</p><ul><li>析构函数不是用户定义的.(隐式声明或声明为default)</li><li>析构函数非虚.(这就要求父类的虚函数也非虚)</li><li>直接父类的析构函数是trivial的.</li><li>非静态数据成员(数组的数据成员)的析构函数是trivial的.</li></ul><p>trivial析构函数不进行任何操作, 析构时只需要释放对象的空间即可. 所有与C语言兼容的数据类型都是<em>trivial destructible</em>的.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;C++对象模型，启动！&lt;/p&gt;
&lt;h2 id=&quot;对象模型&quot;&gt;&lt;a href=&quot;#对象模型&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://JoyTsing.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
      <category term="读书笔记" scheme="https://JoyTsing.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>喜报加悲报(迫真)</title>
    <link href="https://joytsing.github.io/posts/17028/"/>
    <id>https://joytsing.github.io/posts/17028/</id>
    <published>2024-03-13T12:24:15.000Z</published>
    <updated>2024-03-20T08:57:06.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="喜报"><a href="#喜报" class="headerlink" title="喜报"></a>喜报</h2><p>为了庆祝我的blog阅读量全面超过我的qq空间访问数量(快一万)，加上真的没想到有这么多人看这个blog，为了更好的访问体验，本人决定自掏腰包，买了腾讯云的域名和对应服务(主要是dns加快访问，众所众知github的dns服务器经常被污染),因此以后的新域名就是<code>https://joytsing.cn/</code>啦，同时还白嫖了腾讯云的SSL证书(爽到)。</p><p><img src="/posts/17028/1.png" alt="迫真购买记录"></p><h2 id="悲报"><a href="#悲报" class="headerlink" title="悲报"></a>悲报</h2><p>换了新域名后访问记录归零啦！😅这下qq空间又赢了，难蚌。。。</p><p><img src="/posts/17028/2.png" alt="迫真归零"></p><p>不过体感上真的快了不少，以前有时候不挂梯子都上不了blog，果然花钱就是好啊(赞赏🤣)，总体上肯定是好的，访问量归零就归零了把，反正有之前的文章记录了之前的访问量，以后会努力产出的(<del>毕竟花了💰</del>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;喜报&quot;&gt;&lt;a href=&quot;#喜报&quot; class=&quot;headerlink&quot; title=&quot;喜报&quot;&gt;&lt;/a&gt;喜报&lt;/h2&gt;&lt;p&gt;为了庆祝我的blog阅读量全面超过我的qq空间访问数量(快一万)，加上真的没想到有这么多人看这个blog，为了更好的访问体验，本人决定自掏腰
      
    
    </summary>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>纪念这个特殊时刻(迫真)</title>
    <link href="https://joytsing.github.io/posts/29245/"/>
    <id>https://joytsing.github.io/posts/29245/</id>
    <published>2024-03-12T11:53:46.000Z</published>
    <updated>2024-03-12T11:58:01.714Z</updated>
    
    <content type="html"><![CDATA[<h2 id="迫真喜报"><a href="#迫真喜报" class="headerlink" title="迫真喜报"></a>迫真喜报</h2><p>下图为本人qq空间访问量</p><p><img src="/posts/29245/1.png" alt="qq空间访问量"></p><p>下图为本人blog访问量</p><p><img src="/posts/29245/2.png" alt="blog访问量"></p><p><strong>喜报！本人blog花了4年半的时间超过了我10多年的qq空间浏览量！</strong>😄</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;迫真喜报&quot;&gt;&lt;a href=&quot;#迫真喜报&quot; class=&quot;headerlink&quot; title=&quot;迫真喜报&quot;&gt;&lt;/a&gt;迫真喜报&lt;/h2&gt;&lt;p&gt;下图为本人qq空间访问量&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/29245/1.png&quot; alt=&quot;qq空间访问量
      
    
    </summary>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Go语言之context</title>
    <link href="https://joytsing.github.io/posts/31191/"/>
    <id>https://joytsing.github.io/posts/31191/</id>
    <published>2024-03-12T09:00:46.000Z</published>
    <updated>2024-03-12T09:29:45.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、基本认识"><a href="#一、基本认识" class="headerlink" title="一、基本认识"></a><strong>一、基本认识</strong></h2><p>在介绍具体之前，先列几点关于 Context 接口以及 context 包的基本认识，文章后续也会不断的提及：</p><ol><li>Context 只有两个简单的功能：跨 API 或在进程间 <strong>1)携带键值对、2)传递取消信号</strong>(主动取消、时限/超时自动取消) </li><li><strong>Context 是接口</strong>，可以通过两种方式获得上下文：</li></ol><ul><li>通过 <code>BackGround()</code> 或者 <code>TODO()</code> 创建空上下文</li><li>通过 <code>With</code> 开头函数创建新的上下文，新老上下文是派生关系(derived)</li></ul><p>同样的还有两点，函数间传递的 Context 实际是某结构的地址，不用担心消耗问题，并且相同的 Context 可以多个 goroutine 中使用，是并发安全的。另外，实践中还应该遵循一些规范，这些在 Go 的官方文档中有提及：</p><ul><li>Context 显式传递给每个<strong>需要它</strong>的函数且作为第一个参数，通常命名为 <code>ctx</code>：</li></ul><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">DoSomething</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> arg Arg<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ... use ctx ...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>不传递 <code>nil</code> 作为上下文，如果不确定传递什么，可以通过 <code>context.TODO()</code> 创建一个空上下文</li><li>携带的键值对仅用于传输过程和 API 请求相关的数据（比如 security credentials, tracing information, deadlines, and cancellation signals across API and process boundaries），函数相关的参数应该通过函数参数传递</li></ul><h2 id="二、空的上下文的创建"><a href="#二、空的上下文的创建" class="headerlink" title="二、空的上下文的创建"></a><strong>二、空的上下文的创建</strong></h2><p><strong>空的</strong>上下文的创建有两种方式：</p><ul><li>调用 <code>context.TODO()</code></li><li>调用 <code>context.BackGround()</code></li></ul><p>这两个函数的实现都返回一个 <code>context.emptyCtx</code> 对象的地址：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">var</span> <span class="token punctuation">(</span>    background <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>emptyCtx<span class="token punctuation">)</span>    todo       <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>emptyCtx<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>尽管本质上是一样的，但是区分两个函数是<strong>为了在编写代码时，更清晰地表明开发人员在创建这个上下文的意图</strong>：</p><ul><li><code>TODO()</code>: 不确定要使用哪个上下文时，可以将其用作占位符</li><li><code>BackGround()</code>: 打算启动已知上下文的地方，通常我们都使用这个</li></ul><p>空的上下文没有什么用途。因为 <code>emptyCtx</code> 的 <code>Done()</code>、<code>Err()</code>、<code>Value()</code> 等方法，都返回的 <code>nil</code>。</p><h2 id="三、携带键值对"><a href="#三、携带键值对" class="headerlink" title="三、携带键值对"></a><strong>三、携带键值对</strong></h2><p>通过 <code>WithValue()</code> 函数可以让 Context 实现携带键值对的功能。</p><p><code>WithValue()</code> 函数定义中，传入的 <code>Context</code> 命名为 <code>parent</code>：再次强调，<strong>返回的 Context 与其是派生关系</strong>。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">WithValue</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val any<span class="token punctuation">)</span> Context<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>举一个简单的例子：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    a <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span>              <span class="token comment" spellcheck="true">// 创建上下文</span>    b <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">WithValue</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token string">"k1"</span><span class="token punctuation">,</span> <span class="token string">"v1"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 塞入一个kv</span>    c <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">WithValue</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token string">"k2"</span><span class="token punctuation">,</span> <span class="token string">"v2"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 塞入另外一个kv</span>    d <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">WithValue</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token string">"k1"</span><span class="token punctuation">,</span> <span class="token string">"vo1"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 覆盖一个kv</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"k1 of b: %s\n"</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span><span class="token function">Value</span><span class="token punctuation">(</span><span class="token string">"k1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"k1 of d: %s\n"</span><span class="token punctuation">,</span> d<span class="token punctuation">.</span><span class="token function">Value</span><span class="token punctuation">(</span><span class="token string">"k1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"k2 of d: %s\n"</span><span class="token punctuation">,</span> d<span class="token punctuation">.</span><span class="token function">Value</span><span class="token punctuation">(</span><span class="token string">"k2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码打印的内容：</p><pre class="line-numbers language-text"><code class="language-text">k1 of b: v1k1 of d: vo1k2 of d: v2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>直观的感觉是上下文中的<strong>键值对</strong>可以被<strong>覆盖</strong>，但看一下 <code>WithValue()</code> 的实现，这种表现并不是真正的覆盖了某些值。另外，这里的值可以是任何类型，拿出来使用的时候，需要转换成具体的类型。</p><p><strong>如果不断地通过</strong> <strong><code>WithValue()</code></strong> <strong>同一个的 key 更新上下文，写入和读取就像使用一个栈，后边被设置进去的会被先读取到。</strong> <code>Value()</code> 是一个递归解嵌套的过程，终止条件就是 Context 为 <code>emptyCtx</code> 或找到对应 key。</p><h2 id="四、传递取消信号"><a href="#四、传递取消信号" class="headerlink" title="四、传递取消信号"></a><strong>四、传递取消信号</strong></h2><p>Context 接口要求实现 4 个方法，除了 <code>Value()</code> 是和上边介绍的传递键值对有关之外，其他的三个都和<em>传递取消信号</em>有关。</p><p><strong>上下文是可以结束的</strong>。 可以向使用 <code>context.Context</code> 的任何函数发出信号，表明上下文已结束。而这些函数在收到上下文完成的信号后，以自己的方式处理了有关上下文相关的工作。这种处理方式是高效的：虽然可能因为超时或主动取消，没有得到预期结果，但可以及时停止后续操作、释放出资源来处理别的请求，而不必等待每个函数都有返回。</p><h3 id="Done-——-确定上下文是否完成"><a href="#Done-——-确定上下文是否完成" class="headerlink" title="Done() —— 确定上下文是否完成"></a><strong>Done() —— 确定上下文是否完成</strong></h3><p>无论上下文是因为什么原因结束的，都可以通过调用其 <code>Done()</code> 方法确认：该方法返回一个通道(<code>chan struct{}</code>)，该通道会在上下文完成时被关闭，任何监听该通道的函数都会感应到对应上下文完成的事件。</p><p><strong>【channel 基础知识】通道有一种常见的用法：不会往通道里写入任何东西，在需要发送信号的时候关闭通道，此时接收操作符（receive operator）会立马收到一个管道类型的零值</strong>，在 <a href="https://link.zhihu.com/?target=https%3A//go.dev/ref/spec%23Receive_operator">Go 规范</a>中有详细描述：</p><blockquote><p>A receive operation on a <a href="https://link.zhihu.com/?target=https%3A//go.dev/ref/spec%23Close">closed</a> channel can always proceed immediately, yielding the element type’s <a href="https://link.zhihu.com/?target=https%3A//go.dev/ref/spec%23The_zero_value">zero value</a> after any previously sent values have been received.</p></blockquote><p>通道的等待往往结合 <code>select</code> 一块使用。 select 可以通过多个 case 同时读取多个 channel，如果每个 case 的 channel 都被阻塞则 select 会被阻塞。也会有另外的做法，在 default 做<strong>逻辑</strong>或者 sleep，将 select 放在循环中，不断的重复检查。</p><p>再说回 <code>Done()</code> 方法，它返回一个通道，在 Context 未关闭和关闭的表现：</p><ul><li>没有关闭的时候，<code>case &lt;- ctx.Done()</code> 会阻塞住</li><li>关闭之后，每次 <code>&lt;- ctx.Done()</code> 都会返回一个零值</li></ul><h3 id="Cancel-——-取消上下文"><a href="#Cancel-——-取消上下文" class="headerlink" title="Cancel() —— 取消上下文"></a><strong>Cancel() —— 取消上下文</strong></h3><p>取消上下文是结束上下文最直接、最可控的方式。通过 <code>context.WithCancel</code> 会在 Context 上关联上一个 <code>CancelFunc</code> 类型的<em>取消函数</em>，该类型就是一个 <code>func()</code>，不接受参数也没有返回。</p><p><code>WithCancel()</code> 返回的是第一个参数的 Context 是 <code>cancelCtx</code> 类型的对象。cancelCtx 结构有一个方法是 <code>cancel()</code>，而 WithCancel 返回的第二个就是该方法的封装：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">WithCancel</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">)</span> <span class="token punctuation">(</span>ctx Context<span class="token punctuation">,</span> cancel CancelFunc<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> parent <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"cannot create context from nil parent"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    c <span class="token operator">:=</span> <span class="token function">newCancelCtx</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span>    <span class="token function">propagateCancel</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span>c<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> c<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> Canceled<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="取消上下文的示例"><a href="#取消上下文的示例" class="headerlink" title="取消上下文的示例"></a><strong>取消上下文的示例</strong></h3><p>下边的代码来自 <a href="https://link.zhihu.com/?target=https%3A//pkg.go.dev/context%23WithCancel">Go 官方 context 包文档中 WithCancel 的示例</a>，展示了在函数中使用了 <code>Done()</code> 和 <code>Cancel()</code> 两个方法。</p><pre class="line-numbers language-go"><code class="language-go">gen <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>    dst <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>    n <span class="token operator">:=</span> <span class="token number">1</span>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">{</span>            <span class="token keyword">select</span> <span class="token punctuation">{</span>            <span class="token keyword">case</span> <span class="token operator">&lt;-</span>ctx<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token comment" spellcheck="true">// returning not to leak the goroutine</span>            <span class="token keyword">case</span> dst <span class="token operator">&lt;-</span> n<span class="token punctuation">:</span>                n<span class="token operator">++</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> dst<span class="token punctuation">}</span>ctx<span class="token punctuation">,</span> cancel <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">WithCancel</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">defer</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// cancel when we are finished consuming integers</span><span class="token keyword">for</span> n <span class="token operator">:=</span> <span class="token keyword">range</span> <span class="token function">gen</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>    <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">5</span> <span class="token punctuation">{</span>        <span class="token keyword">break</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中代码具体的执行，做一下简单的说明：</p><ul><li><p><code>gen</code> 是一个函数变量，返回一个 <code>chan int</code></p></li><li><p>使用 <code>BackGround()</code> 创建空白上下文，使用 <code>WithCancel()</code> 关联上一个取消函数 cancel</p></li><li><p>将 cancel 函数加入到 defer 栈</p></li><li><p>调用 <code>gen(ctx)</code>，传入 Context，在 <code>gen()</code> 函数中：</p><ul><li>创建一个 <code>chan int</code>。注意，这个 channel 的size 是0，也就是只有下游准备好接收的时候，才能塞入，这个之前文章有介绍过</li><li>启动一个 goroutine，不断的循环在两个 channel 上读写：等待上下文结束通道关闭；等待目的通道可以写，写入递增数字</li><li>返回目的通道 <code>dst</code></li></ul></li><li><p><code>for</code> 循环利用 <code>range</code> 不断的从 dst 通道中读出数字并打印</p><ul><li>在读出并打印出 5 之后，退出</li></ul></li><li><p>defer 栈中的 cancel 函数被拿出来执行，ctx 被取消，上下文结束</p></li><li><p>gen() 函数中启动的 goroutine 中的函数接收到 <code>ctx.Done()</code> 中得到的 0，函数结束退出</p></li></ul><p>这个示例，使用<em>取消上下文</em>的目的是为了<strong>防止 goroutine 的泄漏</strong>：如果没有上下文的结束信号，外部的for循环退出之后，goroutine 运行的函数会会一直阻塞在 select，对应的资源也不会被释放。</p><h2 id="五、带时限-超时的取消"><a href="#五、带时限-超时的取消" class="headerlink" title="五、带时限/超时的取消"></a><strong>五、带时限/超时的取消</strong></h2><p>上边介绍的 <code>WithCancel()</code> 派生出来的上下文，只能主动去取消上下文。context 包中还提供了两个可以带时间<em>自动取消上下文</em>的函数：</p><ul><li>通过 <code>context.WithDeadline()</code> 设置上下文需要完成的截止时间，在到达截止时间之后回自动结束</li><li>通过 <code>context.WithTimeout()</code> 设置上下文的超时时间，在到达超时之后自动结束</li></ul><p>其实，两个函数作用大同小异，<code>WithTimeout()</code> 也是在当前时间上加了一个超时时间，然后调用 <code>WithDeadline()</code> 函数实现的：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">WithTimeout</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">,</span> timeout time<span class="token punctuation">.</span>Duration<span class="token punctuation">)</span> <span class="token punctuation">(</span>Context<span class="token punctuation">,</span> CancelFunc<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">WithDeadline</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="超时取消示例"><a href="#超时取消示例" class="headerlink" title="超时取消示例"></a><strong>超时取消示例</strong></h3><p>这里仍然使用 context 官方文档上的一个示例，做了一点修改：</p><pre class="line-numbers language-go"><code class="language-go">ctx<span class="token punctuation">,</span> cancel <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">WithTimeout</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// Even though ctx will be expired, it is good practice to call its</span>    <span class="token comment" spellcheck="true">// cancellation function in any case. Failure to do so may keep the</span>    <span class="token comment" spellcheck="true">// context and its parent alive longer than necessary.</span>    <span class="token keyword">defer</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">select</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token operator">&lt;-</span>time<span class="token punctuation">.</span><span class="token function">After</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">:</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"overslept"</span><span class="token punctuation">)</span>    <span class="token keyword">case</span> <span class="token operator">&lt;-</span>ctx<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>ctx<span class="token punctuation">.</span><span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对上边的代码做一下简单解释：</p><ul><li>创建空上下文，通过 <code>WithTimeout()</code> 创建一个带 10ms 超时的上下文</li><li>将得到的 cancel 函数压入 defer 栈中</li><li><code>select</code> 等待两个事件：一个是1秒之后的超时，另一个是等待上下文结束</li><li>由于上下文超时时间远小于定时时钟，所以会走到 <code>fmt.Println(ctx.Err())</code></li><li>select 结束，函数结束前执行 defer 栈中的 cancel 函数</li></ul><p>如注释：<strong>尽管上下文会在超时结束取消，但是作为一种良好实践，在任何场景中，都应该调用一下 cancel 函数</strong>。</p><p>从另外角度理解，<code>CancelFunc()</code> 可以被多次调用，不会像多次 close channel 一样会 panic。</p><h3 id="Err-——-获取上下文错误"><a href="#Err-——-获取上下文错误" class="headerlink" title="Err() —— 获取上下文错误"></a><strong>Err() —— 获取上下文错误</strong></h3><p>上边的示例代码会走到外边的 <code>&lt;-ctx.Done()</code> 分支，会打印 <code>ctx.Err()</code> 得到的错误(DeadlineExceeded)：</p><blockquote><p>context deadline exceeded</p></blockquote><p>Context 接口要求的实现一个方法是 <code>Err()</code>：</p><ul><li>在 <code>Done()</code> 返回的 channel 没有被关闭的时候，调用 Err() 一定会返回 nil</li><li>在 <code>Done()</code> 关闭之后，<code>Err()</code> 会返回 Canceled 或 DeadlineExceeded 两种错误</li><li>BackGround() 创建的 emptyCtx 在任何时候都会返回 nil</li></ul><p><code>Canceled</code> 和 <code>DeadlineExceeded</code> 是两个<strong>包级别的变量</strong>，是 error 接口。在 cancelCtx.cancel 方法参数中，可以指定使用何种错误取消上下文。实现上，<code>WithDeadline()</code> 等创建的上下文，在 <code>time.AfterFunc</code> 中调用取消的时候会填入 DeadlineExceeded，否则主动取消会填入Canceled。</p><h2 id="六、Context-树与-Cancel-传播"><a href="#六、Context-树与-Cancel-传播" class="headerlink" title="六、Context 树与 Cancel 传播"></a><strong>六、Context 树与 Cancel 传播</strong></h2><p>我们多次在前文中看到了：Context 的创建过程，是先通过 <code>BackGround()</code> 获得空上下文，然后在此基础上，调用 With 开头的4个函数，不断的派生上下文。</p><p>context 包文档中的这段话也是如此的描述，其中提到的是 <strong>optionally</strong>，这意味着<strong>并不是每个函数都需要派生上下文，而是在确实需要的情况下可以派生，不然可以直接使用当前的上下文</strong>：</p><blockquote><p>The chain of function calls between them must propagate the Context, optionally replacing it with a derived Context created using WithCancel, WithDeadline, WithTimeout, or WithValue. When a Context is canceled, all Contexts derived from it are also canceled.</p></blockquote><p>因为一个 Context 可以派生出多个 child Context，因此所有的 Context 会形成一棵树，而这棵树的根就是 <code>BackGround()</code> 的空上下文。</p><h3 id="ctx-WithValue-ctx-key-val-的过程"><a href="#ctx-WithValue-ctx-key-val-的过程" class="headerlink" title="ctx = WithValue(ctx, key, val) 的过程"></a><strong><code>ctx = WithValue(ctx, key, val)</code></strong> <strong>的过程</strong></h3><p>虽然前边提到过，通过 With 开头的函数，可以派生出新的上下文，但是实际使用中，<strong>并不需要每个中间派生的上下文都需要存到一个变量中</strong>。</p><p>下边的代码也很常见：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">for</span> key<span class="token punctuation">,</span> val <span class="token operator">:=</span> <span class="token keyword">range</span> paramMap <span class="token punctuation">{</span>    ctx <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">WithValue</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这个场景中，中间派生出的 Context 并没有用途，但是随着一次次的 <code>ctx = WithValue(ctx, key, val)</code> 会将中间派生的 Context 保存在新的 Context 中，因此最后一个 ctx 还存在的情况下，中间的 Context 的引用计数没有归零，所以也不会被清理掉。</p><h3 id="为什么需要传播-cancel"><a href="#为什么需要传播-cancel" class="headerlink" title="为什么需要传播 cancel"></a><strong>为什么需要传播 cancel</strong></h3><p>这里的传播和之前提到的传递信号是两个概念：</p><ul><li>传递信号是指创建 goroutine 调用函数，使用同一个上下文，调用方和被调函数都能够主动结束、或感知到结束</li><li>传播是指由派生关系的上下文，当父上下文结束之后，会将派生的上下文也 cancel 掉</li></ul><blockquote><p>Calling the CancelFunc cancels the child and its children, removes the parent’s reference to the child, and stops any associated timers. Failing to call the CancelFunc leaks the child and its children until the parent is canceled or the timer fires. The go vet tool checks that CancelFuncs are used on all control-flow paths.</p></blockquote><p><strong>上下文通过直接调用 Cancel 或者通过定时/截止时间间接调用 Cancel 来结束上下文，都会传递给该上下文的所派生出的所有上下文，使得这些上下文结束。</strong></p><p><strong>这个功能非常容易理解</strong>：以一个 HTTP 请求处理函数为例，假设会多次查询 MySQL，如果我们整个请求处理的超时设置为1秒（会创建一个上下文 parent，WithTimeout 1s），每次 MySQL 请求的超时设置为 800ms(会派生出上下文 childN，WithTimeout 800ms)，当第N个 MySQL 请求还没有达到超时，但是总的超时时间已经达到1秒时，parent 会被自动 cancel 掉，这时候当前的 MySQL 查询（以及后续未执行的查询，但是还没有派生上下文），都没有意义，因此的这个派生的上下文childN 会在 parent canel 的过程中也被 cancel 掉。</p><h3 id="Cancel-传播示例"><a href="#Cancel-传播示例" class="headerlink" title="Cancel 传播示例"></a><strong>Cancel 传播示例</strong></h3><p>以上边解释为什么要是传递给派生上下文的场景为例，写一个简单的例子：</p><pre class="line-numbers language-go"><code class="language-go">ctx<span class="token punctuation">,</span> cancel <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">WithTimeout</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token keyword">defer</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>slowFunc <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    childCtx<span class="token punctuation">,</span> cancel <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">WithTimeout</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> <span class="token number">800</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span>    <span class="token keyword">defer</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"query No. %d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>    <span class="token keyword">select</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token operator">&lt;-</span>childCtx<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"child context err: %v\n"</span><span class="token punctuation">,</span> childCtx<span class="token punctuation">.</span><span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>    <span class="token keyword">select</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token operator">&lt;-</span>ctx<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"parent context err: %v\n"</span><span class="token punctuation">,</span> ctx<span class="token punctuation">.</span><span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token keyword">default</span><span class="token punctuation">:</span>        <span class="token function">slowFunc</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> i<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行上边代码，会在 1秒钟之后结束，其屏幕输出结果是：</p><pre class="line-numbers language-text"><code class="language-text">query No. 0child context err: context deadline exceededquery No. 1child context err: context deadline exceededparent context err: context deadline exceeded<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>将for移入default会是什么情况？</strong>上边的代码中，每执行完一次查询，都去检查上下文是否完成，如果为未完成走 default 分支。如果将 for 循环移入 default 或者移入 slowFunc 中，结果会有什么异同呢？</p><ul><li>也会在1秒钟之后结束</li><li>会调用5次 <code>slowFunc</code>，传入 i 从0到5，会打印 5 次 query 提示</li><li>不会打印到 parent context err：因为 select 只有一次，导致第一次进入default 之后就执行完毕了，而没有机会再进入到 <code>&lt;-ctx.Done()</code> 的分支</li></ul><h2 id="七、进程间-Context-间传递"><a href="#七、进程间-Context-间传递" class="headerlink" title="七、进程间 Context 间传递"></a><strong>七、进程间 Context 间传递</strong></h2><p>context 包文档中第一句就介绍，Context 可以携带信息在跨越 API 边界或在进程间传递。前面的例子大多是说在 API 调用的时候传递 ctx 的例子，接下来介绍一下进程间传递信息的示例和实现。</p><p>在进程间传递上下文，需要 RPC 协议的支持。比如较流行的 gRPC 就支持上下文的传递，包括：</p><ul><li>默认的 context 中部分信息，比如超时时间</li><li>用户自己需要传递的元数据信息 metadata</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、基本认识&quot;&gt;&lt;a href=&quot;#一、基本认识&quot; class=&quot;headerlink&quot; title=&quot;一、基本认识&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、基本认识&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;在介绍具体之前，先列几点关于 Context 接口以及 context 包
      
    
    </summary>
    
    
      <category term="Go" scheme="https://JoyTsing.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="https://JoyTsing.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Google Cpp Style Guide</title>
    <link href="https://joytsing.github.io/posts/45891/"/>
    <id>https://joytsing.github.io/posts/45891/</id>
    <published>2024-03-11T11:54:01.000Z</published>
    <updated>2024-03-20T16:20:45.456Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Google C++ Style Guide是一份不错的C++编码指南，直接看下图快速掌握规范的重点内容。不过规范毕竟是人定的，记得活学活用。</p><ol><li>保持一致也非常重要，如果你在一个文件中新加的代码和原有代码风格相去甚远的话，这就破坏了文件本身的整体美观也影响阅读，所以要尽量避免。</li><li>一些条目往往有例外，比如下面这些，所以本图不能代替文档，有时间还是把PDF认真阅读一遍吧。</li></ol><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p><img src="/posts/45891/1.png" alt></p><p>对于高质量的工程，一般会做到：</p><ul><li><p>代码简洁精炼，美观，可读性好，高效率，高复用，可移植性好，高内聚，低耦合，没有冗余，不符合这些原则，必须特别说明。</p></li><li><p>规范性，代码有规可循。特殊排版、特殊语法、特殊指令，必须特别说明。</p></li></ul><h2 id="2-文件排版"><a href="#2-文件排版" class="headerlink" title="2.文件排版"></a><strong>2.文件排版</strong></h2><h3 id="2-1-包含头文件"><a href="#2-1-包含头文件" class="headerlink" title="2.1.包含头文件"></a><strong>2.1.包含头文件</strong></h3><ul><li>a)系统头文件与用户头文件包含区分开，不交叉。</li><li>b)系统头文件，稳定的目录结构，应采用包含子路径方式。#include”sub/test.h”</li><li>c)系统头文件应用：#include</li><li>d)自定义同文件应用：#include “xxx.h”</li><li>e)只引用需要的头文件。</li><li>f)将所有#include的文件名视为大小写敏感。能使用声明的情况下，使用声明。</li></ul><h3 id="2-2-h和cpp文件"><a href="#2-2-h和cpp文件" class="headerlink" title="2.2. h和cpp文件"></a><strong>2.2. h和cpp文件</strong></h3><ul><li>a)头文件命名为<em>.h，内联文件命名为</em>.inl；C++文件命名为*.cpp</li><li>b)文件名用不要用无意义的名称：例如XImage.cpp，命名方式在系统中应该统一。</li><li>c)头文件除了特殊情况，应使用#ifdef控制块。</li><li>d)头文件#endif应采用行尾注释。</li><li>e)头文件，首先是包含全局函数，其次是宏定义代码块，然后是全局变量，全局常量，类型定义，类定义，内联部分。</li><li>f)cpp文件，包含指令，宏定义，全局变量，函数定义。</li></ul><h3 id="2-3-文件结构"><a href="#2-3-文件结构" class="headerlink" title="2.3.文件结构"></a><strong>2.3.文件结构</strong></h3><ul><li>a)文件应包含文件头注释和内容。</li><li>b)函数体类体之间原则上用1个空行，特殊情况下可用一个或者不需要空行。</li></ul><h3 id="2-4-空行"><a href="#2-4-空行" class="headerlink" title="2.4.空行"></a><strong>2.4.空行</strong></h3><p>文件头、控制块，#include部分、宏定义部分、class部分、全局常量部分、全局变量部分、函数和函数之间，用一个空行。</p><hr><h2 id="3-注释方面"><a href="#3-注释方面" class="headerlink" title="3.注释方面"></a><strong>3.注释方面</strong></h2><h3 id="3-1-文件头注释"><a href="#3-1-文件头注释" class="headerlink" title="3.1.文件头注释"></a><strong>3.1.文件头注释</strong></h3><p>作者，文件名称，文件说明，生成日期(可选)，提供模板</p><h3 id="3-2-函数注释"><a href="#3-2-函数注释" class="headerlink" title="3.2.函数注释"></a><strong>3.2.函数注释</strong></h3><ul><li>a)关键函数必须写上注释，说明函数的用途，提供注释模板。</li><li>b)特别函数参数，需要说明参数的目的，由谁负责释放等等。</li><li>c)除了特别情况，注释写在代码之前，不要放到代码行之后。</li><li>d)对每个#else或#endif给出行末注释。</li><li>e)关键代码注释，包括但不限于：赋值，函数调用，表达式，分支等等。</li><li>f)尚未实现完整的代码，或者需要进一步优化的代码，应加上 // TODO …或者同等含义的注释。</li><li>g)调试的代码，加上注释 // DEBUG或者同等含义的注释</li><li>h)需要引起关注的代码，加上注释 // NOTE …或者同等含义的注释</li><li>i)对于较大的代码块结尾，如for,while,do等，可加上 // end for|while|do或者同等含义的注释。</li></ul><hr><h2 id="4-命名方面"><a href="#4-命名方面" class="headerlink" title="4.命名方面"></a><strong>4.命名方面</strong></h2><h3 id="4-1-原则"><a href="#4-1-原则" class="headerlink" title="4.1.原则"></a><strong>4.1.原则</strong></h3><ul><li>a)同一性：在编写一个子模块或派生类的时候，要遵循其基类或整体模块的命名风格，保持命名风格在整个模块中的同一性。</li><li>b)标识符组成：标识符采用英文单词或其组合，应当直观且可以拼读，可望文知意，用词应当准确，避免用拼音命名。</li><li>c)最小化长度 &amp;&amp; 最大化信息量原则：在保持一个标识符意思明确的同时，应当尽量缩短其长度。</li><li>d)避免过于相似：不要出现仅靠大小写区分的相似的标识符，例如”i”与”I”，”function”与”Function”等等。</li><li>e)避免在不同级别的作用域中重名：程序中不要出现名字完全相同的局部变量和全局变量，尽管两者的作用域不同而不会发生语法错误，但容易使人误解。</li><li>f)正确命名具有互斥意义的标识符：用正确的反义词组命名具有互斥意义的标识符，如：”minValue” 和 “maxValue”，”getName()” 和”setName()” ….</li><li>g)避免名字中出现数字编号：尽量避免名字中出现数字编号，如Value1,Value2等，除非逻辑上的确需要编号。</li></ul><h3 id="4-2-函数"><a href="#4-2-函数" class="headerlink" title="4.2.函数"></a><strong>4.2.函数</strong></h3><ul><li>a)类的函数名称应采用首字母小写类似handleXXX命名，例如：handleColor；不推荐采用例如 HandleColor；除了标准c风格代码，标准模板库，不推荐用下划线，例如，handle_color。容易与系统函数标准函数重名，导致不能目视而知其作用范围。</li><li>b)函数参数比较多时，应考虑用结构代替，参数不能超过6个。</li><li>c)如果不能避免函数参数比较多，应在排版上可考虑相似含义的参数占用一行，参数名竖向对齐。甚至每个参数一行。</li></ul><h3 id="4-3-变量"><a href="#4-3-变量" class="headerlink" title="4.3.变量"></a><strong>4.3.变量</strong></h3><p>a)变量命令方式应采用驼峰命令方式。例如handleColor；不同类型变量打头方式见表 1，当类型叠加时，应以最能够表现变量类型的打头方式，例如int类型的指针，应采用p打头；指针类型的数组，应采用a打头，数组的指针因采用p打头。</p><p>表 1 变量类型打头表</p><table><thead><tr><th align="left">类型</th><th align="left">打头</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">int</td><td align="left">n</td><td align="left">如nValue</td></tr><tr><td align="left">bool</td><td align="left">b</td><td align="left"></td></tr><tr><td align="left">long</td><td align="left">l</td><td align="left">如lValue</td></tr><tr><td align="left">float</td><td align="left">f</td><td align="left"></td></tr><tr><td align="left">double</td><td align="left">d</td><td align="left"></td></tr><tr><td align="left">std::string/QString</td><td align="left">str</td><td align="left"></td></tr><tr><td align="left">std::list/QList</td><td align="left">lst</td><td align="left">如lstValues</td></tr><tr><td align="left">std::vector/QVector</td><td align="left">vec</td><td align="left"></td></tr><tr><td align="left">std::map/QMap</td><td align="left">map</td><td align="left"></td></tr><tr><td align="left">枚举</td><td align="left">e</td><td align="left"></td></tr><tr><td align="left">指针</td><td align="left">p</td><td align="left"></td></tr><tr><td align="left">引用</td><td align="left">r</td><td align="left"></td></tr><tr><td align="left">数组</td><td align="left">a</td><td align="left"></td></tr></tbody></table><p>b)不同作用范围的变量应在类型前面添加前缀加下划线，不同作用范围的前缀见表 2。</p><p>表 2变量作用范围前缀表</p><table><thead><tr><th align="left">类型</th><th align="left">前缀</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">成员变量</td><td align="left">m_</td><td align="left">如m_nValue</td></tr><tr><td align="left">全局变量</td><td align="left">g_</td><td align="left">如g_lValue</td></tr><tr><td align="left">静态变量</td><td align="left">s_</td><td align="left">如s_pValuePtr，静态全局和静态成员也应s为前缀</td></tr></tbody></table><h3 id="4-4-类型名"><a href="#4-4-类型名" class="headerlink" title="4.4.类型名"></a><strong>4.4.类型名</strong></h3><ul><li>a)类名和结构体首字母大写，例如MyClass，MyStruct。</li><li>b)类和对象名应是名词。</li><li>c)枚举定义以E_打头，且应全大写，使用下划线分割不同的引文单词，如E_TYPE_STUDENT_INFO，各枚值名字应为枚举类型名打头，例如E_TYPE_STUDENT_INFO_NUMBER。</li><li>d)宏定义以DEF_打头，且应全大写，使用下划线分割不同的引文单词，如DEF_TYPE_ID。</li></ul><hr><h3 id="4-5-风格兼容性"><a href="#4-5-风格兼容性" class="headerlink" title="4.5.风格兼容性"></a><strong>4.5.风格兼容性</strong></h3><p>a)对于移植的或者开源的代码，可以沿用原有风格，不用C++的命名规范。</p><hr><h3 id="5-1-Tab和空格"><a href="#5-1-Tab和空格" class="headerlink" title="5.1.Tab和空格"></a>5.1.Tab和空格</h3><ul><li>a)每一行开始处的缩进只能用4个空格，不能用Tab，输入内容之后统一用空格。</li><li>b)在代码行的结尾部分不能出现多余的空格。</li><li>c)不要在”::”,”-&gt;”,”.”前后加空格。</li><li>d)不要在”，”,”；”之前加空格。</li></ul><h3 id="5-2-类型定义"><a href="#5-2-类型定义" class="headerlink" title="5.2.类型定义"></a><strong>5.2.类型定义</strong></h3><ul><li>a)类，结构，枚举，联合：大括号另起一行</li><li>b)函数体的{需要新起一行，在{之前的缩进应与上一级对齐。</li><li>c)除了特别情况，函数体内不能出现两个空行。</li><li>d)除了特别情况，函数体内不能宏定义指令，除非该宏定义仅能在该函数内使用。</li><li>e)在一个函数体内，逻揖上密切相关的语句之间不加空行，其它地方应加空行分隔。</li></ul><h3 id="5-3-代码块"><a href="#5-3-代码块" class="headerlink" title="5.3.代码块"></a><strong>5.3.代码块</strong></h3><ul><li>a)”if”、”for”、”while”、”do”、”try”、”catch” 等语句自占一行，执行语句不得紧跟其后。不论执行语句有多少都要加 “{ }” 。这样可以防止书写和修改代码时出现失误。</li><li>b)”if”、”for”、”while”、”do”、”try”、”catch” 的括号和表达式，括号可紧挨关键字，这样强调的是表达式。</li></ul><h3 id="5-4-代码行"><a href="#5-4-代码行" class="headerlink" title="5.4.代码行"></a><strong>5.4.代码行</strong></h3><ul><li>a)一行代码只做一件事情，如只定义一个变量，或只写一条语句。这样的代码容易阅读，并且方便于写注释。</li><li>b)多行变量定义，为了追求代码排版美观，可将变量竖向对齐。</li><li>c)代码行最大长度宜控制在一定个字符以内，能在当前屏幕内全部可见为宜。建议80个。</li></ul><h3 id="5-5-宏"><a href="#5-5-宏" class="headerlink" title="5.5.宏"></a><strong>5.5.宏</strong></h3><ul><li>a)不要用分号结束宏定义。</li><li>b)能使用函数来解决的问题，不要使用宏，方便调式。</li></ul><h3 id="5-6-goto"><a href="#5-6-goto" class="headerlink" title="5.6.goto"></a><strong>5.6.goto</strong></h3><ul><li>a)不要用goto。</li></ul><hr><h2 id="6-类型"><a href="#6-类型" class="headerlink" title="6.类型"></a><strong>6.类型</strong></h2><ul><li>a)定义指针和引用时*和&amp;紧跟变量名。</li><li>b)尽量避免使用浮点数，除非必须。</li><li>c)用typedef简化程序中的复杂语法。</li><li>d)避免定义无名称的类型。例如： enum TState { EIdle, EActive };</li><li>e)少用union，如果一定要用，则采用简单数据类型成员。</li><li>f)用enum取代(一组相关的)常量。</li><li>g)不要使用魔鬼数字。</li><li>h)尽量用引用取代指针。</li><li>i)定义变量完成后立即初始化，勿等到使用时才进行，在需要使用到变量的时候才定义变量。</li><li>j)如果有更优雅的解决方案，不要使用强制类型转换。例如dynamic_cast，尽量使用多态。</li></ul><hr><h2 id="7-表达式"><a href="#7-表达式" class="headerlink" title="7.表达式"></a><strong>7.表达式</strong></h2><ul><li>a)避免在表达式中用赋值语句。</li><li>b)避免对浮点类型做等于或不等于判断。</li><li>c)不能将枚举类型进行运算后再赋给枚举变量。</li><li>d)在循环过程中不要修改循环计数器。</li><li>e)检测空指针，用 if( p )</li><li>f)检测非空指针，用 if( ! p )</li></ul><hr><h2 id="8-函数"><a href="#8-函数" class="headerlink" title="8.函数"></a><strong>8.函数</strong></h2><h3 id="8-1-引用"><a href="#8-1-引用" class="headerlink" title="8.1.引用"></a><strong>8.1.引用</strong></h3><ul><li>a)引用类型作为返回值：函数必须返回一个存在的对象。</li><li>b)引用类型作为参数：调用者必须传递一个存在的对象。</li></ul><h3 id="8-2-返回值"><a href="#8-2-返回值" class="headerlink" title="8.2.返回值"></a><strong>8.2.返回值</strong></h3><ul><li>a)除开void函数，构造函数，析构函数，其它函数必须要有返回值。在函数的实现中，每个分支必须显示返回return。</li><li>b)当函数返回引用或指针时，用文字描述其有效期。</li></ul><h3 id="8-3-内联函数"><a href="#8-3-内联函数" class="headerlink" title="8.3.内联函数"></a><strong>8.3.内联函数</strong></h3><ul><li>a)内联函数应将函数体放到类体外。</li><li>b)只有简单的函数才有必要设计为内联函数，复杂业务逻辑的函数不要这么做。</li><li>c)虚函数不要设计为内联函数。</li></ul><h3 id="8-4-函数参数"><a href="#8-4-函数参数" class="headerlink" title="8.4.函数参数"></a><strong>8.4.函数参数</strong></h3><ul><li>a)只读取该参数的内容，不对其内容做修改，用常量引用。</li><li>b)修改参数内容，或需要通过参数返回，用非常量引用。</li><li>c)简单数据类型用传值方式。</li><li>d)复杂数据类型用引用或指针方式。</li><li>e)输入参数排在前面，输出参数排在后面，默认参数除外。</li><li>f)除通用库函数，尽量不使用默认参数。</li></ul><hr><h2 id="9-类"><a href="#9-类" class="headerlink" title="9.类"></a><strong>9.类</strong></h2><h3 id="9-1-整体结构"><a href="#9-1-整体结构" class="headerlink" title="9.1.整体结构"></a><strong>9.1.整体结构</strong></h3><ul><li>a)按照 public, protected, private 的顺序分块。哪一块没有，就直接忽略。</li><li>b)每一块中，按照下面顺序排列</li></ul><p>1)typedef，enum，struct，class 定义的嵌套类型</p><p>2)常量</p><p>3)构造函数</p><p>4)析构函数</p><p>5)成员函数,含静态成员函数</p><p>6)数据成员,含静态数据成员</p><ul><li>c).cpp 文件中，函数的实现尽可能和声明次序一致。</li></ul><h3 id="9-2-构造函数"><a href="#9-2-构造函数" class="headerlink" title="9.2.构造函数"></a><strong>9.2.构造函数</strong></h3><ul><li>a)构造函数的初始化列表，应和类里成员变量的顺序一致。</li><li>b)初始化列表中的每个项，应独占一行。</li><li>c)避免出现用一个成员初始化另一个成员。</li><li>d)构造函数应初始化所有成员，尤其是指针。</li><li>e)不要在构造函数和析构函数中抛出异常。</li></ul><h3 id="9-3-纯虚函数"><a href="#9-3-纯虚函数" class="headerlink" title="9.3.纯虚函数"></a><strong>9.3.纯虚函数</strong></h3><p>接口类的虚函数应设计为纯虚函数。</p><h3 id="9-4-构造和析构函数"><a href="#9-4-构造和析构函数" class="headerlink" title="9.4.构造和析构函数"></a><strong>9.4.构造和析构函数</strong></h3><ul><li>a)如果类可以继承，则应将类析构函数设计为虚函数。</li><li>b)如果类不允许继承，则应将类析构函数设计为非虚函数。</li><li>c)如果类不能被复制，则应将拷贝构造函数和赋值运算符设计为私有的。</li><li>d)如果为类设计了构造函数，则应有析构函数。</li></ul><h3 id="9-5-成员变量"><a href="#9-5-成员变量" class="headerlink" title="9.5.成员变量"></a><strong>9.5.成员变量</strong></h3><ul><li>a)尽量避免使用mutable(mutex除外)和volatile。</li><li>b)尽量避免使用公有成员变量。</li></ul><h3 id="9-6-成员函数"><a href="#9-6-成员函数" class="headerlink" title="9.6.成员函数"></a><strong>9.6.成员函数</strong></h3><ul><li>a)努力使类的接口少而完备。</li><li>b)尽量使用常成员函数代替非常量成员函数，const函数</li><li>c)除非特别理由，绝不要重新定义非虚函数。</li><li>d)如果是子类型重写父类的虚函数，应该在函数声明后面添加override，让编译器来检查是否重新定义非虚函数。C++11</li><li>e)不想被子类重写的虚函数，函数声明后面添加final。C++11</li></ul><h3 id="9-7-继承"><a href="#9-7-继承" class="headerlink" title="9.7.继承"></a><strong>9.7.继承</strong></h3><ul><li>a)继承必须满足IS-A的关系，HAS-A应采用包含。</li><li>b)虚函数不要采用默认参数。</li><li>c)除非特别需要，应避免设计大而全的虚函数，虚函数功能要单一。</li><li>d)除非特别需要，避免将基类强制转换成派生类。</li></ul><h2 id="10-错误处理"><a href="#10-错误处理" class="headerlink" title="10.错误处理"></a><strong>10.错误处理</strong></h2><ul><li>a)释放内存完成后将指针赋空，避免出现野指针。</li><li>b)使用指针前进行判断合法性，应考虑到为空的情况的处理，除非明显的组合模式。</li><li>c)使用数组时，应先判断索引的有效性，处理无效的索引的情况。</li><li>d)卫句风格：先处理所有可能发生错误的情况，再处理正常情况。</li></ul><hr><h2 id="11-性能"><a href="#11-性能" class="headerlink" title="11.性能"></a><strong>11.性能</strong></h2><ul><li><p>a)头文件中使用前向声明代替头文件包含。Class M;</p></li><li><p>b)尽量在for循环之前，先写计算估值表达式。</p></li><li><p>c)尽量避免在循环体内部定义对象。</p></li><li><p>d)避免对象拷贝，尤其是代价很高的对象拷贝。</p></li><li><p>e)避免生成临时对象，尤其是大的临时对象。</p></li><li><p>f)注意大尺寸对象数组。</p></li><li><p>g)尽量使用标准库中封装的算法。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Google C++ Style Guide是一份不错的C++编码指南，直接看下图快速掌握规范的重点内容。不过规范毕竟是人定的，记得活学活用
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Cpp 中如何优雅进行 enum 到 string 的转换</title>
    <link href="https://joytsing.github.io/posts/30790/"/>
    <id>https://joytsing.github.io/posts/30790/</id>
    <published>2024-03-11T11:27:58.000Z</published>
    <updated>2024-03-20T16:13:18.592Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这里不介绍非侵入式的写法，具体想要了解的话可以观看<a href="https://zhuanlan.zhihu.com/p/680412313">这篇文章</a>,这里仅介绍通过宏写法来进行转换的情况。</p><h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><p>这里拿minilog的log-level定义来介绍，首先肯定是需要按照等级先进行定义：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">define</span> MINILOG_FOREACH_LOG_LEVEL(f) \  f(trace) f(debug) f(info) f(critical) f(warn) f(error) f(fatal)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>后续如果要修改只用修改这一处就行了，优点是一劳永逸，不存在维护额外开销的问题，当然缺点也有，比如在写server的时候遇到过需要将传入的指令进行与操作整合的情况，这种类型的情况下就无法使用宏的方法，或者说需要额外处理。</p><p>在定义好各个level后就需要进行enum的声明了：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">log_level</span> <span class="token operator">:</span> std<span class="token operator">::</span>uint8_t <span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">define</span> _FUNCTION(name) name,</span>  <span class="token function">MINILOG_FOREACH_LOG_LEVEL</span><span class="token punctuation">(</span>_FUNCTION<span class="token punctuation">)</span><span class="token macro property">#<span class="token directive keyword">undef</span> _FUNCTION</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体来说就是将log_level在enum中用宏函数进行了展开，避免无用代码的编写。接下来是文章的核心，怎么进行enum和string的相互转化。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">inline</span> std<span class="token operator">::</span>string <span class="token function">log_level_name</span><span class="token punctuation">(</span>log_level level<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">switch</span> <span class="token punctuation">(</span>level<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">define</span> _FUNCTION(name) \  case log_level::name: \    return #name;</span>    <span class="token function">MINILOG_FOREACH_LOG_LEVEL</span><span class="token punctuation">(</span>_FUNCTION<span class="token punctuation">)</span><span class="token macro property">#<span class="token directive keyword">undef</span> _FUNCTION</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token string">"unknown"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">inline</span> log_level <span class="token function">log_level_from_name</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string_view lev<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">define</span> _FUNCTION(name) \  if (lev == #name) return log_level::name;</span>  <span class="token function">MINILOG_FOREACH_LOG_LEVEL</span><span class="token punctuation">(</span>_FUNCTION<span class="token punctuation">)</span><span class="token macro property">#<span class="token directive keyword">undef</span> _FUNCTION</span>  <span class="token keyword">return</span> log_level<span class="token operator">::</span>info<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>非常方便，相当于自动维护对应的代码，事实上，clang 在定义TokenKind的时候，就是这么做的，具体的案例请参考。由于 clang 要适配多种语言前端，最后总计的TokenKind有几百个之多。如果不这样做，可想而知，进行Token的增加和修改会十分困难。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;这里不介绍非侵入式的写法，具体想要了解的话可以观看&lt;a href=&quot;https://zhuanlan.zhihu.com/p/6804123
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>More Effective-CPP:读书笔记</title>
    <link href="https://joytsing.github.io/posts/59007/"/>
    <id>https://joytsing.github.io/posts/59007/</id>
    <published>2024-03-11T06:30:01.000Z</published>
    <updated>2024-03-20T16:21:03.033Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>虽然早在4年前的大二时期就看过并且实践在工程作业里面，但一直没有一个完整的记录，想着别的几本都有了干脆补全一下吧，个人总结，难免会出现一些不太准确的地方，欢迎各位指正。</p><h2 id="条款1：仔细区别-pointers-和-references"><a href="#条款1：仔细区别-pointers-和-references" class="headerlink" title="条款1：仔细区别 pointers 和 references"></a>条款1：仔细区别 pointers 和 references</h2><ul><li>reference 不能为 null。</li><li>一般而言，当你需要考虑“不指向任何对象”的可能性时，或是考虑“在不同事件指向不同对象”的能力时，你就应该采用 pointer。</li><li>当你知道你需要指向某个东西，而且绝不会改变指向其他东西，或是当你实现一个操作符而其语法需求无法由 pointers 达成，你就应该选择 reference。任何其他时候，请采用 pointers。</li></ul><h2 id="条款2：最好使用-C-转型操作符"><a href="#条款2：最好使用-C-转型操作符" class="headerlink" title="条款2：最好使用 C++ 转型操作符"></a>条款2：最好使用 C++ 转型操作符</h2><h3 id="1-static-cast"><a href="#1-static-cast" class="headerlink" title="1 static_cast"></a>1 static_cast</h3><p>使用 <code>static_cast&lt;type&gt;(expression)</code>代替 (type)expression</p><h3 id="2-const-cast"><a href="#2-const-cast" class="headerlink" title="2 const_cast"></a>2 const_cast</h3><p>将某个对象的常量性去除掉</p><h3 id="3-dynamic-cast"><a href="#3-dynamic-cast" class="headerlink" title="3 dynamic_cast"></a>3 dynamic_cast</h3><ul><li>利用<code>dynamic_cast</code>，将“指向 base class objects 的 pointers 或 references”转型为“指向derived（或 sibling base）class objects 的 pointers 或 references”， 并得知转型是否成功。</li><li>如果转型失败，会以一个 null 指针（当转型对象是指针）或一个 exception （当转型对象是 reference）表现出来。</li></ul><h3 id="4-reinterpret-cast"><a href="#4-reinterpret-cast" class="headerlink" title="4 reinterpret_cast"></a>4 reinterpret_cast</h3><p>最常用用途是转换“函数指针”类型，对应C里面的强制转换</p><h2 id="条款3：绝对不要以多态（polymorphically）方式处理数组"><a href="#条款3：绝对不要以多态（polymorphically）方式处理数组" class="headerlink" title="条款3：绝对不要以多态（polymorphically）方式处理数组"></a>条款3：绝对不要以多态（polymorphically）方式处理数组</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">base</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">base</span><span class="token punctuation">(</span><span class="token keyword">int</span> p1<span class="token punctuation">,</span> <span class="token keyword">int</span> p2<span class="token punctuation">)</span>        <span class="token operator">:</span><span class="token function">p1</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">p2</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> p1<span class="token punctuation">,</span> p2<span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> p1 <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> p2 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">derived</span> <span class="token operator">:</span> <span class="token keyword">public</span> base<span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">derived</span><span class="token punctuation">(</span><span class="token keyword">int</span> p1<span class="token punctuation">,</span> <span class="token keyword">int</span> p2<span class="token punctuation">,</span> <span class="token keyword">int</span> p3<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">base</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">p3</span><span class="token punctuation">(</span>p3<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> p3<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override<span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> p1 <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> p2 <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> p3 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>base array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">"th item's size is: "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    base    <span class="token function">b1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span>  <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    derived <span class="token function">d1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>   <span class="token number">2</span><span class="token punctuation">,</span>  <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    base    <span class="token function">b2</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">,</span>  <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    derived <span class="token function">d2</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span>   <span class="token number">5</span><span class="token punctuation">,</span>  <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    base array<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>d1<span class="token punctuation">,</span> b1<span class="token punctuation">,</span> d2<span class="token punctuation">,</span> b2<span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sizeof(base): "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>b1<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\tsizeof(derived): "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>d1<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// sizeof(base): 8 sizeof(derived): 12</span>    <span class="token function">print</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 0th item's size is: 8    1, 2</span>    <span class="token comment" spellcheck="true">// 1th item's size is: 8    10, 20</span>    <span class="token comment" spellcheck="true">// 2th item's size is: 8    4, 5</span>    <span class="token comment" spellcheck="true">// 3th item's size is: 8    40, 50</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你交给printBaseArray函数一个包含derived对象组成的数组，你的编译器就会被误导。这种情况下它仍假设数组中的每一个元素的大小是base的大小，但其实每一个元素的大小是不一样的。</p><h2 id="条款4：非必要不提供-default-constructor"><a href="#条款4：非必要不提供-default-constructor" class="headerlink" title="条款4：非必要不提供 default constructor"></a>条款4：非必要不提供 default constructor</h2><ul><li>在一个完美的世界中，凡可以“合理地从无到有生成对象”的 classes，都应该内含 default constructors，“必须有某些外来信息才能生成对象” 的 classes，则不必拥有 default constructors。</li><li>在进退维谷的情况下，最后一个考虑点和 virtual base classes 有关。 Virtual base classes 如果缺乏 default constructors，与之合作将会是一种刑法。</li><li>添加无意义的 constructors，也会影响 classes 的效率。</li></ul><h2 id="条款5：对定制的-“类型转换函数”-保持警觉"><a href="#条款5：对定制的-“类型转换函数”-保持警觉" class="headerlink" title="条款5：对定制的 “类型转换函数” 保持警觉"></a>条款5：对定制的 “类型转换函数” 保持警觉</h2><p>下述代码根本的原因在于，在你从未打算也未预期的情况下，此函数可能会被调用，而其结果可能是不正确.不直观的程序行为很难发现调试。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Rational</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Rational</span><span class="token punctuation">(</span><span class="token keyword">int</span> numerator <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">int</span> denominator <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">operator</span> <span class="token keyword">double</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token keyword">friend</span> std<span class="token operator">::</span>ostream <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>std<span class="token operator">::</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> Rational <span class="token operator">&amp;</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> numerator<span class="token punctuation">;</span>    <span class="token keyword">int</span> denominator<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Rational<span class="token operator">::</span><span class="token function">Rational</span><span class="token punctuation">(</span><span class="token keyword">int</span> numerator<span class="token punctuation">,</span> <span class="token keyword">int</span> denominator<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>numerator <span class="token operator">=</span> numerator<span class="token punctuation">;</span>     <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>denominator <span class="token operator">=</span> denominator<span class="token punctuation">;</span><span class="token punctuation">}</span>Rational<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">double</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>numerator<span class="token punctuation">)</span><span class="token operator">/</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>denominator<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>std<span class="token operator">::</span>ostream <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>std<span class="token operator">::</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> Rational <span class="token operator">&amp;</span>r<span class="token punctuation">)</span> <span class="token punctuation">{</span>    os <span class="token operator">&lt;&lt;</span> r<span class="token punctuation">.</span>numerator <span class="token operator">&lt;&lt;</span> <span class="token string">"/"</span> <span class="token operator">&lt;&lt;</span> r<span class="token punctuation">.</span>denominator <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> os<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   Rational <span class="token function">r</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> r<span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// 1/2</span>   <span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">0.5</span> <span class="token operator">*</span> r<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 0.25</span>   std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> d <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假设你忘了为 Rational 写一个 operator&lt;&lt;，你或许以为上述的 std::cout &lt;&lt; r; 不会成功，因为没有适当的 operator&lt;&lt; 可以调用。但是你错了，你的编译器面对上述动作，发现不存在任何 operator&lt;&lt; 可以接受一个 Rational，但它会想尽各种办法（包括找出一系列可接受的隐式类型转换）让函数调用动作成功。即进行了隐式类型转换，导致（非预期）的函数被调用。</p><p>解决这个问题，可以采用:</p><ul><li>以功能对等的另一个函数取代类型转换操作符</li><li>使用关键字 explicit</li></ul><h2 id="条款6：区别-increment-decrement-操作符的前置-prefix-和后置-postfix-形式"><a href="#条款6：区别-increment-decrement-操作符的前置-prefix-和后置-postfix-形式" class="headerlink" title="条款6：区别 increment/decrement 操作符的前置(prefix)和后置(postfix)形式"></a>条款6：区别 increment/decrement 操作符的前置(prefix)和后置(postfix)形式</h2><pre class="line-numbers language-c++"><code class="language-c++">class UPInt{public:    UPInt(int i)                    //提供一个构造函数        :val(i){};    UPInt& operator++();            //前置++    const UPInt operator++(int);    //后置++    UPInt& operator--();            //前置--    const UPInt operator--(int);    //后置--    UPInt& operator+=(const int i); //+=操作符    //...    int val;};//前置++，返回referenceUPInt &UPInt::operator++() {    *this += 1;    return *this;}//后置++，返回一个const对象const UPInt UPInt::operator++(int) {    UPInt oldValue = *this;    ++(*this);    return oldValue;}//前置--，返回referenceUPInt &UPInt::operator--() {    *this += -1;    return *this;}//后置--，返回一个const对象const UPInt UPInt::operator--(int) {    UPInt oldValue = *this;    --(*this);    return oldValue;}//+=操作符，看需求，这里返回一个 referenceUPInt &UPInt::operator+=(const int i) {    this->val = this->val + i;    return *this;}//这里帮助打印UPint里的val值void print(const UPInt &up) { std::cout << up.val <<std::endl; }int main(){    UPInt i(0);    print(i);       // 0    print(++i);     // 1    print(i++);     // 1    print(i);       // 2    print(--i);     // 1    print(i--);     // 1    print(i);       // 0}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为什么后置++或–返回的是一个const值呢？如果不是一个const值的话，那么下面的动作就是合法的。</p><pre class="line-numbers language-cpp"><code class="language-cpp">    UPInt <span class="token function">i</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    i<span class="token operator">++</span><span class="token operator">++</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>处理用户定制类型时，应尽可能使用前置式 increment，因为它天生体质较佳。</p><h2 id="条款7：千万不要重载-amp-amp-，-和-操作符"><a href="#条款7：千万不要重载-amp-amp-，-和-操作符" class="headerlink" title="条款7：千万不要重载 &amp;&amp;，|| 和 , 操作符"></a>条款7：千万不要重载 &amp;&amp;，|| 和 , 操作符</h2><p>C++ 对于“真假值表达式”采用所谓的“骤死式”评估方式。意思是一旦该表达式的真假值确定，即使表达式中还有部分尚未检验，整个评估工作仍结束。</p><p>如果你决定重载 operator&amp;&amp; 或 operator||，你必须知道，你正在从根本层面改变整个游戏规则，因为从此“函数调用”语义会取代“骤死式”语义。</p><p>如果你将 &amp;&amp; 或 || 重载，就没有办法提供程序员预期（甚至依赖）的某种行为模式。</p><p><strong>如果你没有什么好的理由将某个操作符重载，就不要去做。</strong></p><h2 id="条款8：了解各种不同意义的-new-和-delete"><a href="#条款8：了解各种不同意义的-new-和-delete" class="headerlink" title="条款8：了解各种不同意义的 new 和 delete"></a>条款8：了解各种不同意义的 new 和 delete</h2><h3 id="new-operator"><a href="#new-operator" class="headerlink" title="new operator"></a>new operator</h3><p>举个例子，当你写出这样的代码，就是使用了所谓的 new operator</p><p>string *ps = new string(“Hello World!”);<br>分配足够的内存，用来放置某类型的对象<br>调用一个constructor，为上一步中分配的内存中的那个对象设定初始值。<br>new operator 总是做这两件事，无论如何你不能改变其行为。</p><h3 id="operator-new"><a href="#operator-new" class="headerlink" title="operator new"></a>operator new</h3><p>举个例子，函数 operator new 通常声明如下</p><blockquote><p>void *operator new(size_t size);</p></blockquote><p>上述返回值类型是 void*。此函数返回一个指针，直线一块原始的、未设初始值的内存。函数中的 size_t 参数表示需要分配多少内存。你可以将 operator new 重载，加上额外的参数，但第一参数的类型必须总是 size_t。</p><p>举个例子</p><blockquote><p>void *rawMemory = operator new(sizeof(string))</p></blockquote><p>这里的 operator new 将返回指针，指向一块足够容纳一个 string 对象的内存。和 malloc 一样 operator new 的唯一任务就是分配内存。</p><h3 id="placement-new"><a href="#placement-new" class="headerlink" title="placement new"></a>placement new</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">new</span><span class="token punctuation">(</span>内存地址<span class="token punctuation">)</span> 类<span class="token punctuation">(</span><span class="token punctuation">[</span>实参<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">base</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">base</span><span class="token punctuation">(</span><span class="token keyword">int</span> p1<span class="token punctuation">)</span>        <span class="token operator">:</span><span class="token function">p1</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> p1<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>base<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 4</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 1</span>    <span class="token keyword">char</span> <span class="token operator">*</span>memory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>base<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// address: 0xdb3278</span>    base <span class="token operator">*</span>b1 <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>memory<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">base</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// address:0xdb3278    val:e8 03 00 00     03e8    = 1000</span>    base <span class="token operator">*</span>b2 <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>memory<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">base</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// address:0xdb327c    val:02 00 00 00     02      = 2</span>    base <span class="token operator">*</span>b3 <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>memory<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">base</span><span class="token punctuation">(</span><span class="token number">9999999</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// address:0xdb3280    val:7f 96 98 00     98967f  = 9999999</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简而言之，如果你有一些分配好的内存，且需要在上面构建对象。那么可以使用 placement new。</p><table><thead><tr><th></th><th>分配内存</th><th>构造</th></tr></thead><tbody><tr><td>new operator</td><td>√</td><td>√</td></tr><tr><td>operator new</td><td>√</td><td>×</td></tr><tr><td>placement new</td><td>×</td><td>√</td></tr></tbody></table><p>至于delete也是同理，不在这过多描述(很少使用)。</p><h2 id="条款9：利用-deconstructors-避免泄露资源"><a href="#条款9：利用-deconstructors-避免泄露资源" class="headerlink" title="条款9：利用 deconstructors 避免泄露资源"></a>条款9：利用 deconstructors 避免泄露资源</h2><ul><li>使用析构函数</li><li>使用智能指针</li></ul><p>当然，到了现在一般更喜欢依赖RAII来对资源进行自动管理，也更加优雅。</p><h2 id="条款10：在-constructors-内阻止资源泄露"><a href="#条款10：在-constructors-内阻止资源泄露" class="headerlink" title="条款10：在 constructors 内阻止资源泄露"></a>条款10：在 constructors 内阻止资源泄露</h2><ul><li>C++ 只会析构已构造完成的对象</li><li>对于在构造期抛出 exceptions 的对象，C++不会自动清理，所以你必须设计你的 constructors 使它们能够在那种情况下也能自我清理。</li><li>一个更好的解答是，接受条款9的忠告，将point data members所指对象视为资源，交给局部对象管理（即使用智能指针）。</li></ul><h2 id="条款11：禁止异常（exceptions）流出-destructors-之外"><a href="#条款11：禁止异常（exceptions）流出-destructors-之外" class="headerlink" title="条款11：禁止异常（exceptions）流出 destructors 之外"></a>条款11：禁止异常（exceptions）流出 destructors 之外</h2><p>两种情况下 destructor <strong>会被调用</strong>：</p><ul><li>当对象在正常状态下被销毁，也就是当它离开了它的生存空间(scope)或是被明确地删除。</li><li>当对象被 exception 处理机制——也就是 exception 传播过程中的 stk-unwinding(栈展开)机制——销毁。</li></ul><p><strong>危害</strong>：</p><ul><li>如果控制权基于 exception 的因素离开 destructor，而此时正有另一个 exception 处于作用状态，C++ 会调用 terminate 函数。此函数会将你的程序结束掉——它会立刻动手，甚至不等局部对象被销毁。</li></ul><p>全力阻止 exceptions 传出 destructors 的好处：</p><ul><li>避免 terminate 函数在 exception 传播过程的栈展开(stack-unwinding)机制中被调用。</li><li>协助确保 destructors 完成其应该完成的所有事情。</li></ul><p>换句话说，一定要保证析构函数是nonexpection的。</p><h2 id="条款12：了解“抛出一个-exception”-与-“传递一个参数”-或-“调用一个虚函数”-之间的差异"><a href="#条款12：了解“抛出一个-exception”-与-“传递一个参数”-或-“调用一个虚函数”-之间的差异" class="headerlink" title="条款12：了解“抛出一个 exception” 与 “传递一个参数” 或 “调用一个虚函数” 之间的差异"></a>条款12：了解“抛出一个 exception” 与 “传递一个参数” 或 “调用一个虚函数” 之间的差异</h2><p>函数参数和 exceptions 的传递方式有3种:</p><ul><li>by value</li><li>by reference</li><li>by pointer</li></ul><p>区别1：当你调用一个函数，控制器最终会回到调用端（除非函数失败以至于无法返回），但是当你抛出一个 exception ，控制权不会再回到抛出端。而且一个对象被抛出作为 exception 时，总是会发生复制(copy)。</p><p>区别2：“抛出exception”比“传递参数”慢。因为“exception objects 必定会造成复制行为”这一事实，所以解释了“抛出exception”常常比“传递参数”慢。复制动作永远是以静态类型为本。</p><p>区别3：函数调用过程中将一个临时对象传递给一个 non-const reference 参数是不允许的，但是对 exceptions 则属合法。一个被抛出的对象（必为临时对象）可以简单地用 by reference 的方式捕捉，不需要以 by reference-to-const 的方式捕捉。</p><p>区别4：“抛出exception” 比 “传递函数参数”多构造一个“被抛出物”的副本（并于稍后析构），千万不要抛出一个指向局部对象的指针，因为该局部对象会在 exception 传离其 scope 时被销毁，因此 catch 子句会获得一个指向“已被销毁的对象”的指针。这正时“义务性复制(copy)规则”的设计要避免的情况。</p><p>区别5：“自变量传递”与“exception 传播”两动作有着互异的做法。</p><p>区别6：catch 子句总是依出现顺序做匹配尝试。</p><p><strong>总结</strong>：“传递对象到函数去，或是以对象调用虚函数”和“将对象抛出成为一个exception”之间，有3个主要差异</p><ul><li>exception objects 总是会被复制，如果以 by value 方式捕捉，它们甚至被复制两次。至于传递给函数参数的对象则不一定得复制。</li><li>被抛出成为 exceptions 的对象，其被允许的类型转换动作，比“被传递到函数去”的对象少。</li><li>catch 子句以其“出现于源代码的顺序”被编译器检验对比，其中第一个匹配成功者变执行；而当我们以某对象调用一个虚函数，被选中执行的是那个“与对象类型最佳吻合”的函数，不论它是不是源代码所列的第一个。</li></ul><h2 id="条款13：以-by-reference-方式捕捉-exceptions"><a href="#条款13：以-by-reference-方式捕捉-exceptions" class="headerlink" title="条款13：以 by reference 方式捕捉 exceptions"></a>条款13：以 by reference 方式捕捉 exceptions</h2><ul><li>避开 exception objects 的切割（slicing）的问题</li><li>保留捕捉标准 exceptions 的能力</li><li>约束了exception objects 需被复制的次数</li></ul><h2 id="条款14：明智运用-exception-specifications"><a href="#条款14：明智运用-exception-specifications" class="headerlink" title="条款14：明智运用 exception specifications"></a>条款14：明智运用 exception specifications</h2><p>告诉编译器函数不引发任何异常。 但是，在 std:c++14 模式下，如果函数确实引发异常，这可能会导致未定义的行为。 因此，建议使用 noexcept 运算符：</p><h2 id="条款15：了解异常处理（exception-handling）的成本"><a href="#条款15：了解异常处理（exception-handling）的成本" class="headerlink" title="条款15：了解异常处理（exception handling）的成本"></a>条款15：了解异常处理（exception handling）的成本</h2><p>只要你用上那么一个，也就是说一旦你决定捕捉 exceptions，你就得付出那样的成本。不同的编译器以不同的方法实现 try 语句块，代码大约整体膨胀 5%~10%，执行速度亦下降这个数。</p><p><strong>为了将此成本最小化，你应该避免非必要的 try 语句块</strong>。</p><h2 id="条款16：谨记-80-20-法则"><a href="#条款16：谨记-80-20-法则" class="headerlink" title="条款16：谨记 80-20 法则"></a>条款16：谨记 80-20 法则</h2><p>软件的证一性能几乎总是由其构成要素（代码）的一小部分决定。</p><h2 id="条款17：考虑使用-lazy-evaluation（缓式评估）"><a href="#条款17：考虑使用-lazy-evaluation（缓式评估）" class="headerlink" title="条款17：考虑使用 lazy evaluation（缓式评估）"></a>条款17：考虑使用 lazy evaluation（缓式评估）</h2><ul><li>Reference Counting（引用计数）：在你真正需要之前，不必着急为某物做一个副本——可避免非必要的对象复制</li><li>区分读和写：可区别 operator[]的读和写的动作</li><li>Lazy Fatching（缓式取出）：可避免非必要的数据库读取动作</li><li>Lazy Expression Evaluation（表达式缓评估）：可避免非必要的数值计算动作</li></ul><p><strong>总结</strong><br>如果你的计算是必要的，lazy evaluation 并不会为你的程序节省人和工作或任何时间。只有当“你的软件被要求执行某些计算，而那些计算其实可以避免”的情况下，lazy evaluation 才有用处。</p><h2 id="条款18：分期摊还预期的计算成本"><a href="#条款18：分期摊还预期的计算成本" class="headerlink" title="条款18：分期摊还预期的计算成本"></a>条款18：分期摊还预期的计算成本</h2><p>简单来说，就是使用缓存。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">findCubicleNumber</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>employeeName<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">typedef</span> map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> CubicleMap<span class="token punctuation">;</span>    <span class="token keyword">static</span> CubicleMap cubes<span class="token punctuation">;</span>    CubicleMap<span class="token operator">::</span>iterator it <span class="token operator">=</span> cubes<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>employeeName<span class="token punctuation">)</span>  <span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>it <span class="token operator">==</span> cubes<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> cubicle <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   <span class="token comment" spellcheck="true">// 这里逻辑处理</span>        cubes<span class="token punctuation">[</span>employeeName<span class="token punctuation">]</span> <span class="token operator">=</span> cubicle<span class="token punctuation">;</span>        <span class="token keyword">return</span> cubicle<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后一个语句返回 (*it).second 而非传统的 it-&gt;second，为什么？答案关系到STL实行的规矩。简单地说，iterator本身是对象，不是指针，所以并不能保证 -&gt; 可施行于 it 身上。但STL明确要求 . 和 * 对 iterators 必须有效，所以 (*it).second 虽然语法上笨拙，却保证能够有效运行。</p><h2 id="条款19：了解临时对象的来源"><a href="#条款19：了解临时对象的来源" class="headerlink" title="条款19：了解临时对象的来源"></a>条款19：了解临时对象的来源</h2><p>临时对象可能很耗成本，所以你应该尽可能消除它们。这本书写成的时候比较早，到现在有了std::move和移动构造，移动赋值，就转换成了左值和右值的问题。</p><h2 id="条款20：协助完成“返回值优化-RVO"><a href="#条款20：协助完成“返回值优化-RVO" class="headerlink" title="条款20：协助完成“返回值优化(RVO)"></a>条款20：协助完成“返回值优化(RVO)</h2><p>函数返回对象，背后隐藏着 constructor 和 destructor。如果是为了行为正确而不得不这么做，是可以返回一个对象的；否则就不要那么做。</p><p>有人企图采用某些方法消除 by-value的返回方式</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const</span> Rational<span class="token operator">*</span> <span class="token keyword">operator</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>Rational a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>Rational c <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>a <span class="token operator">*</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样会使得整个调用流程显得不自然，同时调用者也需要手动删除此函数返回的指针，不然会导致资源泄露。</p><p>有些人试图返回 references, 于是就有了</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//h</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//cpp</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">{</span>    Rational <span class="token function">result</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span><span class="token function">numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> rhs<span class="token punctuation">.</span><span class="token function">numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lhs<span class="token punctuation">.</span>denominator <span class="token operator">*</span> rhs<span class="token punctuation">.</span><span class="token function">denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//use</span>Rational a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>Rational c <span class="token operator">=</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这看起来似乎没有问题，但是当局部变量 result 离开了 const Rational&amp; operator* 之后，就被自动销毁了。所以 const Rational&amp; operator* 实际返回的 reference 指向的是一个不在存活的对象。</p><h2 id="条款21：利用重载技术（overload）避免隐式类型转换"><a href="#条款21：利用重载技术（overload）避免隐式类型转换" class="headerlink" title="条款21：利用重载技术（overload）避免隐式类型转换"></a>条款21：利用重载技术（overload）避免隐式类型转换</h2><p>假设我们有这么一个结构</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">UPInt</span><span class="token punctuation">{</span>    <span class="token function">UPInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">UPInt</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>UPInt <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> UPInt<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> UPInt<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当我们调用</p><pre class="line-numbers language-cpp"><code class="language-cpp">UPInt upi1<span class="token punctuation">,</span> upi2<span class="token punctuation">,</span> upi3<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>upi3 <span class="token operator">=</span> upi1 <span class="token operator">+</span> upi2<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 成功，调用了 UPInt operator+(const UPInt&amp; lhs, const UPInt&amp; rhs);</span>upi3 <span class="token operator">=</span> upi1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 成功，生成了临时对象</span>upi3 <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> upi1<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 成功，生成了临时对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 upi1 + 1 与 1 + upi1 都会进行隐式类型转换，这里会有一点成本。为了避免隐式类型转换带来的开销，我们可以重载 UPInt operator+ 这个函数</p><pre class="line-numbers language-cpp"><code class="language-cpp">UPInt <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> UPInt<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>UPInt <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> UPInt<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>来消除类型转换。但是我们不能狂热过度写出下面的函数</p><blockquote><p>UPInt operator+(const int lhs, const int rhs);</p></blockquote><p>这会导致可怕的灾难。</p><h2 id="条款22：考虑以操作符符合形式（op-）取代其独身形式（op）"><a href="#条款22：考虑以操作符符合形式（op-）取代其独身形式（op）" class="headerlink" title="条款22：考虑以操作符符合形式（op=）取代其独身形式（op）"></a>条款22：考虑以操作符符合形式（op=）取代其独身形式（op）</h2><p>到目前为止 C++ 并不考虑在 operator+，operator= 和 operator+= 之间设立任何互动关系。如果你希望这三个操作符都存在并且有着你所期望的互动关系，你必须自己实现。</p><p><strong>三个于效率有关的情况需要注意</strong></p><ol><li>一般而言，符合操作符比起对应的独身版本效率高，因为独身版通常必须返回一个新对象，而我们必须因此负担一个临时对象的构造成本和析构成本。至于复合版本则是直接将结果写入其左端自变量，所以不需要产生一个临时对象来放置返回值。</li><li>如果同提供某个操作符的复合形式和独身形式，便允许你的客户在效率与便利性之间做取舍。</li></ol><p>下面的两个例子中，第二个虽然更容易理解，但是却比第一个多构造了一个临时对象。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//Good</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">const</span> T <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">T</span><span class="token punctuation">(</span>lhs<span class="token punctuation">)</span> <span class="token operator">+</span> rhs<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Not Good</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">const</span> T <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">{</span>     T <span class="token function">result</span><span class="token punctuation">(</span>lhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result <span class="token operator">+</span><span class="token operator">=</span> rhs<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>身为一位程序库设计者，你应该为两者都提供。</p><h2 id="条款23：考虑使用其他程序库"><a href="#条款23：考虑使用其他程序库" class="headerlink" title="条款23：考虑使用其他程序库"></a>条款23：考虑使用其他程序库</h2><p>由于不同的程序库将效率、扩充性、移植性、类型安全性等的不同设计具体化，有时候你可以找找看是否存在另一个功能相近的程序库而其在效率上有较高的设计权重。</p><h2 id="条款24：了解虚函数、多重继承、虚基类和运行类型的成本"><a href="#条款24：了解虚函数、多重继承、虚基类和运行类型的成本" class="headerlink" title="条款24：了解虚函数、多重继承、虚基类和运行类型的成本"></a>条款24：了解虚函数、多重继承、虚基类和运行类型的成本</h2><ol><li>虚函数<br>当一个虚函数被调用，执行的代码必须对应于“调用者（对象）的动态类型”。大部分编译器使用所谓的 virtual tables 和 virtual table pointers —— 此二者通常被简写为 vtabls 和 vptrs。</li></ol><p><strong>虚函数成本：</strong></p><ul><li>你必须为每个拥有虚函数的 class 耗费一个 vtable 空间，其大小视虚函数的个数（包括继承而来的）而定。</li><li>你必须在每一个拥有虚函数的对象内付出“一个额外指针”的代价。调用一个虚函数的成本，基本上和”通过一个函数指针来调用函数“相同。虚函数本身并不构成性能上的瓶颈。</li><li>你事实上废弃了 inlining。虚函数不应该 inlined。因为 inline 意味“在编译期，将调用端的调用动作被调用函数的函数本身取代”，而 virtual 则意味着“等待，知道运行时期才知道哪个函数被调用”。</li></ul><ol start="2"><li><p>多重继承<br>多重继承问我导致 virtual base classes（虚拟基类）的需求。<br>在 non-virtual base class 的情况下，如果 derived class 在其 base class 有多条继承路径，则此 base class 的 data members 会在每一个 derived class object 体内复制滋生，每一个副本对应 “derived class 和 base class 之间的一条继承路线”。</p></li><li><p>虚拟继承<br>让base class 成为 virtual，可以消除这样的复制现象，<a href="https://blog.csdn.net/qq_45615577/article/details/115345490">学习资料</a>。</p></li><li><p>RTTI<br><a href="https://zhuanlan.zhihu.com/p/509453699">RTTI</a> 让我们得以在运行时获得 objects 和 classes 的相关信息，他们被存发在类型为 type_info 的对象内。一个 class 只需要一份 RTTI 信息就好，但是必须有某种办法让其下属的每个对象都能取用它。只有当某种类型拥有至少一个虚函数，才保证我们能够检验该类型对象的动态类型。</p></li></ol><table><thead><tr><th>性质</th><th>对象大小增加</th><th>Class数据量增加</th><th>Inlining 几率低</th></tr></thead><tbody><tr><td>虚函数 Virtual Functions</td><td>是</td><td>是</td><td>是</td></tr><tr><td>多重继承Multiple Inheritance</td><td>是</td><td>是</td><td>否</td></tr><tr><td>虚拟基类 Virtual Base Classes</td><td>往往如此</td><td>有时候</td><td>否</td></tr><tr><td>运行时期类型辨识</td><td>RTTI</td><td>否</td><td>是</td></tr></tbody></table><h2 id="条款25：将-constructor-和-non-member-functions-虚化"><a href="#条款25：将-constructor-和-non-member-functions-虚化" class="headerlink" title="条款25：将 constructor 和 non-member functions 虚化"></a>条款25：将 constructor 和 non-member functions 虚化</h2><p>constructor 虚化其实不是真正的虚化构造函数，书中所讲不是很好理解，可以参考下面的例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Shape</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>                 <span class="token comment" spellcheck="true">// A virtual destructor</span>  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// A pure virtual function</span>  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">move</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// ...</span>  <span class="token keyword">virtual</span> Shape<span class="token operator">*</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// Uses the copy constructor</span>  <span class="token keyword">virtual</span> Shape<span class="token operator">*</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// Uses the default constructor</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Circle</span> <span class="token operator">:</span> <span class="token keyword">public</span> Shape <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  Circle<span class="token operator">*</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">const</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// Covariant Return Types; see below</span>  Circle<span class="token operator">*</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// Covariant Return Types; see below</span>  <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Circle<span class="token operator">*</span> Circle<span class="token operator">::</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">Circle</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>Circle<span class="token operator">*</span> Circle<span class="token operator">::</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">Circle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过调用 clone() 或 create()虚函数来间接地调用构造函数与拷贝构造。即虚假的构造函数与真正的构造函数。</p><p>而至于non-member functions 的虚化十分容易：写一个虚函数做实际工作，再写一个什么都不做的非虚函数，只负责调用虚函数。</p><h2 id="条款26：限制某个class所能产生的对象数量"><a href="#条款26：限制某个class所能产生的对象数量" class="headerlink" title="条款26：限制某个class所能产生的对象数量"></a>条款26：限制某个class所能产生的对象数量</h2><h3 id="1-允许零个或一个对象"><a href="#1-允许零个或一个对象" class="headerlink" title="1.允许零个或一个对象"></a>1.允许零个或一个对象</h3><h4 id="1-1-零个对象"><a href="#1-1-零个对象" class="headerlink" title="1.1.零个对象"></a>1.1.零个对象</h4><p>每当即将产生一个对象，就会有一个 <code>constructor</code> 被调用。阻止某个 <code>class</code> 产出对象的最简单方法就是将其 <code>constructors</code> 声明为 <code>private</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">CantBeInstantiated</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token function">CatBeInstantiated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">CantBeInstantiated</span><span class="token punctuation">(</span><span class="token keyword">const</span> CantBeInstantiated<span class="token operator">&amp;</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-封装对象在函数内"><a href="#1-2-封装对象在函数内" class="headerlink" title="1.2.封装对象在函数内"></a>1.2.封装对象在函数内</h4><p>我们可以将对象封装在某个函数内，如此一来只有唯一一个对象被产生.<br>接下使用打印机的例子来说明。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">PrintJob</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Printer</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">submitJob</span><span class="token punctuation">(</span><span class="token keyword">const</span> PrintJob<span class="token operator">&amp;</span> job<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">performSelfTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">friend</span> Printer<span class="token operator">&amp;</span> <span class="token function">thePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token keyword">const</span> Printer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Printer<span class="token operator">&amp;</span> <span class="token function">thePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> Printer p<span class="token punctuation">;</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//唯一一个打印机对象</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里有三个点值得注意</p><ul><li><code>Printer class</code> 的 <code>constructors</code> 属性 <code>private</code>，可以压制对象的诞生。</li><li>全局函数 <code>thePrinter</code> 被声明在此 <code>class</code> 的一个 <code>friend</code>，致使 <code>thePrinter</code> 不受 <code>private constructors</code> 的约束。</li><li><code>thePrinter</code> 内含一个 <code>static Printer</code> 对象，意思只有一个 <code>Printer</code> 对象被产生出来。</li></ul><p>在使用的时候，只需要调用 <code>thePrinter().</code> 就可以</p><h4 id="1-2-消除firend"><a href="#1-2-消除firend" class="headerlink" title="1.2.消除firend"></a>1.2.消除<code>firend</code></h4><p>以上方的例子为例，我们可以让 <code>thePrinter</code> 成为 <code>Printer</code> 的一个 <code>static member function</code>，消除 <code>friend</code> 的必要性。我们就能获得接下来的代码</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Printer</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">static</span> Printer<span class="token operator">&amp;</span> <span class="token function">thePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token keyword">const</span> Printer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Printer<span class="token operator">&amp;</span> Printer<span class="token operator">::</span><span class="token function">thePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> Printer p<span class="token punctuation">;</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在用户调用 <code>Printer</code>时，会显得冗长</p><pre class="line-numbers language-cpp"><code class="language-cpp">Printer<span class="token operator">::</span><span class="token function">thePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="1-3-使用namespace"><a href="#1-3-使用namespace" class="headerlink" title="1.3.使用namespace"></a>1.3.使用<code>namespace</code></h4><p>另一个做法是把 <code>Printer</code> 和 <code>thePrinter</code> 从全局空间移走，放进一个 <code>namespace</code> 内。我们就可以得到以下代码</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">namespace</span> PrintingStuff<span class="token punctuation">{</span>    <span class="token keyword">class</span> <span class="token class-name">Printer</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">//这个class 位于 PrintingStuff namespace 内</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token keyword">void</span> <span class="token function">submitJob</span><span class="token punctuation">(</span><span class="token keyword">const</span> PrintJob<span class="token operator">&amp;</span> job<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token function">performSelfTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">friend</span> Printer<span class="token operator">&amp;</span> <span class="token function">thePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token keyword">const</span> Printer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    Printer<span class="token operator">&amp;</span> <span class="token function">thePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   这个函数也位于 PrintingStuff <span class="token keyword">namespace</span> 内    <span class="token punctuation">{</span>        <span class="token keyword">static</span> Printer p<span class="token punctuation">;</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//唯一一个打印机对象</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了这个 <code>namespace</code>，用户就能使用完全限定名来取用 <code>thePrinter</code>:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> PrintingStuff<span class="token operator">::</span>theprinter<span class="token punctuation">;</span><span class="token function">thePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在此代码实现中，又两个精细的地方值得探讨。</p><ul><li>形成唯一一个 <code>Printer</code> 对象的，是函数中的 <code>static</code> 对象，而非 <code>class</code> 中的 <code>static</code> 对象。<br>C++ 的一个设计哲学基础是你不应该为你并不使用的东西付出任何代价。<br><code>function static</code>的初始时机：在该函数第一次被调用时。<br><code>class static</code> 则不一定在什么时候初始化。</li><li>函数的 <code>static</code> 对象与 <code>inlining</code> 的互动。</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp">Printer<span class="token operator">&amp;</span> <span class="token function">thePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">static</span> Printer p<span class="token punctuation">;</span> <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果上方的函数被声明为 <code>inline</code>，那么你的程序可能会拥有多份该 <code>static</code> 对象的副本。因为 <code>inline</code> 意味着编译器应该将每一个调用动作以函数本身取代。<br>千万不要产生内含 <code>local static</code> 对象的 <code>inline non-member functions</code>。</p><h4 id="1-4-使用抛出异常提示产生了过多的对象"><a href="#1-4-使用抛出异常提示产生了过多的对象" class="headerlink" title="1.4.使用抛出异常提示产生了过多的对象"></a>1.4.使用抛出异常提示产生了过多的对象</h4><p>我们继续改进我们的 <code>Printer</code>,给定一个函数来抛出一个类型为 <code>TooManyObjects</code> 的 <code>exception</code></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Printer</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">class</span> <span class="token class-name">TooManyObjects</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">static</span> size_t numberObjects<span class="token punctuation">;</span>    <span class="token function">Printer</span><span class="token punctuation">(</span>cosnt Printer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//我们限制只有一个打印机，所以绝不允许复制行为，所以放在private区</span><span class="token punctuation">}</span>size_t Printer<span class="token operator">::</span>numberObjects <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>Printer<span class="token operator">::</span><span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>numObjects <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token function">TooManyObjects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 这里处理一般的构造</span>    <span class="token operator">++</span>numObjects<span class="token punctuation">;</span><span class="token punctuation">}</span>Printer<span class="token operator">::</span><span class="token operator">~</span><span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 这里处理析构</span>    <span class="token operator">--</span>numObjects<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个非常简单直观。</p><h3 id="2-不同的对象构造状态"><a href="#2-不同的对象构造状态" class="headerlink" title="2.不同的对象构造状态"></a>2.不同的对象构造状态</h3><h4 id="2-1-继承问题"><a href="#2-1-继承问题" class="headerlink" title="2.1.继承问题"></a>2.1.继承问题</h4><p>假设我们有一台彩色打印机</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">ColorPrinter</span><span class="token operator">:</span> <span class="token keyword">public</span> Printer<span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当我们调用下面的代码时</p><pre class="line-numbers language-cpp"><code class="language-cpp">Printer p<span class="token punctuation">;</span>ColorPrinter cp<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们其实构造了两个Printer对象，这个时候就会有 <code>TooManyObjects exception</code> 被抛出。</p><h4 id="2-2-对象包含问题"><a href="#2-2-对象包含问题" class="headerlink" title="2.2.对象包含问题"></a>2.2.对象包含问题</h4><p>当我们有对象包含<code>Printer</code>时，就会出现这样的代码</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Machine</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//这是一个机器，处理打印、传真等功能</span><span class="token keyword">private</span><span class="token operator">:</span>    Printer p<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 针对打印功能</span>    FaxMachine f<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 针对传真功能</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 这里调用</span>Machine m1<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 没有问题</span>Machine m2<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 抛出 TooManyObjects exception</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，当我们构造 <code>m2</code> 的时候，就出现问题了，因为此时 <code>Printer</code> 对象位于较大对象当中</p><h4 id="2-3-阻止继承"><a href="#2-3-阻止继承" class="headerlink" title="2.3.阻止继承"></a>2.3.阻止继承</h4><p>为了阻止上述的继承导致的问题，我们可以通过把 <code>constructors</code> 变为 <code>private</code> 来实现禁止派生。</p><h3 id="3-允许对象生生灭灭"><a href="#3-允许对象生生灭灭" class="headerlink" title="3.允许对象生生灭灭"></a>3.允许对象生生灭灭</h3><p>到这里我们已经能得到一个较好的版本了，可以限制对象生成的数量。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Printer</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">class</span> <span class="token class-name">TooManyObjects</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> Printer <span class="token operator">*</span><span class="token function">MakePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">submitJob</span><span class="token punctuation">(</span>cibst PrintJob <span class="token operator">&amp;</span>job<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这里是一些外部调用的接口</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">static</span> size_t<span class="token operator">::</span>numObjects<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 用于记录已经生成的Printer对象</span>    <span class="token keyword">const</span> size_t Printer<span class="token operator">::</span>maxObject <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 用于限制最大的对象数量</span>    <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                              <span class="token comment" spellcheck="true">// 我们不允许继承，所以放置再private区</span>    <span class="token function">Printer</span><span class="token punctuation">(</span>cosnt Printer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 我们不允许直接调用拷贝构造，所以放在private区</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>Printer<span class="token operator">::</span><span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>numObjects <span class="token operator">>=</span> maxObjects<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token function">TooManyObjects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 这里处理一般的构造</span>    <span class="token operator">++</span>numObjects<span class="token punctuation">;</span><span class="token punctuation">}</span>Printer<span class="token operator">::</span><span class="token function">Printer</span><span class="token punctuation">(</span>cosnt Printer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 这里处理和默认构造函数一致</span><span class="token punctuation">}</span>Printer<span class="token operator">::</span><span class="token operator">~</span><span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 这里处理析构</span>    <span class="token operator">--</span>numObjects<span class="token punctuation">;</span><span class="token punctuation">}</span>Printer <span class="token operator">*</span>Printer<span class="token operator">::</span><span class="token function">makePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">new</span> Printer<span class="token punctuation">;</span> <span class="token punctuation">}</span>Printer <span class="token operator">*</span>Printer<span class="token operator">::</span><span class="token function">MakePrinter</span><span class="token punctuation">(</span><span class="token keyword">const</span> Printer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">Printer</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-一个用来计算对象个数的-Base-Class"><a href="#4-一个用来计算对象个数的-Base-Class" class="headerlink" title="4.一个用来计算对象个数的 Base Class"></a>4.一个用来计算对象个数的 <code>Base Class</code></h3><p>接下来我们使用 <code>template</code> 来实现</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">BeingCounted</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Counted</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">class</span> <span class="token class-name">TooManyObjects</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">objectCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> numObjects<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token function">Counted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Counted</span><span class="token punctuation">(</span><span class="token keyword">const</span> Counted <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">Counted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">--</span>numObjects<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> numObjects<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> size_t maxObjects<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 用以避免 ctor 码重复出现</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">BeingCounted</span><span class="token operator">></span>Counted<span class="token operator">&lt;</span>BeingCounted<span class="token operator">></span><span class="token operator">::</span><span class="token function">Counted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">BeingCounted</span><span class="token operator">></span>Counted<span class="token operator">&lt;</span>BeingCounted<span class="token operator">></span><span class="token operator">::</span><span class="token function">Counted</span><span class="token punctuation">(</span><span class="token keyword">const</span> Counted<span class="token operator">&lt;</span>BeingCounted<span class="token operator">></span><span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">BeingCounted</span><span class="token operator">></span><span class="token keyword">void</span> Counted<span class="token operator">&lt;</span>BeingCounted<span class="token operator">></span><span class="token operator">::</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>numObjects <span class="token operator">>=</span> maxObjects<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token function">TooManyObjects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">++</span>numObjects<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 下面我们要使用上面的模板，实现一个只能构造 10 个对象的打印机</span><span class="token keyword">const</span> size_t Counted<span class="token operator">&lt;</span>Printer<span class="token operator">></span><span class="token operator">::</span>maxObjects <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Printer</span> <span class="token operator">:</span> <span class="token keyword">private</span> Counted<span class="token operator">&lt;</span>Printer<span class="token operator">></span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">// pseudo-constructors</span>    <span class="token keyword">static</span> Printer <span class="token operator">*</span><span class="token function">makePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> Printer <span class="token operator">*</span><span class="token function">makePrinter</span><span class="token punctuation">(</span><span class="token keyword">const</span> Printer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>    <span class="token operator">~</span><span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">submitJob</span><span class="token punctuation">(</span><span class="token keyword">const</span> PrintJob<span class="token operator">&amp;</span> job<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">performSelfTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">using</span> Counted<span class="token operator">&lt;</span>Printer<span class="token operator">></span><span class="token operator">::</span>objectCount<span class="token punctuation">;</span>    <span class="token keyword">using</span> Counted<span class="token operator">&lt;</span>Printer<span class="token operator">></span><span class="token operator">::</span>TooManyObjects<span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token keyword">const</span> Printer <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="条款27：要求（或禁止）对象产生于-heap-中"><a href="#条款27：要求（或禁止）对象产生于-heap-中" class="headerlink" title="条款27：要求（或禁止）对象产生于 heap 中"></a>条款27：要求（或禁止）对象产生于 heap 中</h2><h3 id="要求对象产生于-heap-之中（Heap-Based-Objects）"><a href="#要求对象产生于-heap-之中（Heap-Based-Objects）" class="headerlink" title="要求对象产生于 heap 之中（Heap-Based Objects）"></a>要求对象产生于 <code>heap 之中</code>（<code>Heap-Based Objects</code>）</h3><p>只要限制 <code>destructor</code> 或 <code>constructors</code> 的运用，便可阻止 <code>non-heap object</code> 的诞生。但是他同时也妨碍了继承（<code>inheritance</code>）和包含（<code>containment</code>）</p><h3 id="禁止对象产生于-heap-中"><a href="#禁止对象产生于-heap-中" class="headerlink" title="禁止对象产生于 heap 中"></a>禁止对象产生于 <code>heap</code> 中</h3><p>首先我们需要知道有三种情况下，对象可能被产生于 <code>heap</code> 中</p><ol><li>对象被直接实例化</li><li>对象被实例化为 <code>derived class objects</code> 内的 “base class 成分”</li><li>对象被内嵌于其他对象之中</li></ol><p>简单来说，可以直接设置 <code>operator new</code> 和 <code>operator delete</code> 为 <code>private</code> 即可</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">UPNumber</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你也像禁止“由 <code>UPNumber</code> 对象所组成的数组” 位于 <code>heap</code> 内，可以将 <code>operator new[]</code> 和 <code>operator delete[]</code> 亦声明为 <code>private</code>。当然现在更推荐直接delete掉。</p><h2 id="条款28：Smart-Pointers（智能指针）"><a href="#条款28：Smart-Pointers（智能指针）" class="headerlink" title="条款28：Smart Pointers（智能指针）"></a>条款28：Smart Pointers（智能指针）</h2><p>这里的智能指针比较早，包括了auto_ptr，可以单独了解，本书内容有点过时了。</p><h2 id="条款29：Reference-counting（引用计数）"><a href="#条款29：Reference-counting（引用计数）" class="headerlink" title="条款29：Reference counting（引用计数）"></a>条款29：Reference counting（引用计数）</h2><p>总体意思需要结合上一个条款中谈到的 <code>smart ptr</code> 来实现引用计数。有几个方面需要考虑</p><ul><li>需要有一个结构体即存储引用次数，也要存储数据</li><li>上述需要生成在堆中，通过指针访问地址</li><li>正确且自动处理引用增加及减少情况<ul><li>构造函数（包括拷贝构造等）</li><li>析构函数</li><li>赋值</li></ul></li><li>修改对象数据时需要调整引用及分享权限（也就是 <code>copy on write</code>）</li><li>避免内存泄漏</li></ul><h2 id="条款30：Proxy-classes（替身类、代理类）"><a href="#条款30：Proxy-classes（替身类、代理类）" class="headerlink" title="条款30：Proxy classes（替身类、代理类）"></a>条款30：Proxy classes（替身类、代理类）</h2><p>简单来说，如果我们有一个 <code>string a = &quot;123&quot;;</code> 此时我们想用 <code>a[0]</code> 取得 <code>&#39;1&#39;</code>。然而我们这里取得<code>&#39;1&#39;</code>之后，我们会有以下一种行为</p><ol><li>只读，此时我们不需要修改 <code>reference count</code></li><li>写入，此时我们需要修改 <code>reference count</code></li></ol><p>所以我们这里返回的时候可以不返回一个 <code>char</code> 而是返回一个结构体，且只要这个结构体能够转换为<code>char</code>就行了。这个和之前所讲的 条款17：缓式评估 有相同的实现思路，可以折回去参考一下。</p><h2 id="条款31：让函数根据一个以上的对象类型来决定如何虚化"><a href="#条款31：让函数根据一个以上的对象类型来决定如何虚化" class="headerlink" title="条款31：让函数根据一个以上的对象类型来决定如何虚化"></a>条款31：让函数根据一个以上的对象类型来决定如何虚化</h2><p>这里指出了一个情况，例如我们有三种物体，且都继承<code>GameObject</code></p><ul><li><code>SpaceShip</code> 飞船</li><li><code>SpaceStation</code> 空间站</li><li><code>Asteroid</code> 陨石</li></ul><p>不同的物体会相撞，且会产生不同的结果。例如飞船和空间站相撞，飞船能进入到空间站内；飞船和陨石相撞，两者都会摧毁。<br>这个时候，我们需要一个方法，传入任意俩个<code>GameObject</code>都可以处理。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">processCollision</span><span class="token punctuation">(</span>GameObject<span class="token operator">&amp;</span> object1<span class="token punctuation">,</span> GameObject<span class="token operator">&amp;</span> object2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>书中讨论了一套方法，是一个不错的方法，但是感觉还不是很完美。目前就整理一下代码，记录下来。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;map></span></span><span class="token keyword">class</span> <span class="token class-name">GameObject</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">GameObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//基类里面有虚函数，派生类继承后，使用typeid().name才能取得对应的class name</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">SpaceShip</span> <span class="token operator">:</span> <span class="token keyword">public</span> GameObject <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">SpaceStation</span> <span class="token operator">:</span> <span class="token keyword">public</span> GameObject <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Asteroid</span> <span class="token operator">:</span> <span class="token keyword">public</span> GameObject <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//匿名namespace</span><span class="token keyword">namespace</span> <span class="token punctuation">{</span>    <span class="token keyword">using</span> std<span class="token operator">::</span>string<span class="token punctuation">;</span>    <span class="token keyword">using</span> std<span class="token operator">::</span>map<span class="token punctuation">;</span>    <span class="token keyword">using</span> std<span class="token operator">::</span>make_pair<span class="token punctuation">;</span>    <span class="token keyword">using</span> std<span class="token operator">::</span>pair<span class="token punctuation">;</span>    <span class="token keyword">using</span> std<span class="token operator">::</span>cout<span class="token punctuation">;</span>    <span class="token keyword">using</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">shipAsteroid</span><span class="token punctuation">(</span>GameObject<span class="token operator">&amp;</span> spaceShip<span class="token punctuation">,</span> GameObject<span class="token operator">&amp;</span> asteroid<span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"spaceShip collide with asteroid"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">shipStation</span><span class="token punctuation">(</span>GameObject<span class="token operator">&amp;</span> spaceShip<span class="token punctuation">,</span> GameObject<span class="token operator">&amp;</span> spaceStation<span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"spaceShip collide with spaceStation"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">asteroidStation</span><span class="token punctuation">(</span>GameObject<span class="token operator">&amp;</span> asteroid<span class="token punctuation">,</span> GameObject<span class="token operator">&amp;</span> spaceStation<span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"asteroid collide with spaceStation"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">asteroidShip</span><span class="token punctuation">(</span>GameObject<span class="token operator">&amp;</span> asteroid<span class="token punctuation">,</span> GameObject<span class="token operator">&amp;</span> spaceShip<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">shipAsteroid</span><span class="token punctuation">(</span>spaceShip<span class="token punctuation">,</span> asteroid<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">stationShip</span><span class="token punctuation">(</span>GameObject<span class="token operator">&amp;</span> spaceStation<span class="token punctuation">,</span> GameObject<span class="token operator">&amp;</span> spaceShip<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">shipStation</span><span class="token punctuation">(</span>spaceShip<span class="token punctuation">,</span> spaceStation<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">stationAsteroid</span><span class="token punctuation">(</span>GameObject<span class="token operator">&amp;</span> spaceStation<span class="token punctuation">,</span> GameObject<span class="token operator">&amp;</span> asteroid<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">asteroidStation</span><span class="token punctuation">(</span>asteroid<span class="token punctuation">,</span> spaceStation<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//碰撞map</span><span class="token keyword">class</span> <span class="token class-name">CollisionMap</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">//这里使用单例</span>    <span class="token keyword">static</span> CollisionMap<span class="token operator">*</span> <span class="token function">theCollisionMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">static</span> CollisionMap CM<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">&amp;</span>CM<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>HitFunctionPtr<span class="token punctuation">)</span><span class="token punctuation">(</span>GameObject<span class="token operator">&amp;</span><span class="token punctuation">,</span> GameObject<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//这里添加新的碰撞处理函数，成对处理</span>    <span class="token keyword">void</span> <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> type1<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> type2<span class="token punctuation">,</span> HitFunctionPtr collisionFunction<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>collisionMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">make_pair</span><span class="token punctuation">(</span>type1<span class="token punctuation">,</span> type2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> collisionMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//成对添加</span>        collisionMap<span class="token punctuation">[</span>std<span class="token operator">::</span><span class="token function">make_pair</span><span class="token punctuation">(</span>type1<span class="token punctuation">,</span> type2<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> collisionFunction<span class="token punctuation">;</span>        collisionMap<span class="token punctuation">[</span>std<span class="token operator">::</span><span class="token function">make_pair</span><span class="token punctuation">(</span>type2<span class="token punctuation">,</span> type1<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> collisionFunction<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//这里移除碰撞函数</span>    <span class="token keyword">void</span> <span class="token function">removeEntry</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> type1<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> type2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>collisionMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">make_pair</span><span class="token punctuation">(</span>type1<span class="token punctuation">,</span> type2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> collisionMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//成对移除</span>        collisionMap<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">make_pair</span><span class="token punctuation">(</span>type1<span class="token punctuation">,</span> type2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        collisionMap<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">make_pair</span><span class="token punctuation">(</span>type2<span class="token punctuation">,</span> type1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//查找有没有对应的碰撞函数</span>    HitFunctionPtr <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> class1<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> class2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        HitMap<span class="token operator">::</span>iterator it <span class="token operator">=</span> collisionMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span>class1<span class="token punctuation">,</span> class2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>it <span class="token operator">==</span> collisionMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> map<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> string<span class="token operator">></span><span class="token punctuation">,</span> HitFunctionPtr<span class="token operator">></span> HitMap<span class="token punctuation">;</span>    HitMap collisionMap<span class="token punctuation">;</span>    <span class="token function">CollisionMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">initializeCollisionMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">CollisionMap</span><span class="token punctuation">(</span><span class="token keyword">const</span> CollisionMap<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这里可以内部初始化，也可以改为一个函数，来注册一下函数</span>    <span class="token keyword">void</span> <span class="token function">initializeCollisionMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        collisionMap<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token string">"class SpaceShip"</span><span class="token punctuation">,</span> <span class="token string">"class Asteroid"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>shipAsteroid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token string">"class SpaceShip"</span><span class="token punctuation">,</span> <span class="token string">"class SpaceStation"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>shipStation<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// ...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//匿名namespace</span><span class="token keyword">namespace</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//这里处理碰撞，会查找碰撞map，如果有函数就执行，没有的话就抛出异常</span>    <span class="token keyword">void</span> <span class="token function">processCollision</span><span class="token punctuation">(</span>GameObject<span class="token operator">&amp;</span> object1<span class="token punctuation">,</span> GameObject<span class="token operator">&amp;</span> object2<span class="token punctuation">)</span> <span class="token punctuation">{</span>          CollisionMap<span class="token operator">*</span> CM <span class="token operator">=</span> CollisionMap<span class="token operator">::</span><span class="token function">theCollisionMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        CollisionMap<span class="token operator">::</span>HitFunctionPtr phf <span class="token operator">=</span> CM<span class="token operator">-</span><span class="token operator">></span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">typeid</span><span class="token punctuation">(</span>object1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>object2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>phf<span class="token punctuation">)</span> <span class="token function">phf</span><span class="token punctuation">(</span>object1<span class="token punctuation">,</span> object2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"UnkowCollision! "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>object1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" - "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>object2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    SpaceShip spaceShip<span class="token punctuation">;</span>    Asteroid asteroid<span class="token punctuation">;</span>    SpaceStation spaceStation<span class="token punctuation">;</span>    <span class="token function">processCollision</span><span class="token punctuation">(</span>spaceShip<span class="token punctuation">,</span> asteroid<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//spaceShip collide with asteroid</span>    <span class="token function">processCollision</span><span class="token punctuation">(</span>asteroid<span class="token punctuation">,</span> spaceShip<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//UnkowCollision! class Asteroid - class SpaceShip</span>    <span class="token function">processCollision</span><span class="token punctuation">(</span>spaceShip<span class="token punctuation">,</span> spaceStation<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//spaceShip collide with spaceStation</span>    <span class="token function">processCollision</span><span class="token punctuation">(</span>asteroid<span class="token punctuation">,</span> spaceStation<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//UnkowCollision! class Asteroid - class SpaceStation</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="条款32：在未来时态下发展程序"><a href="#条款32：在未来时态下发展程序" class="headerlink" title="条款32：在未来时态下发展程序"></a>条款32：在未来时态下发展程序</h2><p>对于未来式思维，作者希望我们多考虑一些东西：</p><ul><li>提供玩真的<code>class</code> —— 即使某些部分目前用不到。当心的需求进来，你不太需要回头去修改那些 <code>classes</code>。</li><li>设计你的接口，使有利于共同的操作行为，阻止共同的错误。让这些 <code>classes</code> 轻易地被正确运用，难以被错误运用。</li><li>尽量使你都代码一般化（泛化），除非有不良的巨大后果。</li></ul><p>但是注意在之前的effective c++中提到的，过早优化是性能恶化之源。</p><h2 id="条款33：将非尾端类-non-leaf-classes-设计为-抽象类-abstract-classes"><a href="#条款33：将非尾端类-non-leaf-classes-设计为-抽象类-abstract-classes" class="headerlink" title="条款33：将非尾端类(non-leaf classes) 设计为 抽象类(abstract classes)"></a>条款33：将非尾端类(non-leaf classes) 设计为 抽象类(abstract classes)</h2><p>继承体系中的 <code>non-leaf</code>(非尾端)类应该使抽象类。如果 使用外界供应的程序库，你或许可以对其法则做点变通；单如果代码完全在你掌控之下，坚持这个法则，可以为你带来许多好处，并提升整个软件的可靠度、健壮度、精巧度、扩充度。</p><p>当然了，现在的设计思路一般都是组合优于继承，继承能干的组合就能够解决。</p><h2 id="条款34：如何在同一程序中结合-C-和-C"><a href="#条款34：如何在同一程序中结合-C-和-C" class="headerlink" title="条款34：如何在同一程序中结合 C++ 和 C"></a>条款34：如何在同一程序中结合 C++ 和 C</h2><ul><li><code>Name Mangling</code>(名命重整)</li><li><code>Statics</code> 的初始化</li><li>动态内存分配</li><li>数据结构的兼容性</li></ul><p>并指明了以下守则</p><ul><li>确定你的 C++ 和 C 编译器产出兼容的目标文件(<code>object files</code>)。</li><li>将双方都使用的函数声明为 <code>extern &quot;C&quot;</code>。</li><li>如果可能，尽可能在 C++ 中撰写 <code>main</code>。</li><li>总是以 <code>delete</code> 删除 <code>new</code> 返回的内存：总是以 <code>free</code> 释放 <code>malloc</code> 放回的内存。</li><li>将两个语言间的“数据结构传递”限制于 C 所能了解的形式；C++ <code>structs</code> 如果内含非虚函数，但是不受此限。</li></ul><h2 id="条款35：让自己习惯于标准-C-语言"><a href="#条款35：让自己习惯于标准-C-语言" class="headerlink" title="条款35：让自己习惯于标准 C++ 语言"></a>条款35：让自己习惯于标准 C++ 语言</h2><p>拥抱新的c++标准。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;虽然早在4年前的大二时期就看过并且实践在工程作业里面，但一直没有一个完整的记录，想着别的几本都有了干脆补全一下吧，个人总结，难免会出现一些不
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://JoyTsing.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="读书笔记" scheme="https://JoyTsing.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Cpp工程实践必备技能</title>
    <link href="https://joytsing.github.io/posts/23555/"/>
    <id>https://joytsing.github.io/posts/23555/</id>
    <published>2024-03-06T08:24:58.000Z</published>
    <updated>2024-03-15T08:01:21.472Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本科时候质疑CMAKE，后面理解CMAKE,加入CMAKE。言归正传，之前不喜欢用clion的原因，一是因为clion每次使用的时候启动慢，加上卡，其次是那会真不会CMAKE，而clion是强制用，然后后面就选择用vs去了，到现在大部分时间都在linux下写代码，慢慢开始熟悉CMAKE，突然有点感慨，遇到这么多人大部分人还停留在学校用vs教个基础语法的阶段，modern cpp不了解，cmake更是不知道。</p><p>接下来会对现代工程进行一个初步介绍，对单元测试框架以及benchmark框架的引入和使用进行个预览。</p><h2 id="CMAKE"><a href="#CMAKE" class="headerlink" title="CMAKE"></a>CMAKE</h2><p>首先是CMAKE，CMAKE写不好你都不要想着启动程序（迫真），目前来说，我觉得CMAKE不需要完全像一门编程语言一样能够熟悉到默写，只要能够看懂仿写我觉得就足够了。目前来说比较优秀的资料有这两个，两者都是类似讲座的形式，对现代CMAKE进行个粗略的介绍：<a href="https://www.bilibili.com/video/BV1nu411u7rb/?spm_id_from=333.999.0.0">一个半小时入门现代CMake</a>，<a href="https://www.bilibili.com/video/BV16P4y1g7MH/?spm_id_from=333.999.0.0&vd_source=698e8d6597cbbceb9e4ea1aa22057b46">现代CMake高级教程</a>, <a href="https://www.bilibili.com/video/BV1V84y117YU/?spm_id_from=333.999.0.0&vd_source=698e8d6597cbbceb9e4ea1aa22057b46">现代CMake模块化项目管理指南</a>大概就能了解个差不多了。</p><h2 id="单元测试框架"><a href="#单元测试框架" class="headerlink" title="单元测试框架"></a>单元测试框架</h2><p>本来想用google test的，后面想想选择更加现代化的 catch2 或 doetest，两者都是head-only类型的，只需要引入就能够使用，不过更推荐用doctest，因为他编译速度比catch2快很多，如果想要使用方便的话直接使用 <code>include(FetchContent)</code>的方式使用即可。</p><pre class="line-numbers language-cmake"><code class="language-cmake"> include(FetchContent) FetchContent_Declare(         doctest         GIT_REPOSITORY https://github.com/doctest/doctest.git         GIT_TAG master         GIT_SHALLOW TRUE ) FetchContent_MakeAvailable(doctest) ​ target_link_libraries(target doctest_with_main)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体使用不在这讲，看<a href="https://github.com/doctest/doctest/tree/master/doc/markdown">官方文档</a>即可，非常方便。</p><h2 id="benchmark框架"><a href="#benchmark框架" class="headerlink" title="benchmark框架"></a>benchmark框架</h2><p>建议使用 nanobench ，同样也是因为引入简单轻量，使用简单且 head only 。使用可以去看<a href="https://nanobench.ankerl.com/tutorial.html#usage">官方文档</a>。</p><pre class="line-numbers language-cmake"><code class="language-cmake">include(FetchContent) ​ FetchContent_Declare(     nanobench     GIT_REPOSITORY https://github.com/martinus/nanobench.git     GIT_TAG master     GIT_SHALLOW TRUE) ​ FetchContent_MakeAvailable(nanobench)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体输出的话如下：</p><ul><li>ns/op：每个bench内容需要经历的时间（ns为单位）。</li><li>op/s：每秒可以执行多少次操作。</li><li>err%：运行多次测试的波动情况（误差）。</li><li>ins/op：每次操作需要多少条指令。</li><li>cyc/op：每次操作需要多少次时钟周期。</li><li>bra/op：每次操作有多少次分支预判。</li><li>miss%：分支预判的miss率。</li><li>total：本次消耗的总时间。</li><li>benchmark：对应的名字。</li></ul><p>注意测试的时候，有时需要记得防止被编译器优化。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;nanobench.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;doctest/doctest.h></span></span><span class="token function">TEST_CASE</span><span class="token punctuation">(</span><span class="token string">"tutorial_fast_v2"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    uint64_t x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    ankerl<span class="token operator">::</span>nanobench<span class="token operator">::</span><span class="token function">Bench</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token string">"++x"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ankerl<span class="token operator">::</span>nanobench<span class="token operator">::</span><span class="token function">doNotOptimizeAway</span><span class="token punctuation">(</span>x <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="内存泄露检测"><a href="#内存泄露检测" class="headerlink" title="内存泄露检测"></a>内存泄露检测</h2><p>推荐使用backward-cpp，同样是head-only类型的，同样的也可以用上面的方式引入。</p><pre class="line-numbers language-cmake"><code class="language-cmake">include(FetchContent)# Also requires one of: libbfd (gnu binutils), libdwarf, libdw (elfutils)FetchContent_Declare(backward    GIT_REPOSITORY https://github.com/bombela/backward-cpp    GIT_TAG master  # or a version tag, such as v1.6    GIT_SHALLOW TRUE    SYSTEM          # optional, the Backward include directory will be treated as system directory)FetchContent_MakeAvailable(backward)# Add Backward to your target (either Backward::Interface, Backward::Object, or Backward::Backward)target_link_libraries(mytarget PUBLIC Backward::Interface)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于perf，sanitizers等就不在这介绍了。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>├── build<br>├── include<br>├── src<br>│  ├── CMakeLists.txt<br>│  └── main.cpp<br>└── test<br>   └── CMakeLists.txt</p><p>对于一个CMAKE构建的cpp工程应该具有类似上面的项目格式，在总目录下有 CMakeLists.txt,同时，在对应的src和test，有时还会有third-party目录下同样具有CMakeLists.txt。</p><pre class="line-numbers language-cmake"><code class="language-cmake">cmake_minimum_required(VERSION 3.20)if(NOT CMAKE_BUILD_TYPE)  set(CMAKE_BUILD_TYPE "Debug")endif()project(main LANGUAGES CXX)include(FetchContent)#用于引入上面介绍的三方库include_directories(${PROJECT_SOURCE_DIR}/include)set(CMAKE_EXPORT_COMPILE_COMMANDS ON)set(CMAKE_CXX_STANDARD 20)add_subdirectory(src/)add_subdirectory(test/)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总的项目cmakelists应该如上，当然对于第三方库的使用除了上面介绍的方法还有将文件download下来编译的，只不过现在介绍的方法更方便。</p><p>对应的src目录的cmakelists应该如下：</p><pre class="line-numbers language-cmake"><code class="language-cmake"># track the stack info# Also requires one of: libbfd (gnu binutils), libdwarf, libdw (elfutils)FetchContent_Declare(  backward  GIT_REPOSITORY https://github.com/bombela/backward-cpp  GIT_TAG master # or a version tag, such as v1.6  GIT_SHALLOW TRUE  SYSTEM # optional, the Backward include directory will be treated as system directory)FetchContent_MakeAvailable(backward)# srcfile(GLOB_RECURSE all_src CONFIGURE_DEPENDS *.cpp)add_executable(main ${all_src})target_include_directories(main PUBLIC ${PROJECT_SOURCE_DIR}/include/)target_link_libraries(main PRIVATE Backward::Backward)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>test的则是如下：</p><pre class="line-numbers language-cmake"><code class="language-cmake"># doctestFetchContent_Declare(  doctest  GIT_REPOSITORY https://github.com/doctest/doctest.git  GIT_TAG master  GIT_SHALLOW TRUE)FetchContent_MakeAvailable(doctest)# benchmarkFetchContent_Declare(  nanobench  GIT_REPOSITORY https://github.com/martinus/nanobench.git  GIT_TAG master  GIT_SHALLOW TRUE)FetchContent_MakeAvailable(nanobench)file(GLOB_RECURSE all_tests *.cpp)file(GLOB_RECURSE all_src CONFIGURE_DEPENDS ${PROJECT_SOURCE_DIR}/src/*.cpp)list(REMOVE_ITEM all_src ${PROJECT_SOURCE_DIR}/src/main.cpp)foreach(v ${all_tests})  string(REGEX MATCH "test/.*" relative_path ${v})  string(REGEX REPLACE "test/" "" target_name ${relative_path})  string(REGEX REPLACE ".cpp" "" target_name ${target_name})  add_executable(${target_name} ${v} ${all_src})  target_include_directories(${target_name} PUBLIC ${PROJECT_SOURCE_DIR}/include/)  target_link_libraries(${target_name} PRIVATE doctest_with_main nanobench Backward::Backward)endforeach()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;本科时候质疑CMAKE，后面理解CMAKE,加入CMAKE。言归正传，之前不喜欢用clion的原因，一是因为clion每次使用的时候启动慢，
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>通过折叠表达式简化返回值检测</title>
    <link href="https://joytsing.github.io/posts/33498/"/>
    <id>https://joytsing.github.io/posts/33498/</id>
    <published>2024-03-04T07:14:44.000Z</published>
    <updated>2024-03-20T16:12:25.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="返回值检查"><a href="#返回值检查" class="headerlink" title="返回值检查"></a>返回值检查</h2><p>比如在启动服务器或者客户端的时候编写init函数， 此时需要依次去config目录加载对应的配置，log的配置等等，在这个时候如果一行行写的话就会有如下代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp">error_t result<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>result <span class="token operator">=</span> <span class="token function">check1</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> error_t<span class="token operator">::</span>ok<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span>result <span class="token operator">=</span> <span class="token function">check2</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> error_t<span class="token operator">::</span>ok<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span>result <span class="token operator">=</span> <span class="token function">check3</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> error_t<span class="token operator">::</span>ok<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span>result <span class="token operator">=</span> <span class="token function">check4</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> error_t<span class="token operator">::</span>ok<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> error_t<span class="token operator">::</span>ok<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽说也可以但是终归是比较丑陋，如果应用折叠表达式的话可以写成如下形式：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">return</span> <span class="token function">checked_exec</span><span class="token punctuation">(</span>  error_t<span class="token operator">::</span>ok<span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">check1</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">check2</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">check3</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">check4</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对应的check_exec可以写成：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> R<span class="token punctuation">,</span>          <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Fn<span class="token operator">></span>R <span class="token function">checked_exec</span><span class="token punctuation">(</span><span class="token keyword">const</span> R<span class="token operator">&amp;</span> expected<span class="token punctuation">,</span>               Fn<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> fn<span class="token punctuation">)</span><span class="token punctuation">{</span>  R result <span class="token operator">=</span> expected<span class="token punctuation">;</span>  <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>result <span class="token operator">=</span> forward<span class="token operator">&lt;</span>Fn<span class="token operator">></span><span class="token punctuation">(</span>             fn<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> expected<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>         <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，前提是不传入参数，传入参数不同的话就需要额外编写。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;返回值检查&quot;&gt;&lt;a href=&quot;#返回值检查&quot; class=&quot;headerlink&quot; title=&quot;返回值检查&quot;&gt;&lt;/a&gt;返回值检查&lt;/h2&gt;&lt;p&gt;比如在启动服务器或者客户端的时候编写init函数， 此时需要依次去config目录加载对应的配置，log的配置等等，
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>vscode CMake Tools 传递命令行参数</title>
    <link href="https://joytsing.github.io/posts/61384/"/>
    <id>https://joytsing.github.io/posts/61384/</id>
    <published>2024-01-20T15:03:02.000Z</published>
    <updated>2024-03-20T16:24:07.149Z</updated>
    
    <content type="html"><![CDATA[<p>vscode调试C++程序时，有时需要给程序传递命令行参数。这么说，如果是用F5去运行的话那么则是另外一套配置配置方法，但现在最近已经习惯了CMake一套工具链，同时懒得跳到命令行里面去打make或者运行脚本。这种时候，通常做法是配置<code>launch.json</code>文件中要调试程序的<code>args</code>字段。但是设置<code>tasks.json</code>和<code>launch.json</code>的方式不如使用CMake Tools插件调试运行程序方便。CMake Tools插件调试运行程序可以在多个cmake的target中切换，省去了写那些配置的繁琐步骤。</p><p><img src="/posts/61384/image-20240120230905008.png" alt></p><h2 id="1-设置方法-设置-cmake-debugConfig-的-args字段"><a href="#1-设置方法-设置-cmake-debugConfig-的-args字段" class="headerlink" title="1. 设置方法: 设置 cmake.debugConfig 的 args字段"></a>1. 设置方法: 设置 cmake.debugConfig 的 args字段</h2><p>注意要是去设置<code>Workspace</code>的<code>settings.json</code>,因为每个项目需要的设置的命令行参数不一样。</p><p>如果设置<code>User</code>的<code>settings.json</code>会对其他项目产生影响。</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"cmake.debugConfig"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"args"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"arg1"</span><span class="token punctuation">,</span> <span class="token string">"arg2"</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里只配置了<code>cmake.debugConfig</code>中的<code>args</code>字段，其他字段省去了，因为我们当前只需要设置命令行参数。</p><p>虽然名字叫<code>debugConfig</code>，这里传递的命令行参数在<code>Release</code>和<code>Debug</code>模式下都是有效的。</p><h2 id="2-例子"><a href="#2-例子" class="headerlink" title="2. 例子"></a>2. 例子</h2><p>假设<code>main.cpp</code>需要用到命令行参数</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> argc <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后直接创建一个.vscode文件夹，创建一个settings.json文件，把上面1中提到的内容加进去就好了。</p><p><img src="/posts/61384/image-20240120230941833.png" alt></p><p>这样用CMake一套就能直接带参数调试或者运行了，同理，想要配置clangd的话也是直接去settings设置就好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;vscode调试C++程序时，有时需要给程序传递命令行参数。这么说，如果是用F5去运行的话那么则是另外一套配置配置方法，但现在最近已经习惯了CMake一套工具链，同时懒得跳到命令行里面去打make或者运行脚本。这种时候，通常做法是配置&lt;code&gt;launch.json&lt;/c
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="Tool" scheme="https://JoyTsing.github.io/tags/Tool/"/>
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>贵安，元旦快乐</title>
    <link href="https://joytsing.github.io/posts/53667/"/>
    <id>https://joytsing.github.io/posts/53667/</id>
    <published>2024-01-01T16:54:05.000Z</published>
    <updated>2024-01-01T16:58:55.541Z</updated>
    
    <content type="html"><![CDATA[<h2 id="元旦快乐"><a href="#元旦快乐" class="headerlink" title="元旦快乐"></a>元旦快乐</h2><p>2024年伊始，很久没有更新新的博文了，先给大家祝贺一下。在这里顺便说一下本站接下来的计划吧：</p><p>因为这个blog是我大二时候一时兴起搭的，大部分插件什么的也是那会弄的，现在发现已经有很多不能用了，可能之后会有一次大的迭代或者重构吧。毕竟前端这东西还是迭代太快了，这才4年hexo的结构就已经变了个样了，插件统计什么的我估计之前都是靠着缓存在工作，clean之后直接罢工了（笑。</p><p>希望新的一年多多努力，好好奋斗，多读点书（不管是什么样的），做一些有意义的工作，别的想说的都融在那两首歌里面了，愿意听就去听吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;元旦快乐&quot;&gt;&lt;a href=&quot;#元旦快乐&quot; class=&quot;headerlink&quot; title=&quot;元旦快乐&quot;&gt;&lt;/a&gt;元旦快乐&lt;/h2&gt;&lt;p&gt;2024年伊始，很久没有更新新的博文了，先给大家祝贺一下。在这里顺便说一下本站接下来的计划吧：&lt;/p&gt;
&lt;p&gt;因为这个blo
      
    
    </summary>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Linux下多Clang工具链的踩坑</title>
    <link href="https://joytsing.github.io/posts/19689/"/>
    <id>https://joytsing.github.io/posts/19689/</id>
    <published>2023-12-21T11:21:21.000Z</published>
    <updated>2024-03-20T16:20:38.855Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>故事是从C++ 17标准说起，在写线程池异步执行的时候发现居然没法使用move移动，然后怀疑到了clang头上，因为发现当我使用C++17标准下的<code>std::invoke_result</code>时直接报错是没有这个函数实现，说明clang版本有点旧了(加上我需要C++20的实现)，然后就开始研究起来clang的更新。</p><p><img src="/posts/19689/2.png" alt></p><h2 id="第一个坑"><a href="#第一个坑" class="headerlink" title="第一个坑"></a>第一个坑</h2><p>首先，因为需要做cmu15445 2023spring的project，在我的环境下安装了全套clang-14的tool-chain，那么问题来了，首先，你直接apt install只能安装到14的版本，其次，如果能安装了，但我需要使用最新的C++标准，但我又想保留老的tool chain怎么办？（可以试一试，如果直接安装的话会把老的版本卸载了）</p><p>首先是安装：我先找到了llvm官网的安装脚本，但又存在一个问题，通过这个安装脚本下载的话速度太慢（是的挂梯子也不行），后来翻找发现果然国内有对应的<a href="https://mirrors.tuna.tsinghua.edu.cn/help/llvm-apt/">镜像源</a>。那么怎么做，长话短说，直接通过脚本安装的话会卸载，这里是手动启用了一部分，即首先信任来自 <a href="https://apt.llvm.org/">llvm</a> 的 PGP 公钥。然后先手动安装clang-17以及clang++-17（或许还有别的，但这两个是肯定有的），在手动安装的情况下因为指定了版本号，所以是不会冲突的（clang-14与clang-17），最重要的部分安装好后通过先前的脚本将完整的tool-chain下载下来（即clang-tidy-17等等）。</p><p>到目前为止没结束，因为还需管理多版本clang，需要通过<code>update-alternatives</code>选择对应版本号，具体怎么用直接搜索该命令就好，最后应该把这3个软件版本设成最新的：clang、clang++、clangd。那么目前多版本算是好了。</p><h2 id="第二个坑"><a href="#第二个坑" class="headerlink" title="第二个坑"></a>第二个坑</h2><p>那么怎么使用多版本呢？如果你不是命令行档（即干啥都坚持在命令行cmake），想要自己多个选择的话，那么此时你打开vscode对应的项目会出现下面的问题<img src="/posts/19689/1.png" alt></p><p>原因很显然，因为我们将对应的默认clang版本更改了，但是理论上说，在vscode上选择对应工具链会切换成对应的版本号，那么为什么？我花了大量时间在.vscode和插件的配置上，但实际上这些都是没用的。上图是我已经正常配置过了的版本，如果你之前使用的话，那么你会发现clang 14和clang17这两个地方的编译器的链接是完全相同的。</p><p>出现这个情况的原因在上文中已经说了，因为我们使用的<code>update-alternatives</code>，做的实际上是帮助我们创建对应的软链接，即：对于<code>clang</code> ，如果我在<code>update-alternatives</code>中把clang版本中的14设为高优先级那么clang链接的就是14，设置的是17就是17。我们需要做的是更改tool chain对应找的工具，也就是不再要之前的软链接（曾经是对的，但不会自动更改）。</p><p><img src="/posts/19689/3.png" alt></p><p>当时思路是正确了，那么怎么更改？在扫描tool chain的时候我注意到他会去一个目录下加载，于是去那个目录：</p><p><img src="/posts/19689/4.png" alt></p><p>把对应的clang14和clang17的tool-chain加上版本号即可，这时候vscode的cmake tool chain也设置好了。以后如果是多环境也是这样即可。</p><h2 id="别的坑"><a href="#别的坑" class="headerlink" title="别的坑"></a>别的坑</h2><p>其实实际上踩的坑不止这些，包括但不限于把公钥全删了导致apt报错等等，但最后终于把vscode下c++的clangd更新，不再给我那些C++17语法报错，总的来说还是指的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;故事是从C++ 17标准说起，在写线程池异步执行的时候发现居然没法使用move移动，然后怀疑到了clang头上，因为发现当我使用C++17标
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="Tool" scheme="https://JoyTsing.github.io/tags/Tool/"/>
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>内存分配函数malloc的原理及实现</title>
    <link href="https://joytsing.github.io/posts/8649/"/>
    <id>https://joytsing.github.io/posts/8649/</id>
    <published>2023-12-19T15:41:01.000Z</published>
    <updated>2024-03-20T16:09:54.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是malloc"><a href="#1-什么是malloc" class="headerlink" title="1 什么是malloc"></a>1 什么是malloc</h2><p>在实现malloc之前，先要相对正式地对malloc做一个定义。</p><p>根据标准C库函数的定义，malloc具有如下原型：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">malloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个函数要实现的功能是在系统中分配一段连续的可用的内存，具体有如下要求：</p><ul><li>malloc分配的内存大小<strong>至少</strong>为size参数所指定的字节数</li><li>malloc的返回值是一个指针，指向一段可用内存的起始地址</li><li>多次调用malloc所分配的地址不能有重叠部分，除非某次malloc所分配的地址被释放掉</li><li>malloc应该尽快完成内存分配并返回（不能使用<a href="http://en.wikipedia.org/wiki/NP-hard">NP-hard</a>的内存分配算法）</li><li>实现malloc时应同时实现内存大小调整和内存释放函数（即realloc和free）</li></ul><p>对于malloc更多的说明可以在命令行中键入以下命令查看：</p><pre><code>man malloc</code></pre><h2 id="2-预备知识"><a href="#2-预备知识" class="headerlink" title="2 预备知识"></a>2 预备知识</h2><p>在实现malloc之前，需要先解释一些Linux系统内存相关的知识。</p><h3 id="2-1-Linux内存管理"><a href="#2-1-Linux内存管理" class="headerlink" title="2.1 Linux内存管理"></a>2.1 Linux内存管理</h3><h4 id="2-1-1-虚拟内存地址与物理内存地址"><a href="#2-1-1-虚拟内存地址与物理内存地址" class="headerlink" title="2.1.1 虚拟内存地址与物理内存地址"></a>2.1.1 虚拟内存地址与物理内存地址</h4><p>为了简单，现代操作系统在处理内存地址时，普遍采用虚拟内存地址技术。即在汇编程序（或机器语言）层面，当涉及内存地址时，都是使用虚拟内存地址。采用这种技术时，每个进程仿佛自己独享一片$2^N$字节的内存，其中$N$是机器位数。例如在64位CPU和64位操作系统下，每个进程的虚拟地址空间为$2^{64}$Byte。</p><p>这种虚拟地址空间的作用主要是简化程序的编写及方便操作系统对进程间内存的隔离管理，真实中的进程不太可能（也用不到）如此大的内存空间，实际能用到的内存取决于物理内存大小。</p><p>由于在机器语言层面都是采用虚拟地址，当实际的机器码程序涉及到内存操作时，需要根据当前进程运行的实际上下文将虚拟地址转换为物理内存地址，才能实现对真实内存数据的操作。这个转换一般由一个叫<a href="http://en.wikipedia.org/wiki/Memory_management_unit">MMU</a>（Memory Management Unit）的硬件完成。</p><h4 id="2-1-2-页与地址构成"><a href="#2-1-2-页与地址构成" class="headerlink" title="2.1.2 页与地址构成"></a>2.1.2 页与地址构成</h4><p>在现代操作系统中，不论是虚拟内存还是物理内存，都不是以字节为单位进行管理的，而是以页（Page）为单位。一个内存页是一段固定大小的连续内存地址的总称，具体到Linux中，典型的内存页大小为4096Byte（4K）。</p><p>所以内存地址可以分为页号和页内偏移量。下面以64位机器，4G物理内存，4K页大小为例，虚拟内存地址和物理内存地址的组成如下：</p><p><img src="https://pic4.zhimg.com/80/v2-b37992424628f32bc5e8245b689a31df_720w.webp" alt="img"></p><p>上面是虚拟内存地址，下面是物理内存地址。由于页大小都是4K，所以页内偏移都是用低12位表示，而剩下的高地址表示页号。</p><p>MMU映射单位并不是字节，而是页，这个映射通过查一个常驻内存的数据结构<a href="http://en.wikipedia.org/wiki/Page_table">页表</a>来实现。现在计算机具体的内存地址映射比较复杂，为了加快速度会引入一系列缓存和优化，例如<a href="http://en.wikipedia.org/wiki/Translation_lookaside_buffer">TLB</a>等机制。下面给出一个经过简化的内存地址翻译示意图，虽然经过了简化，但是基本原理与现代计算机真实的情况的一致的。</p><p><img src="https://pic3.zhimg.com/80/v2-15d430b30f223794b85ce6f54a95006e_720w.webp" alt="img"></p><h4 id="2-1-3-内存页与磁盘页"><a href="#2-1-3-内存页与磁盘页" class="headerlink" title="2.1.3 内存页与磁盘页"></a>2.1.3 内存页与磁盘页</h4><p>我们知道一般将内存看做磁盘的的缓存，有时MMU在工作时，会发现页表表明某个内存页不在物理内存中，此时会触发一个缺页异常（Page Fault），此时系统会到磁盘中相应的地方将磁盘页载入到内存中，然后重新执行由于缺页而失败的机器指令。关于这部分，因为可以看做对malloc实现是透明的，所以不再详细讲述，有兴趣的可以参考《深入理解计算机系统》相关章节。</p><p>最后附上一张在维基百科找到的更加符合真实地址翻译的流程供大家参考，这张图加入了TLB和缺页异常的流程（<a href="http://en.wikipedia.org/wiki/Page_table">图片来源页</a>）。</p><p><img src="https://pic3.zhimg.com/80/v2-5bb7bf5a484d6185e9d5a06a20408da6_720w.webp" alt="img"></p><h3 id="2-2-Linux进程级内存管理"><a href="#2-2-Linux进程级内存管理" class="headerlink" title="2.2 Linux进程级内存管理"></a>2.2 Linux进程级内存管理</h3><h4 id="2-2-1-内存排布"><a href="#2-2-1-内存排布" class="headerlink" title="2.2.1 内存排布"></a>2.2.1 内存排布</h4><p>明白了虚拟内存和物理内存的关系及相关的映射机制，下面看一下具体在一个进程内是如何排布内存的。</p><p>以Linux 64位系统为例。理论上，64bit内存地址可用空间为0x0000000000000000 ~ 0xFFFFFFFFFFFFFFFF，这是个相当庞大的空间，Linux实际上只用了其中一小部分（256T）。</p><p>根据<a href="https://www.kernel.org/doc/Documentation/x86/x86_64/mm.txt">Linux内核相关文档</a>描述，Linux64位操作系统仅使用低47位，高17位做扩展（只能是全0或全1）。所以，实际用到的地址为空间为0x0000000000000000 ~ 0x00007FFFFFFFFFFF和0xFFFF800000000000 ~ 0xFFFFFFFFFFFFFFFF，其中前面为用户空间（User Space），后者为内核空间（Kernel Space）。图示如下：</p><p><img src="https://pic3.zhimg.com/80/v2-c9969fd8e48b5dcdd813de6d0756434a_720w.webp" alt="img"></p><p>对用户来说，主要关注的空间是User Space。将User Space放大后，可以看到里面主要分为如下几段：</p><ul><li>Code：这是整个用户空间的最低地址部分，存放的是指令（也就是程序所编译成的可执行机器码）</li><li>Data：这里存放的是初始化过的全局变量</li><li>BSS：这里存放的是未初始化的全局变量</li><li>Heap：堆，这是我们本文重点关注的地方，堆自低地址向高地址增长，后面要讲到的brk相关的系统调用就是从这里分配内存</li><li>Mapping Area：这里是与mmap系统调用相关的区域。大多数实际的malloc实现会考虑通过mmap分配较大块的内存区域，本文不讨论这种情况。这个区域自高地址向低地址增长</li><li>Stack：这是栈区域，自高地址向低地址增长</li></ul><p>下面我们主要关注Heap区域的操作。对整个Linux内存排布有兴趣的同学可以参考其它资料。</p><h4 id="2-2-2-Heap内存模型"><a href="#2-2-2-Heap内存模型" class="headerlink" title="2.2.2 Heap内存模型"></a>2.2.2 Heap内存模型</h4><p>一般来说，malloc所申请的内存主要从Heap区域分配（本文不考虑通过mmap申请大块内存的情况）。</p><p>由上文知道，进程所面对的虚拟内存地址空间，只有按页映射到物理内存地址，才能真正使用。受物理存储容量限制，整个堆虚拟内存空间不可能全部映射到实际的物理内存。Linux对堆的管理示意如下：</p><p><img src="https://pic2.zhimg.com/80/v2-9bd8544cccfc3709a2139a6121aeab31_720w.webp" alt="img"></p><p>Linux维护一个break指针，这个指针指向堆空间的某个地址。从堆起始地址到break之间的地址空间为映射好的，可以供进程访问；而从break往上，是未映射的地址空间，如果访问这段空间则程序会报错。</p><h4 id="2-2-3-brk与sbrk"><a href="#2-2-3-brk与sbrk" class="headerlink" title="2.2.3 brk与sbrk"></a>2.2.3 brk与sbrk</h4><p>由上文知道，要增加一个进程实际的可用堆大小，就需要将break指针向高地址移动。Linux通过brk和sbrk系统调用操作break指针。两个系统调用的原型如下：</p><pre><code>int brk(void *addr);void *sbrk(intptr_t increment);</code></pre><p>brk将break指针直接设置为某个地址，而sbrk将break从当前位置移动increment所指定的增量。brk在执行成功时返回0，否则返回-1并设置errno为ENOMEM；sbrk成功时返回break移动之前所指向的地址，否则返回(void *)-1。</p><p>一个小技巧是，如果将increment设置为0，则可以获得当前break的地址。</p><p>另外需要注意的是，由于Linux是按页进行内存映射的，所以如果break被设置为没有按页大小对齐，则系统实际上会在最后映射一个完整的页，从而实际已映射的内存空间比break指向的地方要大一些。但是使用break之后的地址是很危险的（尽管也许break之后确实有一小块可用内存地址）。</p><h4 id="2-2-4-资源限制与rlimit"><a href="#2-2-4-资源限制与rlimit" class="headerlink" title="2.2.4 资源限制与rlimit"></a>2.2.4 资源限制与rlimit</h4><p>系统对每一个进程所分配的资源不是无限的，包括可映射的内存空间，因此每个进程有一个rlimit表示当前进程可用的资源上限。这个限制可以通过getrlimit系统调用得到，下面代码获取当前进程虚拟内存空间的rlimit：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> rlimit <span class="token operator">*</span>limit <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> rlimit <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> rlimit<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">getrlimit</span><span class="token punctuation">(</span>RLIMIT_AS<span class="token punctuation">,</span> limit<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"soft limit: %ld, hard limit: %ld\n"</span><span class="token punctuation">,</span> limit<span class="token operator">-></span>rlim_cur<span class="token punctuation">,</span> limit<span class="token operator">-></span>rlim_max<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中rlimit是一个结构体：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> rlimit <span class="token punctuation">{</span>    rlim_t rlim_cur<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* Soft limit */</span>    rlim_t rlim_max<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* Hard limit (ceiling for rlim_cur) */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>每种资源有软限制和硬限制，并且可以通过setrlimit对rlimit进行有条件设置。其中硬限制作为软限制的上限，非特权进程只能设置软限制，且不能超过硬限制。</p><h2 id="3-实现malloc"><a href="#3-实现malloc" class="headerlink" title="3 实现malloc"></a>3 实现malloc</h2><h3 id="3-1-玩具实现"><a href="#3-1-玩具实现" class="headerlink" title="3.1 玩具实现"></a>3.1 玩具实现</h3><p>在正式开始讨论malloc的实现前，我们可以利用上述知识实现一个简单但几乎没法用于真实的玩具malloc，权当对上面知识的复习：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 一个玩具malloc */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">malloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token function">sbrk</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sbrk</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个malloc每次都在当前break的基础上增加size所指定的字节数，并将之前break的地址返回。这个malloc由于对所分配的内存缺乏记录，不便于内存释放，所以无法用于真实场景。</p><h3 id="3-2-正式实现"><a href="#3-2-正式实现" class="headerlink" title="3.2 正式实现"></a>3.2 正式实现</h3><p>下面严肃点讨论malloc的实现方案。</p><h4 id="3-2-1-数据结构"><a href="#3-2-1-数据结构" class="headerlink" title="3.2.1 数据结构"></a>3.2.1 数据结构</h4><p>首先我们要确定所采用的数据结构。一个简单可行方案是将堆内存空间以块（Block）的形式组织起来，每个块由meta区和数据区组成，meta区记录数据块的元信息（数据区大小、空闲标志位、指针等等），数据区是真实分配的内存区域，并且数据区的第一个字节地址即为malloc返回的地址。</p><p>可以用如下结构体定义一个block：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> s_block <span class="token operator">*</span>t_block<span class="token punctuation">;</span><span class="token keyword">struct</span> s_block <span class="token punctuation">{</span>    size_t size<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 数据区大小 */</span>    t_block next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 指向下个块的指针 */</span>    <span class="token keyword">int</span> free<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* 是否是空闲块 */</span>    <span class="token keyword">int</span> padding<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 填充4字节，保证meta块长度为8的倍数 */</span>    <span class="token keyword">char</span> data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">/* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于我们只考虑64位机器，为了方便，我们在结构体最后填充一个int，使得结构体本身的长度为8的倍数，以便内存对齐。示意图如下：</p><p><img src="https://pic2.zhimg.com/80/v2-7f5b5dcb606608867c9d03cc908bcfa1_720w.webp" alt="img"></p><h4 id="3-2-2-寻找合适的block"><a href="#3-2-2-寻找合适的block" class="headerlink" title="3.2.2 寻找合适的block"></a>3.2.2 寻找合适的block</h4><p>现在考虑如何在block链中查找合适的block。一般来说有两种查找算法：</p><ul><li><strong>First fit</strong>：从头开始，使用第一个数据区大小大于要求size的块所谓此次分配的块</li><li><strong>Best fit</strong>：从头开始，遍历所有块，使用数据区大小大于size且差值最小的块作为此次分配的块</li></ul><p>两种方法各有千秋，best fit具有较高的内存使用率（payload较高），而first fit具有更好的运行效率。这里我们采用first fit算法。</p><pre><code>/* First fit */t_block find_block(t_block *last, size_t size) {    t_block b = first_block;    while(b &amp;&amp; !(b-&gt;free &amp;&amp; b-&gt;size &gt;= size)) {        *last = b;        b = b-&gt;next;    }    return b;}</code></pre><p>find_block从frist_block开始，查找第一个符合要求的block并返回block起始地址，如果找不到这返回NULL。这里在遍历时会更新一个叫last的指针，这个指针始终指向当前遍历的block。这是为了如果找不到合适的block而开辟新block使用的，具体会在接下来的一节用到。</p><h4 id="3-2-3-开辟新的block"><a href="#3-2-3-开辟新的block" class="headerlink" title="3.2.3 开辟新的block"></a>3.2.3 开辟新的block</h4><p>如果现有block都不能满足size的要求，则需要在链表最后开辟一个新的block。这里关键是如何只使用sbrk创建一个struct：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> BLOCK_SIZE 24 </span><span class="token comment" spellcheck="true">/* 由于存在虚拟的data字段，sizeof不能正确计算meta长度，这里手工设置 */</span>t_block <span class="token function">extend_heap</span><span class="token punctuation">(</span>t_block last<span class="token punctuation">,</span> size_t s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    t_block b<span class="token punctuation">;</span>    b <span class="token operator">=</span> <span class="token function">sbrk</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">sbrk</span><span class="token punctuation">(</span>BLOCK_SIZE <span class="token operator">+</span> s<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    b<span class="token operator">-></span>size <span class="token operator">=</span> s<span class="token punctuation">;</span>    b<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>last<span class="token punctuation">)</span>        last<span class="token operator">-></span>next <span class="token operator">=</span> b<span class="token punctuation">;</span>    b<span class="token operator">-></span>free <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-4-分裂block"><a href="#3-2-4-分裂block" class="headerlink" title="3.2.4 分裂block"></a>3.2.4 分裂block</h4><p>First fit有一个比较致命的缺点，就是可能会让很小的size占据很大的一块block，此时，为了提高payload，应该在剩余数据区足够大的情况下，将其分裂为一个新的block，示意如下：</p><p><img src="https://pic4.zhimg.com/80/v2-bd539864955725b96751f9b23b8ca293_720w.webp" alt="img"></p><p>实现代码：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">split_block</span><span class="token punctuation">(</span>t_block b<span class="token punctuation">,</span> size_t s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    t_block new<span class="token punctuation">;</span>    new <span class="token operator">=</span> b<span class="token operator">-></span>data <span class="token operator">+</span> s<span class="token punctuation">;</span>    new<span class="token operator">-></span>size <span class="token operator">=</span> b<span class="token operator">-></span>size <span class="token operator">-</span> s <span class="token operator">-</span> BLOCK_SIZE <span class="token punctuation">;</span>    new<span class="token operator">-></span>next <span class="token operator">=</span> b<span class="token operator">-></span>next<span class="token punctuation">;</span>    new<span class="token operator">-></span>free <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    b<span class="token operator">-></span>size <span class="token operator">=</span> s<span class="token punctuation">;</span>    b<span class="token operator">-></span>next <span class="token operator">=</span> new<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-5-malloc的实现"><a href="#3-2-5-malloc的实现" class="headerlink" title="3.2.5 malloc的实现"></a>3.2.5 malloc的实现</h4><p>有了上面的代码，我们可以利用它们整合成一个简单但初步可用的malloc。注意首先我们要定义个block链表的头first_block，初始化为NULL；另外，我们需要剩余空间至少有BLOCK_SIZE + 8才执行分裂操作。</p><p>由于我们希望malloc分配的数据区是按8字节对齐，所以在size不为8的倍数时，我们需要将size调整为大于size的最小的8的倍数：</p><pre class="line-numbers language-c"><code class="language-c">size_t <span class="token function">align8</span><span class="token punctuation">(</span>size_t s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>s <span class="token operator">&amp;</span> <span class="token number">0x7</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> s<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">>></span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">define</span> BLOCK_SIZE 24</span><span class="token keyword">void</span> <span class="token operator">*</span>first_block<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* other functions... */</span><span class="token keyword">void</span> <span class="token function">malloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    t_block b<span class="token punctuation">,</span> last<span class="token punctuation">;</span>    size_t s<span class="token punctuation">;</span>    <span class="token operator">/</span> 对齐地址 <span class="token operator">/</span>    s <span class="token operator">=</span> <span class="token function">align8</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>first_block<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">/</span> 查找合适的block <span class="token operator">/</span>        last <span class="token operator">=</span> first_block<span class="token punctuation">;</span>        b <span class="token operator">=</span> <span class="token function">find_block</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>last<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">/</span> 如果可以，则分裂 <span class="token operator">/</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>b<span class="token operator">-></span>size <span class="token operator">-</span> s<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token punctuation">(</span> BLOCK_SIZE <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token function">split_block</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>            b<span class="token operator">-></span>free <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token operator">/</span> 没有合适的block，开辟一个新的 <span class="token operator">*</span><span class="token operator">/</span>        b <span class="token operator">=</span> <span class="token function">extend_heap</span><span class="token punctuation">(</span>last<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>b<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    b <span class="token operator">=</span> <span class="token function">extend_heap</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>b<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    first_block <span class="token operator">=</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> b<span class="token operator">-></span>data<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-6-calloc的实现"><a href="#3-2-6-calloc的实现" class="headerlink" title="3.2.6 calloc的实现"></a>3.2.6 calloc的实现</h4><p>有了malloc，实现calloc只要两步：</p><ol><li>malloc一段内存</li><li>将数据区内容置为0</li></ol><p>由于我们的数据区是按8字节对齐的，所以为了提高效率，我们可以每8字节一组置0，而不是一个一个字节设置。我们可以通过新建一个size_t指针，将内存区域强制看做size_t类型来实现。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">calloc</span><span class="token punctuation">(</span>size_t number<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    size_t <span class="token operator">*</span>new<span class="token punctuation">;</span>    size_t s8<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    new <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>number <span class="token operator">*</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>new<span class="token punctuation">)</span> <span class="token punctuation">{</span>        s8 <span class="token operator">=</span> <span class="token function">align8</span><span class="token punctuation">(</span>number <span class="token operator">*</span> size<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s8<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            new<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> new<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-7-free的实现"><a href="#3-2-7-free的实现" class="headerlink" title="3.2.7 free的实现"></a>3.2.7 free的实现</h4><p>free的实现并不像看上去那么简单，这里我们要解决两个关键问题：</p><ol><li>如何验证所传入的地址是有效地址，即确实是通过malloc方式分配的数据区首地址</li><li>如何解决碎片问题</li></ol><p>首先我们要保证传入free的地址是有效的，这个有效包括两方面：</p><ul><li>地址应该在之前malloc所分配的区域内，即在first_block和当前break指针范围内</li><li>这个地址确实是之前通过我们自己的malloc分配的</li></ul><p>第一个问题比较好解决，只要进行地址比较就可以了，关键是第二个问题。这里有两种解决方案：一是在结构体内埋一个magic number字段，free之前通过相对偏移检查特定位置的值是否为我们设置的magic number，另一种方法是在结构体内增加一个magic pointer，这个指针指向数据区的第一个字节（也就是在合法时free时传入的地址），我们在free前检查magic pointer是否指向参数所指地址。这里我们采用第二种方案：</p><p>首先我们在结构体中增加magic pointer（同时要修改BLOCK_SIZE）：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> s_block <span class="token operator">*</span>t_block<span class="token punctuation">;</span><span class="token keyword">struct</span> s_block <span class="token punctuation">{</span>    size_t size<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 数据区大小 */</span>    t_block next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 指向下个块的指针 */</span>    <span class="token keyword">int</span> free<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* 是否是空闲块 */</span>    <span class="token keyword">int</span> padding<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 填充4字节，保证meta块长度为8的倍数 */</span>    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Magic pointer，指向data */</span>    <span class="token keyword">char</span> data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">/* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们定义检查地址合法性的函数：</p><pre class="line-numbers language-c"><code class="language-c">t_block <span class="token function">get_block</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>tmp<span class="token punctuation">;</span>      tmp <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> tmp <span class="token operator">-</span><span class="token operator">=</span> BLOCK_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">valid_addr</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>first_block<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">></span> first_block <span class="token operator">&amp;&amp;</span> p <span class="token operator">&lt;</span> <span class="token function">sbrk</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> p <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token function">get_block</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-></span>ptr<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当多次malloc和free后，整个内存池可能会产生很多碎片block，这些block很小，经常无法使用，甚至出现许多碎片连在一起，虽然总体能满足某此malloc要求，但是由于分割成了多个小block而无法fit，这就是碎片问题。</p><p>一个简单的解决方式时当free某个block时，如果发现它相邻的block也是free的，则将block和相邻block合并。为了满足这个实现，需要将s_block改为双向链表。修改后的block结构如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> s_block <span class="token operator">*</span>t_block<span class="token punctuation">;</span><span class="token keyword">struct</span> s_block <span class="token punctuation">{</span>    size_t size<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 数据区大小 */</span>    t_block prev<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 指向上个块的指针 */</span>    t_block next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 指向下个块的指针 */</span>    <span class="token keyword">int</span> free<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* 是否是空闲块 */</span>    <span class="token keyword">int</span> padding<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 填充4字节，保证meta块长度为8的倍数 */</span>    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Magic pointer，指向data */</span>    <span class="token keyword">char</span> data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">/* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>合并方法如下：</p><pre class="line-numbers language-c"><code class="language-c">t_block <span class="token function">fusion</span><span class="token punctuation">(</span>t_block b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token operator">-></span>next <span class="token operator">&amp;&amp;</span> b<span class="token operator">-></span>next<span class="token operator">-></span>free<span class="token punctuation">)</span> <span class="token punctuation">{</span>        b<span class="token operator">-></span>size <span class="token operator">+</span><span class="token operator">=</span> BLOCK_SIZE <span class="token operator">+</span> b<span class="token operator">-></span>next<span class="token operator">-></span>size<span class="token punctuation">;</span>        b<span class="token operator">-></span>next <span class="token operator">=</span> b<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">-></span>next<span class="token punctuation">)</span>            b<span class="token operator">-></span>next<span class="token operator">-></span>prev <span class="token operator">=</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了上述方法，free的实现思路就比较清晰了：首先检查参数地址的合法性，如果不合法则不做任何事；否则，将此block的free标为1，并且在可以的情况下与后面的block进行合并。如果当前是最后一个block，则回退break指针释放进程内存，如果当前block是最后一个block，则回退break指针并设置first_block为NULL。实现如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">free</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    t_block b<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">valid_addr</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        b <span class="token operator">=</span> <span class="token function">get_block</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        b<span class="token operator">-></span>free <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">-></span>prev <span class="token operator">&amp;&amp;</span> b<span class="token operator">-></span>prev<span class="token operator">-></span>free<span class="token punctuation">)</span>            b <span class="token operator">=</span> <span class="token function">fusion</span><span class="token punctuation">(</span>b<span class="token operator">-></span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">-></span>next<span class="token punctuation">)</span>            <span class="token function">fusion</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">-></span>prev<span class="token punctuation">)</span>                b<span class="token operator">-></span>prev<span class="token operator">-></span>prev <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                first_block <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            <span class="token function">brk</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-8-realloc的实现"><a href="#3-2-8-realloc的实现" class="headerlink" title="3.2.8 realloc的实现"></a>3.2.8 realloc的实现</h4><p>为了实现realloc，我们首先要实现一个内存复制方法。如同calloc一样，为了效率，我们以8字节为单位进行复制：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">copy_block</span><span class="token punctuation">(</span>t_block src<span class="token punctuation">,</span> t_block dst<span class="token punctuation">)</span> <span class="token punctuation">{</span>    size_t <span class="token operator">*</span>sdata<span class="token punctuation">,</span> <span class="token operator">*</span>ddata<span class="token punctuation">;</span>    size_t i<span class="token punctuation">;</span>    sdata <span class="token operator">=</span> src<span class="token operator">-></span>ptr<span class="token punctuation">;</span>    ddata <span class="token operator">=</span> dst<span class="token operator">-></span>ptr<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>i <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> src<span class="token operator">-></span>size <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>i <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> dst<span class="token operator">-></span>size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        ddata<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> sdata<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们开始实现realloc。一个简单（但是低效）的方法是malloc一段内存，然后将数据复制过去。但是我们可以做的更高效，具体可以考虑以下几个方面：</p><ul><li>如果当前block的数据区大于等于realloc所要求的size，则不做任何操作</li><li>如果新的size变小了，考虑split</li><li>如果当前block的数据区不能满足size，但是其后继block是free的，并且合并后可以满足，则考虑做合并</li></ul><p>下面是realloc的实现：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">realloc</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    size_t s<span class="token punctuation">;</span>    t_block b<span class="token punctuation">,</span> new<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>newp<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">/* 根据标准库文档，当p传入NULL时，相当于调用malloc */</span>        <span class="token keyword">return</span> <span class="token function">malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">valid_addr</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        s <span class="token operator">=</span> <span class="token function">align8</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>        b <span class="token operator">=</span> <span class="token function">get_block</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">-></span>size <span class="token operator">>=</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">-></span>size <span class="token operator">-</span> s <span class="token operator">>=</span> <span class="token punctuation">(</span>BLOCK_SIZE <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token function">split_block</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/* 看是否可进行合并 */</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">-></span>next <span class="token operator">&amp;&amp;</span> b<span class="token operator">-></span>next<span class="token operator">-></span>free                    <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>b<span class="token operator">-></span>size <span class="token operator">+</span> BLOCK_SIZE <span class="token operator">+</span> b<span class="token operator">-></span>next<span class="token operator">-></span>size<span class="token punctuation">)</span> <span class="token operator">>=</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">fusion</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">-></span>size <span class="token operator">-</span> s <span class="token operator">>=</span> <span class="token punctuation">(</span>BLOCK_SIZE <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token function">split_block</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">/* 新malloc */</span>                newp <span class="token operator">=</span> <span class="token function">malloc</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>newp<span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                new <span class="token operator">=</span> <span class="token function">get_block</span><span class="token punctuation">(</span>newp<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">copy_block</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> new<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">(</span>newp<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-遗留问题和优化"><a href="#3-3-遗留问题和优化" class="headerlink" title="3.3 遗留问题和优化"></a>3.3 遗留问题和优化</h3><p>以上是一个较为简陋，但是初步可用的malloc实现。还有很多遗留的可能优化点，例如：</p><ul><li>同时兼容32位和64位系统</li><li>在分配较大快内存时，考虑使用mmap而非sbrk，这通常更高效</li><li>可以考虑维护多个链表而非单个，每个链表中的block大小均为一个范围内，例如8字节链表、16字节链表、24-32字节链表等等。此时可以根据size到对应链表中做分配，可以有效减少碎片，并提高查询block的速度</li><li>可以考虑链表中只存放free的block，而不存放已分配的block，可以减少查找block的次数，提高效率</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-什么是malloc&quot;&gt;&lt;a href=&quot;#1-什么是malloc&quot; class=&quot;headerlink&quot; title=&quot;1 什么是malloc&quot;&gt;&lt;/a&gt;1 什么是malloc&lt;/h2&gt;&lt;p&gt;在实现malloc之前，先要相对正式地对malloc做一个定义。&lt;/
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Effective Cpp：条款 &amp; 实践</title>
    <link href="https://joytsing.github.io/posts/22113/"/>
    <id>https://joytsing.github.io/posts/22113/</id>
    <published>2023-12-16T12:23:38.000Z</published>
    <updated>2024-03-20T16:20:00.358Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章：让自己习惯-C"><a href="#第一章：让自己习惯-C" class="headerlink" title="第一章：让自己习惯 C++"></a>第一章：让自己习惯 C++</h2><h3 id="条款-1：视-C-为一个语言联邦"><a href="#条款-1：视-C-为一个语言联邦" class="headerlink" title="条款 1：视 C++ 为一个语言联邦"></a>条款 1：视 C++ 为一个语言联邦</h3><p>C++ 拥有多种不同的编程范式，而这些范式集成在一个语言中，使得 C++ 是一门即灵活又复杂的语言：</p><ol><li>传统的面向过程 C：区块，语句，预处理器，内置数据类型，数组，指针。</li><li>面向对象的 C with Classes：类，封装，继承，多态，动态绑定。</li><li>模板编程 Template C++ 和堪称黑魔法的模板元编程（TMP）。</li><li>C++ 标准库 STL。</li></ol><p>C++ 高效编程守则视情况而变化，程序设计没有银弹。</p><h3 id="条款-2：尽量以-const-enum-inline-替换-define"><a href="#条款-2：尽量以-const-enum-inline-替换-define" class="headerlink" title="条款 2：尽量以 const, enum, inline 替换 #define"></a>条款 2：尽量以 const, enum, inline 替换 #define</h3><p>在原书写成时 C++11 中的<code>constexpr</code>还未诞生，现在一般认为应当用<code>constexpr</code>定义编译期常量来替代大部分的<code>#define</code>宏常量定义：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">define</span> ASPECT_RATIO 1.653</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>替代为：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">auto</span> aspect_ratio <span class="token operator">=</span> <span class="token number">1.653</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们也可以将编译期常量定义为类的静态成员：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">GamePlayer</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> <span class="token keyword">auto</span> numTurns <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>enum</code>可以用于替代整型的常量，并且在模板元编程中应用广泛（见条款 48）：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">GamePlayer</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">enum</span> <span class="token punctuation">{</span> numTurns <span class="token operator">=</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>大部分<code>#define</code>宏常量应当用内联模板函数替代：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">define</span> CALL_WITH_MAX(a, b) f((a) > (b) ? (a) : (b))</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>替代为：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">CallWithMax</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">f</span><span class="token punctuation">(</span>a <span class="token operator">></span> b <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，宏和函数的行为本身并不完全一致，宏只是简单的替换，并不涉及传参和复制。</p><h3 id="条款-3：尽可能使用-const"><a href="#条款-3：尽可能使用-const" class="headerlink" title="条款 3：尽可能使用 const"></a>条款 3：尽可能使用 const</h3><p>若你想让一个常量只读，那你应该明确说出它是const常量，对于指针来说，更是如此：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">char</span> greeting<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span> p <span class="token operator">=</span> greeting<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 指针可修改，数据可修改</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> p <span class="token operator">=</span> greeting<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 指针可修改，数据不可修改</span><span class="token keyword">char</span> <span class="token keyword">const</span><span class="token operator">*</span> p <span class="token operator">=</span> greeting<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 指针可修改，数据不可修改</span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> p <span class="token operator">=</span> greeting<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 指针不可修改，数据可修改</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> p <span class="token operator">=</span> greeting<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 指针不可修改，数据不可修改</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于 STL 迭代器，分清使用<code>const</code>还是<code>const_iterator</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator iter <span class="token operator">=</span> vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 迭代器不可修改，数据可修改</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>const_iterator iter <span class="token operator">=</span> vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 迭代器可修改，数据不可修改</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>面对函数声明时，如果你不想让一个函数的结果被无意义地当作左值，请使用const返回值：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>const成员函数：</strong></p><p>const成员函数允许我们操控const对象，这在传递常引用时显得尤为重要：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">TextBlock</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t position<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// const对象使用的重载</span>        <span class="token keyword">return</span> text<span class="token punctuation">[</span>position<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">char</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t position<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// non-const对象使用的重载</span>        <span class="token keyword">return</span> text<span class="token punctuation">[</span>position<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>string text<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，const和non-const对象都有其各自的重载版本：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token keyword">const</span> Textblock<span class="token operator">&amp;</span> ctb<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> ctb<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 调用 const TextBlock::operator[]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>编译器对待const对象的态度通常是 bitwise constness，而我们在编写程序时通常采用 logical constness，这就意味着，在确保客户端不会察觉的情况下，我们认为const对象中的某些成员变量应当是允许被改变的，使用关键字<code>mutable</code>来标记这些成员变量：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">CTextBlock</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    std<span class="token operator">::</span>size_t <span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">char</span><span class="token operator">*</span> pText<span class="token punctuation">;</span>    <span class="token keyword">mutable</span> std<span class="token operator">::</span>size_t textLength<span class="token punctuation">;</span>    <span class="token keyword">mutable</span> <span class="token keyword">bool</span> lengthIsValid<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span>size_t CTextBlock<span class="token operator">::</span><span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>lengthIsValid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        textLength <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">strlen</span><span class="token punctuation">(</span>pText<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 可以修改mutable成员变量</span>        lengthIsValid <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 可以修改mutable成员变量</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> textLength<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在重载const和non-const成员函数时，需要尽可能避免书写重复的内容，这促使我们去进行常量性转除。在大部分情况下，我们应当避免转型的出现，但在此处为了减少重复代码，转型是适当的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">TextBlock</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t position<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 假设这里有非常多的代码</span>        <span class="token keyword">return</span> text<span class="token punctuation">[</span>position<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">char</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t position<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">const</span> TextBlock<span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">[</span>position<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>string text<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，反向做法：令const版本调用non-const版本以避免重复——并不被建议，一般而言const版本的限制比non-const版本的限制更多，因此这样做会带来风险。</p><h3 id="条款-4：确定对象在使用前已被初始化"><a href="#条款-4：确定对象在使用前已被初始化" class="headerlink" title="条款 4：确定对象在使用前已被初始化"></a>条款 4：确定对象在使用前已被初始化</h3><p>无初值对象在 C/C++ 中广泛存在，因此这一条款就尤为重要。在定义完一个对象后需要尽快为它赋初值：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> text <span class="token operator">=</span> <span class="token string">"A C-style string"</span><span class="token punctuation">;</span><span class="token keyword">double</span> d<span class="token punctuation">;</span>std<span class="token operator">::</span>cin <span class="token operator">>></span> d<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于类中的成员变量而言，我们有两种建议的方法完成初始化工作，一种是直接在定义处赋初值（since C++11）：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">CTextBlock</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>size_t textLength<span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">bool</span> lengthIsValid<span class="token punctuation">{</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一种是使用构造函数成员初始化列表：</p><pre class="line-numbers language-cpp"><code class="language-cpp">ABEntry<span class="token operator">::</span><span class="token function">ABEntry</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> name<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> address<span class="token punctuation">,</span>                 <span class="token keyword">const</span> std<span class="token operator">::</span>list<span class="token operator">&lt;</span>PhoneNumber<span class="token operator">></span><span class="token operator">&amp;</span> phones<span class="token punctuation">)</span>    <span class="token operator">:</span> <span class="token function">theName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">theAddress</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">thePhones</span><span class="token punctuation">(</span>phones<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">numTimesConsulted</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>成员初始化列表也可以留空用来执行默认构造函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp">ABEntry<span class="token operator">::</span><span class="token function">ABEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token operator">:</span> <span class="token function">theName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">theAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">thePhones</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">numTimesConsulted</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，类中成员的初始化具有次序性，而这次序与成员变量的声明次序一致，与成员初始化列表的次序无关。</p><blockquote><p>类中成员的初始化是可选的，但是引用类型必须初始化。</p></blockquote><p><strong>静态对象的初始化：</strong></p><p>C++ 对于定义于不同编译单元内的全局静态对象的初始化相对次序并无明确定义，因此，以下代码可能会出现使用未初始化静态对象的情况：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// File 1</span><span class="token keyword">extern</span> FileSystem tfs<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// File 2</span><span class="token keyword">class</span> <span class="token class-name">Directory</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Directory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        FileSystem disk <span class="token operator">=</span> tfs<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Directory tempDir<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面这个例子中，你无法确保位于不同编译单元内的<code>tfs</code>一定在<code>tempDir</code>之前初始化完成。</p><p>这个问题的一个有效解决方案是采用 <strong>Meyers’ singleton</strong>，将全局静态对象转化为局部静态对象：</p><pre class="line-numbers language-cpp"><code class="language-cpp">FileSystem<span class="token operator">&amp;</span> <span class="token function">tfs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> FileSystem fs<span class="token punctuation">;</span>    <span class="token keyword">return</span> fs<span class="token punctuation">;</span><span class="token punctuation">}</span>Directory<span class="token operator">&amp;</span> <span class="token function">tempDir</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> Directory td<span class="token punctuation">;</span>    <span class="token keyword">return</span> td<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个手法的基础在于：C++ 保证，函数内的局部静态对象会在<strong>该函数被调用期间</strong>和<strong>首次遇上该对象之定义式</strong>时被初始化。</p><p>当然，这种做法对于多线程来说并不具有优势，最好还是在单线程启动阶段手动调用函数完成初始化。</p><h2 id="第二章：构造-析构-赋值运算"><a href="#第二章：构造-析构-赋值运算" class="headerlink" title="第二章：构造/析构/赋值运算"></a>第二章：构造/析构/赋值运算</h2><h3 id="条款-5：了解-C-默默编写并调用哪些函数"><a href="#条款-5：了解-C-默默编写并调用哪些函数" class="headerlink" title="条款 5：了解 C++ 默默编写并调用哪些函数"></a>条款 5：了解 C++ 默默编写并调用哪些函数</h3><p>C++ 中的空类并不是真正意义上的空类，编译器会为它预留以下内容：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Empty</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>                           <span class="token comment" spellcheck="true">// 默认构造函数（没有任何构造函数时）</span>    <span class="token function">Empty</span><span class="token punctuation">(</span><span class="token keyword">const</span> Empty<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>               <span class="token comment" spellcheck="true">// 拷贝构造函数</span>    <span class="token function">Empty</span><span class="token punctuation">(</span>Empty<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">// 移动构造函数 (since C++11)</span>    <span class="token operator">~</span><span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>                          <span class="token comment" spellcheck="true">// 析构函数</span>    Empty<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Empty<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 拷贝赋值运算符</span>    Empty<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Empty<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>         <span class="token comment" spellcheck="true">// 移动赋值运算符 (since C++11)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>唯有当这些函数被调用时，它们才会真正被编译器创建出来，下面代码将造成上述每一个函数被创建：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Empty e1<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 默认构造函数 &amp; 析构函数</span>Empty <span class="token function">e2</span><span class="token punctuation">(</span>e1<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 拷贝构造函数</span>Empty e3 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>e2<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 移动构造函数 (since C++11)</span>e2 <span class="token operator">=</span> e1<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 拷贝赋值运算符</span>e3 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>e1<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 移动赋值运算符 (since C++11)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，拷贝赋值运算符只有在允许存在时才会自动创建，比如以下情况：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">NamedObject</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>string<span class="token operator">&amp;</span> nameValue<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在该类中，我们有一个string引用类型，然而引用无法指向不同对象，因此编译器会拒绝为该类创建一个默认的拷贝赋值运算符。</p><p>除此之外，以下情形也会导致拷贝赋值运算符不会自动创建：</p><ol><li>类中含有const成员。</li><li>基类中含有private的拷贝赋值运算符。</li></ol><h3 id="条款-6：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款-6：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款 6：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款 6：若不想使用编译器自动生成的函数，就该明确拒绝</h3><p>原书中使用的做法是将不想使用的函数声明为private，但在 C++11 后我们有了更好的做法：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Uncopyable</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Uncopyable</span><span class="token punctuation">(</span><span class="token keyword">const</span> Uncopyable<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>    Uncopyable<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Uncopyable<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-7：为多态基类声明虚析构函数"><a href="#条款-7：为多态基类声明虚析构函数" class="headerlink" title="条款 7：为多态基类声明虚析构函数"></a>条款 7：为多态基类声明虚析构函数</h3><p>当派生类对象经由一个基类指针被删除，而该基类指针带着一个非虚析构函数，其结果是未定义的，可能会无法完全销毁派生类的成员，造成内存泄漏。消除这个问题的方法就是对基类使用虚析构函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你不想让一个类成为基类，那么在类中声明虚函数是是一个坏主意，因为额外存储的虚表指针会使类的体积变大。</p><blockquote><p>只要基类的析构函数是虚函数，那么派生类的析构函数不论是否用virtual关键字声明，都自动成为虚析构函数。</p></blockquote><p>虚析构函数的运作方式是，最深层派生的那个类的析构函数最先被调用，然后是其上的基类的析构函数被依次调用。</p><p>如果你想将基类作为抽象类使用，但手头上又没有别的虚函数，那么将它的析构函数设为纯虚函数是一个不错的想法。考虑以下情形：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但若此时从该基类中派生出新的类，会发生报错，这是因为编译器无法找到基类的析构函数的实现。因此，即使是纯虚析构函数，也需要一个函数体：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Base<span class="token operator">::</span><span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者以下写法也被允许：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-8：别让异常逃离析构函数"><a href="#条款-8：别让异常逃离析构函数" class="headerlink" title="条款 8：别让异常逃离析构函数"></a>条款 8：别让异常逃离析构函数</h3><p>在析构函数中吐出异常并不被禁止，但为了程序的可靠性，应当极力避免这种行为。</p><p>为了实现 RAII，我们通常会将对象的销毁方法封装在析构函数中，如下例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">DBConn</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token operator">~</span><span class="token function">DBConn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        db<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 该函数可能会抛出异常</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    DBConnection db<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但这样我们就需要在析构函数中完成对异常的处理，以下是几种常见的做法：</p><p>第一种：杀死程序：</p><pre class="line-numbers language-cpp"><code class="language-cpp">DBConn<span class="token operator">::</span><span class="token operator">~</span><span class="token function">DBConn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span> db<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 记录运行日志，以便调试</span>        std<span class="token operator">::</span><span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二种：直接吞下异常不做处理，但这种做法不被建议。</p><p>第三种：重新设计接口，将异常的处理交给客户端完成：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">DBConn</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        db<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        closed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">DBConn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>closed<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                db<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 处理异常</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    DBConnection db<span class="token punctuation">;</span>    <span class="token keyword">bool</span> closed<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个新设计的接口中，我们提供了<code>close</code>函数供客户手动调用，这样客户也可以根据自己的意愿处理异常；若客户忘记手动调用，析构函数才会自动调用<code>close</code>函数。</p><p>当一个操作可能会抛出需要客户处理的异常时，将其暴露在普通函数而非析构函数中是一个更好的选择。</p><h3 id="条款-9：绝不在构造和析构过程中调用虚函数"><a href="#条款-9：绝不在构造和析构过程中调用虚函数" class="headerlink" title="条款 9：绝不在构造和析构过程中调用虚函数"></a>条款 9：绝不在构造和析构过程中调用虚函数</h3><p>在创建派生类对象时，基类的构造函数永远会早于派生类的构造函数被调用，而基类的析构函数永远会晚于派生类的析构函数被调用。</p><p>在派生类对象的基类构造和析构期间，对象的类型是基类而非派生类，因此此时调用虚函数会被编译器解析至基类的虚函数版本，通常不会得到我们想要的结果。</p><p>间接调用虚函数是一个比较难以发现的危险行为，需要尽量避免：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Transaction</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Transaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">LogTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token function">LogTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 此处间接调用了虚函数！</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果想要基类在构造时就得知派生类的构造信息，推荐的做法是在派生类的构造函数中将必要的信息向上传递给基类的构造函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Transaction</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">explicit</span> <span class="token function">Transaction</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> logInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">LogTransaction</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> logInfo<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Transaction<span class="token operator">::</span><span class="token function">Transaction</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> logInfo<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">LogTransaction</span><span class="token punctuation">(</span>logInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>                           <span class="token comment" spellcheck="true">// 更改为了非虚函数调用</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">BuyTransaction</span> <span class="token operator">:</span> <span class="token keyword">public</span> Transaction <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">BuyTransaction</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">Transaction</span><span class="token punctuation">(</span><span class="token function">CreateLogString</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 将信息传递给基类构造函数</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">static</span> std<span class="token operator">::</span>string <span class="token function">CreateLogString</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意此处的<code>CreateLogString</code>是一个静态成员函数，这是很重要的，因为静态成员函数可以确保不会使用未完成初始化的成员变量。</p><h3 id="条款-10：令-operator-返回一个指向-this-的引用"><a href="#条款-10：令-operator-返回一个指向-this-的引用" class="headerlink" title="条款 10：令 operator= 返回一个指向 *this 的引用"></a>条款 10：令 operator= 返回一个指向 *this 的引用</h3><p>虽然并不强制执行此条款，但为了实现连锁赋值，大部分时候应该这样做：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">+</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 这个条款适用于</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                    <span class="token comment" spellcheck="true">// +=, -=, *= 等等运算符</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">// 即使参数类型不是 Widget&amp; 也适用</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-11：在-operator-中处理“自我赋值”"><a href="#条款-11：在-operator-中处理“自我赋值”" class="headerlink" title="条款 11：在 operator= 中处理“自我赋值”"></a>条款 11：在 operator= 中处理“自我赋值”</h3><p>自我赋值是合法的操作，但在一些情况下可能会导致意外的错误，例如在复制堆上的资源时：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">+</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">delete</span> pRes<span class="token punctuation">;</span>                          <span class="token comment" spellcheck="true">// 删除当前持有的资源</span>    pRes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Resource</span><span class="token punctuation">(</span><span class="token operator">*</span>rhs<span class="token punctuation">.</span>pRes<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 复制传入的资源</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但若<code>rhs</code>和<code>*this</code>指向的是相同的对象，就会导致访问到已删除的数据。</p><p>最简单的解决方法是在执行后续语句前先进行<strong>证同测试（Identity test）</strong>：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 若是自我赋值，则不做任何事</span>    <span class="token keyword">delete</span> pRes<span class="token punctuation">;</span>    pRes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Resource</span><span class="token punctuation">(</span><span class="token operator">*</span>rhs<span class="token punctuation">.</span>pRes<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一个常见的做法是只关注异常安全性，而不关注是否自我赋值：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Resource<span class="token operator">*</span> pOrigin <span class="token operator">=</span> pRes<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 先记住原来的pRes指针</span>    pRes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Resource</span><span class="token punctuation">(</span><span class="token operator">*</span>rhs<span class="token punctuation">.</span>pRes<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 复制传入的资源</span>    <span class="token keyword">delete</span> pOrigin<span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">// 删除原来的资源</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>仅仅是适当安排语句的顺序，就可以做到使整个过程具有异常安全性。</p><p>还有一种取巧的做法是使用 copy and swap 技术，这种技术聪明地利用了栈空间会自动释放的特性，这样就可以通过析构函数来实现资源的释放：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Widget <span class="token function">temp</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述做法还可以写得更加巧妙，就是利用按值传参，自动调用构造函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Widget rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">,</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-12：复制对象时勿忘其每一个成分"><a href="#条款-12：复制对象时勿忘其每一个成分" class="headerlink" title="条款 12：复制对象时勿忘其每一个成分"></a>条款 12：复制对象时勿忘其每一个成分</h3><p>这个条款正如其字面意思，当你决定手动实现拷贝构造函数或拷贝赋值运算符时，忘记复制任何一个成员都可能会导致意外的错误。</p><p>当使用继承时，继承自基类的成员往往容易忘记在派生类中完成复制，如果你的基类拥有拷贝构造函数和拷贝赋值运算符，应该记得调用它们：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">PriorityCustomer</span> <span class="token operator">:</span> <span class="token keyword">public</span> Customer <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">PriorityCustomer</span><span class="token punctuation">(</span><span class="token keyword">const</span> PriorityCustomer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    PriorityCustomer<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> PriorityCustomer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> priority<span class="token punctuation">;</span><span class="token punctuation">}</span>PriorityCustomer<span class="token operator">::</span><span class="token function">PriorityCustomer</span><span class="token punctuation">(</span><span class="token keyword">const</span> PriorityCustomer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>    <span class="token operator">:</span> <span class="token function">Customer</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token comment" spellcheck="true">// 调用基类的拷贝构造函数</span>      <span class="token function">priority</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>priority<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>PriorityCustomer<span class="token operator">::</span>PriorityCustomer<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> PriorityCustomer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Customer<span class="token operator">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 调用基类的拷贝赋值运算符</span>    priority <span class="token operator">=</span> rhs<span class="token punctuation">.</span>priority<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，不要尝试在拷贝构造函数中调用拷贝赋值运算符，或在拷贝赋值运算符的实现中调用拷贝构造函数，一个在初始化时，一个在初始化后，它们的功用是不同的。</p><h2 id="第三章：资源管理"><a href="#第三章：资源管理" class="headerlink" title="第三章：资源管理"></a>第三章：资源管理</h2><h3 id="条款-13：以对象管理资源"><a href="#条款-13：以对象管理资源" class="headerlink" title="条款 13：以对象管理资源"></a>条款 13：以对象管理资源</h3><p>对于传统的堆资源管理，我们需要使用成对的<code>new</code>和<code>delete</code>，这样若忘记<code>delete</code>就会造成内存泄露。因此，我们应尽可能以对象管理资源，并采用RAII（Resource Acquisition Is Initialize，资源取得时机便是初始化时机），让析构函数负责资源的释放。</p><p>原书此处关于智能指针的内容已经过时，在 C++11 中，通过专一所有权来管理RAII对象可以使用<code>std::unique_ptr</code>，通过引用计数来管理RAII对象可以使用<code>std::shared_ptr</code>。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// Investment* CreateInvestment();</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Investment<span class="token operator">></span> <span class="token function">pUniqueInv1</span><span class="token punctuation">(</span><span class="token function">CreateInvestment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Investment<span class="token operator">></span> <span class="token function">pUniqueInv2</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>pUniqueInv1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 转移资源所有权</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Investment<span class="token operator">></span> <span class="token function">pSharedInv1</span><span class="token punctuation">(</span><span class="token function">CreateInvestment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Investment<span class="token operator">></span> <span class="token function">pSharedInv2</span><span class="token punctuation">(</span>pSharedInv1<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 引用计数+1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>智能指针默认会自动delete所持有的对象，我们也可以为智能指针指定所管理对象的释放方式（删除器deleter）：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// void GetRidOfInvestment(Investment*) {}</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Investment<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>GetRidOfInvestment<span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">></span> <span class="token function">pUniqueInv</span><span class="token punctuation">(</span><span class="token function">CreateInvestment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> GetRidOfInvestment<span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Investment<span class="token operator">></span> <span class="token function">pSharedInv</span><span class="token punctuation">(</span><span class="token function">CreateInvestment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> GetRidOfInvestment<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-14：在资源管理类中小心拷贝行为"><a href="#条款-14：在资源管理类中小心拷贝行为" class="headerlink" title="条款 14：在资源管理类中小心拷贝行为"></a>条款 14：在资源管理类中小心拷贝行为</h3><p>我们应该永远保持这样的思考：当一个RAII对象被复制，会发生什么事？</p><p><strong>选择一：禁止复制</strong></p><p>许多时候允许RAII对象被复制并不合理，如果确是如此，那么就该明确禁止复制行为，条款 6 已经阐述了怎么做这件事。</p><p><strong>选择二：对底层资源祭出“引用计数法”</strong></p><p>正如<code>std::shared_ptr</code>所做的那样，每一次复制对象就使引用计数+1，每一个对象离开定义域就调用析构函数使引用计数-1，直到引用计数为0就彻底销毁资源。</p><p><strong>选择三：复制底层资源</strong></p><p>在复制对象的同时复制底层资源的行为又被称作<strong>深拷贝（Deep copying）</strong>，例如在一个对象中有一个指针，那么在复制这个对象时就不能只复制指针，也要复制指针所指向的数据。</p><p><strong>选择四：转移底层资源的所有权</strong></p><p>和<code>std::unique_ptr</code>的行为类似，永远保持只有一个对象拥有对资源的管理权，当需要复制对象时转移资源的管理权。</p><h3 id="条款-15：在资源管理类中提供对原始资源的访问"><a href="#条款-15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款 15：在资源管理类中提供对原始资源的访问"></a>条款 15：在资源管理类中提供对原始资源的访问</h3><p>和所有的智能指针一样，STL 中的智能指针也提供了对原始资源的隐式访问和显式访问：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Investment<span class="token operator">*</span> pRaw <span class="token operator">=</span> pSharedInv<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 显式访问原始资源</span>Investment raw <span class="token operator">=</span> <span class="token operator">*</span>pSharedInv<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 隐式访问原始资源</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当我们在设计自己的资源管理类时，也要考虑在提供对原始资源的访问时，是使用显式访问还是隐式访问的方法，还是两者皆可。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Font</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    FontHandle <span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> handle<span class="token punctuation">;</span> <span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">// 显式转换函数</span>    <span class="token keyword">operator</span> <span class="token function">FontHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> handle<span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 隐式转换函数</span><span class="token keyword">private</span><span class="token operator">:</span>    FontHandle handle<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般而言显式转换比较安全，但隐式转换对客户比较方便。</p><h3 id="条款-16：成对使用-new-和-delete-时要采用相同形式"><a href="#条款-16：成对使用-new-和-delete-时要采用相同形式" class="headerlink" title="条款 16：成对使用 new 和 delete 时要采用相同形式"></a>条款 16：成对使用 new 和 delete 时要采用相同形式</h3><p>使用<code>new</code>来分配单一对象，使用<code>new[]</code>来分配对象数组，必须明确它们的行为并不一致，分配对象数组时会额外在内存中记录“数组大小”，而使用<code>delete[]</code>会根据记录的数组大小多次调用析构函数，使用<code>delete</code>则仅仅只会调用一次析构函数。对于单一对象使用<code>delete[]</code>其结果也是未定义的，程序可能会读取若干内存并将其错误地解释为数组大小。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">*</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token operator">*</span> object <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">;</span><span class="token keyword">delete</span> object<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，使用<code>typedef</code>定义数组类型会带来额外的风险：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> std<span class="token operator">::</span>string AddressLines<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>std<span class="token operator">::</span>string<span class="token operator">*</span> pal <span class="token operator">=</span> <span class="token keyword">new</span> AddressLines<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// pal 是一个对象数组，而非单一对象</span><span class="token keyword">delete</span> pal<span class="token punctuation">;</span>                             <span class="token comment" spellcheck="true">// 行为未定义</span><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pal<span class="token punctuation">;</span>                           <span class="token comment" spellcheck="true">// 正确</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-17：以独立语句将-newed-对象置入智能指针"><a href="#条款-17：以独立语句将-newed-对象置入智能指针" class="headerlink" title="条款 17：以独立语句将 newed 对象置入智能指针"></a>条款 17：以独立语句将 newed 对象置入智能指针</h3><p>原书此处所讲已过时，现在更好的做法是使用<code>std::make_unique</code>和<code>std::make_shared</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> pUniqueInv <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Investment<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// since C++14</span><span class="token keyword">auto</span> pSharedInv <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>Investment<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// since C++11</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="第四章：设计与声明"><a href="#第四章：设计与声明" class="headerlink" title="第四章：设计与声明"></a>第四章：设计与声明</h2><h3 id="条款-18：让接口容易被正确使用，不易被误用"><a href="#条款-18：让接口容易被正确使用，不易被误用" class="headerlink" title="条款 18：让接口容易被正确使用，不易被误用"></a>条款 18：让接口容易被正确使用，不易被误用</h3><ol><li>好的接口很容易被正确使用，不易被误用。你应在在你的所有接口中努力达成这些性质。</li><li>“促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容。</li><li>“阻止误用”的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。</li></ol><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 三个参数类型相同的函数容易造成误用</span>Data<span class="token operator">::</span><span class="token function">Data</span><span class="token punctuation">(</span><span class="token keyword">int</span> month<span class="token punctuation">,</span> <span class="token keyword">int</span> day<span class="token punctuation">,</span> <span class="token keyword">int</span> year<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 通过适当定义新的类型加以限制，降低误用的可能性</span>Data<span class="token operator">::</span><span class="token function">Data</span><span class="token punctuation">(</span><span class="token keyword">const</span> Month<span class="token operator">&amp;</span> m<span class="token punctuation">,</span> <span class="token keyword">const</span> Day<span class="token operator">&amp;</span> d<span class="token punctuation">,</span> <span class="token keyword">const</span> Year<span class="token operator">&amp;</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>尽量使用智能指针，避免跨DLL的 new 和 delete，使用智能指针自定义删除器来解除互斥锁（mutexes）。</li></ol><h3 id="条款-19：设计-class-犹如设计-type"><a href="#条款-19：设计-class-犹如设计-type" class="headerlink" title="条款 19：设计 class 犹如设计 type"></a>条款 19：设计 class 犹如设计 type</h3><p>几乎在设计每一个 class 时，都要面对如下问题：</p><p><strong>新 type 对象应该如何被创建和销毁？</strong> 这会影响到类中构造函数、析构函数、内存分配和释放函数（<code>operator new</code>，<code>operator new[]</code>，<code>operator delete</code>，<code>operator delete[]</code>）的设计。</p><p><strong>对象的初始化和赋值该有什么样的差别？</strong> 这会影响到构造函数和拷贝赋值运算之间行为的差异。</p><p><strong>新 type 的对象如果被按值传递，意味着什么？</strong> 这会影响到拷贝构造函数的实现。</p><p><strong>什么是新 type 的合法值？</strong> 你的类中的成员函数必须对类中成员变量的值进行检查，如果不合法就要尽快解决或明确地抛出异常。</p><p><strong>你的新 type 需要配合某个继承图系吗？</strong> 你的类是否受到基类设计地束缚，是否拥有该覆写地虚函数，是否允许被继承（若不想要被继承，应该声明为<code>final</code>）。</p><p><strong>什么样的运算符和函数对此新 type 而言是合理的？</strong> 这会影响到你将为你的类声明哪些函数和重载哪些运算符。</p><p><strong>什么样的标准函数应该被驳回？</strong> 这会影响到你将哪些标准函数声明为<code>= delete</code>。</p><p><strong>谁该取用新 type 的成员？</strong> 这会影响到你将类中哪些成员设为 public，private 或 protected，也将影响到友元类和友元函数的设置。</p><p><strong>什么是新 type 的“未声明接口”？</strong> 为未声明接口提供效率、异常安全性以及资源运用上的保证，并在实现代码中加上相应的约束条件。</p><p><strong>你的新 type 有多么一般化？</strong> 如果你想要一系列新 type 家族，应该优先考虑模板类。</p><h3 id="条款-20：宁以按常引用传参替换按值传参"><a href="#条款-20：宁以按常引用传参替换按值传参" class="headerlink" title="条款 20：宁以按常引用传参替换按值传参"></a>条款 20：宁以按常引用传参替换按值传参</h3><p>当使用按值传参时，程序会调用对象的拷贝构造函数构建一个在函数内作用的局部对象，这个过程的开销可能会较为昂贵。对于任何用户自定义类型，使用按常引用传参是较为推荐的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">ValidateStudent</span><span class="token punctuation">(</span><span class="token keyword">const</span> Student<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为没有任何新对象被创建，这种传参方式不会调用任何构造函数或析构函数，所以效率比按值传参高得多。</p><p>使用按引用传参也可以避免<strong>对象切片（Object slicing）</strong> 的问题，参考以下例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Window</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    std<span class="token operator">::</span>string <span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">WindowWithScrollBars</span> <span class="token operator">:</span> <span class="token keyword">public</span> Window <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> override<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此处一个<code>WindowWithScrollBars</code>类继承自<code>Window</code>基类。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">PrintNameAndDisplay</span><span class="token punctuation">(</span>Window w<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 按值传参，会发生对象切片</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> w<span class="token punctuation">.</span><span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    w<span class="token punctuation">.</span><span class="token function">Display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>此处在传参时，调用了基类<code>Window</code>的拷贝构造函数而非派生类的拷贝构造函数，因此在函数种使用的是一个<code>Window</code>对象，调用虚函数时也只能调用到基类的虚函数<code>Window::Display</code>。</p><p>由于按引用传递不会创建新对象，这个问题就能得到避免：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">PrintNameAndDisplay</span><span class="token punctuation">(</span><span class="token keyword">const</span> Window<span class="token operator">&amp;</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 参数不会被切片</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> w<span class="token punctuation">.</span><span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    w<span class="token punctuation">.</span><span class="token function">Display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>也并非永远都使用按引用传参，对于内置类型、STL的迭代器和函数对象，我们认为使用按值传参是比较合适的。</p><h3 id="条款-21：必须返回对象时，别妄想返回其引用"><a href="#条款-21：必须返回对象时，别妄想返回其引用" class="headerlink" title="条款 21：必须返回对象时，别妄想返回其引用"></a>条款 21：必须返回对象时，别妄想返回其引用</h3><p>返回一个指向函数内部局部变量的引用是严重的错误，因为局部变量在离开函数时就被销毁了，除此之外，返回一个指向局部静态变量的引用也是不被推荐的。</p><p>尽管返回对象会调用拷贝构造函数产生开销，但这开销比起出错而言微不足道。</p><h3 id="条款-22：将成员变量声明为-private"><a href="#条款-22：将成员变量声明为-private" class="headerlink" title="条款 22：将成员变量声明为 private"></a>条款 22：将成员变量声明为 private</h3><p>出于对封装性的考虑，应该尽可能地隐藏类中的成员变量，并通过对外暴露函数接口来实现对成员变量的访问：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">AccessLevels</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">GetReadOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> readOnly<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">SetReadWrite</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> readWrite <span class="token operator">=</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">GetReadWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> readWrite<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">SetWriteOnly</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> writeOnly <span class="token operator">=</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> noAccess<span class="token punctuation">;</span>    <span class="token keyword">int</span> readOnly<span class="token punctuation">;</span>    <span class="token keyword">int</span> readWrite<span class="token punctuation">;</span>    <span class="token keyword">int</span> writeOnly<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过为成员变量提供 getter 和 setter 函数，我们就能避免客户做出写入只读变量或读取只写变量这样不被允许的操作。</p><p>将成员变量隐藏在函数接口的背后，可以为“所有可能的实现”提供弹性。例如这可使得在成员变量被读或写时轻松通知其它对象，可以验证类的约束条件以及函数的提前和事后状态，可以在多线程环境中执行同步控制……</p><p><code>protected</code>和<code>public</code>一样，都不该被优先考虑。假设我们有一个public成员变量，最终取消了它，那么所有使用它的客户代码都将被破坏；假设我们有一个protected成员变量，最终取消了它，那么所有使用它的派生类都将被破坏。</p><p>综合以上讨论，在类中应当将成员变量优先声明为 private。</p><h3 id="条款-23：宁以非成员、非友元函数替换成员函数"><a href="#条款-23：宁以非成员、非友元函数替换成员函数" class="headerlink" title="条款 23：宁以非成员、非友元函数替换成员函数"></a>条款 23：宁以非成员、非友元函数替换成员函数</h3><p>假设有这样一个类：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">WebBrowser</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">void</span> <span class="token function">ClearCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">ClearHistory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">RemoveCookies</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果想要一次性调用这三个函数，那么需要额外提供一个新的函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">ClearEverything</span><span class="token punctuation">(</span>WebBrowser<span class="token operator">&amp;</span> wb<span class="token punctuation">)</span> <span class="token punctuation">{</span>    wb<span class="token punctuation">.</span><span class="token function">ClearCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    wb<span class="token punctuation">.</span><span class="token function">ClearHistory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    wb<span class="token punctuation">.</span><span class="token function">RemoveCookies</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，虽然成员函数和非成员函数都可以完成我们的目标，但此处更建议使用非成员函数，这是为了遵守一个原则：<strong>越少的代码可以访问数据，数据的封装性就越强</strong>。此处的<code>ClearEverything</code>函数仅仅是调用了<code>WebBrowser</code>的三个public成员函数，而并没有使用到<code>WebBrowser</code>内部的private成员，因此没有必要让其也拥有访问类中private成员的能力。</p><p>这个原则对于友元函数也是相同的，因为友元函数和成员函数拥有相同的权力，所以在能使用非成员函数完成任务的情况下，就不要使用友元函数和成员函数。</p><p>如果你觉得一个全局函数并不自然，也可以考虑将<code>ClearEverything</code>函数放在工具类中充当静态成员函数，或与<code>WebBrowser</code>放在同一个命名空间中：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">namespace</span> WebBrowserStuff <span class="token punctuation">{</span>    <span class="token keyword">class</span> <span class="token class-name">WebBrowser</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">ClearEverything</span><span class="token punctuation">(</span>WebBrowser<span class="token operator">&amp;</span> wb<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-24：若所有参数皆需类型转换，请为此采用非成员函数"><a href="#条款-24：若所有参数皆需类型转换，请为此采用非成员函数" class="headerlink" title="条款 24：若所有参数皆需类型转换，请为此采用非成员函数"></a>条款 24：若所有参数皆需类型转换，请为此采用非成员函数</h3><p>现在我们手头上拥有一个<code>Rational</code>类，并且它可以和<code>int</code>隐式转换：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Rational</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Rational</span><span class="token punctuation">(</span><span class="token keyword">int</span> numerator <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> denominator <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，我们需要重载乘法运算符来实现<code>Rational</code>对象之间的乘法：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Rational</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将运算符重载放在类中是行得通的，至少对于<code>Rational</code>对象来说是如此。但当我们考虑混合运算时，就会出现一个问题：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Rational <span class="token function">oneEight</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Rational <span class="token function">oneHalf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Rational result <span class="token operator">=</span> oneHalf <span class="token operator">/</span> oneEight<span class="token punctuation">;</span>result <span class="token operator">=</span> oneHalf <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 正确</span>result <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> oneHalf<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 报错</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假如将乘法运算符写成函数形式，错误的原因就一目了然了：</p><pre class="line-numbers language-cpp"><code class="language-cpp">result <span class="token operator">=</span> oneHalf<span class="token punctuation">.</span><span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 正确</span>result <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">.</span><span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span>oneHalf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 报错</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在调用<code>operator*</code>时，<code>int</code>类型的变量会隐式转换为<code>Rational</code>对象，因此用<code>Rational</code>对象乘以<code>int</code>对象是合法的，但反过来则不是如此。</p><p>所以，为了避免这个错误，我们应当将运算符重载放在类外，作为非成员函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="条款-25：考虑写出一个不抛异常的swap函数"><a href="#条款-25：考虑写出一个不抛异常的swap函数" class="headerlink" title="条款 25：考虑写出一个不抛异常的swap函数"></a>条款 25：考虑写出一个不抛异常的swap函数</h3><p>由于<code>std::swap</code>函数在 C++11 后改为了用<code>std::move</code>实现，因此几乎已经没有性能的缺陷，也不再有像原书中所说的为自定义类型去自己实现的必要。不过原书中透露的思想还是值得一学的。</p><p>如果想为自定义类型实现自己的swap方法，可以考虑使用模板全特化，并且这种做法是被 STL 允许的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">using</span> std<span class="token operator">::</span>swap<span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>pImpl<span class="token punctuation">,</span> other<span class="token punctuation">.</span>pImpl<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    WidgetImpl<span class="token operator">*</span> pImpl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">namespace</span> std <span class="token punctuation">{</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span>    <span class="token keyword">void</span> swap<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> Widget<span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        a<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，由于外部函数并不能直接访问<code>Widget</code>的private成员变量，因此我们先是在类中定义了一个 public 成员函数，再由<code>std::swap</code>去调用这个成员函数。</p><p>然而若<code>Widget</code>和<code>WidgetImpl</code>是类模板，情况就没有这么简单了，因为 C++ 不支持函数模板偏特化，所以只能使用重载的方式：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">namespace</span> std <span class="token punctuation">{</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>    <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Widget<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span> Widget<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        a<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但很抱歉，这种做法是被 STL 禁止的，因为这是在试图向 STL 中添加新的内容，所以我们只能退而求其次，在其它命名空间中定义新的swap函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">namespace</span> WidgetStuff <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>    <span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token number">3</span>    <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Widget<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span> Widget<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        a<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们希望在对自定义对象进行操作时找到正确的swap函数重载版本，这时候如果再写成<code>std::swap</code>，就会强制使用 STL 中的swap函数，无法满足我们的需求，因此需要改写成：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> std<span class="token operator">::</span>swap<span class="token punctuation">;</span><span class="token function">swap</span><span class="token punctuation">(</span>obj1<span class="token punctuation">,</span> obj2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样，C++ 名称查找法则能保证我们优先使用的是自定义的swap函数而非 STL 中的swap函数。</p><blockquote><p>C++ 名称查找法则：编译器会从使用名字的地方开始向上查找，由内向外查找各级作用域（命名空间）直到全局作用域（命名空间），找到同名的声明即停止，若最终没找到则报错。 函数匹配优先级：普通函数 &gt; 特化函数 &gt; 模板函数</p></blockquote><h2 id="第五章：实现"><a href="#第五章：实现" class="headerlink" title="第五章：实现"></a>第五章：实现</h2><h3 id="条款-26：尽可能延后变量定义式出现的时间"><a href="#条款-26：尽可能延后变量定义式出现的时间" class="headerlink" title="条款 26：尽可能延后变量定义式出现的时间"></a>条款 26：尽可能延后变量定义式出现的时间</h3><p>当变量定义出现时，程序需要承受其构造成本；当变量离开其作用域时，程序需要承受其析构成本。因此，避免不必要的变量定义，以及延后变量定义式直到你确实需要它。</p><p>延后变量定义式还有一个意义，即“默认构造+赋值”效率低于“直接构造”：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 效率低</span>std<span class="token operator">::</span>string encrypted<span class="token punctuation">;</span>encrypted <span class="token operator">=</span> password<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 效率高</span>std<span class="token operator">::</span>string <span class="token function">encrypted</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于循环中变量的定义，我们一般有两种做法：</p><p>A. 定义于循环外，在循环中赋值：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget w<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    w <span class="token operator">=</span> 取决于 i 的某个值<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种做法产生的开销：1 个构造函数 + 1 个析构函数 + n 个赋值操作</p><p>B. 定义于循环内：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Widget <span class="token function">w</span><span class="token punctuation">(</span>取决于 i 的某个值<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这种做法产生的开销：n 个构造函数 + n 个析构函数</p><p>由于做法A会将变量的作用域扩大，因此除非知道该变量的赋值成本比“构造+析构”成本低，或者对这段程序的效率要求非常高，否则建议使用做法B。</p><h3 id="条款-27：少做转型动作"><a href="#条款-27：少做转型动作" class="headerlink" title="条款 27：少做转型动作"></a>条款 27：少做转型动作</h3><p>C 式转型：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">(</span>T<span class="token punctuation">)</span>expression<span class="token function">T</span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>C++ 式转型：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const_cast</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>const_cast</code>用于常量性转除，这也是唯一一个有这个能力的 C++ 式转型。</li><li><code>dynamic_cast</code>用于安全地向下转型，这也是唯一一个 C 式转型无法代替的转型操作，它会执行对继承体系的检查，因此会带来额外的开销。只有拥有虚函数的基类指针能进行<code>dynamic_cast</code>。</li><li><code>reinterpret_cast</code>用于在任意两个类型间进行低级转型，执行该转型可能会带来风险，也可能不具备移植性。</li><li><code>static_cast</code>用于进行强制隐式转换，也是最常用的转型操作，可以将内置数据类型互相转换，也可以将<code>void*</code>和typed指针，基类指针和派生类指针互相转换。</li></ul><p>尽量在 C++ 程序中使用 C++ 式转型，因为 C++ 式转型操作功能更明确，可以避免不必要的错误。</p><p>唯一使用 C 式转型的时机可能是在调用 explicit 构造函数时：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">explicit</span> <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">DoSomeWork</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">DoSomeWork</span><span class="token punctuation">(</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 等价于 DoSomeWork(static_cast&lt;Widget>(15));</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，转型并非什么都没有做，而是可能会更改数据的底层表述，或者为指针附加偏移值，这和具体平台有关，因此不要妄图去揣测转型后对象的具体布局方式。</p><p>避免对<code>*this</code>进行转型，参考以下例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Window</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">OnResize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">SpecialWindow</span> <span class="token operator">:</span> <span class="token keyword">public</span> Window <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">OnResize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Window<span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">OnResize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码试图通过转型<code>*this</code>来调用基类的虚函数，然而这是严重错误的，这样做会得到一个新的<code>Window</code>副本并在该副本上调用函数，而非在原本的对象上调用函数。</p><p>正确的做法如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">SpecialWindow</span> <span class="token operator">:</span> <span class="token keyword">public</span> Window <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">OnResize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Window<span class="token operator">::</span><span class="token function">OnResize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当你想知道一个基类指针是否指向一个派生类对象时，你需要用到<code>dynamic_cast</code>，如果不满足，则会产生报错。但是对于继承体系的检查可能是非常慢的，所以在注重效率的程序中应当避免使用<code>dynamic_cast</code>，改用<code>static_cast</code>或别的代替方法。</p><h3 id="条款-28：避免返回-handles-指向对象的内部成分"><a href="#条款-28：避免返回-handles-指向对象的内部成分" class="headerlink" title="条款 28：避免返回 handles 指向对象的内部成分"></a>条款 28：避免返回 handles 指向对象的内部成分</h3><p>考虑以下<code>Rectangle</code>类：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> RectData <span class="token punctuation">{</span>    Point ulhc<span class="token punctuation">;</span>    Point lrhc<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    Point<span class="token operator">&amp;</span> <span class="token function">UpperLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> pData<span class="token operator">-</span><span class="token operator">></span>ulhc<span class="token punctuation">;</span> <span class="token punctuation">}</span>    Point<span class="token operator">&amp;</span> <span class="token function">LowerRight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> pData<span class="token operator">-</span><span class="token operator">></span>lrhc<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>RectData<span class="token operator">></span> pData<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码看起来没有任何问题，但其实是在做自我矛盾的事情：我们通过const成员函数返回了一个指向成员变量的引用，这使得成员变量可以在外部被修改，而这是违反 logical constness 的原则的。换句话说，你<strong>绝对不应该令成员函数返回一个指针指向“访问级别较低”的成员函数</strong>。</p><p>改成返回常引用可以避免对成员变量的修改：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const</span> Point<span class="token operator">&amp;</span> <span class="token function">UpperLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> pData<span class="token operator">-</span><span class="token operator">></span>ulhc<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">const</span> Point<span class="token operator">&amp;</span> <span class="token function">LowerRight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> pData<span class="token operator">-</span><span class="token operator">></span>lrhc<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>但是这样依然会带来一个称作 <strong>dangling handles（空悬句柄）</strong> 的问题，当对象不复存在时，你将无法通过引用获取到返回的数据。</p><p>采用最保守的做法，返回一个成员变量的副本：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Point <span class="token function">UpperLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> pData<span class="token operator">-</span><span class="token operator">></span>ulhc<span class="token punctuation">;</span> <span class="token punctuation">}</span>Point <span class="token function">LowerRight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> pData<span class="token operator">-</span><span class="token operator">></span>lrhc<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>避免返回 handles（包括引用、指针、迭代器）指向对象内部。遵循这个条款可增加封装性，使得const成员函数的行为符合常量性，并将发生 “空悬句柄” 的可能性降到最低。</p><h3 id="条款-29：为“异常安全”而努力是值得的"><a href="#条款-29：为“异常安全”而努力是值得的" class="headerlink" title="条款 29：为“异常安全”而努力是值得的"></a>条款 29：为“异常安全”而努力是值得的</h3><p>异常安全函数提供以下三个保证之一：</p><p><strong>基本承诺：</strong> 如果异常被抛出，程序内的任何事物仍然保持在有效状态下，没有任何对象或数据结构会因此败坏，所有对象都处于一种内部前后一致的状态，然而程序的真实状态是不可知的，也就是说客户需要额外检查程序处于哪种状态并作出对应的处理。</p><p><strong>强烈保证：</strong> 如果异常被抛出，程序状态完全不改变，换句话说，程序会回复到“调用函数之前”的状态。</p><p><strong>不抛掷（nothrow）保证：</strong> 承诺绝不抛出异常，因为程序总是能完成原先承诺的功能。作用于内置类型身上的所有操作都提供 nothrow 保证。</p><p>原书中实现 nothrow 的方法是<code>throw()</code>，不过这套异常规范在 C++11 中已经被弃用，取而代之的是<code>noexcept</code>关键字：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">DoSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意，使用<code>noexcept</code>并不代表函数绝对不会抛出异常，而是在抛出异常时，将代表出现严重错误，会有意想不到的函数被调用（可以通过<code>set_unexpected</code>设置），接着程序会直接崩溃。</p><p>当异常被抛出时，带有异常安全性的函数会：</p><ol><li>不泄漏任何资源。</li><li>不允许数据败坏。</li></ol><p>考虑以下<code>PrettyMenu</code>的<code>ChangeBackground</code>函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">PrettyMenu</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">void</span> <span class="token function">ChangeBackground</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>uint8_t<span class="token operator">></span><span class="token operator">&amp;</span> imgSrc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    Mutex mutex<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 互斥锁</span>    Image<span class="token operator">*</span> bgImage<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 目前的背景图像</span>    <span class="token keyword">int</span> imageChanges<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 背景图像被改变的次数</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> PrettyMenu<span class="token operator">::</span><span class="token function">ChangeBackground</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>uint8_t<span class="token operator">></span><span class="token operator">&amp;</span> imgSrc<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> bgImage<span class="token punctuation">;</span>    <span class="token operator">++</span>imageChanges<span class="token punctuation">;</span>    bgImage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Image</span><span class="token punctuation">(</span>imgSrc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很明显这个函数不满足我们所说的具有异常安全性的任何一个条件，若在函数中抛出异常，<code>mutex</code>会发生资源泄漏，<code>bgImage</code>和<code>imageChanges</code>也会发生数据败坏。</p><p>通过以对象管理资源，使用智能指针和调换代码顺序，我们能将其变成一个具有强烈保证的异常安全函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> PrettyMenu<span class="token operator">::</span><span class="token function">ChangeBackground</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>uint8_t<span class="token operator">></span><span class="token operator">&amp;</span> imgSrc<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Lock <span class="token function">m1</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    bgImage<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>Image<span class="token operator">></span><span class="token punctuation">(</span>imgSrc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">++</span>imageChanges<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一个常用于提供强烈保证的方法是我们所提到过的 copy and swap，为你打算修改的对象做出一份副本，对副本执行修改，并在所有修改都成功执行后，用一个不会抛出异常的swap方法将原件和副本交换：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> PMImpl <span class="token punctuation">{</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Image<span class="token operator">></span> bgImage<span class="token punctuation">;</span>    <span class="token keyword">int</span> imageChanges<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">PrettyMenu</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    Mutex mutex<span class="token punctuation">;</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>PMImpl<span class="token operator">></span> pImpl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> PrettyMenu<span class="token operator">::</span><span class="token function">ChangeBackground</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>uint8_t<span class="token operator">></span><span class="token operator">&amp;</span> imgSrc<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Lock <span class="token function">m1</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> pNew <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>PMImpl<span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">*</span>pImpl<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取副本</span>    pNew<span class="token operator">-</span><span class="token operator">></span>bgImage<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>Image<span class="token operator">></span><span class="token punctuation">(</span>imgSrc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">++</span>pNew<span class="token operator">-</span><span class="token operator">></span>imageChanges<span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">swap</span><span class="token punctuation">(</span>pImpl<span class="token punctuation">,</span> pNew<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当一个函数调用其它函数时，函数提供的“异常安全保证”通常最高只等于其所调用的各个函数的“异常安全保证”中的最弱者。</p><p>强烈保证并非永远都是可实现的，特别是当函数在操控非局部对象时，这时就只能退而求其次选择不那么美好的基本承诺，并将该决定写入文档，让其他人维护时不至于毫无心理准备。</p><h3 id="条款-30：透彻了解-inlining-的里里外外"><a href="#条款-30：透彻了解-inlining-的里里外外" class="headerlink" title="条款 30：透彻了解 inlining 的里里外外"></a>条款 30：透彻了解 inlining 的里里外外</h3><p>将函数声明为内联一共有两种方法，一种是为其显式指定<code>inline</code>关键字，另一种是直接将成员函数的定义式写在类中，如下所示：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">int</span> <span class="token function">Age</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> theAge<span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 隐式声明为 inline</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> theAge<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>inline</code>诞生之初，它被当作是一种对编译器的优化建议，即将“对此函数的每一个调用”都以函数本体替换之。但在编译器的具体实现中，该行为完全被优化等级所控制，与函数是否内联无关。</p><p>在现在的 C++ 标准中，<code>inline</code>作为优化建议的含义已经被完全抛弃，取而代之的是“允许函数在不同编译单元中多重定义”，使得可以在头文件中直接给出函数的实现。</p><p>在 C++17 中，引入了一个新的<code>inline</code>用法，使静态成员变量可以在类中直接定义：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> theAge <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// since C++17</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-31：将文件间的编译依存关系降至最低"><a href="#条款-31：将文件间的编译依存关系降至最低" class="headerlink" title="条款 31：将文件间的编译依存关系降至最低"></a>条款 31：将文件间的编译依存关系降至最低</h3><p>C++ 坚持将类的实现细节放置于类的定义式中，这就意味着，即使你只改变类的实现而不改变类的接口，在构建程序时依然需要重新编译。这个问题的根源出在编译器必须在编译期间知道对象的大小，如果看不到类的定义式，就没有办法为对象分配内存。也就是说，C++ 并没有把“将接口从实现中分离”这件事做得很好。</p><p><strong>用“声明的依存性”替换“定义的依存性”：</strong></p><p>我们可以玩一个“将对象实现细目隐藏于一个指针背后”的游戏，称作 <strong>pimpl idiom（pimpl 是 pointer to implemention 的缩写）</strong>：将原来的一个类分割为两个类，一个只提供接口，另一个负责实现该接口，称作<strong>句柄类（handle class）</strong>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// person.hpp 负责声明类</span><span class="token keyword">class</span> <span class="token class-name">PersonImpl</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>PersonImpl<span class="token operator">></span> pImpl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// person.cpp 负责实现类</span><span class="token keyword">class</span> <span class="token class-name">PersonImpl</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> data<span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Person<span class="token operator">::</span><span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    pImpl <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>PersonImpl<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> Person<span class="token operator">::</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> pImpl<span class="token operator">-</span><span class="token operator">></span>data<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，假如我们要修改<code>Person</code>的private成员，就只需要修改<code>PersonImpl</code>中的内容，而<code>PersonImpl</code>的具体实现是被隐藏起来的，对它的任何修改都不会使得<code>Person</code>客户端重新编译，真正实现了“类的接口和实现分离”。</p><p><strong>如果使用对象引用或对象指针可以完成任务，就不要使用对象本身：</strong></p><p>你可以只靠一个类型声明式就定义出指向该类型的引用和指针；但如果定义某类型的对象，就需要用到该类型的定义式。</p><p><strong>如果能够，尽量以类声明式替换类定义式：</strong></p><p>当你在声明一个函数而它用到某个类时，你不需要该类的定义；但当你触及到该函数的定义式后，就必须也知道类的定义：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Date</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">// 类的声明式</span>Date <span class="token function">Today</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">ClearAppointments</span><span class="token punctuation">(</span>Data d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 此处并不需要得知类的定义</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>为声明式和定义式提供不同的头文件：</strong></p><p>为了避免频繁地添加声明，我们应该为所有要用的类声明提供一个头文件，这种做法对 template 也适用：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"datefwd.h"</span>            </span><span class="token comment" spellcheck="true">// 这个头文件内声明 class Date</span>Date <span class="token function">Today</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">ClearAppointments</span><span class="token punctuation">(</span>Data d<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此处的头文件命名方式<code>&quot;datefwd.h&quot;</code>取自标准库中的<code>&lt;iosfwd&gt;</code>。</p><p>上面我们讲述了接口与实现分离的其中一个方法——提供句柄类，另一个方法就是将句柄类定义为抽象基类，称作<strong>接口类（interface class）</strong>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了将<code>Person</code>对象实际创建出来，我们一般采用工厂模式。可以尝试在类中塞入一个静态成员函数<code>Create</code>用于创建对象：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">static</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Person<span class="token operator">></span> <span class="token function">Create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但此时<code>Create</code>函数还无法使用，需要在派生类中给出<code>Person</code>类中的函数的具体实现：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">RealPerson</span> <span class="token operator">:</span> <span class="token keyword">public</span> Person <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">RealPerson</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">RealPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> data<span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完成<code>Create</code>函数的定义：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">static</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Person<span class="token operator">></span> Person<span class="token operator">::</span><span class="token function">Create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>RealPerson<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>毫无疑问的是，句柄类和接口类都需要额外的开销：句柄类需要通过 pimpl 取得对象数据，增加一层间接访问、指针大小和动态分配内存带来的开销；而接口类会增加存储虚表指针和实现虚函数跳转带来的开销。</p><p>而当这些开销过于重大以至于类之间的耦合度在相形之下不成为关键时，就以具象类（concrete class）替换句柄类和接口类。</p><h2 id="第六章：继承与面向对象设计"><a href="#第六章：继承与面向对象设计" class="headerlink" title="第六章：继承与面向对象设计"></a>第六章：继承与面向对象设计</h2><h3 id="条款-32：确定你的public继承塑模出-is-a-关系"><a href="#条款-32：确定你的public继承塑模出-is-a-关系" class="headerlink" title="条款 32：确定你的public继承塑模出 is-a 关系"></a>条款 32：确定你的public继承塑模出 is-a 关系</h3><p>“public继承”意味着 is-a，所谓 is-a，就是指适用于基类身上的每一件事情一定也适用于继承类身上，因为我们可以认为每一个派生类对象也都是一个基类对象。</p><p>这看似很自然，但在面对自然语言的表述时，往往会产生歧义。</p><p>考虑<code>Bird</code>类和<code>Penguin</code>类的继承关系：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Bird</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Penguin</span> <span class="token operator">:</span> <span class="token keyword">public</span> Bird <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Penguin</code>类会获得来自<code>Bird</code>类的飞行方法，这就造成了误解，因为企鹅恰恰是不会飞的鸟类。一种解决方法是当调用<code>Penguin</code>类中的<code>Fly</code>函数时，抛出一个运行期错误，但这种做法通常不够直观；另一个解决方法是使用双继承，区分会飞和不会飞的鸟类：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Bird</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">FlyingBird</span> <span class="token operator">:</span> <span class="token keyword">public</span> Bird <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Penguin</span> <span class="token operator">:</span> <span class="token keyword">public</span> FlyingBird <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但若要处理鸟类的多钟不同属性时，双继承模式就不太管用了，因此我们总是说程序设计没有银弹。</p><p>另一个常见的例子是用<code>Square</code>类继承自<code>Rectangle</code>类，从几何学的角度来讲这很自然，然而正方形的长宽是相等的，矩形却不是如此，因此<code>Square</code>类和<code>Rectangle</code>类也无法满足严格的 is-a 关系。</p><h3 id="条款-33：避免遮掩继承而来的名称"><a href="#条款-33：避免遮掩继承而来的名称" class="headerlink" title="条款 33：避免遮掩继承而来的名称"></a>条款 33：避免遮掩继承而来的名称</h3><p>之前我们了解过 C++ 名称查找法则，这在继承体系中也是类似的，当我们在派生类中使用到一个名字时，编译器会优先查找派生类覆盖的作用域，如果没找到，再去查找基类的作用域，最后再查找全局作用域。</p><p>考虑以下情形：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">mf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">mf</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">mf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样会导致派生类无法使用来自基类的重载函数，因为派生类中的名称<code>mf</code>掩盖了来自基类的名称<code>mf</code>。</p><p>对于名称掩盖问题的一种方法是使用<code>using</code>关键字：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> Base<span class="token operator">::</span>mf<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>using</code>关键字会将基类中所有使用到名称<code>mf</code>的函数全部包含在派生类中，包括其重载版本。</p><p>若有时我们不想要一个函数的全部版本，只想要单一版本（特别是在private继承时），可以考虑使用<strong>转发函数（forwarding function）</strong>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Base<span class="token operator">::</span><span class="token function">mf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-34：区分接口继承和实现继承"><a href="#条款-34：区分接口继承和实现继承" class="headerlink" title="条款 34：区分接口继承和实现继承"></a>条款 34：区分接口继承和实现继承</h3><ol><li>接口继承和实现继承不一样。在public继承下，派生类总是继承基类的接口。</li><li>声明一个纯虚函数的目的，是为了让派生类只继承函数接口。</li><li>声明简朴的非纯虚函数的目的，是让派生类继承该函数的接口和缺省实现。</li><li>声明非虚函数的目的，是为了令派生类继承函数的接口及一份强制性实现。</li></ol><p>通常而言，我们不会为纯虚函数提供具体实现，然而这样做是被允许的，并且用于替代简朴的非纯虚函数，提供更平常更安全的缺省实现。</p><p>用非纯虚函数提供缺省的默认实现：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Airplane</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 缺省实现</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Model</span> <span class="token operator">:</span> <span class="token keyword">public</span> Airplane <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是最简朴的做法，但是这样做会带来的问题是，由于不强制对虚函数的覆写，在定义新的派生类时可能会忘记进行覆写，导致错误地使用了缺省实现。</p><p>使用纯虚函数并提供默认实现：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Airplane</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">DefaultFly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 缺省实现</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Model</span> <span class="token operator">:</span> <span class="token keyword">public</span> Airplane <span class="token punctuation">{</span> <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        <span class="token function">DefaultFly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述写法可以替代为：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Airplane</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> Airplane<span class="token operator">::</span><span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 缺省实现</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Model</span> <span class="token operator">:</span> <span class="token keyword">public</span> Airplane <span class="token punctuation">{</span> <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        Airplane<span class="token operator">::</span><span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-35：考虑虚函数以外的其它选择"><a href="#条款-35：考虑虚函数以外的其它选择" class="headerlink" title="条款 35：考虑虚函数以外的其它选择"></a>条款 35：考虑虚函数以外的其它选择</h3><p><strong>藉由非虚接口手法实现 template method：</strong></p><p><strong>非虚接口（non-virtual interface，NVI）</strong> 设计手法的核心就是用一个非虚函数作为 wrapper，将虚函数隐藏在封装之下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">GameCharacter</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">HealthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 做一些前置工作</span>        <span class="token keyword">int</span> retVal <span class="token operator">=</span> <span class="token function">DoHealthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 做一些后置工作</span>        <span class="token keyword">return</span> retVal<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">int</span> <span class="token function">DoHealthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 缺省算法</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>NVI手法的一个优点就是在 wrapper 中做一些前置和后置工作，确保得以在一个虚函数被调用之前设定好适当场景，并在调用结束之后清理场景。如果你让客户直接调用虚函数，就没有任何好办法可以做这些事。</p><p>NVI手法允许派生类重新定义虚函数，从而赋予它们“如何实现机能”的控制能力，但基类保留诉说“函数何时被调用”的权利。</p><p>在NVI手法中虚函数除了可以是private，也可以是protected，例如要求在派生类的虚函数实现内调用其基类的对应虚函数时，就必须得这么做。</p><p><strong>藉由函数指针实现 Strategy 模式：</strong></p><p>参考以下例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">GameCharacter</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">DefaultHealthCalc</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 缺省算法</span><span class="token keyword">class</span> <span class="token class-name">GameCharacter</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> HealthCalcFunc <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 定义函数指针类型</span>    <span class="token keyword">explicit</span> <span class="token function">GameCharacter</span><span class="token punctuation">(</span>HealthCalcFunc hcf <span class="token operator">=</span> DefaultHealthCalc<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">healthFunc</span><span class="token punctuation">(</span>hcf<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">HealthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">healthFunc</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    HealthCalcFunc healthFunc<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同一个人物类型的不同实体可以有不同的健康计算函数，并且该计算函数可以在运行期变更。</p><p>这间接表明健康计算函数不再是<code>GameCharacter</code>继承体系内的成员函数，它也无权使用非public成员。为了填补这个缺陷，我们唯一的做法是弱化类的封装，引入友元或提供public访问函数。</p><p><strong>藉由 std::function 完成 Strategy 模式</strong></p><p><code>std::function</code>是 C++11 中引入的函数包装器，使用它能提供比函数指针更强的灵活度：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">GameCharacter</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">DefaultHealthCalc</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 缺省算法</span><span class="token keyword">class</span> <span class="token class-name">GameCharacter</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> HealthCalcFunc <span class="token operator">=</span> std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 定义函数包装器类型</span>    <span class="token keyword">explicit</span> <span class="token function">GameCharacter</span><span class="token punctuation">(</span>HealthCalcFunc hcf <span class="token operator">=</span> DefaultHealthCalc<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">healthFunc</span><span class="token punctuation">(</span>hcf<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">HealthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">healthFunc</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    HealthCalcFunc healthFunc<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看起来并没有很大的改变，但当我们需要时，<code>std::function</code>就能展现出惊人的弹性：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 使用返回值不同的函数</span><span class="token keyword">short</span> <span class="token function">CalcHealth</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>GameCharacter <span class="token function">chara1</span><span class="token punctuation">(</span>CalcHealth<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用函数对象（仿函数）</span><span class="token keyword">struct</span> HealthCalculator <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>GameCharacter <span class="token function">chara2</span><span class="token punctuation">(</span><span class="token function">HealthCalculator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用某个成员函数</span><span class="token keyword">class</span> <span class="token class-name">GameLevel</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">float</span> <span class="token function">Health</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>GameLevel currentLevel<span class="token punctuation">;</span>GameCharacter <span class="token function">chara2</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>GameLevel<span class="token operator">::</span>Health<span class="token punctuation">,</span> currentLevel<span class="token punctuation">,</span> std<span class="token operator">::</span>placeholders<span class="token operator">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>古典的 Strategy 模式：</strong></p><p>在古典的 Strategy 模式中，我们并非直接利用函数指针（或包装器）调用函数，而是内含一个指针指向来自<code>HealthCalcFunc</code>继承体系的对象：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">GameCharacter</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">HealthCalcFunc</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">int</span> <span class="token function">Calc</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span> gc<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>HealthCalcFunc defaultHealthCalc<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">GameCharacter</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">explicit</span> <span class="token function">GameCharacter</span><span class="token punctuation">(</span>HealthCalcFunc<span class="token operator">*</span> phcf <span class="token operator">=</span> <span class="token operator">&amp;</span>defaultHealthCalc<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">pHealthCalc</span><span class="token punctuation">(</span>phcf<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">HealthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> pHealthCalc<span class="token operator">-</span><span class="token operator">></span><span class="token function">Calc</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    HealthCalcFunc<span class="token operator">*</span> pHealthCalc<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个设计模式的好处在于足够容易辨认，想要添加新的计算函数也只需要为<code>HealthCalcFunc</code>基类添加一个派生类即可。</p><h3 id="条款-36：绝不重新定义继承而来的非虚函数"><a href="#条款-36：绝不重新定义继承而来的非虚函数" class="headerlink" title="条款 36：绝不重新定义继承而来的非虚函数"></a>条款 36：绝不重新定义继承而来的非虚函数</h3><p>非虚函数和虚函数具有本质上的不同：非虚函数执行的是静态绑定（statically bound，又称前期绑定，early binding），由对象类型本身（称之静态类型）决定要调用的函数；而虚函数执行的是动态绑定（dynamically bound，又称后期绑定，late binding），决定因素不在对象本身，而在于“指向该对象之指针”当初的声明类型（称之动态类型）。</p><p>前面我们已经说过，public继承意味着 is-a 关系，而在基类中声明一个非虚函数将会为该类建立起一种不变性（invariant），凌驾其特异性（specialization）。而若在派生类中重新定义该非虚函数，则会使人开始质疑是否该使用public继承的形式；如果必须使用，则又打破了基类“不变性凌驾特异性”的性质，就此产生了设计上的矛盾。</p><p>综上所述，在任何情况下都不该重新定义一个继承而来的非虚函数。</p><h3 id="条款-37：绝不重新定义继承而来的缺省参数值"><a href="#条款-37：绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款 37：绝不重新定义继承而来的缺省参数值"></a>条款 37：绝不重新定义继承而来的缺省参数值</h3><p>在条款 36 中我们已经否定了重新定义非虚函数的可能性，因此此处我们只讨论带有缺省参数值的虚函数。</p><p>虚函数是动态绑定而来，意思是调用一个虚函数时，究竟调用哪一份函数实现代码，取决于发出调用的那个对象的动态类型。但与之不同的是，<strong>缺省参数值却是静态绑定</strong>，意思是你可能会在“调用一个定义于派生类的虚函数”的同时，却使用基类为它所指定的缺省参数值。考虑以下例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">ShapeColor</span> <span class="token punctuation">{</span> Red<span class="token punctuation">,</span> Green<span class="token punctuation">,</span> Blue <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Draw</span><span class="token punctuation">(</span>ShapeColor color <span class="token operator">=</span> ShapeColor<span class="token operator">::</span>Red<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Rectangle</span> <span class="token operator">:</span> <span class="token keyword">public</span> Shape <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Draw</span><span class="token punctuation">(</span>ShapeColor color <span class="token operator">=</span> ShapeColor<span class="token operator">::</span>Green<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Circle</span> <span class="token operator">:</span> <span class="token keyword">public</span> Shape <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Draw</span><span class="token punctuation">(</span>ShapeColor color<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时若对派生类对象调用<code>Draw</code>函数，则会发现：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Shape<span class="token operator">*</span> pr <span class="token operator">=</span> <span class="token keyword">new</span> Rectangle<span class="token punctuation">;</span>Shape<span class="token operator">*</span> pc <span class="token operator">=</span> <span class="token keyword">new</span> Circle<span class="token punctuation">;</span>pr<span class="token operator">-</span><span class="token operator">></span><span class="token function">Draw</span><span class="token punctuation">(</span>Shape<span class="token operator">::</span>ShapeColor<span class="token operator">::</span>Green<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用 Rectangle::Draw(Shape::Green)</span>pr<span class="token operator">-</span><span class="token operator">></span><span class="token function">Draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// 调用 Rectangle::Draw(Shape::Red)</span>pc<span class="token operator">-</span><span class="token operator">></span><span class="token function">Draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// 调用 Rectangle::Draw(Shape::Red)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这就迫使我们在指定虚函数时使用相同的缺省参数值，为了避免不必要的麻烦和错误，可以考虑条款 35 中列出的虚函数的替代设计，例如NVI手法：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">ShapeColor</span> <span class="token punctuation">{</span> Red<span class="token punctuation">,</span> Green<span class="token punctuation">,</span> Blue <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">Draw</span><span class="token punctuation">(</span>ShapeColor color <span class="token operator">=</span> ShapeColor<span class="token operator">::</span>Red<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token function">DoDraw</span><span class="token punctuation">(</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">DoDraw</span><span class="token punctuation">(</span>ShapeColor color<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Rectangle</span> <span class="token operator">:</span> <span class="token keyword">public</span> Shape <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">DoDraw</span><span class="token punctuation">(</span>ShapeColor color<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-38：通过复合塑模出-has-a-或“根据某物实现出”"><a href="#条款-38：通过复合塑模出-has-a-或“根据某物实现出”" class="headerlink" title="条款 38：通过复合塑模出 has-a 或“根据某物实现出”"></a>条款 38：通过复合塑模出 has-a 或“根据某物实现出”</h3><p>所谓<strong>复合（composition）</strong>，指的是某种类型的对象内含它种类型的对象。复合通常意味着 <strong>has-a</strong> 或<strong>根据某物实现出（is-implemented-in-terms-of）</strong> 的关系，当复合发生于应用域（application domain）内的对象之间，表现出 has-a 的关系；当它发生于实现域（implementation domain）内则是表现出“根据某物实现出”的关系。</p><p>下面是一个 has-a 关系的例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Address</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">PhoneNumber</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>string name<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 合成成分物（composed object）</span>    Address address<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 同上</span>    PhoneNumber voiceNumber<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 同上</span>    PhoneNumber faxNumber<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 同上</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是一个“根据某物实现出”关系的例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 将 list 应用于 Set</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Set</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">member</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> item<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>size_t <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>list<span class="token operator">&lt;</span>T<span class="token operator">></span> rep<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 用来表述 Set 的数据</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-39：明智而审慎地使用private继承"><a href="#条款-39：明智而审慎地使用private继承" class="headerlink" title="条款 39：明智而审慎地使用private继承"></a>条款 39：明智而审慎地使用private继承</h3><p>private继承的特点：</p><ol><li>如果类之间是private继承关系，那么编译器不会自动将一个派生类对象转换为一个基类对象。</li><li>由private继承来的所有成员，在派生类中都会变为private属性，换句话说，private继承只继承实现，不继承接口。</li></ol><p>private继承的意义是“根据某物实现出”，如果你读过条款 38，就会发现private继承和复合具有相同的意义，事实上也确实如此，绝大部分private继承的使用场合都可以被“public继承+复合”完美解决：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Timer</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">explicit</span> <span class="token function">Timer</span><span class="token punctuation">(</span><span class="token keyword">int</span> tickFrequency<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">OnTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token operator">:</span> <span class="token keyword">private</span> Timer <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">OnTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>替代为：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">class</span> <span class="token class-name">WidgetTimer</span> <span class="token operator">:</span> <span class="token keyword">public</span> Timer <span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">OnTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    WidgetTimer timer<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用后者比前者好的原因有以下几点：</p><ol><li>private继承无法阻止派生类重新定义虚函数，但若使用public继承定义<code>WidgetTimer</code>类并复合在<code>Widget</code>类中，就能防止在<code>Widget</code>类中重新定义虚函数。</li><li>可以仅提供<code>WidgetTimer</code>类的声明，并将<code>WidgetTimer</code>类的具体定义移至实现文件中，从而降低<code>Widget</code>的编译依存性。</li></ol><p>然而private继承并非完全一无是处，一个适用于它的极端情况是<strong>空白基类最优化（empty base optimization，EBO）</strong>，参考以下例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Empty</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">HoldsAnInt</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    Empty e<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个没有非静态成员变量、虚函数的类，看似不需要任何存储空间，但实际上 C++ 规定凡是独立对象都必须有非零大小，因此此处<code>sizeof(HoldsAnInt)</code>必然大于<code>sizeof(int)</code>，通常会多出一字节大小，但有时考虑到内存对齐之类的要求，可能会多出更多的空间。</p><p>使用private继承可以避免产生额外存储空间，将上面的代码替代为：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">HoldsAnInt</span> <span class="token operator">:</span> <span class="token keyword">private</span> Empty <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-40：明智而审慎地使用多重继承"><a href="#条款-40：明智而审慎地使用多重继承" class="headerlink" title="条款 40：明智而审慎地使用多重继承"></a>条款 40：明智而审慎地使用多重继承</h3><p>多重继承是一个可能会造成很多歧义和误解的设计，因此反对它的声音此起彼伏，下面我们来接触几个使用多重继承的场景。</p><p>最先需要认清的一件事是，程序有可能从一个以上的基类继承相同名称，那会导致较多的歧义机会：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">BorrowableItem</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">CheckOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">ElectronicGadget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">CheckOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">MP3Player</span> <span class="token operator">:</span> <span class="token keyword">public</span> BorrowableItem<span class="token punctuation">,</span> <span class="token keyword">public</span> ElectronicGadget <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>MP3Player mp<span class="token punctuation">;</span>mp<span class="token punctuation">.</span><span class="token function">CheckOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// MP3Player::CheckOut 不明确！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果真遇到这种情况，必须明确地指出要调用哪一个基类中的函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp">mp<span class="token punctuation">.</span>BorrowableItem<span class="token operator">::</span><span class="token function">CheckOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 使用 BorrowableItem::CheckOut</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在使用多重继承时，我们可能会遇到要命的“菱形继承”：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">File</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">InputFile</span> <span class="token operator">:</span> <span class="token keyword">public</span> File <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">OutputFile</span> <span class="token operator">:</span> <span class="token keyword">public</span> File <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">IOFile</span> <span class="token operator">:</span> <span class="token keyword">public</span> InputFile<span class="token punctuation">,</span> <span class="token keyword">public</span> OutputFile <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这时候必须面对这样一个问题：是否打算让基类内的成员变量经由每一条路径被复制？如果不想要这样，应当使用虚继承，指出其愿意共享基类：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">File</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">InputFile</span> <span class="token operator">:</span> <span class="token keyword">virtual</span> <span class="token keyword">public</span> File <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">OutputFile</span> <span class="token operator">:</span> <span class="token keyword">virtual</span> <span class="token keyword">public</span> File <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">IOFile</span> <span class="token operator">:</span> <span class="token keyword">public</span> InputFile<span class="token punctuation">,</span> <span class="token keyword">public</span> OutputFile <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然而由于虚继承会在派生类中额外存储信息来确认成员来自于哪个基类，虚继承通常会付出更多空间和速度的代价，并且由于虚基类的初始化责任是由继承体系中最底层的派生类负责，就导致了虚基类必须认知其虚基类并且承担虚基类的初始化责任。因此我们应当遵循以下两个建议：</p><ol><li>非必要不使用虚继承。</li><li>如果必须使用虚继承，尽可能避免在虚基类中放置数据。</li></ol><p>多重继承可用于结合public继承和private继承，public继承用于提供接口，private继承用于提供实现：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// IPerson 类指出要实现的接口</span><span class="token keyword">class</span> <span class="token class-name">IPerson</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">IPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> std<span class="token operator">::</span>string <span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> std<span class="token operator">::</span>string <span class="token function">BirthDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">DatabaseID</span> <span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// PersonInfo 类有若干已实现的函数</span><span class="token comment" spellcheck="true">// 可用以实现 IPerson 接口</span><span class="token keyword">class</span> <span class="token class-name">PersonInfo</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">explicit</span> <span class="token function">PersonInfo</span><span class="token punctuation">(</span>DatabaseID pid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">PersonInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">TheName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">TheBirthDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">ValueDelimOpen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">ValueDelimClose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// CPerson 类使用多重继承</span><span class="token keyword">class</span> <span class="token class-name">CPerson</span><span class="token operator">:</span> <span class="token keyword">public</span> IPerson<span class="token punctuation">,</span> <span class="token keyword">private</span> PersonInfo <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">explicit</span> <span class="token function">CPerson</span><span class="token punctuation">(</span>DatabaseID pid<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">PersonInfo</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">virtual</span> std<span class="token operator">::</span>string <span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// 实现必要的 IPerson 成员函数</span>        <span class="token keyword">return</span> PersonInfo<span class="token operator">::</span><span class="token function">TheName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token keyword">virtual</span> std<span class="token operator">::</span>string <span class="token function">BirthDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 实现必要的 IPerson 成员函数</span>        <span class="token keyword">return</span> PersonInfo<span class="token operator">::</span><span class="token function">TheBirthDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">// 重新定义继承而来的虚函数</span>    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">ValueDelimOpen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">ValueDelimClose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第七章：模板与泛型编程"><a href="#第七章：模板与泛型编程" class="headerlink" title="第七章：模板与泛型编程"></a>第七章：模板与泛型编程</h2><h3 id="条款-41：了解隐式接口和编译期多态"><a href="#条款-41：了解隐式接口和编译期多态" class="headerlink" title="条款 41：了解隐式接口和编译期多态"></a>条款 41：了解隐式接口和编译期多态</h3><p>类与模板都支持接口和多态。对于类而言接口是显式的，以函数签名为中心，多态则是通过虚函数发生于运行期；而对模板参数而言，接口是隐式的，奠基于有效表达式，多态则是通过模板具现化和函数重载解析（function overloading resolution）发生于编译期。</p><p>考虑以下例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">DoProcessing</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>w<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">10</span> <span class="token operator">&amp;&amp;</span> w <span class="token operator">!=</span> someNastyWidget<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码中，<code>T</code>类型的隐式接口要求：</p><ol><li>提供一个名为<code>size</code>的成员函数，该函数的返回值可与<code>int</code>（10 的类型）执行<code>operator&gt;</code>，或经过隐式转换后可执行<code>operator&gt;</code>。</li><li>必须支持一个<code>operator!=</code>函数，接受<code>T</code>类型和<code>someNastyWidget</code>的类型，或其隐式转换后得到的类型。</li></ol><blockquote><p>此处没有考虑<code>operator&amp;&amp;</code>被重载的可能性。</p></blockquote><p>加诸于模板参数身上的隐式接口，就像加诸于类对象身上的显式接口“一样真实”，两者都在编译期完成检查，你无法在模板中使用“不支持模板所要求之隐式接口”的对象（代码无法通过编译）。</p><h3 id="条款-42：了解-typename-的双重含义"><a href="#条款-42：了解-typename-的双重含义" class="headerlink" title="条款 42：了解 typename 的双重含义"></a>条款 42：了解 typename 的双重含义</h3><p>在模板声明式中，使用<code>class</code>和<code>typename</code>关键字并没有什么不同，但在模板内部，<code>typename</code>拥有更多的一重含义。</p><p>为了方便解释，我们首先需要引入一个模板相关的概念：模板内出现的名称如果相依于某个模板参数，我们称之为<strong>从属名称（dependent names）</strong>；如果从属名称在类内呈嵌套状，我们称之为<strong>嵌套从属名称（nested dependent name）</strong>；如果一个名称并不倚赖任何模板参数的名称，我们称之为<strong>非从属名称（non-dependent names）</strong>。</p><p>考虑以下模板代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> C<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">Print2nd</span><span class="token punctuation">(</span><span class="token keyword">const</span> C<span class="token operator">&amp;</span> container<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>container<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        C<span class="token operator">::</span>const_iterator <span class="token function">iter</span><span class="token punctuation">(</span>container<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">++</span>iter<span class="token punctuation">;</span>        <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token operator">*</span>iter<span class="token punctuation">;</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码看起来没有任何问题，但实际编译时却会报错，这一切的罪魁祸首便是<code>C::const_iterator</code>。此处的<code>C::const_iterator</code>是一个指向某类型的<strong>嵌套从属类型名称（nested dependent type name）</strong>，而嵌套从属名称可能会导致解析困难，因为在编译器知道<code>C</code>是什么之前，没有任何办法知道<code>C::const_iterator</code>是否为一个类型，这就导致出现了歧义状态，而 C++ 默认假设嵌套从属名称不是类型名称。</p><p>显式指明嵌套从属类型名称的方法就是将<code>typename</code>关键字作为其前缀词：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">typename</span> C<span class="token operator">::</span>const_iterator <span class="token function">iter</span><span class="token punctuation">(</span>container<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同样地，若嵌套从属名称出现在模板函数声明部分，也需要显式地指明是否为类型名称：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> C<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">Print2nd</span><span class="token punctuation">(</span><span class="token keyword">const</span> C<span class="token operator">&amp;</span> container<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">typename</span> C<span class="token operator">::</span>iterator iter<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这一规则的例外是，<code>typename</code>不可以出现在基类列表内的嵌套从属类型名称之前，也不可以在成员初始化列表中作为基类的修饰符：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>Nested <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 基类列表中不允许使用 typename</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">explicit</span> <span class="token function">Derived</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>        <span class="token operator">:</span> Base<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">Nested</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                 <span class="token comment" spellcheck="true">// 成员初始化列表中不允许使用 typename</span>        <span class="token keyword">typename</span> Base<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>Nested temp<span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在类型名称过于复杂时，可以使用<code>using</code>或<code>typedef</code>来进行简化：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> value_type <span class="token operator">=</span> <span class="token keyword">typename</span> std<span class="token operator">::</span>iterator_traits<span class="token operator">&lt;</span>IterT<span class="token operator">></span><span class="token operator">::</span>value_type<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="条款-43：学习处理模板化基类内的名称"><a href="#条款-43：学习处理模板化基类内的名称" class="headerlink" title="条款 43：学习处理模板化基类内的名称"></a>条款 43：学习处理模板化基类内的名称</h3><p>在模板编程中，模板类的继承并不像普通类那么自然，考虑以下情形：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MsgInfo</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Company<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">MsgSender</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">SendClear</span><span class="token punctuation">(</span><span class="token keyword">const</span> MsgInfo<span class="token operator">&amp;</span> info<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Company<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">LoggingMsgSender</span> <span class="token operator">:</span> <span class="token keyword">public</span> MsgSender<span class="token operator">&lt;</span>Company<span class="token operator">></span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">SendClearMsg</span><span class="token punctuation">(</span><span class="token keyword">const</span> MsgInfo<span class="token operator">&amp;</span> info<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">SendClear</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 调用基类函数，这段代码无法通过编译</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很明显，由于直到模板类被真正实例化之前，编译器并不知道<code>MsgSender&lt;Company&gt;</code>具体长什么样，有可能它是一个全特化的版本，而在这个版本中不存在<code>SendClear</code>函数。由于 C++ 的设计策略是宁愿较早进行诊断，所以编译器会拒绝承认在基类中存在一个<code>SendClear</code>函数。</p><p>为了解决这个问题，我们需要令 C++“进入模板基类观察”的行为生效，有三种办法达成这个目标：</p><p>第一种：在基类函数调用动作之前加上<code>this-&gt;</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">SendClear</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第二种：使用<code>using</code>声明式：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> MsgSender<span class="token operator">&lt;</span>Company<span class="token operator">></span><span class="token operator">::</span>SendClear<span class="token punctuation">;</span><span class="token function">SendClear</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第三种：明白指出被调用的函数位于基类内：</p><pre class="line-numbers language-cpp"><code class="language-cpp">MsgSender<span class="token operator">&lt;</span>Company<span class="token operator">></span><span class="token operator">::</span><span class="token function">SendClear</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第三种做法是最不令人满意的，如果被调用的是虚函数，上述的明确资格修饰（explicit qualification）会使“虚函数绑定行为”失效。</p><h3 id="条款-44：将与参数无关的代码抽离模板"><a href="#条款-44：将与参数无关的代码抽离模板" class="headerlink" title="条款 44：将与参数无关的代码抽离模板"></a>条款 44：将与参数无关的代码抽离模板</h3><p>模板可以节省时间和避免代码重复，编译器会为填入的每个不同模板参数具现化出一份对应的代码，但长此以外，可能会造成代码膨胀（code bloat），生成浮夸的二进制目标码。</p><p>基于<strong>共性和变性分析（commonality and variability analysis）</strong> 的方法，我们需要分析模板中重复使用的部分，将其抽离出模板，以减轻模板具现化带来的代码量。</p><ul><li>因非类型模板参数而造成的代码膨胀，往往可以消除，做法是以函数参数或类成员变量替换模板参数。</li><li>因类型模板参数而造成的代码膨胀，往往可以降低，做法是让带有完全相同二进制表述的具现类型共享实现代码。</li></ul><p>参考以下矩阵类的例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t n<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">SquareMatrix</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">Invert</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>array<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> n <span class="token operator">*</span> n<span class="token operator">></span> data<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改为：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">SquareMatrixBase</span> <span class="token punctuation">{</span><span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">Invert</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t matrixSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>array<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> n <span class="token operator">*</span> n<span class="token operator">></span> data<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t n<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">SquareMatrix</span> <span class="token operator">:</span> <span class="token keyword">private</span> SquareMatrixBase<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// private 继承实现，见条款 39</span>    <span class="token keyword">using</span> SquareMatrixBase<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>Invert<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 避免掩盖基类函数，见条款 33</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">Invert</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">Invert</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>              <span class="token comment" spellcheck="true">// 调用模板基类函数，见条款 43</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Invert</code>并不是我们唯一要使用的矩阵操作函数，而且每次都往基类传递矩阵尺寸显得太过繁琐，我们可以考虑将数据放在派生类中，在基类中储存指针和矩阵尺寸。修改代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">SquareMatrixBase</span> <span class="token punctuation">{</span><span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token function">SquareMatrixBase</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t n<span class="token punctuation">,</span> T<span class="token operator">*</span> pMem<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">size</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">pData</span><span class="token punctuation">(</span>pMem<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">SetDataPtr</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span> pData <span class="token operator">=</span> ptr<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>size_t size<span class="token punctuation">;</span>    T<span class="token operator">*</span> pData<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t n<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">SquareMatrix</span> <span class="token operator">:</span> <span class="token keyword">private</span> SquareMatrixBase<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">SquareMatrix</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> SquareMatrixBase<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> data<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>array<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> n <span class="token operator">*</span> n<span class="token operator">></span> data<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然而这种做法并非永远能取得优势，硬是绑着矩阵尺寸的那个版本，有可能生成比共享版本更佳的代码。例如在尺寸专属版中，尺寸是个编译期常量，因此可以在编译期藉由常量的广传达到最优化；而在共享版本中，不同大小的矩阵只拥有单一版本的函数，可减少可执行文件大小，也就因此降低程序的 working set（在“虚内存环境”下执行的进程所使用的一组内存页），并强化指令高速缓存区内的引用集中化（locality of reference），这些都可能使程序执行得更快速。究竟哪个版本更佳，只能经由具体的测试后决定。</p><p>同样地，上面的代码也使用到了牺牲封装性的<code>protected</code>，可能会导致资源管理上的混乱和复杂，考虑到这些，也许一点点模板代码的重复并非不可接受。</p><h3 id="条款-45：运用成员函数模板接受所有兼容类型"><a href="#条款-45：运用成员函数模板接受所有兼容类型" class="headerlink" title="条款 45：运用成员函数模板接受所有兼容类型"></a>条款 45：运用成员函数模板接受所有兼容类型</h3><p>C++ 视模板类的不同具现体为完全不同的的类型，但在泛型编程中，我们可能需要一个模板类的不同具现体能够相互类型转换。</p><p>考虑设计一个智能指针类，而智能指针需要支持不同类型指针之间的隐式转换（如果可以的话），以及普通指针到智能指针的显式转换。很显然，我们需要的是模板拷贝构造函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">SmartPtr</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> U<span class="token operator">></span>    <span class="token function">SmartPtr</span><span class="token punctuation">(</span><span class="token keyword">const</span> SmartPtr<span class="token operator">&lt;</span>U<span class="token operator">></span><span class="token operator">&amp;</span> other<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">heldPtr</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> U<span class="token operator">></span>    <span class="token keyword">explicit</span> <span class="token function">SmartPtr</span><span class="token punctuation">(</span>U<span class="token operator">*</span> p<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">heldPtr</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>    T<span class="token operator">*</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> heldPtr<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    T<span class="token operator">*</span> heldPtr<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>get</code>获取原始指针，并将在原始指针之间进行类型转换本身提供了一种保障，如果原始指针之间不能隐式转换，那么其对应的智能指针之间的隐式转换会造成编译错误。</p><p>模板构造函数并不会阻止编译器暗自生成默认的构造函数，所以如果你想要控制拷贝构造的方方面面，你必须同时声明泛化拷贝构造函数和普通拷贝构造函数，相同规则也适用于赋值运算符：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">shared_ptr</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">shared_ptr</span><span class="token punctuation">(</span>shared_ptr <span class="token keyword">const</span><span class="token operator">&amp;</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 拷贝构造函数</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Y<span class="token operator">></span>    <span class="token function">shared_ptr</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>Y<span class="token operator">></span> <span class="token keyword">const</span><span class="token operator">&amp;</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 泛化拷贝构造函数</span>    shared_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>shared_ptr <span class="token keyword">const</span><span class="token operator">&amp;</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 拷贝赋值运算符</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Y<span class="token operator">></span>    shared_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>Y<span class="token operator">></span> <span class="token keyword">const</span><span class="token operator">&amp;</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 泛化拷贝赋值运算符</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-46：需要类型转换时请为模板定义非成员函数"><a href="#条款-46：需要类型转换时请为模板定义非成员函数" class="headerlink" title="条款 46：需要类型转换时请为模板定义非成员函数"></a>条款 46：需要类型转换时请为模板定义非成员函数</h3><p>该条款与条款 24 一脉相承，还是使用原先的例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Rational</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Rational</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> numerator <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> denominator <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token function">Numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token function">Denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span><span class="token function">Numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> rhs<span class="token punctuation">.</span><span class="token function">Numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lhs<span class="token punctuation">.</span><span class="token function">Denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> rhs<span class="token punctuation">.</span><span class="token function">Denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Rational<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">oneHalf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Rational<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> result <span class="token operator">=</span> oneHalf <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 无法通过编译！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述失败启示我们：模板实参在推导过程中，从不将隐式类型转换纳入考虑。虽然以<code>oneHalf</code>推导出<code>Rational&lt;int&gt;</code>类型是可行的，但是试图将<code>int</code>类型隐式转换为<code>Rational&lt;T&gt;</code>是绝对会失败的。</p><p>由于模板类并不依赖模板实参推导，所以编译器总能够在<code>Rational&lt;T&gt;</code>具现化时得知<code>T</code>，因此我们可以使用友元声明式在模板类内指涉特定函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Rational</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">friend</span> <span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在模板类内，模板名称可被用来作为“模板及其参数”的简略表达形式，因此下面的写法也是一样的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Rational</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">friend</span> <span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当对象<code>oneHalf</code>被声明为一个<code>Rational&lt;int&gt;</code>时，<code>Rational&lt;int&gt;</code>类于是被具现化出来，而作为过程的一部分，友元函数<code>operator*</code>也就被自动声明出来，其为一个普通函数而非模板函数，因此在接受参数时可以正常执行隐式转换。</p><p>为了使程序能正常链接，我们需要为其提供对应的定义式，最简单有效的方法就是直接合并至声明式处：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">friend</span> <span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">Rational</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span><span class="token function">Numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> rhs<span class="token punctuation">.</span><span class="token function">Numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lhs<span class="token punctuation">.</span><span class="token function">Denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> rhs<span class="token punctuation">.</span><span class="token function">Denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>由于定义在类内的函数都会暗自成为内联函数，为了降低内联带来的冲击，可以使<code>operator*</code>调用类外的辅助模板函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Rational</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">DoMultiply</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span><span class="token function">Numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> rhs<span class="token punctuation">.</span><span class="token function">Numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lhs<span class="token punctuation">.</span><span class="token function">Denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> rhs<span class="token punctuation">.</span><span class="token function">Denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Rational</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">friend</span> <span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">DoMultiply</span><span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-47：请使用-traits-classes-表现类型信息"><a href="#条款-47：请使用-traits-classes-表现类型信息" class="headerlink" title="条款 47：请使用 traits classes 表现类型信息"></a>条款 47：请使用 traits classes 表现类型信息</h3><p>traits classes 可以使我们在编译期就能获取某些类型信息，它被广泛运用于 C++ 标准库中。traits 并不是 C++ 关键字或一个预先定义好的构件：它们是一种技术，也是 C++ 程序员所共同遵守的协议，并要求对用户自定义类型和内置类型表现得一样好。</p><p>设计并实现一个 trait class 的步骤如下：</p><ol><li>确认若干你希望将来可取得的类型相关信息。</li><li>为该类型选择一个名称。</li><li>提供一个模板和一组特化版本，内含你希望支持的类型相关信息。</li></ol><p>以迭代器为例，标准库中拥有多种不同的迭代器种类，它们各自拥有不同的功用和限制：</p><ol><li><code>input_iterator_tag</code>：单向输入迭代器，只能向前移动，一次一步，客户只可读取它所指的东西。</li><li><code>output_iterator_tag</code>：单向输出迭代器，只能向前移动，一次一步，客户只可写入它所指的东西。</li><li><code>forward_iterator_tag</code>：单向访问迭代器，只能向前移动，一次一步，读写均允许。</li><li><code>bidirectional_iterator_tag</code>：双向访问迭代器，去除了只能向前移动的限制。</li><li><code>random_access_iterator_tag</code>：随机访问迭代器，没有一次一步的限制，允许随意移动，可以执行“迭代器算术”。</li></ol><p>标准库为这些迭代器种类提供的卷标结构体（tag struct）的继承关系如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> input_iterator_tag <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> output_iterator_tag <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> forward_iterator_tag <span class="token operator">:</span> input_iterator_tag <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> bidirectional_iterator_tag <span class="token operator">:</span> forward_iterator_tag <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> random_access_iterator_tag <span class="token operator">:</span> bidirectional_iterator_tag <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将<code>iterator_category</code>作为迭代器种类的名称，嵌入容器的迭代器中，并且确认使用适当的卷标结构体：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">deque</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">class</span> <span class="token class-name">iterator</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token keyword">using</span> iterator_category <span class="token operator">=</span> random_access_iterator<span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">list</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">class</span> <span class="token class-name">iterator</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token keyword">using</span> iterator_category <span class="token operator">=</span> bidirectional_iterator<span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了做到类型的 traits 信息可以在类型自身之外获得，标准技术是把它放进一个模板及其一个或多个特化版本中。这样的模板在标准库中有若干个，其中针对迭代器的是<code>iterator_traits</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">IterT</span><span class="token operator">></span><span class="token keyword">struct</span> iterator_traits <span class="token punctuation">{</span>    <span class="token keyword">using</span> iterator_category <span class="token operator">=</span> IterT<span class="token operator">::</span>iterator_category<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了支持指针迭代器，<code>iterator_traits</code>特别针对指针类型提供一个偏特化版本，而指针的类型和随机访问迭代器类似，所以可以写出如下代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">IterT</span><span class="token operator">></span><span class="token keyword">struct</span> iterator_traits<span class="token operator">&lt;</span>IterT<span class="token operator">*</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">using</span> iterator_category <span class="token operator">=</span> random_access_iterator_tag<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当我们需要为不同的迭代器种类应用不同的代码时，traits classes 就派上用场了：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> IterT<span class="token punctuation">,</span> <span class="token keyword">typename</span> DisT<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">advance</span><span class="token punctuation">(</span>IterT<span class="token operator">&amp;</span> iter<span class="token punctuation">,</span> DisT d<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeid</span><span class="token punctuation">(</span>std<span class="token operator">::</span>iterator_traits<span class="token operator">&lt;</span>IterT<span class="token operator">></span><span class="token operator">::</span>iterator_category<span class="token punctuation">)</span>        <span class="token operator">==</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>std<span class="token operator">::</span>random_access_iterator_tag<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但这些代码实际上是错误的，我们希望类型的判断能在编译期完成。<code>iterator_category</code>是在编译期决定的，然而<code>if</code>却是在运行期运作的，无法达成我们的目标。</p><p>在 C++17 之前，解决这个问题的主流做法是利用函数重载（也是原书中介绍的做法）：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> IterT<span class="token punctuation">,</span> <span class="token keyword">typename</span> DisT<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">doAdvance</span><span class="token punctuation">(</span>IterT<span class="token operator">&amp;</span> iter<span class="token punctuation">,</span> DisT d<span class="token punctuation">,</span> std<span class="token operator">::</span>random_access_iterator_tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>   <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> IterT<span class="token punctuation">,</span> <span class="token keyword">typename</span> DisT<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">doAdvance</span><span class="token punctuation">(</span>IterT<span class="token operator">&amp;</span> iter<span class="token punctuation">,</span> DisT d<span class="token punctuation">,</span> std<span class="token operator">::</span>bidirectional_iterator_tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> IterT<span class="token punctuation">,</span> <span class="token keyword">typename</span> DisT<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">doAdvance</span><span class="token punctuation">(</span>IterT<span class="token operator">&amp;</span> iter<span class="token punctuation">,</span> DisT d<span class="token punctuation">,</span> std<span class="token operator">::</span>input_iterator_tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>d <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">out_of_range</span><span class="token punctuation">(</span><span class="token string">"Negative distance"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 单向迭代器不允许负距离</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> IterT<span class="token punctuation">,</span> <span class="token keyword">typename</span> DisT<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">advance</span><span class="token punctuation">(</span>IterT<span class="token operator">&amp;</span> iter<span class="token punctuation">,</span> DisT d<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">doAdvance</span><span class="token punctuation">(</span>iter<span class="token punctuation">,</span> d<span class="token punctuation">,</span> std<span class="token operator">::</span>iterator_traits<span class="token operator">&lt;</span>IterT<span class="token operator">></span><span class="token operator">::</span><span class="token function">iterator_category</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 C++17 之后，我们有了更简单有效的做法——使用<code>if constexpr</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> IterT<span class="token punctuation">,</span> <span class="token keyword">typename</span> DisT<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">Advance</span><span class="token punctuation">(</span>IterT<span class="token operator">&amp;</span> iter<span class="token punctuation">,</span> DisT d<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span><span class="token keyword">typeid</span><span class="token punctuation">(</span>std<span class="token operator">::</span>iterator_traits<span class="token operator">&lt;</span>IterT<span class="token operator">></span><span class="token operator">::</span>iterator_category<span class="token punctuation">)</span>        <span class="token operator">==</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>std<span class="token operator">::</span>random_access_iterator_tag<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-48：认识模板元编程"><a href="#条款-48：认识模板元编程" class="headerlink" title="条款 48：认识模板元编程"></a>条款 48：认识模板元编程</h3><p>模板元编程（Template metaprogramming，TMP）是编写基于模板的 C++ 程序并执行于编译期的过程，它并不是刻意被设计出来的，而是当初 C++ 引入模板带来的副产品，事实证明模板元编程具有强大的作用，并且现在已经成为 C++ 标准的一部分。实际上，在条款 47 中编写 traits classes 时，我们就已经在进行模板元编程了。</p><p>由于模板元程序执行于 C++ 编译期，因此可以将一些工作从运行期转移至编译期，这可以帮助我们在编译期时发现一些原本要在运行期时才能察觉的错误，以及得到较小的可执行文件、较短的运行期、较少的内存需求。当然，副作用就是会使编译时间变长。</p><p>模板元编程已被证明是“图灵完备”的，并且以“函数式语言”的形式发挥作用，因此在模板元编程中没有真正意义上的循环，所有循环效果只能藉由递归实现，而递归在模板元编程中是由 <strong>“递归模板具现化（recursive template instantiation）”</strong> 实现的。</p><p>常用于引入模板元编程的例子是在编译期计算阶乘：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">unsigned</span> n<span class="token operator">></span>            <span class="token comment" spellcheck="true">// Factorial&lt;n> = n * Factorial&lt;n-1></span><span class="token keyword">struct</span> Factorial <span class="token punctuation">{</span>    <span class="token keyword">enum</span> <span class="token punctuation">{</span> value <span class="token operator">=</span> n <span class="token operator">*</span> Factorial<span class="token operator">&lt;</span>n<span class="token number">-1</span><span class="token operator">></span><span class="token operator">::</span>value <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">struct</span> Factorial<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">></span> <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">// 处理特殊情况：Factorial&lt;0> = 1</span>    <span class="token keyword">enum</span> <span class="token punctuation">{</span> value <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> Factorial<span class="token operator">&lt;</span><span class="token number">5</span><span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>模板元编程很酷，但对其进行调试可能是灾难性的，因此在实际应用中并不常见。我们可能会在下面几种情形中见到它的出场：</p><ol><li>确保量度单位正确。</li><li>优化矩阵计算。</li><li>可以生成客户定制之设计模式（custom design pattern）实现品。</li></ol><h2 id="第八章：定制-new-和-delete"><a href="#第八章：定制-new-和-delete" class="headerlink" title="第八章：定制 new 和 delete"></a>第八章：定制 new 和 delete</h2><h3 id="条款-49：了解-new-handler-的行为"><a href="#条款-49：了解-new-handler-的行为" class="headerlink" title="条款 49：了解 new-handler 的行为"></a>条款 49：了解 new-handler 的行为</h3><p>当<code>operator new</code>无法满足某一内存分配需求时，会不断调用一个客户指定的错误处理函数，即所谓的 <strong>new-handler</strong>，直到找到足够内存为止，调用声明于<code>&lt;new&gt;</code>中的<code>set_new_handler</code>可以指定这个函数。<code>new_handler</code>和<code>set_new_handler</code>的定义如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">namespace</span> std <span class="token punctuation">{</span>    <span class="token keyword">using</span> new_handler <span class="token operator">=</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    new_handler <span class="token function">set_new_handler</span><span class="token punctuation">(</span>new_handler<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 返回值为原来持有的 new-handler</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>一个设计良好的 new-handler 函数必须做以下事情之一：</p><p><strong>让更多的内存可被使用：</strong> 可以让程序一开始执行就分配一大块内存，而后当 new-handler 第一次被调用，将它们释还给程序使用，造成<code>operator new</code>的下一次内存分配动作可能成功。</p><p><strong>安装另一个 new-handler：</strong> 如果目前这个 new-handler 无法取得更多内存，可以调换为另一个可以完成目标的 new-handler（令 new-handler 修改“会影响 new-handler 行为”的静态或全局数据）。</p><p><strong>卸除 new-handler：</strong> 将<code>nullptr</code>传给<code>set_new_handler</code>，这样会使<code>operator new</code>在内存分配不成功时抛出异常。</p><p><strong>抛出 bad_alloc（或派生自 bad_alloc）的异常：</strong> 这样的异常不会被<code>operator new</code>捕捉，因此会被传播到内存分配处。</p><p><strong>不返回：</strong> 通常调用<code>std::abort</code>或<code>std::exit</code>。</p><p>有的时候我们或许会希望在为不同的类分配对象时，使用不同的方式处理内存分配失败情况。这时候使用静态成员是不错的选择：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> std<span class="token operator">::</span>new_handler <span class="token function">set_new_handler</span><span class="token punctuation">(</span>std<span class="token operator">::</span>new_handler p<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">static</span> std<span class="token operator">::</span>new_handler currentHandler<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 做和 std::set_new_handler 相同的事情</span>std<span class="token operator">::</span>new_handler Widget<span class="token operator">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>std<span class="token operator">::</span>new_handler p<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>new_handler oldHandler <span class="token operator">=</span> currentHandler<span class="token punctuation">;</span>    currentHandler <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token keyword">return</span> oldHandler<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">void</span><span class="token operator">*</span> Widget<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> globalHandler <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>currentHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 切换至 Widget 的专属 new-handler</span>    <span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>                           <span class="token comment" spellcheck="true">// 分配内存或抛出异常</span>    std<span class="token operator">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>globalHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 切换回全局的 new-handler</span>    <span class="token keyword">return</span> globalHandler<span class="token punctuation">;</span><span class="token punctuation">}</span>std<span class="token operator">::</span>new_handler Widget<span class="token operator">::</span>currentHandler <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Widget</code>的客户应该类似这样使用其 new-handling：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">OutOfMem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Widget<span class="token operator">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>OutOfMem<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> pw1 <span class="token operator">=</span> <span class="token keyword">new</span> Widget<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 若分配失败，则调用 OutOfMem</span>Widget<span class="token operator">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> pw2 <span class="token operator">=</span> <span class="token keyword">new</span> Widget<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 若分配失败，则抛出异常</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现这一方案的代码并不因类的不同而不同，因此对这些代码加以复用是合理的构想。一个简单的做法是建立起一个“mixin”风格的基类，让其派生类继承它们所需的<code>set_new_handler</code>和<code>operator new</code>，并且使用模板确保每一个派生类获得一个实体互异的<code>currentHandler</code>成员变量：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">NewHandlerSupport</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// “mixin”风格的基类</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> std<span class="token operator">::</span>new_handler <span class="token function">set_new_handler</span><span class="token punctuation">(</span>std<span class="token operator">::</span>new_handler p<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                         <span class="token comment" spellcheck="true">// 其它的 operator new 版本，见条款 52</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">static</span> std<span class="token operator">::</span>new_handler currentHandler<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>std<span class="token operator">::</span>new_handler NewHandlerSupport<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>std<span class="token operator">::</span>new_handler p<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>new_handler oldHandler <span class="token operator">=</span> currentHandler<span class="token punctuation">;</span>    currentHandler <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token keyword">return</span> oldHandler<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span><span class="token operator">*</span> NewHandlerSupport<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> globalHandler <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>currentHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>globalHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> globalHandler<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>std<span class="token operator">::</span>new_handler NewHandlerSupport<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>currentHandler <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token operator">:</span> <span class="token keyword">public</span> NewHandlerSupport<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                         <span class="token comment" spellcheck="true">// 不必再声明 set_new_handler 和 operator new</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意此处的模板参数<code>T</code>并没有真正被当成类型使用，而仅仅是用来区分不同的派生类，使得模板机制为每个派生类具现化出一份对应的<code>currentHandler</code>。</p><p>这个做法用到了所谓的 <strong>CRTP（curious recurring template pattern，奇异递归模板模式）</strong> ，除了在上述设计模式中用到之外，它也被用于实现<strong>静态多态</strong>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Derived</span><span class="token operator">></span> <span class="token keyword">struct</span> Base <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">Interface</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Derived<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">Implementation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 在基类中暴露接口</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> Derived <span class="token operator">:</span> Base<span class="token operator">&lt;</span>Derived<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">Implementation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                  <span class="token comment" spellcheck="true">// 在派生类中提供实现</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了会调用 new-handler 的<code>operator new</code>以外，C++ 还保留了传统的“分配失败便返回空指针”的<code>operator new</code>，称为 nothrow new，通过<code>std::nothrow</code>对象来使用它：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget<span class="token operator">*</span> pw1 <span class="token operator">=</span> <span class="token keyword">new</span> Widget<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 如果分配失败，抛出 bad_alloc</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pw1 <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                     <span class="token comment" spellcheck="true">// 这个测试一定失败</span>Widget<span class="token operator">*</span> pw2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>nothrow<span class="token punctuation">)</span> Widget<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果分配失败，返回空指针</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pw2 <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                     <span class="token comment" spellcheck="true">// 这个测试可能成功</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>nothrow new 对异常的强制保证性并不高，使用它只能保证<code>operator new</code>不抛出异常，而无法保证像<code>new (std::nothrow) Widget</code>这样的表达式不会导致异常，因此实际上并没有使用 nothrow new 的必要。</p><h3 id="条款-50：了解-new-和-delete-的合理替换时机"><a href="#条款-50：了解-new-和-delete-的合理替换时机" class="headerlink" title="条款 50：了解 new 和 delete 的合理替换时机"></a>条款 50：了解 new 和 delete 的合理替换时机</h3><p>以下是常见的替换默认<code>operator new</code>和<code>operator delete</code>的理由：</p><p><strong>用来检测运用上的错误：</strong> 如果将“new 所得内存”delete 掉却不幸失败，会导致内存泄漏；如果在“new 所得内存”身上多次 delete 则会导致未定义行为。如果令<code>operator new</code>持有一串动态分配所得地址，而<code>operator delete</code>将地址从中移除，就很容易检测出上述错误用法。此外各式各样的编程错误可能导致 <strong>“overruns”（写入点在分配区块尾端之后）</strong> 和 <strong>“underruns”（写入点在分配区块起点之前）</strong>，以额外空间放置特定的 byte pattern 签名，检查签名是否原封不动就可以检测此类错误，下面给出了一个这样的范例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> signature <span class="token operator">=</span> <span class="token number">0xDEADBEEF</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 调试“魔数”</span><span class="token keyword">using</span> Byte <span class="token operator">=</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>    size_t realSize <span class="token operator">=</span> size <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 分配额外空间以塞入两个签名</span>    <span class="token keyword">void</span><span class="token operator">*</span> pMem <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>realSize<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 调用 malloc 取得内存</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pMem<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token function">bad_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将签名写入内存的起点和尾端</span>    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>pMem<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> signature<span class="token punctuation">;</span>    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Byte<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>pMem<span class="token punctuation">)</span> <span class="token operator">+</span> realSize <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> signature<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Byte<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>pMem<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 返回指针指向第一个签名后的内存位置</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上这段代码不能保证内存对齐，并且有许多地方不遵守 C++ 规范，我们将在条款 51 中进行详细讨论。</p><p><strong>为了收集使用上的统计数据：</strong> 定制 new 和 delete 动态内存的相关信息：分配区块的大小分布，寿命分布，FIFO（先进先出）、LIFO（后进先出）或随机次序的倾向性，不同的分配/归还形态，使用的最大动态分配量等等。</p><p><strong>为了增加分配和归还的速度：</strong> 泛用型分配器往往（虽然并非总是）比定制型分配器慢，特别是当定制型分配器专门针对某特定类型之对象设计时。类专属的分配器可以做到“区块尺寸固定”，例如 Boost 提供的 Pool 程序库。又例如，编译器所带的内存管理器是线程安全的，但如果你的程序是单线程的，你也可以考虑写一个不线程安全的分配器来提高速度。当然，这需要你对程序进行分析，并确认程序瓶颈的确发生在那些内存函数身上。</p><p><strong>为了降低缺省内存管理器带来的空间额外开销：</strong> 泛用型分配器往往（虽然并非总是）还比定制型分配器使用更多内存，那是因为它们常常在每一个分配区块身上招引某些额外开销。针对小型对象而开发的分配器（例如 Boost 的 Pool 程序库）本质上消除了这样的额外开销。</p><p><strong>为了弥补缺省分配器中的非最佳内存对齐（suboptimal alignment）：</strong> 许多计算机体系架构要求特定的类型必须放在特定的内存地址上，如果没有奉行这个约束条件，可能导致运行期硬件异常，或者访问速度变低。<code>std::max_align_t</code>用来返回当前平台的最大默认内存对齐类型，对于<code>malloc</code>分配的内存，其对齐和<code>max_align_t</code>类型的对齐大小应当是一致的，但若对<code>malloc</code>返回的指针进行偏移，就没有办法保证内存对齐。</p><p>在 C++11 中，提供了以下内存对齐相关方法：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// alignas 用于指定栈上数据的内存对齐要求</span><span class="token keyword">struct</span> <span class="token keyword">alignas</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> testStruct <span class="token punctuation">{</span> <span class="token keyword">double</span> data<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// alignof 和 std::alignment_of 用于得到给定类型的内存对齐要求</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">alignof</span><span class="token punctuation">(</span>std<span class="token operator">::</span>max_align_t<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>alignment_of<span class="token operator">&lt;</span>std<span class="token operator">::</span>max_align_t<span class="token operator">></span><span class="token operator">::</span>value <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// std::align 用于在一大块内存中获取一个符合指定内存要求的地址</span><span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"memory alignment"</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> buffer<span class="token punctuation">;</span>std<span class="token operator">::</span>size_t space <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>std<span class="token operator">::</span><span class="token function">align</span><span class="token punctuation">(</span><span class="token keyword">alignof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ptr<span class="token punctuation">,</span> space<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 C++17 后，可以使用<code>std::align_val_t</code>来重载需求额外内存对齐的<code>operator new</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t count<span class="token punctuation">,</span> std<span class="token operator">::</span>align_val_t al<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>为了将相关对象成簇集中：</strong> 如果你知道特定的某个数据结构往往被一起使用，而你又希望在处理这些数据时将“内存页错误（page faults）”的频率降至最低，那么可以考虑为此数据结构创建一个堆，将它们成簇集中在尽可能少的内存页上。一般可以使用 placement new 达成这个目标（见条款 52）。</p><p><strong>为了获得非传统的行为：</strong> 有时候你会希望<code>operator new</code>和<code>operator delete</code>做编译器版不会做的事情，例如分配和归还共享内存（shared memory），而这些事情只能被 C API 完成，则可以将 C API 封在 C++ 的外壳里，写在定制的 new 和 delete 中。</p><h3 id="条款-51：编写-new-和-delete-时需固守常规"><a href="#条款-51：编写-new-和-delete-时需固守常规" class="headerlink" title="条款 51：编写 new 和 delete 时需固守常规"></a>条款 51：编写 new 和 delete 时需固守常规</h3><p>我们在条款 49 中已经提到过一些<code>operator new</code>的规矩，比如内存不足时必须不断调用 new-handler，如果无法供应客户申请的内存，就抛出<code>std::bad_alloc</code>异常。C++ 还有一个奇怪的规定，即使客户需求为0字节，<code>operator new</code>也得返回一个合法的指针，这种看似诡异的行为其实是为了简化语言其他部分。</p><p>根据这些规约，我们可以写出非成员函数版本的<code>operator new</code>代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// 处理0字节申请</span>        size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 将其视为1字节申请</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 如果分配成功</span>            <span class="token keyword">return</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回指针指向分配得到的内存</span>        <span class="token comment" spellcheck="true">// 如果分配失败，调用目前的 new-handler</span>        <span class="token keyword">auto</span> globalHandler <span class="token operator">=</span> <span class="token function">get_new_handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// since C++11</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>globalHandler<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>globalHandler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">bad_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>operator new</code>的成员函数版本一般只会分配大小刚好为类的大小的内存空间，但是情况并不总是如此，比如假设我们没有为派生类声明其自己的<code>operator new</code>，那么派生类会从基类继承<code>operator new</code>，这就导致派生类可以使用其基类的 new 分配方式，但派生类和基类的大小很多时候是不同的。</p><p>处理此情况的最佳做法是将“内存申请量错误”的调用行为改为采用标准的<code>operator new</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> Base<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">!=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Base<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 转交给标准的 operator new 进行处理</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意在<code>operator new</code>的成员函数版本中我们也不需要检测分配的大小是否为0了，因为在条款 39 中我们提到过，非附属对象必须有非零大小，所以<code>sizeof(Base)</code>无论如何也不能为0。</p><p>如果你打算实现<code>operator new[]</code>，即所谓的 array new，那么你唯一要做的一件事就是分配一块未加工的原始内存，因为你无法对 array 之内迄今尚未存在的元素对象做任何事情，实际上你甚至无法计算这个 array 将含有多少元素对象。</p><p><code>operator delete</code>的规约更加简单，你需要记住的唯一一件事情就是 C++ 保证 <strong>“删除空指针永远安全”</strong>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> rawMemory<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>rawMemory <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 归还 rawMemory 所指的内存</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>operator delete</code>的成员函数版本要多做的唯一一件事就是将大小有误的删除行为转交给标准的<code>operator delete</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> Base<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> rawMemory<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t size<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>rawMemory <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">!=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Base<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span>rawMemory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 转交给标准的 operator delete 进行处理</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 归还 rawMemory 所指的内存</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果即将被删除的对象派生自某个基类而后者缺少虚析构函数，那么 C++ 传给<code>operator delete</code>的<code>size</code>大小可能不正确，这或许是“为多态基类声明虚析构函数”的一个足够的理由，能作为对条款 7 的补充。</p><h3 id="条款-52：写了-placement-new-也要写-placement-delete"><a href="#条款-52：写了-placement-new-也要写-placement-delete" class="headerlink" title="条款 52：写了 placement new 也要写 placement delete"></a>条款 52：写了 placement new 也要写 placement delete</h3><p>placement new 最初的含义指的是“接受一个指针指向对象该被构造之处”的<code>operator new</code>版本，它在标准库中的用途广泛，其中之一是负责在 vector 的未使用空间上创建对象，它的声明如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> pMemory<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们此处要讨论的是广义上的 placement new，即带有附加参数的<code>operator new</code>，例如下面这种：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t<span class="token punctuation">,</span> std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span> logStream<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> pw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>cerr<span class="token punctuation">)</span> Widget<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当我们在使用 new 表达式创建对象时，共有两个函数被调用：一个是用以分配内存的<code>operator new</code>，一个是对象的构造函数。假设第一个函数调用成功，而第二个函数却抛出异常，那么会由 C++ runtime 调用<code>operator delete</code>，归还已经分配好的内存。</p><p>这一切的前提是 C++ runtime 能够找到<code>operator new</code>对应的<code>operator delete</code>，如果我们使用的是自定义的 placement new，而没有为其准备对应的 placement delete 的话，就无法避免发生内存泄漏。因此，合格的代码应该是这样的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">,</span> std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span> logStream<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// placement new</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> pMemory<span class="token punctuation">)</span><span class="token punctuation">;</span>                             <span class="token comment" spellcheck="true">// delete 时调用的正常 operator delete</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> pMemory<span class="token punctuation">,</span> std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span> logStream<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// placement delete</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一个要注意的问题是，由于成员函数的名称会掩盖其外部作用域中的相同名称（见条款 33），所以提供 placement new 会导致无法使用正常版本的<code>operator new</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">,</span> std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span> logStream<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">auto</span> pb <span class="token operator">=</span> <span class="token keyword">new</span> Base<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 无法通过编译！</span><span class="token keyword">auto</span> pb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>cerr<span class="token punctuation">)</span> Base<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正确</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样道理，派生类中的<code>operator new</code>会掩盖全局版本和继承而得的<code>operator new</code>版本：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">auto</span> pd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>clog<span class="token punctuation">)</span> Derived<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 无法通过编译！</span><span class="token keyword">auto</span> pd <span class="token operator">=</span> <span class="token keyword">new</span> Derived<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 正确</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了避免名称遮掩问题，需要确保以下形式的<code>operator new</code>对于定制类型仍然可用，除非你的意图就是阻止客户使用它们：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span>std<span class="token operator">::</span>bad_alloc<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// normal new</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// placement new</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>nothrow_t<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// nothrow new</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一个最简单的实现方式是，准备一个基类，内含所有正常形式的 new 和 delete：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">StadardNewDeleteForms</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">// normal new/delete</span>    <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> pMemory<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>        <span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span>pMemory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// placement new/delete</span>    <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> pMemory<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>        <span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span>pMemory<span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// nothrow new/delete</span>    <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>nothrow_t<span class="token operator">&amp;</span> nt<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span>nt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> pMemory<span class="token punctuation">,</span><span class="token keyword">const</span> std<span class="token operator">::</span>nothrow_t<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>        <span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span>pMemory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>凡是想以自定义形式扩充标准形式的客户，可以利用继承和<code>using</code>声明式（见条款 33）取得标准形式：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span><span class="token operator">:</span> <span class="token keyword">public</span> StandardNewDeleteForms<span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> StandardNewDeleteForms<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">;</span>    <span class="token keyword">using</span> StandardNewDeleteForms<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">,</span> std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span> logStream<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token function">detele</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">,</span> std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span> logStream<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第九章：杂项讨论"><a href="#第九章：杂项讨论" class="headerlink" title="第九章：杂项讨论"></a>第九章：杂项讨论</h2><h3 id="条款-53：不要轻忽编译器的警告"><a href="#条款-53：不要轻忽编译器的警告" class="headerlink" title="条款 53：不要轻忽编译器的警告"></a>条款 53：不要轻忽编译器的警告</h3><ol><li>严肃对待编译器发出的警告信息。努力在你的编译器的最高（最严苛）警告级别下争取“无任何警告”的荣誉。</li><li>不要过度依赖编译器的警告能力，因为不同的编译器对待事情的态度不同。一旦移植到另一个编译器上，你原本依赖的警告信息可能会消失。</li></ol><h3 id="条款-54：让自己熟悉包括-TR1-在内的标准程序库"><a href="#条款-54：让自己熟悉包括-TR1-在内的标准程序库" class="headerlink" title="条款 54：让自己熟悉包括 TR1 在内的标准程序库"></a>条款 54：让自己熟悉包括 TR1 在内的标准程序库</h3><p>如今 TR1 草案已完全融入 C++ 标准当中，没有再过多了解 TR1 标准库的必要。</p><h3 id="条款-55：让自己熟悉-Boost"><a href="#条款-55：让自己熟悉-Boost" class="headerlink" title="条款 55：让自己熟悉 Boost"></a>条款 55：让自己熟悉 Boost</h3><p>Boost 是若干个程序库的集合，并且当中的许多库已经被 C++ 吸纳为标准库的一部分。不过在现在的 Modern C++ 时代，是否该在项目中使用 Boost 仍然有一定的争议，一些 Boost 组件并无法做到像 C++ 标准库那样高性能，零开销抽象，但毫无疑问的是，Boost 的参考价值是无法忽视的，你可以在 Boost 中找到许多非常值得学习和借鉴的实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一章：让自己习惯-C&quot;&gt;&lt;a href=&quot;#第一章：让自己习惯-C&quot; class=&quot;headerlink&quot; title=&quot;第一章：让自己习惯 C++&quot;&gt;&lt;/a&gt;第一章：让自己习惯 C++&lt;/h2&gt;&lt;h3 id=&quot;条款-1：视-C-为一个语言联邦&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://JoyTsing.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="读书笔记" scheme="https://JoyTsing.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Cpp中RAII和智能指针</title>
    <link href="https://joytsing.github.io/posts/57427/"/>
    <id>https://joytsing.github.io/posts/57427/</id>
    <published>2023-12-14T07:39:36.000Z</published>
    <updated>2024-03-15T08:01:09.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概-述"><a href="#概-述" class="headerlink" title="概 述"></a>概 述</h2><h3 id="RAII-Resource-Acquisition-Is-Initialization"><a href="#RAII-Resource-Acquisition-Is-Initialization" class="headerlink" title="RAII (Resource Acquisition Is Initialization)"></a><strong>RAII (Resource Acquisition Is Initialization)</strong></h3><p>RAII 要求，资源的有效期与持有资源的对象的生命期严格绑定，即由对象的构造函数完成资源的分配（获取），同时由析构函数，完成资源的释放。在这种要求下，只要对象能正确地析构，就不会出现资源泄露问题。</p><h3 id="C-三-五法则"><a href="#C-三-五法则" class="headerlink" title="C++三/五法则"></a><strong>C++三/五法则</strong></h3><ul><li>当定义一个类时，我们显式地或隐式地指定了此类型的对象在拷贝、赋值和销毁时做什么。一个类通过定义三种特殊的成员函数来控制这些操作，分别是拷贝构造函数、赋值运算符和析构函数。</li><li><strong>拷贝构造函数，定义了当用同类型的另一个对象初始化新对象时做什么；赋值运算符，定义了将一个对象赋予同类型的另一个对象时做什么；析构函数，定义了此类型的对象销毁时做什么。我们将这些操作称为拷贝控制操作</strong>。</li><li>由于拷贝控制操作是由三个特殊的成员函数来完成的，所以我们称此为“C++三法则”。在较新的C++11标准中，为了支持移动语义，又增加了<strong>移动构造函数</strong>和<strong>移动赋值运算符</strong>，这样共有五个特殊的成员函数，所以又称为“C++五法则”。也就是说，“三法则”是针对较旧的C++98 标准说的，“五法则” 是针对较新的C++11标准说的。为了统一称呼，后来人们干把它叫做“C++ 三/五法则”。</li></ul><p>RAII ， 如果没有解构函数，在每个带有返回的分支，都要手动释放所有之前的资源；与Java Python 等自动垃圾回收语言不同（由gc延时回收），C++结构函数是显示的，当进程离开了函数作用域自动销毁之前的资源，不含糊。这样做，有好处也有坏处，对于高性能计算，利大于弊。</p><h3 id="RAII，异常安全（exception-safe）"><a href="#RAII，异常安全（exception-safe）" class="headerlink" title="RAII，异常安全（exception-safe）"></a>RAII，异常安全（exception-safe）</h3><p>C++ 标准保证了当异常发生时，会调用已创建对象的解构函数，因此 C++中不需要 finally 语句。</p><pre class="line-numbers language-java"><code class="language-java">connection c <span class="token operator">=</span> driver<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>   c<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比如Java语句，需要在 finally 里显示 close资源，而 C++可以在 catch异常同时，自动释放资源。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>ofstream <span class="token function">fout</span><span class="token punctuation">(</span><span class="token string">"a.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    fout <span class="token operator">&lt;&lt;</span> <span class="token string">"in\n"</span><span class="token punctuation">;</span>    <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    fout <span class="token operator">&lt;&lt;</span> <span class="token string">"out\n"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>exception <span class="token keyword">const</span> <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"catch"</span> <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="编译器自动生成的函数：全家桶"><a href="#编译器自动生成的函数：全家桶" class="headerlink" title="编译器自动生成的函数：全家桶"></a><strong>编译器自动生成的函数：全家桶</strong></h2><p>除了 <strong>拷贝构造</strong>和 <strong>拷贝赋值</strong>，编译器会自动生成特殊函数。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> C <span class="token punctuation">{</span>    <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 默认构造函数</span>    <span class="token function">C</span><span class="token punctuation">(</span>C <span class="token keyword">const</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 拷贝构造函数</span>    <span class="token function">C</span><span class="token punctuation">(</span>C <span class="token operator">&amp;&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 移动构造函数 (C++11 引入)</span>    C <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>C <span class="token keyword">const</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 拷贝赋值函数</span>    C <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>C <span class="token operator">&amp;&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 移动赋值函数 (C++11 引入)</span>    <span class="token operator">~</span><span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 解构函数</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在其他面向对象语言中是看不到这些底层的函数。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">Pig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 拷贝构造</span><span class="token function">Pig</span><span class="token punctuation">(</span>Pig <span class="token keyword">const</span> <span class="token operator">&amp;</span>other<span class="token punctuation">)</span>    <span class="token operator">:</span> <span class="token function">m_name</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>m_name<span class="token punctuation">)</span>    <span class="token punctuation">,</span> <span class="token function">m_weight</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>m_weight<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 移动构造</span><span class="token function">Pig</span><span class="token punctuation">(</span>Pig <span class="token operator">&amp;&amp;</span>other<span class="token punctuation">)</span>    <span class="token operator">:</span> <span class="token function">m_name</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>m_name<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">,</span> <span class="token function">m_weight</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>m_weight<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 拷贝赋值</span>Pig <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Pig <span class="token keyword">const</span> <span class="token operator">&amp;</span>other<span class="token punctuation">)</span> <span class="token punctuation">{</span>    m_name <span class="token operator">=</span> other<span class="token punctuation">.</span>m_name<span class="token punctuation">;</span>    m_weight <span class="token operator">=</span> other<span class="token punctuation">.</span>m_weight<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 移动赋值</span>Pig <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Pig <span class="token operator">&amp;&amp;</span>other<span class="token punctuation">)</span> <span class="token punctuation">{</span>    m_name <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>m_name<span class="token punctuation">)</span><span class="token punctuation">;</span>    m_weight <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>m_weight<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">~</span><span class="token function">Pig</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++规定，除了智能指针，都是用深拷贝。以上这些函数都是编译器默认生成的。</p><h3 id="三五法则深入理解"><a href="#三五法则深入理解" class="headerlink" title="三五法则深入理解"></a>三五法则深入理解</h3><p><img src="https://pic4.zhimg.com/v2-666b134737e695bee046025df65e381b_r.jpg" alt></p><p>从一个例子出发。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">struct</span> Vector <span class="token punctuation">{</span>    size_t m_size<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>m_data<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//    Vector(size_t n) {    // 构造函数 - 对象初始化时调用</span><span class="token comment" spellcheck="true">//        m_size = n;</span><span class="token comment" spellcheck="true">//        m_data = (int *)malloc(n * sizeof(int));</span><span class="token comment" spellcheck="true">//    }</span>    <span class="token function">Vector</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">)</span>      <span class="token operator">:</span> <span class="token function">m_size</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_data</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>n <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">Vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">// 解构函数 - 对象销毁时调用</span>        <span class="token function">free</span><span class="token punctuation">(</span>m_data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>       size_t <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> m_size<span class="token punctuation">;</span>    <span class="token punctuation">}</span>       <span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>        m_size <span class="token operator">=</span> size<span class="token punctuation">;</span>        m_data <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">realloc</span><span class="token punctuation">(</span>m_data<span class="token punctuation">,</span> m_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>       <span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>size_t index<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 当 v[index] 时调用</span>        <span class="token keyword">return</span> m_data<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Vector <span class="token function">v</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    v<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    v<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    v<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        sum <span class="token operator">+</span><span class="token operator">=</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>       std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> sum <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>Vector类 并没有定义拷贝构造函数，编译器实际会发生拷贝构造，发生一次浅拷贝。如果我们使用拷贝操作，会发生什么问题吗？</p><p><img src="https://pic3.zhimg.com/80/v2-2af21508834624d5214285b0418c7192_720w.webp" alt></p><pre class="line-numbers language-text"><code class="language-text">41行     Vector v2 = v1; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在执行以上语句时，编译器默认是会发生一次浅拷贝，那么在退出main函数时候，v1.m_data 会被释放两次（析构v1 v2，就会发生两次对 v1.m_data的释放；更危险的是，如果v1被释放，而v2还在被使用，空指针出现）</p><p>– 这就是为什么，一个类定义了 <strong>解构函数，</strong> 还要定义或删除 <strong>拷贝构造函数</strong> 和 <strong>拷贝赋值函数</strong> 的原因。</p><ul><li>两种解决办法：</li></ul><p>① 直接禁止用户拷贝这个类的对象，让用户拷贝时，报错</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">Vector</span><span class="token punctuation">(</span>Vector <span class="token keyword">const</span> <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://pic4.zhimg.com/80/v2-91861b16bf3b362d7650bd32183da6f3_720w.webp" alt></p><p>② 我们自己实现一下拷贝构造函数，通过深拷贝，解决指针双重释放的问题。– 如果要用浅拷贝，那涉及到 <strong>智能指针</strong>。</p><p><img src="https://pic1.zhimg.com/80/v2-80ca3e62c5cc9a96612d9fa4cfe10764_720w.webp" alt></p><p>这样保证了 任何单次操作前后，对象都处于正确状态（存在或者删除），从而避免程序读到空悬指针。这就是保证了面向对象的 “封装：不变性”。</p><p>无论，size()/resize()这样的get/set模式，还是深拷贝，都是为了满足 “封装： 不变性” – 也就是ACID中的C（consistency）。一次对象的操作，要么完成，要么不完成，要保证 对象始终处于正确的状态。</p><h3 id="拷贝赋值函数"><a href="#拷贝赋值函数" class="headerlink" title="拷贝赋值函数"></a>拷贝赋值函数</h3><p>同理，如果使用了拷贝赋值，也需要定义拷贝赋值函数。</p><p><img src="https://pic1.zhimg.com/80/v2-37fdd4f26dbee98666227602895a5f58_720w.webp" alt></p><p>以上方式，先销毁，再通过 placement new，在原有this指针上构造。为了提高性能，推荐使用，realloc，从而就地利用现有m_data，避免重新分配。</p><p><img src="https://pic4.zhimg.com/80/v2-c03216e982a84dd1123035865f2aa763_720w.webp" alt></p><p>m_data显然，本来就有一段内存，那么通过 realloc 可以方便在原有的指针地址上扩展内存，避免了一次销毁在分配操作。</p><h3 id="移动构造函数-amp-移动赋值函数"><a href="#移动构造函数-amp-移动赋值函数" class="headerlink" title="移动构造函数 &amp; 移动赋值函数"></a>移动构造函数 &amp; 移动赋值函数</h3><p><img src="https://pic4.zhimg.com/80/v2-06d734b391ec5af5320b2ff777f842ff_720w.webp" alt></p><ul><li>std::move</li></ul><p>调用 std::move，V1 接管了V2的这块内存的所有权。</p><p>而拷贝赋值的 复杂度为 O(n)，因为分配了两块内存，v1 = v2 完成的是深拷贝。</p><p>以上两个操作，都不会产生二次free。</p><ul><li>std::swap</li></ul><p>另外还有 通过 std::swap 完成两块内存内容的交换。</p><p><img src="https://pic3.zhimg.com/80/v2-9c74e7f4751238aefa8f15f3973de46a_720w.webp" alt></p><ul><li>隐式发生 Move的情况</li></ul><p>① return v2 // C++规定，return 的对象不会再使用，自然等价于 std::move 语义。</p><ul><li>显式发生 拷贝的情况</li></ul><p>① return std::as_const(v2) // 显式拷贝</p><p>② v1 = v2 // 默认拷贝</p><p><img src="https://pic2.zhimg.com/80/v2-f0385bfdf4e88fdfb80b63f596a5a301_720w.webp" alt></p><p>自定义移动构造、移动赋值，可以提高执行效率。</p><p><img src="https://pic4.zhimg.com/80/v2-c3ff25be1b7a8b0cfb1107dd130b8727_720w.webp" alt></p><p>因为移动后，销毁了原对象，不存在两次free的情况，移动是浅移动。</p><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a><strong>unique_ptr</strong></h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a><strong>含义</strong></h3><p>对象释放，保证释放之前和之后，对象都处于正常状态。这样，不会出现 野指针(空悬指针)。</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> p <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在解构函数中，会自动调用 delete p 释放 p。对比 C++ 98 古老的释放对象的方法。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 之后要设null，不然可能会被再利用。</span>p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>而 unique_ptr 只需要 即可提前释放对象。– 体现了封装：一致性。</p><pre class="line-numbers language-cpp"><code class="language-cpp">p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 等价于 p.reset();</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="浅拷贝问题"><a href="#浅拷贝问题" class="headerlink" title="浅拷贝问题"></a>浅拷贝问题</h3><p>以下代码，unique_ptr 是删除了拷贝函数的，调用类的成员函数会报错。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> C <span class="token punctuation">{</span>    <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">do_sth</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 调用时，发生了浅拷贝</span>    p<span class="token operator">-</span><span class="token operator">></span><span class="token function">do_sth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> p <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">func</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//报错</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为 unique_ptr 删除了 拷贝构造函数，不能被拷贝。宁可编译器出错，不在运行时出错。按照三五法则，unique_ptr 自定义了解构函数，所以它必须删除拷贝构造函数。unique_ptr 采用的是上文提到的第一种方法，来避免 double free的情况。</p><ul><li>那么如何解决这个问题，解决方法</li></ul><p>可以这样修改，从 unique_ptr 获取 原始指针</p><ul><li><strong>case 1</strong></li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>C <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    p<span class="token operator">-</span><span class="token operator">></span><span class="token function">do_sth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> p <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 从p中 get出原始指针，并不是要夺取资源的占有权，只是调用p的成员函数，并没有接管对象生命周期。</span>    <span class="token function">func</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一种情况，我们只是对 p做了一些事情，并不是需要获取p 的控制权，此时只需要指针的 get() 出一个原始指针，并没有修改它什么时候释放这件事。还可以这样，把 p 指针 move到全局变量。（不推荐）</p><ul><li><strong>case 2</strong></li></ul><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>C<span class="token operator">>></span> objlist<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 把指针放到一个全局列表，那么 p的生命周期将变得和 objlist一样长。所以需要接管p的生命周期。</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    objlist<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 进一步移动到 objlist</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> p <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//  不为空</span>    <span class="token function">func</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过移动构造函数，转移指针控制器</span>    p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//  为空</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但移交了p 的控制权，就不能再访问 p 这个地址了。如果还想对 移交后的指针p，调用成员函数等操作，可以这样操作（不推荐，都这样做了还用什么unique_ptr）</p><ul><li><strong>case 3</strong></li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> p <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    C <span class="token operator">*</span>raw_p <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 先把原始指针拷贝一份</span>    <span class="token function">func</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 转移p 控制权给 objlist </span>    <span class="token comment" spellcheck="true">// 但需要注意，要保证 raw_p的存在时间不能超过 p的生命周期，否则 会出现危险的空悬指针。</span>    <span class="token comment" spellcheck="true">//objlist.clear();</span>    raw_p<span class="token operator">-</span><span class="token operator">></span><span class="token function">do_something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic2.zhimg.com/80/v2-b7c7fbfbb20e00f81ebb1ad056a41165_720w.webp" alt></p><p>raw_p 返回错误值。报错分析如下图，</p><p><img src="/posts/57427/1.jpg" alt></p><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a><strong>shared_ptr</strong></h2><h3 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h3><p>下面的例子说明了 shared_ptr 的使用特点，</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">struct</span> C <span class="token punctuation">{</span>     <span class="token keyword">int</span> m_number<span class="token punctuation">;</span>    <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"分配内存!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        m_number <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>       <span class="token operator">~</span><span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"释放内存!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        m_number <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2333333</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>       <span class="token keyword">void</span> <span class="token function">do_something</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"我的数字是 %d!\n"</span><span class="token punctuation">,</span> m_number<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>C<span class="token operator">>></span> objlist<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    objlist<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 这里用移动可以更高效，但不必须</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> p <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 引用计数初始化为1</span>    <span class="token function">func</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// shared_ptr 允许拷贝！和当前指针共享所有权，引用计数加1</span>    <span class="token function">func</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 多次也没问题~ 多个 shared_ptr 会共享所有权，引用计数加1</span>    p<span class="token operator">-</span><span class="token operator">></span><span class="token function">do_something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 正常执行，p 指向的地址本来就没有改变</span>    objlist<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 刚刚 p 移交给 func 的生命周期结束了！引用计数减2</span>    p<span class="token operator">-</span><span class="token operator">></span><span class="token function">do_something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 正常执行，因为引用计数还剩1，不会被释放</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 到这里最后一个引用 p 也被释放，p 指向的对象才终于释放</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>unique_ptr</strong> 解决了重复释放的方式是禁止拷贝，这样虽然效率高，但导致使用困难，容易出错；</p><p>相比之下，牺牲效率换来自由度的 <strong>shared_ptr</strong> 允许拷贝，他解决重复释放的方式是通过<strong>引用计数</strong>；</p><p>1、当初始化一个 shared_ptr时，计数初始化为 1</p><p>2、shared_ptr 被拷贝一次，计数加 1</p><p>3、shared_ptr 被解构一次，计数减 1， 减到 0 则自动销毁他指向的对象，比如 main函数 return</p><p>从而保证要还有引用存在，就不会解构对象。</p><ul><li>总结下 两种指针的特点，</li></ul><p>1&gt; unique_ptr 容易保证原子性，shared_ptr 需要硬件指令保证原子性，效率没有 unique_ptr 高；</p><p>2&gt; shared_ptr 方便，但还有循环引用问题，接着往下看。</p><h3 id="循环引用问题"><a href="#循环引用问题" class="headerlink" title="循环引用问题"></a>循环引用问题</h3><ul><li>一个 使用 shared_ptr 的 <strong>Bad Case</strong></li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token keyword">struct</span> C <span class="token punctuation">{</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> m_child<span class="token punctuation">;</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> m_parent<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> parent <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> child <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 建立相互引用</span>    parent<span class="token operator">-</span><span class="token operator">></span>m_child <span class="token operator">=</span> child<span class="token punctuation">;</span>    child<span class="token operator">-</span><span class="token operator">></span>m_parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>    parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// parent 不会被释放，child 还指向它</span>    child <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// child  不会被释放，parent 还指向它</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 完了，直到main函数退出，这两块内存都没有被释放。</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面实例的目的，通常 释放 parent时候，希望 child也同时被释放，但是因为产生了循环引用，导致内存泄漏。</p><p>总结一下：</p><p>动态指针 shared_ptr，可以适当减少使用者的出错概率，因为他的行为类似 GC语言的引用计数机制，但也有以下问题：</p><p>1、shared_ptr 需要维护一个 atomic 的引用计数器，效率会降低，需要额外维护一块管理内存，访问实际对象需要二级指针，而且 deleter 使用了<strong>类型擦除技术</strong>；</p><p>2、另外，全部使用 shared_ptr，可能会出现循环引用的问题，导致内存泄漏，那么要使用不影响计数的原始指针，或者 <strong>weak_ptr</strong> 来避免这个问题。</p><blockquote><p>c语言有特定方法解决循环引用，c++需要改造如下: 使用 weak_ptr</p></blockquote><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a><strong>weak_ptr</strong></h2><h3 id="讲解-weak-ptr-概念"><a href="#讲解-weak-ptr-概念" class="headerlink" title="讲解 weak_ptr 概念"></a>讲解 weak_ptr 概念</h3><ul><li>case 1</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>C<span class="token operator">>></span> objlist<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    objlist<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 进一步移动到 objlist</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> p <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 引用数初始化为 1</span>    p<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span>    std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> weak_p <span class="token operator">=</span> p<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 创建一个不影响计数器的弱引用</span>    p<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span>    <span class="token function">func</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 控制权转移，p 变为 null， 引用计数不变!</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>weak_p<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// here</span>        weak_p<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">do_sth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 正常执行，p 的生命周期仍然被 objlist 延续</span>    <span class="token punctuation">}</span>    objlist<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 刚刚 p移交给 objlist的生命周期结束，引用数-1 变0</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>weak_p<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 因为 shared_ptr 指向的对象，已经释放，弱引用会失败。</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// here</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        weak_p<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">do_sth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 不会执行到这.</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这里最后一个弱引用 weak_p 也被释放，他指向的管理块 被释放。</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="解决方案1"><a href="#解决方案1" class="headerlink" title="# 解决方案1"></a># 解决方案1</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token keyword">struct</span> C <span class="token punctuation">{</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> m_child<span class="token punctuation">;</span>    std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> m_parent<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> parent <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> child <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 建立相互引用</span>    parent<span class="token operator">-</span><span class="token operator">></span>m_child <span class="token operator">=</span> child<span class="token punctuation">;</span>    child<span class="token operator">-</span><span class="token operator">></span>m_parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>    parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    child <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不影响 shared_ptr 计数，弱引用 weak_ptr</p><p>有时候，我们希望维护一个 shared_ptr 的弱引用 weak_ptr, 即 弱引用的拷贝与 解构不影响其引用计数器。</p><p>之后，有需要时，可以再通过 lock() 随时产生一个新的 shared_ptr 作为强引用，但不lock的时候，不影响计数。</p><blockquote><p>lock(): creates a shared_ptr that manages the referenced object</p></blockquote><p>如果失效了(计数器归零), 则 expired() 会返回 true，并且 lock() 会返回nullptr</p><p><strong>可以把 C * 理解为 unique_ptr 的弱引用，weak_ptr 理解为 shared_ptr 的弱引用。但 weak_ptr 能提供 失效检测，更安全。</strong></p><p>shared_ptr 管理的对象生命周期，取决于所有引用中，最长寿的哪一个；</p><p>unique_ptr 管理的对象生命周期长度，取决于他所属的唯一一个引用的寿命。</p><h3 id="智能指针-做为类的成员变量"><a href="#智能指针-做为类的成员变量" class="headerlink" title="# 智能指针 做为类的成员变量"></a># 智能指针 做为类的成员变量</h3><p>可以在类中使用智能指针作为成员变量，需要根据所有权情况，判断使用哪一种智能指针</p><p>1、<strong>unique_ptr</strong>: 当该对象仅仅属于我时，比如 父对象中指向子对象的指针；</p><p>2、<strong>原始指针</strong>: 当该对象不属于我，但他释放前，我必然被释放。比如：子对象中指向父对象的指针；– unique_ptr 和 原始指针 一起使用。</p><p>3、<strong>shared_ptr</strong>: 当该对象由多个对象共享，或虽然该对象仅属于我，但有使用weak_ptr的需要</p><p>4、<strong>weak_ptr</strong>: 当该对象不属于我，且他释放后，我仍可能不被释放时。比如：指向窗口中上一次被点击的元素。</p><p>5、shared_ptr 和 weak_ptr 一起使用。即使 weak_ptr 指向的原指针已失效， expired可以判断出，而不会造成报错。这一点，强于原始指针对 unique_ptr 的弱引用。</p><p><strong>综上 ，初学者 更推荐 shared_ptr 和 weak_ptr的组合，而不是 unique_ptr 和 原始指针的组合。</strong></p><h3 id="解决方案2"><a href="#解决方案2" class="headerlink" title="# 解决方案2"></a># 解决方案2</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token keyword">struct</span> C <span class="token punctuation">{</span>     std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> m_child<span class="token punctuation">;</span>    C <span class="token operator">*</span>m_parent<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> parent <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> child <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 建立相互引用：</span>    parent<span class="token operator">-</span><span class="token operator">></span>m_child <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 移交 child 的所属权给 parent</span>    child<span class="token operator">-</span><span class="token operator">></span>m_parent <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// parent 会被释放。因为 child 指向他的是原始指针</span>    <span class="token comment" spellcheck="true">// 此时 child 也已经被释放了，因为 child 完全隶属于 parent</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>刚才提到的 unique_ptr 的应用场景，“当该对象仅仅属于我时”。既然都是用了原始指针（假设它释放前我必然被释放），因而我们完全可以把 m_child 变成一个标志着 “完全所有权”的 unique_ptr 。</p><p>这样 也不需要， shared_ptr 维护原子计数器的开销。</p><blockquote><p>C++ 中所有的拷贝都是深拷贝，除了 shared_ptr 和 weak_ptr 是浅拷贝，而 unique_ptr 禁止拷贝。</p></blockquote><h2 id="三五法则"><a href="#三五法则" class="headerlink" title="三五法则"></a>三五法则</h2><h3 id="安全和不安全的类型"><a href="#安全和不安全的类型" class="headerlink" title="安全和不安全的类型"></a>安全和不安全的类型</h3><p>① 以下类型是安全的：</p><ul><li>int id; // 基础类型</li><li>std::vector<int> arr; // STL容器 自动调用 vector的深拷贝</int></li><li>std::shared_ptr<Object> child; // 智能指针，它是浅拷贝，引用了计数，也不会出错。除非有循环引用需要 weak_ptr配合</Object></li><li>Object *parent; // 原始指针，前提是从 unique_ptr里 .get() 出来的弱引用，才是合理的</li></ul><p>② 以下对象时不安全的：</p><ul><li>char *ptr; // 原始指针，如果是通过 malloc/free 或者 new/delete 分配的， 需要自己去删除拷贝，或者定义拷贝。</li><li>GLint tex; // 是基础类型 int，但对应的某种资源。实际和 malloc/free函数一样是分配释放资源函数。</li><li>std::vector&lt;Object *&gt; obj; // STL容器，但存储了不安全的对象。 最好，通过深拷贝，或者禁止拷贝来避免 double free 的问题。</li></ul><h3 id="那么什么样的类定义是安全的呢"><a href="#那么什么样的类定义是安全的呢" class="headerlink" title="那么什么样的类定义是安全的呢"></a>那么什么样的类定义是安全的呢</h3><ul><li>如果你的类所有成员，都是安全类型。那么五大函数都不需要声明 (或声明为 = default)，你的类自动就是安全的；</li></ul><p>那么举一个安全的结构体定义</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Mesh <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// points</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>math<span class="token operator">::</span>vec3f<span class="token operator">></span> vert<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// corners</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>uint32_t<span class="token operator">></span> loop<span class="token punctuation">;</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>math<span class="token operator">::</span>vec2f<span class="token operator">></span> loop_uv<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// faces</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>uint32_t<span class="token operator">></span> poly<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>最好的判断方式，如果你不需自定义解构函数，便可不担心安全问题，<strong>因为通常自定义解构函数</strong>，意味着你的类成员里，包含不安全的类型。</li></ul><p>管理资源的类，先删除它的拷贝构造和拷贝赋值函数。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">Shader</span><span class="token punctuation">(</span>Shader <span class="token keyword">const</span> <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>Shader <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Shader <span class="token keyword">const</span> <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>既然，标准库已经提供了 shared_ptr，直接用 shared_ptr<Shader> 来管理。</Shader></p><h3 id="对于数据结构"><a href="#对于数据结构" class="headerlink" title="对于数据结构"></a>对于数据结构</h3><p>如果可以（它的构造函数使用 malloc()），自己定义拷贝和移动函数。</p><p><img src="https://pic4.zhimg.com/80/v2-5070fdad816a798edfcdda5afbaf2707_720w.webp" alt></p><h3 id="如何避免不必要的拷贝：常引用"><a href="#如何避免不必要的拷贝：常引用" class="headerlink" title="如何避免不必要的拷贝：常引用"></a>如何避免不必要的拷贝：常引用</h3><p>函数的参数声明为值类型，此时，实际调用了类的拷贝构造函数。产生了一次不必要的拷贝。那么替换成 const &amp;，常引用，从而传递了一个指针，避免了拷贝。</p><h3 id="函数参数类型优化规则：-按引用还是按值？"><a href="#函数参数类型优化规则：-按引用还是按值？" class="headerlink" title="函数参数类型优化规则： 按引用还是按值？"></a>函数参数类型优化规则： 按引用还是按值？</h3><pre class="line-numbers language-text"><code class="language-text">① 如果参数是基础类型（int、float） 则按值传递；       float  squareRoot(float val);② 如果是原始指针（int*、Object*）则按值传递；       void doSomethingWith(Object *ptr);③ 如果是 容器类型（vector、string）则按常引用传递；       int sumArray(std::vector<int> const &arr);④ 如果容器不大 （tuple<int, int>）按值传递；       glm::vec3 calculate(glm::vec3 pos);⑤ 如果智能指针（shared_ptr）且需要生命周期控制权，则按值传递；用户自己调用 std::move()       void addObject(std::shared_ptr<Object> obj);⑥ 如果是智能指针，但不需要生命周期，则通过 .get() 获取原始指针后，按值传递；       void modifyObject(Object *obj);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>只有数据容器、自定义的可拷贝的类，使用常引用的方法。</li></ul><h3 id="避免不必要的隐式拷贝"><a href="#避免不必要的隐式拷贝" class="headerlink" title="避免不必要的隐式拷贝"></a>避免不必要的隐式拷贝</h3><p>我们 可以将拷贝构造函数声明为 explicit (明确的)，这样隐式拷贝会出错，从而发现不必要的拷贝。</p><p><img src="https://pic2.zhimg.com/80/v2-20424e22ed1a52d441d087e172255fd5_720w.webp" alt></p><h2 id="语言管理资源"><a href="#语言管理资源" class="headerlink" title="语言管理资源"></a>语言管理资源</h2><p>为什么很多面向对象的语言，比如Java，都没有构造函数全家桶的概念呢？</p><ul><li>因为，他们的业务需求大都是面向资源的，比如操作数据库，发送http请求等等。</li><li>这些业务往往都是和“资源”在打交道，从而，基本上都是删除了拷贝函数的那一类，解决这类需求，几乎总是在用 shared_ptr<GLShader> 的模式，于是 Java和Python 干脆简化：一切非基础类型的对象都是 <strong>浅拷贝</strong>，使用引用计数，同时再通过 <strong>垃圾回收机制</strong> 自动管理。</GLShader></li></ul><p>因此，以<strong>系统级编程、算法数据结构、高性能计算</strong> 为主要业务的C++，才发展出了这些思想，并将 <strong>拷贝、移动、指针、可变性、多线程</strong> 等概念作为 <strong>语言基础元素</strong> 而存在。这些在我们的业务中非常重要，所以不可替代。</p><h2 id="扩展关键词"><a href="#扩展关键词" class="headerlink" title="扩展关键词"></a>扩展关键词</h2><p>1、P-IMPL 的模式</p><p>2、虚函数和纯虚函数</p><p>3、拷贝如何作为虚函数</p><p>4、std::unique_ptr::release()</p><p>5、std::enable_shared_from_this</p><p>6、dynamic_cast</p><p>7、std::dynamic_pointer_cast</p><p>8、运算符重载</p><p>9、右值引用 &amp;&amp;</p><p>10、std::shared_ptr<void> 和 std::any // 可以接受任何一个对象指针，和c的void *像，但可以管理生命周期，std::any 深拷贝版本的 shared_ptr<void></void></void></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概-述&quot;&gt;&lt;a href=&quot;#概-述&quot; class=&quot;headerlink&quot; title=&quot;概 述&quot;&gt;&lt;/a&gt;概 述&lt;/h2&gt;&lt;h3 id=&quot;RAII-Resource-Acquisition-Is-Initialization&quot;&gt;&lt;a href=&quot;#RAII-R
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
</feed>
