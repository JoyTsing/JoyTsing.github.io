<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="Shell编程小结(二), 博客 JoyTsing blog"><meta name="description" content="Keep It Simple, Stupid too"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="theme-color" content="white"><title>Shell编程小结(二) | JoyTsing</title><link rel="apple-touch-icon" href="/"><link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="/favicon.ico"><link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css"><link rel="stylesheet" type="text/css" href="/libs/aos/aos.css"><link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css"><link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" type="text/css" href="/css/matery.css"><link rel="stylesheet" type="text/css" href="/css/my.css"><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style><script src="/libs/jquery/jquery.min.js"></script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="JoyTsing" type="application/atom+xml"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><img src="/apple-touch-icon.png" class="logo-img" alt="LOGO"> <span class="logo-span">JoyTsing</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fa fa-home"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-tags"></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-bookmark"></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-archive"></i> <span>归档</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa fa-user-circle-o"></i> <span>关于</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa fa-envelope"></i> <span>留言</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa fa-address-book"></i> <span>友链</span></a></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fa fa-search" title="搜索"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="/medias/avatars/touxiang2.jpg" class="logo-img circle responsive-img"><div class="logo-name">JoyTsing</div><div class="logo-desc">寒冬本来就冷, 还要吵个不停</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="m-nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-fw fa-bookmark"></i> 分类</a></li><li class="m-nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li class="m-nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa fa-fw fa-user-circle-o"></i> 关于</a></li><li class="m-nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa fa-fw fa-envelope"></i> 留言</a></li><li class="m-nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa fa-fw fa-address-book"></i> 友链</a></li><li><div class="divider"></div></li><li><a href="https://github.com/JoyTsing" class="waves-effect waves-light" target="_blank"><i class="fa fa-github-square fa-fw"></i>Follow Me</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#000;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href="https://github.com/JoyTsing" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Follow Me" data-position="left" data-delay="50"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a></nav></header><div class="bg-cover pd-header post-cover" style="background-image:url(/medias/featureimages/23.jpg)"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">Shell编程小结(二)</h1></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{width:345px;padding-left:20px}.toc-widget .toc-title{margin:35px 0 15px 0;padding-left:17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content{height:calc(100vh - 250px);overflow:auto}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px;position:absolute;right:23.5vw;display:block}#toc-content .is-active-link{color:#42b983}#floating-toc-btn{position:fixed;right:15px;bottom:76px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/Linux/"><span class="chip bg-color">Linux</span> </a><a href="/tags/Shell/"><span class="chip bg-color">Shell</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/Linux/" class="post-category">Linux</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp; 2020-12-18</div><div class="post-date info-break-policy"><i class="fa fa-calendar-check-o fa-fw"></i>更新日期:&nbsp;&nbsp; 2023-12-14</div><div class="info-break-policy"><i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp; 16.8k</div><div class="info-break-policy"><i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp; 63 分</div><div id="busuanzi_container_page_pv" class="info-break-policy"><i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp; <span id="busuanzi_value_page_pv"></span></div></div></div><hr class="clearfix"><div class="card-content article-card-content"><div id="articleContent"><h2 id="文件系统操作"><a href="#文件系统操作" class="headerlink" title="文件系统操作"></a>文件系统操作</h2><h3 id="文件系统在-Linux-操作系统中的位置"><a href="#文件系统在-Linux-操作系统中的位置" class="headerlink" title="文件系统在 Linux 操作系统中的位置"></a>文件系统在 Linux 操作系统中的位置</h3><p>如何来认识文件系统呢？从 Shell 程序员的角度来看，文件系统就是一个用来组织各种文件的方法。但是文件系统无法独立于硬件存储设备和操作系统而存在，因此还是有必要来弄清楚硬件存储设备、分区、操作系统、逻辑卷、文件系统等各种概念之间的联系，以便理解文件系统常规操作的一些“细节”。这个联系或许（也许会有一些问题）可以通过这样一种方式来呈现：</p><p><img src="https://tinylab.gitbooks.io/shellbook/content/zh/chapters/pic/Linux_FileSystem_Architecture.jpg" alt="Linux_FileSystem_Architecture"></p><p>从图中可以清晰地看到各个“概念”之间的关系，它们以不同层次分布，覆盖硬件设备、系统内核空间、系统用户空间。在用户空间，用户可以不管内核如何操作具体硬件设备，仅仅使用程序员设计的各种界面就可以，而普通程序员也仅仅需要利用内核提供的各种接口（System Call）或者一些C库来和内核进行交互，而无须关心具体的实现细节。不过对于操作系统开发人员，他们需要在内核空间设计特定的数据结构来管理和组织底层的硬件设备。</p><p>下面从下到上的方式（即从底层硬件开始），用工具来分析和理解图中几个重要概念。（如果有兴趣，可以先看看下面的几则资料）</p><p>参考资料：</p><ul><li><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-vfs/">从文件 I/O 看 Linux 的虚拟文件系统</a></li><li><a href="http://www.ibm.com/developerworks/cn/linux/l-linux-filesystem/index.html?ca=drs-cn">Linux 文件系统剖析</a></li></ul><h3 id="硬件管理和设备驱动"><a href="#硬件管理和设备驱动" class="headerlink" title="硬件管理和设备驱动"></a>硬件管理和设备驱动</h3><p>Linux 系统通过设备驱动管理硬件设备。如果添加了新的硬件设备，那么需要编写相应的硬件驱动来管理它。对于一些常见的硬件设备，系统已经自带了相应的驱动，编译内核时，选中它们，然后编译成内核的一部分或者以模块的方式编译。如果以模块的方式编译，那么可以在系统的 <code>/lib/modules/$(uname -r)</code>目录下找到对应的模块文件。</p><h4 id="范例：查找设备所需的驱动文件"><a href="#范例：查找设备所需的驱动文件" class="headerlink" title="范例：查找设备所需的驱动文件"></a>范例：查找设备所需的驱动文件</h4><p>比如，可以这样找到相应的 scsi 驱动和 usb 驱动对应的模块文件：</p><p>更新系统中文件索引数据库(有点慢）</p><pre class="line-numbers language-bash"><code class="language-bash">$ updatedb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查找 scsi 相关的驱动</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">locate</span> scsi*.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查找 usb 相关的驱动</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">locate</span> usb*.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这些驱动以 <code>.ko</code> 为后缀，在安装系统时默认编译为了模块。实际上可以把它们编译为内核的一部分，仅仅需要在编译内核时选择为<code>[*]</code>即可。但是，很多情况下会以模块的方式编译它们，这样可以减少内核的大小，并根据需要灵活地加载和卸载它们。下面简单地演示如何卸载模块、加载模块以及查看已加载模块的状态。</p><p>可通过 <code>/proc</code> 文件系统的 <code>modules</code> 文件检查内核中已加载的各个模块的状态，也可以通过 <code>lsmod</code> 命令直接查看它们。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> /proc/modules<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-bash"><code class="language-bash">$ lsmod<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="范例：查看已经加载的设备驱动"><a href="#范例：查看已经加载的设备驱动" class="headerlink" title="范例：查看已经加载的设备驱动"></a>范例：查看已经加载的设备驱动</h4><p>查看 scsi 和 usb 相关驱动，结果各列为模块名、模块大小、被其他模块的引用情况（引用次数、引用它们的模块）</p><pre class="line-numbers language-bash"><code class="language-bash">$ lsmod <span class="token operator">|</span> <span class="token function">egrep</span> <span class="token string">"scsi|usb"</span>
usbhid                 29536  0
hid                    28928  1 usbhid
usbcore               138632  4 usbhid,ehci_hcd,ohci_hcd
scsi_mod              147084  4 sg,sr_mod,sd_mod,libata<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="范例：卸载设备驱动"><a href="#范例：卸载设备驱动" class="headerlink" title="范例：卸载设备驱动"></a>范例：卸载设备驱动</h4><p>下面卸载 <code>usbhid</code> 模块看看（不要卸载scsi的驱动！因为你的系统可能就跑在上面，如果确实想玩玩，卸载前记得保存数据），通过 <code>rmmod</code> 命令就可以实现，先切换到 Root 用户：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> -s
<span class="token comment" spellcheck="true"># rmmod usbhid</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>再查看该模块的信息，已经看不到了吧</p><pre class="line-numbers language-bash"><code class="language-bash">$ lsmod <span class="token operator">|</span> <span class="token function">grep</span> ^usbhid<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="范例：挂载设备驱动"><a href="#范例：挂载设备驱动" class="headerlink" title="范例：挂载设备驱动"></a>范例：挂载设备驱动</h4><p>如果有个 usb 鼠标，那么移动一下，是不是发现动不了啦？因为设备驱动都没有了，设备自然就没法用罗。不过不要紧张，既然知道原因，那么重新加载驱动就可以，下面用 <code>insmod</code> 把 <code>usbhid</code> 模块重新加载上。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> -s
<span class="token comment" spellcheck="true"># insmod `locate usbhid.ko`</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>locate usbhid.ko</code> 是为了找出 <code>usbhid.ko</code> 模块的路径，如果之前没有 <code>updatedb</code>，估计用它是找不到了，不过也可以直接到 <code>/lib/modules</code> 目录下用 <code>find</code> 把 <code>usbhid.ko</code> 文件找到。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># insmod $(find /lib/modules -name "*usbhid.ko*" | grep `uname -r`)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在鼠标又可以用啦，不信再动一下鼠标 :-)</p><p>到这里，硬件设备和设备驱动之间关系应该是比较清楚了。如果没有，那么继续下面的内容。</p><h4 id="范例：查看设备驱动对应的设备文件"><a href="#范例：查看设备驱动对应的设备文件" class="headerlink" title="范例：查看设备驱动对应的设备文件"></a>范例：查看设备驱动对应的设备文件</h4><p>Linux 设备驱动关联着相应的设备文件，而设备文件则和硬件设备一一对应。这些设备文件都统一存放在系统的 <code>/dev/</code> 目录下。</p><p>例如，scsi 设备对应<code>/dev/sda</code>，<code>/dev/sda1</code>，<code>/dev/sda2</code>… 下面查看这些设备信息。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ls</span> -l /dev/sda*
brw-rw---- 1 root disk 8, 0 2007-12-28 22:49 /dev/sda
brw-rw---- 1 root disk 8, 1 2007-12-28 22:50 /dev/sda1
brw-rw---- 1 root disk 8, 3 2007-12-28 22:49 /dev/sda3
brw-rw---- 1 root disk 8, 4 2007-12-28 22:49 /dev/sda4
brw-rw---- 1 root disk 8, 5 2007-12-28 22:50 /dev/sda5
brw-rw---- 1 root disk 8, 6 2007-12-28 22:50 /dev/sda6
brw-rw---- 1 root disk 8, 7 2007-12-28 22:50 /dev/sda7
brw-rw---- 1 root disk 8, 8 2007-12-28 22:50 /dev/sda8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到第一列第一个字符都是 <code>b</code>，第五列都是数字 8 。 <code>b</code> 表示该文件是一个块设备文件，对应地，如果是 <code>c</code> 则表示字符设备（例如 `/dev/ttyS0)，关于块设备和字符设备的区别，可以看这里：</p><blockquote><ul><li><p>字符设备：字符设备就是能够像字节流一样访问的设备，字符终端和串口就属于字符设备。</p></li><li><p>块设备：块设备上可以容纳文件系统。与字符设备不同，在读写时，块设备每次只能传输一个或多个完整的块。在 Linux 操作系统中，应用程序可以像访问字符设备一样读写块设备（一次读取或写入任意的字节数据）。因此，块设备和字符设备的区别仅仅是在内核中对于数据的管理不同。</p></li></ul></blockquote><p>数字 8 则是该硬件设备在内核中对应的设备编号，可以在内核的 <code>Documentation/devices.txt</code> 和 <code>/proc/devices</code> 文件中找到设备号分配情况。但是为什么同一个设备会对应不同的设备文件（<code>/dev/sda</code> 后面为什么还有不同的数字，而且 <code>ls</code> 结果中的第 6 列和它们对应起来）。这实际上是为了区分不同设备的不同部分。对于硬盘，这样可以处理硬盘内部的不同分区。就内核而言，它仅仅需要通过第 5 列的设备号就可以找到对应的硬件设备，但是对于驱动模块来说，它还需要知道如何处理不同的分区，于是就多了一个辅设备号，即第 6 列对应的内容。这样一个设备就有了主设备号（第 5 列）和辅设备号（第 6 列），从而方便地实现对各种硬件设备的管理。</p><p>因为设备文件和硬件是对应的，这样可以直接从 <code>/dev/sda</code> （如果是 <code>IDE</code> 的硬盘，那么对应的设备就是 <code>/dev/hda</code> 啦）设备中读出硬盘的信息，例如：</p><h4 id="范例：访问设备文件"><a href="#范例：访问设备文件" class="headerlink" title="范例：访问设备文件"></a>范例：访问设备文件</h4><p>用 <code>dd</code> 命令复制出硬盘的前 512 个字节，要 Root 用户</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">dd</span> if<span class="token operator">=</span>/dev/sda of<span class="token operator">=</span>mbr.bin bs<span class="token operator">=</span>512 count<span class="token operator">=</span>1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用 <code>file</code> 命令查看相应的信息</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">file</span> mbr.bin
mbr.bin: x86 boot sector, LInux i386 boot LOader<span class="token punctuation">;</span> partition 3: ID<span class="token operator">=</span>0x82, starthead 254, startsector 19535040, 1959930 sectors<span class="token punctuation">;</span> partition 4: ID<span class="token operator">=</span>0x5, starthead 254, startsector 21494970, 56661255 sectors, code offset 0x48<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>也可以用 <code>od</code> 命令以 16 进制的形式读取并进行分析</p><pre class="line-numbers language-bash"><code class="language-bash">$ od -x mbr.bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>bs</code> 是块的大小（以字节 <code>bytes</code> 为单位），<code>count</code> 是块数</p><p>因为这些信息并不直观（而且下面会进一步深入分析），那么先来看看另外一个设备文件，将可以非常直观地演示设备文件和硬件的对应关系。还是以鼠标为例吧，下面来读取鼠标对应的设备文件的信息。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> -s
<span class="token comment" spellcheck="true"># cat /dev/input/mouse1 | od -x</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>你的鼠标驱动可能不太一样，所以设备文件可能是其他的，但是都会在 <code>/dev/input</code> 下。</p><p>移动鼠标看看，是不是发现有不同信息输出。基于这一原理，我们经常通过在一端读取设备文件 <code>/dev/ttyS0</code> 中的内容，而在另一端往设备文件 <code>/dev/ttyS0</code> 中写入内容来检查串口线是否被损坏。</p><p>到这里，对设备驱动、设备文件和硬件设备之间的关联应该是印象更深刻了。如果想深入了解设备驱动的工作原理和设备驱动的编写，那么看看下面列出的相关资料，开始设备驱动的编写历程吧。</p><p>参考资料：</p><ul><li><a href="http://www.cyberciti.biz/tips/compiling-linux-kernel-26.html">Compile linux kernel 2.6</a></li><li><a href="http://www.blue1000.com/bkhtml/2001-02/2409.htm">Linux 系统的硬件驱动程序编写原理</a></li><li><a href="http://soft.zdnet.com.cn/software_zone/2007/1108/617545.shtml">Linux 下 USB设备的原理、配置、常见问题</a></li><li><a href="http://www.tldp.org/LDP/lkmpg/2.6/html/lkmpg.html">The Linux Kernel Module Programming Guide</a></li><li><a href="http://lwn.net/Kernel/LDD3/">Linux 设备驱动开发</a></li></ul><h3 id="理解、查看磁盘分区"><a href="#理解、查看磁盘分区" class="headerlink" title="理解、查看磁盘分区"></a>理解、查看磁盘分区</h3><p>实际上内存、u 盘等都可以作为文件系统底层的“存储”设备，但是这里仅用硬盘作为实例来介绍磁盘和分区的关系。</p><p>目前 Linux 的分区依然采用第一台PC硬盘所使用的分区原理，下面逐步分析和演示这一分区原理。</p><h4 id="磁盘分区基本原理"><a href="#磁盘分区基本原理" class="headerlink" title="磁盘分区基本原理"></a>磁盘分区基本原理</h4><p>先来看看几个概念：</p><ul><li><p>设备管理和分区</p><p>Linux 下，每一个存储设备对应一个系统的设备文件，对于硬盘等 <code>IDE</code> 和 <code>SCSI</code> 设备，在系统的 <code>/dev</code> 目录下可以找到对应的包含字符 <code>hd</code> 和 <code>sd</code> 的设备文件。而根据硬盘连接的主板设备接口和数据线接口的不同，在 <code>hd</code> 或者 <code>sd</code> 字符后面可以添加一个从 <code>a</code> 到 <code>z</code> 的字符，例如 <code>hda</code>，<code>hdb</code>，<code>hdc</code> 和 <code>sda</code>，<code>sdb</code>，<code>sdc</code> 等，另外为了区别同一个硬件设备的不同分区，在后面还可以添加了一个数字，例如 <code>hda1</code>，<code>hda2</code>，<code>hda3</code> 和 <code>sda1</code>，<code>sda2</code>，<code>sda3</code>，所以在 <code>/dev</code> 目录下，可以看到很多类似的设备文件。</p></li><li><p>各分区的作用</p></li></ul><p>在分区时常遇到主分区和逻辑分区的问题，这实际上是为了方便扩展分区，正如后面的逻辑卷的引入是为了更好地管理多个硬盘一样，引入主分区和逻辑分区可以方便地进行分区的管理。</p><p>Linux 系统中每一个硬盘设备最多由 4 个主分区（包括扩展分区）构成。</p><p>主分区的作用是计算机用来进行启动操作系统的，因此每一个操作系统的启动程序或者称作是引导程序，都应该存放在主分区上。 Linux 规定主分区（或者扩展分区）占用分区编号中的前 4 个。所以会看到主分区对应的设备文件为 <code>/dev/hda1-4</code> 或者 <code>/dev/sda1-4</code>，而不会是 <code>hda5</code> 或者 <code>sda5</code> 。</p><p>扩展分区则是为了扩展更多的逻辑分区的，在 Linux 下，逻辑分区占用了 <code>hda5-16</code> 或者 <code>sda5-16</code> 等 12 个编号。</p><ul><li>分区类型</li></ul><p>它规定了这个分区上的文件系统的类型。Linux支持诸如msdoc,vfat,ext2,ext3等诸多的文件系统类型，更多信息在下一小节进行进一步的介绍。</p><h4 id="通过分析-MBR-来理解分区原理"><a href="#通过分析-MBR-来理解分区原理" class="headerlink" title="通过分析 MBR 来理解分区原理"></a>通过分析 MBR 来理解分区原理</h4><p>下面通过分析硬盘的前 512 个字节（即 <code>MBR</code>）来分析和理解分区。</p><p>先来看看这张图：</p><p><img src="https://tinylab.gitbooks.io/shellbook/content/zh/chapters/pic/MBR_Architecture.jpg" alt="MBR_Architecture"></p><p>它用来描述 <code>MBR</code> 的结构。 <code>MBR</code> 包括引导部分、分区表、以及结束标记 `(55AAH)，分别占用了 512 字节中 446 字节、 64 字节和 2 字节。这里仅仅关注分区表部分，即中间的 64 字节以及图中左边的部分。</p><p>由于我用的是 <code>SCSI</code> 的硬盘，下面从 <code>/dev/sda</code> 设备中把硬盘的前 512 个字节拷贝到文件 <code>mbr.bin</code> 中。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> -s
<span class="token comment" spellcheck="true"># dd if=/dev/sda of=mbr.bin bs=512 count=1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>下面用 <code>file</code>，<code>od</code>，<code>fdisk</code> 等命令来分析这段 <code>MBR</code> 的数据，并对照上图以便加深理解。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">file</span> mbr.bin
mbr.bin: x86 boot sector, LInux i386 boot LOader<span class="token punctuation">;</span> partition 3: ID<span class="token operator">=</span>0x82, starthead 254, startsector 19535040, 1959930 sectors<span class="token punctuation">;</span> partition 4: ID<span class="token operator">=</span>0x5, starthead 254, startsector 21494970, 56661255 sectors, code offset 0x48
$ od -x mbr.bin <span class="token operator">|</span> <span class="token function">tail</span> -6   <span class="token comment" spellcheck="true">#仅关注中间的64字节，所以截取了结果中后6行</span>
0000660 0000 0000 0000 0000 a666 a666 0000 0180
0000700 0001 fe83 ffff 003f 0000 1481 012a 0000
0000720 0000 0000 0000 0000 0000 0000 0000 fe00
0000740 ffff fe82 ffff 14c0 012a e7fa 001d fe00
0000760 ffff fe05 ffff fcba 0147 9507 0360 aa55
$ <span class="token function">sudo</span> -s
<span class="token comment" spellcheck="true"># fdisk -l | grep ^/  #仅分析MBR相关的部分，不分析逻辑分区部分</span>
/dev/sda1   *           1        1216     9767488+  83  Linux
/dev/sda3            1217        1338      979965   82  Linux swap / Solaris
/dev/sda4            1339        4865    28330627+   5  Extended
<span class="token function">file</span><span class="token variable"><span class="token variable">`</span> 命令的结果显示，刚拷贝的 512 字节是启动扇区，用分号分开的几个部分分别是 <span class="token variable">`</span></span>bootloader<span class="token variable"><span class="token variable">`</span>，分区 3 和分区 4 。分区 3 的类型是 82，即 <span class="token variable">`</span></span>swap<span class="token variable"><span class="token variable">`</span> 分区（可以通过 <span class="token variable">`</span></span><span class="token function">fdisk</span><span class="token variable"><span class="token variable">`</span> 命令的 <span class="token variable">`</span></span>l<span class="token variable"><span class="token variable">`</span> 命令列出相关信息），它对应 <span class="token variable">`</span></span><span class="token function">fdisk</span><span class="token variable"><span class="token variable">`</span> 的结果中 <span class="token variable">`</span></span>/dev/sda3<span class="token variable"><span class="token variable">`</span> 所在行的第 5 列，分区 3 的扇区数是 1959930，转换成字节数是 <span class="token variable">`</span></span>1959930\*512<span class="token variable"><span class="token variable">`</span> （目前，硬盘的默认扇区大小是 512 字节），而 <span class="token variable">`</span></span>swap<span class="token variable"><span class="token variable">`</span> 分区的默认块大小是 1024 字节，这样块数就是 <span class="token variable">`</span></span><span class="token keyword">:</span>
$ <span class="token keyword">echo</span> 1959930*512/1024 <span class="token operator">|</span> <span class="token function">bc</span>
979965<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正好是 <code>fdisk</code> 结果中 <code>/dev/sda3</code> 所在行的第四列对应的块数，同样地，可以对照 <code>fdisk</code> 和 <code>file</code> 的结果分析分区 4 。</p><p>再来看看 <code>od</code> 命令以十六进制显示的结果，同样考虑分区 3，计算一下发现，分区 3 对应的 <code>od</code> 命令的结果为：</p><pre><code>fe00 ffff fe82 ffff 14c0 012a e7fa 001d</code></pre><p>首先是分区标记，<code>00H</code>，从上图中，看出它就不是引导分区（<code>80H</code> 标记的才是引导分区），而分区类型呢？为 <code>82H</code>，和 <code>file</code> 显示结果一致，现在再来关注一下分区大小，即 <code>file</code> 结果中的扇区数。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token string">"ibase=10;obase=16;1959930"</span> <span class="token operator">|</span> <span class="token function">bc</span>
1DE7FA<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>刚好对应 <code>e7fa 001d</code>，同样地考虑引导分区的结果：</p><blockquote><p>0180 0001 fe83 ffff 003f 0000 1481 012a</p></blockquote><p>分区标记： <code>80H</code>，正好反应了这个分区是引导分区，随后是引导分区所在的磁盘扇区情况，010100，即 1 面 0 道 1 扇区。其他内容可以对照分析。</p><p>考虑到时间关系，更多细节请参考下面的资料或者查看看系统的相关手册。</p><p>补充：安装系统时，可以用 <code>fdisk</code>，<code>cfdisk</code> 等命令进行分区。如果要想从某个分区启动，那么需要打上 <code>80H</code> 标记，例如可通过 <code>cfdisk</code> 把某个分区设置为 <code>bootable</code> 来实现。</p><p>参考资料：</p><ul><li><a href="http://www-128.ibm.com/developerworks/linux/library/l-linuxboot/">Inside the linux boot process</a></li><li><a href="http://docs.huihoo.com/gnu_linux/own_os/booting.htm">Develop your own OS: booting</a></li><li><a href="http://blog.csdn.net/fowse/article/details/7220021">Redhat9 磁盘分区简介</a></li><li><a href="http://www.tldp.org/HOWTO/Partition/">Linux partition HOWTO</a></li></ul><h3 id="分区和文件系统的关系"><a href="#分区和文件系统的关系" class="headerlink" title="分区和文件系统的关系"></a>分区和文件系统的关系</h3><p>在没有引入逻辑卷之前，分区类型和文件系统类型几乎可以同等对待，设置分区类型的过程就是格式化分区，建立相应的文件系统类型的过程。</p><p>下面主要介绍如何建立分区和文件系统类型的联系，即如何格式化分区为指定的文件系统类型。</p><h4 id="常见分区类型"><a href="#常见分区类型" class="headerlink" title="常见分区类型"></a>常见分区类型</h4><p>先来看看 Linux 下文件系统的常见类型（如果要查看所有 Linux 支持的文件类型，可以用 <code>fdisk</code> 命令的 <code>l</code> 命令查看，或者通过 <code>man fs</code> 查看，也可通过 <code>/proc/filesystems</code> 查看到当前内核支持的文件系统类型）</p><ul><li><code>ext2</code>，<code>ext3</code>，<code>ext4</code> ：这三个是 Linux 根文件系统通常采用的类型</li><li><code>swap</code> ：这个是实现 Linux 虚拟内存时采用的一种文件系统，安装时一般需要建立一个专门的分区，并格式化为 <code>swap</code> 文件系统（如果想添加更多 <code>swap</code> 分区，可以参考本节的<a href="http://soft.zdnet.com.cn/software_zone/2007/1010/545261.shtml">参考资料</a>，熟悉 <code>dd</code>，<code>mkswap</code>，<code>swapon</code>，<code>swapoff</code> 等命令的用法）</li><li><code>proc</code> ：这是一种比较特别的文件系统，作为内核和用户之间的一个接口存在，建立在内存中（可以通过 <code>cat</code> 命令查看 <code>/proc</code> 系统下的文件，甚至可以通过修改 <code>/proc/sys</code> 下的文件实时调整内核配置，当前前提是需要把 <code>proc</code> 文件系统挂载上： <code>mount -t proc proc /proc</code></li></ul><p>除了上述文件系统类型外，Linux 支持包括 <code>vfat</code>，<code>iso</code>，<code>xfs</code>，<code>nfs</code> 在内各种常见的文件系统类型，在 Linux 下，可以自由地查看和操作 Windows 等其他操作系统使用的文件系统。</p><p>那么如何建立磁盘和这些文件系统类型的关联呢？格式化。</p><p>格式化的过程实际上就是重新组织分区的过程，可通过 <code>mkfs</code> 命令来实现，当然也可以通过 <code>fdisk</code> 等命令来实现。这里仅介绍 <code>mkfs</code>，<code>mkfs</code> 可用来对一个已有的分区进行格式化，不能实现分区操作（如果要对一个磁盘进行分区和格式化，那么可以用 <code>fdisk</code>）。格式化后，相应分区上的数据就会通过某种特别的文件系统类型进行组织。</p><h4 id="范例：格式化文件系统"><a href="#范例：格式化文件系统" class="headerlink" title="范例：格式化文件系统"></a>范例：格式化文件系统</h4><p>例如：把 <code>/dev/sda9</code> 分区格式化为 <code>ext3</code> 的文件系统。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> -s
<span class="token comment" spellcheck="true"># mkfs -t ext3 /dev/sda9</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果要列出各个分区的文件系统类型，那么可以用 <code>fdisk -l</code> 命令。</p><p>更多信息请参考下列资料。</p><p>参考资料：</p><ul><li><a href="http://soft.zdnet.com.cn/software_zone/2007/1010/545261.shtml">Linux 下加载 swap 分区的步骤</a></li><li><a href="http://www.examda.com/linux/fudao/20071212/113445321.html">Linux 下 ISO 镜像文件的制作与刻录</a></li><li>RAM 磁盘分区解释: <a href="http://oldlinux.org/oldlinux/viewthread.php?tid=2677">[1]</a>, <a href="http://www.ibm.com/developerworks/cn/linux/l-initrd.html">[2]</a></li><li><a href="http://www.ibm.com/Search/?q=高级文件系统实现者指南&v=17&en=utf&lang=en&cc=us">高级文件系统实现者指南</a></li></ul><h3 id="分区、逻辑卷和文件系统的关系"><a href="#分区、逻辑卷和文件系统的关系" class="headerlink" title="分区、逻辑卷和文件系统的关系"></a>分区、逻辑卷和文件系统的关系</h3><p>上一节直接把分区格式化为某种文件系统类型，但是考虑到扩展新的存储设备的需要，开发人员在文件系统和分区之间引入了逻辑卷。考虑到时间关系，这里不再详述，请参考资料：<a href="http://unix-cd.com/vc/www/28/2007-06/1178.html">Linux 逻辑卷管理详解</a></p><h3 id="文件系统的可视化结构"><a href="#文件系统的可视化结构" class="headerlink" title="文件系统的可视化结构"></a>文件系统的可视化结构</h3><p>文件系统最终呈现出来的是一种可视化的结构，可用ls,find,tree等命令把它呈现出来。它就像一颗倒挂的“树”，在树的节点上还可以挂载新的“树”。</p><p>下面简单介绍文件系统的挂载。</p><p>一个文件系统可以通过一个设备挂载（<code>mount</code>）到某个目录下，这个目录被称为挂载点。有趣的是，在 Linux 下，一个目录本身还可以挂载到另外一个目录下，一个格式化了的文件也可以通过一个特殊的设备 <code>/dev/loop</code> 进行挂载（如 <code>iso</code> 文件）。另外，就文件系统而言，Linux 不仅支持本地文件系统，还支持远程文件系统（如 <code>nfs</code>）。</p><h4 id="范例：挂载文件系统"><a href="#范例：挂载文件系统" class="headerlink" title="范例：挂载文件系统"></a>范例：挂载文件系统</h4><p>下面简单介绍文件系统挂载的几个实例。</p><ul><li>根文件系统的挂载</li></ul><p>挂载需要 Root 权限，例如，挂载系统根文件系统 <code>/dev/sda1</code> 到 <code>/mnt</code></p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> -s
<span class="token comment" spellcheck="true"># mount -t ext3 /dev/sda1 /mnt/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看 <code>/dev/sda1</code> 的挂载情况，可以看到，一个设备可以多次挂载</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">mount</span> <span class="token operator">|</span> <span class="token function">grep</span> sda1
/dev/sda1 on / <span class="token function">type</span> ext3 <span class="token punctuation">(</span>rw,errors<span class="token operator">=</span>remount-ro<span class="token punctuation">)</span>
/dev/sda1 on /mnt <span class="token function">type</span> ext3 <span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对于一个已经挂载的文件系统，为支持不同属性可以重新挂载</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">mount</span> -n -o remount, rw /<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>挂载一个新增设备</li></ul><p>如果内核已经支持 USB 接口，那么插入 u 盘时，可以通过 <code>dmesg</code> 命令查看对应的设备号，并挂载它。</p><p>查看 <code>dmesg</code> 结果中的最后几行内容，找到类似 <code>/dev/sdN</code> 的信息，找出 u 盘对应的设备号</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">dmesg</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里假设 u 盘是 <code>vfat</code> 格式，以便在一些打印店里的 Windows 上也可使用</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># mount -t vfat /dev/sdN /path/to/mountpoint_directory</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>挂载一个 iso 文件或者是光盘</li></ul><p>对于一些iso文件或者是 iso 格式的光盘，同样可以通过 <code>mount</code> 命令挂载。</p><p>对于 iso 文件：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># mount -t iso9660 /path/to/isofile /path/to/mountpoint_directory</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于光盘：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># mount -t iso9660 /dev/cdrom /path/to/mountpoint_directory</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>挂载一个远程文件系统</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># mount -t nfs remote_ip:/path/to/share_directory /path/to/local_directory</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>挂载一个 proc 文件系统</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># mount -t proc proc /proc</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>proc</code> 文件系统组织在内存中，但是可以把它挂载到某个目录下。通常把它挂载在 <code>/proc</code> 目录下，以便一些系统管理和配置工具使用它。例如 <code>top</code> 命令用它分析内存的使用情况（读取 <code>/proc/meminfo</code> 和 <code>/proc/stat</code> 等文件中的内容）； <code>lsmod</code> 命令通过它获取内核模块的状态（读取 <code>/proc/modules</code>）； <code>netstat</code> 命令通过它获取网络的状态（读取 <code>/proc/net/dev</code> 等文件）。当然，也可以编写相关工具。除此之外，通过调整 <code>/proc/sys</code> 目录下的文件，可以动态地调整系统配置，比如往 <code>/proc/sys/net/ipv4/ip_forward</code> 文件中写入数字 1 就可以让内核支持数据包转发。（更多信息请参考 <code>proc</code> 的帮助，<code>man</code> <code>proc</code>）</p><ul><li>挂载一个目录</li></ul><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">mount</span> --bind /path/to/needtomount_directory /path/to/mountpoint_directory<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个非常有意思，比如可以把某个目录挂载到 ftp 服务的根目录下，而无须把内容复制过去，就可以把相应目录中的资源提供给别人共享。</p><h4 id="范例：卸载某个分区"><a href="#范例：卸载某个分区" class="headerlink" title="范例：卸载某个分区"></a>范例：卸载某个分区</h4><p>以上都只提到了挂载，那怎么卸载呢？用 <code>umount</code> 命令跟上挂载的源地址或者挂载点（设备，文件，远程目录等）就可以。例如：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">umount</span> /path/to/mountpoint_directory<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">umount</span> /path/to/mount_source<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果想管理大量的或者经常性的挂载服务，那么每次手动挂载是很糟糕的事情。这时就可利用 <code>mount</code> 的配置文件 <code>/etc/fstab</code>，把 <code>mount</code> 对应的参数写到 <code>/etc/fstab</code> 文件对应的列中即可实现批量挂载（ <code>mount -a</code> ）和卸载（ <code>umount -a</code> ）。 <code>/etc/fstab</code> 中各列分别为文件系统、挂载点、类型、相关选项。更多信息可参考 <code>fstab</code> 的帮助（ <code>man fstab</code> ）。</p><p>参考资料：</p><ul><li><a href="http://www.xxlinux.com/linux/article/accidence/technique/20070521/8493.html">Linux 硬盘分区以及其挂载原理</a></li><li><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-vfs/">从文件 I/O 看 Linux 的虚拟文件系统</a></li><li><a href="http://www.tinylab.org/callgraph-draw-the-calltree-of-c-functions/">源码分析：静态分析 C 程序函数调用关系图</a></li></ul><h3 id="如何制作一个文件系统"><a href="#如何制作一个文件系统" class="headerlink" title="如何制作一个文件系统"></a>如何制作一个文件系统</h3><p>Linux 文件系统下有一些最基本的目录，不同的目录下存放着不同作用的各类文件。最基本的目录有 <code>/etc</code>，<code>/lib</code>，<code>/dev</code>，<code>/bin</code> 等，它们分别存放着系统配置文件，库文件，设备文件和可执行程序。这些目录一般情况下是必须的，在做嵌入式开发时，需要手动或者是用 <code>busybox</code> 等工具来创建这样一个基本的文件系统。这里仅制作一个非常简单的文件系统，并对该文件系统进行各种常规操作，以便加深对文件系统的理解。</p><h4 id="范例：用-dd-创建一个固定大小的文件"><a href="#范例：用-dd-创建一个固定大小的文件" class="headerlink" title="范例：用 dd 创建一个固定大小的文件"></a>范例：用 dd 创建一个固定大小的文件</h4><p>还记得 <code>dd</code> 命令么？就用它来产生一个固定大小的文件，这个为 <code>1M(1024\*1024 bytes)</code> 的文件</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">dd</span> if<span class="token operator">=</span>/dev/zero of<span class="token operator">=</span>minifs bs<span class="token operator">=</span>1024 count<span class="token operator">=</span>1024<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看文件类型，这里的 <code>minifs</code> 是一个充满 <code>\\0</code> 的文件，没有任何特定的数据结构</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">file</span> minifs
minifs: data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>说明： <code>/dev/zero</code> 是一个非常特殊的设备，如果读取它，可以获取任意多个 <code>\\0</code> 。</p><p>接着把该文件格式化为某个指定文件类型的文件系统。（是不是觉得不可思议，文件也可以格式化？是的，不光是设备可以，文件也可以以某种文件系统类型进行组织，但是需要注意的是，某些文件系统（如 <code>ext3</code>）要求被格式化的目标最少有 <code>64M</code> 的空间）。</p><h4 id="范例：用-mkfs-格式化文件"><a href="#范例：用-mkfs-格式化文件" class="headerlink" title="范例：用 mkfs 格式化文件"></a>范例：用 mkfs 格式化文件</h4><pre class="line-numbers language-bash"><code class="language-bash">$ mkfs.ext2 minifs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看此时的文件类型，这时文件 <code>minifs</code> 就以 <code>ext2</code> 文件系统的格式组织了</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">file</span> minifs
minifs: Linux <span class="token function">rev</span> 1.0 ext2 filesystem data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="范例：挂载刚创建的文件系统"><a href="#范例：挂载刚创建的文件系统" class="headerlink" title="范例：挂载刚创建的文件系统"></a>范例：挂载刚创建的文件系统</h4><p>因为该文件以文件系统的类型组织了，那么可以用 <code>mount</code> 命令挂载并使用它。</p><p>请切换到 <code>root</code> 用户挂载它，并通过 <code>-o loop</code> 选项把它关联到一个特殊设备 <code>/dev/loop</code></p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> -s
<span class="token comment" spellcheck="true"># mount minifs /mnt/ -o loop</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看该文件系统信息，仅可以看到一个目录文件 <code>lost+found</code></p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ls</span> /mnt/
lost+found<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="范例：对文件系统进行读、写、删除等操作"><a href="#范例：对文件系统进行读、写、删除等操作" class="headerlink" title="范例：对文件系统进行读、写、删除等操作"></a>范例：对文件系统进行读、写、删除等操作</h4><p>在该文件系统下进行各种常规操作，包括读、写、删除等。(每次操作前先把 <code>minifs</code> 文件保存一份，以便比较，结合相关资料就可以深入地分析各种操作对文件系统的改变情况，从而深入理解文件系统作为一种组织数据的方式的实现原理等)</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cp</span> minifs minifs.bak
$ <span class="token function">cd</span> /mnt
$ <span class="token function">touch</span> hello
$ <span class="token function">cd</span> -
$ <span class="token function">cp</span> minifs minifs-touch.bak
$ od -x minifs.bak <span class="token operator">></span> orig.od
$ od -x minifs-touch.bak <span class="token operator">></span> touch.od<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建一个文件后，比较此时文件系统和之前文件系统的异同</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">diff</span> orig.od touch.od
<span class="token function">diff</span> orig.od touch.od
61,63c61,64
<span class="token operator">&lt;</span> 0060020 000c 0202 2e2e 0000 000b 0000 03e8 020a
<span class="token operator">&lt;</span> 0060040 6f6c 7473 662b 756f 646e 0000 0000 0000
<span class="token operator">&lt;</span> 0060060 0000 0000 0000 0000 0000 0000 0000 0000
---
<span class="token operator">></span> 0060020 000c 0202 2e2e 0000 000b 0000 0014 020a
<span class="token operator">></span> 0060040 6f6c 7473 662b 756f 646e 0000 000c 0000
<span class="token operator">></span> 0060060 03d4 0105 6568 6c6c 006f 0000 0000 0000
<span class="token operator">></span> 0060100 0000 0000 0000 0000 0000 0000 0000 0000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过比较发现：添加文件，文件系统的相应位置发生了明显的变化</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token string">"hello, world"</span> <span class="token operator">></span> /mnt/hello<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行 <code>sync</code> 命令，确保缓存中的数据已经写入磁盘（还记得本节图 1 的 <code>buffer cache</code> 吧，这里就是把 <code>cache</code> 中的数据写到磁盘中）</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sync</span>
$ <span class="token function">cp</span> minifs minifs-echo.bak
$ od -x minifs-echo.bak <span class="token operator">></span> echo.od<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>写入文件内容后，比较文件系统和之前的异同</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">diff</span> touch.od echo.od<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看文件系统中的字符串</p><pre class="line-numbers language-bash"><code class="language-bash">$ strings minifs
lost+found
hello
hello, world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>删除 <code>hello</code> 文件，查看文件系统变化</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">rm</span> /mnt/hello
$ <span class="token function">cp</span> minifs minifs-rm.bak
$ od -x minifs-rm.bak <span class="token operator">></span> rm.od
$ <span class="token function">diff</span> echo.od rm.od<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过查看文件系统的字符串发现：删除文件时并没有覆盖文件内容，所以从理论上说内容此时还是可恢复的</p><pre class="line-numbers language-bash"><code class="language-bash">$ strings minifs
lost+found
hello
hello, world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面仅仅演示了一些分析文件系统的常用工具，并分析了几个常规的操作，如果想非常深入地理解文件系统的实现原理，请熟悉使用上述工具并阅读相关资料。</p><p>参考资料：</p><ul><li><a href="http://202.201.1.130:8080/docs/summer_school_2007/team3/doc/build_a_mini_filesystem_from_scratch">Build a mini filesystem in linux from scratch</a></li><li><a href="http://202.201.1.130:8080/docs/summer_school_2007/team3/doc/build_a_mini_filesystem_with_busybox">Build a mini filesystem in linux with BusyBox</a></li><li><a href="http://man.chinaunix.net/tech/lyceum/linuxK/fs/filesystem.html">ext2 文件系统</a></li></ul><h3 id="如何开发自己的文件系统"><a href="#如何开发自己的文件系统" class="headerlink" title="如何开发自己的文件系统"></a>如何开发自己的文件系统</h3><p>随着 <code>fuse</code> 的出现，在用户空间开发文件系统成为可能，如果想开发自己的文件系统，那么推荐阅读：<a href="http://www.ibm.com/developerworks/cn/linux/l-fuse/">使用 fuse 开发自己的文件系统</a>。</p><h2 id="进程操作"><a href="#进程操作" class="headerlink" title="进程操作"></a>进程操作</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>进程作为程序真正发挥作用时的“形态”，我们有必要对它的一些相关操作非常熟悉，这一节主要描述进程相关的概念和操作，将介绍包括程序、进程、作业等基本概念以及进程状态查询、进程通信等相关的操作。</p><p>###什么是程序，什么又是进程</p><p>程序是指令的集合，而进程则是程序执行的基本单元。为了让程序完成它的工作，必须让程序运行起来成为进程，进而利用处理器资源、内存资源，进行各种 <code>I/O</code> 操作，从而完成某项特定工作。</p><p>从这个意思上说，程序是静态的，而进程则是动态的。</p><p>进程有区别于程序的地方还有：进程除了包含程序文件中的指令数据以外，还需要在内核中有一个数据结构用以存放特定进程的相关属性，以便内核更好地管理和调度进程，从而完成多进程协作的任务。因此，从这个意义上可以说“高于”程序，超出了程序指令本身。</p><p>如果进行过多进程程序的开发，又会发现，一个程序可能创建多个进程，通过多个进程的交互完成任务。在 Linux 下，多进程的创建通常是通过 <code>fork</code> 系统调用来实现。从这个意义上来说程序则”包含”了进程。</p><p>另外一个需要明确的是，程序可以由多种不同程序语言描述，包括 C 语言程序、汇编语言程序和最后编译产生的机器指令等。</p><p>下面简单讨论 Linux 下面如何通过 Shell 进行进程的相关操作。</p><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>通常在命令行键入某个程序文件名以后，一个进程就被创建了。例如，</p><h4 id="范例：让程序在后台运行"><a href="#范例：让程序在后台运行" class="headerlink" title="范例：让程序在后台运行"></a>范例：让程序在后台运行</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sleep</span> 100 <span class="token operator">&amp;</span>
<span class="token punctuation">[</span>1<span class="token punctuation">]</span> 9298<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="范例：查看进程-ID"><a href="#范例：查看进程-ID" class="headerlink" title="范例：查看进程 ID"></a>范例：查看进程 ID</h4><p>用<code>pidof</code>可以查看指定程序名的进程ID：</p><pre class="line-numbers language-bash"><code class="language-bash">$ pidof <span class="token function">sleep</span>
9298<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="范例：查看进程的内存映像"><a href="#范例：查看进程的内存映像" class="headerlink" title="范例：查看进程的内存映像"></a>范例：查看进程的内存映像</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> /proc/9298/maps
08048000-0804b000 r-xp 00000000 08:01 977399     /bin/sleep
0804b000-0804c000 rw-p 00003000 08:01 977399     /bin/sleep
0804c000-0806d000 rw-p 0804c000 00:00 0          <span class="token punctuation">[</span>heap<span class="token punctuation">]</span>
b7c8b000-b7cca000 r--p 00000000 08:01 443354
<span class="token punctuation">..</span>.
bfbd8000-bfbed000 rw-p bfbd8000 00:00 0          <span class="token punctuation">[</span>stack<span class="token punctuation">]</span>
ffffe000-fffff000 r-xp 00000000 00:00 0          <span class="token punctuation">[</span>vdso<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序被执行后，就被加载到内存中，成为了一个进程。上面显示了该进程的内存映像（虚拟内存），包括程序指令、数据，以及一些用于存放程序命令行参数、环境变量的栈空间，用于动态内存申请的堆空间都被分配好。</p><p>实际上，创建一个进程，也就是说让程序运行，还有其他的办法，比如，通过一些配置让系统启动时自动启动程序（具体参考 <code>man init</code>），或者是通过配置 <code>crond</code> （或者 <code>at</code>）让它定时启动程序。除此之外，还有一个方式，那就是编写 Shell 脚本，把程序写入一个脚本文件，当执行脚本文件时，文件中的程序将被执行而成为进程。这些方式的细节就不介绍，下面了解如何查看进程的属性。</p><p>需要补充一点的是：在命令行下执行程序，可以通过 <code>ulimit</code> 内置命令来设置进程可以利用的资源，比如进程可以打开的最大文件描述符个数，最大的栈空间，虚拟内存空间等。具体用法见 <code>help ulimit</code> 。</p><h3 id="查看进程的属性和状态"><a href="#查看进程的属性和状态" class="headerlink" title="查看进程的属性和状态"></a>查看进程的属性和状态</h3><p>可以通过 <code>ps</code> 命令查看进程相关属性和状态，这些信息包括进程所属用户，进程对应的程序，进程对 <code>cpu</code> 和内存的使用情况等信息。熟悉如何查看它们有助于进行相关的统计分析等操作。</p><h4 id="范例：通过-ps-命令查看进程属性"><a href="#范例：通过-ps-命令查看进程属性" class="headerlink" title="范例：通过 ps 命令查看进程属性"></a>范例：通过 ps 命令查看进程属性</h4><p>查看系统当前所有进程的属性：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ps</span> -ef<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看命令中包含某字符的程序对应的进程，进程 <code>ID</code> 是 1 。 <code>TTY</code> 为？表示和终端没有关联：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ps</span> -C init
  PID TTY          TIME CMD
    1 ?        00:00:01 init<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>选择某个特定用户启动的进程：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ps</span> -U falcon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>按照指定格式输出指定内容，下面输出命令名和 <code>cpu</code> 使用率：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ps</span> -e -o <span class="token string">"%C %c"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打印 <code>cpu</code> 使用率最高的前 4 个程序：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ps</span> -e -o <span class="token string">"%C %c"</span> <span class="token operator">|</span> <span class="token function">sort</span> -u -k1 -r <span class="token operator">|</span> <span class="token function">head</span> -5
 7.5 firefox-bin
 1.1 Xorg
 0.8 scim-panel-gtk
 0.2 scim-bridge<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>获取使用虚拟内存最大的 5 个进程：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ps</span> -e -o <span class="token string">"%z %c"</span> <span class="token operator">|</span> <span class="token function">sort</span> -n -k1 -r <span class="token operator">|</span> <span class="token function">head</span> -5
349588 firefox-bin
 96612 xfce4-terminal
 88840 xfdesktop
 76332 gedit
 58920 scim-panel-gt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="范例：通过-pstree-查看进程亲缘关系"><a href="#范例：通过-pstree-查看进程亲缘关系" class="headerlink" title="范例：通过 pstree 查看进程亲缘关系"></a>范例：通过 pstree 查看进程亲缘关系</h4><p>系统所有进程之间都有“亲缘”关系，可以通过 <code>pstree</code> 查看这种关系：</p><pre class="line-numbers language-bash"><code class="language-bash">$ pstree<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面会打印系统进程调用树，可以非常清楚地看到当前系统中所有活动进程之间的调用关系。</p><h4 id="范例：用top动态查看进程信息"><a href="#范例：用top动态查看进程信息" class="headerlink" title="范例：用top动态查看进程信息"></a>范例：用top动态查看进程信息</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">top</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该命令最大特点是可以动态地查看进程信息，当然，它还提供了一些其他的参数，比如 <code>-S</code> 可以按照累计执行时间的大小排序查看，也可以通过 <code>-u</code> 查看指定用户启动的进程等。</p><p>补充： <code>top</code> 命令支持交互式，比如它支持 <code>u</code> 命令显示用户的所有进程，支持通过 <code>k</code> 命令杀掉某个进程；如果使用 <code>-n 1</code> 选项可以启用批处理模式，具体用法为：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">top</span> -n 1 -b<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="范例：确保特定程序只有一个副本在运行"><a href="#范例：确保特定程序只有一个副本在运行" class="headerlink" title="范例：确保特定程序只有一个副本在运行"></a>范例：确保特定程序只有一个副本在运行</h4><p>下面来讨论一个有趣的问题：如何让一个程序在同一时间只有一个在运行。</p><p>这意味着当一个程序正在被执行时，它将不能再被启动。那该怎么做呢？</p><p>假如一份相同的程序被复制成了很多份，并且具有不同的文件名被放在不同的位置，这个将比较糟糕，所以考虑最简单的情况，那就是这份程序在整个系统上是唯一的，而且名字也是唯一的。这样的话，有哪些办法来回答上面的问题呢？</p><p>总的机理是：在程序开头检查自己有没有执行，如果执行了则停止否则继续执行后续代码。</p><p>策略则是多样的，由于前面的假设已经保证程序文件名和代码的唯一性，所以通过 <code>ps</code> 命令找出当前所有进程对应的程序名，逐个与自己的程序名比较，如果已经有，那么说明自己已经运行了。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">ps</span> -e -o <span class="token string">"%c"</span> <span class="token operator">|</span> <span class="token function">tr</span> -d <span class="token string">" "</span> <span class="token operator">|</span> <span class="token function">grep</span> -q ^init$   <span class="token comment" spellcheck="true">#查看当前程序是否执行</span>
<span class="token punctuation">[</span> <span class="token variable">$?</span> -eq 0 <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">exit</span>   <span class="token comment" spellcheck="true">#如果在，那么退出, $?表示上一条指令是否执行成功</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>每次运行时先在指定位置检查是否存在一个保存自己进程 <code>ID</code> 的文件，如果不存在，那么继续执行，如果存在，那么查看该进程 <code>ID</code> 是否正在运行，如果在，那么退出，否则往该文件重新写入新的进程 <code>ID</code>，并继续。</p><pre class="line-numbers language-bash"><code class="language-bash">pidfile<span class="token operator">=</span>/tmp/<span class="token variable">$0</span><span class="token string">".pid"</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> -f <span class="token variable">$pidfile</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
       OLDPID<span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">cat</span> $pidfile<span class="token variable">)</span></span>
    <span class="token function">ps</span> -e -o <span class="token string">"%p"</span> <span class="token operator">|</span> <span class="token function">tr</span> -d <span class="token string">" "</span> <span class="token operator">|</span> <span class="token function">grep</span> -q <span class="token string">"^<span class="token variable">$OLDPID</span>$"</span>
    <span class="token punctuation">[</span> <span class="token variable">$?</span> -eq 0 <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">exit</span>
<span class="token keyword">fi</span>

<span class="token keyword">echo</span> $$ <span class="token operator">></span> <span class="token variable">$pidfile</span>

<span class="token comment" spellcheck="true">#... 代码主体</span>

<span class="token comment" spellcheck="true">#设置信号0的动作，当程序退出时触发该信号从而删除掉临时文件</span>
<span class="token function">trap</span> <span class="token string">"rm <span class="token variable">$pidfile</span>"</span>      0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更多实现策略自己尽情发挥吧！</p><h3 id="调整进程的优先级"><a href="#调整进程的优先级" class="headerlink" title="调整进程的优先级"></a>调整进程的优先级</h3><p>在保证每个进程都能够顺利执行外，为了让某些任务优先完成，那么系统在进行进程调度时就会采用一定的调度办法，比如常见的有按照优先级的时间片轮转的调度算法。这种情况下，可以通过 <code>renice</code> 调整正在运行的程序的优先级，例如：`</p><h4 id="范例：获取进程优先级"><a href="#范例：获取进程优先级" class="headerlink" title="范例：获取进程优先级"></a>范例：获取进程优先级</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ps</span> -e -o <span class="token string">"%p %c %n"</span> <span class="token operator">|</span> <span class="token function">grep</span> xfs
 5089 xfs               0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="范例：调整进程的优先级"><a href="#范例：调整进程的优先级" class="headerlink" title="范例：调整进程的优先级"></a>范例：调整进程的优先级</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">renice</span> 1 -p 5089
renice: 5089: setpriority: Operation not permitted
$ <span class="token function">sudo</span> <span class="token function">renice</span> 1 -p 5089   <span class="token comment" spellcheck="true">#需要权限才行</span>
<span class="token punctuation">[</span>sudo<span class="token punctuation">]</span> password <span class="token keyword">for</span> falcon:
5089: old priority 0, new priority 1
$ <span class="token function">ps</span> -e -o <span class="token string">"%p %c %n"</span> <span class="token operator">|</span> <span class="token function">grep</span> xfs  <span class="token comment" spellcheck="true">#再看看，优先级已经被调整过来了</span>
 5089 xfs               1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h3><p>既然可以通过命令行执行程序，创建进程，那么也有办法结束它。可以通过 <code>kill</code> 命令给用户自己启动的进程发送某个信号让进程终止，当然“万能”的 <code>root</code> 几乎可以 <code>kill</code> 所有进程（除了 <code>init</code> 之外）。例如，</p><h4 id="范例：结束进程"><a href="#范例：结束进程" class="headerlink" title="范例：结束进程"></a>范例：结束进程</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sleep</span> 50 <span class="token operator">&amp;</span>   <span class="token comment" spellcheck="true">#启动一个进程</span>
<span class="token punctuation">[</span>1<span class="token punctuation">]</span> 11347
$ <span class="token function">kill</span> 11347<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>kill</code> 命令默认会发送终止信号（ <code>SIGTERM</code> ）给程序，让程序退出，但是 <code>kill</code> 还可以发送其他信号，这些信号的定义可以通过 <code>man 7 signal</code> 查看到，也可以通过 <code>kill -l</code> 列出来。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">man</span> 7 signal
$ <span class="token function">kill</span> -l
 1<span class="token punctuation">)</span> SIGHUP       2<span class="token punctuation">)</span> SIGINT       3<span class="token punctuation">)</span> SIGQUIT      4<span class="token punctuation">)</span> SIGILL
 5<span class="token punctuation">)</span> SIGTRAP      6<span class="token punctuation">)</span> SIGABRT      7<span class="token punctuation">)</span> SIGBUS       8<span class="token punctuation">)</span> SIGFPE
 9<span class="token punctuation">)</span> SIGKILL     10<span class="token punctuation">)</span> SIGUSR1     11<span class="token punctuation">)</span> SIGSEGV     12<span class="token punctuation">)</span> SIGUSR2
13<span class="token punctuation">)</span> SIGPIPE     14<span class="token punctuation">)</span> SIGALRM     15<span class="token punctuation">)</span> SIGTERM     16<span class="token punctuation">)</span> SIGSTKFLT
17<span class="token punctuation">)</span> SIGCHLD     18<span class="token punctuation">)</span> SIGCONT     19<span class="token punctuation">)</span> SIGSTOP     20<span class="token punctuation">)</span> SIGTSTP
21<span class="token punctuation">)</span> SIGTTIN     22<span class="token punctuation">)</span> SIGTTOU     23<span class="token punctuation">)</span> SIGURG      24<span class="token punctuation">)</span> SIGXCPU
25<span class="token punctuation">)</span> SIGXFSZ     26<span class="token punctuation">)</span> SIGVTALRM   27<span class="token punctuation">)</span> SIGPROF     28<span class="token punctuation">)</span> SIGWINCH
29<span class="token punctuation">)</span> SIGIO       30<span class="token punctuation">)</span> SIGPWR      31<span class="token punctuation">)</span> SIGSYS      34<span class="token punctuation">)</span> SIGRTMIN
35<span class="token punctuation">)</span> SIGRTMIN+1  36<span class="token punctuation">)</span> SIGRTMIN+2  37<span class="token punctuation">)</span> SIGRTMIN+3  38<span class="token punctuation">)</span> SIGRTMIN+4
39<span class="token punctuation">)</span> SIGRTMIN+5  40<span class="token punctuation">)</span> SIGRTMIN+6  41<span class="token punctuation">)</span> SIGRTMIN+7  42<span class="token punctuation">)</span> SIGRTMIN+8
43<span class="token punctuation">)</span> SIGRTMIN+9  44<span class="token punctuation">)</span> SIGRTMIN+10 45<span class="token punctuation">)</span> SIGRTMIN+11 46<span class="token punctuation">)</span> SIGRTMIN+12
47<span class="token punctuation">)</span> SIGRTMIN+13 48<span class="token punctuation">)</span> SIGRTMIN+14 49<span class="token punctuation">)</span> SIGRTMIN+15 50<span class="token punctuation">)</span> SIGRTMAX-14
51<span class="token punctuation">)</span> SIGRTMAX-13 52<span class="token punctuation">)</span> SIGRTMAX-12 53<span class="token punctuation">)</span> SIGRTMAX-11 54<span class="token punctuation">)</span> SIGRTMAX-10
55<span class="token punctuation">)</span> SIGRTMAX-9  56<span class="token punctuation">)</span> SIGRTMAX-8  57<span class="token punctuation">)</span> SIGRTMAX-7  58<span class="token punctuation">)</span> SIGRTMAX-6
59<span class="token punctuation">)</span> SIGRTMAX-5  60<span class="token punctuation">)</span> SIGRTMAX-4  61<span class="token punctuation">)</span> SIGRTMAX-3  62<span class="token punctuation">)</span> SIGRTMAX-2
63<span class="token punctuation">)</span> SIGRTMAX-1  64<span class="token punctuation">)</span> SIGRTMAX<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="范例：暂停某个进程"><a href="#范例：暂停某个进程" class="headerlink" title="范例：暂停某个进程"></a>范例：暂停某个进程</h4><p>例如，用 <code>kill</code> 命令发送 <code>SIGSTOP</code> 信号给某个程序，让它暂停，然后发送 <code>SIGCONT</code> 信号让它继续运行。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sleep</span> 50 <span class="token operator">&amp;</span>
<span class="token punctuation">[</span>1<span class="token punctuation">]</span> 11441
$ <span class="token function">jobs</span>
<span class="token punctuation">[</span>1<span class="token punctuation">]</span>+  Running                 <span class="token function">sleep</span> 50 <span class="token operator">&amp;</span>
$ <span class="token function">kill</span> -s SIGSTOP 11441   <span class="token comment" spellcheck="true">#这个等同于我们对一个前台进程执行CTRL+Z操作</span>
$ <span class="token function">jobs</span>
<span class="token punctuation">[</span>1<span class="token punctuation">]</span>+  Stopped                 <span class="token function">sleep</span> 50
$ <span class="token function">kill</span> -s SIGCONT 11441   <span class="token comment" spellcheck="true">#这个等同于之前我们使用bg %1操作让一个后台进程运行起来</span>
$ <span class="token function">jobs</span>
<span class="token punctuation">[</span>1<span class="token punctuation">]</span>+  Running                 <span class="token function">sleep</span> 50 <span class="token operator">&amp;</span>
$ <span class="token function">kill</span> %1                  <span class="token comment" spellcheck="true">#在当前会话(session)下，也可以通过作业号控制进程</span>
$ <span class="token function">jobs</span>
<span class="token punctuation">[</span>1<span class="token punctuation">]</span>+  Terminated              <span class="token function">sleep</span> 50<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见 <code>kill</code> 命令提供了非常好的功能，不过它只能根据进程的 <code>ID</code> 或者作业来控制进程，而 <code>pkill</code> 和 <code>killall</code> 提供了更多选择，它们扩展了通过程序名甚至是进程的用户名来控制进程的方法。更多用法请参考它们的手册。</p><h4 id="范例：查看进程退出状态"><a href="#范例：查看进程退出状态" class="headerlink" title="范例：查看进程退出状态"></a>范例：查看进程退出状态</h4><p>当程序退出后，如何判断这个程序是正常退出还是异常退出呢？还记得 Linux 下，那个经典 <code>hello world</code> 程序吗？在代码的最后总是有条 <code>return 0</code> 语句。这个 <code>return 0</code> 实际上是让程序员来检查进程是否正常退出的。如果进程返回了一个其他的数值，那么可以肯定地说这个进程异常退出了，因为它都没有执行到 <code>return 0</code> 这条语句就退出了。</p><p>那怎么检查进程退出的状态，即那个返回的数值呢？</p><p>在 <code>Shell</code> 中，可以检查这个特殊的变量 <code>$?</code>，它存放了上一条命令执行后的退出状态。</p><pre class="line-numbers language-bash"><code class="language-bash">$ test1
bash: test1: <span class="token function">command</span> not found
$ <span class="token keyword">echo</span> <span class="token variable">$?</span>
127
$ <span class="token function">cat</span> ./test.c <span class="token operator">|</span> <span class="token function">grep</span> hello
$ <span class="token keyword">echo</span> <span class="token variable">$?</span>
1
$ <span class="token function">cat</span> ./test.c <span class="token operator">|</span> <span class="token function">grep</span> hi
    printf<span class="token punctuation">(</span><span class="token string">"hi, myself!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
$ <span class="token keyword">echo</span> <span class="token variable">$?</span>
0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>貌似返回 0 成为了一个潜规则，虽然没有标准明确规定，不过当程序正常返回时，总是可以从 <code>$?</code> 中检测到 0，但是异常时，总是检测到一个非 0 值。这就告诉我们在程序的最后最好是跟上一个 <code>exit 0</code> 以便任何人都可以通过检测 <code>$?</code> 确定程序是否正常结束。如果有一天，有人偶尔用到你的程序，试图检查它的退出状态，而你却在程序的末尾莫名地返回了一个 <code>-1</code> 或者 1，那么他将会很苦恼，会怀疑他自己编写的程序到底哪个地方出了问题，检查半天却不知所措，因为他太信任你了，竟然从头至尾都没有怀疑你的编程习惯可能会与众不同！</p><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>为便于设计和实现，通常一个大型的任务都被划分成较小的模块。不同模块之间启动后成为进程，它们之间如何通信以便交互数据，协同工作呢？在《UNIX 环境高级编程》一书中提到很多方法，诸如管道（无名管道和有名管道）、信号（<code>signal</code>）、报文（<code>Message</code>）队列（消息队列）、共享内存（<code>mmap/munmap</code>）、信号量（<code>semaphore</code>，主要是同步用，进程之间，进程的不同线程之间）、套接口（<code>Socket</code>，支持不同机器之间的进程通信）等，而在 Shell 中，通常直接用到的就有管道和信号等。下面主要介绍管道和信号机制在 Shell 编程时的一些用法。</p><h4 id="范例：无名管道（pipe）"><a href="#范例：无名管道（pipe）" class="headerlink" title="范例：无名管道（pipe）"></a>范例：无名管道（pipe）</h4><p>在 Linux 下，可以通过 <code>|</code> 连接两个程序，这样就可以用它来连接后一个程序的输入和前一个程序的输出，因此被形象地叫做个管道。在 C 语言中，创建无名管道非常简单方便，用 <code>pipe</code> 函数，传入一个具有两个元素的 <code>int</code> 型的数组就可以。这个数组实际上保存的是两个文件描述符，父进程往第一个文件描述符里头写入东西后，子进程可以从第一个文件描述符中读出来。</p><p>如果用多了命令行，这个管子 <code>|</code> 应该会经常用。比如上面有个演示把 <code>ps</code> 命令的输出作为 <code>grep</code> 命令的输入：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ps</span> -ef <span class="token operator">|</span> <span class="token function">grep</span> init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也许会觉得这个“管子”好有魔法，竟然真地能够链接两个程序的输入和输出，它们到底是怎么实现的呢？实际上当输入这样一组命令时，当前 Shell 会进行适当的解析，把前面一个进程的输出关联到管道的输出文件描述符，把后面一个进程的输入关联到管道的输入文件描述符，这个关联过程通过输入输出重定向函数 <code>dup</code> （或者 <code>fcntl</code> ）来实现。</p><h4 id="范例：有名管道（named-pipe）"><a href="#范例：有名管道（named-pipe）" class="headerlink" title="范例：有名管道（named pipe）"></a>范例：有名管道（named pipe）</h4><p>有名管道实际上是一个文件（无名管道也像一个文件，虽然关系到两个文件描述符，不过只能一边读另外一边写），不过这个文件比较特别，操作时要满足先进先出，而且，如果试图读一个没有内容的有名管道，那么就会被阻塞，同样地，如果试图往一个有名管道里写东西，而当前没有程序试图读它，也会被阻塞。下面看看效果。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">mkfifo</span> fifo_test    <span class="token comment" spellcheck="true">#通过mkfifo命令创建一个有名管道</span>
$ <span class="token keyword">echo</span> <span class="token string">"fewfefe"</span> <span class="token operator">></span> fifo_test
<span class="token comment" spellcheck="true">#试图往fifo_test文件中写入内容，但是被阻塞，要另开一个终端继续下面的操作</span>
$ <span class="token function">cat</span> fifo_test        <span class="token comment" spellcheck="true">#另开一个终端，记得，另开一个。试图读出fifo_test的内容</span>
fewfefe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的 <code>echo</code> 和 <code>cat</code> 是两个不同的程序，在这种情况下，通过 <code>echo</code> 和 <code>cat</code> 启动的两个进程之间并没有父子关系。不过它们依然可以通过有名管道通信。</p><p>这样一种通信方式非常适合某些特定情况：例如有这样一个架构，这个架构由两个应用程序构成，其中一个通过循环不断读取 <code>fifo_test</code> 中的内容，以便判断，它下一步要做什么。如果这个管道没有内容，那么它就会被阻塞在那里，而不会因死循环而耗费资源，另外一个则作为一个控制程序不断地往 <code>fifo_test</code> 中写入一些控制信息，以便告诉之前的那个程序该做什么。下面写一个非常简单的例子。可以设计一些控制码，然后控制程序不断地往 <code>fifo_test</code> 里头写入，然后应用程序根据这些控制码完成不同的动作。当然，也可以往 <code>fifo_test</code> 传入除控制码外的其他数据。</p><ul><li><p>应用程序的代码</p><pre class="line-numbers language-bash"><code class="language-bash">  $ <span class="token function">cat</span> app.sh
  <span class="token comment" spellcheck="true">#!/bin/bash</span>

  FIFO<span class="token operator">=</span>fifo_test
  <span class="token keyword">while</span> <span class="token keyword">:</span><span class="token punctuation">;</span>
  <span class="token keyword">do</span>
      CI<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">cat</span> $FIFO<span class="token variable">`</span></span>  <span class="token comment" spellcheck="true">#CI --> Control Info</span>
      <span class="token keyword">case</span> <span class="token variable">$CI</span> <span class="token keyword">in</span>
          0<span class="token punctuation">)</span> <span class="token keyword">echo</span> <span class="token string">"The CONTROL number is ZERO, do something ..."</span>
              <span class="token punctuation">;</span><span class="token punctuation">;</span>
          1<span class="token punctuation">)</span> <span class="token keyword">echo</span> <span class="token string">"The CONTROL number is ONE, do something ..."</span>
              <span class="token punctuation">;</span><span class="token punctuation">;</span>
          *<span class="token punctuation">)</span> <span class="token keyword">echo</span> <span class="token string">"The CONTROL number not recognized, do something else..."</span>
              <span class="token punctuation">;</span><span class="token punctuation">;</span>
      esac
  <span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>控制程序的代码</p><pre class="line-numbers language-bash"><code class="language-bash">  $ <span class="token function">cat</span> control.sh
  <span class="token comment" spellcheck="true">#!/bin/bash</span>

  FIFO<span class="token operator">=</span>fifo_test
  CI<span class="token operator">=</span><span class="token variable">$1</span>

  <span class="token punctuation">[</span> -z <span class="token string">"<span class="token variable">$CI</span>"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">echo</span> <span class="token string">"the control info should not be empty"</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">exit</span>

  <span class="token keyword">echo</span> <span class="token variable">$CI</span> <span class="token operator">></span> <span class="token variable">$FIFO</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>一个程序通过管道控制另外一个程序的工作</p><pre class="line-numbers language-bash"><code class="language-bash">  $ <span class="token function">chmod</span> +x app.sh control.sh    <span class="token comment" spellcheck="true">#修改这两个程序的可执行权限，以便用户可以执行它们</span>
  $ ./app.sh  <span class="token comment" spellcheck="true">#在一个终端启动这个应用程序，在通过./control.sh发送控制码以后查看输出</span>
  The CONTROL number is ONE, <span class="token keyword">do</span> something <span class="token punctuation">..</span>.    <span class="token comment" spellcheck="true">#发送1以后</span>
  The CONTROL number is ZERO, <span class="token keyword">do</span> something <span class="token punctuation">..</span>.    <span class="token comment" spellcheck="true">#发送0以后</span>
  The CONTROL number not recognized, <span class="token keyword">do</span> something else<span class="token punctuation">..</span>.  <span class="token comment" spellcheck="true">#发送一个未知的控制码以后</span>
  $ ./control.sh 1            <span class="token comment" spellcheck="true">#在另外一个终端，发送控制信息，控制应用程序的工作</span>
  $ ./control.sh 0
  $ ./control.sh 4343<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>这样一种应用架构非常适合本地的多程序任务设计，如果结合 <code>web cgi</code>，那么也将适合远程控制的要求。引入 <code>web cgi</code> 的唯一改变是，要把控制程序 <code>./control.sh</code> 放到 <code>web</code> 的 <code>cgi</code> 目录下，并对它作一些修改，以使它符合 <code>CGI</code> 的规范，这些规范包括文档输出格式的表示（在文件开头需要输出 <code>content-tpye: text/html</code> 以及一个空白行）和输入参数的获取 <code>(web</code> 输入参数都存放在 <code>QUERY_STRING</code> 环境变量里头）。因此一个非常简单的 <code>CGI</code> 控制程序可以写成这样：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

FIFO<span class="token operator">=</span>./fifo_test
CI<span class="token operator">=</span><span class="token variable">$QUERY_STRING</span>

<span class="token punctuation">[</span> -z <span class="token string">"<span class="token variable">$CI</span>"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">echo</span> <span class="token string">"the control info should not be empty"</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">exit</span>

<span class="token keyword">echo</span> -e <span class="token string">"content-type: text/html\n\n"</span>
<span class="token keyword">echo</span> <span class="token variable">$CI</span> <span class="token operator">></span> <span class="token variable">$FIFO</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在实际使用时，请确保 <code>control.sh</code> 能够访问到 <code>fifo_test</code> 管道，并且有写权限，以便通过浏览器控制 <code>app.sh</code> ：</p><pre><code>http://ipaddress\_or\_dns/cgi-bin/control.sh?0</code></pre><p>问号 <code>?</code> 后面的内容即 <code>QUERY_STRING</code>，类似之前的 <code>$1</code> 。</p><p>这样一种应用对于远程控制，特别是嵌入式系统的远程控制很有实际意义。在去年的暑期课程上，我们就通过这样一种方式来实现马达的远程控制。首先，实现了一个简单的应用程序以便控制马达的转动，包括转速，方向等的控制。为了实现远程控制，我们设计了一些控制码，以便控制马达转动相关的不同属性。</p><p>在 C 语言中，如果要使用有名管道，和 Shell 类似，只不过在读写数据时用 <code>read</code>，<code>write</code> 调用，在创建 <code>fifo</code> 时用 <code>mkfifo</code> 函数调用。</p><h4 id="范例：信号（Signal）"><a href="#范例：信号（Signal）" class="headerlink" title="范例：信号（Signal）"></a>范例：信号（Signal）</h4><p>信号是软件中断，Linux 用户可以通过 <code>kill</code> 命令给某个进程发送一个特定的信号，也可以通过键盘发送一些信号，比如 <code>CTRL+C</code> 可能触发 <code>SGIINT</code> 信号，而 <code>CTRL+\</code> 可能触发 <code>SGIQUIT</code> 信号等，除此之外，内核在某些情况下也会给进程发送信号，比如在访问内存越界时产生 <code>SGISEGV</code> 信号，当然，进程本身也可以通过 <code>kill</code>，<code>raise</code> 等函数给自己发送信号。对于 Linux 下支持的信号类型，大家可以通过 <code>man 7 signal</code> 或者 <code>kill -l</code> 查看到相关列表和说明。</p><p>对于有些信号，进程会有默认的响应动作，而有些信号，进程可能直接会忽略，当然，用户还可以对某些信号设定专门的处理函数。在 Shell 中，可以通过 <code>trap</code> 命令（Shell 内置命令）来设定响应某个信号的动作（某个命令或者定义的某个函数），而在 C 语言中可以通过 <code>signal</code> 调用注册某个信号的处理函数。这里仅仅演示 <code>trap</code> 命令的用法。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">function</span> signal_handler <span class="token punctuation">{</span> <span class="token keyword">echo</span> <span class="token string">"hello, world."</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">#定义signal_handler函数</span>
$ <span class="token function">trap</span> signal_handler SIGINT  <span class="token comment" spellcheck="true">#执行该命令设定：收到SIGINT信号时打印hello, world</span>
$ hello, world     <span class="token comment" spellcheck="true">#按下CTRL+C，可以看到屏幕上输出了hello, world字符串</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>类似地，如果设定信号 0 的响应动作，那么就可以用 <code>trap</code> 来模拟 C 语言程序中的 <code>atexit</code> 程序终止函数的登记，即通过 <code>trap signal_handler SIGQUIT</code> 设定的 <code>signal_handler</code> 函数将在程序退出时执行。信号 0 是一个特别的信号，在 <code>POSIX.1</code> 中把信号编号 0 定义为空信号，这常被用来确定一个特定进程是否仍旧存在。当一个程序退出时会触发该信号。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> sigexit.sh
<span class="token comment" spellcheck="true">#!/bin/bash</span>

<span class="token keyword">function</span> signal_handler <span class="token punctuation">{</span>
    <span class="token keyword">echo</span> <span class="token string">"hello, world"</span>
<span class="token punctuation">}</span>
<span class="token function">trap</span> signal_handler 0
$ <span class="token function">chmod</span> +x sigexit.sh
$ ./sigexit.sh    <span class="token comment" spellcheck="true">#实际Shell编程会用该方式在程序退出时来做一些清理临时文件的收尾工作</span>
hello, world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="作业和作业控制"><a href="#作业和作业控制" class="headerlink" title="作业和作业控制"></a>作业和作业控制</h3><p>当我们为完成一些复杂的任务而将多个命令通过 <code>|,\&gt;,&lt;, ;, (,)</code> 等组合在一起时，通常这个命令序列会启动多个进程，它们间通过管道等进行通信。而有时在执行一个任务的同时，还有其他的任务需要处理，那么就经常会在命令序列的最后加上一个&amp;，或者在执行命令后，按下 <code>CTRL+Z</code> 让前一个命令暂停。以便做其他的任务。等做完其他一些任务以后，再通过 <code>fg</code> 命令把后台任务切换到前台。这样一种控制过程通常被成为作业控制，而那些命令序列则被成为作业，这个作业可能涉及一个或者多个程序，一个或者多个进程。下面演示一下几个常用的作业控制操作。</p><h4 id="范例：创建后台进程，获取进程的作业号和进程号"><a href="#范例：创建后台进程，获取进程的作业号和进程号" class="headerlink" title="范例：创建后台进程，获取进程的作业号和进程号"></a>范例：创建后台进程，获取进程的作业号和进程号</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sleep</span> 50 <span class="token operator">&amp;</span>
<span class="token punctuation">[</span>1<span class="token punctuation">]</span> 11137<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="范例：把作业调到前台并暂停"><a href="#范例：把作业调到前台并暂停" class="headerlink" title="范例：把作业调到前台并暂停"></a>范例：把作业调到前台并暂停</h4><p>使用 Shell 内置命令 <code>fg</code> 把作业 1 调到前台运行，然后按下 <code>CTRL+Z</code> 让该进程暂停</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">fg</span> %1
<span class="token function">sleep</span> 50
^Z
<span class="token punctuation">[</span>1<span class="token punctuation">]</span>+  Stopped                 <span class="token function">sleep</span> 50<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="范例：查看当前作业情况"><a href="#范例：查看当前作业情况" class="headerlink" title="范例：查看当前作业情况"></a>范例：查看当前作业情况</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">jobs</span>            <span class="token comment" spellcheck="true">#查看当前作业情况，有一个作业停止</span>
<span class="token punctuation">[</span>1<span class="token punctuation">]</span>+  Stopped                 <span class="token function">sleep</span> 50
$ <span class="token function">sleep</span> 100 <span class="token operator">&amp;</span>     <span class="token comment" spellcheck="true">#让另外一个作业在后台运行</span>
<span class="token punctuation">[</span>2<span class="token punctuation">]</span> 11138
$ <span class="token function">jobs</span>            <span class="token comment" spellcheck="true">#查看当前作业情况，一个正在运行，一个停止</span>
<span class="token punctuation">[</span>1<span class="token punctuation">]</span>+  Stopped                 <span class="token function">sleep</span> 50
<span class="token punctuation">[</span>2<span class="token punctuation">]</span>-  Running                 <span class="token function">sleep</span> 100 <span class="token operator">&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="范例：启动停止的进程并运行在后台"><a href="#范例：启动停止的进程并运行在后台" class="headerlink" title="范例：启动停止的进程并运行在后台"></a>范例：启动停止的进程并运行在后台</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">bg</span> %1
<span class="token punctuation">[</span>2<span class="token punctuation">]</span>+ <span class="token function">sleep</span> 50 <span class="token operator">&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>不过，要在命令行下使用作业控制，需要当前 Shell，内核终端驱动等对作业控制支持才行。</p><h2 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>前面章节已经介绍了Shell编程范例之数值、布尔值、字符串、文件、文件系统、进程等的操作。这些内容基本覆盖了网络中某个独立机器正常工作的“方方面面”，现在需要把视角从单一的机器延伸到这些机器通过各种网络设备和协议连接起来的网络世界，分析网络拓扑结构、网络工作原理、了解各种常见网络协议、各种常见硬件工作原理、网络通信与安全相关软件以及工作原理分析等。</p><p>不过，因为网络相关的问题确实太复杂了，这里不可能介绍具体，因此如果想了解更多细节，还是建议参考相关资料。但Linux是一个网络原理学习和实践的好平台，不仅因为它本身对网络体系结构的实现是开放源代码的，而且各种相关的分析工具和函数库数不胜数，因此千万不要错过通过它来做相关的实践工作。</p><h3 id="网络原理介绍"><a href="#网络原理介绍" class="headerlink" title="网络原理介绍"></a>网络原理介绍</h3><h4 id="我们的网络世界"><a href="#我们的网络世界" class="headerlink" title="我们的网络世界"></a>我们的网络世界</h4><p>在进行所有介绍之前，来直观地感受一下那个真真实实存在的网络世界吧。当我在 Linux 下通过 <code>Web</code> 编辑器写这篇 Blog 时，一边用 <code>mplayer</code> 听着远程音乐，累了时则打开兰大的网络 <code>TV</code> 频道开始看看凤凰卫视……这些“现代化”的生活，我想，如果没有网络，将变得无法想象。</p><p>下面来构想一下这样一个网络世界的优美图画：</p><blockquote><p>一边盯着显示器，一边敲击着键盘，一边挂着耳机。</p><p>主机电源灯灿烂得很，发着绿光，这时很容易想象主机背后的那个网卡位置肯定有两个不同颜色的灯光在闪烁，它显示着主机正在与计算机网络世界打着交道。</p><p>就在实验室的某个角落，有一个交换机上的一个网口的网线连到主机上，这个交换机接到了一个局域网的网关上，然后这个网关再接到了信息楼的某个路由器上，再转接到学校网络中心的另外一个路由器上……</p><p>期间，有一个路由器连接到了这个 Blog 服务器上，而另外一个则可能连到了那个网络 <code>TV</code> 服务器上，还有呢，另外一些则连接到了电信网络里头的某个音乐服务器上……</p></blockquote><p>下面用 <code>dia</code> 绘制一个简单的“网络地图”：</p><p><img src="https://tinylab.gitbooks.io/shellbook/content/zh/chapters/pic/Network_Architecture.jpg" alt="Network_Architecture"></p><p>该图把一些最常见的网络设备和网络服务基本都呈现出来了，包括本地主机、路由、交换机、网桥，域名服务器，万维网服务，视频服务，防火墙服务，动态 <code>IP</code> 地址服务等。其中各种设备构成了整个物理网络，而网络服务则是构建在这些设备上的各种网络应用。</p><p>现在的网络应用越来越丰富多样，比如即时聊天（<code>IM</code>）、 <code>p2p</code> 资源共享、网络搜索等，它们是如何实现的，它们如何构建在各种各样的网络设备之上，并且能够安全有效的工作呢？这取决于这背后逐步完善的网络体系结构和各种相关网络协议的开发、实现和应用。</p><h4 id="网络体系结构和网络协议介绍"><a href="#网络体系结构和网络协议介绍" class="headerlink" title="网络体系结构和网络协议介绍"></a>网络体系结构和网络协议介绍</h4><p>那么网络体系结构是怎么样的呢？涉及到哪些相关的网络协议呢？什么又是网络协议呢？</p><p>在《计算机网络——自顶向下的方法》一书中非常巧妙地给出了网络体系结构分层的比喻，把网络中各层跟交通运输体系中的各个环节对照起来，让人通俗易懂。在交通运输体系中，运输的是人和物品，在计算机网络体系中，运输的是电子数据。考虑到交通运输网络和计算机网络中最终都可以划归为点对点的信息传输。这里考虑两点之间的信息传递过程，得到这样一个对照关系，见下图：</p><p><img src="https://tinylab.gitbooks.io/shellbook/content/zh/chapters/pic/Network_Layer_Compare.jpg" alt="Network_Layer_Compare"></p><p>对照上图，更容易理解右侧网络体系结构的分层原理（如果比照一封信发出到收到的这一中间过程可能更容易理解），上图右侧是 <code>TCP/IP</code> 网络体系结构的一个网络分层示意图，在把数据发送到网络之前，在各层中需要进行各种“打包”的操作，而从网络接收到数据后，就需要进行“解包”操作，最终把纯粹的数据信息给提取出来。这种分层的方式是为了传输数据的需要，也是两个主机之间如何建立连接以及如何保证数据传输的完整性和可靠性的需要。通过把各种需要分散在不同的层次，使得整个体系结构更加清晰和明了。这些“需求”具体通过各种对应的协议来规范，这些规范统成为网络协议。</p><p>关于 <code>OSI</code> 模型（7 层）比照 <code>TCP/IP</code> 模型（4 层）的协议栈可以从下图（来自网络）看个明了：</p><p><img src="https://tinylab.gitbooks.io/shellbook/content/zh/chapters/pic/Network_Layer_OSI.jpg" alt="Network_Layer_OSI"></p><p>而下图（来自网络）则更清晰地体现了 <code>TCP/IP</code> 分层模型。</p><p><img src="https://tinylab.gitbooks.io/shellbook/content/zh/chapters/pic/Network_Layer_TCP_IP.jpg" alt="Network_Layer_TCP_IP"></p><p>上面介绍了网络原理方面的基本内容，如果想了解更多网络原理和操作系统对网络支持的实现，可以考虑阅读后面的参考资料。下面将做一些实践，即在 Linux 下如何联网，如何用 Linux 搭建各种网络服务，并进行网络安全方面的考量以及基本的网络编程和开发的介绍。</p><h3 id="Linux-下网络“实战”"><a href="#Linux-下网络“实战”" class="headerlink" title="Linux 下网络“实战”"></a>Linux 下网络“实战”</h3><h4 id="如何把我们的-Linux-主机接入网络"><a href="#如何把我们的-Linux-主机接入网络" class="headerlink" title="如何把我们的 Linux 主机接入网络"></a>如何把我们的 Linux 主机接入网络</h4><p>如果要让一个系统能够联网，首先当然是搭建好物理网络了。接入网络的物理方式还是蛮多的，比如直接用网线接入以太网，用无线网卡上网，用 <code>ADSL</code> 拨号上网……</p><p>对于用以太网网卡接入网络的常见方式，在搭建好物理网络并确保连接正常后，可以通过配置 <code>IP</code> 地址和默认网关来接入网络，这个可以通过手工配置和动态获取两种方式。</p><h5 id="范例：通过dhclient获取IP地址"><a href="#范例：通过dhclient获取IP地址" class="headerlink" title="范例：通过dhclient获取IP地址"></a>范例：通过dhclient获取IP地址</h5><p>如果所在的局域网有 <code>DHCP</code> 服务，那么可以这么获取，<code>N</code> 是设备名称，如果只有一块网卡，一般是 0 或者 1 。</p><pre><code>$ dhclient ethN</code></pre><h5 id="范例：静态配置IP地址"><a href="#范例：静态配置IP地址" class="headerlink" title="范例：静态配置IP地址"></a>范例：静态配置IP地址</h5><p>当然，也可以考虑采用静态配置的方式，<code>ip_address</code> 是本地主机的 <code>IP</code> 地址，<code>gw_ip_address</code> 是接入网络的网关的 <code>IP</code> 地址。</p><pre><code>$ ifconfig eth0 ip_address on
$ route add deafult gw gw_ip_address</code></pre><p>如果上面不工作，记得通过 <code>ifconfig/mii-tool/ethtool</code> 等工具检查网卡是否有被驱动起来，然后通过 <code>lspci/dmesg</code> 等检查网卡类型（或者通过主板手册和独立网卡自带的手册查看），接着安装或者编译相关驱动，最后把驱动通过 <code>insmod/modprobe</code> 等工具加载到内核中。</p><h4 id="用-Linux-搭建网桥"><a href="#用-Linux-搭建网桥" class="headerlink" title="用 Linux 搭建网桥"></a>用 Linux 搭建网桥</h4><p>网桥工作在 <code>OSI</code> 模型的第二层，即数据链路层，它只需要知道目标主机的 <code>MAC</code> 地址就可以工作。 Linux 内核在 <code>2.2</code> 开始就已经支持了这个功能，具体怎么配置看看后续<a href="http://www.ibm.com/developerworks/cn/linux/kernel/l-netbr/index.html">参考资料</a>吧。如果要把 Linux 主机配置成一个网桥，至少需要两个网卡。</p><p>网桥的作用相当于一根网线，用户无须关心里头有什么东西，把它的两个网口连接到两个主机上就可以让这两个主机支持相互通信。不过它比网线更厉害，如果配上防火墙，就可以隔离连接在它两端的网段（注意这里是网络，因为它不识别 <code>IP</code>），另外，如果这个网桥有多个网口，那么可以实现一个功能复杂的交换机，而如果有效组合多个网桥，则有可能实现一个复杂的可实现流量控制和负载平衡的防火墙系统。</p><h4 id="用-Linux-做路由"><a href="#用-Linux-做路由" class="headerlink" title="用 Linux 做路由"></a>用 Linux 做路由</h4><p>路由工作在 <code>OSI</code> 模型的第三层，即网络层，通过 <code>router</code> 可以配置 Linux 的路由，当然，Linux 下也有很多工具支持动态路由的。相关的资料在网路中铺天盖地，由于时间关系，这里不做介绍。</p><h4 id="用-Linux-搭建各种常规的网络服务"><a href="#用-Linux-搭建各种常规的网络服务" class="headerlink" title="用 Linux 搭建各种常规的网络服务"></a>用 Linux 搭建各种常规的网络服务</h4><p>需要什么网络服务呢？</p><ul><li>给局域网弄个 <code>DHCP</code> 服务器，那就弄个 <code>dhcpd</code>，看看<a href="http://tldp.org/HOWTO/DHCP/">参考资料</a>；</li><li>如果想弄个邮件发送服务器，那就安装个 <code>sendmail</code> 或者 <code>exim4</code> ；</li><li>如果再想弄个邮件列表服务器呢，那就装个 <code>mailman</code> ；</li><li>如果想弄个接收邮件的服务器呢，那就安装个 <code>pop3</code> 服务器；</li><li>如果想弄个 <code>web</code> 站点，那就弄个 <code>apache</code> 或者 <code>nginx</code> 服务器；</li><li>如果想弄上防火墙服务，那么通过 <code>iptables</code> 工具配置 <code>netfilter</code> 就可以</li></ul><p>What’s more？如果你能想到，Linux上基本都有相应的实现。</p><h4 id="Linux-下网络问题诊断与维护"><a href="#Linux-下网络问题诊断与维护" class="headerlink" title="Linux 下网络问题诊断与维护"></a>Linux 下网络问题诊断与维护</h4><p>如果出现网络问题，不要惊慌，逐步检查网络的各个层次：物理链接、链路层、网络层直到应用层，熟悉使用各种如下的工具，包括 <code>ethereal/tcpdump</code>，<code>hping</code>，<code>nmap</code>，<code>netstat</code>，<code>netpipe</code>，<code>netperf</code>，<code>vnstat</code>，<code>ntop</code> 等。</p><p>关于这些工具的详细用法和网络问题诊断和维护的相关知识，请看后续相关资料。</p><h3 id="Linux-下网络编程与开发"><a href="#Linux-下网络编程与开发" class="headerlink" title="Linux 下网络编程与开发"></a>Linux 下网络编程与开发</h3><p>如果想做网络编程开发，比如：</p><ul><li>要实现一个客户端 <code>/</code> 服务器架构的应用，可以采用 Linux 下的 <code>socket</code> 编程了；</li><li>如果想写一个数据包抓获和协议分析的程序，可以采用 <code>libpap</code> 等函数库；</li><li>如果想实现某个协议呢，那就可以参考相关的 <code>RFC</code> 文档，并通过 <code>socket</code> 编程来实现。</li></ul><p>这个可以参考相关的 <code>Linux socket</code> 编程等资料。</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>本来介绍网络相关的一些基本内容，但因时间关系，没有详述，更多细节请参考相关资料。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>计算机网络——自上而下的分析方法</li><li>Linux 网络体系结构（清华大学出版社出版）</li><li>Linux 系统故障诊断与排除 第13章 网络问题（人民邮电出版社）</li><li>在 Linux 下用 ADSL 拨号上网</li><li>Linux 下无线网络相关资料收集</li><li><a href="http://www.ibm.com/developerworks/cn/linux/kernel/l-netbr/index.html">Linux网桥的实现分析与使用</a></li><li><a href="http://tldp.org/HOWTO/DHCP/">DHCP mini howto</a></li><li>最佳的 75 个安全工具</li><li>网络管理员必须掌握的知识</li><li>Linux 上检测 rootkit 的两种工具: Rootkit Hunter 和 Chkrootkit</li><li>数据包抓获与 ip 协议的简单分析（基于 pcap 库）</li><li><a href="http://www.ietf.org/rfc">RFC</a></li><li><a href="http://zhoulifa.bokee.com/4640913.html">HTTP 协议的 C 语言编程实现实例</a></li></ul><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>在实际使用中，Linux 系统首先是面向用户的系统，所有之前介绍的内容全部是提供给不同的用户使用的。实际使用中常常碰到各类用户操作，所以这里添加一个独立的章节来介绍。</p><p>Linux 支持多用户，也就是说允许不同的人使用同一个系统，每个人有一个属于自己的帐号。而且允许大家设置不同的认证密码，确保大家的私有信息得到保护。另外，为了确保整个系统的安全，用户权限又做了进一步划分，包括普通用户和系统管理员。普通用户只允许访问自己账户授权下的信息，而系统管理员才能访问所有资源。普通用户如果想行使管理员的职能，必须获得系统管理员的许可。</p><p>为避免分散注意力，咱们不去介绍背后的那些数据文件： <code>/etc/passwd</code>，<code>/etc/shadow</code>，<code>/etc/group</code>，<code>/etc/gshadow</code></p><p>如果确实有需要，大家可通过如下命令查看帮助： <code>man 5 passwd</code>，<code>man shadow</code>, <code>man group</code> 和 <code>man gshadow</code></p><p>下面我们分如下几个部分来介绍：</p><ul><li>用户帐号</li><li>用户口令</li><li>用户组别</li><li>用户和组</li><li>用户切换</li></ul><h3 id="用户帐号"><a href="#用户帐号" class="headerlink" title="用户帐号"></a>用户帐号</h3><p>帐号操作主要是增、删、改、禁。Linux 系统提供了底层的 <code>useradd</code>, <code>userdel</code> 和 <code>usermod</code> 来完成相关操作，也提供了进一步的简化封装：<code>adduser</code>, <code>deluser</code>。为了避免混淆，咱们这里只介绍最底层的指令，这些指令设计上已经够简洁明了方便。</p><p>由于只有系统管理员才能创建新用户，请确保以 root 帐号登录或者可以通过 sudo 切换为管理员帐号。</p><h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><p>创建家目录并指定登录 Shell：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># useradd -s /bin/bash -m test</span>
<span class="token comment" spellcheck="true"># groups test</span>
<span class="token function">test</span> <span class="token keyword">:</span> <span class="token function">test</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>并加入所属组：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># useradd -s /bin/bash -m -G docker test</span>
<span class="token comment" spellcheck="true"># groups test</span>
<span class="token function">test</span> <span class="token keyword">:</span> <span class="token function">test</span> docker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>删除用户以及家目录等：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># userdel -r test</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p>常常用来修改默认的 Shell：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># usermod -s /bin/bash test</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者把用户加入某个新安装软件所属的组：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># usermod -a -G docker test</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改登录用户名并搬到新家：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># usermod -d /home/new_test -m -l new_test test</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="禁用"><a href="#禁用" class="headerlink" title="禁用"></a>禁用</h4><p>如果想禁用某个帐号：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># usermod -L test</span>
<span class="token comment" spellcheck="true"># usermod --expiredate 1 test</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="用户口令"><a href="#用户口令" class="headerlink" title="用户口令"></a>用户口令</h3><p>口令操作主要是设置、删除、修改和禁用。Linux 系统提供了 <code>passwd</code> 命令来管理用户口令。</p><h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><p>设置用户 test 的初始密码：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">passwd</span> <span class="token function">test</span>
Enter new UNIX password:
Retype new UNIX password:
passwd: password updated successfully<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><p>让用户 test 无须密码登录（密码为空）：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">passwd</span> -d <span class="token function">test</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个很方便某些安全无关紧要的条件下（比如已登录主机中的虚拟机），可避免每次频繁输入密码。</p><h4 id="修改-1"><a href="#修改-1" class="headerlink" title="修改"></a>修改</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">passwd</span> <span class="token function">test</span>
Changing password <span class="token keyword">for</span> test.
<span class="token punctuation">(</span>current<span class="token punctuation">)</span> UNIX password:
Enter new UNIX password:
Retype new UNIX password:
passwd: password updated successfully<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="禁用-1"><a href="#禁用-1" class="headerlink" title="禁用"></a>禁用</h4><p>禁止用户通过密码登录：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">passwd</span> -l user<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为了安全起见或者为了避免暴力破解，我们通常可以禁用密码登录，而只允许通过 SSH Key 登录。</p><p>如果要真地禁用整个帐号的使用，需要用上一节提到的 <code>usermod --expiredate 1</code>。</p><h3 id="用户组别"><a href="#用户组别" class="headerlink" title="用户组别"></a>用户组别</h3><p>类似帐号，主要操作也是增、删、改。</p><p>Linux 系统提供了底层的 <code>groupadd</code>, <code>groupdel</code> 和 <code>groupmod</code> 来完成相关操作，也提供了进一步的简化封装：<code>addgroup</code>, <code>delgroup</code>。</p><p>用户组别通常用来管理不同的资源，确保只有某个组别的用户才可以访问某类资源。当然，实际案例中，有些软件也为自己定义一个组别，只有该组别的用户才能访问该软件的一些功能。</p><h4 id="添加-1"><a href="#添加-1" class="headerlink" title="添加"></a>添加</h4><p>添加一个新组别：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># groupadd test</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># groupdel test</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="修改-2"><a href="#修改-2" class="headerlink" title="修改"></a>修改</h4><p>修改组别名：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># groupmod -n new_test test</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="用户和组"><a href="#用户和组" class="headerlink" title="用户和组"></a>用户和组</h3><p>用户和组别不能独立存在，<code>gpasswd</code> 可以用来处理两者的关系。</p><h4 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h4><p>从 docker 组中增加用户 test（等同于把 test 增加到 docker 组中）：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># gpasswd -a test docker</span>

或

<span class="token comment" spellcheck="true"># usermod -a -G docker test</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="删除-3"><a href="#删除-3" class="headerlink" title="删除"></a>删除</h4><p>从 test 组中删除用户 test：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># gpasswd -d test test</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="用户切换"><a href="#用户切换" class="headerlink" title="用户切换"></a>用户切换</h3><p>由于支持多用户，那么在登录一个帐号后，可能需要切换到另外一个帐号下，可以通过 <code>su</code> 命令完成，而 <code>sudo</code> 则可以用来作为另外一个用户来执行命令。</p><h4 id="切换帐号"><a href="#切换帐号" class="headerlink" title="切换帐号"></a>切换帐号</h4><p>切换到 Root 并启用 Bash：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">su</span> -s /bin/bash -
root@falcon-desktop:~<span class="token comment" spellcheck="true">#</span>

或者

$ <span class="token function">sudo</span> -s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>切换到普通用户：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">su</span> -s /bin/bash - <span class="token function">test</span>
test@falcon-desktop:~$ 

或者

$ <span class="token function">sudo</span> -i -u <span class="token function">test</span> 
test@falcon-desktop:~$ <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="免密码切到-Root"><a href="#免密码切到-Root" class="headerlink" title="免密码切到 Root"></a>免密码切到 Root</h4><p>首先得把用户加入到 sudo 用户组：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># usermod -a -G sudo falcon</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>否则，会看到如下信息：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> -s
<span class="token punctuation">[</span>sudo<span class="token punctuation">]</span> password <span class="token keyword">for</span> test: 
<span class="token function">test</span> is not <span class="token keyword">in</span> the sudoers file.  This incident will be reported.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>加入 sudo 用户组以后：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> -s
<span class="token punctuation">[</span>sudo<span class="token punctuation">]</span> password <span class="token keyword">for</span> test: <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>要实现免密切换，需要先修改 <code>/etc/sudoers</code>，加入如下一行：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">test</span> ALL<span class="token operator">=</span><span class="token punctuation">(</span>ALL<span class="token punctuation">)</span> NOPASSWD: ALL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者在 <code>/etc/sudoers.d/</code> 下创建一个文件并加入上述内容。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># echo "test ALL=(ALL) NOPASSWD: ALL" > /etc/sudoers.d/test</span>
<span class="token comment" spellcheck="true"># chmod 440 /etc/sudoers.d/test</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里，整个复习系列就要结束了，作为总结篇，主要回顾一下各个小节的主要内容，并总结出 Shell 编程的一些常用框架和相关注意事项等。</p><h3 id="正确使用-source-和"><a href="#正确使用-source-和" class="headerlink" title="正确使用 source 和 ."></a>正确使用 <code>source</code> 和 <code>.</code></h3><p>仅使用 <code>source</code> 和 <code>.</code> 来执行你的环境配置等功能，建议不要用于其它用途。 在Shell中使用脚本时，使用 <code>bash your_script.sh</code> 而不是 <code>source your_script.sh</code> 或 <code>. your_script.sh</code>。</p><p>当使用 <code>bash</code> 的时候，当前的Shell会创建一个新的子进程执行你的脚本；当使用 <code>source</code> 和 <code>.</code> 时，当前的Shell会直接解释执行 <code>your_script.sh</code> 中的代码。如果 <code>your_script.sh</code> 中包含了类似 <code>exit 0</code> 这样的代码，使用<code>source</code> 和 <code>.</code> 执行会导致当前Shell意外地退出。</p></div><hr><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/tags/Linux/"><span class="chip bg-color">Linux</span> </a><a href="/tags/Shell/"><span class="chip bg-color">Shell</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="wechat,qq,weibo,twitter,facebook,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="/libs/share/js/social-share.min.js"></script></div></div></div></div></div><style>.valine-card{margin:1.5rem auto}.valine-card .card-content{padding:20px 20px 5px 20px}#vcomments textarea{box-sizing:border-box;background:url(/medias/comment_bg.png) 100% 100% no-repeat}#vcomments p{margin:2px 2px 10px;font-size:1.05rem;line-height:1.78rem}#vcomments blockquote p{text-indent:.2rem}#vcomments a{padding:0 2px;color:#4cbf30;font-weight:500;text-decoration:none}#vcomments img{max-width:100%;height:auto;cursor:pointer}#vcomments ol li{list-style-type:decimal}#vcomments ol,ul{display:block;padding-left:2em;word-spacing:.05rem}#vcomments ul li,ol li{display:list-item;line-height:1.8rem;font-size:1rem}#vcomments ul li{list-style-type:disc}#vcomments ul ul li{list-style-type:circle}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}#vcomments table,td,th{border:0}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments h1{font-size:1.85rem;font-weight:700;line-height:2.2rem}#vcomments h2{font-size:1.65rem;font-weight:700;line-height:1.9rem}#vcomments h3{font-size:1.45rem;font-weight:700;line-height:1.7rem}#vcomments h4{font-size:1.25rem;font-weight:700;line-height:1.5rem}#vcomments h5{font-size:1.1rem;font-weight:700;line-height:1.4rem}#vcomments h6{font-size:1rem;line-height:1.3rem}#vcomments p{font-size:1rem;line-height:1.5rem}#vcomments hr{margin:12px 0;border:0;border-top:1px solid #ccc}#vcomments blockquote{margin:15px 0;border-left:5px solid #42b983;padding:1rem .8rem .3rem .8rem;color:#666;background-color:rgba(66,185,131,.1)}#vcomments pre{font-family:monospace,monospace;padding:1.2em;margin:.5em 0;background:#272822;overflow:auto;border-radius:.3em;tab-size:4}#vcomments code{font-family:monospace,monospace;padding:1px 3px;font-size:.92rem;color:#e96900;background-color:#f8f8f8;border-radius:2px}#vcomments pre code{font-family:monospace,monospace;padding:0;color:#e8eaf6;background-color:#272822}#vcomments pre[class*=language-]{padding:1.2em;margin:.5em 0}#vcomments code[class*=language-],pre[class*=language-]{color:#e8eaf6}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}#vcomments b,strong{font-weight:700}#vcomments dfn{font-style:italic}#vcomments small{font-size:85%}#vcomments cite{font-style:normal}#vcomments mark{background-color:#fcf8e3;padding:.2em}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}.v .vlist .vcard{padding-top:2.5em!important}</style><div class="card valine-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;left:20px;top:15px;padding-bottom:5px"><i class="fa fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="vcomments" class="card-content" style="display:grid"></div></div><script src="/libs/valine/av-min.js"></script><script src="/libs/valine/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"98JpzSGcrl9jFqHO13vqxHvX-gzGzoHsz",appKey:"mDmr2h9PB20xvPMNqgyRnNIC",notify:!0,verify:!0,visitor:!0,avatar:"mm",pageSize:"10",lang:"zh-cn",placeholder:"just go go"})</script><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fa fa-chevron-left"></i>&nbsp;上一篇</div><div class="card"><a href="/posts/31993/"><div class="card-image"><img src="/medias/featureimages/1.jpg" class="responsive-img" alt="Own Virtual Machine(一)"> <span class="card-title">Own Virtual Machine(一)</span></div></a><div class="card-content article-content"><div class="summary block-with-text">一个可以运行汇编语言属于你的虚拟机。</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2020-12-20 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/C/" class="post-category">C</a></span></div></div><div class="card-action article-tags"><a href="/tags/C/"><span class="chip bg-color">C</span> </a><a href="/tags/Virtual-Machine/"><span class="chip bg-color">Virtual Machine</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fa fa-chevron-right"></i></div><div class="card"><a href="/posts/50641/"><div class="card-image"><img src="/medias/featureimages/12.jpg" class="responsive-img" alt="Shell基础学习"> <span class="card-title">Shell基础学习</span></div></a><div class="card-content article-content"><div class="summary block-with-text">之前也有一些关于这方面的笔记，但过于零碎，特地整理。</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2020-12-18 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/Linux/" class="post-category">Linux</a></span></div></div><div class="card-action article-tags"><a href="/tags/Linux/"><span class="chip bg-color">Linux</span> </a><a href="/tags/Shell/"><span class="chip bg-color">Shell</span></a></div></div></div></div></article></div><script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script><script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script><script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script><script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget"><div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fa fa-list"></i></a></div><script src="/libs/tocbot/tocbot.min.js"></script><script>$(function(){tocbot.init({tocSelector:"#toc-content",contentSelector:"#articleContent",headingsOffset:-(.4*$(window).height()-45),headingSelector:"h2, h3, h4, h5"});let t=0;var e="toc-heading-";$("#toc-content a").each(function(){$(this).attr("href","#"+e+ ++t)}),t=0,$("#articleContent").children("h2, h3, h4, h5").each(function(){$(this).attr("id",e+ ++t)});var n=parseInt(.4*$(window).height()-64);let o=$(".toc-widget");$(window).scroll(function(){var t=$(window).scrollTop();n<t?o.addClass("toc-fixed"):o.removeClass("toc-fixed")});var i="expanded";let a=$("#toc-aside"),c=$("#main-content");$("#floating-toc-btn .btn-floating").click(function(){a.hasClass(i)?(a.removeClass(i).hide(),c.removeClass("l9")):(a.addClass(i).show(),c.addClass("l9")),function(){let e=$("#artDetail");if(0!==e.length){let t=e.width();450<=t?t+=21:350<=t&&t<450?t+=18:300<=t&&t<350?t+=16:t+=14,$("#prenext-posts").width(t)}}()})})</script></main><footer class="page-footer bg-color"><div class="container row center-align"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2019</span> <a href="/about" rel="external nofollow noreferrer">JoyTsing</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br><span id="sitetime">载入运行时间...</span> <span id="busuanzi_container_site_pv">|&nbsp;<i class="fa fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span>&nbsp;次 </span><span id="busuanzi_container_site_uv">|&nbsp;<i class="fa fa-user"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv" class="white-color"></span>&nbsp;人</span><br>&nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;<span class="white-color">367.9k</span>&nbsp;字<script>function siteTime(){var e=864e5,t="2019",n=(m=new Date).getFullYear(),o=m.getMonth()+1,r=m.getDate(),a=m.getHours(),i=m.getMinutes(),l=m.getSeconds(),m=Date.UTC(t,"7","24","0","0","0"),r=Date.UTC(n,o,r,a,i,l)-m,a=Math.floor(r/31536e6),i=Math.floor(r/e-365*a),l=Math.floor((r-(365*a+i)*e)/36e5),m=Math.floor((r-(365*a+i)*e-36e5*l)/6e4),M=Math.floor((r-(365*a+i)*e-36e5*l-6e4*m)/1e3);t==n?(document.getElementById("year").innerHTML=n,document.getElementById("sitetime").innerHTML="本站已安全运行 "+i+" 天 "+l+" 小时 "+m+" 分钟 "+M+" 秒"):(document.getElementById("year").innerHTML=t+" - "+n,document.getElementById("sitetime").innerHTML="本站已安全运行 "+a+" 年 "+i+" 天 "+l+" 小时 "+m+" 分钟 "+M+" 秒")}setInterval(siteTime,1e3)</script></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/JoyTsing" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fa fa-github"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script src="/js/search.js"></script><script type="text/javascript">$(function(){searchFunc("/search.xml","searchInput","searchResult")})</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fa fa-angle-up"></i></a></div><script src="/libs/materialize/materialize.min.js"></script><script src="/libs/masonry/masonry.pkgd.min.js"></script><script src="/libs/aos/aos.js"></script><script src="/libs/scrollprogress/scrollProgress.min.js"></script><script src="/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="/js/matery.js"></script><script async src="/libs/others/busuanzi.pure.mini.js"></script><script type="text/javascript">var st,OriginTitile=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="(oﾟvﾟ)ノ Hi",clearTimeout(st)):(document.title="(*´∇｀*) 欢迎回来！",st=setTimeout(function(){document.title=OriginTitile},3e3))})</script><script type="text/javascript" color="0,0,255" pointcolor="0,0,255" opacity="0.8" zindex="-1" count="150" src="/libs/background/canvas-nest.js"></script><script src="/libs/instantpage/instantpage.js" type="module"></script><script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script><script>const hasAttr = (e,a) => a.some(_=> e.attr(_)!==undefined);
        $('a').each(function() {
          const $this = $(this);
          if(hasAttr($this,["data-fancybox","ignore-external-link"])) return;
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== '' || window.location.host) {
                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/shizuku.model.json"},display:{position:"left",width:150,height:200},mobile:{show:!1},react:{opacity:.7}})</script></body></html>