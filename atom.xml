<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JoyTsing</title>
  
  <subtitle>深海</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://joytsing.github.io/"/>
  <updated>2024-05-18T08:24:56.597Z</updated>
  <id>https://joytsing.github.io/</id>
  
  <author>
    <name>JoyTsing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Cpp中的ABI探究</title>
    <link href="https://joytsing.github.io/posts/27828/"/>
    <id>https://joytsing.github.io/posts/27828/</id>
    <published>2024-05-18T08:07:59.000Z</published>
    <updated>2024-05-18T08:24:56.597Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Application Binary Interface 也就是我们常说的 ABI，是个让人感觉到既熟悉又陌生的概念。熟悉在哪里？讨论问题的时候经常会讨论到它，看文章的时候经常会提到它，有时候又要处理它导致的兼容性。陌生在哪里？如果有人问你什么是 ABI，你会发现你知道它是怎么一回事，但是要用严谨的语言去描述它有些困难。最后只好照着 WIKI 说：ABI 就是两个二进制程序模块之间的接口。有问题吗？没有问题，但是回答了跟没有回答一样。</p><p>软件工程讲究分层，对于一个 C++ 程序的 ABI 来说，我们也可以从下面这五个层次来看待。</p><h2 id="CPU-amp-OS"><a href="#CPU-amp-OS" class="headerlink" title="CPU &amp; OS"></a>CPU &amp; OS</h2><p>最终的可执行文件最后都是要运行在特定 CPU 上的特定操作系统的。如果 CPU 的指令集不同，那肯定会导致二进制不兼容，比如 ARM 上的程序没法<strong>直接</strong>运行在 x64 处理器上（除非借助一些虚拟化技术）。如果指令集兼容呢？比如 x64 处理器就兼容 x86 的指令集，那 x86 程序一定能运行在 x64 操作系统上吗？这时候就要看操作系统了，具体来说，要考虑到 <strong>Object File Format</strong>（目标文件格式），<strong>Data Representation</strong>（数据表示）， <strong>Function Calling Convention</strong>（函数调用约定）和 <strong>Runtime Library</strong>（运行时库）等因素。这几点就可以看做是操作系统层面的 ABI 规定。第四点我们后面有专门的一节来讨论，下面以 x64 平台为例，就前三点进行讨论。</p><blockquote><p>x64, x86-64, x86_64, AMD64 和 Intel 64 是一个意思，都是指 x86 指令集的 64 位版本。</p></blockquote><p><strong>x64 平台上主要有两套常用的 ABI</strong>：</p><ul><li>用于 64 位 Windows 操作系统上的 Windows x64 ABI</li><li>用于 64 位 Linux 以及一众 UNIX-like 的操作系统上的 x86-64 System V ABI</li></ul><p>而从一个动态库里面调用某个函数可以简单的看成下面这个三个步骤：</p><ul><li>按照某种格式解析动态库</li><li>根据符号名从解析结果中查找函数地址</li><li>函数参数传递，调用函数</li></ul><h3 id="Object-File-Format"><a href="#Object-File-Format" class="headerlink" title="Object File Format"></a>Object File Format</h3><p>以何种格式解析动态库？这就是 ABI 中对 Object File Format 的规定起作用的地方了。如果你希望自己写一个链接器，那么最后生成的可执行文件就需要满足对应平台的格式要求。Windows x64 使用的可执行文件格式是 <a href="https://learn.microsoft.com/en-us/windows/win32/debug/pe-format">PE32+</a> ，也就是 PE32（Portable Executable 32-bit）格式的<code>64</code>位版本。System V ABI 使用的则是 <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">ELF（Executable Linkable Format）</a> 格式的可执行文件。通过使用一些 parse 库（当然感兴趣的话也可以自己写），例如 pe-parse 和 elfio，对实际的可执行文件进行解析，得到其中的符号表，我们便能拿到函数名与函数地址的映射关系了。</p><h3 id="Data-Representation"><a href="#Data-Representation" class="headerlink" title="Data Representation"></a>Data Representation</h3><p>拿到函数地址之后，接下来就是怎么进行调用了。在调用之前，首先得传参对吧。那传参的时候就特别要注意 Data Representation（数据表示）表示的一致性，什么意思呢？</p><p>假设我把下面这个文件编译成动态库</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> X<span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">int</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span>X x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> x<span class="token punctuation">.</span>a <span class="token operator">+</span> x<span class="token punctuation">.</span>b<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果后续版本升级导致结构体内容发生变动了，用户代码里面看到的结构体定义变成了</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> X<span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">int</span> b<span class="token punctuation">;</span>    <span class="token keyword">int</span> c<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后仍然去尝试链接旧版本代码编译出的动态库，并调用里面的函数</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>能成功吗？当然会失败了，这种错误可以看成所谓的 ODR（One Definition Rule）违反。</p><p>上面的情况属于用户主动变更代码导致的 ODR 违反，那如果我不主动变更代码，能确保结构体布局的稳定性吗？那这就由 ABI 中 Data Representation 来进行相关保证了。例如：规定一些基础类型的大小和对齐， Windows x64 规定<code>long</code>是<code>32</code>位，而 System V 则规定<code>long</code>是<code>64</code>位。规定<code>struct</code>和<code>union</code>的大小和对齐等等。</p><blockquote><p>注意 C 语言标准仍然是不规定 ABI 的，对于 System V ABI 来说，其主要使用 C 语言的术语和概念编写，所以可以认为提供了针对 C 语言的 ABI。而 Windows x64 ABI 在 C 和 C++ 之间并没有太过明显的界限。</p></blockquote><h3 id="Function-Calling-Convention"><a href="#Function-Calling-Convention" class="headerlink" title="Function Calling Convention"></a>Function Calling Convention</h3><p>接下来就到函数传参这一步了。我们知道，函数不过就是一段二进制数据，执行函数其实就是跳转到函数的入口地址，然后执行那一段代码，最后执行完了再跳转回来就行了。而传参无非就是找一块地方，存放数据，<strong>使得调用前后都能访问到这个地方来取数据</strong>。有哪些位置可以选择呢？主要有下面四个选项：</p><ul><li>global（全局变量）</li><li>heap（堆）</li><li>register（寄存器）</li><li>stack（栈）</li></ul><p>使用全局变量进行传参，听起来很魔幻，实际上平常写代码的时候经常把一些需要反复传递的参数改成全局变量，例如<code>config</code>这种的。但是，显然不是所有参数都适合使用全局变量传参，如果考虑到线程安全就要更加注意了。</p><p>使用堆进行传参，似乎也很不可思议，但其实 C++20 加入的无栈协程就把协程的状态（函数参数，局部变量）保存在堆上。不过对于普通的函数调用来说，如果每次传参都要动态内存分配，确实有些奢侈了。</p><p>所以我们主要还是考虑使用寄存器和栈进行传参。多一种选择总是好的，但是在这里并不好。如果调用方觉得应该使用寄存器传参，于是把参数存到寄存器里面去了。而被调用方觉得应该使用栈传参，所以取数据的时候是从栈里面取的。不一致就出现了，很可能从栈里面独到的就是垃圾值，导致代码逻辑错误，程序直接崩溃。</p><p>如何保证调用方和被调用方传参的位置一致呢？相信你已经猜到了，这就是 Function Calling Convention（函数调用约定）发挥作用的地方。</p><p>具体来说，调用约定规定下面这些内容：</p><ul><li>函数参数传递顺序，从左到右还是从右到左？</li><li>函数参数和返回值传递的方式，通过栈还是寄存器？</li><li>哪些寄存器在调用者调用前后是保持不变的？</li><li>谁负责清理栈帧，调用者还是被调用者？</li><li><code>...</code></li></ul><p>在<code>32</code>位程序中，有很多调用约定，像什么<code>__cdecl</code>，<code>__stdcall</code>，<code>__fastcall</code>，<code>__thiscall</code>等等，当时的程序可谓是饱受兼容性之苦。而在<code>64</code>位程序中，已经基本完成统一。主要有两种调用约定，也就是 Windows x64 ABI 和 x86-64 System V ABI 分别规定的调用约定（不过并没有个正式的名字）。<strong>需要强调的是函数传参方式只和调用约定有关，和代码优化等级无关。你也不想不同优化等级编译出来的代码，链接到一起之后跑不起来吧。</strong></p><p>介绍具体的规定是有些无聊的，感兴趣的读者可以自行查阅对应文档的相关小节，下面主要讨论一些比较有意思的话题。</p><blockquote><p>注意：下面这些讨论只适用于函数调用实际发生的情况，如果函数被完全内联，函数传参这一行为并不会发生。目前 C++ 代码的内联优化主要发生在同一编译单元内（单个文件），对于跨编译单元的代码，必须要打开 LTO（Link Time Optimization）才行，跨动态库的代码目前还不能内联。</p></blockquote><ul><li><strong>小于<code>16</code>字节大小的结构体值传递效率比引用效率更高</strong></li></ul><p>这个说法由来已久，但是我始终没有找到依据。终于，最近在研究调用约定的时候，让我找到原因了。首先如果结构体大小小于等于<code>8</code>字节，那么可以直接塞进一个<code>64</code>位寄存器里面传参，<strong>通过寄存器传参比通过引用传参要少几次访存</strong>，效率要高一些，没什么问题。那对于<code>16</code>字节呢？System V ABI 允许将一个<code>16</code>字节大小的结构体拆两个<code>8</code>个字节的部分，然后分别使用寄存器传递。那么在这种情况下传值确实比传引用要高一些，观察下面的 <a href="https://godbolt.org/z/5Ph34x1cK">代码</a></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span><span class="token keyword">struct</span> X <span class="token punctuation">{</span>    size_t x<span class="token punctuation">;</span>    size_t y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token keyword">const</span> X<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// pass by value</span>    <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// pass by reference</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后生成的代码如下所示</p><pre class="line-numbers language-nasm"><code class="language-nasm"><span class="token label function">main:</span>        sub     <span class="token register variable">rsp</span>, <span class="token number">24</span>        mov     <span class="token register variable">edi</span>, <span class="token number">1</span>        mov     <span class="token register variable">esi</span>, <span class="token number">2</span>         call    f(X)        movdqa  <span class="token register variable">xmm0</span>, XMMWORD PTR .LC0<span class="token operator">[</span>rip<span class="token operator">]</span>        mov     <span class="token register variable">rdi</span>, <span class="token register variable">rsp</span>        movaps  XMMWORD PTR <span class="token operator">[</span><span class="token register variable">rsp</span><span class="token operator">]</span>, <span class="token register variable">xmm0</span>        call    g(X const<span class="token operator">&amp;</span>)        xor     <span class="token register variable">eax</span>, <span class="token register variable">eax</span>        add     <span class="token register variable">rsp</span>, <span class="token number">24</span>        ret<span class="token label function">.LC0:</span>        .quad   <span class="token number">1</span>        .quad   <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>System V ABI 规定了前六个整形参数，依次可以使用<code>rdi</code>，<code>rsi</code>，<code>rdx</code>，<code>rcx</code>，<code>r8</code>，<code>r9</code>寄存器传递，而 Windows x64 ABI 规定了前四个整形参数，依次可以使用<code>rcx</code>，<code>rdx</code>，<code>r8</code>，<code>r9</code>寄存器传递。如果过寄存器用完了，就通过栈传递。整形参数即<code>char</code>，<code>short</code>，<code>int</code>，<code>long</code>，<code>long long</code>等基础整数类型外加指针类型。浮点参数和 SIMD 类型的参数则有专门的寄存器负责，这里不过多涉及了。</p></blockquote><p>可以发现<code>1</code>,<code>2</code>分别通过寄存器<code>edi</code>和<code>esi</code>传递给了<code>f</code>函数，而<code>g</code>则是把临时变量的地址传递给了<code>g</code>函数。但是这只是 System V ABI，对于 Windows x64 ABI 来说，<strong>只要结构体的大小大于<code>8</code>字节，只能通过引用传递。</strong>同样的代码，在 Windows 上编译的结果如下</p><pre class="line-numbers language-nasm"><code class="language-nasm"><span class="token label function">main:</span>        sub     <span class="token register variable">rsp</span>, <span class="token number">56</span>                                     lea     <span class="token register variable">rcx</span>, QWORD PTR <span class="token operator">[</span><span class="token register variable">rsp</span><span class="token operator">+</span><span class="token number">32</span><span class="token operator">]</span>        mov     QWORD PTR <span class="token operator">[</span><span class="token register variable">rsp</span><span class="token operator">+</span><span class="token number">32</span><span class="token operator">]</span>, <span class="token number">1</span>        mov     QWORD PTR <span class="token operator">[</span><span class="token register variable">rsp</span><span class="token operator">+</span><span class="token number">40</span><span class="token operator">]</span>, <span class="token number">2</span>        call    void f(X)                           lea     <span class="token register variable">rcx</span>, QWORD PTR <span class="token operator">[</span><span class="token register variable">rsp</span><span class="token operator">+</span><span class="token number">32</span><span class="token operator">]</span>        mov     QWORD PTR <span class="token operator">[</span><span class="token register variable">rsp</span><span class="token operator">+</span><span class="token number">32</span><span class="token operator">]</span>, <span class="token number">1</span>        mov     QWORD PTR <span class="token operator">[</span><span class="token register variable">rsp</span><span class="token operator">+</span><span class="token number">40</span><span class="token operator">]</span>, <span class="token number">2</span>        call    void g(X const <span class="token operator">&amp;</span>)        xor     <span class="token register variable">eax</span>, <span class="token register variable">eax</span>        add     <span class="token register variable">rsp</span>, <span class="token number">56</span>                                ret     <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到两次函数调用产生的代码完全相同，也就是说对于 Windows x64 ABI 来说，大于<code>8</code>字节的结构体无论是通过引用传递还是值传递，生成的代码都是一样的。</p><ul><li><strong>unique_ptr 和 raw_ptr 的效率</strong></li></ul><p><code>unique_ptr</code>只是对裸指针简单包装一层嘛，所以他们效率应该一致？ CPPCON 上 <a href="https://www.bilibili.com/video/BV1qp421y75W/?spm_id_from=333.999.0.0">There are no zero-cost abstractions</a> 就讨论这个问题。这里不谈异常导致的额外开销（析构函数导致编译器必须额外生成清理栈帧的代码），仅仅讨论一个 C++ 对象（小于<code>8</code>字节）能使用寄存器传参吗？对于一个完全 <a href="https://en.cppreference.com/w/cpp/language/classes#Trivial_class">trivial</a> 的类型来说，是没问题的，它表现得和一个 C 语言的结构体几乎完全一样。但是如果不满足呢？</p><p>比如自定义了拷贝构造函数，还能放寄存器里面吗？其实从逻辑上就不能，为什么呢？C++ 是允许我们对函数参数取地址的，那如果参数是整形，那么它通过寄存器传参，那取地址的结果哪里来的呢？实验一下，就知道了</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>生成的对应汇编如下</p><pre class="line-numbers language-nasm"><code class="language-nasm">g(int):        sub     <span class="token register variable">rsp</span>, <span class="token number">24</span>        mov     DWORD PTR <span class="token operator">[</span><span class="token register variable">rsp</span><span class="token operator">+</span><span class="token number">12</span><span class="token operator">]</span>, <span class="token register variable">edi</span>        lea     <span class="token register variable">rdi</span>, <span class="token operator">[</span><span class="token register variable">rsp</span><span class="token operator">+</span><span class="token number">12</span><span class="token operator">]</span>        call    f(int<span class="token operator">&amp;</span>)        mov     <span class="token register variable">eax</span>, DWORD PTR <span class="token operator">[</span><span class="token register variable">rsp</span><span class="token operator">+</span><span class="token number">12</span><span class="token operator">]</span>        add     <span class="token register variable">rsp</span>, <span class="token number">24</span>        ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现，这里把<code>edi</code>（用于传递第一个整形参数）里面的值拷贝到了 <code>rsp+12</code> 这个地址，也就是栈上，之后把这个地址传递给了<code>f</code>。也就是说，如果一个函数参数通过寄存器传递，如果在某些情况下需要它的地址，编译器会把这个参数拷贝到栈上。<strong>但是无论如何，用户是观察不到这些拷贝过程的，因为它们的拷贝构造函数是<code>trivial</code>的。不影响最终代码执行结果的任何优化都是符合 as if 原则的。</strong></p><p>那么如果这个对象有用户定义的拷贝构造函数，假设参数通过寄存器传递，就可能会导致额外的拷贝构造函数调用，并且用户可以观察到这个副作用。显然这是不合理的，所以不允许拥有自定义拷贝构造函数的对象通过寄存器传参，那通过栈传递呢？实际上也会遇到类似的拷贝困境。于是最终这类对象只能通过引用传递了。<strong>注意，给拷贝构造显式标记为<code>delete</code>也算是自定义拷贝构造函数。</strong></p><p>所以对于<code>unique_ptr</code>来说，只能通过引用传递，无论你函数签名写成<code>void f(unique_ptr&lt;int&gt;)</code>还是<code>void f(unique_ptr&lt;int&gt;&amp;)</code>，最后在传参处生成的二进制代码都是一样的。但是裸指针却可以通过寄存器安全的传递。综上所述，<code>unique_ptr</code>和裸指针的效率并不是完全一致的。</p><blockquote><p>实际上对于一个非 trivial 的 C++ 对象，究竟能否使用寄存器传参的实际情况更复杂一些，相关的内容参考对应 ABI 中的相关小节，这里不过多描述。另外 C++ 对象如何传递这部分规定，究竟属于操作系统的 ABI 还是 C++ 编译器 ABI 这个问题也并不是很明确。</p></blockquote><h2 id="C-Standard"><a href="#C-Standard" class="headerlink" title="C++ Standard"></a>C++ Standard</h2><p>终于说完了操作系统层面的保证，由于偏向底层，涉及到较多汇编，对于不那么熟悉汇编的读者，读起来可能有些困难。不过接下来的内容基本就和汇编没什么关系了，可以放心阅读。</p><p>我们都知道 C++ 标准没有明确规定 ABI，但并不是完全没有规定，它对于编译器的实现是有一些要求的，例如：</p><ul><li>结构体成员地址按照声明顺序 <a href="https://en.cppreference.com/w/c/language/struct#Explanation">递增</a>，这保证了编译器不会对结构体成员进行重新排序</li><li>满足 <a href="https://en.cppreference.com/w/cpp/language/data_members#Standard-layout">Standard Layout</a> 约束的结构体需要与相应的 C 结构体布局兼容</li><li>满足 <a href="https://en.cppreference.com/w/cpp/types/is_trivially_copyable">Trivially Copyable</a> 约束的结构体可以使用<code>memmove</code>或者<code>memcpy</code>进行拷贝得到一个完全相同的全新对象</li><li><code>...</code></li></ul><p>另外，由于 C++ 一直在推出新的版本。同一份代码，我使用新标准和旧标准分别进行编译，得到的结果相同吗（不考虑使用宏控制 C++ 版本进行条件编译的影响）？这就要看 C++ 标准层面对 ABI 兼容性的保证了，事实上，C++ 标准尽可能的保证<strong>向后兼容性</strong>。也就是说，两段代码，使用旧标准和新标准编译出来的代码是完全一样的。</p><p>然而，也有极少数的例外，例如（我只找得到这些，欢迎评论区补充）：</p><ul><li>C++17 把<code>noexcept</code>作为函数类型的一部分，这会影响函数最后生成的 mangling name</li><li>C++20 引入的<code>no_unique_address</code>，MSVC 目前仍然没直接支持，因为会导致 ABI Broken</li></ul><p>更多时候，C++ 新版本会在加入新的语言特性的同时带来新的 ABI，而不会影响旧的代码，例如 C++23 加入的两个新特性：</p><h3 id="Explicit-Object-Parameter"><a href="#Explicit-Object-Parameter" class="headerlink" title="Explicit Object Parameter"></a><a href="https://en.cppreference.com/w/cpp/language/member_functions#Explicit_object_parameter">Explicit Object Parameter</a></h3><p>在 C++23 之前，事实上没有<strong>合法</strong>的手段获取一个成员函数的地址，我们唯一能做的就是获取成员指针（关于成员指针是什么，可以参考这篇 <a href="https://zhuanlan.zhihu.com/p/659510753">文章</a> 的内容）</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> X <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">auto</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>X<span class="token operator">::</span>f<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// p is a pointer to member function of X</span><span class="token comment" spellcheck="true">// type of p is void (X::*)(int)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>想要获取使用成员函数作为回调函数，只能使用 lambda 表达式包装一层</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> X <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">using</span> Fn <span class="token operator">=</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>X<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Fn p <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>A<span class="token operator">*</span> self<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> self<span class="token operator">-</span><span class="token operator">></span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这其实很麻烦，没有任何必要，而且这层包装可能会导致额外的函数调用开销。某种程度上这算是个历史遗留问题，<code>32</code>位系统上对成员函数的调用约定有些特殊（广为人知的<code>thiscall</code>），而 C++ 中并没有调用约定相关的内容，所以搞了个成员函数指针这么个东西。旧的代码为了 ABI 兼容性已经无法改变，但是新的可以，C++23 加入了显式对象参数，我们现在可以明确<code>this</code>的传入方式了，甚至可以使用值传递</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> X <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 这里的 this 只是个标记作用，为了和旧语法区分开来</span>    <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">this</span> X self<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// pass by value</span>    <span class="token keyword">void</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token keyword">this</span> X<span class="token operator">&amp;</span> self<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// pass by reference</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>被显式<code>this</code>标记的函数也可以直接获取函数地址了，就和普通的函数一样</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token operator">&amp;</span>X<span class="token operator">::</span>f<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// type of f is void(*)(X, int)</span><span class="token keyword">auto</span> g <span class="token operator">=</span> <span class="token operator">&amp;</span>X<span class="token operator">::</span>g<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// type of g is void(*)(X*, int)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>所以新代码可以都采用这种写法，只有好处，没有坏处。</p><h3 id="Static-Operator"><a href="#Static-Operator" class="headerlink" title="Static Operator()"></a><a href="https://en.cppreference.com/w/cpp/feature_test#cpp_static_call_operator">Static Operator()</a></h3><p>标准库中有一些仿函数，里面什么成员都没有，只有一个<code>operator()</code>，例如<code>std::hash</code></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">struct</span> hash <span class="token punctuation">{</span>    std<span class="token operator">::</span>size_t <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>T <span class="token keyword">const</span><span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>尽管这是个空的结构体，但是由于<code>operator()</code>是成员函数，所以有一个隐式<code>this</code>参数。在非内联调用的情况下仍然需要传递一个无用的空指针。这个问题在 C++23 中得到了解决，可以直接定义<code>static operator()</code>，从而避免这个问题</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">struct</span> hash <span class="token punctuation">{</span>    <span class="token keyword">static</span> std<span class="token operator">::</span>size_t <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>T <span class="token keyword">const</span><span class="token operator">&amp;</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>static</code>也就意味着这是个静态函数了，使用上还是和原来一样</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>hash<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> h<span class="token punctuation">;</span>std<span class="token operator">::</span>size_t n <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>但这里只是拿<code>hash</code>举个例子，实际上标准库的代码为了 ABI 兼容性已经不会改动了。新代码可以使用这个特性，来避免不必要的<code>this</code>传递。</p><h2 id="Compiler-Specific"><a href="#Compiler-Specific" class="headerlink" title="Compiler Specific"></a>Compiler Specific</h2><p>接下来就到了重头戏了，实现定义的部分，这部分似乎是被人诟病最多的内容了。然而事实真的如此吗？让我们一点点往下看。</p><h3 id="De-Facto-Standard"><a href="#De-Facto-Standard" class="headerlink" title="De Facto Standard"></a>De Facto Standard</h3><p>C++ 中的一些抽象最终是要落实到实现上的，而标准有没有规定如何实现，那这部分内容就由编译器自由发挥，例如：</p><ul><li>name mangling 的规则（为了实现函数重载和模板函数）</li><li>复杂类型的布局（例如含有虚继承）</li><li>虚函数表的布局</li><li>RTTI 的实现</li><li>异常处理</li><li><code>...</code></li></ul><p>如果编译器对这些部分的实现不同，那么最后不同编译器编译出的二进制产物自然是互不兼容，不能混用的。</p><blockquote><p>在上世纪<code>90</code>年代，那时候还是 C++ 发展的黄金时期，各个厂商都致力于实现自己的编译器并扩大基本盘，争夺用户。出于竞争关系，不同编译器之间使用不同的 ABI 是很常见的行为。随着时代的发展，它们中的大多数已经退出了历史舞台，要么停止更新，要么仅做维护，不再跟进 C++ 的新标准。浪潮过后，留下的只有 GCC，Clang 和 MSVC 这三大编译器。</p></blockquote><p>在今天，C++ 编译器的 ABI 已经基本得到统一，主流的 ABI 只有两套：</p><ul><li>Itanium C++ ABI，具有公开透明的文档</li><li>MSVC C++ ABI，并没有官方的文档</li></ul><blockquote><p>尽管名为 Itanium C++ ABI，但它实际上是用于 C++ 的跨架构 ABI，除了 MSVC 之外，几乎所有的 C++ 编译器都在使用它，尽管在异常处理方面的细节略有不同。历史上，C++ 编译器都以各自的方式处理 C++ ABI。当英特尔大力推广 Itanium 时，他们希望避免不兼容问题，因此，他们为 Itanium 上的所有 C++ 供应商创建了一个标准化的 ABI。后来，由于各种原因，GCC 需要修改其内部 ABI，而且鉴于它已经支持了 Itanium ABI（为 Itanium 处理器），他们选择将 ABI 定义扩展到所有架构，而不是创建自己的 ABI。从那时起，所有主要的编译器除了 MSVC 都采用了跨架构的 Itanium ABI，并且即使 Itanium 处理器本身不再接收维护，该 ABI 仍然得到了维护。</p></blockquote><p>在 Linux 平台上，GCC 和 Clang 都使用 Itanium ABI，所以两个编译器编译出来的代码就具有互操作性，可以链接到一起并运行。而在 Windows 平台上，情况则稍微复杂些，默认的 MSVC 工具链使用自己的 ABI。但是除了 MSVC 工具链以外，还有人把 GCC 移植到 Windows 上了，也就是我们熟知的 <a href="https://www.mingw-w64.org//">MinGW</a> 工具链，它使用的仍然是 Itanium ABI。这两套 ABI 互不兼容，编译出来的代码不能直接链接到一起。而 Windows 平台上的 Clang 可以通过编译选项控制使用这两种 ABI 的其中的一种。</p><blockquote><p>注意：MinGW 既然在 Windows 上运行，那它生成的代码的调用约定自然是尽量遵守 Windows x64 ABI 的，最终生成的可执行文件格式也是 PE32+。但是它的使用的 C++ ABI 仍然是 Itanium ABI，这两者并没有必然关联。</p></blockquote><p>考虑到 C++ 巨大的 codebase，这两套 C++ ABI 已经基本稳定，不会再改动了，<strong>所以我们现在其实可以说 C++ 编译器具有稳定的 ABI</strong>。怎么样，是不是和网上主流的说法不同？但是事实的确就摆在这里。</p><blockquote><p>MSVC 从 <a href="https://learn.microsoft.com/en-us/cpp/porting/binary-compat-2015-2017?view=msvc-170">2015</a> 的版本往后开始保证 ABI 稳定。GCC 从 3.4 开始使用 Itanium ABI 并保证 ABI 稳定。</p></blockquote><h3 id="Workaround"><a href="#Workaround" class="headerlink" title="Workaround"></a>Workaround</h3><p>尽管基础的 ABI 不再改变，但是升级编译器版本仍然可能会导致编译出来的库发生 ABI Broken，为什么呢？</p><p>这其实不难理解，首先编译器也是软件，只要是软件就可能有 BUG。有时候为了修复 BUG，会被迫做出一些 ABI Broken（一般会在新版本的发行介绍中详细说明）。例如 GCC 有一个编译选项 <code>-fabi-version</code> 用于专门控制这些不同的版本，其中一些内容如下：</p><ul><li>版本<code>7</code>首次出现在 G++ 4.8 中，它将<code>nullptr_t</code>视为内建类型，并修正了默认参数作用域中 Lambda 表达式的名称编码</li><li>版本<code>8</code>首次出现在 G++ 4.9 中，修正了带有函数 CV 限定符的函数类型的替换行为</li><li>版本<code>9</code>首次出现在 G++ 5.2 中，修正了<code>nullptr_t</code>的对齐方式</li></ul><p>另外对于用户来说，也可能之前为了绕过编译器的 BUG，编写了一些特殊的代码，我们一般把这个叫做 workaround。当 BUG 被修复之后，这些 workaround 很可能起到反作用。从而导致 ABI 出现不兼容</p><h3 id="Important-Options"><a href="#Important-Options" class="headerlink" title="Important Options"></a>Important Options</h3><p>除此之外，编译器还提供了一些列选项用来控制编译器的行为，这些选项可能会影响 ABI，比如：</p><ul><li><code>-fno-strict-aliasing</code>：关闭严格别名</li><li><code>-fno-exceptions</code>：关闭异常</li><li><code>-fno-rtti</code>：关闭 RTTI</li><li><code>...</code></li></ul><p>给不同选项编译出来的库链接到一起的时候，尤其要兼容性问题。例如你的代码关闭了严格别名，但是依赖的外部库开启了严格别名，很可能指针错误的传播，从而导致程序出错。</p><p>我最近就遇到了这种情况，我在给 LLVM 的一些函数编写 Python Wrapper，通过 <a href="https://github.com/pybind/pybind11">pybind11</a>。而 pybind11 要求必须打开 RTTI，但是 LLVM 默认构建是关闭异常和 RTTI 的，所以最后代码就链接不到一块去了。一开始我是自己编译了一份开 RTTI 的 LLVM，这会导致二进制膨胀，后来发现没必要这样做。我其实没有用到 LLVM 里面类型的 RTTI 信息，只是由于写在同一个文件里面，编译器认为我用到了。于是把使用到 LLVM 部分的代码单独编译成一个动态库，再和使用 pybind11 部分的代码一起链接就解决了。</p><h2 id="Runtime-amp-Library"><a href="#Runtime-amp-Library" class="headerlink" title="Runtime &amp; Library"></a>Runtime &amp; Library</h2><p>这一小节主要讨论的就是，一个 C++ 程序依赖的库的 ABI 稳定性。<strong>理想情况下是，对于一个可执行程序，使用新版本的动态库替换旧版本的动态库，仍然不影响它运行。</strong></p><p>三大 C++ 编译器都有自己的标准库</p><ul><li>MSVC 对应的是 msvc stl</li><li>GCC 对应的是 libstdc++</li><li>Clang 对应的是 libc++</li></ul><p>我们在前面提到过，C++ 标准尽量保证 ABI 向后兼容。即使是从 C++98 到 C++11 这样的大更新，旧代码的 ABI 也没有受到太大影响，导致 ABI Break Change 的措辞改变更是完全找不到。</p><p>但是对于 C++ 标准库来说情况就有些不一样了，从 C++98 到 C++11，标准库经历了一次大的 ABI Break Change。标准库中修改了对一些容器实现的要求，例如<code>std::string</code>。这导致原来广泛使用的 COW 实现不符合新标准，于是在 C++11 中不得不采用新实现。这也就导致了 C++98 和 C++11 之间的标准库 ABI Broken。不过在这之后，标准库的 ABI 一般相对稳定，各家实现也尽量保证。</p><p>另外由于 RTTI 和 Exception 一般可以关掉，所以这两项功能可能由单独的运行时库来负责，比如 MSVC 的 vcruntime和 libc++ 的 libcxxabi。</p><blockquote><p>值得一提的是，libcxxabi 中还包含了对静态局部变量初始化的支持，涉及到的主要函数是 <strong>cxa_guard_acquire,</strong> cxa_guard_release。使用它们来保证静态局部变量只在运行时初始化一次，如果对具体的实现感到好奇，可以查阅相关源码。</p></blockquote><p>还有就是负责一些底层功能的运行时库，除了标准库以外，C++ 程序一般还需要链接 C 运行时：</p><ul><li>在 Windows 上，必须链接 CRT</li><li>在 Linux 上 取决于所使用的发行版和编译环境，可能会链接 glibc或者 musl</li></ul><p>C 运行时除了提供 C 标准库的实现外，还负责程序的初始化和清理。它负责调用<code>main</code>函数，并管理程序的启动和终止过程，包括执行一些必要的初始化和清理工作。对于大多数在操作系统上的软件来说，链接它是必须的。</p><p>最理想的状态自然是，升级编译器的时候把这些对应的运行时库版本也升级，避免不必要的麻烦。但是在实际项目中，依赖关系可能十分复杂，可能会引发连锁反应。</p><h2 id="User-Code"><a href="#User-Code" class="headerlink" title="User Code"></a>User Code</h2><p>最后我们来谈谈用户代码自身的改变导致的 ABI 问题，如果希望将你的库以二进制形式进行分发，那么当用户量达到一定程度之后，ABI 兼容性就很重要了。</p><p>在第一小节讨论调用约定的时候，就提到过变更结构体定义导致的 ABI 不兼容问题。那如果既想要保证 ABI 兼容，又想要为以后得扩展留下空间怎么办呢？答案就是在运行时处理了</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> X<span class="token punctuation">{</span>    size_t x<span class="token punctuation">;</span>    size_t y<span class="token punctuation">;</span>    <span class="token keyword">void</span><span class="token operator">*</span> reserved<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过一个<code>void*</code>指针为以后的扩展预留空间。可以根据它来判断不同的版本，比如</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>X<span class="token operator">*</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Reserved<span class="token operator">*</span> r <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Reserved<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token operator">></span>reserved<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token operator">-</span><span class="token operator">></span>version <span class="token operator">==</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// do something</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token operator">-</span><span class="token operator">></span>version <span class="token operator">==</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// do something else</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就能在添加新的功能的同时而不影响原有的代码。</p><p>在对外暴露接口的时候，对于函数参数中有自定义析构函数的类型，也要格外注意。假设我们要暴露<code>std::vector</code>作为返回值，例如把下面这个简单的代码编译成动态库，并且使用<code>\MT</code>选项来静态链接 Windows CRT。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">__declspec</span><span class="token punctuation">(</span>dllexport<span class="token punctuation">)</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后我们写一个源文件，链接到刚才编译的这个动态库，调用这个函数</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> vec <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译运行，发现直接崩溃了。如果关闭<code>\MT</code>重新编译一遍动态库，然后运行，发现一切正常。很奇怪，为什么依赖的动态库静态链接 CRT 会导致代码崩溃？</p><p>思考一下上面的代码不难发现，<code>vec</code>的构造实际上发生在动态库里面，而析构则是发生在<code>main</code>函数里面。更进一步，其实就是内存是在动态库里面分配的，释放是在<code>main</code>函数里面。但是每一份 CRT 都有自己的<code>malloc</code>，<code>free</code>（类似于不同进程间的内存）。<strong>你不能把 CRT A 分配的内存交给 CRT B 释放</strong>，这就是问题的根源。所以之后不静态链接到 CRT 就没事了，它们用的都是同一个<code>malloc</code>，<code>free</code>。不仅仅是 WIndows CRT，对于 Linux 上的 glibc 或者 musl 也是一样的。</p><h3 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h3><p>对于任何带有自定义析构函数的 C++ 类型都可能出现上面那种情况，<strong>由于种种原因，构造函数和析构函数的调用跨越动态库边界，RAII 的约定被打破，导致严重的错误。</strong></p><p>如何解决呢？那自然是函数参数和返回值都不使用带有析构函数的类型了，只使用 POD 类型。例如上面那个例子需要改成</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> Vec <span class="token operator">=</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token function">__declspec</span><span class="token punctuation">(</span>dllexport<span class="token punctuation">)</span> Vec <span class="token function">create_Vec</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">__declspec</span><span class="token punctuation">(</span>dllexport<span class="token punctuation">)</span> <span class="token keyword">void</span> <span class="token function">destroy_Vec</span><span class="token punctuation">(</span>Vec vec<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">delete</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>vec<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后使用就得这样</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> Vec <span class="token operator">=</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">;</span>Vec <span class="token function">create_Vec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">destroy_Vec</span><span class="token punctuation">(</span>Vec vec<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Vec vec <span class="token operator">=</span> <span class="token function">create_Vec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">destroy_Vec</span><span class="token punctuation">(</span>vec<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实我们就是在按照 C 风格的 RAII 来进行封装。更进一步，如果想要解决 C 和 C++ 由于 mangling 不同而导致的链接问题，可以使用<code>extern &quot;C&quot;</code>来修饰函数</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">extern</span> <span class="token string">"C"</span> <span class="token punctuation">{</span>    Vec <span class="token function">create_Vec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">destroy_Vec</span><span class="token punctuation">(</span>Vec vec<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样的话 C 语言也可以使用上述的导出函数了，但是如果代码量很大的话，把全部的函数都封装成这样的 API 显然不太现实，那就只能把 C++ 的类型暴露在导出接口中，然后小心地管理依赖项（比如所有依赖库全都静态链接）。具体选择哪一种方式，还是要看项目大小和复杂度，然后再做定夺。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>到这里，我们终于讨论完了影响 C++ 程序 ABI 的主要因素。可以清楚地看到，C++ 标准、编译器厂商和运行时库都在尽力维护 ABI 的稳定性，C++ ABI 并没有很多人说的那么不堪，那么不稳定。对于小型项目而言，带源码静态链接，几乎不会有任何的兼容性问题。对于那些历史悠久的大型项目来说，由于复杂的依赖关系，升级某些库的版本可能会导致程序崩溃。<strong>但这并不是 C++ 的错，对于大型项目的管理，早已超出了单纯的语言层面，不能指望通过更换编程语言来解决这些问题</strong>。实际上，学习软件工程就是在学习如何应对巨大的复杂度，如何保证复杂系统的稳定性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Application Binary Interface 也就是我们常说的 ABI，是个让人感觉到既熟悉又陌生的概念。熟悉在哪里？讨论问题的
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="读书笔记" scheme="https://JoyTsing.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>grpc与CMake中find_package()命令神奇的寻址</title>
    <link href="https://joytsing.github.io/posts/48298/"/>
    <id>https://joytsing.github.io/posts/48298/</id>
    <published>2024-05-17T12:33:13.000Z</published>
    <updated>2024-05-17T13:36:21.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>问题总是在你意想不到的地方出现。</p><h2 id="重启了个电脑怎么就报错了呢"><a href="#重启了个电脑怎么就报错了呢" class="headerlink" title="重启了个电脑怎么就报错了呢"></a>重启了个电脑怎么就报错了呢</h2><p>昨天还在用，更新了一下写了个</p><p><img src="/posts/48298/faf973679d56abb145795bcf0223f26d.png" alt="有毛病"></p><h2 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2><p>长话短说，我一开始以为是谷歌的锅，看了一圈issue还去Stack Overflow上差了发现没人遇到我这个问题，当时我就怀疑是不是版本的问题，然后我把版本号打出来一看20230802（没意识到用的是最新的absl）</p><p>在这之后去还去看了absl的abslTargets.cmake，确实是有的，那么其实可以知道不是谷歌的锅，肯定又是和之前protobuf一样的全局变量的问题，但是这次问题就诡异在我没有显示或者隐式的引入过任何absl的库，那么为什么会报错。</p><p><img src="/posts/48298/f1fbd7ec93ad84e5608ffe2dfdc16c1e.png" alt="确实有"></p><p>后面还下了最新的absl加入到全局环境变量里面也不行（太神奇了），到后面想到可以看它引用的库地址在哪，一看发现非常神秘的找到了我曾经make过的库，但是这个库和grpc库是同级的。</p><p><img src="/posts/48298/1e41604d21dcc682b4c454b5b2bcf652.png" alt="要不是我版本名字取错了我还真没意识到"></p><p>直接删掉一试，发现就好了。</p><p><img src="/posts/48298/06da1d76fb8edc247c1b6e2cf8229da7.png" alt="尝试修改"></p><p>通过编译。</p><p><img src="/posts/48298/8a5d98be8540f8c41a082bb8510cd364.png" alt="终于解决了"></p><p>那么为什么grpc库会找到同级目录下的其他absl？</p><p><img src="/posts/48298/5f8f7c535e66dbc0c3ca6aedb553afea.png" alt="原来是你"></p><h2 id="find-package-查找逻辑"><a href="#find-package-查找逻辑" class="headerlink" title="find_package()查找逻辑"></a>find_package()查找逻辑</h2><p>CMAKE<strong>先在CMAKE_MODULE_PATH变量对应的路径中查找。如果路径为空，或者路径中查找失败，则在cmake module directory（cmake安装时的Modules目录，比如/usr/local/share/cmake/Modules）查找。</strong></p><p>搜索标准的系统环境变量PATH，其中如果是以/bin或者/sbin结尾的，会自动转化为其父目录，发现没有，makeInstall下面有一个bin文件夹，所以会自动转换，在同级文件夹下去找，而不是去子文件夹中寻找（优先级低）。</p><p>CMake为该软件包构造了一组可能的安装前缀。在每个前缀下的几个目录中搜索配置文件。下表显示了搜索的目录。每个条目均用于遵循Windows（<code>W</code>），UNIX（<code>U</code>）或Apple（<code>A</code>）约定的安装树：</p><pre class="line-numbers language-css"><code class="language-css">&lt;prefix>/                                                       <span class="token punctuation">(</span>W<span class="token punctuation">)</span>&lt;prefix>/<span class="token punctuation">(</span>cmake|CMake<span class="token punctuation">)</span>/                                         <span class="token punctuation">(</span>W<span class="token punctuation">)</span>&lt;prefix>/&lt;name>*/                                               <span class="token punctuation">(</span>W<span class="token punctuation">)</span>&lt;prefix>/&lt;name>*/<span class="token punctuation">(</span>cmake|CMake<span class="token punctuation">)</span>/                                 <span class="token punctuation">(</span>W<span class="token punctuation">)</span>&lt;prefix>/<span class="token punctuation">(</span>lib/&lt;arch>|lib*|share<span class="token punctuation">)</span>/cmake/&lt;name>*/                 <span class="token punctuation">(</span>U<span class="token punctuation">)</span>&lt;prefix>/<span class="token punctuation">(</span>lib/&lt;arch>|lib*|share<span class="token punctuation">)</span>/&lt;name>*/                       <span class="token punctuation">(</span>U<span class="token punctuation">)</span>&lt;prefix>/<span class="token punctuation">(</span>lib/&lt;arch>|lib*|share<span class="token punctuation">)</span>/&lt;name>*/<span class="token punctuation">(</span>cmake|CMake<span class="token punctuation">)</span>/         <span class="token punctuation">(</span>U<span class="token punctuation">)</span>&lt;prefix>/&lt;name>*/<span class="token punctuation">(</span>lib/&lt;arch>|lib*|share<span class="token punctuation">)</span>/cmake/&lt;name>*/         <span class="token punctuation">(</span>W/U<span class="token punctuation">)</span>&lt;prefix>/&lt;name>*/<span class="token punctuation">(</span>lib/&lt;arch>|lib*|share<span class="token punctuation">)</span>/&lt;name>*/               <span class="token punctuation">(</span>W/U<span class="token punctuation">)</span>&lt;prefix>/&lt;name>*/<span class="token punctuation">(</span>lib/&lt;arch>|lib*|share<span class="token punctuation">)</span>/&lt;name>*/<span class="token punctuation">(</span>cmake|CMake<span class="token punctuation">)</span>/ <span class="token punctuation">(</span>W/U<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以会去搜索标准的系统环境变量，在bin的同级目录中就找到了老版本的absl，所以编译就失败了。说实话我没想到影响今天编译的会是昨晚上添加的可执行bin路径，令人感叹。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;问题总是在你意想不到的地方出现。&lt;/p&gt;
&lt;h2 id=&quot;重启了个电脑怎么就报错了呢&quot;&gt;&lt;a href=&quot;#重启了个电脑怎么就报错了呢&quot; c
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>RPC的基本原理和层次架构</title>
    <link href="https://joytsing.github.io/posts/17654/"/>
    <id>https://joytsing.github.io/posts/17654/</id>
    <published>2024-05-14T13:02:16.000Z</published>
    <updated>2024-05-14T13:26:20.350Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>本文来自srpc作者李颖欣。</strong></p><p>只要涉及到网络通信，必然涉及到网络协议，应用层也是一样。在应用层最标准和常用的就是HTTP协议。但在很多性能要求较高的场景各大企业内部也会自定义的 RPC 协议。举个例子，就是相当于各个省不但用官方普通话，还都有自己的方言，RPC就相当于是一个方言。</p><p><strong>RPC</strong> 的全称是 <strong>Remote Procedure Call</strong>，翻译过来就是远程过程调用，其实这个名称过分强调了和LPC（本地过程调用）的对比。没有突出出来 RPC 本身涉及到的一些技术特点。现在从三个角度聊聊 RPC</p><ul><li>RPC是什么：通过和HTTP的对比来帮大家了解RPC</li><li>RPC有什么：介绍了RPC用到的用户桩代码、IDL序列化、压缩、协议、通信等技术点</li><li>RPC生命周期：详细探讨RPC从请求发出到收到返回的全过程</li></ul><h2 id="RPC是什么"><a href="#RPC是什么" class="headerlink" title="RPC是什么"></a>RPC是什么</h2><p>RPC可以分为两部分：<strong>用户调用接口</strong> + <strong>具体网络协议</strong>。前者为开发者需要关心的，后者由框架来实现。</p><h3 id="1-用户调用接口"><a href="#1-用户调用接口" class="headerlink" title="1. 用户调用接口"></a>1. 用户调用接口</h3><p>举个例子，定义一个函数希望函数如果输入为“Hello World”的话，输出给一个“OK”，那么这个函数是个本地调用。如果一个远程服务收到“Hello World”可以给我们返回一个“OK”，那么这是一个远程调用。我们会和服务约定好远程调用的函数名。因此，我们的用户接口就是：<strong>输入</strong>、<strong>输出</strong>、<strong>远程函数名</strong>。</p><h3 id="2-具体网络协议"><a href="#2-具体网络协议" class="headerlink" title="2. 具体网络协议"></a>2. 具体网络协议</h3><p>这是框架来实现的，把开发者要发出和接收的内容以某种应用层协议打包进行网络收发。这里可以和HTTP进行一个明显的对比：</p><ul><li><p>RPC是一种自定义网络协议，由具体框架来定，比如SRPC里支持的RPC协议有：SRPC / thrift / BRPC / tRPC，并且也是<strong>tRPC</strong>协议目前唯一的开源实现，拿其中的SogouRPC-std protocol为例给大家看看RPC协议的大概样子：</p><p><img src="/posts/17654/640-1715693046838-12.webp" alt></p></li><li><p>HTTP也是一种网络协议，但包的内容是固定的，必须是：请求行 + 请求头 + 请求体；</p><p><img src="/posts/17654/640.webp" alt></p></li></ul><h3 id="3-进一步思考"><a href="#3-进一步思考" class="headerlink" title="3. 进一步思考"></a>3. 进一步思考</h3><p>上图对应的颜色，所实现的功能是类似的。为什么大家都长差不多呢？</p><p>这里就需要搞清楚，我们想要实现用户接口，需要怎么做？最重要需要支持以下三个功能：</p><ul><li>定位要调用的服务；</li><li>把完整的消息切下来；</li><li>让我们的消息向前/向后兼容；</li></ul><p>这样既可以让消息内保证一定的灵活性，又可以方便拿下一块数据，去调用用户想要的服务。</p><p>我们用一个表格来看一下HTTP和RPC分别是怎么解决的：</p><table><thead><tr><th align="left"></th><th align="left">定位要调用的服务</th><th align="left">消息长度</th><th align="left">消息前后兼容</th></tr></thead><tbody><tr><td align="left">HTTP</td><td align="left">URL</td><td align="left">header里Content-Length</td><td align="left">body里自己解决</td></tr><tr><td align="left">RPC</td><td align="left">指定Service和Method名</td><td align="left">协议header里自行约定</td><td align="left">交给具体IDL</td></tr></tbody></table><p>因此，大家都会需要类似的结构去组装一条完整的用户请求，而第三部分的body只要框架支持，RPC协议和HTTP是可以互通的！因此开发者完全可以根据自己的业务需求进行选型，接下来我们看一下RPC的层次架构，就可以明白为什么不同RPC框架之间的互通、以及RPC和HTTP协议又是如何做到互通的。</p><h2 id="RPC有什么"><a href="#RPC有什么" class="headerlink" title="RPC有什么"></a>RPC有什么</h2><p>我们可以借SRPC的架构，看一下RPC框架从用户到系统都有哪些层次，以及SRPC目前所横向支持的功能是什么：</p><ul><li><strong>用户代码</strong>（client的发送函数/server的函数实现）</li><li><strong>IDL序列化</strong>（protobuf/thrift serialization）</li><li><strong>数据组织</strong> （protobuf/thrift/json）</li><li><strong>压缩</strong>（none/gzip/zlib/snappy/lz4）</li><li><strong>协议</strong> （Sogou-std/Baidu-std/Thrift-framed/TRPC）</li><li><strong>通信</strong> （TCP/HTTP）</li></ul><p>我们先关注以下三个层级：</p><p><img src="/posts/17654/640-1715692787329-3.webp" alt></p><p>如图从左到右，是用户接触的最多到最少的层次。IDL层会根据开发者定义的请求/回复结构进行代码生成，目前用得比较多的是protobuf和thrift，而刚才说到的用户接口和前后兼容问题，都是IDL层来解决的。SRPC对于这两个IDL的用户接口实现方式是：</p><ul><li>thrift：IDL纯手工解析，用户使用srpc是不需要链thrift的库的</li><li>protobuf：service的定义部分纯手工解析</li></ul><p>中间那列是具体的网络协议，而各RPC能互通，就是因为大家实现了对方的“语言”，因此可以协议互通。</p><p>而RPC作为和HTTP并列的层次，第二列和第三列理论上是可以两两结合的，只需要第二列的具体RPC协议在发送时，把HTTP相关的内容进行特化，不要按照自己的协议去发，而按照HTTP需要的形式去发，就可以实现RPC与HTTP互通。</p><h2 id="RPC的生命周期"><a href="#RPC的生命周期" class="headerlink" title="RPC的生命周期"></a>RPC的生命周期</h2><p>到此我们可以通过SRPC看一下，把request通过method发送出去并处理response再回来的整件事情是怎么做的：</p><p><img src="/posts/17654/640-1715692932973-6.webp" alt></p><p>根据上图，可以更清楚地看到刚才提及的各个层级，其中压缩层、序列化层、协议层其实是互相解耦打通的，在SRPC代码上实现得非常统一，横向增加任何一种压缩算法或IDL或协议都不需要也不应该改动现有的代码。</p><p><img src="/posts/17654/640-1715692973908-9.webp" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本文来自srpc作者李颖欣。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只要涉及到网络通信，必然涉及到网络协议，应用层也是一样。在应用
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Redis单线程高性能解密</title>
    <link href="https://joytsing.github.io/posts/55825/"/>
    <id>https://joytsing.github.io/posts/55825/</id>
    <published>2024-05-12T13:48:11.000Z</published>
    <updated>2024-05-15T09:04:00.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>仅仅靠单线程就可以支撑起每秒数万 QPS 的高处理能力，今天重点来看一下Redis 核心网络模块，很多时候网络是限制性能的重要因素。</p><h2 id="一、多路复用原理"><a href="#一、多路复用原理" class="headerlink" title="一、多路复用原理"></a>一、多路复用原理</h2><p>epoll可以说是老生常谈了，这里就放一张图吧。</p><p>性能提升思路很简单，就是让很多的用户连接来复用同一个进(线)程，这就是<strong>多路复用</strong>。<strong>多路</strong>指的是许许多多个用户的网络连接。<strong>复用</strong>指的是对进(线)程的复用。换到牧羊人的例子里，就是一群羊只要一个牧羊人来处理就行了。</p><p>不过复用实现起来是需要特殊的 socket 事件管理机制的，最典型和高效的方案就是 epoll。放到牧羊人的例子来，epoll 就相当于一只牧羊犬。</p><p>在 epoll 的系列函数里， epoll_create 用于创建一个 epoll 对象，epoll_ctl 用来给 epoll 对象添加或者删除一个 socket。epoll_wait 就是查看它当前管理的这些 socket 上有没有可读可写事件发生。</p><p><img src="/posts/55825/640-1715754558858-5.webp" alt></p><p>当网卡上收到数据包后，Linux 内核进行一系列的处理后把数据放到 socket 的接收队列。然后会检查是否有 epoll 在管理它，如果是则在 epoll 的就绪队列中插入一个元素。epoll_wait 的操作就非常的简单了，就是到 epoll 的就绪队列上来查询有没有事件发生就行了。关于 epoll 这只“牧羊犬”的工作原理参见：<a href="https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&mid=2247484905&idx=1&sn=a74ed5d7551c4fb80a8abe057405ea5e&scene=21#wechat_redirect">深入揭秘 epoll 是如何实现 IO 多路复用的</a> （或者深入理解Linux网络内核这本书）。</p><p>在基于 epoll 的编程中，和传统的函数调用思路不同的是，我们并不能主动调用某个 API 来处理。因为无法知道我们想要处理的事件啥时候发生。所以只好提前把想要处理的事件的处理函数注册到一个<strong>事件分发器</strong>上去。当事件发生的时候，由这个事件分发器调用回调函数进行处理。这类基于实现注册事件分发器的开发模式也叫 Reactor 模型。</p><h2 id="二、Redis-服务启动初始化"><a href="#二、Redis-服务启动初始化" class="headerlink" title="二、Redis 服务启动初始化"></a>二、Redis 服务启动初始化</h2><p>其中整个 Redis 服务的代码总入口在 src/server.c 文件中，如下。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: src/server.c</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 启动初始化</span>    <span class="token function">initServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 运行事件处理循环，一直到服务器关闭为止</span>    <span class="token function">aeMain</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>整个 Redis 的工作过程，就只需要理解清楚 main 函数中调用的 initServer 和 aeMain 这两个函数就足够了。在 initServer 这个函数内，Redis 做了这么三件重要的事情。</p><p><img src="/posts/55825/640.webp" alt></p><ul><li>创建一个 epoll 对象</li><li>对配置的监听端口进行 listen</li><li>把 listen socket 让 epoll 给管理起来</li></ul><h3 id="2-1-创建-epoll-对象"><a href="#2-1-创建-epoll-对象" class="headerlink" title="2.1 创建 epoll 对象"></a>2.1 创建 epoll 对象</h3><p>Redis 在操作系统提供的 epoll 对象基础上又封装了一个 eventLoop 出来，所以创建的时候是先申请和创建 eventLoop。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/ae.c</span>aeEventLoop <span class="token operator">*</span><span class="token function">aeCreateEventLoop</span><span class="token punctuation">(</span><span class="token keyword">int</span> setsize<span class="token punctuation">)</span> <span class="token punctuation">{</span>    aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">;</span>    eventLoop <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//将来的各种回调事件就都会存在这里</span>    eventLoop<span class="token operator">-></span>events <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>aeFileEvent<span class="token punctuation">)</span><span class="token operator">*</span>setsize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">aeApiCreate</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> eventLoop<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-绑定监听服务端口"><a href="#2-2-绑定监听服务端口" class="headerlink" title="2.2 绑定监听服务端口"></a>2.2 绑定监听服务端口</h3><p> Redis 中的 listen 过程，它在 listenToPort 函数中。虽然调用链条很长，但其实主要就是执行了个简单 listen 而已。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: src/redis.c</span><span class="token keyword">int</span> <span class="token function">listenToPort</span><span class="token punctuation">(</span><span class="token keyword">int</span> port<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>fds<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>count<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>bindaddr_count <span class="token operator">||</span> j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        fds<span class="token punctuation">[</span><span class="token operator">*</span>count<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">anetTcpServer</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>neterr<span class="token punctuation">,</span>port<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>                server<span class="token punctuation">.</span>tcp_backlog<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Redis 是支持开启多个端口的，所以在 listenToPort 中我们看到是启用一个循环来调用 anetTcpServer。在 anetTcpServer 中，逐步会展开调用，直到执行到 bind 和 listen 系统调用。</p><h3 id="2-3-注册事件回调函数"><a href="#2-3-注册事件回调函数" class="headerlink" title="2.3 注册事件回调函数"></a>2.3 注册事件回调函数</h3><p> initServer里面调用 aeCreateEventLoop 创建了 epoll，调用 listenToPort 进行了服务端口的 bind 和 listen。接着就开始调用 aeCreateFileEvent 来注册一个 accept 事件处理器。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: src/server.c</span><span class="token keyword">void</span> <span class="token function">initServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 2.1.1 创建 epoll</span>    server<span class="token punctuation">.</span>el <span class="token operator">=</span> <span class="token function">aeCreateEventLoop</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxclients<span class="token operator">+</span>CONFIG_FDSET_INCR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2.1.2 监听服务端口</span>    <span class="token function">listenToPort</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>port<span class="token punctuation">,</span>server<span class="token punctuation">.</span>ipfd<span class="token punctuation">,</span><span class="token operator">&amp;</span>server<span class="token punctuation">.</span>ipfd_count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2.1.3 注册 accept 事件处理器</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>ipfd_count<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span> server<span class="token punctuation">.</span>ipfd<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> AE_READABLE<span class="token punctuation">,</span>            acceptTcpHandler<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用 aeCreateFileEvent 时传的重要参数是 acceptTcpHandler，它表示将来在 listen socket 上有新用户连接到达的时候，该函数将被调用执行。我们来看 aeCreateFileEvent 具体代码。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: src/ae.c</span><span class="token keyword">int</span> <span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">,</span>        aeFileProc <span class="token operator">*</span>proc<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 取出一个文件事件结构</span>    aeFileEvent <span class="token operator">*</span>fe <span class="token operator">=</span> <span class="token operator">&amp;</span>eventLoop<span class="token operator">-></span>events<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 监听指定 fd 的指定事件</span>    <span class="token function">aeApiAddEvent</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> mask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 设置文件事件类型，以及事件的处理器</span>    fe<span class="token operator">-></span>mask <span class="token operator">|</span><span class="token operator">=</span> mask<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mask <span class="token operator">&amp;</span> AE_READABLE<span class="token punctuation">)</span> fe<span class="token operator">-></span>rfileProc <span class="token operator">=</span> proc<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mask <span class="token operator">&amp;</span> AE_WRITABLE<span class="token punctuation">)</span> fe<span class="token operator">-></span>wfileProc <span class="token operator">=</span> proc<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 私有数据</span>    fe<span class="token operator">-></span>clientData <span class="token operator">=</span> clientData<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数 aeCreateFileEvent 一开始，从 eventLoop-&gt;events 获取了一个 aeFileEvent 对象， eventLoop-&gt;events 数组，注册的各种事件处理器会保存在这个地方。接下来调用 aeApiAddEvent。这个函数其实就是对 epoll_ctl 的一个封装。主要就是实际执行 epoll_ctl EPOLL_CTL_ADD。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/ae_epoll.c</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">aeApiAddEvent</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// add or mod</span>    <span class="token keyword">int</span> op <span class="token operator">=</span> eventLoop<span class="token operator">-></span>events<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">.</span>mask <span class="token operator">==</span> AE_NONE <span class="token operator">?</span>            EPOLL_CTL_ADD <span class="token punctuation">:</span> EPOLL_CTL_MOD<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// epoll_ctl 添加事件</span>    <span class="token function">epoll_ctl</span><span class="token punctuation">(</span>state<span class="token operator">-></span>epfd<span class="token punctuation">,</span>op<span class="token punctuation">,</span>fd<span class="token punctuation">,</span><span class="token operator">&amp;</span>ee<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每一个 eventLoop-&gt;events 元素都指向一个 aeFileEvent 对象。在这个对象上，设置了三个关键东西</p><ul><li>rfileProc：读事件回调</li><li>wfileProc：写事件回调</li><li>clientData：一些额外的扩展数据</li></ul><p>当 epoll_wait 发现某个 fd 上有事件发生的时候，这样 redis 首先根据 fd 到 eventLoop-&gt;events 中查找 aeFileEvent 对象，然后再看 rfileProc、wfileProc 就可以找到读、写回调处理函数。回头看 initServer 调用 aeCreateFileEvent 时传参来看。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: src/server.c</span><span class="token keyword">void</span> <span class="token function">initServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 2.1.3 注册 accept 事件处理器</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>ipfd_count<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span> server<span class="token punctuation">.</span>ipfd<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> AE_READABLE<span class="token punctuation">,</span>            acceptTcpHandler<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>listen fd 对应的读回调函数 rfileProc 事实上就被设置成了 acceptTcpHandler，写回调没有设置，私有数据 client_data 也为 null。</p><h2 id="三、Redis-事件处理循环"><a href="#三、Redis-事件处理循环" class="headerlink" title="三、Redis 事件处理循环"></a>三、Redis 事件处理循环</h2><p>接下来，Redis 就会进入 aeMain 开始进行真正的用户请求处理了。在 aeMain 函数中，是一个无休止的循环。在每一次的循环中，要做如下几件事情。</p><p><img src="/posts/55825/640-1715755732174-8.webp" alt></p><ul><li>通过 epoll_wait 发现 listen socket 以及其它连接上的可读、可写事件</li><li>若发现 listen socket 上有新连接到达，则接收新连接，并追加到 epoll 中进行管理</li><li>若发现其它 socket 上有命令请求到达，则读取和处理命令，把命令结果写到缓存中，加入写任务队列</li><li>每一次进入 epoll_wait 前都调用 beforesleep 来将写任务队列中的数据实际进行发送</li><li>如若有首次未发送完毕的，当写事件发生时继续发送</li></ul><p>以上就是 aeMain 函数的核心逻辑所在，接下来我们分别对如上提到的四件事情进行详细的阐述。</p><h3 id="3-1-epoll-wait-发现事件"><a href="#3-1-epoll-wait-发现事件" class="headerlink" title="3.1  epoll_wait 发现事件"></a>3.1  epoll_wait 发现事件</h3><p>Redis 不管有多少个用户连接，都是通过 epoll_wait 来统一发现和管理其上的可读（包括 liisten socket 上的 accept事件）、可写事件的。甚至连 timer，也都是交给 epoll_wait 来统一管理的。</p><p><img src="/posts/55825/640-1715756405877-11.webp" alt></p><p>每当 epoll_wait 发现特定的事件发生的时候，就会调用相应的事先注册好的事件处理函数进行处理。aeProcessEvents 就是调用 epoll_wait 来发现事件。当发现有某个 fd 上事件发生以后，则调为其事先注册的事件处理器函数 rfileProc 和 wfileProc。</p><h3 id="3-2-处理新连接请求"><a href="#3-2-处理新连接请求" class="headerlink" title="3.2 处理新连接请求"></a>3.2 处理新连接请求</h3><p>我们假设现在有新用户连接到达了。前面在我们看到 listen socket 上的 rfileProc 注册的是 acceptTcpHandler。也就是说，如果有连接到达的时候，会回调到 acceptTcpHandler。</p><p>在 acceptTcpHandler 中，主要做了几件事情</p><p><img src="/posts/55825/640-1715756436233-14.webp" alt></p><ul><li>调用 accept 系统调用把用户连接给接收回来</li><li>为这个新连接创建一个唯一 redisClient 对象</li><li>将这个新连接添加到 epoll，并注册一个读事件处理函数</li></ul><h3 id="3-3-处理客户连接上的可读事件"><a href="#3-3-处理客户连接上的可读事件" class="headerlink" title="3.3 处理客户连接上的可读事件"></a>3.3 处理客户连接上的可读事件</h3><p>现在假设该用户连接有命令到达了，就假设用户发送了<code>GET XXXXXX_KEY</code> 命令。那么在 Redis 的时间循环中调用 epoll_wait 发现该连接上有读时间后，会调用在上一节中讨论的为其注册的读处理函数 readQueryFromClient。</p><p><img src="/posts/55825/640-1715760737074-17.webp" alt></p><p>在读处理函数 readQueryFromClient 中主要做了这么几件事情。</p><ul><li>解析并查找命令</li><li>调用命令处理</li><li>添加写任务到队列</li><li>将输出写到缓存等待发送</li></ul><h3 id="3-4-beforesleep-处理写任务队列"><a href="#3-4-beforesleep-处理写任务队列" class="headerlink" title="3.4 beforesleep 处理写任务队列"></a>3.4 beforesleep 处理写任务队列</h3><p>次在进入 aeProcessEvents 前都需要先进行 beforesleep 处理。这个函数名字起的怪怪的，但实际上大有用处。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/ae.c</span><span class="token keyword">void</span> <span class="token function">aeMain</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">{</span>    eventLoop<span class="token operator">-></span>stop <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>eventLoop<span class="token operator">-></span>stop<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// beforesleep 处理写任务队列并实际发送之</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>eventLoop<span class="token operator">-></span>beforesleep <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            eventLoop<span class="token operator">-></span><span class="token function">beforesleep</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">aeProcessEvents</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> AE_ALL_EVENTS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该函数处理了许多工作，其中一项便是遍历发送任务队列，并将 client 发送缓存区中的处理结果通过 write 发送到客户端手中。</p><p><img src="/posts/55825/640-1715761315329-20.webp" alt></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/server.c</span><span class="token keyword">void</span> <span class="token function">beforeSleep</span><span class="token punctuation">(</span><span class="token keyword">struct</span> aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">handleClientsWithPendingWrites</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//file:src/networking.c</span><span class="token keyword">int</span> <span class="token function">handleClientsWithPendingWrites</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    listIter li<span class="token punctuation">;</span>    listNode <span class="token operator">*</span>ln<span class="token punctuation">;</span>    <span class="token keyword">int</span> processed <span class="token operator">=</span> <span class="token function">listLength</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_write<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//遍历写任务队列 server.clients_pending_write</span>    <span class="token function">listRewind</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_write<span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>        c<span class="token operator">-></span>flags <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token operator">~</span>CLIENT_PENDING_WRITE<span class="token punctuation">;</span>        <span class="token function">listDelNode</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_write<span class="token punctuation">,</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//实际将 client 中的结果数据发送出去</span>        <span class="token function">writeToClient</span><span class="token punctuation">(</span>c<span class="token operator">-></span>fd<span class="token punctuation">,</span>c<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//如果一次发送不完则准备下一次发送</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">clientHasPendingReplies</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//注册一个写事件处理器，等待 epoll_wait 发现可写后再处理 </span>            <span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span> c<span class="token operator">-></span>fd<span class="token punctuation">,</span> ae_flags<span class="token punctuation">,</span>                sendReplyToClient<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>handleClientsWithPendingWrites</code> 中，遍历了发送任务队列 <code>server.clients_pending_write</code>，并调用 writeToClient 进行实际的发送处理。值得注意的是，发送 write 并不总是能一次性发送完的。假如要发送的结果太大，而系统为每个 socket 设置的发送缓存区又是有限的。</p><p>在这种情况下，<code>clientHasPendingReplies</code> 判断仍然有未发送完的数据的话，就需要注册一个写事件处理函数到 epoll 上。等待 epoll 发现该 socket 可写的时候再次调用 <code>sendReplyToClient</code>进行发送。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/networking.c</span><span class="token keyword">int</span> <span class="token function">writeToClient</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> client <span class="token operator">*</span>c<span class="token punctuation">,</span> <span class="token keyword">int</span> handler_installed<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">clientHasPendingReplies</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 先发送固定缓冲区</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>bufpos <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            nwritten <span class="token operator">=</span> <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>c<span class="token operator">-></span>buf<span class="token operator">+</span>c<span class="token operator">-></span>sentlen<span class="token punctuation">,</span>c<span class="token operator">-></span>bufpos<span class="token operator">-</span>c<span class="token operator">-></span>sentlen<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nwritten <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true">// 再发送回复链表中数据</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            o <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span><span class="token function">listFirst</span><span class="token punctuation">(</span>c<span class="token operator">-></span>reply<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            nwritten <span class="token operator">=</span> <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> o<span class="token operator">-></span>buf <span class="token operator">+</span> c<span class="token operator">-></span>sentlen<span class="token punctuation">,</span> objlen <span class="token operator">-</span> c<span class="token operator">-></span>sentlen<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>writeToClient 中的主要逻辑就是调用 write 系统调用让内核帮其把数据发送出去即可。由于每个命令的处理结果大小是不固定的。所以 Redis 采用的做法用固定的 buf + 可变链表来储存结果字符串。这里自然发送的时候就需要分别对固定缓存区和链表来进行发送了。</p><h2 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h2><p>到了喜闻乐见的小结时间，Redis 服务器端只需要单线程可以达到非常高的处理能力，每秒可以达到数万 QPS 的高处理能力。如此高性能的程序其实就是对 Linux 提供的多路复用机制 epoll 的一个较为完美的运用。</p><p>在 Redis 源码中，核心逻辑其实就是两个，一个是 initServer 启动服务，另外一个就是 aeMain 事件循环。在 initServer 这个函数内，Redis 做了这么三件重要的事情。</p><ul><li>创建一个 epoll 对象</li><li>对配置的监听端口进行 listen</li><li>把 listen socket 让 epoll 给管理起来</li></ul><p>在 aeMain 函数中，是一个无休止的循环，它是 Redis 中最重要的部分。在每一次的循环中，要做的事情可以总结为如下图。</p><p><img src="/posts/55825/640-1715761585179-23.webp" alt></p><ul><li>通过 epoll_wait 发现 listen socket 以及其它连接上的可读、可写事件</li><li>若发现 listen socket 上有新连接到达，则接收新连接，并追加到 epoll 中进行管理</li><li>若发现其它 socket 上有命令请求到达，则读取和处理命令，把命令结果写到缓存中，加入写任务队列</li><li>每一次进入 epoll_wait 前都调用 beforesleep 来将写任务队列中的数据实际进行发送</li></ul><p>其实事件分发器还处理了一个不明显的逻辑，那就是如果 beforesleep 在将结果写回给客户端的时候，如果由于内核 socket 发送缓存区过小而导致不能一次发送完毕的时候，也会注册一个写事件处理器。等到 epoll_wait 发现对应的 socket 可写的时候，再执行 write 写处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;仅仅靠单线程就可以支撑起每秒数万 QPS 的高处理能力，今天重点来看一下Redis 核心网络模块，很多时候网络是限制性能的重要因素。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://JoyTsing.github.io/categories/Redis/"/>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
      <category term="Redis" scheme="https://JoyTsing.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>重新认识端口重用</title>
    <link href="https://joytsing.github.io/posts/48/"/>
    <id>https://joytsing.github.io/posts/48/</id>
    <published>2024-05-12T12:08:25.000Z</published>
    <updated>2024-05-14T13:55:49.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>如果服务器上已经有个进程在 listen 6000 这个端口号了。那么该服务器上其它进程是否还能 bind 和 listen 该端口呢？相信学过一些的一定会答说是不能的。因为很多人都遇到过“Address already in use”这个错误。而这个错误产生的原因就是端口已经被占用。</p><p>但其实在 Linux 3.9 以上的内核版本里，是允许多个进程绑定到同一个端口号上(其实在使用<code>boost asio</code>的时候你就会发现我们并没有显式调用bind)。这就是今天要说的 REUSEPORT 新特性。那么REUSEPORT 是为了解决什么问题而产生的。如果有多个进程复用同一个端口，当用户请求到达时内核是如何选一个进程进行响应的。</p><h2 id="REUSEPORT-要解决的问题"><a href="#REUSEPORT-要解决的问题" class="headerlink" title="REUSEPORT 要解决的问题"></a>REUSEPORT 要解决的问题</h2><p>关于 REUSEPORT 特性产生的背景其实在 linux 的 <a href="https://github.com/torvalds/linux/commit/da5e36308d9f7151845018369148201a5d28b46d">commit</a> 中提供的足够详细了，本质上与PV4向IPV6转变的理由是相同的，都是端口(IP)不够满足现在的发展。如今互联网澎湃发展，应对海量流量的主要措施就是应用多进程模型。在端口不可被重复 bind 和 listen 的年代里，提供海量服务的多进程 Server 提供一般是采用如下两种进程模型来工作。</p><p>第一种是专门搞一个或多个进程服务 accept 新连接，接收请求，然后将请求转给其它的 worker 进程来处理。</p><p><img src="/posts/48/640.webp" alt></p><p>这种多进程模型有两个问题，首先第一个是 dispatcher 进程并不处理任务，需要转交给 worker 进程来处理和响应。这会导致一次额外的进程上下文切换的开销。第二个问题是如果流量特别大的时候 dispatcher 进程很容易成为制约整个服务 qps 提升的瓶颈。</p><p>还有另一种多进程模型是多个进程复用一个 listen 状态的 socket，多个进程同时从一个 socket 中 accept 请求来处理。Nginx 就采用的是这种模型。</p><p><img src="/posts/48/640-1715688988548-1.webp" alt></p><p>这种进程模型解决了第一个模型的问题。但是又带来了新的问题。当 socket 收到一条连接的时候，不能把所有的 worker 进程都招呼起来。需要用锁来保证唯一性，这样就会有锁竞争的问题。</p><h2 id="REUSEPORT-的诞生"><a href="#REUSEPORT-的诞生" class="headerlink" title="REUSEPORT 的诞生"></a>REUSEPORT 的诞生</h2><p>为了更高效地让多个用户态的进程接收和响应客户端的请求。Linux 在 2013 年的 3.9 版本中提供了 REUSEPORT 新特性。</p><p><img src="/posts/48/640-1715689168184-6.webp" alt></p><p>该特性允许同一机器上的多个进程同时创建<strong>不同的 socket 来 bind 和 listen 在相同的端口上</strong>。然后在<strong>内核层面实现多个用户进程的负载均衡</strong>。</p><h3 id="SO-REUSEPORT-设置"><a href="#SO-REUSEPORT-设置" class="headerlink" title="SO_REUSEPORT 设置"></a>SO_REUSEPORT 设置</h3><p>想给自己的服务开启 REUSEPORT 很简单，就是给自己 server 里 listen 用的 socket 上加这么一句。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">setsockopt</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> SOL_SOCKET<span class="token punctuation">,</span> SO_REUSEPORT<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这行代码在内核中对应的处理步骤就是把内核 socket 的 sk_reuseport 字段设置为相应的值，开启的话是 1。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: net/core/sock.c</span><span class="token keyword">int</span> <span class="token function">sock_setsockopt</span><span class="token punctuation">(</span><span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">int</span> level<span class="token punctuation">,</span> <span class="token keyword">int</span> optname<span class="token punctuation">,</span>      <span class="token keyword">char</span> __user <span class="token operator">*</span>optval<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> optlen<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">switch</span> <span class="token punctuation">(</span>optname<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token keyword">case</span> SO_REUSEPORT<span class="token punctuation">:</span>   sk<span class="token operator">-></span>sk_reuseport <span class="token operator">=</span> valbool<span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="bind-时的处理"><a href="#bind-时的处理" class="headerlink" title="bind 时的处理"></a>bind 时的处理</h3><p>内核在 inet_bind 时会调用到 inet_csk_get_port 函数。bind 时对 reuseport 的处理过程。来看源码：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: net/ipv4/inet_connection_sock.c</span><span class="token keyword">int</span> <span class="token function">inet_csk_get_port</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">short</span> snum<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true">//在绑定表（bhash）中查找，</span> head <span class="token operator">=</span> <span class="token operator">&amp;</span>hashinfo<span class="token operator">-></span>bhash<span class="token punctuation">[</span><span class="token function">inet_bhashfn</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> snum<span class="token punctuation">,</span>   hashinfo<span class="token operator">-></span>bhash_size<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token function">inet_bind_bucket_for_each</span><span class="token punctuation">(</span>tb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>head<span class="token operator">-></span>chain<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//找到了，在一个命名空间下而且端口号一致，表示该端口已经绑定</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">net_eq</span><span class="token punctuation">(</span><span class="token function">ib_net</span><span class="token punctuation">(</span>tb<span class="token punctuation">)</span><span class="token punctuation">,</span> net<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> tb<span class="token operator">-></span>port <span class="token operator">==</span> snum<span class="token punctuation">)</span>   <span class="token keyword">goto</span> tb_found<span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>内核通过拉链哈希表的方式来管理所有的 bind 的 socket。其中 inet_bhashfn 是计算哈希值的函数。</p><p><img src="/posts/48/640-1715689472912-9.webp" alt></p><p>当计算找到哈希槽位以后，通过<code>inet_bind_bucket_for_each</code> 来遍历所有的 bind 状态的 socket，目的是为了判断是否冲突。</p><p><code>net_eq(ib_net(tb), net)</code> 这个条件表示网络命名空间匹配，tb-&gt;port == snum 表示端口号匹配。这两个条件加起来，就是说在同一个命名空间下，该端口已经被绑定过了。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: net/ipv4/inet_connection_sock.c</span><span class="token keyword">int</span> <span class="token function">inet_csk_get_port</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">short</span> snum<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>tb<span class="token operator">-></span>fastreuse <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>       sk<span class="token operator">-></span>sk_reuse <span class="token operator">&amp;&amp;</span> sk<span class="token operator">-></span>sk_state <span class="token operator">!=</span> TCP_LISTEN<span class="token punctuation">)</span> <span class="token operator">||</span>      <span class="token punctuation">(</span>tb<span class="token operator">-></span>fastreuseport <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>       sk<span class="token operator">-></span>sk_reuseport <span class="token operator">&amp;&amp;</span> <span class="token function">uid_eq</span><span class="token punctuation">(</span>tb<span class="token operator">-></span>fastuid<span class="token punctuation">,</span> uid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>     smallest_size <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">goto</span> success<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//绑定冲突</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看<code>tb-&gt;fastreuseport &gt; 0</code>和 <code>sk-&gt;sk_reuseport</code> 这两个条件。</p><p>这两个条件的意思是已经 bind 的 socket 和正在 bind 的 socket 都开启了 SO_REUSEPORT 特性。符合条件的话，将会跳转到 success 进行绑定成功的处理。<strong>也就是说，这个端口可以重复绑定使用！</strong></p><p><code>uid_eq(tb-&gt;fastuid, uid)</code>这个条件目的是安全性，必须要求相同的用户进程下的 socket 才可以复用端口。<strong>避免跨用户启动相同端口来窃取另外用户服务上的流量。</strong></p><h3 id="accept-响应新连接"><a href="#accept-响应新连接" class="headerlink" title="accept 响应新连接"></a>accept 响应新连接</h3><p>当有多个进程都 bind 和 listen 了同一个端口的时候。有客户端连接请求到来的时候就涉及到选择哪个 socket（进程）进行处理的问题。我们再简单看一下，响应连接时的处理过程。</p><p>内核仍然是通过 hash + 拉链的方式来保存所有的 listen 状态的 socket。</p><p><img src="/posts/48/640-1715689472912-10.webp" alt></p><p>查找 listen 状态的 socket 的时候需要查找该哈希表。进入响应握手请求的时候进入的一个关键函数<code>__inet_lookup_listener</code> 。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: net/ipv4/inet_hashtables.c</span><span class="token keyword">struct</span> sock <span class="token operator">*</span><span class="token function">__inet_lookup_listener</span><span class="token punctuation">(</span><span class="token keyword">struct</span> net <span class="token operator">*</span>net<span class="token punctuation">,</span>        <span class="token keyword">struct</span> inet_hashinfo <span class="token operator">*</span>hashinfo<span class="token punctuation">,</span>        <span class="token keyword">const</span> __be32 saddr<span class="token punctuation">,</span> __be16 sport<span class="token punctuation">,</span>        <span class="token keyword">const</span> __be32 daddr<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">short</span> hnum<span class="token punctuation">,</span>        <span class="token keyword">const</span> <span class="token keyword">int</span> dif<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//所有 listen socket 都在这个 listening_hash 中</span> <span class="token keyword">struct</span> inet_listen_hashbucket <span class="token operator">*</span>ilb <span class="token operator">=</span> <span class="token operator">&amp;</span>hashinfo<span class="token operator">-></span>listening_hash<span class="token punctuation">[</span>hash<span class="token punctuation">]</span><span class="token punctuation">;</span>begin<span class="token punctuation">:</span> result <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> hiscore <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token function">sk_nulls_for_each_rcu</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> node<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ilb<span class="token operator">-></span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>  score <span class="token operator">=</span> <span class="token function">compute_score</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> net<span class="token punctuation">,</span> hnum<span class="token punctuation">,</span> daddr<span class="token punctuation">,</span> dif<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>score <span class="token operator">></span> hiscore<span class="token punctuation">)</span> <span class="token punctuation">{</span>   result <span class="token operator">=</span> sk<span class="token punctuation">;</span>   hiscore <span class="token operator">=</span> score<span class="token punctuation">;</span>   reuseport <span class="token operator">=</span> sk<span class="token operator">-></span>sk_reuseport<span class="token punctuation">;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>reuseport<span class="token punctuation">)</span> <span class="token punctuation">{</span>    phash <span class="token operator">=</span> <span class="token function">inet_ehashfn</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> daddr<span class="token punctuation">,</span> hnum<span class="token punctuation">,</span>           saddr<span class="token punctuation">,</span> sport<span class="token punctuation">)</span><span class="token punctuation">;</span>    matches <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>score <span class="token operator">==</span> hiscore <span class="token operator">&amp;&amp;</span> reuseport<span class="token punctuation">)</span> <span class="token punctuation">{</span>   matches<span class="token operator">++</span><span class="token punctuation">;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>u64<span class="token punctuation">)</span>phash <span class="token operator">*</span> matches<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">32</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    result <span class="token operator">=</span> sk<span class="token punctuation">;</span>   phash <span class="token operator">=</span> <span class="token function">next_pseudo_random32</span><span class="token punctuation">(</span>phash<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 sk_nulls_for_each_rcu 是在遍历所有 hash 值相同的 listen 状态的 socket。注意看 compute_score 这个函数，这里是计算匹配分。当有多个 socket 都命中的时候，匹配分高的优先命中。我们来看一下这个函数里的一个细节。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: net/ipv4/inet_hashtables.c</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">compute_score</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">int</span> score <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">struct</span> inet_sock <span class="token operator">*</span>inet <span class="token operator">=</span> <span class="token function">inet_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">net_eq</span><span class="token punctuation">(</span><span class="token function">sock_net</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> net<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> inet<span class="token operator">-></span>inet_num <span class="token operator">==</span> hnum <span class="token operator">&amp;&amp;</span>   <span class="token operator">!</span><span class="token function">ipv6_only_sock</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//如果服务绑定的是 0.0.0.0，那么 rcv_saddr 为假</span>  __be32 rcv_saddr <span class="token operator">=</span> inet<span class="token operator">-></span>inet_rcv_saddr<span class="token punctuation">;</span>  score <span class="token operator">=</span> sk<span class="token operator">-></span>sk_family <span class="token operator">==</span> PF_INET <span class="token operator">?</span> <span class="token number">2</span> <span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>rcv_saddr<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>rcv_saddr <span class="token operator">!=</span> daddr<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>   score <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">}</span> <span class="token keyword">return</span> score<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么匹配分解决的是什么问题呢？为了描述的更清楚，我们假设某台服务器有两个 ip 地址，分别是 10.0.0.2 和 10.0.0.3。我们启动了如下三个服务器进程。</p><pre><code>A 进程：./test-server 10.0.0.2 6000B 进程：./test-server 0.0.0.0 6000C 进程：./test-server 127.0.0.1 6000</code></pre><p>那么你的客户端如果指定是连接 10.0.0.2:6000，那么 A 进程会优先执行。因为当匹配到 A 进程的 socket 的时候，需要看一下握手包中的目的 ip 和这个地址是否匹配，确实匹配那得分就是 4 分，最高分。</p><p>如果你指定连接的是 10.0.0.3，那么 A 进程就无法被匹配到。这个时候 B 进程监听时指定的是 0.0.0.0（rcv_saddr 为 false），则不需要进行目的地址的比对，得分为 2。由于没有更高分，所以这次命中的是 B 进程。</p><p>C 进程只有你在本机访问，且指定 ip 使用 127.0.0.1 才能命中，得分也是为 4 分。外部服务器或者是在本机使用其它 ip 都无法访问的到。</p><p>如果当多个 socket 的匹配分一致，通过调用 next_pseudo_random32 进行随机的选择。<strong>在内核态做了负载均衡的事情，选定一个具体的 socket，避免了多个进程在同一个 socket 上的锁竞争。</strong></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在 Linux 3.9 以前的版本中，一个端口只能被一个 socket 绑定。在多进程的场景下，无论是使用一个进程来在这个 socket 上 accept，还是说用多个 worker 来 accept 同一个 socket，在高并发的场景下性能都显得有那么一些低下。</p><p>在 2013 年发布的 3.9 中添加了 reuseport 的特性。该特定允许多个进程分别用不同的 socket 绑定到同一个端口。当有流量到达的时候，在内核态以随机的方式进行负载均衡。避免了锁的开销。</p><p>如果使用的是nginx，只需要一行简单的配置就可以体验这个特性。</p><pre class="line-numbers language-cpp"><code class="language-cpp">server <span class="token punctuation">{</span>  listen <span class="token number">80</span> reuseport<span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;如果服务器上已经有个进程在 listen 6000 这个端口号了。那么该服务器上其它进程是否还能 bind 和 listen 该端口呢？相信
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>std::enable_shared_from_this():诞生和作用</title>
    <link href="https://joytsing.github.io/posts/5981/"/>
    <id>https://joytsing.github.io/posts/5981/</id>
    <published>2024-05-11T07:35:50.000Z</published>
    <updated>2024-05-14T13:55:27.126Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>std::shared_from_this()</code>是 C++11 标准引入的功能，但之前一直都没用到过，直到在boost中使用asio需要异步保存回调函数时为了保存io_context，防止提前析构才了解到这个。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>简单地说就是帮助你怎么在class内部拿到this的shared_ptr版本。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">></span> <span class="token function">local_sp_a</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// do something with local_sp_a</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  A<span class="token operator">*</span> a<span class="token punctuation">;</span>  std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">></span> <span class="token function">sp_a</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  a<span class="token operator">-</span><span class="token operator">></span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// sp_a becomes dangling.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上述方式拿的话，表面上看起来你是拿到了一个this的shared_ptr版本，但是由于<strong>计数器和被管理的对象是分离</strong>的，因此相当于2个计数器（reference count都=1），同时只有一个被管理的对象。函数内部的那个计数器，在函数调用完成之后，认为reference count变成0了，于是释放掉了对应的object。main里构造的计数器当然不知道对应的object已经被释放了，于是就会二重释放宕掉,换句话说：<strong>智能共享指针不能够直接从this对象进行构造。</strong></p><p>C++解决方案是通过继承一个类（该方法是侵入式的，也可以手动保证只有构造第一个指向被持有对象的shared_ptr实例是由原始指针构造的），这个类本质上会给被管理的object上加一个指向计数器的weak ptr，于是就可以正确地增加引用计数而不是搞出2个独立的计数器。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="/posts/5981/v2-e9eefb114e3e371ac246ee8d9714b681_720w.webp" alt></p><p>该类是一个类模版，通过模版参数TP将被持有对象的类型传递进来，然后在类的内部构件一个weak_ptr<T>类型的成员变量。该成员变量用来保存指向自身的指针以及控制块相关信息，外部使用的时候如前一章节示例代码一样，为方便讨论代码重复贴出代码如下，采用继承的方式来扩展派生类的功能。</T></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token operator">:</span> <span class="token keyword">public</span> std<span class="token operator">::</span>enable_shared_from_this<span class="token operator">&lt;</span>Test<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面这种继承自一个类模版，将自身类型以模版参数的形式传入派生类的方式有一个专有名词对应，那就是CRTP，英文全称curious recurring template pattern，中文译名是奇异递归模版模式。可以通过该模式将派生类的类型信息通过模版参数的方式传入enable_shared_from_this类模版中，在enable_shared_from_this类模版中，将用该类型信息声明内部的用于管理派生类对象的成员变量__weak_this，并且声明相关成员方法，从而扩展派生类的功能。</p><p>该类的方法可以通过调用基类提供的成员函数shared_from_this来获取一个指向自身的shared_ptr对象，通过weak_from_this方法来获取一个指向自身的weak_ptr对象，其中weak_ptr对象也是指向被管理对象的智能指针，只不过该智能指针是<a href="https://www.zhihu.com/search?q=弱引用&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={" sourcetype"%3a"answer"%2c"sourceid"%3a3079826725}">弱引用</a>关系，不管理“被持有”对象的声明周期（这里被持有是带有引号的，用来表示区别于shared_ptr，这里是弱引用，不具有被管理对象的所有权），只提供访问对象数据的功能，但是和裸指针(raw pointer)功能类似，但是可以通过该指针的成员方法expire来判断被指向对象是否还有效（是否已经被销毁）。</p><p>核心逻辑在shared_from_this函数内部,该函数的内部逻辑不复杂，仅仅是通过成员变量__weak_this_来构建一个shared_ptr对象，然后将该对象返回:</p><pre class="line-numbers language-cpp"><code class="language-cpp">shared_ptr<span class="token operator">&lt;</span>_Tp<span class="token operator">></span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> shared_ptr<span class="token operator">&lt;</span>_Tp<span class="token operator">></span><span class="token punctuation">(</span>__weak_this_<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="enable-shared-from-this在异步求值中的应用"><a href="#enable-shared-from-this在异步求值中的应用" class="headerlink" title="enable_shared_from_this在异步求值中的应用"></a>enable_shared_from_this在异步求值中的应用</h2><p>enable_shared_from_this真实的应用场景是什么？如果只是需要正常让shared_ptr计数的话完全有其他更简单的方法（工厂方法），之前提到的应用场景大部分是在类的外部，可以通过对已有的shared_ptr进行复制，来共享所有权。在类的内部如果想安全的实现所有权的共享，并且和外部的shared_ptr来共同的管理对象，这个时候就需要使用enable_shared_from_this模版类了。</p><p>看一下下面的例子，定义了一个Process类，该类通过SetContext设置了一些上下文信息，然后保存在类的内部，然后在内部通过lambda函数捕捉自身this指针，并且封装一个求值的操作，然后将该lambda函数交给一个线程池来进行异步的执行：</p><p><img src="/posts/5981/v2-60007984ac84fd2552268f4c2742c317_720w.webp" alt></p><p>在异步执行的时候，调用它</p><p><img src="/posts/5981/v2-2d99285ca4ade1f1fd5ba7bd1a224157_720w.webp" alt></p><p>运行上述代码，会发现运行异常，异常结果如下图所示</p><p><img src="/posts/5981/v2-70077f07c846bf45cf47b0c3a0f31060_720w.webp" alt></p><p>之所以会产生异常，是因为当异步调用开始执行的时候，Process对象实例_process已经被释放了，此时加入线程池的lambda函数对象内捕捉的this指针指向的对象已经被释放了，此时异步执行的时候，会导致未定义行为。</p><p><img src="/posts/5981/v2-2e956c602a3784b3ac47da321b308467_720w.webp" alt="解决"></p><p>如上图中间红框部分，在进行异步调用函数封装的时候，不直接去捕捉this指针，而通过shared_from_this函数来构造一个shared_ptr对象，来捕捉这个shared_ptr对象，从而达到异步调用中使用的shared_ptr对象和外部的（通过Create创建以及后续从已有shared_ptr对象拷贝复制的）shared_ptr对象共享所有权，共同管理被指向对象的生命周期。从而避免异步执行时，捕捉的对象被释放的问题。</p><h2 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h2><p>像下面这样的写法是不正确的，</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyCar</span><span class="token operator">:</span><span class="token keyword">public</span> std<span class="token operator">::</span>enable_shared_from_this<span class="token operator">&lt;</span>MyCar<span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  shared_ptr<span class="token operator">&lt;</span>MyCar<span class="token operator">></span> <span class="token function">get_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token operator">~</span><span class="token function">MyCar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"free ~Mycar()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  MyCar<span class="token operator">*</span> _myCar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">MyCar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  shared_ptr<span class="token operator">&lt;</span>MyCar<span class="token operator">></span> _myCar1 <span class="token operator">=</span> _myCar<span class="token operator">-</span><span class="token operator">></span><span class="token function">get_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  shared_ptr<span class="token operator">&lt;</span>MyCar<span class="token operator">></span> _myCar2 <span class="token operator">=</span> _myCar<span class="token operator">-</span><span class="token operator">></span><span class="token function">get_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> _myCar1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> _myCar2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>区别在于在调用时候没有对智能指针进行构造，而是想通过get直接得到（符合直觉），但是这样的写法是会报错的：</p><p><img src="/posts/5981/13a914c223ade96d1a1dbdc2b97c3528.png" alt="报错内容"></p><p>如上图所示，异常位置是在弱指针处，弱指针实际上是智能共享指针的伴随指针，它主要负责监控智能指针的声明周期，弱指针本身的构造和析构都不会对引用计数进行修改，纯粹是作为一个助手监视shared_ptr管理的资源是否存在。因此弱指针的初始化是通过智能指针的构造函数来实现的，在上面的代码中对智能指针初始化时并没有使用构造函数的方式，因为弱指针是没有正常进行初始化的，所以抛出了异常。</p><p>这也是为什么推荐和工程模式一起使用，避免了这种问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;code&gt;std::shared_from_this()&lt;/code&gt;是 C++11 标准引入的功能，但之前一直都没用到过，直到在boos
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>MySQL技术内幕-InnoDB存储引擎(四)</title>
    <link href="https://joytsing.github.io/posts/8527/"/>
    <id>https://joytsing.github.io/posts/8527/</id>
    <published>2024-05-10T13:10:38.000Z</published>
    <updated>2024-05-14T13:55:40.344Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>事务是保证数据库不会出错的重要机制。</p><h2 id="一-事务"><a href="#一-事务" class="headerlink" title="一.事务"></a>一.事务</h2><p>数据库系统引入事务的目的：</p><p><strong>事务会把数据库从一种一致状态转换为另一种一致状态。</strong>在数据库提交工作的时候，可以确保要么所有修改已经保存了，要么所有修改都不保存。InnoDB存储引擎中的事务符合ACID特性：</p><ul><li>原子性：事务是不可分割的工作单位。</li><li>一致性：事务会把数据库从一种一致状态转换为另一种一致状态。</li><li>隔离性：要求每个读写事务的对象和其他事务的操作对象能够相互分离，事务提交之前对其他事务不可见。</li><li>持久性：事务一旦提交，其结果就是永久性的。</li></ul><p><strong>事务的分类：</strong></p><ul><li>扁平事务：</li></ul><blockquote><p>最简单也是使用最频繁的一种，所有操作都处于同一个层次。<br>由Begin Work开始，Commit Work或者Rollback Work结束，其间的操作都是原子性的，要么都执行要么都回滚。</p></blockquote><ul><li>带有保存点的扁平事务：允许事务执行过程中回滚到同一个事务中较早的一个状态。</li></ul><blockquote><p>意思是，一个事务的执行过程中出现的错误<strong>并不会导致所有的操作都无效，放弃整个事务并不符合要求，开销太大。</strong></p><p>那么就用保存点（Savepoint）来通知系统应该记住事务当前的状态，以便之后发生错误时，事务可以回到保存点当时的状态。</p></blockquote><ul><li>链事务：保存点模式的一种变种。</li></ul><blockquote><p>提交一个事务的时候，释放不需要的数据对象，将必要的处理上下文隐式地传给下一个要开始的事务。</p></blockquote><ul><li>嵌套事务：是一个层次结构框架。</li></ul><blockquote><p><strong>由一个顶层事务控制着各个层次的事务</strong>，顶层事务之下嵌套的事务被称为子事务，其控制每一个局部的变换。</p></blockquote><ul><li>分布式事务：通常是在一个分布式环境下运行的扁平事务。</li></ul><blockquote><p>要保证分布式事务正常运行比较复杂，这个就是另一个专题了</p></blockquote><p><strong>事务的实现：</strong></p><ol><li><strong>事务的原子性是通过undo log来实现</strong>，也就是所谓的回滚操作。 undo log记录了数据被修改之前的信息以及新增、删除的信息。undo log就是通过生成操作相反的sql语句来实现。</li><li>事务的持久性：<br>1.redolog在提交commit前会写一次数据，顺序存储。<br>2.InnoDB的二次写以及自带的buffer pool。</li><li><strong>事务的隔离性则通过4种隔离级别来实现。</strong></li><li>事务的一致性：其实现依赖于以上3个特性的实现、即回滚、恢复、隔离机制。</li></ol><h3 id="1-1-purge"><a href="#1-1-purge" class="headerlink" title="1.1 purge"></a>1.1 purge</h3><p>purge用于最终完成delete和update操作。因为InnoDB存储引擎支持MVCC，所以记录不能再事务提交的时候立即进行处理，因为这个时候其他的事务肯呢个正在读取这一行数据，因此需要InnoDB保存记录之前的版本。<strong>而是否删除该记录则是通过purge来进行判断。</strong></p><p>为了节省存储空间，InnoDB存储引擎的undo log的设计为：</p><ol><li>一个页上允许多个事务的undo log存在，后面的事务产生的undo log总是在最后。</li><li>用一个history列表，根据事务提交的顺序，将undo log进行链接。</li><li>purge的时候，<strong>先从history list中寻找undo log，然后再从undo page中找undo log。</strong></li></ol><p>当InnoDB存储引擎压力非常大的时候，并不能高效的进行purge操作，那么history list的长度会变的越来越长，因此可以使用全局动态参数<code>innodb_max_purge_lag</code>来控制history list的长度，如果长度大于该参数的时候，会延缓DML的操作。其算法为：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># delay单位是毫秒，并且其作用对象是一行数据，而不是一个DML操作。</span><span class="token comment" spellcheck="true"># 例如，一个update操作需要更新5行数据，那么每行数据的操作都会被delay，因此总的延长时间为5*delay</span>delay<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">(</span>length<span class="token punctuation">(</span>history list<span class="token punctuation">)</span><span class="token operator">-</span>innodb_max_purge_lag<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">5</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="1-2-group-commit"><a href="#1-2-group-commit" class="headerlink" title="1.2 group commit"></a>1.2 group commit</h3><p>为了提高磁盘的fsync（持久化到日志）效率，当前数据库都提供了group commit的功能，<strong>即一次fsync可以刷新确保多个多个事务日志被写入文件。</strong> 对于InnoDB存储引擎来说，事务提交的时候会进行两个阶段的操作：</p><ol><li><strong>修改内存中事务对应的信息，并且将日志写入重做日志缓冲中。</strong></li><li><strong>调用fsync确保日志都从重做日志缓冲中写入到磁盘。</strong></li></ol><p>步骤2是一个较慢的过程（因为需要存储引擎需要和磁盘打交道），因此如果通过group commit使用一次fsync刷新到磁盘，可以大大减少了磁盘的压力。Mysql在5.6之后，采用了BLGC的实现方式（Binary Log Group Commit），将事务提交的过程分为几个步骤来完成：</p><p><img src="/posts/8527/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pvbmdfMDkxNQ==,size_16,color_FFFFFF,t_70.png" alt></p><p>在Mysql数据库上层进行提交时首先按顺序将其放入一个队列中，<strong>队列中的第一个事务称为leader，其他事务叫follower，leader控制着follower的行为</strong>。BLGL的步骤分为三个阶段：</p><ol><li>Flush阶段：将每个事务的二进制日志写入文件中。</li><li>Sync阶段：将内存中的二进制日志刷新到磁盘，若队列有多个事务，那么仅一次fsync操作就可以完成二进制日志的写入，这就是BLGC。</li><li>Commit阶段：leader根据顺序调用存储引擎层事务的提交。</li></ol><h3 id="1-3-事务控制语句"><a href="#1-3-事务控制语句" class="headerlink" title="1.3 事务控制语句"></a>1.3 事务控制语句</h3><p>Mysql默认配置下，事务都是自动提交的（auto commit），即执行SQL语句后会马上执行commit操作。接下来看一看还有哪些有关事务的控制语句：</p><ul><li>Start | Begin Transaction：显式地开启一个事务。</li><li>Commit：提交事务，并使得已对数据库做的所有修改成为永久性的。</li><li>Rollback：回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。</li><li>Savepoint identifier：Savepoint允许在事务中创建一个保存点，一个事务中可以有多个Savepoint。</li><li>Release Savepoint identifier：删除一个事务的保存点。</li><li>Rollback To [Savepoint] identifier：可以把事务回滚到保存点。</li><li>Set Transaction：设置事务的隔离级别。</li></ul><p>注意：<strong>回滚至保存点的时候，事务并不会真正的回滚，即没有结束，需要运行Rollback后，事务才会完整的回滚。</strong></p><p>接下来再讲一下一些会隐式提交事务的SQL语句：</p><ul><li>DDL语句。</li></ul><blockquote><p>Alter Database | Event | Procedure | Table | View等<br>Create Database | Event | Index | Trigger | View | Table等<br>Drop Database | Event | Index | Trigger | View | Table等</p></blockquote><ul><li>用来隐式地修改Mysql架构的语句。</li></ul><blockquote><p>Create | Drop | Rename User 、Grant、 Revoke、Set Password。</p></blockquote><ul><li>管理语句。</li></ul><blockquote><p>Analyze Table、Cache Index、Check Table、Load Index Into Cache等</p></blockquote><h3 id="1-4-事务隔离级别"><a href="#1-4-事务隔离级别" class="headerlink" title="1.4 事务隔离级别"></a>1.4 事务隔离级别</h3><p>事务的隔离级别有4个：</p><ul><li>READ UNCOMMITTED</li><li>READ COMMITTED</li><li>REPEATABLE READ</li><li>SERIALIZABLE</li></ul><p>注意的点：</p><ol><li>InnoDB存储引擎默认的隔离级别是REPEATABLE READ，<strong>并且在该隔离级别下，使用Next-Key Lock锁的算法，避免幻读的产生。</strong></li><li>隔离级别越低，<strong>事务请求的锁越少或者保持锁的时间越短。</strong></li><li><strong>SERIALIZABLE的事务隔离级别，InnoDB存储引擎会对每个Select语句后自动加上Lock In Share Mode。</strong></li><li>在READ COMMITTED的隔离级别下，<strong>除了唯一性的约束检查以及外键约束的检查需要gap lock，InnoDB存储引擎不会使用gap lock的锁算法。</strong></li></ol><p>查看当前会话的事务隔离级别：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> @<span class="token variable">@tx_isolation</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看全局的事务隔离级别：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> @<span class="token variable">@global.tx_isolation</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="二-备份与恢复"><a href="#二-备份与恢复" class="headerlink" title="二.备份与恢复"></a>二.备份与恢复</h2><p>1.根据<strong>备份的方法不同</strong>可以将备份划分为：</p><ul><li>Hot Backup（热备）：数据库<strong>运行时</strong>直接备份，<strong>对正在运行放的数据库操作没有任何的影响。</strong></li><li>Cold Backup（冷备）：<strong>在数据库停止的情况下备份，只需要复制相关的数据库物理文件即可。</strong></li><li>Warm Backup（温备）：运行时备份，但是会对当前数据库的操作有影响。</li></ul><p>2.按照<strong>备份后文件的内容</strong>可以将备份划分为：</p><ul><li>逻辑备份：指的是文件内容可读，一般是文本文件，内容为SQL语句或者实际表内数据。</li><li>裸文件备份：指的是复制数据库的物理文件，<strong>这种备份的恢复时间往往要短很多。</strong></li></ul><p>3.按照<strong>备份数据库的内容</strong>可以将备份划分为：</p><ul><li>完全备份：指的是对数据库进行一个完整的备份。</li><li>增量备份：指的是在上次完全备份的基础上，<strong>对于更改的数据进行备份。</strong></li><li>日志备份：主要是针对二进制日志的备份。</li></ul><h3 id="2-1-冷备和逻辑备份"><a href="#2-1-冷备和逻辑备份" class="headerlink" title="2.1 冷备和逻辑备份"></a>2.1 冷备和逻辑备份</h3><p>对于InnoDB存储引擎的冷备非常简单，只需要备份Mysql数据库中的<code>frm</code>文件、共享表空间文件、独立表空间文件（<code>*.ibd</code>）、重做日志文件。<br>冷备的优点：</p><ul><li>备份简单，只需要复制相关文件即可。</li><li>备份文件易于在不同操作系统，不同Mysql版本上进行恢复。</li><li>恢复操作容易，只需要把文件移动到相应的位置即可。</li><li>恢复速度快，不需要执行任何SQL语句，也不需要重建索引。</li></ul><p>冷备的缺点：</p><ul><li>InnoDB存储引擎<strong>冷备的文件通常比逻辑文件大很多</strong>，因为表空间中存放着很多其他的数据。</li></ul><p>逻辑备份：使用<strong>mysqldump</strong><br>例子：想要对test数据库做一个备份：</p><pre class="line-numbers language-sql"><code class="language-sql">mysqldump <span class="token operator">-</span>uroot <span class="token operator">-</span>p <span class="token comment" spellcheck="true">--single-transaction test > test_backup.sql     </span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>mysqldump的重要参数：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>--single-transaction</code></td><td>在备份开始前，先执行Start Transaction命令，以此来获得备份的一致性（该参数只对InnoDB有效）</td></tr><tr><td><code>--lock-tables(-l)</code></td><td>在备份中，<strong>依次</strong>锁住每个架构下的所有表。</td></tr><tr><td><code>--lock-all-tables(-x)</code></td><td>在备份过程中，对所有架构中的表上锁。</td></tr><tr><td><code>--add-drop-database</code></td><td>在Create Database之前线运行Drop Database。</td></tr><tr><td><code>--master-data [=value]</code></td><td>通过该参数产生的备份转存文件主要用来建立一个replication，该参数会自动忽略 –lock-tables选项。</td></tr><tr><td><code>--events(-E)</code></td><td>备份时间调度器</td></tr><tr><td><code>--rountines（-R）</code></td><td>备份存储过程和函数</td></tr><tr><td><code>--triggers</code></td><td>备份触发器</td></tr><tr><td><code>--hex-blob</code></td><td>将BitNary、VarBinary、Blog、Bit列类型备份为十六进制的格式。<strong>因为mysqldump导出的文件一般是文本文件</strong>，而如果导出的数据包含上述类型，在文本文件模式下可能有些字符不可见，加上这个参数，可以以十六进制的方式显示。</td></tr><tr><td><code>--where=&#39;[条件语句]&#39;</code></td><td>例如：mysqldump –where=‘b&gt;2’ test a &gt; a.sql意思是导出数据库test下表a中列b&gt;2的数据</td></tr></tbody></table><hr><p>上面讲了如何使用mysqldump进行备份，那么来看看具体数据库中如何操作：<br>直接使用该文件即可。</p><pre class="line-numbers language-sql"><code class="language-sql">mysql <span class="token operator">-</span>uroot <span class="token operator">-</span>p <span class="token operator">&lt;</span> test_backup<span class="token punctuation">.</span>sql<span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-2-热备"><a href="#2-2-热备" class="headerlink" title="2.2 热备"></a>2.2 热备</h3><p>这里讲一下<strong>ibbackup</strong>，不过不会讲具体的操作方式（百度都有）。</p><p>ibbackup是InnoDB存储引擎官方提供的热备工具，同时可以备份MyISAM存储引擎和InnoDB存储引擎表。那么对于InnoDB的备份工作原理如下：</p><ol><li>记录备份开始时，InnoDB存储引擎重做日志文件检查点的LSN。</li><li>复制共享表空间文件以及独立表空间文件。</li><li>记录复制完表空间文件后，InnoDB存储引擎重做日志文件检查点的LSN。</li><li>复制在备份时候产生的重做日志。</li></ol><p>其优点：</p><ul><li>在线备份，<strong>不阻塞任何的SQL语句。</strong></li><li>备份性能好，<strong>备份的实质是复制数据库文件和重做日志文件</strong>。</li><li>支持压缩备份。</li></ul><p>而ibbackup对InnoDB存储引擎的恢复步骤大概为2步：</p><ol><li>恢复表空间文件。</li><li>应用重做日志文件。</li></ol><h3 id="2-3-复制（主从架构）"><a href="#2-3-复制（主从架构）" class="headerlink" title="2.3 复制（主从架构）"></a>2.3 复制（主从架构）</h3><p>复制（replication）是Mysql数据库提供的一种高可用高性能的解决方案。其工作原理分为3个步骤：</p><ol><li>主服务器（master）<strong>把数据更改记录到二进制日志中。</strong></li><li>从服务器（slave）<strong>把master的二进制日志复制到自己的中继日志中</strong>。（relay log）</li><li><strong>slave重做中继日志中的内容，把更改应用到自己的数据库上</strong>，以达到数据的一致性。</li></ol><p>总的来说<strong>就是一个完全备份加上二进制日志备份的还原。</strong></p><p>注意：复制的流程不是完全实时的同步进行的，而是<strong>异步实时</strong>。其工作原理图如下：<br><img src="/posts/8527/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pvbmdfMDkxNQ==,size_16,color_FFFFFF,t_70-1715607367125-3.png" alt><br>从服务器有2个线程：</p><ul><li>IO线程：<strong>负责读取主服务器的二进制日志，并把它保存为自己的中继日志。</strong></li><li>SQL线程：<strong>负责执行中继日志。</strong></li></ul><p>用户可以通过<code>Show Slave Status</code>来查看当前复制的运行状态，变量表如下：<br><img src="/posts/8527/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pvbmdfMDkxNQ==,size_16,color_FFFFFF,t_70-1715607367125-4.png" alt><br>与之对应的，则可以使用<code>Show Master Status</code>来查看主服务器中二进制日志的状态。</p><hr><p><strong>复制</strong>除了可以用来作为备份，还可以有其他的功能，如下：</p><ul><li>数据分布。</li><li>读取的负载均衡。</li><li>数据库备份。</li><li>高可用性和故障转移。</li></ul><p>最后，还应该注意：<br>建议从服务器上启用<code>read-only</code>选项，<strong>这样能够保证从服务器上的数据仅仅与主服务器进行同步，避免其他线程修改数据。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;事务是保证数据库不会出错的重要机制。&lt;/p&gt;
&lt;h2 id=&quot;一-事务&quot;&gt;&lt;a href=&quot;#一-事务&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://JoyTsing.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="读书笔记" scheme="https://JoyTsing.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数据库" scheme="https://JoyTsing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>探究分布式架构的理论基石</title>
    <link href="https://joytsing.github.io/posts/9434/"/>
    <id>https://joytsing.github.io/posts/9434/</id>
    <published>2024-05-09T08:51:17.000Z</published>
    <updated>2024-05-09T09:14:27.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>现如今的服务已经很少是仅由单机提供的了，这些系统为了同时服务大量的客户，都需要依靠分布式系统以突破单机的瓶颈。CAP 定理决定了分布式系统天生上的限制，通过 CAP 定理我们可以理解为什么共识机制如此复杂，以及系统如何在强一致性与最终一致性间做取舍。</p><p><img src="/posts/9434/v2-5baf23193b56b3a76a987e20c84972fa_720w.webp" alt="青蛙图"></p><h3 id="分布式有多难？"><a href="#分布式有多难？" class="headerlink" title="分布式有多难？"></a>分布式有多难？</h3><p>不管设计什么架构，我们都希望满足 <strong>高性能</strong> 且 <strong>高可用</strong> 的系统，为了突破性能的瓶颈，我们从单核走向了多核，从单机走向了多机；为了防止意外造成系统无法运作，我们通过「备份」来对抗各种天灾人祸。分布式的目的就在于 <strong>突破单机的性能瓶颈</strong> 并 <strong>建立不间断的服务</strong> ，而分布式设计带来的好处，恰恰也是分布式设计的困难点。拓展阅读：<a href="https://zhuanlan.zhihu.com/p/387487859">分布式事务最经典的七种解决方案</a></p><p><img src="/posts/9434/v2-70196133172a61ad7056fdce813d5d54_r.jpg" alt></p><h2 id="CAP-定理"><a href="#CAP-定理" class="headerlink" title="CAP 定理"></a>CAP 定理</h2><h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><p><strong>一致性（C：Consistency）</strong></p><p>一致性意思就是写操作之后进行读操作无论在哪个节点都需要返回写操作的值。</p><blockquote><p>对于一个将数据副本分布在不同分布式节点上的系统来说，如果对第一个节点的数据更新后，却没有使得第二个节点上的数据得到更新，于是在对第二个节点的数据进行读取时，获取的依然是老数据，这就是典型的分布式数据不一致的情况。</p></blockquote><p><img src="/posts/9434/v2-acb72c0b044953442a914a8bae237d1e_720w.webp" alt></p><p><strong>可用性（A：Availability）</strong></p><p>指系统提供的服务一直处于可用的状态，每次请求都能获取到非错的响应（不保证获取的数据为最新数据）。</p><p><strong>分区容错性（P：Partition tolerance）</strong></p><p>分布式系统在遇到任何网络分区（个别节点通信异常）故障的时候，仍然能够对外提供服务。</p><blockquote><p>网络分区是指在分布式系统中，不同的节点分布在不同的子网络（机房或异地网络）中，由于一些特殊的原因导致这些子网络出现网络不连通的状况，但各个子网络的内部网络是正常的，从而导致整个系统的网络环境被切分成了若干个孤立的区域。</p></blockquote><p>对于分布式系统而言，网络问题是一个必定会出现的异常情况，因此分区容错性也就成为了一个分布式系统必然要解决的问题。因此往往需要根据业务特点在一致性和可用性之间寻求平衡，也就是说理论上不可能选择 CA 架构，而必须选择 CP 或 AP 架构。</p><h3 id="分布式的不可能三角-—-CAP-三元取舍"><a href="#分布式的不可能三角-—-CAP-三元取舍" class="headerlink" title="分布式的不可能三角 — CAP 三元取舍"></a>分布式的不可能三角 — CAP 三元取舍</h3><p>CAP 定理乍看之下，三个任取两个都可以，但在现实世界中，网络是最无法被保证的，所以分区容错性（P）是一定要被保障的，所以实际设计系统时，我们要在一致性（C）跟可用性（A）之间做取舍。</p><p><img src="/posts/9434/v2-67ca99570376cd4bd087f201a2a76396_720w.webp" alt></p><h3 id="强一致性-—-CP-与-ACID"><a href="#强一致性-—-CP-与-ACID" class="headerlink" title="强一致性 — CP 与 ACID"></a>强一致性 — CP 与 ACID</h3><p>ACID 是关系型数据库的基石，代表每次事务（Transaction）需要满足原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）及持久性（Durability）。CAP 定理是对于系统的描述，而 ACID 是对于事务（Transaction）的描述，虽然两种对于不同层面描述的理论不应该被放在一起讨论，但这里想强调的是 ACID 是强一致性的描述，如果在分布式情况下满足了，也等于满足了 CP 模型。</p><p>分布式要在系统层面满足强一致性，通常会使用两阶段提交（Two-Phase Commit, 2PC），通常步骤如下：</p><ol><li>使用者向协调者（Coordinator）发起一个写操作</li><li>准备阶段（Prepare Phase）: 协调者向其他所有节点询问是否可以进行此操作</li><li>执行阶段（Commit Phase）: 若所有节点都回复可以执行操作，则协调者向所有节点发送执行此操作</li></ol><p>设计两阶段提交时要注意，在准备阶段（Prepare Phase），节点如果回复「允许」进行操作，那么不管发生什么意外，节点都要能保证在执行阶段（Commit Phase）进行此操作，即使准备阶段后，节点因意外关机，节点也要在意外恢复后，也需要依据协调者的指令完成准备阶段答应的操作。另外因为是强一致性的关系，所以协调者会在执行阶段（Commit Phase）结束才回复使用者，因为如果协调者在准备阶段（Prepare Phase）结束就回复给使用者，那可能因为协调者还没发送执行信息给其他节点前，就意外关机，造成使用者接收到的信息与整个集群不一致。</p><p><img src="/posts/9434/v2-e61c06ca7974075f39582321a82ba5d9_720w.webp" alt="Prepare Phase"></p><p><img src="/posts/9434/v2-2cec963d794c8cb8e6439fb873c38bcf_720w.webp" alt="Commit Phase"></p><p>两阶段操作被应用在许多分布式算法及系统中，比较出名的像是 MySQL XA 、 Raft 等。在更复杂的情况，使用三阶段提交（Three-Phase Commit, 3PC）来解决。</p><h3 id="高可用性-—-AP-与-BASE"><a href="#高可用性-—-AP-与-BASE" class="headerlink" title="高可用性 — AP 与 BASE"></a>高可用性 — AP 与 BASE</h3><p>BASE 是 Basically Available（基本可用）、Soft State（软状态）和 Eventually Consistent（最终一致性）三个短语的缩写。BASE 理论是对 CAP 中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结。BASE 强调牺牲高一致性，从而获取可用性，数据允许在一段时间内不一致，只要保证最终一致性就可以了。</p><p>对于互联网的用户来说，如果一个系统不可用，那即使应用内部的状态有多么的一致，对用户来说都是坏掉的，所以我们很常在互联网应用中看到基础可用（Basically Available）的手法，以 微博点赞数为例，热门的贴文刚发表时，就会涌入一堆人按赞，每一次按赞对系统来说都是一次写入，如果系统为了强一致性让一部份人暂时无法写入的话，那大家一定会觉得是不是系统坏掉了，所以微博并不需要急著统计出一个精确的数字，因为对大多数人来说 8 个赞跟 10 个赞没什么区别，只要系统可以在最后保持最终一致性即可。</p><p>不过只满足了基础可用，系统还是要有方法可以恢复最终一致性（Eventually Consistent），常见的做法有读时修复（Read Repair）、写时修复（Write Repair）以及反熵（Anti-Entropy）。读时修复在读取时同时到多个节点读取，并以最新的节点为主；写时修复，同时写入多个节点，若发现有写入失败则记录下来，定时重传，直到写入成功，或是有新的写入为止；最后反熵则是定期检查状态是否一致，如果不一致则通过特定的修复顺序，修正每个节点的数据。</p><h2 id="NPC-挑战"><a href="#NPC-挑战" class="headerlink" title="NPC 挑战"></a>NPC 挑战</h2><p>NPC是<strong>Network Delay</strong>, <strong>Process Pause</strong>, <strong>Clock Drift</strong>的首字母缩写。我们先看看具体的NPC问题是什么：</p><ul><li><strong>Network Delay</strong>，网络延迟。虽然网络在多数情况下工作的还可以，虽然TCP保证传输顺序和不会丢失，但它无法消除网络延迟问题。</li><li><strong>Process Pause</strong>，进程暂停。有很多种原因可以导致进程暂停：比如编程语言中的GC（垃圾回收机制）会暂停所有正在运行的线程；再比如，我们有时会暂停云服务器，从而可以在不重启的情况下将云服务器从一台主机迁移到另一台主机。我们无法确定性预测进程暂停的时长，你以为持续几百毫秒已经很长了，但实际上持续数分钟之久进程暂停并不罕见。</li><li><strong>Clock Drift</strong>，时钟漂移。现实生活中我们通常认为时间是平稳流逝，单调递增的，但在计算机中不是。计算机使用时钟硬件计时，通常是石英钟，计时精度有限，同时受机器温度影响。为了在一定程度上同步网络上多个机器之间的时间，通常使用NTP协议将本地设备的时间与专门的时间服务器对齐，这样做的一个直接结果是设备的本地时间可能会突然向前或向后跳跃。</li></ul><h3 id="TCC的空补偿与悬挂"><a href="#TCC的空补偿与悬挂" class="headerlink" title="TCC的空补偿与悬挂"></a>TCC的空补偿与悬挂</h3><p>以分布式事务中的TCC作为例子，看看NP带来的影响。一般情况下，一个TCC回滚时的执行顺序是，先执行完Try，再执行Cancel，但是由于N，则有可能Try的网络延迟大，导致先执行Cancel，再执行Try。这种情况就引入了分布式事务中的两个难题：</p><ol><li>空补偿：Cancel执行时，Try未执行，事务分支的Cancel操作需要判断出Try未执行，这时需要忽略Cancel中的业务数据更新，直接返回</li><li>悬挂：Try执行时，Cancel已执行完成，事务分支的Try操作需要判断出Cancel一致性，这时需要忽略Try中的业务数据更新，直接返回</li></ol><p>分布式事务还有一类需要处理的常见问题，就是重复请求，业务需要做幂等处理。因为空补偿、悬挂、重复请求都跟NP有关，我们把他们统称为子事务乱序问题。在业务处理中，需要小心处理好这三种问题，否则会出现错误数据。</p><h3 id="现有方案的问题"><a href="#现有方案的问题" class="headerlink" title="现有方案的问题"></a>现有方案的问题</h3><ul><li>空补偿：“针对该问题，在服务设计时，需要允许空补偿，即在没有找到要补偿的业务主键时，返回补偿成功，并将原业务主键记录下来，标记该业务流水已补偿成功。”</li><li>防悬挂：“需要检查当前业务主键是否已经在空补偿记录下来的业务主键中存在，如果存在则要拒绝执行该笔服务，以免造成数据不一致。”</li></ul><p>上述的这种实现，能够在大部分情况下正常运行，但是上述做法中的“先查后改”在并发情况下是容易掉坑里的，我们分析一下如下场景：</p><ul><li>正常执行顺序下，Try执行时，在查完没有空补偿记录的业务主键之后，事务提交之前，如果发生了进程暂停P，或者事务内部进行网络请求出现了拥塞，导致本地事务等待较久</li><li>全局事务超时后，Cancel执行，因为没有查到要补偿的业务主键，因此判断是空补偿，直接返回</li><li>Try的进程暂停结束，最后提交本地事务</li><li>全局事务回滚完成后，Try分支的业务操作没有被回滚，产生了悬挂</li></ul><p>事实上，NPC里的P和C，以及P和C的组合，有很多种的场景，都可以导致上述竞态情况，情况发生的概率不高，但是在分布式只要有概率发生的事情那就一定会发生。当然现在也有一些更优的解决方案，如阿里开源的seata。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;现如今的服务已经很少是仅由单机提供的了，这些系统为了同时服务大量的客户，都需要依靠分布式系统以突破单机的瓶颈。CAP 定理决定了分布式系统天
      
    
    </summary>
    
    
      <category term="分布式" scheme="https://JoyTsing.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="https://JoyTsing.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis 6与多线程探析</title>
    <link href="https://joytsing.github.io/posts/24194/"/>
    <id>https://joytsing.github.io/posts/24194/</id>
    <published>2024-05-09T08:28:23.000Z</published>
    <updated>2024-05-15T09:04:18.775Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>为什么会开始像多线程转变，最大的原因还是因为两个问题：一个问题是没有办法充分发挥现代 CPU 的多核处理能力，一个实例只能使用一个核的能力。二是如果某个用户请求的处理过程卡住一段时间，会导致其它所有的请求都会出现超时的情况，所以在6.0后Reids也引入了多线程。</p><p><img src="/posts/24194/640-1715762677853-12.webp" alt="单线程"></p><h2 id="一、多线程-Redis-服务启动"><a href="#一、多线程-Redis-服务启动" class="headerlink" title="一、多线程 Redis 服务启动"></a>一、多线程 Redis 服务启动</h2><p>默认情况下多线程是默认关闭的。如果想要启动多线程，需要在配置文件中做适当的修改。相关的配置项是 io-threads 和 io-threads-do-reads 两个。</p><pre><code>io-threads 4 #启用的 io 线程数量io-threads-do-reads yes #读请求也使用io线程</code></pre><p>其中 io-threads 表示要启动的 io 线程的数量。io-threads-do-reads 表示是否在读阶段也使用 io 线程，默认是只在写阶段使用 io 线程的(避免阻塞)。现在假设我们已经打开了如上两项多线程配置。重新看一下Redis 的 main 入口函数。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: src/server.c</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 1.1 主线程初始化</span>    <span class="token function">initServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1.2 启动 io 线程</span>    <span class="token function">InitServerLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 进入事件循环</span>    <span class="token function">aeMain</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-1-主线程初始化"><a href="#1-1-主线程初始化" class="headerlink" title="1.1 主线程初始化"></a>1.1 主线程初始化</h3><p>在 initServer 这个函数内，Redis 主线程做了这么几件重要的事情。</p><p><img src="/posts/24194/640.webp" alt></p><ul><li>初始化读任务队列、写任务队列</li><li>创建一个 epoll 对象</li><li>对配置的监听端口进行 listen</li><li>把 listen socket 让 epoll 给管理起来</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: src/server.c</span><span class="token keyword">void</span> <span class="token function">initServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 1 初始化 server 对象</span>    server<span class="token punctuation">.</span>clients_pending_write <span class="token operator">=</span> <span class="token function">listCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>clients_pending_read <span class="token operator">=</span> <span class="token function">listCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 2 初始化回调 events，创建 epoll</span>    server<span class="token punctuation">.</span>el <span class="token operator">=</span> <span class="token function">aeCreateEventLoop</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxclients<span class="token operator">+</span>CONFIG_FDSET_INCR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 3 绑定监听服务端口</span>    <span class="token function">listenToPort</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>port<span class="token punctuation">,</span>server<span class="token punctuation">.</span>ipfd<span class="token punctuation">,</span><span class="token operator">&amp;</span>server<span class="token punctuation">.</span>ipfd_count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 4 注册 accept 事件处理器</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>ipfd_count<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span> server<span class="token punctuation">.</span>ipfd<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> AE_READABLE<span class="token punctuation">,</span>            acceptTcpHandler<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来我们分别来看。</p><h4 id="初始化-server-对象"><a href="#初始化-server-对象" class="headerlink" title="初始化 server 对象"></a>初始化 server 对象</h4><p>在 initServer 的一开头，先是对 server 的各种成员变量进行初始化。值得注意的是 clients_pending_write 和 clients_pending_read 这两个成员，它们分别是写任务队列和读任务队列。将来主线程产生的任务都会放在放在这两个任务队列里。</p><p>主线程会根据这两个任务队列来进行任务哈希散列，以将任务分配到多个线程中进行处理。</p><h4 id="aeCreateEventLoop-处理"><a href="#aeCreateEventLoop-处理" class="headerlink" title="aeCreateEventLoop 处理"></a>aeCreateEventLoop 处理</h4><p>aeCreateEventLoop会初始化事件回调 event，并且创建了一个 epoll 对象出来。具体创建 epoll 的过程在 ae_epoll.c 文件下的 aeApiCreate 中。在这里，真正调用了 epoll_create</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/ae_epoll.c</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">aeApiCreate</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">{</span>    aeApiState <span class="token operator">*</span>state <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>aeApiState<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    state<span class="token operator">-></span>epfd <span class="token operator">=</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     eventLoop<span class="token operator">-></span>apidata <span class="token operator">=</span> state<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="绑定监听服务端口"><a href="#绑定监听服务端口" class="headerlink" title="绑定监听服务端口"></a>绑定监听服务端口</h4><p>我们再来看 Redis 中的 listen 过程，它在 listenToPort 函数中。调用链条很长，依次是 listenToPort =&gt; anetTcpServer =&gt; _anetTcpServer =&gt; anetListen。在 anetListen 中，就是简单的 bind 和 listen 的调用。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/anet.c</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">anetListen</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">bind</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>sa<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">listen</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> backlog<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="注册事件回调函数"><a href="#注册事件回调函数" class="headerlink" title="注册事件回调函数"></a>注册事件回调函数</h4><p>前面我们调用 aeCreateEventLoop 创建了 epoll，调用 listenToPort 进行了服务端口的 bind 和 listen。接着就调用的 aeCreateFileEvent 就是来注册一个 accept 事件处理器。 aeCreateFileEvent 具体代码:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: src/ae.c</span><span class="token keyword">int</span> <span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">,</span>        aeFileProc <span class="token operator">*</span>proc<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 取出一个文件事件结构</span>    aeFileEvent <span class="token operator">*</span>fe <span class="token operator">=</span> <span class="token operator">&amp;</span>eventLoop<span class="token operator">-></span>events<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 监听指定 fd 的指定事件</span>    <span class="token function">aeApiAddEvent</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> mask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 设置文件事件类型，以及事件的处理器</span>    fe<span class="token operator">-></span>mask <span class="token operator">|</span><span class="token operator">=</span> mask<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mask <span class="token operator">&amp;</span> AE_READABLE<span class="token punctuation">)</span> fe<span class="token operator">-></span>rfileProc <span class="token operator">=</span> proc<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mask <span class="token operator">&amp;</span> AE_WRITABLE<span class="token punctuation">)</span> fe<span class="token operator">-></span>wfileProc <span class="token operator">=</span> proc<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 私有数据</span>    fe<span class="token operator">-></span>clientData <span class="token operator">=</span> clientData<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数 aeCreateFileEvent 一开始，从 eventLoop-&gt;events 获取了一个 aeFileEvent 对象。接下来调用 aeApiAddEvent。这个函数其实就是对 epoll_ctl 的一个封装。主要就是实际执行 epoll_ctl <code>EPOLL_CTL_ADD</code>。</p><p>每一个 eventLoop-&gt;events 元素都指向一个 aeFileEvent 对象。在这个对象上，设置了三个关键东西</p><ul><li>rfileProc：读事件回调</li><li>wfileProc：写事件回调</li><li>clientData：一些额外的扩展数据</li></ul><p>将来 当 epoll_wait 发现某个 fd 上有事件发生的时候，这样 redis 首先根据 fd 到 eventLoop-&gt;events 中查找 aeFileEvent 对象，然后再看 rfileProc、wfileProc 就可以找到读、写回调处理函数。</p><h3 id="1-2-io-线程启动"><a href="#1-2-io-线程启动" class="headerlink" title="1.2 io 线程启动"></a>1.2 io 线程启动</h3><p>回顾完后，接下来是重点。在主线程启动以后，会调用 InitServerLast =&gt; initThreadedIO 来创建多个 io 线程。</p><p><img src="/posts/24194/640-1715762635473-3.webp" alt></p><p>将来这些 IO 线程会配合主线程一起共同来处理所有的 read 和 write 任务。</p><p><img src="/posts/24194/640-1715762635473-4.webp" alt></p><p>我们来看 InitServerLast 创建 IO 线程的过程：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/server.c</span><span class="token keyword">void</span> <span class="token function">InitServerLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">initThreadedIO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//file:src/networking.c</span><span class="token keyword">void</span> <span class="token function">initThreadedIO</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//如果没开启多 io 线程配置就不创建了</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>io_threads_num <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//开始 io 线程的创建</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>io_threads_num<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        pthread_t tid<span class="token punctuation">;</span>        <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tid<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>IOThreadMain<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>i<span class="token punctuation">)</span>        io_threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tid<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 initThreadedIO 中调用 pthread_create 库函数创建线程，并且注册线程回调函数 IOThreadMain。 IOThreadMain将当前线程等待队列 io_threads_list[id] 里所有的请求 client，依次取出处理。其中读操作通过 readQueryFromClient 处理， 写操作通过 writeToClient 处理，其中 io_threads_list[id] 中的任务是主线程分配过来的。</p><h2 id="二、主线程事件循环"><a href="#二、主线程事件循环" class="headerlink" title="二、主线程事件循环"></a>二、主线程事件循环</h2><p>接着我们进入到 Redis 最重要的 aeMain，这个函数就是一个死循环（Redis 不退出的话），不停地执行 aeProcessEvents 函数。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">aeMain</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">{</span>    eventLoop<span class="token operator">-></span>stop <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>eventLoop<span class="token operator">-></span>stop<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">aeProcessEvents</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> AE_ALL_EVENTS<span class="token operator">|</span>                                   AE_CALL_BEFORE_SLEEP<span class="token operator">|</span>                                   AE_CALL_AFTER_SLEEP<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 aeProcessEvents 就是所谓的事件分发器。它通过调用 epoll_wait 来发现所发生的各种事件，然后调用事先注册好的处理函数进行处理。</p><p><img src="/posts/24194/640-1715763062870-15.webp" alt></p><p>接着看 aeProcessEvents 函数。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/ae.c</span><span class="token keyword">int</span> <span class="token function">aeProcessEvents</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 2.3 事件循环处理3：epoll_wait 前进行读写任务队列处理</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>eventLoop<span class="token operator">-></span>beforesleep <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> flags <span class="token operator">&amp;</span> AE_CALL_BEFORE_SLEEP<span class="token punctuation">)</span>            eventLoop<span class="token operator">-></span><span class="token function">beforesleep</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//epoll_wait发现事件并进行处理</span>    numevents <span class="token operator">=</span> <span class="token function">aeApiPoll</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> tvp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 从已就绪数组中获取事件</span>    aeFileEvent <span class="token operator">*</span>fe <span class="token operator">=</span> <span class="token operator">&amp;</span>eventLoop<span class="token operator">-></span>events<span class="token punctuation">[</span>eventLoop<span class="token operator">-></span>fired<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>fd<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果是读事件，并且有读回调函数</span>    <span class="token comment" spellcheck="true">//2.1 如果是 listen socket 读事件，则处理新连接请求</span>    <span class="token comment" spellcheck="true">//2.2 如果是客户连接socket 读事件，处理客户连接上的读请求</span>    fe<span class="token operator">-></span><span class="token function">rfileProc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//如果是写事件，并且有写回调函数</span>    fe<span class="token operator">-></span><span class="token function">wfileProc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 aeApiPoll 就是对 epoll_wait 的一个封装而已。所以aeProcessEvents 就是调用 epoll_wait 来发现事件，当发现有某个 fd 上事件发生以后，则调为其事先注册的事件处理器函数 rfileProc 和 wfileProc。</p><h3 id="2-1-事件循环处理1：新连接到达"><a href="#2-1-事件循环处理1：新连接到达" class="headerlink" title="2.1 事件循环处理1：新连接到达"></a>2.1 事件循环处理1：新连接到达</h3><p>主线程初始化的时候，将 listen socket 上的读事件处理函数注册成了 acceptTcpHandler。也就是说如果有新连接到达的时候，acceptTcpHandler 将会被执行到。</p><p><img src="/posts/24194/640-1715763179991-18.webp" alt></p><p>在这个函数内，主要完成如下几件事情。</p><ul><li>调用 accept 接收连接</li><li>创建一个 redisClient对象</li><li>添加到 epoll</li><li>注册读事件处理函数，将这个新连接的读事件处理函数设置成了 readQueryFromClient。</li></ul><h3 id="2-2-事件循环处理2：用户命令请求到达"><a href="#2-2-事件循环处理2：用户命令请求到达" class="headerlink" title="2.2 事件循环处理2：用户命令请求到达"></a>2.2 事件循环处理2：用户命令请求到达</h3><p> Redis 把用户连接上的读请求处理函数设置成了 readQueryFromClient，这意味着当用户连接上有命令发送过来的时候，会进入 readQueryFromClient 开始执行。在多线程版本的 readQueryFromClient 中，处理逻辑非常简单，仅仅只是将发生读时间的 client 放到了任务队列里而已。</p><p><img src="/posts/24194/640-1715763235459-21.webp" alt></p><p>来详细看 readQueryFromClient 代码。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/networking.c</span><span class="token keyword">void</span> <span class="token function">readQueryFromClient</span><span class="token punctuation">(</span>connection <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token punctuation">{</span>    client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">connGetPrivateData</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果启动 threaded I/O 的话，直接入队</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">postponeClientRead</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//处理用户连接读请求</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    c<span class="token operator">-></span>querybuf <span class="token operator">=</span> <span class="token function">sdsMakeRoomFor</span><span class="token punctuation">(</span>c<span class="token operator">-></span>querybuf<span class="token punctuation">,</span> readlen<span class="token punctuation">)</span><span class="token punctuation">;</span>    nread <span class="token operator">=</span> <span class="token function">connRead</span><span class="token punctuation">(</span>c<span class="token operator">-></span>conn<span class="token punctuation">,</span> c<span class="token operator">-></span>querybuf<span class="token operator">+</span>qblen<span class="token punctuation">,</span> readlen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">processInputBuffer</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 postponeClientRead 中判断，是不是开启了多 io 线程，如果开启了的话，那就将有请求数据到达的 client 直接放到读任务队列（server.clients_pending_read）中就算是完事。</p><h3 id="2-3-事件循环处理3：epoll-wait-前进行任务处理"><a href="#2-3-事件循环处理3：epoll-wait-前进行任务处理" class="headerlink" title="2.3 事件循环处理3：epoll_wait 前进行任务处理"></a>2.3 事件循环处理3：epoll_wait 前进行任务处理</h3><p>在 aeProcessEvents 中假如 aeApiPoll(epoll_wait)中的事件都处理完了以后，则会进入下一次的循环再次进入 aeProcessEvents。而这一次中 beforesleep 将会处理前面读事件处理函数添加的读任务队列了。</p><p>在 beforeSleep 里会依次处理两个任务队列。先处理读任务队列，解析其中的请求，并处理之。然后将处理结果写到缓存中，同时写到写任务队列中。紧接着 beforeSleep 会进入写任务队列处理，会将处理结果写到 socket 里，进行真正的数据发送。</p><p><img src="/posts/24194/640-1715763342627-24.webp" alt></p><p> beforeSleep 的代码，这个函数中最重要的两个调用是 handleClientsWithPendingReadsUsingThreads（处理读任务队列），handleClientsWithPendingWritesUsingThreads（处理写任务队列）</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/server.c</span><span class="token keyword">void</span> <span class="token function">beforeSleep</span><span class="token punctuation">(</span><span class="token keyword">struct</span> aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//处理读任务队列</span>    <span class="token function">handleClientsWithPendingReadsUsingThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//处理写任务队列</span>    <span class="token function">handleClientsWithPendingWritesUsingThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>值得注意的是，如果开启了多 io 线程的话，handleClientsWithPendingReadsUsingThreads 和 handleClientsWithPendingWritesUsingThreads 中将会是主线程、io 线程一起配合来处理的。</p><h2 id="三、主线程-amp-amp-io-线程处理读请求"><a href="#三、主线程-amp-amp-io-线程处理读请求" class="headerlink" title="三、主线程 &amp;&amp; io 线程处理读请求"></a>三、主线程 &amp;&amp; io 线程处理读请求</h2><p>在 handleClientsWithPendingReadsUsingThreads 中，主线程会遍历读任务队列 server.clients_pending_read，把其中的请求分配到每个 io 线程的处理队列 io_threads_list[target_id] 中。然后通知各个 io 线程开始处理。</p><p><img src="/posts/24194/640-1715763385277-27.webp" alt="图片"></p><h3 id="3-1-主线程分配任务"><a href="#3-1-主线程分配任务" class="headerlink" title="3.1 主线程分配任务"></a>3.1 主线程分配任务</h3><p> handleClientsWithPendingReadsUsingThreads 详细代码。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/networking.c</span><span class="token comment" spellcheck="true">//当开启了 reading + parsing 多线程 I/O </span><span class="token comment" spellcheck="true">//read handler 仅仅只是把 clients 推到读队列里</span><span class="token comment" spellcheck="true">//而这个函数开始处理该任务队列</span><span class="token keyword">int</span> <span class="token function">handleClientsWithPendingReadsUsingThreads</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//访问读任务队列 server.clients_pending_read</span>    <span class="token function">listRewind</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_read<span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//把每一个任务取出来</span>    <span class="token comment" spellcheck="true">//添加到指定线程的任务队列里 io_threads_list[target_id]</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> target_id <span class="token operator">=</span> item_id <span class="token operator">%</span> server<span class="token punctuation">.</span>io_threads_num<span class="token punctuation">;</span>        <span class="token function">listAddNodeTail</span><span class="token punctuation">(</span>io_threads_list<span class="token punctuation">[</span>target_id<span class="token punctuation">]</span><span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        item_id<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//启动Worker线程，处理读请求</span>    io_threads_op <span class="token operator">=</span> IO_THREADS_OP_READ<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>io_threads_num<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token function">listLength</span><span class="token punctuation">(</span>io_threads_list<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setIOPendingCount</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//主线程处理 0 号任务队列</span>    <span class="token function">listRewind</span><span class="token punctuation">(</span>io_threads_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//需要先干掉 CLIENT_PENDING_READ 标志</span>        <span class="token comment" spellcheck="true">//否则 readQueryFromClient 并不处理，而是入队</span>        client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">readQueryFromClient</span><span class="token punctuation">(</span>c<span class="token operator">-></span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//主线程等待其它线程处理完毕</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> pending <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>io_threads_num<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            pending <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">getIOPendingCount</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pending <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//再跑一遍任务队列，目的是处理输入</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">listLength</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_read<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token function">processInputBuffer</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>c<span class="token operator">-></span>flags <span class="token operator">&amp;</span> CLIENT_PENDING_WRITE<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">clientHasPendingReplies</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">clientInstallWriteHandler</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在主线程中将任务分别放到了 io_threads_list 的第 0 到第 N 个元素里。并对 1 : N 号线程通过 setIOPendingCount 发消息，告诉他们起来处理。这时候 io 线程将会在 IOThreadMain 中收到消息并开始处理读任务。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/networking.c</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">IOThreadMain</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>myid<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//遍历当前线程等待队列里的请求 client</span>        <span class="token function">listRewind</span><span class="token punctuation">(</span>io_threads_list<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>io_threads_op <span class="token operator">==</span> IO_THREADS_OP_WRITE<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">writeToClient</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>io_threads_op <span class="token operator">==</span> IO_THREADS_OP_READ<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">readQueryFromClient</span><span class="token punctuation">(</span>c<span class="token operator">-></span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token function">serverPanic</span><span class="token punctuation">(</span><span class="token string">"io_threads_op value is unknown"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 io 线程中，从自己的 io_threads_list[id] 中遍历获取待处理的 client。如果发现是读请求处理，则进入 readQueryFromClient 开始处理特定的 client。而主线程在分配完 1 ：N 任务队列让其它 io 线程处理后，自己则开始处理第 0 号任务池。同样是会进入到 readQueryFromClient 中来执行。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/networking.c</span><span class="token keyword">int</span> <span class="token function">handleClientsWithPendingReadsUsingThreads</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">//主线程处理 0 号任务队列</span>    <span class="token function">listRewind</span><span class="token punctuation">(</span>io_threads_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//需要先干掉 CLIENT_PENDING_READ 标志</span>        <span class="token comment" spellcheck="true">//否则 readQueryFromClient 并不处理，而是入队</span>        client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">readQueryFromClient</span><span class="token punctuation">(</span>c<span class="token operator">-></span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以无论是主线程还是 io 线程，处理客户端的读事件都是会进入 readQueryFromClient。</p><h3 id="3-2-读请求处理"><a href="#3-2-读请求处理" class="headerlink" title="3.2 读请求处理"></a>3.2 读请求处理</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/networking.c</span><span class="token keyword">void</span> <span class="token function">readQueryFromClient</span><span class="token punctuation">(</span>connection <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//读取请求</span>    nread <span class="token operator">=</span> <span class="token function">connRead</span><span class="token punctuation">(</span>c<span class="token operator">-></span>conn<span class="token punctuation">,</span> c<span class="token operator">-></span>querybuf<span class="token operator">+</span>qblen<span class="token punctuation">,</span> readlen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//处理请求</span>    <span class="token function">processInputBuffer</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 connRead 中就是调用 read 将 socket 中的命令读取出来。接着在 processInputBuffer 中将输入缓冲区中的数据解析成对应的命令。解析完命令后真正开始处理它。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/networking.c</span><span class="token keyword">void</span> <span class="token function">processInputBuffer</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>c<span class="token operator">-></span>qb_pos <span class="token operator">&lt;</span> <span class="token function">sdslen</span><span class="token punctuation">(</span>c<span class="token operator">-></span>querybuf<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//解析命令</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true">//真正开始处理 command</span>        <span class="token function">processCommandAndResetClient</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数 processCommandAndResetClient 会调用 processCommand，查询命令并开始执行，执行的核心方法是 call 函数。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/server.c</span><span class="token keyword">void</span> <span class="token function">call</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 查找处理命令，</span>    <span class="token keyword">struct</span> redisCommand <span class="token operator">*</span>real_cmd <span class="token operator">=</span> c<span class="token operator">-></span>cmd<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用命令处理函数</span>    c<span class="token operator">-></span>cmd<span class="token operator">-></span><span class="token function">proc</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-写处理结果到发送缓存区"><a href="#3-3-写处理结果到发送缓存区" class="headerlink" title="3.3 写处理结果到发送缓存区"></a>3.3 写处理结果到发送缓存区</h3><p>其主体是调用 addReply 来设置回复数据。在 addReply 方法中做了两件事情：</p><ul><li>prepareClientToWrite 判断是否需要返回数据，并且将当前 client 添加到等待写返回数据队列中。</li><li>调用 _addReplyToBuffer 和 _addReplyObjectToList 方法将返回值写入到输出缓冲区中，等待写入 socekt</li></ul><p>读请求处理过程是主线程和 io 线程在并行执行的。主线程在处理完后会等待其它的 io 线程处理。在所有的读请求都处理完后，主线程 beforeSleep 中对 handleClientsWithPendingReadsUsingThreads 的调用就结束了。</p><h2 id="四、主线程-amp-amp-io-线程配合处理写请求"><a href="#四、主线程-amp-amp-io-线程配合处理写请求" class="headerlink" title="四、主线程 &amp;&amp; io 线程配合处理写请求"></a>四、主线程 &amp;&amp; io 线程配合处理写请求</h2><p>当所有的读请求处理完后，handleClientsWithPendingReadsUsingThreads 会退出。主线程会紧接着进入 handleClientsWithPendingWritesUsingThreads 中来处理。</p><p><img src="/posts/24194/640-1715763641211-30.webp" alt></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/server.c</span><span class="token keyword">void</span> <span class="token function">beforeSleep</span><span class="token punctuation">(</span><span class="token keyword">struct</span> aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//处理读任务队列</span>    <span class="token function">handleClientsWithPendingReadsUsingThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//处理写任务队列</span>    <span class="token function">handleClientsWithPendingWritesUsingThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-1-主线程分配任务"><a href="#4-1-主线程分配任务" class="headerlink" title="4.1 主线程分配任务"></a>4.1 主线程分配任务</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/networking.c</span><span class="token keyword">int</span> <span class="token function">handleClientsWithPendingWritesUsingThreads</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//没有开启多线程的话，仍然是主线程自己写</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>io_threads_num <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> <span class="token function">stopThreadedIOIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">handleClientsWithPendingWrites</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">//获取待写任务</span>    <span class="token keyword">int</span> processed <span class="token operator">=</span> <span class="token function">listLength</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_write<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//在N个任务列表中分配该任务</span>    listIter li<span class="token punctuation">;</span>    listNode <span class="token operator">*</span>ln<span class="token punctuation">;</span>    <span class="token function">listRewind</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_write<span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> item_id <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>        c<span class="token operator">-></span>flags <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token operator">~</span>CLIENT_PENDING_WRITE<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* Remove clients from the list of pending writes since         * they are going to be closed ASAP. */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>flags <span class="token operator">&amp;</span> CLIENT_CLOSE_ASAP<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">listDelNode</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_write<span class="token punctuation">,</span> ln<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//hash的方式进行分配</span>        <span class="token keyword">int</span> target_id <span class="token operator">=</span> item_id <span class="token operator">%</span> server<span class="token punctuation">.</span>io_threads_num<span class="token punctuation">;</span>        <span class="token function">listAddNodeTail</span><span class="token punctuation">(</span>io_threads_list<span class="token punctuation">[</span>target_id<span class="token punctuation">]</span><span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        item_id<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//告诉对应的线程该开始干活了</span>    io_threads_op <span class="token operator">=</span> IO_THREADS_OP_WRITE<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>io_threads_num<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token function">listLength</span><span class="token punctuation">(</span>io_threads_list<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setIOPendingCount</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//主线程自己也会处理一些</span>    <span class="token function">listRewind</span><span class="token punctuation">(</span>io_threads_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">writeToClient</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">listEmpty</span><span class="token punctuation">(</span>io_threads_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//循环等待其它线程结束处理</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> pending <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>io_threads_num<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            pending <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">getIOPendingCount</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pending <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 io 线程中收到消息后，开始遍历自己的任务队列 io_threads_list[id]，并将其中的 client 挨个取出来开始处理。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/networking.c</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">IOThreadMain</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>myid<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//遍历当前线程等待队列里的请求 client</span>        <span class="token function">listRewind</span><span class="token punctuation">(</span>io_threads_list<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>io_threads_op <span class="token operator">==</span> IO_THREADS_OP_WRITE<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">writeToClient</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>io_threads_op <span class="token operator">==</span> IO_THREADS_OP_READ<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">readQueryFromClient</span><span class="token punctuation">(</span>c<span class="token operator">-></span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>         <span class="token punctuation">}</span>        <span class="token function">listEmpty</span><span class="token punctuation">(</span>io_threads_list<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-写请求处理"><a href="#4-2-写请求处理" class="headerlink" title="4.2 写请求处理"></a>4.2 写请求处理</h3><p>由于这次任务队列里都是写请求，所以 io 线程会进入 writeToClient。而主线程在分配完任务以后，自己开始处理起了 io_threads_list[0]，并也进入到 writeToClient。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/networking.c</span><span class="token keyword">int</span> <span class="token function">writeToClient</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> client <span class="token operator">*</span>c<span class="token punctuation">,</span> <span class="token keyword">int</span> handler_installed<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">clientHasPendingReplies</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 先发送固定缓冲区</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>bufpos <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            nwritten <span class="token operator">=</span> <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>c<span class="token operator">-></span>buf<span class="token operator">+</span>c<span class="token operator">-></span>sentlen<span class="token punctuation">,</span>c<span class="token operator">-></span>bufpos<span class="token operator">-</span>c<span class="token operator">-></span>sentlen<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nwritten <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true">// 再发送回复链表中数据</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            o <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span><span class="token function">listFirst</span><span class="token punctuation">(</span>c<span class="token operator">-></span>reply<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            nwritten <span class="token operator">=</span> <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> o<span class="token operator">-></span>buf <span class="token operator">+</span> c<span class="token operator">-></span>sentlen<span class="token punctuation">,</span> objlen <span class="token operator">-</span> c<span class="token operator">-></span>sentlen<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>writeToClient 中的主要逻辑就是调用 write 系统调用让内核帮其把数据发送出去即可。由于每个命令的处理结果大小是不固定的。所以 Redis 采用的做法用固定的 buf + 可变链表来储存结果字符串。这里自然发送的时候就需要分别对固定缓存区和链表来进行发送了。</p><p>当所有的写请求也处理完后，beforeSleep 就退出了。主线程将会再次调用 epoll_wait 来发现请求，进入下一轮的用户请求处理。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: src/server.c</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 1.1 主线程初始化</span>    <span class="token function">initServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1.2 启动 io 线程</span>    <span class="token function">InitServerLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 进入事件循环</span>    <span class="token function">aeMain</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 initServer 这个函数内，Redis 做了这么三件重要的事情。</p><ul><li>创建一个 epoll 对象</li><li>对配置的监听端口进行 listen</li><li>把 listen socket 让 epoll 给管理起来</li></ul><p>在 initThreadedIO 中调用 pthread_create 库函数创建线程，并且注册线程回调函数 IOThreadMain。在 IOThreadMain 中等待其队列 io_threads_list[id] 产生请求，当有请求到达的时候取出 client，依次处理。其中读操作通过 readQueryFromClient 处理， 写操作通过 writeToClient 处理。</p><p>主线程在 aeMain 函数中，是一个无休止的循环，它是 Redis 中最重要的部分。它先是调用事件分发器发现事件。如果有新连接请求到达的时候，执行 accept 接收新连接，并为其注册事件处理函数。</p><p>当用户连接上有命令请求到达的时候，主线程在 read 处理函数中将其添加到读发送队列中。然后接着在 beforeSleep 中开启对读任务队列和写任务队列的处理。总体工作过程如下图所示。</p><p><img src="/posts/24194/640-1715763674958-33.webp" alt></p><p>在这个处理过程中，对读任务队列和写任务队列的处理都是多线程并行进行的（前提是开篇我们开启了多 IO 线程并且也并发处理读）。当读任务队列和写任务队列的都处理完的时候，主线程再一次调用 epoll_wait 去发现新的待处理事件，如此往复循环进行处理。</p><p>但这并不是说就不会阻塞了，原因是主线程是在处理读、写任务队列的时候还要等待其它的 io 线程处理完才能进入下一步。假设这时有 10 个用户请求到达，其中 9 个处理耗时需要 1 ms，而另外一个命令需要 1 s。则这时主线程仍然会等待这个 io 线程处理 1s 结束后才能进入后面的处理。整个 Redis 服务还是被一个耗时的命令给 block 住了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;为什么会开始像多线程转变，最大的原因还是因为两个问题：一个问题是没有办法充分发挥现代 CPU 的多核处理能力，一个实例只能使用一个核的能力。
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://JoyTsing.github.io/categories/Redis/"/>
    
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
      <category term="Redis" scheme="https://JoyTsing.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL技术内幕-InnoDB存储引擎(三)</title>
    <link href="https://joytsing.github.io/posts/47027/"/>
    <id>https://joytsing.github.io/posts/47027/</id>
    <published>2024-05-07T12:38:06.000Z</published>
    <updated>2024-05-14T13:46:51.716Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>可以说是核心部分了，很多时候我们谈数据库其实大部分时间谈的都是其存储引擎。</p><h2 id="一-索引算法"><a href="#一-索引算法" class="headerlink" title="一.索引算法"></a>一.索引算法</h2><h3 id="1-1-B-树"><a href="#1-1-B-树" class="headerlink" title="1.1 B+树"></a>1.1 B+树</h3><p>就不在这科普了，可以看看相关的文章。</p><h4 id="1-1-1-B-树索引"><a href="#1-1-1-B-树索引" class="headerlink" title="1.1.1 B+树索引"></a>1.1.1 B+树索引</h4><p>B+树索引在数据库当中有一个特点是<strong>高扇出性</strong>，其高度一般在2 ~ 4层，也就是说查找某一个键值的行记录时最多只需要2 ~ 4次IO。B+树索引可以分为聚簇索引和辅助索引。</p><h5 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h5><p><strong>聚簇索引就是按照每张表的主键构造一颗B+树，叶子节点存放的是整张表的行记录数据</strong>，其叶子节点也称为数据页，而在非数据页的索引页中，存放的仅仅是键值以及指向数据页的偏移量，此外，每个数据页都通过一个双向链表来进行连接。由于实际的数据页只能按照一颗B+树进行排序，因此每张表只能拥有一个聚簇索引。</p><p>聚簇索引的存储并不是物理上连续的，而是逻辑上连续的，其中包含两点：</p><ul><li>页通过双向列表连接，页按照主键的顺序排序。</li><li><strong>每个页中的记录也是通过双向链表进行维护的，物理存储上可以同样不按照主键存储。</strong></li></ul><p>聚簇索引的好处：</p><ul><li>对于主键的排序查找和范围查找速度非常快，<strong>因为叶子节点的数据就是用户所需要查询的数据。</strong></li><li>如果想要查找主键某一范围内的数据，<strong>通过叶子节点的上层中间节点就可以得到页的范围，之后直接读取数据页即可。</strong></li></ul><h5 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h5><p>辅助索引也就是非聚簇索引，<strong>叶子节点不包含行记录的全部数据</strong>。叶子节点除了包含键值以外，每个叶子节点的索引行中还包含了一个书签（bookmark）</p><blockquote><p>书签：<strong>用来告诉InnoDB存储引擎哪里可以找到与索引相对应的行数据，书签作为一个行标识符（Row Identified RID），可以用如“文件号：页号：槽号”的格式来定位实际的行数据。</strong></p><p>由于InnoDB存储引擎表是索引组织表，因此InnoDB存储引擎的辅助索引的书签就是相对应的行数据的聚簇索引键。</p></blockquote><p>大家知道，聚簇索引是顺序读，非聚簇索引是离散读，<strong>而一般数据库就通过预读的方式来避免多次的离散操作。</strong></p><h4 id="1-1-2-B-树索引的分裂"><a href="#1-1-2-B-树索引的分裂" class="headerlink" title="1.1.2 B+树索引的分裂"></a>1.1.2 B+树索引的分裂</h4><p>首先大家应该了解到，B+树的索引页的分裂并不总是从页的中间记录开始，因为这样可能导致页空间的浪费，举个例子：</p><blockquote><p>数据页中的记录为：1，2，3，4，5，6，7，8，9。此时要插入记录10<br>假设插入操作会引起页的分裂，那么此时会将记录5作为分裂点记录，分裂后得到两个页：<br>P1：1，2，3，4<br>P2：5，6，7，8，9，10<br>又因为<strong>插入是根据自增顺序进行的，P1这个也中将不会在有记录被插入，从而导致空间的浪费</strong>，而P2又会再次进行分裂（当需要分裂的时候）。</p></blockquote><p>然后对于InnoDB存储引擎而言，<strong>通过Page Header保存的插入顺序信息来决定是向左还是向右进行分裂，同时决定将哪一个点作为分裂点（若插入是随机的，则取页的中检记录作为分裂点的记录），</strong> 保存的信息如下：</p><ul><li>PAGE_LAST_INSERT</li><li>PAGE_DIRECTION</li><li>PAGE_N_DIRECTION</li></ul><h4 id="1-1-3-B-树索引的管理"><a href="#1-1-3-B-树索引的管理" class="headerlink" title="1.1.3 B+树索引的管理"></a>1.1.3 B+树索引的管理</h4><h5 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h5><p>索引的创建和删除可以通过两种方法：</p><ul><li>Alter Table</li></ul><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token punctuation">[</span>表名<span class="token punctuation">]</span> <span class="token keyword">ADD</span> <span class="token punctuation">[</span><span class="token keyword">INDEX</span> <span class="token operator">|</span> <span class="token keyword">key</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>索引名称<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">[</span>需要加索引的列名称<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>Create/Drop Index</li></ul><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> <span class="token punctuation">[</span>索引名称<span class="token punctuation">]</span> <span class="token keyword">on</span> <span class="token punctuation">[</span>表名<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">[</span>需要加索引的列名称<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如，我有一张login表(主键为id)：<br><img src="/posts/47027/20201215151943898.png" alt><br>我通过两种方式进行添加索引：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># username(10)表示只对前10个字段索引</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> login <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> myindex<span class="token punctuation">(</span>username<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>；<span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> unioIndex <span class="token keyword">on</span> login<span class="token punctuation">(</span>username<span class="token punctuation">,</span>login_time<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以通过命令<code>SHOW INDEX FROM [表名];</code>的方式查看索引信息</p><p>参考表：</p><table><thead><tr><th>属性名</th><th>含义</th></tr></thead><tbody><tr><td>Table</td><td>索引所在的表名</td></tr><tr><td>Non_unique</td><td>非唯一的索引，可以看到primary key是0，因为其必须是唯一</td></tr><tr><td>Key_name</td><td>索引的名字，用户可以通过这个名字来执行Drop Index</td></tr><tr><td>Seq_in_index</td><td>索引中该列的位置（直观的看联合索引）</td></tr><tr><td>Column_name</td><td>索隐列的名称</td></tr><tr><td>Collation</td><td>列以什么方式存储在索引中，可以为A（B+树索引总是A）或者NULL（使用Heap存储引擎并且简历了Hash索引）</td></tr><tr><td><strong>Cardinality</strong></td><td>很重要，表示索引中唯一值的数目的估计值，需要其尽可能接近1，若非常小，可以考虑删除该索引</td></tr><tr><td>Sub_part</td><td>是否是列的部分被索引,参考username(10)</td></tr><tr><td>Packed</td><td>关键字如何被压缩，若没有被压缩，则为NULL</td></tr><tr><td>Null</td><td>是否索引的列中含有Null值</td></tr><tr><td>Index_type</td><td>索引的类型，包含BTREE和HASH</td></tr><tr><td>Comment</td><td>注释</td></tr></tbody></table><p>Cardinality这个值非常关键，优化器会根据这个值来判断是否使用这个索引。这个值是不太准确的，也并非实时更新，若需要更新索引Cardinality的信息，可以使用<code>ANALYZE TABLE [表名];</code>进行刷新。</p><h5 id="Fast-Index-Creation（FIC）"><a href="#Fast-Index-Creation（FIC）" class="headerlink" title="Fast Index Creation（FIC）"></a>Fast Index Creation（FIC）</h5><p>在Mysql5.5版本之前，Mysql数据库对于索引的添加或者删除的这类DDL操作，其操作过程为：</p><ol><li>首先创建一张新的临时表，表结构为通过命令Alter Table新定义的结构。</li><li>然后把原表中的数据导入到临时表中。</li><li>接着删除原表。</li><li>最后把临时表重命名为原来的表名。</li></ol><p>那么，如果一张表存放着大量的数据，进行删除或者添加索引的操作，这肯定会消耗很长的时间。因此有了一种快速索引创建的方式：FIC。</p><blockquote><p>对于辅助索引的创建，<strong>InnoDB存储引擎会对创建索引的表加上一个S锁</strong>。而在创建过程中，不需要新建一个临时表。<br>对于其删除，<strong>InnoDB存储引擎只需要更新内部视图，并将辅助索引的空间标记为可用，同时删除Mysql数据库内部视图上对该表的索引定义即可。</strong></p></blockquote><p><strong>注意：<br>FIC方式只限定于辅助索引，对主键的创建和删除同样需要重建一张表。</strong></p><h3 id="1-2-Cardinality值"><a href="#1-2-Cardinality值" class="headerlink" title="1.2 Cardinality值"></a>1.2 Cardinality值</h3><p>先来说下什么时候用B+树索引？在访问表中很少一部分时使用B+树索引才有意义，对于性别字段这一类取值范围小的，也就是低选择性的，添加B+树索引是没有必要的。那么怎样查看索引是否是高选择性呢？通过Cardinality来观察。</p><p>Cardinality表示索引中不重复记录数量的<strong>预估值</strong>，在InnoDB存储引擎中，Cardinality统计信息的更新发生在两个操作中：<code>INSERT</code>和<code>UPDATE</code>。但同时，也不可能每次发生这俩操作就去更新Cardinality信息，这样会增加数据库系统的负荷。因此InnoDB存储引擎有一个更新策略：</p><ul><li>表中1/16的数据已发生过变化。</li><li>stat_modified_counter（表示发生变化的次数） &gt; 2 000 000 000。</li></ul><p>再来说一下Cardinality的统计，通过<strong>采样</strong>的方法来完成：</p><ol><li>取得B+树索引中叶子节点的数量，记为A。</li><li>随机取得B+树索引中的8个叶子节点，统计每个页不同记录的个数，记为P1,P2……P8。</li><li>根据采样信息给出Cardinality的预估值：Cardinality=（P1+P2……+P8）*A/8</li></ol><p>备注：<strong>InnoDB存储引擎默认对8个叶子节点进行采用。</strong></p><h3 id="1-3-B-树索引的使用"><a href="#1-3-B-树索引的使用" class="headerlink" title="1.3 B+树索引的使用"></a>1.3 B+树索引的使用</h3><p><strong>联合索引</strong><br>联合索引是指对表上的多个列进行索引。例如：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> test<span class="token punctuation">(</span>    <span class="token number">a</span> <span class="token keyword">INT</span><span class="token punctuation">,</span>    <span class="token number">b</span> <span class="token keyword">INT</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token number">a</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> unioIdx<span class="token punctuation">(</span><span class="token number">a</span><span class="token punctuation">,</span><span class="token number">b</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 联合索引</span><span class="token punctuation">)</span><span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">INNODB</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>联合索引的构造：<br>从本质来说，联合索引也是一颗B+树，但不同的是联合索引的简直的数量不是1，而是大于等于2。</p><p>下面假设给定两个键值的名称，分别为a，b，使用B+树索引，如图：<img src="/posts/47027/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pvbmdfMDkxNQ==,size_16,color_FFFFFF,t_70.png" alt><br>那么数据（1，1）,（1，2）,（2，1）,（2，4）,（1，1）,（3，2）是根据（a，b)的顺序进行存放的，这里直接说结论：</p><ul><li>对于查询<code>select * from table where a=xxx and b=xxx</code>是可以使用联合索引（a，b）的。</li><li>对于单个的a列查询<code>select * from table where a=xxx</code>也可以使用联合索引（a，b）的。</li><li>对于单个b列查询<code>select * from table where b=xxx</code>不可以使用B+树索引。（因为每个数据对的第二个数字单独拿出来的顺序是：1，2，1，4，1，2显然不是排序的）</li></ul><p>那么回过头说联合索引，<strong>联合索引的好处就是对上述情况的第二个键值进行了排序处理。</strong></p><p><strong>覆盖索引</strong><br>覆盖索引即：<strong>从辅助索引中就可以得到查询的记录，而不需要查询聚集索引中的记录。</strong></p><p>其次，我们知道辅助索引不包含整行记录的所有信息，<strong>因此其大小要远小于聚簇索引，因此可以减少大量IO的操作。</strong></p><h3 id="1-4-InnoDB中的哈希算法"><a href="#1-4-InnoDB中的哈希算法" class="headerlink" title="1.4 InnoDB中的哈希算法"></a>1.4 InnoDB中的哈希算法</h3><p>InnoDB存储引擎中：</p><ul><li><strong>使用哈希算法来对字典进行查找。</strong></li><li><strong>哈希的冲突机制（哈希碰撞）使用链表方式解决</strong>。</li><li><strong>哈希函数采用除法散列方式。</strong></li></ul><blockquote><p>对于缓冲池页的哈希表来说，在缓冲池中的Page页都有一个chain指针，它指向相同哈希函数值的页。<br>对于除法散列来说，m（槽数）的取值为略大于2倍的缓冲池页数量的质数。<br>例如：若当前缓冲池大小为10M，则共有640个16KB的页，对于哈希表来说，需要分配640*2=1280个槽，然后离1280最近的质数为1399，那么在启动的时候会分配1399个槽的哈希表，用来哈希查询所在缓冲池中的页。</p></blockquote><p>InnoDB存储引擎的缓冲池对于其中的页是怎么进行查找的？</p><blockquote><p>InnoDB存储引擎的表空间都有一个space_id，用户所要查询的应该是某个表空间的某个连续16KB的页，即偏移量offset。InnoDB存储引擎将space_id左移20位，然后加上这个space_id和offset，即关键字<code>K=space_id&lt;&lt;20+space_id+offset</code>，然后通过除法散列到各个槽中。</p></blockquote><h3 id="1-5-InnoDB全文检索"><a href="#1-5-InnoDB全文检索" class="headerlink" title="1.5 InnoDB全文检索"></a>1.5 InnoDB全文检索</h3><p><strong>全文检索通常使用倒排索引来实现。它在辅助表中存储了单词与单词自身在一个或者多个文档所在位置之间的映射。</strong> 这通常利用关联数组来实现，拥有两种表现形式：</p><ul><li>inverted file index：表现形式为：{单词，单词所在文档的ID}</li><li>full inverted index：表现形式为：{单词，(单词所在文档的ID，在具体文档中的位置)}</li></ul><p>Mysql在1.2.x版本开始，才开始支持全文检索，采用的是<code>full inverted index</code>的方式。</p><blockquote><p>在InnoDB存储引擎中，<strong>将(DocumentId，Position)视为一个ilist</strong>。因此在全文检索的表中，有两个列，一个是word字段，一个是ilist字段，<strong>并且在word字段上有索引。</strong><br>此外，<strong>InnoDB存储引擎在ilist字段中存放了Position信息（存储位置），因此可以进行Proximity Search(近似搜索)</strong>，比如<code>SELECT * from login where username LIKE &#39;%3&#39;;</code></p></blockquote><p><strong>倒排索引需要将word存放在一张表上，这个表叫做Auxiliary Table（辅助表），并且共有6张表，存放于磁盘上。</strong></p><p>InnoDB中的全文索引有俩重要概念：</p><ul><li>FTS Index Cache：全文检索索引缓存。</li></ul><blockquote><p>FTS Index Cache是一个<strong>红黑树结构</strong>，根据（word，ilist）进行排序，<strong>意味着插入的数据已经更新了对应的表。</strong> 同时，在缓存中的word字段要想合并到Auxiliary Table（辅助表，存放word的表）中，这个合并过程类似于前面文章讲的Insert Buffer，<strong>批量插入。</strong><br>当然，当需要进行全文检索的时候，辅助表会先把缓存中的word整合在一起，再从表中查询结果。</p></blockquote><ul><li>FTS Document ID：</li></ul><blockquote><p>为了支持全文检索，必须有一个列和word进行映射，在InnoDB中这个列被命名为FTS_DOC_ID，其类型必须是BIGINT UNSIGNED NOT NULL，并且InnoDB会自动在该列上添加一个名为FTS_DOC_ID_INDEX的唯一索引。</p></blockquote><p>InnoDB存储引擎的全文检索存在的限制：</p><ul><li>每张表只能有一个全文检索的索引。</li><li>由多列组合而成的全文检索的索引列必须使用相同的字符集和排序规则。</li><li>不支持没有单词界定符的语言，如中文、日语。</li></ul><p><strong>全文检索的使用：</strong><br>1.先创建表和插入数据。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> fts_a<span class="token punctuation">(</span>    FTS_DOC_ID <span class="token keyword">BIGINT</span> UNSIGNED <span class="token keyword">AUTO_INCREMENT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    body <span class="token keyword">TEXT</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>FTS_DOC_ID<span class="token punctuation">)</span><span class="token punctuation">)</span>；<span class="token keyword">INSERT</span> <span class="token keyword">into</span> fts_a <span class="token keyword">SELECT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token string">'Pease porridge in the pot'</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">into</span> fts_a <span class="token keyword">SELECT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token string">'Pease porridge hot,pease porridge cold'</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">into</span> fts_a <span class="token keyword">SELECT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token string">'Nine days old'</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">into</span> fts_a <span class="token keyword">SELECT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token string">'Some like it hot, some like it cold'</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">into</span> fts_a <span class="token keyword">SELECT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token string">'Some like it int the pot'</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">into</span> fts_a <span class="token keyword">SELECT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token string">'Nine days old'</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">into</span> fts_a <span class="token keyword">SELECT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token string">'I like code days'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># body字段是进行全文检索的字段，因此创建一个类型为FULLTEXT的索引。</span><span class="token keyword">CREATE</span> FULLTEXT <span class="token keyword">INDEX</span> idx_fts <span class="token keyword">ON</span> fts_a<span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.通过设置参数<code>innodb_ft_aux_table</code>来查看分词对应的信息，注意数据库的名称要对上</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SET</span> <span class="token keyword">GLOBAL</span> innodb_ft_aux_table<span class="token operator">=</span><span class="token string">'test/fts_a'</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> information_schema<span class="token punctuation">.</span>INNODB_FT_INDEX_TABLE<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>部分结果：</p><p><img src="/posts/47027/image-20240513205829440.png" alt></p><p>可以看到每个word都对应了一个DOC_ID和POSITION，并且还记录了这么几个重要的信息：</p><ul><li>FIRST_DOC_ID：该word第一次出现的文档ID。</li><li>LAST_DOC_ID：最后一次出现的文档ID。</li><li>DOC_COUNT：该word在多少个文档中存在。</li></ul><p>3.全文检索的使用：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># 全文检索通过Match函数进行查询，默认采用NATURAL LANGUAGE模式</span><span class="token comment" spellcheck="true"># 代表查询代带有指定word的文档。</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> fts_a <span class="token keyword">WHERE</span> <span class="token keyword">MATCH</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span> AGAINST<span class="token punctuation">(</span><span class="token string">'Porridge'</span> <span class="token operator">IN</span> <span class="token keyword">NATURAL</span> LANGUAGE MODE<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里再来讲一讲全文检索的另一个模式：<strong>Boolean</strong>，<strong>当使用该修饰符的时候，查询字符串的前后字符会有特殊的含义</strong>。例如：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># +代表这个单词必须出现，-代表这个单词一定不存在</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> fts_a <span class="token keyword">WHERE</span> <span class="token keyword">MATCH</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span> AGAINST<span class="token punctuation">(</span><span class="token string">'+Pease -hot'</span> <span class="token operator">IN</span> <span class="token keyword">BOOLEAN</span> MODE<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其余的操作符还有：（只列举几个好记的）</p><table><thead><tr><th>操作符</th><th>含义</th></tr></thead><tbody><tr><td>+</td><td>该word必须存在</td></tr><tr><td>-</td><td>该word必须被排除</td></tr><tr><td>&gt;</td><td>表示出现该单词时增加相关性</td></tr><tr><td>&lt;</td><td>表示出现该单词时降低相关性</td></tr><tr><td>~</td><td>允许出现该单词，但是出现时相关性为负</td></tr><tr><td>*</td><td>表示以该单词开头的单词</td></tr></tbody></table><p>全文检索相关性的计算依据：</p><ul><li>word是否在文档中出现。</li><li>word在文档中出现的次数。</li><li>word在索引列中的数量。</li><li>多少个文档包含该word。</li></ul><p>最后再总结式的讲一下文档中分词的插入和删除操作。</p><p>插入：</p><blockquote><p>在事务提交的时候完成。</p></blockquote><p>删除：</p><blockquote><p>在事务提交的时候，<strong>不删除磁盘中辅助表Auxiliary Table的记录，而是删除FTS Cache Index中的记录，对于辅助表中被删除的记录，InnoDB会记录他的FTS Document ID，并把它保存在一张表中（DELETED Auxiliary Table）中</strong></p></blockquote><p>当然，也可以彻底删除倒排索引中该文档的分词信息：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SET</span> <span class="token keyword">GLOBAL</span> innodb_optimize_fulltext_only<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">OPTIMIZE</span> <span class="token keyword">TABLE</span> fts_a<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="二-锁"><a href="#二-锁" class="headerlink" title="二. 锁"></a>二. 锁</h2><p>InnoDB存储引擎锁的实现提供一致性的非锁定读、行级锁支持，还可以同时得到并发性和一致性。在数据库中，lock和latch都可以被称之为“锁”。</p><ul><li>latch：<strong>轻量级锁，要求锁定的时间必须非常短，目的是保证并发线程操作临界资源的正确性。可以分为<code>mutex（互斥量）</code>和<code>rwlock（读写锁）</code></strong></li><li>lock：<strong>对象：事务，</strong> 锁定的是数据库中的对象，如表、页。</li></ul><p>两者对比表：</p><table><thead><tr><th></th><th>lock</th><th>latch</th></tr></thead><tbody><tr><td>对象</td><td>事务</td><td>线程</td></tr><tr><td>保护</td><td>数据库内容</td><td>内存数据结构</td></tr><tr><td>持续时间</td><td>整个事务过程</td><td>临界资源</td></tr><tr><td>模式</td><td>行锁、表锁、意向锁</td><td>读写锁、互斥量</td></tr><tr><td>死锁</td><td>通过waits-for graph、time out等机制进行死锁检测与处理</td><td>没有死锁检测和处理机制。仅通过应用程序加锁的顺序来保证没有死锁的情况发生。</td></tr><tr><td>存在于</td><td>Lock Manager的哈希表中</td><td>每个数据结构的对象中</td></tr></tbody></table><p>一般也从物理锁和逻辑锁这两种概念来区分。</p><h3 id="2-1-InnoDB存储引擎中的锁"><a href="#2-1-InnoDB存储引擎中的锁" class="headerlink" title="2.1 InnoDB存储引擎中的锁"></a>2.1 InnoDB存储引擎中的锁</h3><h4 id="2-1-1-锁的类型"><a href="#2-1-1-锁的类型" class="headerlink" title="2.1.1 锁的类型"></a>2.1.1 锁的类型</h4><p>InnoDB存储引擎实现了如下两种标准的行级锁：</p><ul><li>共享锁（S Lock），允许事务读一行数据。</li><li>排他锁（X Lock），允许事务删除或者更新一行数据。</li></ul><p>再来说下两个概念，锁的兼容和不兼容。</p><blockquote><p>锁兼容：如果一个事务T1已经获得了行m的S锁，那么事务T2可以立即获得行m的S锁。（因为读取并不会改变行m的数据）<br>锁不兼容：若有其他的事务T3想要获得行m的X锁，那必须等待事务T1和T2释放掉行m上的S锁。</p></blockquote><p>注意：兼容是指对<strong>同一记录</strong>（row）锁的兼容性情况。<br><img src="/posts/47027/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pvbmdfMDkxNQ==,size_16,color_FFFFFF,t_70-1715605242597-5.png" alt></p><p>此外，InnoDB存储引擎还支持多粒度缩影，即允许事务在行级上的锁和表级上的锁同时存在，而为了支持在不同粒度上的加锁操作，InnoDB推出了意向锁，其锁定的对象可以分为多个层次，目前支持两种意向锁：</p><ul><li>意向共享锁（IS Lock）：事务想要获得一张表中某几行的共享锁。</li><li>意向排他锁（IX Lock）：事务想要获得一张表中某几行的排他锁。</li></ul><p>由于InnoDB支持的是行级锁，<strong>因此意向锁并不会堵塞除全表扫描以外的任何请求。</strong> <strong>表级意向锁</strong>和<strong>行级锁</strong>的兼容性如下图：<br><img src="/posts/47027/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pvbmdfMDkxNQ==,size_16,color_FFFFFF,t_70-1715605284972-8.png" alt><br>在InnoDB1.0开始，我们可以通过3张表来监控当前事务并分析可能存在的锁问题。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> information_schema<span class="token punctuation">.</span>INNODB_TRX<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/47027/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pvbmdfMDkxNQ==,size_16,color_FFFFFF,t_70-1715605284972-9.png" alt="表1：INNODB_TRX"></p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> information_schema<span class="token punctuation">.</span>INNODB_LOCKS<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/47027/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pvbmdfMDkxNQ==,size_16,color_FFFFFF,t_70-1715605284972-10.png" alt="表2：INNODB_LOCKS"></p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> information_schema<span class="token punctuation">.</span>INNODB_LOCK_WAITS<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结构：<br><img src="/posts/47027/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pvbmdfMDkxNQ==,size_16,color_FFFFFF,t_70-1715605284972-11.png" alt="表3：INNODB_LOCK_WAITS"></p><h4 id="2-1-2-一致性非读定锁"><a href="#2-1-2-一致性非读定锁" class="headerlink" title="2.1.2 一致性非读定锁"></a>2.1.2 一致性非读定锁</h4><p>一致性非读定锁是指InnoDB存储引擎<strong>通过多版本控制的方式来读取当前执行时间数据库中行的数据。</strong> <strong>作为InnoDB存储引擎的默认读取方式。</strong></p><p>如果读取的行正在执行Delete或者Update操作，那<strong>么这时候读取操作不会因此去等待锁的释放，而是去读取该行的一个快照数据。</strong> 因为不需要等待访问的行上的X锁的释放，也因此叫非读定锁。</p><p>快照数据指的是该行的之前版本的数据（通过undo log来实现），<strong>一行记录可能有多个快照数据，一般称这种技术为行多版本技术，而由此带来的并发控制，称之为多版本并发控制，也就是我们听烂了的MVCC！</strong></p><p>虽然一致性非读定锁作为默认的读取方式，但是在不同的事务隔离级别下，读取方式还是不一样的。事务隔离级别在<strong>重复读</strong>和<strong>读提交</strong>两个级别下，使用的是一致性非读定锁。并且这两个级别下的快照数据定义也不一样：</p><ul><li>Read Committed（读提交）：非一致性读<strong>总是读取被锁定行的最新一份快照数据。</strong></li><li>Repeatable Read（重复读）：<strong>总是读取事务开始时的行数据版本。</strong></li></ul><h4 id="2-1-3-一致性读定锁"><a href="#2-1-3-一致性读定锁" class="headerlink" title="2.1.3 一致性读定锁"></a>2.1.3 一致性读定锁</h4><p>默认配置下，即事务的隔离级别为重复读模式下，InnoDB存储引擎的Select操作使用一致性非锁定读，但是某些情况下，用户需要<strong>显式地对数据库读取操作进行加锁以保证数据逻辑的一致性。</strong> 因此InnoDB存储引擎对于Select语句支持了两种一致性的锁定读操作：</p><ul><li><code>Select ··· For Update</code>：对读取的行记录加一个X锁，则其他事务不能对已经锁定的行加上任何锁。</li><li><code>Select ··· Lock In Share Mode</code>：对读取的行记录加一个S锁，其他事务则只能加S锁，若加X锁，则被堵塞。</li></ul><h4 id="2-1-4-自增长和锁"><a href="#2-1-4-自增长和锁" class="headerlink" title="2.1.4 自增长和锁"></a>2.1.4 自增长和锁</h4><p>在InnoDB存储引擎的内存结构中，<strong>对每个含有自增长值的表都有一个自增长计数器（auto-increment counter）</strong> ，当对含有自增长计数器的表进行插入操作时，这个计数器会被初始化。</p><p>插入操作会依据这个自增长的计数器值来加1进行赋值，这个实现方式叫做AUTO-INC Locking。</p><blockquote><p>其实这是一种特殊的表锁机制，为了提高插入的性能，<strong>锁不是在一个事务完成后才释放的，而是在完成对自增长值插入的SQL语句后立即释放</strong>。</p></blockquote><p>从Mysql5.1.22开始，InnoDB存储引擎提供了一种轻量级互斥量的自增长实现机制，该版本提供了参数<code>innodb_autoinc_lock_mode</code>来控制自增长的模式，默认值为1。</p><p>先来看下自增长的插入类型：<br><img src="/posts/47027/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pvbmdfMDkxNQ==,size_16,color_FFFFFF,t_70-1715605284973-12.png" alt><br>再来看下不同参数下的自增影响：<br><img src="/posts/47027/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pvbmdfMDkxNQ==,size_16,color_FFFFFF,t_70-1715605284973-13.png" alt><br>此外，在InnoDB存储引擎中，<strong>自增长值的列必须是索引，同时也必须是索引的第一个列</strong>。</p><h4 id="2-1-5-外键和锁"><a href="#2-1-5-外键和锁" class="headerlink" title="2.1.5 外键和锁"></a>2.1.5 外键和锁</h4><p><strong>外键主要是用于引用完整性的约束检查。</strong> 并且，如果对于一个外键列，如果没有显式地对这个列加索引，InnoDB会自动对其加一个索引，从而避免表锁。</p><p>对于外键值的插入或者更新操作：</p><blockquote><p>1.首先查询父表中的记录，select。<br>2.select操作通过select xxx lock in share mode的方式。<br>3.即主动对父表加一个S锁。</p></blockquote><p>试想下，为什么外键值的插入或者更新不是使用一致性非锁定读的方式呢？举个例子：（一致性读锁定）<br><img src="/posts/47027/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pvbmdfMDkxNQ==,size_16,color_FFFFFF,t_70-1715605284973-14.png" alt><br>若是一致性非读锁定，那么此时会话B会对父表中id为3的记录，是可以进行插入操作的，但如果A的事务提交，那么对于A来说，id为3的记录是删除的，对于B来说是存在的，那么就出现了不一致的情况。因此需要一致性读锁定。</p><h3 id="2-2-锁的算法"><a href="#2-2-锁的算法" class="headerlink" title="2.2 锁的算法"></a>2.2 锁的算法</h3><p>InnoDB存储引擎共有3种行锁的算法，分别是：</p><ul><li>Record Lock：单个行记录上的锁。</li><li>Gap Lock：间隙锁，锁定一个范围，但不包含记录本身。</li><li>Next-Key Lock：Record Lock+Gap Lock，锁定一个范围，并且锁定记录本身。</li></ul><p>Record Lock<strong>总是会去锁住索引记录</strong>，如果InnoDB存储引擎表在简历的时候没有设置任何一个索引，那么他会<strong>使用隐式的主键来进行锁定。</strong></p><p>Next-Key Lock算法下，例如一个索引有10，11，13，20这4个值，那么这个索引可能被Next-Key Locking的区间为：<br><img src="/posts/47027/20201216104921320.png" alt></p><p>当然，既然有Next-Key Lock，也存在一个<code>Previous-Key Lock</code>。如果采用这种锁定技术，同样的上述索引，可锁定的区间为：<br><img src="/posts/47027/20201216104908758.png" alt></p><p>为什么要采用这个锁技术？其<strong>目的是为了解决Phantom Problem</strong></p><blockquote><p>Phantom Problem即幻像问题，也就是所谓的<strong>幻读</strong>，<strong>是指在同一个事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL语句可能会返回之前不存在的行。</strong><br>举个例子：</p><p><img src="/posts/47027/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pvbmdfMDkxNQ==,size_16,color_FFFFFF,t_70-1715605284973-15.png" alt>)<img src="/posts/47027/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pvbmdfMDkxNQ==,size_16,color_FFFFFF,t_70-1715605284973-16.png" alt><br><strong>可以看到，会话A执行第二次SQL的时候，会把会话B插入的语句返回给结果</strong></p></blockquote><p>那么Next-Key Locking算法怎么避免幻读？</p><blockquote><p>对于上述的SQL语句<code>Select * from t where a &gt; 2 for update;</code> 锁住的不是5这个单个值，而是对(2，+∞)这个范围都加了X锁，因此对于这个范围的任何插入都是不被允许的，从而避免了幻读的产生。</p></blockquote><p>InnoDB存储引擎默认的事务隔离级别是重复读，在该隔离级别下，采用的是Next-Key Lock。<strong>而在事务隔离级别为提交读的情况下，仅仅采用Record Lock。</strong></p><p><strong>注意</strong>：对于唯一键值的锁定，Next-Key Lock会降级为Record Lock，仅存在于查询所有的唯一索引列。</p><h3 id="2-3-锁问题"><a href="#2-3-锁问题" class="headerlink" title="2.3 锁问题"></a>2.3 锁问题</h3><p><strong>1.脏读</strong>：在不同的事务下，当前事务可以读到另外事务未提交的数据。</p><p><img src="/posts/47027/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pvbmdfMDkxNQ==,size_16,color_FFFFFF,t_70-1715605284973-17.png" alt><br><strong>2.不可重复读</strong>：在一个事务内多次读取同一个数据集合，而第二次读取的数据和第一次读取的数据不是一样的。</p><p><img src="/posts/47027/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pvbmdfMDkxNQ==,size_16,color_FFFFFF,t_70-1715605284973-18.png" alt><br>这里需要做一个区分（因为两个例子很像)：</p><ul><li><strong>脏读是读到未提交的数据。</strong></li><li><strong>不可重复读读到的是已经提交的数据。</strong></li></ul><p><strong>3.丢失更新</strong>：<br>丢失更新简单来说就是<strong>一个事务的更新操作会被另一个事务的更新操作所覆盖。</strong> ，从而导致数据的不一致。</p><ol><li>事务T1将记录m更新为n1，但是事务T1没有提交。</li><li>与此同时，事务T2将记录m更新为n2，事务T2没有提交。</li><li>事务T1提交。</li><li>事务T2提交。</li></ol><p>而为了避免这种丢失更新发生，需要让事务在这种情况下的操作变成串行化，而不是并行的操作。对于上述操作，可以给步骤1和2分别加一个X锁，那么事务T2就会进入堵塞。</p><h3 id="2-4-死锁"><a href="#2-4-死锁" class="headerlink" title="2.4 死锁"></a>2.4 死锁</h3><p>死锁是指两个以及以上的事务在执行过程中，<strong>因争夺锁资源而造成的一种互相等待的现象。</strong></p><p>解决死锁的方式：</p><ul><li><strong>time out</strong>：即<strong>超时机制</strong>，当两个事务互相等待时，当一个等待时间超过<code>innodb_lock_wait_timeout</code>设置的某一个阈值时，<strong>其中一个事务进行回滚，另一个等待的事务就能够继续进行。</strong></li></ul><blockquote><p>超时机制的优点：简单。<br>缺点：根据FIFO的顺序选择回滚对象，如果超时的事务所占的权重比较大（比如事务操作更新了很多行），那么此时占用的undo log比较大，若此事进行回滚，那么回滚的时间相比另一个事务所占用的时间可能要多很多。即不合理。</p></blockquote><ul><li><strong>wait-for graph：等待图（InnoDB也采用这种方式）</strong></li></ul><p>wait-for graph要求数据库保存两种信息：</p><ul><li>锁的信息链表。</li><li>事务等待链表。</li></ul><p>其中，wait-for graph中，<strong>事务为图的节点</strong>。并且事务T1指向T2边的定义为：</p><ul><li>事务T1等待事务T2所占用的资源。</li><li>事务T1最终等待T2所占用的资源。也就是事务之间在等待相同的资源，<strong>而事务T1发生在事务T2的后面。</strong></li></ul><p>事务发生死锁的概率与以下几点因素有关：</p><ul><li>系统中事务的数量（n），n越多发生死锁的概率越大。</li><li>每个事务操作的数量（r），r越多发生思索的概率越大。</li><li>操作数据的集合（R)，越小则发生死锁的概率越大。</li></ul><blockquote><p>题外话，<strong>操作系统</strong>发生死锁的条件：</p><ul><li>互斥条件：某一个资源在一段时间内只能由一个进程占有，不能被两个及以上进程占有。</li><li>不可抢占条件：进程所占有的资源在使用完毕之前，不会被其他的资源申请者占有，除非该资源自行释放。</li><li>占有且申请条件：进程至少占有一个资源，但是又申请新的资源。</li><li>循环等待条件：存在一个进程等待序列{P1,P2,…Pn}，P1等待P2的资源，P2等待P3的资源…Pn等待P1的资源。即形成环。</li></ul></blockquote><h3 id="2-5-锁升级"><a href="#2-5-锁升级" class="headerlink" title="2.5 锁升级"></a>2.5 锁升级</h3><p>锁升级是指<strong>将当前锁的粒度降低。</strong> 如把一个表的1000个行锁升级为一个页锁。 <strong>但是InnoDB存储引擎不存在锁升级的问题，因为他并不是根据每个记录来产生行锁的，相反，它是根据每个事务访问的每个页对锁进行管理的，采用的位图的方式。</strong></p><p><strong>因此不管一个事务锁住页中一个记录还是多个记录，其开销都是一致的。</strong></p><h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h2><p>最后总结一些事情：</p><ol><li><strong>首先，InnoDB是一种存储引擎，不是索引，不是索引，不是索引。</strong></li><li>其次，InnoDB存储引擎下，包含两种索引类型，一个是BTREE（就是B+树），一个是HASH。</li><li>4个事务隔离级别：读未提交，读提交，重复读，串行化。</li><li>InnoDB是行级锁：包括<strong>共享锁</strong>和<strong>排他锁</strong>，MyISAM是表级锁。</li><li>3种锁问题：脏读、不可重复读（<strong>切忌不要和事务隔离级别中的重复读搞串了</strong>）、幻读。</li><li>3种锁算法：<code>Record Lock</code>、<code>Gap Lock</code>、<code>Next-Key Lock</code>（<strong>解决幻读</strong>）。</li><li>锁类型：一致性非读定锁（<strong>MVCC</strong>）、一致性读定锁（<strong>悲观锁，for update</strong>）、自增长锁（<strong>特殊的锁机制，锁不是在一个事务完成后才释放的，而是在完成对自增长值插入的SQL语句后立即释放</strong>）、外键锁（插入操作时，对父表进行<code>lock in share mode</code>操作）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;可以说是核心部分了，很多时候我们谈数据库其实大部分时间谈的都是其存储引擎。&lt;/p&gt;
&lt;h2 id=&quot;一-索引算法&quot;&gt;&lt;a href=&quot;#一-
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://JoyTsing.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="读书笔记" scheme="https://JoyTsing.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数据库" scheme="https://JoyTsing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>从百行线程池了解线程池相关技术</title>
    <link href="https://joytsing.github.io/posts/14242/"/>
    <id>https://joytsing.github.io/posts/14242/</id>
    <published>2024-05-06T11:01:25.000Z</published>
    <updated>2024-05-06T12:03:00.174Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在实际编程实践的过程中，一个应用通常由多个线程组成，这些线程通常可以分成两类</p><ol><li>常驻线程：这种线程的生命周期通常和应用的生命周期大致相同，在应用运行的期间，这些线程就一直存在。通常这些线程负责的是应用整个生命周期内，需要不断运行的任务。比如，用于负责整个应用的日志记录的线程、负责通讯的线程、负责<code>UI</code>交互的线程</li><li>非常驻线程：用于执行异步操作任务，该任务的执行周期较短，并且不是周期性的任务，没有必要建立一个常驻线程。比如，进行计算量比较大的任务，比如矩阵分块运算的时候，可以将一个任务拆分给多个线程进行计算，然后在汇总结果从而提高计算速度。此时这些拆分出来的任务，可以为其创建新的线程来进行计算，当计算完成返回计算结果之后，线程销毁</li></ol><p>第<code>2</code>种通过创建一个线程，对异步任务进行计算然后在计算完成返回结果之后再销毁线程。这种设计在硬件资源比较充足或者这种”临时性”的异步需求不是特别频繁的时候，是无需特别在意的，但是如果需要频繁地请求创建任务和销毁任务，那么由此带来的额外开销可能会比执行任务本身的开销更大（比如简单地计算任务），那么这种情况下使用线程池可以缓解这个问题。</p><h2 id="一些关键点"><a href="#一些关键点" class="headerlink" title="一些关键点"></a>一些关键点</h2><p>实现一个线程池通常需要以下几个关键点：</p><ol><li>线程池中的池，即预先创建的若干线程的存储</li><li>线程池中线程的状态管理，即线程未执行异步任务时需要阻塞，执行异步任务的时候需要唤醒。以及识别当前线程中线程处于何种状态（空闲/忙碌）</li><li>通用任务的封装，线程池通常不是为执行单一某种异步任务而设计的，是为了多种异步任务而设计的，此时需要将任务进行封装，从而使得这些任务可以以一种统一的方式传递给线程池，供线程池进行执行</li></ol><p>7.5k star的轻量级<a href="https://github.com/progschj/ThreadPool">线程池</a>，算上头文件代码行数也就100行。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="数据成员"><a href="#数据成员" class="headerlink" title="数据成员"></a>数据成员</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">ThreadPool</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">ThreadPool</span><span class="token punctuation">(</span>size_t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">F</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span>    <span class="token keyword">auto</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>F<span class="token operator">&amp;&amp;</span> f<span class="token punctuation">,</span> Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span>         <span class="token operator">-</span><span class="token operator">></span> std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token keyword">typename</span> std<span class="token operator">::</span>result_of<span class="token operator">&lt;</span><span class="token function">F</span><span class="token punctuation">(</span>Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">></span><span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">ThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">// need to keep track of threads so we can join them</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span> std<span class="token operator">::</span>thread <span class="token operator">></span> workers<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// the task queue</span>    std<span class="token operator">::</span>queue<span class="token operator">&lt;</span> std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> <span class="token operator">></span> tasks<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// synchronization</span>    std<span class="token operator">::</span>mutex queue_mutex<span class="token punctuation">;</span>    std<span class="token operator">::</span>condition_variable condition<span class="token punctuation">;</span>    <span class="token keyword">bool</span> stop<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数据成员其实不算多，仅仅5个</p><ul><li><code>workers</code>：用来存储预先创建（<code>pre-allocate</code>）的线程对象的，是用来保存线程对象的容器</li><li><code>tasks</code>：任务队列（<code>queue</code>），用来存储接受到异步任务的。当有任务需要该线程池来执行时，将任务放入该队列中。线程池中有空闲的线程时，从中唤醒一个空闲的线程，然后从该队列中取出一个任务，将该任务交给该线程来执行</li><li><code>queue_mutex</code>：互斥锁，用来保证任务队列<code>tasks</code>以及控制线程池停止的<code>stop</code>标志位的多线程并发安全的</li><li><code>condition</code>：条件变量，用来实现线程池内的线程的休眠（阻塞）和运行（唤醒）的</li><li><code>stop</code>：用来结束线程池的运行，用来控制线程池停止，线程池内的线程的退出和销毁</li></ul><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p>讨论完线程池的内部数据成员，我们看一下该线程池对象<code>ThreadPool</code>的构造函数的代码实现，代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// the constructor just launches some amount of workers</span><span class="token keyword">inline</span> ThreadPool<span class="token operator">::</span><span class="token function">ThreadPool</span><span class="token punctuation">(</span>size_t threads<span class="token punctuation">)</span>    <span class="token operator">:</span>   <span class="token function">stop</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>threads<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>        workers<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>            <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span>            <span class="token punctuation">{</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> task<span class="token punctuation">;</span>                    <span class="token punctuation">{</span>                        std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>queue_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>condition<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span>                            <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>stop <span class="token operator">||</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>tasks<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>stop <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>tasks<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                            <span class="token keyword">return</span><span class="token punctuation">;</span>                        task <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>tasks<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>tasks<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token function">task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在构造函数处通过for循环创建完指定数量线程，同时在线程内部启动一个工作函数，保证线程安全的同时用来不断消费任务队列里的任务。同时调用线程池类的<code>condition</code>条件变量的<code>wait</code>函数，等待条件变量的满足。如果线程池内存在线程由于任务队列为空时，进入阻塞等待状态时，此时如果有新的任务添加到任务队列，在接受任务的函数内会调用条件变量的通知函数，此时线程池内会有一个线程在此行函数，判定被通知为条件变量满足，退出等待条件变量的阻塞状态，唤醒开始执行该任务。</p><h3 id="异步任务接受函数"><a href="#异步任务接受函数" class="headerlink" title="异步任务接受函数"></a>异步任务接受函数</h3><p>大部分线程池的核心部分，如何添加异步任务，首先我们看一下函数签名</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// add new work item to the pool</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">F</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span><span class="token keyword">auto</span> ThreadPool<span class="token operator">::</span><span class="token function">enqueue</span><span class="token punctuation">(</span>F<span class="token operator">&amp;&amp;</span> f<span class="token punctuation">,</span> Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span>     <span class="token operator">-</span><span class="token operator">></span> std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token keyword">typename</span> std<span class="token operator">::</span>result_of<span class="token operator">&lt;</span><span class="token function">F</span><span class="token punctuation">(</span>Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">using</span> return_type <span class="token operator">=</span> <span class="token keyword">typename</span> std<span class="token operator">::</span>result_of<span class="token operator">&lt;</span><span class="token function">F</span><span class="token punctuation">(</span>Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">::</span>type<span class="token punctuation">;</span>    <span class="token keyword">auto</span> task <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span> std<span class="token operator">::</span>packaged_task<span class="token operator">&lt;</span><span class="token function">return_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> <span class="token operator">></span><span class="token punctuation">(</span>            std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>F<span class="token operator">></span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Args<span class="token operator">></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>future<span class="token operator">&lt;</span>return_type<span class="token operator">></span> res <span class="token operator">=</span> task<span class="token operator">-</span><span class="token operator">></span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span>queue_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// don't allow enqueueing after stopping the pool</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>stop<span class="token punctuation">)</span>            <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"enqueue on stopped ThreadPool"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tasks<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span><span class="token punctuation">[</span>task<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">(</span><span class="token operator">*</span>task<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    condition<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>函数返回值：<code>std::future&lt;typename std::result_of&lt;F(Args...)&gt;::type&gt;</code>，返回一个<code>future</code>类型的对象，该对象可以用于异步任务创建方来获取异步调用结果。</li><li>函数形参：<code>f</code>用于接受携带异步任务的可调用对象，<code>args</code>用来携带执行异步调用需要的函数调用的参数信息。</li></ol><blockquote><p>更推荐用 <code>std::invoke_result_t&lt;F, Args...&gt;&gt;</code>去取代<code>std::result_of&lt;F(Args...)&gt;::type</code></p></blockquote><p>重点在task是怎么被包装的，通过构建一个<code>shared_ptr</code>指针，该指针指向一个<code>packaged_task</code>对象，同时参数通过<code>std::bind()</code>，对可调用对象<code>f</code>进行柯里化，将可调用对象和其执行时需要的函数参数，封装成一个新的可调用对象，这个新的可调用对象进行函数调用的时候，无需进行函数传参。当然使用lambda表达式同样也可以进行绑定（asio中可以减少bind的使用）。</p><p>在这之后通过 <code>task-&gt;get_future()</code>获取异步调用的结果<code>future</code>对象并将这个<code>future</code>返回，同时不要忘记将task入队列，通过lambda包装后统一为<code>void()</code>函数类型。入队列后通知线程去取用，这里需要注意最好要等锁结束后再去通知，不然可能有极小概率出现通知结束后取不到锁的问题。</p><p>上面代码行中涉及到了我们前面讨论到的任务的统一化存储，我们集中梳理讨论一下。先说一下为什么要做任务的统一化存储？通常线程池是用来接受不同的异步操作任务的，每一个异步操作（异步调用）任务，通常是有一个可调用对象来存储的，这些可调用对象的进行函数调用的时候需要的参数和返回值的类型，是有差异的。如果直接对原始的异步操作任务进行存储，由于<code>C++</code>是强类型语言，是不能将有差异的异步操作类型保存到同一个容器中的。所以需要对异步操作任务进行封装，将其封装成统一的任务进行存储。</p><p>首先，通过<code>std::bind</code>对可调用对象进行柯里化，将带参数的可调用对象封装成无参数的可调用对象，从而磨平可调用对象在参数上的差异。这里<code>std::bind</code>通过接受初始可调用对象以及参数，然后根据两者构建出一个新的可调用对象，并将这个新的可调用对象返回完成柯里化操作。最后，通过<code>lambda</code>将<code>packaged_task</code>封装成一个无返回值，无参数的<code>lambda</code>对象，此时该<code>lambda</code>对象将最后一个差异，即返回值的差异，磨平从而可以达到统一存储到一个容器（任务队列）的目的。</p><blockquote><p>为什么这里不将<code>package_task</code>对象直接存储到任务队列中？</p></blockquote><p>这事因为<code>packaged_task</code>对象的类型是一个类模版<code>std::packaged_task&lt;return_type&gt;</code>，其模版实例化之后的类型信息中包含了原始可调用对象的返回值的类型信息。当可调用对象的返回值类型不同的时候，对应的<code>packaged_task</code>的类型信息是不相同的，无法存储到同一个容器中</p><h3 id="析构"><a href="#析构" class="headerlink" title="析构"></a><strong>析构</strong></h3><p>上面已经将线程池运行的时候的主要代码都讨论完毕，下面只剩下一个析构函数的代码实现。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// the destructor joins all threads</span><span class="token keyword">inline</span> ThreadPool<span class="token operator">::</span><span class="token operator">~</span><span class="token function">ThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span>queue_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        stop <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    condition<span class="token punctuation">.</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>std<span class="token operator">::</span>thread <span class="token operator">&amp;</span>worker<span class="token operator">:</span> workers<span class="token punctuation">)</span>        worker<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="思考一个问题"><a href="#思考一个问题" class="headerlink" title="思考一个问题"></a>思考一个问题</h2><p>当调用条件变量的<code>notify_one</code>函数的时候，该操作仅仅会唤醒在该条件变量上处于等待阻塞的其他线程。当其他线程未处于等待阻塞状态的时候，此时此次通知不会传递到该线程。</p><p>比如有一个主线程和两个工作线程，当主线程调用条件变量的<code>notify_one</code>函数的时候，另外两个线程都处于工作状态，即没有阻塞在<code>condition.wait</code>函数上的时候，此时此次对于条件变量的这次<code>notify_once</code>函数的调用将会是无效的，后续这两个线程工作完成之后，重新等待该条件变量满足的时候，这两个线程都会阻塞在<code>wait</code>函数位置。</p><p>如果一瞬间异步调用的任务来的比较密集，造成异步调用队列的任务堆积，即所有的线程都处于工作状态，此时调用<code>ThreadPool</code>的<code>enqueue</code>成员函数将任务入任务队列的时候，此时当所有工作线程处理完当前的异步任务之后是否会处理这个新入队的异步任务？</p><pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span>            <span class="token punctuation">{</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> task<span class="token punctuation">;</span>                    <span class="token punctuation">{</span>                        std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>queue_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>condition<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span>                            <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>stop <span class="token operator">||</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>tasks<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>stop <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>tasks<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                            <span class="token keyword">return</span><span class="token punctuation">;</span>                        task <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>tasks<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>tasks<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token function">task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>问题的关键之处，就在于<code>std::condition_variable::wait</code>这个函数的实现，我们看一下<a href="https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/thread/condition_variable/wait">CPP Reference</a>关于这个函数的相关描述</p><p><img src="/posts/14242/image-20240506195846086.png" alt></p><p>可以看见与这种写法是等价的，注意，也就是其会先判断传入的<code>stop_waiting</code>谓词判别式，当该判别式返回<code>true</code>的时候，意味着不需要在此条件变量上进行等待。此时不会进入<code>while</code>循环，不进行条件变量的<code>wait</code>操作。<code>stop_waiting</code>条件判别式在<code>ThreadPool</code>传入的是，如果当前线程池处于停止状态或者当前异步调用任务队列不为空（还有待执行的异步任务）的时候，该判别式返回<code>true</code>。</p><p>因此当正在工作的工作线程结束当前工作的时候，重新进入下一次<code>for</code>循环的时候，如果此时异步调用队列不为空的时候，不会在条件变量上调用<code>wait</code>函数，此时会继续从异步任务队列中获取任务并对获取到的任务进行处理。</p><h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><pre class="line-numbers language-cpp"><code class="language-cpp"> ThreadPool <span class="token function">pool</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span> std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> results<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        results<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>            pool<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">{</span>                std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>                std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"world "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>                <span class="token keyword">return</span> i<span class="token operator">*</span>i<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;&amp;</span> result<span class="token operator">:</span> results<span class="token punctuation">)</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;在实际编程实践的过程中，一个应用通常由多个线程组成，这些线程通常可以分成两类&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;常驻线程：这种线程的生命周期通常和应
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
      <category term="源码阅读" scheme="https://JoyTsing.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>从示例到源码探究std::ref</title>
    <link href="https://joytsing.github.io/posts/36267/"/>
    <id>https://joytsing.github.io/posts/36267/</id>
    <published>2024-05-06T09:04:18.000Z</published>
    <updated>2024-05-06T11:01:43.277Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>相信大部分人在使用的时候是从多线程那了解的，在启动一个线程的时候如果要执行的函数是一个引用，这时候就需要我们使用<code>std::ref</code>进行包裹，那么究竟是怎么起作用的呢。先看一下官方手册里面的定义是什么。</p><p><img src="/posts/36267/image-20240506170901054.png" alt></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="自定义值传递函数模板"><a href="#自定义值传递函数模板" class="headerlink" title="自定义值传递函数模板"></a>自定义值传递函数模板</h3><p>我们先引入代码，观察并思考如下代码</p><pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Fn<span class="token punctuation">,</span><span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token operator">></span> <span class="token keyword">auto</span> <span class="token function">call_by_value</span><span class="token punctuation">(</span>Fn <span class="token operator">&amp;&amp;</span>fn<span class="token punctuation">,</span>Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>     a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token function">call_by_value</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于模板函数<code>call_by_value</code>是以值传递的方式接受参数的，所以该模板函数在调用的时候，首先会对参数进行一次值拷贝，构造一个临时的实参对象，然后将实参对象传递给<code>func</code>函数。</p><p><code>func</code>函数开始执行的时候，函数形参接受的是外部传入变量的引用，然后在函数内部将这个引用对应的变量赋值为1。由于这里面在外部函数<code>call_by_value</code>函数调用中，参数是以值传递的方式进行实现的。所以<code>func</code>函数内变量<code>a</code>这个引用指向的是<code>call_by_value</code>的函数实参，即临时构造的变量</p><p>所以，经过函数调用，变量并不会被修改。值还是0。所以上述代码运行之后的终端输出如下</p><pre class="line-numbers language-text"><code class="language-text"> 0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在实际的编程实践中，我们使用其他模板函数的时候，有时会遇到该模板函数是通过值的方式对参数进行接受的。但是我们希望希望该模板函数接受的是引用。比如上边的代码中，我们的<code>func</code>代码接受的是引用，目的是在函数内部对变量进行计算更改。比如在使用<code>std::bind</code>进行柯里化函数的时候，待柯里化的函数形参是引用，这个时候就无法进行形参的有效传递。</p><h3 id="bind工具函数模板"><a href="#bind工具函数模板" class="headerlink" title="bind工具函数模板"></a><strong>bind工具函数模板</strong></h3><p>我们在实际的编程实践中，经常需要通过<code>bind</code>进行函数柯里化，比如<code>std::find_if</code>的谓词函数仅仅接受一个参数的函数，如果你的比较函数是二元谓词函数，则需要进行柯里化，示例如下</p><pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">bool</span> <span class="token function">great_than</span><span class="token punctuation">(</span><span class="token keyword">int</span> first<span class="token punctuation">,</span><span class="token keyword">int</span> second<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> first <span class="token operator">></span> second<span class="token punctuation">;</span> <span class="token punctuation">}</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//找到第一个大于3的元素</span> <span class="token keyword">auto</span> it <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find_if</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">cbegin</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">,</span>std<span class="token operator">::</span><span class="token function">cend</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">,</span>std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>great_than<span class="token punctuation">,</span>std<span class="token operator">::</span>placeholders<span class="token operator">::</span>_1<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>考虑如下代码，实现了一个函数<code>func</code>在函数函数的形参是引用类型的，函数的目的是对传递进来的变量进行值的修改，修改成1:</p><pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>     a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">auto</span> wrap_func <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后答案与之前一样，都是0，原因也是因为在函数包装的过程中，将引用类型的参数进行了值的传递导致的，但是<code>bind</code>模板函数略有不同。</p><p>直接进去看函数定义：</p><p><img src="/posts/36267/image-20240506182733520.png" alt></p><p>这个函数模板的签名中用来传递参数的<code>__bound_args</code>是一个转发引用(forwarding reference，在以前的叫法为万能引用，但这种叫法已经过时，在现有的C++标准中叫转发引用)。当我们传递一个变量名的标识符进来的时候，该参数是以引用的形式传递的。没错，在这一层的函数调用中当传递一个函数名的时候，变量是通过左值引用的方式进行传递。</p><p>但是，由于柯里化的需求上面的<code>bind</code>函数需要做的是，将可调用对象<code>__f</code>和参数进行一个收集，构建并且返回另一个可调用对象给调用者，由调用者对这个调用对象进行调用并且传入剩余参数（也可以在调用<code>bind</code>函数进行柯里化的时候一次性将所有参数传递进来，这样在调用得到的可调用对象的时候就不需要传递剩余参数了，但是这样就失去了柯里化的意义）。</p><p>问题关键就是这个可调用对象的构建以及参数收集上，也就是这里面的<code>__bind</code>的对象的构建，下面我们看一下这个对象的构造函数相关代码：</p><p><img src="/posts/36267/image-20240506183107881.png" alt="注意两个成员变量"></p><p><img src="/posts/36267/image-20240506183133123.png" alt="构造函数"></p><p>该函数内部通过<code>__bound_args_</code>成员变量对函数参数的值进行存储，并且是值的方式通过一个元组<code>tuple</code>进行存储的。这会导致当我们使用<code>bind</code>对一个具有引用类型形参的函数进行柯里化的时候，传入的引用类型的形参将会以值传递的形式进行参数收集保存。这与我们想要传递变量的引用，并且在函数内部对该变量进行值的修改的需求不符合。</p><h2 id="std-ref"><a href="#std-ref" class="headerlink" title="std::ref"></a>std::ref</h2><p>当我们需要使用可能上面两种进行值传递的方式进行函数参数转发的进行带引用函数形参的的时候，就不能对直接传递原始的数据了。为了解决这个问题，C++标准库提供了一个帮助函数模板<code>std::ref</code>，相当于打了个补丁。该帮助函数模板通过左值引用类型的形参接受变量，并且将该变量包装成一个另外的类型返回。</p><p><img src="/posts/36267/image-20240506183529734.png" alt></p><p>函数内部构造了一个<code>reference_wrapper</code>类型对象并且将变量的左值引用传入到该类型的构造函数，让该对象持有这个左值引用。</p><p><img src="/posts/36267/image-20240506183700824.png" alt></p><ul><li>首先是指针引用部分<code>_TP* _M_data</code>，用来持有这个被修饰对象的相关信息的。</li><li>构造函数通过<code>addressof(__f)</code>函数取出该变量的地址，将这个地址信息存入成员变量中</li></ul><p>为了保证引用类型在经过函数模板或者类模板中的值传递过程中可以保持引用信息。这里面采用将传入变量包装成另外一个新的对象，在这个新的对象中持有被包装对象的地址信息。</p><p>在函数模板和类模板的值传递过程中，对这个新的对象进行值传递，其内部的被包装的对象地址信息可以得到保存。在函数模板或者内模板内部使用这个新的对象的时候，可以通过重载的类型转换函数将被包装变量的地址信息转换还原成相应的引用，对这个引用进行操作。从而达到操作外部变量的作用。</p><blockquote><p><code>addressof</code>这个函数用来取对象的地址。如果一个类型没有重载取地址操作符&amp;，则使用该函数和使用取地址操作符效果是一致的。如果这个类型重载了取地址操作符（这种情况不常见，但是也有），则想取得对象的内存地址则无法通过取地址操作符，只能通过这个函数。函数库里面使用这个函数是为了可以兼容所有的情况。我们在自己的代码中如果是确认取实际的内存地址信息，也因该使用<code>addressof</code></p></blockquote><h3 id="通过std-ref修改示例代码"><a href="#通过std-ref修改示例代码" class="headerlink" title="通过std::ref修改示例代码"></a><strong>通过std::ref修改示例代码</strong></h3><p>下面我们通过<code>std::ref</code>对上面的代码进行修改，首先是自定义值传递函数模板示例代码的修改:</p><pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Fn<span class="token punctuation">,</span><span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token operator">></span> <span class="token keyword">auto</span> <span class="token function">call_by_value</span><span class="token punctuation">(</span>Fn <span class="token operator">&amp;&amp;</span>fn<span class="token punctuation">,</span>Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>     a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token function">call_by_value</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span>std<span class="token operator">::</span><span class="token function">ref</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码中将第13行中的第2个参数<code>a</code>通过<code>std::ref</code>进行包装传入，代码运行结果如下</p><pre><code>1</code></pre><p>另一个示例代码修改同理，在使用上可以说是非常方便。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;相信大部分人在使用的时候是从多线程那了解的，在启动一个线程的时候如果要执行的函数是一个引用，这时候就需要我们使用&lt;code&gt;std::ref
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>如何在Linux下让grpc与protobuf多版本共存</title>
    <link href="https://joytsing.github.io/posts/9331/"/>
    <id>https://joytsing.github.io/posts/9331/</id>
    <published>2024-05-05T16:00:02.000Z</published>
    <updated>2024-05-06T14:16:07.047Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://joytsing.cn/posts/24753/">前情提要</a>，之前配置了比较低版本的protobuf，当时我就有预感肯定有伏笔，没想到伏笔来得这么快，因为grpc是需要配合protobuf使用的，也就是你单独弄的protobuf和grpc大概率版本是不统一的，这时候你去使用两者都会有问题，并且如果你按照前情提要配置的话大概率会遇到这个问题，其实这个问题只要不在全局配置问题都不大。</p><h2 id="grpc"><a href="#grpc" class="headerlink" title="grpc"></a>grpc</h2><p>安装过程就不必多说了，配置完后为了方便给加到了<code>.zshrc</code>里（不推荐，但是经常使用的话可以加，去掉也简单）。这时候因为protobuf版本冲突会导致有一者无法正常编译（版本出问题）。这时候我选择的是留下grpc而把老的protobuf版本去掉，因为grpc其实里面包含了protobuf,还有很多其他三方库（re2，abseil等等），在使用上可以用grpc里带的protobuf代替。当然，如果像我一样遇到这种问题要给解决，可以尝试一下。</p><p>配置好后的grpc使用：</p><p><img src="/posts/9331/349e76de8ff10715ccdad6dbc227013e.png" alt="方便？下面就有伏笔了"></p><pre class="line-numbers language-cmake"><code class="language-cmake">find_package(Protobuf CONFIG REQUIRED)find_package(gRPC CONFIG REQUIRED)message(STATUS "Using protobuf-${Protobuf_VERSION}")message(STATUS "Using gRPC-${gRPC_VERSION}")set(PROTO_PATH ${PROJECT_SOURCE_DIR}/proto)file(GLOB_RECURSE PROTO_FILES ${PROTO_PATH}/*.cc)file(GLOB_RECURSE all_srcs CONFIGURE_DEPENDS *.cpp)include_directories(${PROTO_PATH})add_executable(main ${all_srcs} ${PROTO_FILES})target_link_libraries(main PUBLIC gRPC::grpc++ protobuf)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/9331/image-20240506002754665.png" alt="猜猜直接找到了配套的老的会怎么样"></p><h2 id="版本冲突"><a href="#版本冲突" class="headerlink" title="版本冲突"></a>版本冲突</h2><p>当版本冲突时候的报错让人头皮发麻：</p><p><img src="/posts/9331/66f2db0ff9599db168f991216770f647.png" alt="头皮发麻"></p><p>如果像下面一样两个都留着的话，按照添加path的递归方式会选择使用grpc的，那么自然老的protobuf就不能够编译，那么如果我想使用前文提到过的直接手动指定行不行？</p><p><img src="/posts/9331/image-20240506001306510.png" alt></p><p>也就是将CMakeLists这样编写手动指定应该就行了吧？</p><pre><code>set(Protobuf_PREFIX_PATH  &quot;/home/joytsing/makeInstall/protobuf3.21.12/include&quot;  &quot;/home/joytsing/makeInstall/protobuf3.21.12/lib&quot;  &quot;/home/joytsing/makeInstall/protobuf3.21.12/bin&quot;)list(APPEND CMAKE_PREFIX_PATH &quot;${Protobuf_PREFIX_PATH}&quot;)find_package(Protobuf 3.21.12 REQUIRED)</code></pre><p>很遗憾，答案是不行，因为在我们全局配置完后，你只要使用<code>target_link_libraries(main PUBLIC protobuf)</code>，那么它默认会使用我们添加在全局PATH里的路径（而且我们已经在全局配置完lib和include，也就是说只需要link就能使用），只有当它在全局路径中找不到的时候它才会使用我们指定的路径，就是这么霸道。也就是说，在link的时候的protobuf都是默认指的grpc的（这取决于你），那么在把留在<code>.zshrc</code>老的<code>protobuf</code>去掉后我们还需要做什么，其实需要做的并不多，只需要稍稍修改就行。</p><p>再提一嘴为什么要把老的protobuf配置给去掉（很重要，不去掉的话一样会报错），因为现在版本有冲突，留着不仅没有用还会造成命名空间污染。所以现在相当于要配置一个安在其他地方的第三方库，仅此而已，稍稍配置就行了（除了库名因为被grpc污染不能使用）。</p><pre class="line-numbers language-cmake"><code class="language-cmake">set(Protobuf_PREFIX_PATH  "/home/joytsing/makeInstall/protobuf3.21.12/include"  "/home/joytsing/makeInstall/protobuf3.21.12/lib"  "/home/joytsing/makeInstall/protobuf3.21.12/bin")list(APPEND CMAKE_PREFIX_PATH "${Protobuf_PREFIX_PATH}")find_package(Protobuf 3.21.12 REQUIRED)include_directories(${Protobuf_INCLUDE_DIRS})include_directories(${PROJECT_SOURCE_DIR}/pb)file(GLOB_RECURSE all_srcs ${PROJECT_SOURCE_DIR}/src/*.cpp ${PROJECT_SOURCE_DIR}/pb/*.cc)add_executable(server ${all_srcs})target_link_libraries(server PUBLIC ${Protobuf_LIBRARIES})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把需要链接的库名protobuf改成对应cmake变量就行，同时加上对应的include，和正常使用三方库没区别（其实就是）。</p><p><img src="/posts/9331/image-20240506002501985.png" alt></p><p>好了，可喜可贺，一些可能有用的文档：</p><p><a href="https://www.jianshu.com/p/ae5c56845896">多个Protobuf版本时让find_package正确选择</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>另外在运行的时候发现一件事情，顺便还把k8s在最后<code>kubeadm init</code>时最后的通信连接不上的问题给解决了。</p><p><img src="/posts/9331/image-20240506221042708.png" alt="无响应"></p><p>因为之前在配置<code>minikube</code>的时候，官方推荐添加<code>NO_PROXY</code>,于是我图方便写了个脚本又给加入了全局环境中</p><p><img src="/posts/9331/image-20240506221343597.png" alt="孩子们，又是我"></p><p>所以现在的情况就是grpc依然走的代理，但是实际上我们把对应的代理地址给关闭了，自然也就连接不上，解决方法很简单，再写个脚本用<code>unset</code>，有同样的情况直接取消代理就行。</p><p><img src="/posts/9331/image-20240506221413586.png" alt="第六行"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://joytsing.cn/posts/24753/&quot;&gt;前情提要&lt;/a&gt;，之前配置了比较低版本的protobu
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://JoyTsing.github.io/categories/Linux/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>西安市植物园与三五壹壹花鸟市场游记</title>
    <link href="https://joytsing.github.io/posts/3181/"/>
    <id>https://joytsing.github.io/posts/3181/</id>
    <published>2024-05-04T09:09:57.000Z</published>
    <updated>2024-05-08T11:47:44.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本来四月初就想去见见郁金香花田的，可惜本人比较懒最后拖到五月初才去。</p><h2 id="Why-is-everyone-in-such-a-rush？"><a href="#Why-is-everyone-in-such-a-rush？" class="headerlink" title="Why is everyone in such a rush？"></a>Why is everyone in such a rush？</h2><p><img src="/posts/3181/16f227f7c2050955tplv-t2oaga2asx-jj-mark3024000q75.png" alt="如何21天学会C++"></p><p>我是我想成为的那个人和别人把我塑造成的那个人之间的裂缝，或半个裂缝，因为还有生活…… 我就是我，没有了，<strong>So Why is everyone in such a rush？</strong></p><h2 id="Hana"><a href="#Hana" class="headerlink" title="Hana"></a>Hana</h2><h3 id="草绣球"><a href="#草绣球" class="headerlink" title="草绣球"></a>草绣球</h3><p><img src="/posts/3181/2ddc4ded71aacf5bedc561d9e7455143_720.jpg" alt="草绣球"></p><ul><li>拉丁学名：<em>Cardiandra moellendorffii</em> (Hance) Migo</li><li>木兰纲山茱萸目绣球科草绣球属草绣球</li><li>别名八仙花，紫阳花あじさい</li><li>花语为“冷酷无情”</li></ul><h3 id="芍药"><a href="#芍药" class="headerlink" title="芍药"></a>芍药</h3><p><img src="/posts/3181/8a832207ca21d2ace2bb84a9da6b2cfe_720.jpg" alt="芍药花1"></p><p><img src="/posts/3181/9d8e4ef4ccbe53f2e41e3cf35f8af289.jpeg" alt="芍药花2"></p><p><img src="/posts/3181/3fc3220edc54ea1104caa0a6be2b5a91_720.png" alt="芍药园里的荷兰芍药"></p><p><img src="/posts/3181/23f99b849c02c3929aaa13fc951fb46c_720.jpg" alt="花店里的鲜切芍药"></p><ul><li>拉丁学名：<em>Paeonia lactiflora</em> Pall</li><li>木兰纲虎耳草目木芍药科芍药属芍药</li><li>别名将离草</li><li>花语为”示爱真心”、”与世无争”、”思念别离”、”美丽动人”</li></ul><h3 id="牡丹花"><a href="#牡丹花" class="headerlink" title="牡丹花"></a>牡丹花</h3><p><img src="/posts/3181/u=2047227644,846415873&fm=253&fmt=auto&app=138&f=JPEG.jpeg" alt="牡丹花"></p><ul><li>拉丁学名：<em>Paeonia × suffruticosa</em> Andrews</li><li>木兰纲虎耳草目木芍药科芍药属牡丹</li><li>别名木芍药、洛阳花</li><li>花语为”雍容华贵”</li></ul><blockquote><p>牡丹与芍药是亲戚，但是芍药是草本植物，牡丹是木本植物，同时牡丹果期花盘开裂，在植物园里面有些花期过了可以看到。芍药的叶子是二回三出羽状复叶。牡丹花的叶片较宽，芍药花的叶片较窄；牡丹花叶色呈现正面绿色反面淡黄色，而芍药花叶色为黑绿色；牡丹花叶片下表面有白粉，芍药花叶片茂密，颜色亮，有蜡质光泽。</p><p><img src="/posts/3181/049cabf359f9508c4d3c12cb2d50be23_720w.webp" alt></p></blockquote><h3 id="洋桔梗"><a href="#洋桔梗" class="headerlink" title="洋桔梗"></a>洋桔梗</h3><p><img src="/posts/3181/9b61a645d0df6ddd26b9ba2f7d9e7b6d_720.jpg" alt="洋桔梗"></p><ul><li>拉丁学名：<em>Eustoma grandiflorum</em>（Raf.）Shinners</li><li>木兰纲菊超目龙胆科洋桔梗属洋桔梗</li><li>别名草原龙胆，丽钵花</li><li>花语为”不变的爱”</li></ul><h3 id="短筒倒挂金钟"><a href="#短筒倒挂金钟" class="headerlink" title="短筒倒挂金钟"></a>短筒倒挂金钟</h3><p><img src="/posts/3181/45c84fb82495c1c6c0b01ccd34e4d2ed_720.jpg" alt="短筒倒挂金钟"></p><ul><li>拉丁学名：Fuchsia magellanica Lam.</li><li>双子叶植物纲桃金娘目柳叶菜科倒挂金钟属短筒倒挂金钟</li><li>别名吊钟海棠、灯笼花</li><li>花语为”相信爱情”、”热烈的心”</li></ul><h3 id="大丽花"><a href="#大丽花" class="headerlink" title="大丽花"></a>大丽花</h3><p><img src="/posts/3181/fc18d9fa4c1e0035088331867f713fe5.png" alt="大丽花"></p><ul><li>拉丁学名：<em>Dahlia pinnata</em> Cav.</li><li>木兰纲菊目菊科大丽花属大丽花</li><li>别名东洋菊、天竺牡丹</li><li>花语为”富贵”、”背叛”</li></ul><h3 id="粉团"><a href="#粉团" class="headerlink" title="粉团"></a>粉团</h3><p><img src="/posts/3181/141d13a7f416fedc50d8a250b6f45812_720.jpg" alt="粉团"></p><ul><li>拉丁学名：<em>Viburnum plicatum</em> Thunb.</li><li>双子叶植物纲茜草木忍冬科荚蒾属粉团</li><li>别名雪球荚蒾</li><li>花语为”团圆美满”</li></ul><h3 id="丹麦风铃草"><a href="#丹麦风铃草" class="headerlink" title="丹麦风铃草"></a>丹麦风铃草</h3><p><img src="/posts/3181/9514b1b43701f862b0511c041986e53c_720.jpg" alt="重瓣丹麦风铃草1"></p><p><img src="/posts/3181/a69b652d7ff452447a851bc0821ead26_720.jpg" alt="重瓣丹麦风铃草2"></p><ul><li>拉丁学名：Campanula x haylodgensis “Plena”</li><li>木兰纲菊目桔梗科风铃草属风铃草</li><li>目前国内无正式名称，是一种引种到我国时间不长的新型观赏花卉</li><li>花语为”温柔优雅”</li></ul><h3 id="蝴蝶兰"><a href="#蝴蝶兰" class="headerlink" title="蝴蝶兰"></a>蝴蝶兰</h3><p><img src="/posts/3181/da8a8a9859aa3e8b4c950844b4db3be6_720.jpg" alt="蝴蝶兰（右方和上方）"></p><ul><li>拉丁学名：<em>Phalaenopsis aphrodite</em> Rchb. f.</li><li>木兰纲天门冬目兰科蝴蝶兰属蝴蝶兰</li><li>别名蝶兰</li><li>花语为”幸福向你飞来”</li></ul><h3 id="长寿花"><a href="#长寿花" class="headerlink" title="长寿花"></a>长寿花</h3><p><img src="/posts/3181/e2e6a761c35d9d3e0cd61d0fb8a291f5_720.jpg" alt="长寿花（模糊版）"></p><ul><li>拉丁学名：<em>Kalanchoe blossfeldiana</em> Poelln.</li><li>木兰纲虎耳草目景天科伽蓝菜属长寿花</li><li>别名寿星花、圣诞长寿花、家乐花</li><li>花语为”健康长寿”</li></ul><h3 id="德国鸢尾"><a href="#德国鸢尾" class="headerlink" title="德国鸢尾"></a>德国鸢尾</h3><p><img src="/posts/3181/fec4baf14efef14d7227aa4a30aadbf6_720.jpg" alt="德国鸢尾（暴雨凋萎版）"></p><ul><li>拉丁学名：<em>Iris germanica</em> L.</li><li>单子叶植物纲百合目鸢尾科鸢尾属德国鸢尾</li><li>别名为爱丽丝、紫蝴蝶、扁竹花</li><li>花语为”<em>绝望的爱</em>“</li></ul><h3 id="络石"><a href="#络石" class="headerlink" title="络石"></a>络石</h3><p><img src="/posts/3181/IMG_6918.jpg" alt="络石1"></p><p><img src="/posts/3181/c1f78d5393f78b23deabdba2a3dae8fd.JPG" alt="络石"></p><ul><li>拉丁学名：<em>Trachelospermum jasminoides</em> (Lindl.) Lem.</li><li>木兰纲龙胆目夹竹桃科络石属络石</li><li>别名风车茉莉(仅指上图)，《本草纲目》记载了络石的名字由来：“以其包络石木而生，故名络石”，是以其生长习性命名的。</li><li>花语为”<em>等待心上人的到来</em>“</li></ul><h3 id="光序翠雀花"><a href="#光序翠雀花" class="headerlink" title="光序翠雀花"></a>光序翠雀花</h3><p><img src="/posts/3181/IMG_6924.jpg" alt="光序翠雀花"></p><ul><li>拉丁学名：<em>Delphinium grandiflorum</em> L.</li><li>木兰纲毛莨目毛莨科翠雀属光序翠雀花</li><li>别名大花飞燕草、鸡爪连</li><li>花语为”倾慕柔顺”</li></ul><h3 id="三色堇"><a href="#三色堇" class="headerlink" title="三色堇"></a>三色堇</h3><p><img src="/posts/3181/IMG_6927.jpg" alt="三色堇"></p><ul><li>拉丁学名：<em>Viola tricolor</em> L.</li><li>木兰纲金虎尾目堇菜科堇菜属三色堇</li><li>别名蝴蝶花、猫儿脸</li><li>花语为”<em>请思念我</em>“</li></ul><h3 id="阿尔泰堇菜"><a href="#阿尔泰堇菜" class="headerlink" title="阿尔泰堇菜"></a>阿尔泰堇菜</h3><p><img src="/posts/3181/2326609c22440490f8b1c7c9fb1b4e3d.jpg" alt="阿尔泰堇菜田与三色堇花团"></p><ul><li>拉丁学名：<em>Viola altaica</em> Ker Gawl.</li><li>木兰纲金虎尾目堇菜科堇菜属阿尔泰堇菜</li></ul><h3 id="大花三色堇"><a href="#大花三色堇" class="headerlink" title="大花三色堇"></a>大花三色堇</h3><p><img src="/posts/3181/155d054a1769c3d3fd35d3b5598d4366.png" alt="大花三色堇"></p><ul><li>拉丁学名：<em>Viola×wittrockiana</em>Gams</li><li>双子叶植物纲侧膜胎座目堇菜科堇菜属大花三色堇</li><li>别名杂种堇菜</li><li>花语为”<em>思虑、思念</em>“</li></ul><h3 id="金叶欧洲山梅花"><a href="#金叶欧洲山梅花" class="headerlink" title="金叶欧洲山梅花"></a>金叶欧洲山梅花</h3><p><img src="/posts/3181/IMG_6932(20240502-012315).JPG" alt="金叶欧洲山梅花"></p><p><img src="/posts/3181/IMG_6941(20240504-200622).JPG" alt="欧洲山梅花模糊版"></p><ul><li>拉丁学名：<em>Philadelphus coronarius</em> ‘Aureus’</li><li>外文名：sweet mock orange</li><li>双子叶植物纲蔷薇目虎耳草科山梅花属欧洲山梅花</li><li>原产欧洲南部及小亚细亚一带</li><li>花语为”自强不息”</li></ul><h3 id="矮牵牛"><a href="#矮牵牛" class="headerlink" title="矮牵牛"></a>矮牵牛</h3><p><img src="/posts/3181/198573cb87359b97ffc83eaf1f08c46f_720.png" alt="矮牵牛"></p><ul><li>拉丁学名：<em>Petunia hybrida</em> (Hook.) E. Vilm.</li><li>木兰纲茄目茄科矮牵牛属碧冬茄</li><li>别名碧冬茄</li><li>花语为”与你同心”</li></ul><h3 id="黄菖蒲"><a href="#黄菖蒲" class="headerlink" title="黄菖蒲"></a>黄菖蒲</h3><p><img src="/posts/3181/%E9%BB%84%E8%8F%96%E8%92%B2.JPG" alt="黄菖蒲"></p><ul><li>拉丁学名：<em>Iris pseudacorus</em> L.</li><li>木兰纲天门冬目鸢尾科鸢尾属黄菖蒲</li><li>别名黄鸢尾</li><li>花语为”<em>信仰者的幸福</em>“</li></ul><h3 id="美丽月见草"><a href="#美丽月见草" class="headerlink" title="美丽月见草"></a>美丽月见草</h3><p><img src="/posts/3181/IMG_6946.jpg" alt="美丽月见草"></p><ul><li>拉丁学名：<em>Oenothera speciosa</em> Nutt.</li><li>双子叶植物纲桃金娘目柳叶菜科月见草属美丽月见草</li><li>别名待霄草、粉晚樱草</li><li>花语为”默默的爱”</li></ul><h3 id="锦带花"><a href="#锦带花" class="headerlink" title="锦带花"></a>锦带花</h3><p><img src="/posts/3181/1587485004691883_694.jpg" alt></p><ul><li>拉丁学名：<em>Weigela florida</em> (Bunge) A. DC.</li><li>木兰纲川续断目忍冬科锦带花属锦带花</li><li>别名五色海棠、海仙花</li><li>花语为”前程似锦”</li></ul><h3 id="溲疏"><a href="#溲疏" class="headerlink" title="溲疏"></a>溲疏</h3><p><img src="/posts/3181/soushu.jpeg" alt></p><ul><li>拉丁学名：<em>Deutzia scabra</em> Thunb.</li><li>木兰纲山茱萸目绣球科溲疏属溲疏</li><li>别名巨骨、空木</li><li>花语为”纯洁美丽”</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;本来四月初就想去见见郁金香花田的，可惜本人比较懒最后拖到五月初才去。&lt;/p&gt;
&lt;h2 id=&quot;Why-is-everyone-in-such
      
    
    </summary>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>MySQL技术内幕-InnoDB存储引擎(二)</title>
    <link href="https://joytsing.github.io/posts/10001/"/>
    <id>https://joytsing.github.io/posts/10001/</id>
    <published>2024-05-03T11:50:40.000Z</published>
    <updated>2024-05-14T13:46:52.750Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://joytsing.cn/posts/9398/">上一篇文章</a>说过，MySQL数据库其实可以看做是一个存放了多个文件的容器，其中的每一种、每一个文件都有着非常重要的作用，那么接下来就先从文件的角度来一一细说，虽然这块部分可能比较枯燥，不过了解下MySQL的日志还是很不错的。（<strong>至少知道各个种类的日志又怎样的作用，又去哪里查看</strong>）</p><h2 id="一、文件"><a href="#一、文件" class="headerlink" title="一、文件"></a>一、文件</h2><h3 id="1-1-参数文件"><a href="#1-1-参数文件" class="headerlink" title="1.1 参数文件"></a>1.1 参数文件</h3><p>我们知道，Mysql实例启动后，会按照一定的顺序在指定的位置进行读取，输入命令：</p><pre class="line-numbers language-sql"><code class="language-sql"> mysql <span class="token comment" spellcheck="true">--help | grep my.cnf</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果如下，意思是按照<code>/etc/my.cnf</code>——&gt;<code>/etc/mysql/my.cnf</code>——&gt; <code>~/.my.cnf</code>的顺序进行读取（<strong>以读取到的最后一个文件为准</strong>）</p><p><img src="/posts/10001/image-20240513200346012.png" alt></p><p>这些配置文件的作用如其名字一样，而具体的参数可以由命令<code>show variables</code>来完成，部分结果如下：</p><p><img src="/posts/10001/image-20240513200550759.png" alt></p><p>Mysql中的参数可以分为两类：</p><ol><li>动态参数：运行在运行时进行更改。</li><li>静态参数：在实例整个生命周期内都不得进行更改。（只读）</li></ol><p>我们可以通过<code>Set</code>命令对动态参数的值进行修改，同时，动态参数还有两个作用范围：</p><ul><li>global：作用于整个实例的生命周期，如binlog_cache_size参数。</li><li>session：作用于当前会话，如autocommit参数。</li></ul><p>使用格式：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">set</span> <span class="token punctuation">[</span><span class="token keyword">global</span> <span class="token operator">|</span> <span class="token keyword">session</span><span class="token punctuation">]</span> name<span class="token operator">=</span><span class="token keyword">value</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>通过<code>set</code>命令修改了任何类型的参数只对当前会话起作用</p></blockquote><h3 id="1-2-日志文件"><a href="#1-2-日志文件" class="headerlink" title="1.2 日志文件"></a>1.2 日志文件</h3><p>Mysql很多功能的实现都离不开日志，而日志文件当然是记录影像Mysql的各类型活动的文件，其中常见的日志包括：</p><ul><li>错误日志（error log）</li><li>二进制日志（binlog）</li><li>慢查询日志（slow query log）</li><li>查询日志（log）：记录所有对Mysql数据库请求的信息，无论这些请求是否得到了正确的执行。</li></ul><h4 id="1-2-1-错误日志"><a href="#1-2-1-错误日志" class="headerlink" title="1.2.1 错误日志"></a>1.2.1 错误日志</h4><p>错误日志主要针对Mysql的启动、运行、关闭过程。虽然名字上说是错误日志，<strong>但是他还记录一些警告或者正确的信息。</strong> 其实错误日志这一块没什么好说的，这里就教大家怎么辨别哪个日志是错误日志，输入命令：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'log_error'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：会显示错误日志对应的存储地址，当大家遇到一些数据库的相关报错问题时，请第一时间来看看错误日志上怎么说，对症下药比较快。</p><p><img src="/posts/10001/image-20240513200832561.png" alt></p><h4 id="1-2-2-慢查询日志"><a href="#1-2-2-慢查询日志" class="headerlink" title="1.2.2 慢查询日志"></a>1.2.2 慢查询日志</h4><p>慢查询日志（slow log）主要是用来定位可能存在问题的sql语句，从而进行SQL语句层面的优化。使用过程：</p><ol><li>在Mysql启动的时候设置一个阈值：<code>long_query_time</code>，默认值是10秒，但是默认不启动。</li><li><strong>那么运行时间超过该值的所有SQL语句都会记录到慢查询日志当中。</strong></li></ol><p>这里先把慢查询的3个最重要的参数放出来：</p><ul><li><code>slow_query_log</code>：慢查询开启状态。</li><li><code>slow_query_log_file</code>：慢查询日志存放的位置。</li><li><code>long_query_time</code>：慢查询的阈值。</li></ul><h5 id="慢查询测试："><a href="#慢查询测试：" class="headerlink" title="慢查询测试："></a>慢查询测试：</h5><p>1.执行命令（或者修改my.cnf文件，靠谱点）</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">set</span> <span class="token keyword">global</span> slow_query_log<span class="token operator">=</span><span class="token string">'ON'</span><span class="token punctuation">;</span> <span class="token keyword">set</span> <span class="token keyword">global</span> long_query_time<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">select</span> sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/posts/10001/image-20240513201339355.png" alt></p><p>此外，和慢查询相关的参数还有：</p><ul><li><code>log_queries_not_using_indexes</code>：如果运行的SQL语句没有使用索引，那么Mysql同样会把这条语句记录到慢查询日志文件中，打开此参数可以关闭该功能。</li><li><code>log_throttle_queries_not_using_indexes</code>：表示每分钟允许记录到慢查询日志的且没有使用索引的SQL语句次数（默认是10，表示无限制）</li><li><code>log_output</code>：指定慢查询输出的格式，默认是FILE（文件），可以将它设置为TABLE，然后即可查询mysql库中的slow_log表了。</li></ul><h4 id="1-2-3-二进制日志☆"><a href="#1-2-3-二进制日志☆" class="headerlink" title="1.2.3 二进制日志☆"></a>1.2.3 二进制日志☆</h4><p>二进制日志记录了对Mysql执行更改的所有操作，<strong>不包括select、show等不影响数据的操作。</strong> 二进制日志的作用有：</p><ol><li>恢复：某些数据的恢复需要二进制日志。</li><li>复制：一般用于主从复制。</li><li>审计：用户通过二进制日志的信息来进行审计，判断是否有对数据库进行SQL注入。</li></ol><p>查看二进制文件的存放目录：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'datadir'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/10001/image-20240513201503906.png" alt></p><p>二进制文件的格式为：（后面为标志性的二进制日志序列号）</p><p><img src="/posts/10001/image-20240513201704273.png" alt></p><p>接下来说一下和二进制日志有关的几个重要参数：</p><ul><li><code>max_binlog_size</code>：<strong>指定单个二进制日志文件的最大值</strong>，若超过该值，则产生新的二进制文件，后缀名+1。</li><li><code>binlog_cache_size</code>☆：<ul><li>1.使用InnoDB存储引擎时，<strong>所有未提交的（uncommitted）的二进制日志会被记录到一个缓存中，等到该事务提交的时候直接将缓冲中的二进制日志写入到二进制文件中。</strong> 而binlog_cache_size则控制了这个缓存的大小，默认32K。</li><li>2.此外，<strong>binlog_cache_size基于会话（session），即当一个线程开始一个事务时，Mysql会自动分配一个大小为binlog_cache_size的缓存。</strong></li><li>3.当一个事务的记录大小大于阈值的话，会把缓冲的日志写入到一个临时文件中。<strong>（即这个值不能太小）建议使用<code>show global status like &#39;binlog_cache%&#39;;</code>来判断当前的binlog_cache_size是否合适，</strong></li></ul></li></ul><p><img src="/posts/10001/image-20240513202154335.png" alt></p><ul><li><p><code>sync_binlog</code>：参数sync_binlog=【N】表示每写缓冲多少次就同步到磁盘，若该值为1，则<strong>代表采用同步写磁盘的方式来写二进制日志。</strong></p></li><li><p><code>binlog_do_db</code>：表示需要写入xxx库中的日志，<strong>默认为空，表示需要同步所有库的日志到二进制日志文件中。</strong></p></li><li><p><code>binlog_ignore_db</code>：表示需要忽略xxx库中的日志。</p></li><li><p><code>log_slave_update</code>：该参数一般用于主从架构。<strong>如果当前数据库是复制中的从节点</strong>，则他不会将从主节点中取得并且执行的二进制日志写入到自己的二进制日志中，若需要写入，则需要开启该参数。</p></li><li><p><code>binlog_format</code>☆</p><ul><li><strong>STATEMENT</strong>：若设置为该值，则二进制日志文件<strong>记录的是日志的逻辑SQL语句。</strong></li><li><strong>ROW</strong>：二进制日志文件<strong>记录的是表的行更改情况。</strong> （这种模式下，将事务隔离级别设置为Read Committed会获得更好的并发性）</li><li><strong>MIXED：Mysql</strong>默认采用STATEMENT格式进行二进制日志文件的记录，但是在以下几个情况下会转成ROW模式：</li></ul><blockquote><p>1.表的存储引擎为InnoDB，这时候对表的DML操作都会以ROW格式记录。<br>2.使用了UUID()，USER()，CURRENT_USER()，FOUND_ROWS()，ROW_COUNT()等不确定函数。<br>3.使用了insert delay语句。<br>4.使用了用户定义函数（UDF）。<br>5.使用了临时表。</p></blockquote></li></ul><p>二进制文件的查看必须使用Mysql提供的mysqlbinlog工具来查看，例如：对于STATEMENT格式的二进制日志文件，在使用mysqlbinlog后，看到的就是执行的逻辑SQL语句。</p><h3 id="1-3-其他类型文件（了解）"><a href="#1-3-其他类型文件（了解）" class="headerlink" title="1.3 其他类型文件（了解）"></a>1.3 其他类型文件（了解）</h3><p><strong>套接字文件</strong><br>在UNIX系统下本地连接Mysql可以采用UNIX域套接字方式，而这种方式则需要一个套接字文件（socket），名为mysql.socket。</p><p><strong>pid文件</strong><br>当Mysql实例启动的时候，会将自己的进程Id写入一个文件中，而这个文件就是pid文件。该参数由参数pid_file控制，默认位于数据库目录下。</p><p><strong>表结构定义文件</strong><br>Mysql数据的存储是根据表进行的，<strong>每个表都有一个与之对应的文件，无论使用哪一种存储引擎，Mysql都有一个以frm为后缀名的文件，该文件记录该表的表结构定义。</strong></p><h2 id="二-InnoDB存储引擎文件☆"><a href="#二-InnoDB存储引擎文件☆" class="headerlink" title="二.InnoDB存储引擎文件☆"></a>二.InnoDB存储引擎文件☆</h2><p>上面介绍的文件都是Mysql数据库本身的文件，和我们的存储引擎无关。那么存储引擎也有属于自己的独特文件。</p><h3 id="2-1-表空间文件"><a href="#2-1-表空间文件" class="headerlink" title="2.1 表空间文件"></a>2.1 表空间文件</h3><p>InnoDB采用<strong>将存储的数据按照表空间（tablespace）进行存放的设计。</strong> 在默认配置下会<strong>有一个初始大小为10MB、名为ibdata1的文件，该文件就是默认的表空间文件。</strong></p><p><img src="/posts/10001/image-20240513203106904.png" alt></p><p>此外，用户可以通过参数<code>innodb_data_file_path</code>对表空间路径进行设置，举例如下：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># 这里将/db/ibdata1和/db/ibdata2两个文件一起来组成表空间。（若俩文件在不同磁盘上，还可以做到负载均衡）</span><span class="token comment" spellcheck="true"># 两个文件后跟的属性含义：100M，代表ibdata1的大小为100M。</span><span class="token comment" spellcheck="true"># 200M:autoextend代表超过200MB时，这个文件的大小可以自动增长。</span>innodb_data_file_path <span class="token operator">=</span><span class="token operator">/</span><span class="token number">db</span><span class="token operator">/</span>ibdata1:100M<span class="token punctuation">;</span><span class="token operator">/</span><span class="token number">db</span><span class="token operator">/</span>ibdata2:200M:autoextend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>若设置了<code>innodb_data_file_path</code>参数，<strong>那么所有基于InnoDB存储引擎的表中的数据都会记录到该共享表空间中。</strong> 此外，若设置了参数<code>innodb_file_per_table</code>，用户可以将每个基于InnoDB的表都产生一个独立的表空间，命名规则为：<code>表名.ibd</code>（注意：<strong>这些单独的表空间文件仅存储该表的数据、索引、插入缓冲BitMap等信息，而其余的信息还是存放在默认的表空间中</strong>）</p><h3 id="2-2-重做日志文件☆"><a href="#2-2-重做日志文件☆" class="headerlink" title="2.2 重做日志文件☆"></a>2.2 重做日志文件☆</h3><p>默认情况下，每个InnoDB存储引擎至少有一个重做日志文件组（group），每个文件组下至少有2个重做日志文件。如默认的ib_logfile0和ib_logfile1。</p><p>重做日志也称为redo log，用来保证事务的原子性和持久性，重做日志中还包含着一种日志，叫undo log，也就是回滚日志，用来帮助事务回滚以及MVCC的功能。</p><h4 id="2-2-1-重做日志块（log-block）"><a href="#2-2-1-重做日志块（log-block）" class="headerlink" title="2.2.1 重做日志块（log block）"></a>2.2.1 重做日志块（log block）</h4><p>InnoDB存储引擎中，重做日志都是以512个字节进行存储的，<strong>也就意味着重做日志缓存、重做日志文件都是以块（block）的方式进行保存的，称之为重做日志块。</strong></p><p>一个块有512个字节这么大，其结构除了日志本身外，还包括：</p><ul><li>日志块头（log block header）12字节</li><li>日志块尾（log block tailer）8字节</li></ul><p><img src="/posts/10001/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pvbmdfMDkxNQ==,size_16,color_FFFFFF,t_70.png" alt></p><h4 id="2-2-2-重做日志组（log-group）"><a href="#2-2-2-重做日志组（log-group）" class="headerlink" title="2.2.2 重做日志组（log group）"></a>2.2.2 重做日志组（log group）</h4><p>log group为重做日志组，包含多个重做日志文件。<strong>每个log group中的日志文件大小是相同的</strong>。而每个重做日志文件中存储的就是上面的log block块，因此也是根据块的方式进行物理存储的管理。<strong>在InnoDB存储引擎运行过程中，log buffer会根据一定的规则将内存中的block刷新到磁盘</strong>，规则如下：</p><ol><li>事务提交时。</li><li>当log buffer有一半的内存空间已经被使用时。</li><li>log Checkpoint时。</li></ol><p><strong>仅仅对于一个重做日志组的第一个重做日志文件（其他部分不保存）</strong>，它前2KB的部分会保存4个512字节的block，保存信息如下：</p><p><img src="/posts/10001/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pvbmdfMDkxNQ==,size_16,color_FFFFFF,t_70-1715603673922-3.png" alt>log group和redo log file之间的关系如下：<br><img src="/posts/10001/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pvbmdfMDkxNQ==,size_16,color_FFFFFF,t_70-1715603679083-6.png" alt></p><h4 id="2-2-3-重做日志格式和LSN"><a href="#2-2-3-重做日志格式和LSN" class="headerlink" title="2.2.3 重做日志格式和LSN"></a>2.2.3 重做日志格式和LSN</h4><p>重做日志格式：<br><img src="/posts/10001/20201212130116665.png" alt></p><ul><li>redo_log_type：重做日志的类型。</li><li>space：表空间Id。</li><li>page_no：页的偏移量。（InnoDB的存储管理是基于页的，因此重做日志格式也是基于页的）</li></ul><p>LSN（Log Sequence Number），<strong>代表日志序列号</strong>，占用8字节，单调递增，其表示的含义有：</p><ul><li>重做日志写入的总量。</li><li><strong>Checkpoint的位置</strong>。</li><li>页的版本。</li></ul><p>我们可以通过命令来查看LSN的情况：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SHOW</span> <span class="token keyword">ENGINE</span> <span class="token keyword">INNODB</span> <span class="token keyword">STATUS</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>部分结果：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">---</span>LOG<span class="token comment" spellcheck="true">---</span><span class="token comment" spellcheck="true"># 表示当前的LSN</span>Log sequence number <span class="token number">4732508</span><span class="token comment" spellcheck="true"># 表示刷新到重做日志文件的LSN</span>Log flushed up <span class="token keyword">to</span>   <span class="token number">4732508</span><span class="token comment" spellcheck="true"># 在生产环境中，这3个值一般是不同的，因为一个事务中从日志缓冲刷新到重做日志文件并不是只是在事务提交的时候发生。</span><span class="token comment" spellcheck="true"># 因为比如master线程，每秒都会有从日志缓冲刷新到重做日志文件的动作发生。</span>Pages flushed up <span class="token keyword">to</span> <span class="token number">4732508</span><span class="token comment" spellcheck="true"># 表示刷新到磁盘的LSN</span><span class="token keyword">Last</span> <span class="token keyword">checkpoint</span> at  <span class="token number">4732499</span><span class="token number">0</span> pending log flushes<span class="token punctuation">,</span> <span class="token number">0</span> pending chkp writes<span class="token number">15</span> log i<span class="token operator">/</span>o<span class="token string">'s done, 0.00 log i/o'</span>s<span class="token operator">/</span>second<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-4-redo"><a href="#2-2-4-redo" class="headerlink" title="2.2.4 redo"></a>2.2.4 redo</h4><p><strong>重做日志用来实现事务的持久性</strong>，由两个部分组成：</p><ul><li>内存中的重做日志缓冲（redo log buffer）</li><li>重做日志文件（redo log file）</li></ul><p>redo log基本上是<strong>顺序写</strong>的，在数据库运行时不需要对redo log的文件进行读取操作，使用InnoDB存储引擎的时候，<strong>当事务提交的时候，必须将该事务的所有日志写入到重做日志文件中进行持久化</strong>，等待事务的Commit操作完成。而为了保证每次日志都写入重做日志文件中，在每次将重做日志缓冲写入重做日志文件后，InnoDB都需要调用一次fsync操作。</p><blockquote><p>fsync操作可以理解为：将日志持久化到磁盘上</p></blockquote><p>此外，mysql还提供一个参数<code>innodb_flush_log_at_trx_commit</code>用来控制重做日志刷新到磁盘的策略，有3个值：</p><ul><li>0：<strong>表示事务提交的时候不进行写入重做日志操作，而写入日志操作交给master线程来完成</strong>，主线程每1秒会进行一次重做日志文件的fsync操作。</li><li>1：表示<strong>事务提交时必须调用一次fsync操作</strong>。（性能相比其他两个要低，因为fsync操作次数多，但是保证事务的持久性）</li><li>2：事务提交时将重做日志写入重做日志文件中，<strong>但是仅写入文件系统的缓存中，不进行fsync操作</strong>。</li></ul><p>讲到这里，先对redo log和binlog进行一个比较。</p><table><thead><tr><th>比较层面</th><th>redo log</th><th>binlog</th></tr></thead><tbody><tr><td>作用层面</td><td>InnoDB存储引擎层面</td><td>Mysql数据库层</td></tr><tr><td>记录的内容形式</td><td><strong>物理格式日志</strong>：记录的是对于每个页的修改</td><td><strong>逻辑日志</strong>：记录的是对应的SQL语句</td></tr><tr><td>写入磁盘的时间点</td><td>在事务进行中不断被写入</td><td>只在事务提交完成后进行一次写入</td></tr><tr><td>对应关系</td><td>一个事务可以对应多个日志条目</td><td>对于每一个事务，仅对应事务的一个日志</td></tr></tbody></table><p>那么redo是怎么进行恢复的呢？<br>InnoDB存储引擎在启动的时候，<strong>不管上次数据库运行时是否正常关闭，都会尝试进行恢复操作。</strong> 而进行恢复的过程，离不开Checkpoint的发挥。</p><p><strong>由于Checkpoint表示已经刷新到磁盘页上的LSN，因此在恢复过程中只需要恢复Checkpoint开始的日志部分。</strong></p><p><img src="/posts/10001/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pvbmdfMDkxNQ==,size_16,color_FFFFFF,t_70-1715603826650-11.png" alt></p><h4 id="2-2-5-undo"><a href="#2-2-5-undo" class="headerlink" title="2.2.5 undo"></a>2.2.5 undo</h4><p>当事务需要进行回滚的时候，这时就需要用到undo log了（保证原子性）。undo存放在数据库内部的一个特殊段：Segment中。其位于共享表空间内。此外，undo log还用于MVCC的实现，<strong>当用户读取一行记录的时候，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取。</strong></p><p><strong>此外，undo log也会产生redo log，因为undo log也需要持久性的保护。</strong></p><h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h2><p>问题1：为什么要讲重做日志块和日志组？</p><blockquote><p>1.首先我们知道，<strong>InnoDB事务在进行提交之前，会先写到日志缓冲，在持久化到磁盘上</strong>，而这个<strong>日志缓冲也就是所谓的redo log buffer</strong>。<br>2.其次，<strong>redo log buffer像一个数组，由多个重做日志块组成</strong>，而重做日志文件也可以看成多个块构成，因此这个块的重要性可想而知。<br>3.第三点，谈到日志组，是想牵引出Checkpoint的概念。重点是什么？<strong>每个组的第一个文件的前4个重组块会包含两个Checkpoint</strong>，而这个Checkpoint会在数据恢复的时候使用到。</p></blockquote><p>问题2：知道LSN这个概念有用吗？</p><blockquote><p>1.首先，恕我无知，我一开始并没听说过这个东西。<br>2.第二，这个LSN和redo log息息相关。<strong>由于Checkpoint表示已经刷新到磁盘页上的LSN，因此在恢复过程中只需要恢复Checkpoint开始的日志部分。</strong> 而这个LSN就是所谓的日志序列。</p></blockquote><p>问题3：综上所述，redolog是干啥的？</p><blockquote><p>1.首先，<strong>redolog可以用来实现事务的持久性</strong>。redolog包含俩部分：<br>—-第一部分：redo log buffer：我们事务提交之前，先把数据写到这。（该部分易丢失）<br>—-第二部分： redo log file：我们事务提交后或者其他情况下，会把buffer中的内容持久化到文件中。（该部分是持久的，即安全），也因此redo log文件<strong>属于物理格式日志。</strong><br>2.<strong>我们数据库实例启动的时候，都会根据redo log去尝试进行数据恢复。</strong></p></blockquote><p>问题4：undolog又有啥用？</p><blockquote><p>1.首先，undolog用来回滚以及确保MVCC的实现。<br>2.<strong>其次undolog的原理就是生成对应SQL的逆向操作语句，在进行回滚的时候，执行对应的逆向SQL，达到正反消除即回滚的一个效果。</strong></p></blockquote><p>问题5：讲这么多种类型的文件有什么用？</p><blockquote><p>1.如错误日志：文章里告诉你怎么去寻找错误日志存储在哪，什么时候需要去看。（当然是报错的时候🤣🤣）<br>2.慢查询日志：用来干啥？优化SQL。<br>3.二进制日志：用来主从复制、数据恢复（使用mysqlbinlog工具进行恢复）。<br>4.redolog：这个日志一定要和二进制文件搞清楚，<strong>二进制文件是基于Mysql层面的，作用于所有的存储引擎，而redolog是基于InnoDB引擎层面的。</strong> 事务是InnoDB的特性对吧？那么其特性需要什么来实现？需要redolog来保证持久性，用它来记录事务对数据页进行了哪些更改。</p></blockquote><p>最后啰嗦一句，当面试问到你或者你自己想到Mysql事务是如何实现的时候，一定要想起来redolog和undolog。<strong>因为事务的持久性和原子性就是通过他们去实现的。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://joytsing.cn/posts/9398/&quot;&gt;上一篇文章&lt;/a&gt;说过，MySQL数据库其实可以看做是一
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://JoyTsing.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="读书笔记" scheme="https://JoyTsing.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数据库" scheme="https://JoyTsing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL实战45讲</title>
    <link href="https://joytsing.github.io/posts/44885/"/>
    <id>https://joytsing.github.io/posts/44885/</id>
    <published>2024-04-29T08:00:58.000Z</published>
    <updated>2024-05-10T07:58:12.447Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>数据库是系统的核心，如果它缓慢那么所有的业务都会受它影响，一个系统的性能很少能超过核心数据库的性能上限。</p><h2 id="01-基础架构：-一条SQL查询语句是如何执行的"><a href="#01-基础架构：-一条SQL查询语句是如何执行的" class="headerlink" title="01 | 基础架构： 一条SQL查询语句是如何执行的 ?"></a><strong>01 | 基础架构：</strong> <strong>一条SQL查询语句是如何执行的 ?</strong></h2><p>MySQL基本架构示意图：</p><p><img src="/posts/44885/image-20240421185512876.png" alt></p><p>MySQL可以分为Server层和存储引擎层两部分。</p><ul><li>Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</li><li>存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。</li></ul><p><strong>连接器</strong></p><p>第一步，会先连接到这个数据库上， 这时候接待你的就是连接器。 连接器负责跟客户端建立连接、 获取权限、 维持和管理连接。</p><blockquote><p><strong>长连接</strong></p></blockquote><p>数据库中<strong>长连接</strong>是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p><p>问题：MySQL在执行过程中临时使用的内存是管理在连接对象里面的，可能导致MySQL占用内存涨得特别快。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是MySQL异常重启了。</p><p>解决方法：</p><ol><li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li><li>MySQL 5.7及以上，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li></ol><p><strong>查询缓存</strong></p><p>MySQL拿到一个查询请求后， 会先到查询缓存看看， 之前是不是执行过这条语句。 之前执行过的语句及其结果可能会以key-value对的形式， 被直接缓存在内存中。 key是查询的语句， value是查询的结果。 如果你的查询能够直接在这个缓存中找到key， 那么这个value就会被直接返回给客户端。</p><p>查询缓存往往弊大于利 ，大多数时候建议不要使用。</p><p>原因：查询缓存的失效频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。</p><p><strong>分析器</strong></p><p>如果没有命中查询缓存， 就要开始真正执行语句了。 分析器先会做“词法分析”。 你输入的是由多个字符串和空格组成的一条SQL语句， MySQL需要识别出里面的字符串分别是什么， 代表什么 。做完了这些识别以后， 就要做“语法分析”。 根据词法分析的结果， 语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。</p><p><strong>优化器</strong></p><p>在开始执行之前， 还要先经过优化器的处理。优化器是在表里面有多个索引的时候， 决定使用哪个索引； 或者在一个语句有多表关联（join）的时候， 决定各个表的连接顺序。</p><p><strong>执行器</strong></p><p>开始执行的时候， 要先判断一下你对这个表T有没有执行查询的权限 。如果有权限， 就打开表继续执行。 打开表的时候， 执行器就会根据表的引擎定义， 去使用这个引擎提供的接口。</p><h2 id="02-日志系统：-一条SQL更新语句是如何执行的？"><a href="#02-日志系统：-一条SQL更新语句是如何执行的？" class="headerlink" title="02 | 日志系统： 一条SQL更新语句是如何执行的？"></a><strong>02 | 日志系统：</strong> <strong>一条SQL更新语句是如何执行的？</strong></h2><p>与查询流程不一样的是， 更新流程还涉及两个重要的日志模块： redo log（重做日志） 和 binlog（归档日志）。 当有一条记录需要更新的时候， InnoDB引擎就会先把记录写到redo log里面， 并更新内存， 这个时候更新就算完成了。然后Server层更新binlog,刷到磁盘。 同时， InnoDB引擎会在适当的时候， 将这个操作记录更新到磁盘里面。</p><p><strong>Redo log</strong></p><p>文中举了《孔乙己》粉板和账本配合的故事，即对应MySQL中的WAL技术，WAL的全称是Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。</p><p>具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。</p><p>这里来介绍下redo log：</p><p>InnoDB的redo log是固定大小的， 比如可以配置为一组4个文件， 每个文件的大小是1GB， 那么这块“粉板”总共就可以记录4GB的操作。 从头开始写， 写到末尾就又回到开头循环写， 如下面这个图所示。</p><p><img src="/posts/44885/image-20240421190252047.png" alt></p><p>write pos是当前记录的位置， 一边写一边后移， 写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置， 也是往后推移并且循环的， 擦除记录前要把记录更新到数据文件。write pos和checkpoint之间的是“粉板”上还空着的部分， 可以用来记录新的操作。 如果write pos追上checkpoint， 表示“粉板”满了， 这时候不能再执行新的更新， 得停下来先擦掉一些记录， 把checkpoint推进一下。</p><blockquote><p><strong>补充</strong></p></blockquote><p>redo log其实是由两部分组成的，一部分是重做日志缓冲（redo log buffer），这部分是确实存在于内存中的；而另一部分则是重做日志文件（redo log file），这部分是存储在磁盘中的。当事务提交后，所有修改的信息会先存到内存中的重做日志缓冲，然后再被写入到磁盘的重做日志文件中。所以，我们不能简单地说redo log是在内存还是在磁盘，它其实是同时在内存和磁盘中都有存在的部分</p><p><strong>Binlog</strong></p><p>另外一个日志就是Binlog啦，先看看和redo log有啥差异。</p><p><strong>思考</strong>：为啥要有这个binlog日志呢，我认为是用于备份用的，即主从备份，分布式raft那一套。而redo log是用于优化效率用的。</p><p>有以下三点不同</p><ol><li>redo log是InnoDB引擎特有的； binlog是MySQL的Server层实现的， 所有引擎都可以使用。</li><li>redo log是物理日志， 记录的是“在某个数据页上做了什么修改”； binlog是逻辑日志， 记录的是这个语句的原始逻辑， 比如“给ID=2这一行的c字段加1 ”。</li><li>redo log是循环写的， 空间固定会用完； binlog是可以追加写入的。 “追加写”是指binlog文件写到一定大小后会切换到下一个， 并不会覆盖以前的日志。</li></ol><p>接下来，看看下面这条update SQL的执行流程</p><pre><code>update T set c=c+1 where ID=2;</code></pre><p>执行流程图</p><p><img src="/posts/44885/image-20240421191135808.png" alt></p><p>解释：</p><ol><li>执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li><li>执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的binlog，并把binlog写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。</li></ol><p><strong>两阶段提交</strong></p><p>这个两阶段提交在分布式也极为常见的概念，2阶段提交的<strong>2阶段</strong>分别是<strong>提交请求阶段</strong>和<strong>提交执行阶段</strong>。</p><p><strong>怎样让数据库恢复到半个月内任意一秒的状态？</strong></p><ul><li>首先，找到最近的一次全量备份，从这个备份恢复到临时库。</li><li>然后，从备份的时间点开始，将备份的binlog依次取出来，重放到误删表之前的那个时刻。</li></ul><p><strong>为什么需要2阶段提交呢？</strong></p><p>这里通过反证明法说明。</p><p>由于redo log和binlog是两个独立的逻辑， 如果不用两阶段提交， 要么就是先写完redo log再写binlog， 或者采用反过来的顺序。仍然用前面的update语句来做例子。 假设当前ID=2的行， 字段c的值是0， 再假设执行update语句过程中在写完第一个日志后， 第二个日志还没有写完期间发生了crash， 会出现什么情况呢？</p><p><strong>先写redo log后写binlog。</strong> 假设在redo log写完， binlog还没有写完的时候， MySQL进程异常重启。 由redo log写完之后， 系统即使崩溃， 仍然能够把数据恢复回来， 所以恢复后这一行c的值是1。但是由于binlog没写完就crash了， 这时候binlog里面就没有记录这个语句。 因此， 之后备份日志的时候， 存起来的binlog里面就没有这条语句。如果需要用这个binlog来恢复临时库的话，恢复出来的这一行c的值就是0， 与原库的值不同。</p><p><strong>先写binlog后写redo log。</strong> 如果在binlog写完之后crash， 由于redo log还没写， 崩溃恢复以后这个事务无效， 所以这一行c的值是0。 但是binlog里面已经记录了“把c从0改成1”这个日志。 所以， 在之后用binlog来恢复的时候就多了一个事务出来， 恢复出来的这一行c的值就是1， 与原库的值不同。</p><p>简单说， redo log和binlog都可以用于表示事务的提交状态， 而两阶段提交就是让这两个状态保持逻辑上的一致。</p><h2 id="03-事务隔离：-为什么你改了我还看不见？"><a href="#03-事务隔离：-为什么你改了我还看不见？" class="headerlink" title="03 | 事务隔离： 为什么你改了我还看不见？"></a><strong>03 | 事务隔离：</strong> <strong>为什么你改了我还看不见？</strong></h2><p>简单来说， 事务就是要保证一组数据库操作， 要么全部成功， 要么全部失败。 在MySQL中， <strong>事务支持是在引擎层实现的</strong>。 你现在知道， MySQL是一个支持多引擎的系统， 但并不是所有的引擎都支持事务。 比如MySQL原生的MyISAM引擎就不支持事务， 这也是MyISAM被InnoDB取代的重要原因之一。</p><p><strong>隔离性与隔离级别</strong></p><p>提到事务，脑海里肯定有ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）。这里重点说隔离性。</p><p>当数据库上有多个事务同时执行的时候， 就可能出现脏读（dirtyread） 、 不可重复读（non repeatable read） 、 幻读（ phantom read） 的问题， 为了解决这些问题， 就有了“隔离级别”的概念。SQL标准的事务隔离级别包括： 读未提交（ read uncommitted） 、读提交（read committed） 、 可重复读（ repeatable read） 和串行化（ serializable ） 。</p><ul><li>读未提交是指， 一个事务还没提交时， 它做的变更就能被别的事务看到。</li><li>读提交是指， 一个事务提交之后， 它做的变更才会被其他事务看到。<br>可重复读是指， 一个事务执行过程中看到的数据， 总是跟这个事务在启动时看到的数据是一致的。 当然在可重复读隔离级别下， 未提交变更对其他事务也是不可见的。</li><li>串行化， 顾名思义是对于同一行记录， “写”会加“写锁”， “读”会加“读锁”。 当出现读写锁冲突的时候， 后访问的事务必须等前一个事务执行完成， 才能继续执行。</li></ul><p>假设数据表T中只有一列， 其中一行的值为1， 下面是按照时间顺序执行两个事务的行为。</p><pre><code>mysql&gt; create table T(c int) engine=InnoDB;insert into T(c) values(1);</code></pre><p><img src="/posts/44885/image-20240421191725626.png" alt></p><ul><li>若隔离级别是“读未提交”， 则V1的值就是2。 这时候事务B虽然还没有提交， 但是结果已经被A看到了。 因此， V2、 V3也都是2。</li><li>若隔离级别是“读提交”， 则V1是1， V2的值是2。 事务B的更新在提交后才能被A看到。 所以，V3的值也是2。</li><li>若隔离级别是“可重复读”， 则V1、 V2是1， V3是2。 之所以V2还是1， 遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。</li><li>若隔离级别是“串行化”， 则在事务B执行“将1改成2”的时候， 会被锁住。 直到事务A提交后，事务B才可以继续执行。 所以从A的角度看， V1、 V2值是1， V3的值是2。</li></ul><p>在实现上， 数据库里面会创建一个视图， 访问的时候以视图的逻辑结果为准。</p><ul><li>在“可重复读”隔离级别下， 这个视图是在事务启动时创建的， 整个事务存在期间都用这个视图。</li><li>在“读提交”隔离级别下， 这个视图是在每个SQL语句开始执行的时候创建的。 这里需要注意的是，</li><li>“读未提交”隔离级别下直接返回记录上的最新值， 没有视图概念。</li><li>“串行化”隔离级别下直接用加锁的方式来避免并行访问。</li></ul><p>Note：Oracle数据库的默认隔离级别是“读提交”，MySQL数据库的默认隔离级别是可重复读。因此，从Oracle迁移到MySQL的应用，为保证数据库隔离级别的一致，一定要将MySQL的隔离级别设置为“读提交”。</p><p><strong>事务隔离的实现</strong></p><p>可重复读 ：在MySQL中， 实际上每条记录在更新的时候都会同时记录一条回滚操作。 记录上的最新值， 通过回滚操作， 都可以得到前一个状态的值。假设一个值从1被按顺序改成了2、 3、 4， 在回滚日志里面就会有类似下面的记录。</p><p><img src="/posts/44885/image-20240421192045780.png" alt></p><p><strong>为什么建议你尽量不要使用长事务</strong></p><ul><li>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</li><li>长事务还占用锁资源，也可能拖垮整个库。</li></ul><p><strong>事务的启动方式</strong></p><ol><li>显式启动事务语句， begin 或 start transaction。 配套的提交语句是commit， 回滚语句是rollback。</li><li>set autocommit=0， 这个命令会将这个线程的自动提交关掉。 意味着如果你只执行一个select语句， 这个事务就启动了， 而且并不会自动提交。 这个事务持续存在直到你主动执行commit 或 rollback 语句， 或者断开连接。因此，建议总是使用set autocommit=1, 通过显式语句的方式来启动事务。</li></ol><h2 id="04-深入浅出索引（上）"><a href="#04-深入浅出索引（上）" class="headerlink" title="04 | 深入浅出索引（上）"></a><strong>04 | 深入浅出索引（上）</strong></h2><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzIzNjg4OTcyNA==&mid=2247484419&idx=1&sn=534c25b454a48d182849c551e4e063d0&chksm=e8d1b710dfa63e06a7d807c873ee6ce432e2c1b48b82560ccd14ea2ab3e22a2eb26df73ca410&cur_album_id=2138177096085471232&scene=189#wechat_redirect">MySQL索引经典15问！</a></li></ul><p>索引的出现其实就是为了提高数据查询的效率， 就像书的目录一样。</p><p><strong>索引的常见模型</strong></p><p>哈希表、 有序数组和搜索树。</p><p><strong>哈希表</strong></p><p><img src="/posts/44885/image-20240421192109123.png" alt></p><p>哈希表这种结构适用于只有等值查询的场景。</p><p><strong>有序数组</strong></p><p><img src="/posts/44885/image-20240421192116542.png" alt></p><p>有序数组在等值查询和范围查询场景中的性能就都非常优秀。但是有序数组索引只适用于静态存储引擎。</p><p><strong>搜索树</strong></p><p><img src="/posts/44885/image-20240421192123739.png" alt></p><p><strong>InnoDB的索引模型</strong></p><p>InnoDB中， 表都是根据主键顺序以索引的形式存放的， 这种存储方式的表称为索引组织表。又因为前面我们提到的， InnoDB使用了B+树索引模型， 所以数据都是存储在B+树中的。每一个索引在InnoDB里面对应一棵B+树。<br>假设， 我们有一个主键列为ID的表， 表中有字段k， 并且在k上有索引。<br>这个表的建表语句是：</p><pre><code>mysql&gt; create table T(id int primary key, k int not null, name varchar(16),index (k))engine=InnoDB;</code></pre><p>表中R1~R5的(ID,k)值分别为(100,1)、 (200,2)、 (300,3)、 (500,5)和(600,6)， 两棵树的示例示意图如下。</p><p><img src="/posts/44885/image-20240421192319244.png" alt></p><p>从图中不难看出， 根据叶子节点的内容， 索引类型分为主键索引和非主键索引。主键索引的叶子节点存的是整行数据。 在InnoDB里， 主键索引也被称为聚簇索引（clustered index） 。非主键索引的叶子节点内容是主键的值。 在InnoDB里， 非主键索引也被称为二级索引（secondaryindex）。</p><p><strong>基于主键索引和普通索引的查询有什么区别？</strong></p><p>如果语句是select * from Twhere ID=500， 即主键查询方式， 则只需要搜索ID这棵B+树；</p><p>如果语句是select * from Twhere k=5， 即普通索引查询方式， 则需要先搜索k索引树， 得到ID的值为500， 再到ID索引树搜索一次。 这个过程称为回表。</p><p><strong>索引维护</strong></p><p>主要是由于页分裂和合并。</p><p>自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。</p><p>自增主键的插入数据模式，符合递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</p><p>显然， 主键长度越小， 普通索引的叶子节点就越小， 普通索引占用的空间也就越小。</p><p><strong>如何避免长事务对业务的影响</strong> <strong>？</strong></p><p>首先， 从应用开发端来看：</p><ol><li>确认是否使用了set autocommit=0。 这个确认工作可以在测试环境中开展， 把MySQL的general_log开起来， 然后随便跑一个业务逻辑， 通过general_log的日志来确认。 一般框架如果会设置这个值， 也就会提供参数来控制行为， 你的目标就是把它改成1。</li><li>确认是否有不必要的只读事务。 有些框架会习惯不管什么语句先用begin/commit框起来。 我见过有些是业务并没有这个需要， 但是也把好几个select语句放到了事务中。 这种只读事务可以去掉。</li><li>业务连接数据库的时候， 根据业务本身的预估， 通过SETMAX_EXECUTION_TIME命令，来控制每个语句执行的最长时间， 避免单个语句意外执行太长时间。 （为什么会意外？ 在后续的文章中会提到这类案例）</li></ol><p><strong>其次，</strong> <strong>从数据库端来看</strong></p><ol><li>监控 information_schema.Innodb_trx表， 设置长事务阈值， 超过就报警/或者kill；</li><li>Percona的pt-kill这个工具不错， 推荐使用；</li><li>在业务功能测试阶段要求输出所有的general_log， 分析日志行为提前发现问题；</li><li>如果使用的是MySQL 5.6或者更新版本， 把innodb_undo_tablespaces设置成2（或更大的值） 。 如果真的出现大事务导致回滚段过大， 这样设置后清理起来更方便。</li></ol><h2 id="05-深入浅出索引（下）"><a href="#05-深入浅出索引（下）" class="headerlink" title="05 | 深入浅出索引（下）"></a><strong>05 | 深入浅出索引（下）</strong></h2><p>执行</p><pre><code>select * from Twhere k between 3 and 5</code></pre><p>需要执行几次树的搜索操作，会扫描多少行？</p><p>表的初始化语句</p><pre><code>mysql&gt; create table T (ID int primary key,k int NOT NULL DEFAULT 0, s varchar(16) NOT NULL DEFAULT &#39;&#39;,index k(k))engine=InnoDB;insert into T values(100,1, &#39;aa&#39;),(200,2,&#39;bb&#39;),(300,3,&#39;cc&#39;),(500,5,&#39;ee&#39;),(600,6,&#39;ff&#39;),(700,7,&#39;gg&#39;);</code></pre><p><img src="/posts/44885/image-20240421192628068.png" alt></p><p>我们一起来看看这条SQL查询语句的执行流程：</p><p>我们一起来看看这条SQL查询语句的执行流程：</p><ol><li>在k索引树上找到k=3的记录，取得 ID = 300；</li><li>再到ID索引树查到ID=300对应的R3；</li><li>在k索引树取下一个值k=5，取得ID=500；</li><li>再回到ID索引树查到ID=500对应的R4；</li><li>在k索引树取下一个值k=6，不满足条件，循环结束。</li></ol><p>回到主键索引树搜索的过程， 我们称为回表。</p><p><strong>覆盖索引</strong></p><p>由于覆盖索引可以减少树的搜索次数， 显著提升查询性能， 所以使用覆盖索引是一个常用的性能优化手段。</p><p><strong>最左前缀原则</strong></p><p>如果为每一种查询都设计一个索引， 索引是不是太多了。B+树这种索引结构， 可以利用索引的“最左前缀”， 来定位记录。</p><p><img src="/posts/44885/image-20240421192809647.png" alt></p><p>可以看到， 索引项是按照索引定义里面出现的字段顺序排序的。</p><p><strong>索引下推</strong></p><p>什么是索引下推？拿到索引之后根据where条件看看能不能再进行过滤。</p><pre><code>mysql&gt; select * from tuser where name like &#39;张%&#39; and age=10 and ismale=1;</code></pre><p>在MySQL 5.6之前， 只能从ID3开始一个个回表。 到主键索引上找出数据行， 再对比字段值。<br>而MySQL 5.6 引入的索引下推优化（indexcondition pushdown)， 可以在索引遍历过程中， 对索引中包含的字段先做判断， 直接过滤掉不满足条件的记录， 减少回表次数。</p><p><img src="/posts/44885/image-20240421192816713.png" alt></p><p><img src="/posts/44885/image-20240421192822945.png" alt></p><p>区别是， InnoDB在(name,age)索引内部就判断了age是否等于10， 对于不等于10的记录， 直接判断并跳过。 在我们的这个例子中， 只需要对ID4、 ID5这两条记录回表取数据判断， 就只需要回表2次。</p><h2 id="06-全局锁和表锁-：-给表加个字段怎么有这么多阻碍？"><a href="#06-全局锁和表锁-：-给表加个字段怎么有这么多阻碍？" class="headerlink" title="06 | 全局锁和表锁 ： 给表加个字段怎么有这么多阻碍？"></a><strong>06 | 全局锁和表锁</strong> <strong>：</strong> <strong>给表加个字段怎么有这么多阻碍？</strong></h2><p>数据库锁设计的初衷是处理并发问题。</p><p>根据加锁的范围， MySQL里面的锁大致可以分成全局锁、 表级锁和行锁三类。</p><p><strong>全局锁</strong></p><p>当你需要让整个库处于只读状态的时候， 可以使用这个命令， 之后其他线程的以下语句会被阻塞： 数据更新语句（数据的增删改） 、 数据定义语句（包括建表、 修改表结构等） 和更新类事务的提交语句。</p><p><strong>全局锁的典型使用场景是， 做全库逻辑备份。</strong></p><p>但是让整库都只读， 听上去就很危险：<br>如果你在主库上备份， 那么在备份期间都不能执行更新， 业务基本上就得停摆；<br>如果你在从库上备份， 那么备份期间从库不能执行主库同步过来的binlog， 会导致主从延迟 。</p><p><img src="/posts/44885/image-20240421192903605.png" alt></p><p>这个备份结果里， 用户A的数据状态是“账户余额没扣， 但是用户课程表里面已经多了一门课”。 如果后面用这个备份来恢复数据的话， 用户A就发现， 自己赚了。但是，如果备份表的顺序反过来，先备份用户课程表再备份账户余额表，又可能会出现什么结果【狗头】。</p><p>官方自带的逻辑备份工具是mysqldump。当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。</p><p><strong>表级锁</strong></p><p>MySQL里面表级别的锁有两种： 一种是表锁， 一种是元数据锁（meta data lock， MDL) 。</p><p>表锁的语法是 lock tables …read/write。举个例子, 如果在某个线程A中执行lock tables t1 read, t2 write; 这个语句， 则其他线程写t1、 读写t2的语句都会被阻塞。 同时， 线程A在执行unlock tables之前， 也只能执行读t1、 读写t2的操作。 连写t1都不允许， 自然也不能访问其他表。</p><p>另一类表级的锁是MDL（ metadata lock)。 MDL不需要显式使用， 在访问一个表的时候会被自动加上。 MDL的作用是， 保证读写的正确性。 你可以想象一下， 如果一个查询正在遍历一个表中的数据， 而执行期间另一个线程对这个表结构做变更， 删了一列， 那么查询线程拿到的结果跟表结构对不上， 肯定是不行的。</p><p>MDL读锁之间不互斥， 因此你可以有多个线程同时对一张表增删改查。</p><p>读写锁之间、 写锁之间是互斥的， 用来保证变更表结构操作的安全性。</p><p>因此， 如果有两个线程要同时给一个表加字段， 其中一个要等另一个执行完才能开始执行。</p><p><img src="/posts/44885/image-20240421193106335.png" alt></p><ol><li>session A先启动，对表t加一个MDL读锁。</li><li>由于session B需要的也是MDL读锁。</li><li>session C会被blocked，是因为session A的MDL读锁还没有释放，而session C需要MDL写锁，因此只能被阻塞。</li><li>问题来了，之后所有要在表t上新申请MDL读锁的请求也会被session C阻塞。等于这个表现在完全不可读写了。</li></ol><p>上面的例子如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新session再请求的话，这个库的线程很快就会爆满。</p><p><strong>事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。</strong></p><p><strong>pro1:如何安全地给小表加字段？</strong></p><p><strong>solution1:</strong>首先我们要解决长事务，事务不提交，就会一直占着MDL锁。在MySQL的information_schema 库的 innodb_trx 表中，你可以查到当前执行中的事务。如果你要做DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务。</p><p><strong>pro2:你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，你该怎么做呢？</strong></p><p>这时候kill可能未必管用，因为新的请求马上就来了。比较理想的机制是，在alter table语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者DBA再通过重试命令重复这个过程。</p><h2 id="07-行锁功过：-怎么减少行锁对性能的影响？"><a href="#07-行锁功过：-怎么减少行锁对性能的影响？" class="headerlink" title="07 | 行锁功过： 怎么减少行锁对性能的影响？"></a><strong>07 | 行锁功过：</strong> <strong>怎么减少行锁对性能的影响？</strong></h2><p>MySQL的行锁是在引擎层由各个引擎自己实现的。 但并不是所有的引擎都支持行锁。 InnoDB是支持行锁的。MyISAM引擎就不支持行锁。</p><p><strong>从两阶段锁说起</strong></p><p><img src="/posts/44885/image-20240421194317901.png" alt></p><p>实际上事务B的update语句会被阻塞， 直到事务A执行commit之后， 事务B才能继续执行。 在InnoDB事务中， 行锁是在需要的时候才加上的， 但并不是不需要了就立刻释放， 而是要等到事务结束时才释放。 这个就是两阶段锁协议。</p><p><strong>在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</strong></p><p><strong>结论</strong>：如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</p><p><strong>死锁和死锁检测</strong></p><p><img src="/posts/44885/image-20240421194324791.png" alt></p><p>这时候， 事务A在等待事务B释放id=2的行锁， 而事务B在等待事务A释放id=1的行锁。 事务A和事务B在互相等待对方的资源释放， 就是进入了死锁状态。</p><p>当出现死锁以后， 有两种策略：</p><ul><li>一种策略是， 直接进入等待， 直到超时。 这个超时时间可以通过参数innodb_lock_wait_timeout来设置。<ul><li>在InnoDB中，innodb_lock_wait_timeout的默认值是50s。意味着当出现死锁以后，第一个被锁住的线程要过50s才会超时退出，然后其他线程才有可能继续执行。如果我们把这个时间设置成一个很小的值，比如1s，会伤害到普通的锁等待。</li></ul></li><li>另一种策略是， 发起死锁检测， 发现死锁后， 主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。 将参数innodb_deadlock_detect设置为on， 表示开启这个逻辑。</li></ul><p>背景：</p><p>每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。</p><p>那如果是我们上面说到的所有事务都要更新同一行的场景呢？</p><p>每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是O(n)的操作。假设有1000个并发线程要同时更新同一行，那么死锁检测操作就是100万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的CPU资源。因此，你就会看到CPU利用率很高，但是每秒却执行不了几个事务。</p><p>根据上面的分析，我们来讨论一下，怎么解决由这种热点行更新导致的性能问题呢？</p><p>问题：</p><p>问题的关键在于死锁检测要耗费大量的CPU资源。</p><p>解决方法：</p><ol><li>如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。</li><li>控制并发度。比如同一行同时最多只有10个线程在更新，那么死锁检测的成本很低，就不会出现这个问题。</li></ol><h2 id="08-事务到底是隔离的还是不隔离的？"><a href="#08-事务到底是隔离的还是不隔离的？" class="headerlink" title="08 | 事务到底是隔离的还是不隔离的？"></a><strong>08 | 事务到底是隔离的还是不隔离的？</strong></h2><p>这部分主要是MVCC原理，可以到B站上学习下。</p><p>网上看到不错的作图，贴在这里啦~</p><p><img src="/posts/44885/image-20240421194150016.png" alt></p><p><img src="/posts/44885/image-20240421194201861.png" alt></p><p><img src="/posts/44885/image-20240421194212043.png" alt></p><p><img src="/posts/44885/image-20240421194233781.png" alt></p><p>好文推荐</p><ul><li><a href="https://mp.weixin.qq.com/s/yyMI3uPvovEr1EgndGro5g">看一遍就懂：MVCC原理详解</a></li></ul><p>如果是可重复读隔离级别， 事务T启动的时候会创建一个视图read-view， 之后事务T执行期间， 即使有其他事务修改了数据， 事务T看到的仍然跟在启动时看到的一样。</p><p>begin/start transaction 命令并不是一个事务的起点， 在执行到它们之后的第一个操作InnoDB表的语句， 事务才真正启动。 如果你想要马上启动一个事务， 可以使用start transaction withconsistent snapshot 这个命令。</p><p>在MySQL里， 有两个“视图”的概念：一个是view。 它是一个用查询语句定义的虚拟表， 在调用的时候执行查询语句并生成结果。创建视图的语法是create view …， 而它的查询方法与表一样。另一个是InnoDB在实现MVCC时用到的一致性读视图， 即consistent read view， 用于支持RC（Read Committed， 读提交） 和RR（ Repeatable Read， 可重复读） 隔离级别的实现。</p><p><strong>“快照”在MVCC里是怎么工作的？</strong></p><p>InnoDB里面每个事务有一个唯一的事务ID， 叫作transaction id。 它是在事务开始的时候向InnoDB的事务系统申请的， 是按申请顺序严格递增的。而每行数据也都是有多个版本的。 每次事务更新数据的时候， 都会生成一个新的数据版本， 并且把transaction id赋值给这个数据版本的事务ID， 记为row trx_id。 同时， 旧的数据版本要保留，并且在新的数据版本中， 能够有信息可以直接拿到它。也就是说， 数据表中的一行记录， 其实可能有多个版本(row)， 每个版本有自己的row trx_id。</p><p><img src="/posts/44885/image-20240421194335011.png" alt></p><p>实际上， 图2中的三个虚线箭头， 就是undo log； 而V1、 V2、 V3并不是物理上真实存在的， 而是每次需要的时候根据当前版本和undo log计算出来的。 比如， 需要V2的时候， 就是通过V4依次执行U3、 U2算出来。</p><p>InnoDB为每个事务构造了一个数组， 用来保存这个事务启动瞬间， 当前正在“活跃”的所有事务ID。 “活跃”指的就是， 启动了但还没提交。</p><p>更新数据都是先读后写的， 而这个读， 只能读当前的值， 称为“当前读”（ current read） 。</p><p>InnoDB的行数据有多个版本， 每个数据版本有自己的row trx_id， 每个事务或者语句有自己的一致性视图。 普通查询语句是一致性读， 一致性读会根据row trx_id和一致性视图确定数据版本的可见性。</p><p>￮ 对于可重复读， 查询只承认在事务启动前就已经提交完成的数据；</p><p>￮ 对于读提交， 查询只承认在语句启动前就已经提交完成的数据；</p><p>￮ 而当前读， 总是读取已经提交完成的最新版本。</p><h2 id="09-普通索引和唯一索引，-应该怎么选择？"><a href="#09-普通索引和唯一索引，-应该怎么选择？" class="headerlink" title="09 | 普通索引和唯一索引， 应该怎么选择？"></a><strong>09 | 普通索引和唯一索引，</strong> <strong>应该怎么选择？</strong></h2><p>从性能的角度考虑， 你选择唯一索引还是普通索引呢？ 选择的依据是什么呢？</p><p><img src="/posts/44885/image-20240421194340923.png" alt></p><p><strong>查询过程</strong></p><p>假设，执行查询的语句是 select id from T where k=5。这个查询语句在索引树上查找的过程，先是通过B+树从树根开始，按层搜索到叶子节点，也就是图中右下角的这个数据页，然后可以认为数据页内部通过二分法来定位记录。</p><ul><li>对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。</li><li>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</li></ul><p>那么，这个不同带来的性能差距会有多少呢？答案是，微乎其微。</p><p>InnoDB的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在InnoDB中，每个数据页的大小默认是16KB。</p><p>因为引擎是按页读写的，所以说，当找到k=5的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。</p><p><strong>更新过程</strong></p><p>先介绍一下change buffer。</p><p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。</p><p>虽然名字叫作change buffer，实际上它是可以持久化的数据。也就是说，change buffer在内存中有拷贝，也会被写入到磁盘上。</p><p>将change buffer中的操作应用到原数据页，得到最新结果的过程称为merge。除了访问这个数据页会触发merge外，系统有后台线程会定期merge。在数据库正常关闭（shutdown）的过程中，也会执行merge操作。</p><p><strong>pro</strong>:什么条件下可以使用change buffer呢？</p><p><strong>ans</strong>：唯一索引的更新就不能使用change buffer，实际上也只有普通索引可以使用。</p><p>介绍完change buffer,来说说更新过程，分为2个case。</p><p>第一种情况是，<strong>这个记录要更新的目标页在内存中</strong>。这时，InnoDB的处理流程如下：</p><ul><li>对于唯一索引来说，找到3和5之间的位置，判断到没有冲突，插入这个值，语句执行结束；</li><li>对于普通索引来说，找到3和5之间的位置，插入这个值，语句执行结束。</li></ul><p>这样看来，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的CPU时间。</p><p>第二种情况是，<strong>这个记录要更新的目标页不在内存中</strong>。这时，InnoDB的处理流程如下：</p><ul><li>对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；</li><li>对于普通索引来说，则是将更新记录在change buffer，语句执行就结束了。</li></ul><p>将数据从磁盘读入内存涉及随机IO的访问，是数据库里面成本最高的操作之一。change buffer因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。</p><p><strong>change buffer使用场景</strong></p><p>先来一个问题：普通索引的所有场景，使用change buffer都可以起到加速作用吗？</p><p>心中有个最初的原则：change buffer的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做merge之前，change buffer记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。</p><p>因此，对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好。</p><p>有好的场景当然也有不好的场景。</p><p>不好的场景就是假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在change buffer，但之后由于马上要访问这个数据页，会立即触发merge过程。这样随机访问IO的次数不会减少，反而增加了change buffer的维护代价。所以，对于这种业务模式来说，change buffer反而起到了副作用。</p><p><strong>索引选择和实践</strong></p><p>普通索引和唯一索引应该怎么选择。其实，这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响。所以，建议你尽量选择普通索引</p><p>如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭change buffer。而在其他情况下，change buffer都能提升更新性能。</p><p><strong>change buffer 和 redo log</strong></p><p>接下来其实主要就是区分redo log和change buffer。</p><p>现在，我们要在表上执行这个插入语句：</p><pre><code>mysql&gt; insert into t(id,k) values(id1,k1),(id2,k2);</code></pre><p>这里，我们假设当前k索引树的状态，查找到位置后，k1所在的数据页在内存(InnoDB buffer pool)中，k2所在的数据页不在内存中。如图2所示是带change buffer的更新状态图。</p><p><img src="/posts/44885/image-20240421195152846.png" alt></p><p>分析这条更新语句，你会发现它涉及了四个部分：内存、redo log（ib_log_fileX）、 数据表空间（t.ibd）、系统表空间（ibdata1）。</p><p>这条更新语句做了如下的操作（按照图中的数字顺序）：</p><ol><li>Page 1在内存中，直接更新内存；</li><li>Page 2没有在内存中，就在内存的change buffer区域，记录下“我要往Page 2插入一行”这个信息</li><li>将上述两个动作记入redo log中（图中3和4）。</li></ol><p>做完上面这些，事务就可以完成了。所以，你会看到，执行这条更新语句的成本很低，就是写了两处内存，然后写了一处磁盘（两次操作合在一起写了一次磁盘），而且还是顺序写的。</p><p>同时，图中的两个虚线箭头，是后台操作，不影响更新的响应时间。</p><p>现在要执行 select * from t where k in (k1, k2)。</p><p><img src="/posts/44885/image-20240421195257043.png" alt></p><ol><li>读Page 1的时候，直接从内存返回。有几位同学在前面文章的评论中问到，WAL之后如果读数据，是不是一定要读盘，是不是一定要从redo log里面把数据更新以后才可以返回？其实是不用的。你可以看一下图3的这个状态，虽然磁盘上还是之前的数据，但是这里直接从内存返回结果，结果是正确的。</li><li>要读Page 2的时候，需要把Page 2从磁盘读入内存中，然后应用change buffer里面的操作日志，生成一个正确的版本并返回结果。</li></ol><p>可以看到，直到需要读Page 2的时候，这个数据页才会被读入内存。</p><p>所以，如果要简单地对比这两个机制在提升更新性能上的收益的话，<strong>redo log 主要节省的是随机写磁盘的IO消耗（转成顺序写），而change buffer主要节省的则是随机读磁盘的IO消耗。</strong></p><p><strong>来个问题：</strong>如果某次写入使用了change buffer机制，之后主机异常重启，是否会丢失change buffer和数据。</p><p>这个问题的答案是不会丢失。虽然是只更新内存，但是在事务提交的时候，我们把change buffer的操作也记录到redo log里了，所以崩溃恢复的时候，change buffer也能找回来。</p><h2 id="10-MySQL为什么有时候会选错索引？"><a href="#10-MySQL为什么有时候会选错索引？" class="headerlink" title="10 | MySQL为什么有时候会选错索引？"></a><strong>10 | MySQL为什么有时候会选错索引？</strong></h2><p>【优化器工作原理】</p><p>一种方法是， 像我们第一个例子一样， 采用force index强行选择一个索引。</p><p>第二种方法就是， 我们可以考虑修改 语句， 引导MySQL使用我们期望的索引。 比如， 在这个例子里， 显然把“order byb limit 1” 改成 “order byb,a limit 1” ， 语义的逻辑是相同的。</p><p>第三种方法是， 在有些场景下， 我们可以新建一个更合适的索引， 来提供给优化器做选择， 或删掉误用的索引。</p><h2 id="11-怎么给字符串字段加索引？"><a href="#11-怎么给字符串字段加索引？" class="headerlink" title="11 | 怎么给字符串字段加索引？"></a><strong>11 | 怎么给字符串字段加索引？</strong></h2><pre><code>mysql&gt; alter table SUser add index index1(email);或mysql&gt; alter table SUser add index index2(email(6));</code></pre><p>第一个语句创建的index1索引里面， 包含了每个记录的整个字符串； 而第二个语句创建的index2索引里面， 对于每个记录都是只取前6个字节。</p><p><img src="/posts/44885/image-20240421195513438.png" alt></p><p><img src="/posts/44885/image-20240421195518185.png" alt></p><pre><code>select id,name,email from SUser where email=&#39;zhangssxyz@xxx.com&#39;;</code></pre><p><strong>如果使用的是index1</strong>（即email整个字符串的索引结构），执行顺序是这样的：</p><ol><li>从index1索引树找到满足索引值是’<a href="mailto:zhangssxyz@xxx.com">zhangssxyz@xxx.com</a>’的这条记录，取得ID2的值；</li><li>到主键上查到主键值是ID2的行，判断email的值是正确的，将这行记录加入结果集；</li><li>取index1索引树上刚刚查到的位置的下一条记录，发现已经不满足email=’zhangssxyz@xxx.com’的条件了，循环结束。</li></ol><p>这个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。</p><p><strong>如果使用的是index2</strong>（即email(6)索引结构），执行顺序是这样的：</p><ol><li>从index2索引树找到满足索引值是’zhangs’的记录，找到的第一个是ID1；</li><li>到主键上查到主键值是ID1的行，判断出email的值不是’<a href="mailto:zhangssxyz@xxx.com">zhangssxyz@xxx.com</a>’，这行记录丢弃；</li><li>取index2上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出ID2，再到ID索引上取整行然后判断，这次值对了，将这行记录加入结果集；</li><li>重复上一步，直到在idxe2上取到的值不是’zhangs’时，循环结束。</li></ol><p>在这个过程中，要回主键索引取4次数据，也就是扫描了4行。</p><p>通过这个对比，你很容易就可以发现，使用前缀索引后，可能会导致查询语句读数据的次数变多。</p><p><strong>结论：使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</strong></p><p>来个问题：当要给字符串创建前缀索引时，有什么方法能够确定我应该使用多长的前缀呢？</p><p>实际上，我们在建立索引时关注的是区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。因此，我们可以通过统计索引上有多少个不同的值来判断要使用多长的前缀。</p><p>常用方法</p><pre><code>mysql&gt; select count(distinct email) as L from SUser;-----mysql&gt; select   count(distinct left(email,4)）as L4,  count(distinct left(email,5)）as L5,  count(distinct left(email,6)）as L6,  count(distinct left(email,7)）as L7,from SUser;</code></pre><p><strong>前缀索引对覆盖索引的影响</strong></p><p>先来看看这个SQL语句：</p><pre><code>select id,email from SUser where email=&#39;zhangssxyz@xxx.com&#39;;</code></pre><p>与前面例子中的SQL语句</p><pre><code>select id,name,email from SUser where email=&#39;zhangssxyz@xxx.com&#39;;</code></pre><p>如果使用index1（即email整个字符串的索引结构）的话，可以利用覆盖索引，从index1查到结果后直接就返回了，不需要回到ID索引再去查一次。而如果使用index2（即email(6)索引结构）的话，就不得不回到ID索引再去判断email字段的值。</p><p>即使你将index2的定义修改为email(18)的前缀索引，这时候虽然index2已经包含了所有的信息，但InnoDB还是要回到id索引再查一下，因为系统并不确定前缀索引的定义是否截断了完整信息。</p><p><strong>使用前缀索引就用不上覆盖索引对查询性能的优化</strong>了， 这也是你在选择是否使用前缀索引时需要考虑的一个因素。</p><p><strong>其他方式</strong></p><p>第一种方式是使用倒序存储。</p><p>第二种方式是使用hash字段。</p><p>首先， 它们的相同点是， 都不支持范围查询。 倒序存储的字段上创建的索引是按照倒序字符串的方式排序的， 已经没有办法利用索引方式查出身份证号码在[ID_X, ID_Y]的所有市民了。 同样地， hash字段的方式也只能支持等值查询。</p><p>它们的区别， 主要体现在以下三个方面：</p><ol><li>从占用的额外空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，而hash字段方法需要增加一个字段。当然，倒序存储方式使用4个字节的前缀长度应该是不够的，如果再长一点，这个消耗跟额外这个hash字段也差不多抵消了。</li><li>在CPU消耗方面，倒序方式每次写和读的时候，都需要额外调用一次reverse函数，而hash字段的方式需要额外调用一次crc32()函数。如果只从这两个函数的计算复杂度来看的话，reverse函数额外消耗的CPU资源会更小些。</li><li>从查询效率上看，使用hash字段方式的查询性能相对更稳定一些。因为crc32算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。</li></ol><p><strong>总结</strong></p><ol><li>直接创建完整索引，这样可能比较占用空间；</li><li>创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；</li><li>倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；</li><li>创建hash字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。</li></ol><h2 id="12-为什么我的MySQL会“抖”一下？"><a href="#12-为什么我的MySQL会“抖”一下？" class="headerlink" title="12 | 为什么我的MySQL会“抖”一下？"></a><strong>12 | 为什么我的MySQL会“抖”一下？</strong></h2><p>【数据库代码】</p><p>当内存数据页跟磁盘数据页内容不一致的时候， 我们称这个内存页为“脏页”。 内存数据写入到磁盘后， 内存和磁盘上的数据页的内容就一致了， 称为“干净页”。</p><p>什么时候flush？</p><p>1：是InnoDB的redo log写满了。 这时候系统会停止所有更新操作， 把:checkpoint往前推进， redo log留出空间可以继续写。</p><p><img src="/posts/44885/image-20240421195941651.png" alt></p><p>checkpoint可不是随便往前修改一下位置就可以的。 比如图中， 把checkpoint位置从CP推进到CP’， 就需要将两个点之间的日志（浅绿色部分） ， 对应的所有脏页都flush到磁盘上。 之后， 图中从write pos到CP’之间就是可以再写入的redo log的区域。</p><p>2：系统内存不足。 当需要新的内存页， 而内存不够用的时候， 就要淘汰一些数据页， 空出内存给别的数据页使用。 如果淘汰的是“脏页”， 就要先将脏页写到磁盘。</p><p>3：MySQL认为系统“空闲”的时候。</p><p>4：MySQL正常关闭的情况。 这时候， MySQL会把内存的脏页都flush到磁盘上， 这样下次MySQL启动的时候， 就可以直接从磁盘上读数据， 启动速度会很快。</p><p>第一种是“redo log写满了， 要flush脏页”， 这种情况是InnoDB要尽量避免的。 因为出现这种情况的时候， 整个系统就不能再接受更新了， 所有的更新都必须堵住。</p><p>第二种是“内存不够用了， 要先将脏页写到磁盘”， 这种情况其实是常态。InnoDB用缓冲池（ buffer pool） 管理内存， 缓冲池中的内存页有三种状态：第一种是， 还没有使用的；第二种是， 使用了并且是干净页；第三种是， 使用了并且是脏页。</p><p>InnoDB的刷盘速度就是要参考这两个因素： 一个是脏页比例， 一个是redo log写盘速度。 InnoDB会根据这两个因素先单独算出两个数字。</p><p>InnoDB每次写入的日志都有一个序号， 当前写入的序号跟checkpoint对应的序号之间的差值，我们假设为N。 InnoDB会根据这个N算出一个范围在0到100之间的数字， 这个计算公式可以记为F2(N)。 F2(N)算法比较复杂， 你只要知道N越大， 算出来的值越大就好了。然后， 根据上述算得的F1(M)和F2(N)两个值， 取其中较大的值记为R， 之后引擎就可以按照innodb_io_capacity定义的能力乘以R%来控制刷脏页的速度。</p><p><img src="/posts/44885/image-20240421195954851.png" alt></p><p>现在你知道了， InnoDB会在后台刷脏页， 而刷脏页的过程是要将内存页写入磁盘。 所以， 无论是你的查询语句在需要内存的时候可能要求淘汰一个脏页， 还是由于刷脏页的逻辑会占用IO资源并可能影响到了你的更新语句</p><p>而MySQL中的一个机制， 可能让你的查询会更慢： 在准备刷一个脏页的时候， 如果这个数据页旁边的数据页刚好是脏页， 就会把这个“邻居”也带着一起刷掉； 而且这个把“邻居”拖下水的逻辑还可以继续蔓延， 也就是对于每个邻居数据页， 如果跟它相邻的数据页也还是脏页的话， 也会被放到一起刷</p><h2 id="13-为什么表数据删掉一半，-表文件大小不变？"><a href="#13-为什么表数据删掉一半，-表文件大小不变？" class="headerlink" title="13 | 为什么表数据删掉一半， 表文件大小不变？"></a><strong>13 | 为什么表数据删掉一半，</strong> <strong>表文件大小不变？</strong></h2><p>【B+树代码】</p><p>InnoDB引擎只会把R4这个记录标记为删除。 如果之后要再插入一个ID在300和600之间的记录时， 可能会复用这个位置。 但是， 磁盘文件的大小并不会缩小。</p><p>delete命令其实只是把记录的位置， 或者数据页标记为了“可复用”， 但磁盘文件的大小是不会变的。 也就是说， 通过delete命令是不能回收表空间的。 这些可以复用， 而没有被使用的空间， 看起来就像是“空洞”。</p><p>不止是删除数据会造成空洞， 插入数据也会。</p><p><img src="/posts/44885/image-20240421200036775.png" alt></p><p>page A满了， 再插入一个ID是550的数据时， 就不得不再申请一个新的页面page B来保存数据了。 页分裂完成后， page A的末尾就留下了空洞（注意： 实际上， 可能不止1个记录的位置是空洞） 。</p><p><strong>重建表</strong></p><p>你可以新建一个与表A结构相同的表B， 然后按照主键ID递增的顺序， 把数据一行一行地从表A里读出来再插入到表B中。由于表B是新建的表， 所以表A主键索引上的空洞， 在表B中就都不存在了。 显然地， 表B的主键索引更紧凑， 数据页的利用率也更高。 如果我们把表B作为临时表， 数据从表A导入表B的操作完成后， 用表B替换A，从效果上看， 就起到了收缩表A空间的作用。</p><p><img src="/posts/44885/image-20240421200044232.png" alt></p><p>引入了Online DDL之后， 重建表的流程：</p><ol><li>建立一个临时文件，扫描表A主键的所有数据页；</li><li>用数据页中表A的记录生成B+树，存储到临时文件中；</li><li>生成临时文件的过程中，将所有对A的操作记录在一个日志文件（row log）中，对应的是图中state2的状态；</li><li>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表A相同的数据文件，对应的就是图中state3的状态；</li><li>用临时文件替换表A的数据文件。</li></ol><p><img src="/posts/44885/image-20240421200108974.png" alt></p><p><img src="/posts/44885/image-20240421200122892.png" alt></p><h2 id="14-count-这么慢，-我该怎么办？"><a href="#14-count-这么慢，-我该怎么办？" class="headerlink" title="14 | count(*)这么慢， 我该怎么办？"></a><strong>14 | count(*)这么慢，</strong> <strong>我该怎么办？</strong></h2><p>【不同引擎工作以及常见count】</p><p><strong>count(*)的实现方式</strong></p><p>在不同的MySQL引擎中， count( * )有不同的实现方式。</p><ul><li>MyISAM引擎把一个表的总行数存在了磁盘上， 因此执行count( * )的时候会直接返回这个数，效率很高</li><li>InnoDB引擎就麻烦了， 它执行count(*)的时候， 需要把数据一行一行地从引擎里面读出来， 然后累积计数</li></ul><p>那为什么InnoDB不跟MyISAM一样， 也把数字存起来呢？ <strong>这是因为即使是在同一个时刻的多个查询， 由于多版本并发控制（MVCC） 的原因</strong>， InnoDB表“应该返回多少行”也是不确定的。 这里， 我用一个算count(*)的例子来为你解释一下。</p><p><img src="/posts/44885/image-20240421200223518.png" alt></p><p>这和InnoDB的事务设计有关系， 可重复读是它默认的隔离级别， 在代码上就是通过多版本并发控制， 也就是MVCC来实现的。 每一行记录都要判断自己是否对这个会话可见， 因此对于count(*)请求来说， InnoDB只好把数据一行一行地读出依次判断， 可见的行才能够用于计算“基于这个查询”的表的总行数。</p><p><strong>不同的count用法</strong></p><p><strong>对于count(主键id)来说</strong>，InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层。server层拿到id后，判断是不可能为空的，就按行累加。</p><p><strong>对于count(1)来说</strong>，InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</p><p><strong>对于count(字段)来说</strong>：</p><ol><li>如果这个“字段”是定义为not null的话，一行行地从记录里面读出这个字段，判断不能为null，按行累加；</li><li>如果这个“字段”定义允许为null，那么执行的时候，判断到有可能是null，还要把值取出来再判断一下，不是null才累加。</li></ol><p><strong>但是count(*)是例外</strong>，并不会把全部字段取出来，而是专门做了优化，不取值。count(*)肯定不是null，按行累加。</p><p><strong>结论是</strong>：按照效率排序的话，count(字段)&lt;count(主键id)&lt;count(1)≈count(<em>)，所以我建议你，尽量使用count(</em>)。</p><h2 id="15-答疑文章（一）-：-日志和索引相关问题"><a href="#15-答疑文章（一）-：-日志和索引相关问题" class="headerlink" title="15 | 答疑文章（一） ： 日志和索引相关问题"></a><strong>15 | 答疑文章（一）</strong> <strong>：</strong> <strong>日志和索引相关问题</strong></h2><p>这个部分好好看看平台文章。</p><p><strong>日志相关问题</strong></p><p><strong>在两阶段提交的不同瞬间，MySQL如果发生异常重启，是怎么保证数据完整性的？</strong></p><p><img src="/posts/44885/image-20240421200445846.png" alt></p><p>崩溃恢复时的判断规则。</p><ol><li>如果redo log里面的事务是完整的，也就是已经有了commit标识，则直接提交；</li><li>如果redo log里面的事务只有完整的prepare，则判断对应的事务binlog是否存在并完整：<br>a. 如果是，则提交事务；<br>b. 否则，回滚事务。</li></ol><p><strong>MySQL怎么知道binlog是完整的?</strong></p><p>回答：一个事务的binlog是有完整格式的：</p><ul><li>statement格式的binlog，最后会有COMMIT；</li><li>row格式的binlog，最后会有一个XID event。</li></ul><p>另外，在MySQL 5.6.2版本以后，还引入了binlog-checksum参数，用来验证binlog内容的正确性。对于binlog日志由于磁盘原因，可能会在日志中间出错的情况，MySQL可以通过校验checksum的结果来发现。所以，MySQL还是有办法验证事务binlog的完整性的。</p><p><strong>redo log 和 binlog是怎么关联起来的?</strong></p><p>回答： 它们有一个共同的数据字段， 叫XID。 崩溃恢复的时候， 会按顺序扫描redo log：<br>如果碰到既有prepare、 又有commit的redo log， 就直接提交；<br>如果碰到只有parepare、 而没有commit的redo log， 就拿着XID去binlog找对应的事务。</p><p><strong>redo log一般设置多大？</strong></p><p>redo log太小的话， 会导致很快就被写满， 然后不得不强行刷redo log， 这样WAL机制的能力就发挥不出来了。所以， 如果是现在常见的几个TB的磁盘的话， 就不要太小气了， 直接将redo log设置为4个文件、 每个文件1GB吧。</p><p><strong>redo log buffer是什么？是先修改内存，还是先写redo log文件？</strong></p><p>在一个事务的更新过程中，日志是要写多次的。比如下面这个事务：</p><pre><code>begin;insert into t1 ...insert into t2 ...commit;</code></pre><p>这个事务要往两个表中插入记录，插入数据的过程中，生成的日志都得先保存起来，但又不能在还没commit的时候就直接写到redo log文件里。</p><p>所以，redo log buffer就是一块内存，用来先存redo日志的。也就是说，在执行第一个insert的时候，数据的内存被修改了，redo log buffer也写入了日志。</p><p>但是，真正把日志写到redo log文件（文件名是 ib_logfile+数字），是在执行commit语句的时候做的。</p><h2 id="16-“order-by”是怎么工作的？"><a href="#16-“order-by”是怎么工作的？" class="headerlink" title="16 | “order by”是怎么工作的？"></a><strong>16 | “order by”是怎么工作的？</strong></h2><p>【流程及其优化】</p><pre><code>select city,name,age from t where city=&#39;杭州&#39; order by name limit 1000  ;</code></pre><p><strong>全字段排序</strong></p><p>为避免全表扫描， 我们需要在city字段加上索引。在city字段上创建索引之后， 我们用explain命令来看看这个语句的执行情况。</p><p><img src="/posts/44885/image-20240421200729385.png" alt></p><p>Extra这个字段中的“Using filesort”表示的就是需要排序，MySQL会给每个线程分配一块内存用于排序，称为sort_buffer。</p><p><img src="/posts/44885/image-20240421200739061.png" alt></p><p>通常情况下，这个语句执行流程如下所示 ：</p><ol><li>初始化sort_buffer，确定放入name、city、age这三个字段；</li><li>从索引city找到第一个满足city=’杭州’条件的主键id，也就是图中的ID_X；</li><li>到主键id索引取出整行，取name、city、age三个字段的值，存入sort_buffer中；</li><li>从索引city取下一个记录的主键id；</li><li>重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是图中的ID_Y；</li><li>对sort_buffer中的数据按照字段name做快速排序；</li><li>按照排序结果取前1000行返回给客户端。</li></ol><p><img src="/posts/44885/image-20240421200817067.png" alt></p><p><strong>这里，我们要熟悉OPTIMIZER_TRACE命，explain以及慢查询查看结果。</strong></p><p><strong>rowid排序</strong></p><p>新的算法放入sort_buffer的字段， 只有要排序的列（ 即name字段） 和主键id。但这时， 排序的结果就因为少了city和age字段的值， 不能直接返回了， 整个执行流程就变成如<br>下所示的样子：</p><ol><li>初始化sort_buffer，确定放入两个字段，即name和id；</li><li>从索引city找到第一个满足city=’杭州’条件的主键id，也就是图中的ID_X；</li><li>到主键id索引取出整行，取name、id这两个字段，存入sort_buffer中；</li><li>从索引city取下一个记录的主键id；</li><li>重复步骤3、4直到不满足city=’杭州’条件为止，也就是图中的ID_Y；</li><li>对sort_buffer中的数据按照字段name进行排序；</li><li>遍历排序结果，取前1000行，并按照id的值回到原表中取出city、name和age三个字段返回给客户端。</li></ol><p><img src="/posts/44885/image-20240421201012251.png" alt></p><p><strong>全字段排序 VS rowid排序</strong></p><p>使用索引优化从而优化排序。</p><h2 id="17-如何正确地显示随机消息？"><a href="#17-如何正确地显示随机消息？" class="headerlink" title="17 | 如何正确地显示随机消息？"></a><strong>17 | 如何正确地显示随机消息？</strong></h2><p>【学习SQL执行过程】</p><p><strong>背景</strong></p><p>这个英语学习App首页有一个随机显示单词的功能，也就是根据每个用户的级别有一个单词表，然后这个用户每次访问首页的时候，都会随机滚动显示三个单词。他们发现随着单词表变大，选单词这个逻辑变得越来越慢，甚至影响到了首页的打开速度。</p><p>现在对这个例子进行了简化：去掉每个级别的用户都有一个对应的单词表这个逻辑，直接就是从一个单词表中随机选出三个单词。</p><p><strong>内存临时表</strong></p><pre><code>mysql&gt; select word from words order by rand() limit 3;</code></pre><p>这个语句的意思很直白，随机排序取前3个。使用explain命令来看看这个语句的执行情况。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421201253209.png" alt></p><p>对于内存表， 回表过程只是简单地根据数据行的位置， 直接访问内存得到数据， 根本不会导致多访问磁盘。</p><p>这条语句的执行流程是这样的：</p><ol><li>创建一个临时表。这个临时表使用的是memory引擎，表里有两个字段，第一个字段是double类型，为了后面描述方便，记为字段R，第二个字段是varchar(64)类型，记为字段W。并且，这个表没有建索引。</li><li>从words表中，按主键顺序取出所有的word值。对于每一个word值，调用rand()函数生成一个大于0小于1的随机小数，并把这个随机小数和word分别存入临时表的R和W字段中，到此，扫描行数是10000。</li><li>现在临时表有10000行数据了，接下来你要在这个没有索引的内存临时表上，按照字段R排序。</li><li>初始化 sort_buffer。sort_buffer中有两个字段，一个是double类型，另一个是整型。</li><li>从内存临时表中一行一行地取出R值和位置信息（我后面会和你解释这里为什么是“位置信息”），分别存入sort_buffer中的两个字段里。这个过程要对内存临时表做全表扫描，此时扫描行数增加10000，变成了20000。</li><li>在sort_buffer中根据R的值进行排序。注意，这个过程没有涉及到表操作，所以不会增加扫描行数。</li><li>排序完成后，取出前三个结果的位置信息，依次到内存临时表中取出word值，返回给客户端。这个过程中，访问了表的三行数据，总扫描行数变成了20003。</li></ol><p>接下来，我们通过慢查询日志（slow log）来验证一下我们分析得到的扫描行数是否正确。</p><pre><code># Query_time: 0.900376  Lock_time: 0.000347 Rows_sent: 3 Rows_examined: 20003SET timestamp=1541402277;select word from words order by rand() limit 3;</code></pre><p>其中，Rows_examined：20003就表示这个语句执行过程中扫描了20003行，也就验证了我们分析得出的结论。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421201352186.png" alt></p><p><strong>总结：order by rand()使用了内存临时表，内存临时表排序的时候使用了rowid排序方法。</strong></p><p>MySQL的表是用什么方法来定位“一行数据”的。 如果你创建的表没有主键， 或者把一个表的主键删掉了， 那么InnoDB会自己生成一个长度为6字节的rowid来作为主键</p><h2 id="18-为什么这些SQL语句逻辑相同，-性能却差异巨大？"><a href="#18-为什么这些SQL语句逻辑相同，-性能却差异巨大？" class="headerlink" title="18 | 为什么这些SQL语句逻辑相同， 性能却差异巨大？"></a><strong>18 | 为什么这些SQL语句逻辑相同，</strong> <strong>性能却差异巨大？</strong></h2><p>【索引失效】</p><p>案例一： 条件字段函数操作</p><p>对索引字段做函数操作， 可能会破坏索引值的有序性， 因此优化器就决定放弃走树搜索功能。</p><p>案例二： 隐式类型转换</p><p>数据类型转换的规则是什么？<br>为什么有数据类型转换， 就需要走全索引扫描？</p><p>在MySQL中， 字符串和数字做比较的话， 是将字符串转换成数字</p><p>案例三： 隐式字符编码转换</p><p>其实是在说同一件事儿， 即： 对索引字段做函数操作， 可能会破坏索引值的有序性， 因此优化器就决定放弃走树搜索功能。</p><h2 id="19-为什么我只查一行的语句，-也执行这么慢？"><a href="#19-为什么我只查一行的语句，-也执行这么慢？" class="headerlink" title="19 | 为什么我只查一行的语句， 也执行这么慢？"></a><strong>19 | 为什么我只查一行的语句，</strong> <strong>也执行这么慢？</strong></h2><p>【锁住了or长事务】</p><p>套路：分析问题，验证问题，解决问题。</p><p>有些情况下， “查一行”， 也会执行得特别慢。</p><p><strong>第一类：</strong> <strong>查询长时间不返回</strong></p><p>如图1所示， 在表t执行下面的SQL语句：</p><pre><code>mysql&gt; select * from t where id=1;</code></pre><p>查询结果长时间不返回。一般碰到这种情况的话， 大概率是表t被锁住了。</p><p>接下来分析原因的时候， 一般都是首先执行一下show processlist命令， 看看当前语句处于什么状态。然后我们再针对每种状态， 去分析它们产生的原因、 如何复现， 以及如何处理。</p><p><strong>等MDL锁</strong></p><p>使用show processlist命令查看Waiting for table metadata lock。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421201745437.png" alt></p><p>出现这个状态表示的是， 现在有一个线程正在表t上请求或者持有MDL写锁， 把select语句堵住了。</p><p>解决方法：就是找到谁持有MDL写锁，然后把它kill掉。</p><p>通过查询sys.schema_table_lock_waits这张表，我们就可以直接找出造成阻塞的process id，把这个连接用kill 命令断开即可。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421201712264.png" alt></p><p><strong>等flush</strong></p><pre><code>mysql&gt; select * from information_schema.processlist where id=1;</code></pre><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421201753947.png" alt></p><p>使用show processlist排查。</p><p><strong>等行锁</strong></p><p>现在， 经过了表级锁的考验， 我们的select 语句终于来到引擎里了。</p><pre><code>mysql&gt; select * from t where id=1 lock in share mode;</code></pre><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421201839042.png" alt></p><p>解决方法：</p><p>通过sys.innodb_lock_waits 表查出是谁占着这个写锁</p><pre><code>mysql&gt; select * from t sys.innodb_lock_waits where locked_table=`&#39;test&#39;.&#39;t&#39;`\G</code></pre><p>然后直接断开这个连接。</p><p><strong>第二类：</strong> <strong>查询慢</strong></p><pre><code>mysql&gt; select * from t where id=1；</code></pre><p>虽然扫描行数是1， 但执行时间却长达800毫秒。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421202203454.png" alt></p><pre><code>select * from t where id=1 lock in share mode</code></pre><p>执行时扫描行数也是1行， 执行时间是0.2毫秒。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421202228245.png" alt></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421202237859.png" alt></p><p>先猜测下，再往下看。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421202245363.png" alt></p><p>session A先用start transaction with consistent snapshot命令启动了一个事务， 之后session B才开始执行update 语句。</p><p>session B执行完100万次update语句后， id=1这一行处于什么状态呢？</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421202312908.png" alt></p><p>session B更新完100万次，生成了100万个回滚日志(undo log)。</p><p>带lock in share mode的SQL语句，是当前读，因此会直接读到1000001这个结果，所以速度很快；而select * from t where id=1这个语句，是一致性读，因此需要从1000001开始，依次执行undo log，执行了100万次以后，才将1这个结果返回。</p><h2 id="20-幻读是什么，-幻读有什么问题？"><a href="#20-幻读是什么，-幻读有什么问题？" class="headerlink" title="20 | 幻读是什么， 幻读有什么问题？"></a><strong>20 | 幻读是什么，</strong> <strong>幻读有什么问题？</strong></h2><p>【是什么？会出现什么问题？数据库又是怎么解决的？】</p><p>前提：可重复读隔离级别下的，间隙锁才会发生。</p><p><strong>幻读是什么？</strong></p><pre><code>CREATE TABLE `t` (  `id` int(11) NOT NULL,  `c` int(11) DEFAULT NULL,  `d` int(11) DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `c` (`c`)) ENGINE=InnoDB;insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25);</code></pre><p>这个表除了主键id外，还有一个索引c，初始化语句在表中插入了6行数据。</p><p>现在，我们就来分析一下，如果只在id=5这一行加锁，而其他行的不加锁的话，会怎么样。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421202441948.png" alt></p><p>可以看到， session A里执行了三次查询， 分别是Q1、 Q2和Q3。 它们的SQL语句相同， 都是select * from t where d=5 for update。 查所有d=5的行， 而且使用的是当前读， 并且加上写锁。</p><ol><li>Q1只返回id=5这一行；</li><li>在T2时刻，session B把id=0这一行的d值改成了5，因此T3时刻Q2查出来的是id=0和id=5这两行；</li><li>在T4时刻，session C又插入一行（1,1,5），因此T5时刻Q3查出来的是id=0、id=1和id=5的这三行。</li></ol><p>其中， Q3读到id=1这一行的现象， 被称为“幻读”。</p><p><strong>幻读指的是一个事务在前后两次查询同一个范围的时候， 后一次查询看到了前一次查询没有看到的行。</strong></p><p><strong>说明</strong></p><ol><li>在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。</li><li>上面session B的修改结果，被session A之后的select语句用“当前读”看到，不能称为幻读。<strong>幻读仅专指“新插入的行”。</strong></li></ol><p><strong>幻读有什么问题？</strong></p><p>会导致数据不一致问题。</p><p>下面这个例子非常好。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421202546044.png" alt></p><p>分析一下上图</p><ol><li>经过T1时刻，id=5这一行变成 (5,5,100)，当然这个结果最终是在T6时刻正式提交的;</li><li>经过T2时刻，id=0这一行变成(0,5,5);</li><li>经过T4时刻，表里面多了一行(1,5,5);</li><li>其他行跟这个执行序列无关，保持不变。</li></ol><p>这些数据也没啥问题，但是我们来看看binlog里面的内容。</p><ol><li>T2时刻，session B事务提交，写入了两条语句；</li><li>T4时刻，session C事务提交，写入了两条语句；</li><li>T6时刻，session A事务提交，写入了update t set d=100 where d=5 这条语句。</li></ol><pre><code>update t set d=5 where id=0; /*(0,0,5)*/update t set c=5 where id=0; /*(0,5,5)*/insert into t values(1,1,5); /*(1,1,5)*/update t set c=5 where id=1; /*(1,5,5)*/update t set d=100 where d=5;/*所有d=5的行，d改成100*/</code></pre><p>好，你应该看出问题了。这个语句序列，不论是拿到备库去执行，还是以后用binlog来克隆一个库，这三行的结果，都变成了 (0,5,100)、(1,5,100)和(5,5,100)。</p><p>也就是说，id=0和id=1这两行，发生了数据不一致。这个问题很严重，是不行的。</p><p><strong>如何解决幻读？</strong></p><p>行锁只能锁住行， 但是新插入记录这个动作， 要更新的是记录之间的“间隙”。 因此， 为了解决幻读问题， InnoDB只好引入新的锁， 也就是间隙锁(Gap Lock)。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421202915584.png" alt></p><p>解决办法：执行 select * from t where d=5 for update的时候， 就不止是给数据库中已有的6个记录加上了行锁， 还同时加了7个间隙锁。 这样就确保了无法再插入新的记录。也就是说这时候， 在一行行扫描的过程中， 不仅将给行加上了行锁， 还给行两边的空隙， 也加上了间隙锁。</p><p><strong>跟间隙锁存在冲突关系的， 是“往这个间隙中插入一个记录”这个操作。 间隙锁之间都不存在冲突关系</strong>。</p><p>间隙锁和行锁合称next-keylock， 每个next-keylock是前开后闭区间。 也就是说， 我们的表t初始化以后， 如果用select * from t for update要把整个表所有记录锁起来， 就形成了7个next-key lock， 分别是 (-∞,0]、 (0,5]、 (5,10]、 (10,15]、 (15,20]、 (20, 25]、 (25, +supremum]。</p><p>但是可能会有死锁的情况发生。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421203059813.png" alt></p><p>你看到了，其实都不需要用到后面的update语句，就已经形成死锁了。我们按语句执行顺序来分析一下：</p><ol><li>session A 执行select … for update语句，由于id=9这一行并不存在，因此会加上间隙锁(5,10);</li><li>session B 执行select … for update语句，同样会加上间隙锁(5,10)，间隙锁之间不会冲突，因此这个语句可以执行成功；</li><li>session B 试图插入一行(9,9,9)，被session A的间隙锁挡住了，只好进入等待；</li><li>session A试图插入一行(9,9,9)，被session B的间隙锁挡住了。</li></ol><p>至此，两个session进入互相等待状态，形成死锁。当然，InnoDB的死锁检测马上就发现了这对死锁关系，让session A的insert语句报错返回了。</p><p>最后，这节分析的问题都是在可重复读隔离级别下的，间隙锁是在可重复读隔离级别下才会生效的。所以，你如果把隔离级别设置为读提交的话，就没有间隙锁了。但同时，你要解决可能出现的数据和日志不一致问题，需要把binlog格式设置为row。这也是现在不少公司使用的配置组合。</p><h2 id="21-为什么我只改一行的语句，-锁这么多？"><a href="#21-为什么我只改一行的语句，-锁这么多？" class="headerlink" title="21 | 为什么我只改一行的语句， 锁这么多？"></a><strong>21 | 为什么我只改一行的语句，</strong> <strong>锁这么多？</strong></h2><p>【重点】</p><p><strong>以下默认是可重复读隔离级别。</strong></p><ol><li>原则1：加锁的基本单位是next-key lock。希望你还记得，next-key lock是前开后闭区间。</li><li>原则2：查找过程中访问到的对象才会加锁。</li><li>优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。</li><li>优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。</li><li>一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li></ol><p>该节有许多经典案例，回到平台文章细看，就不再这里一一列举。</p><h2 id="22-MySQL有哪些“饮鸩止渴”提高性能的方法？"><a href="#22-MySQL有哪些“饮鸩止渴”提高性能的方法？" class="headerlink" title="22 | MySQL有哪些“饮鸩止渴”提高性能的方法？"></a><strong>22 | MySQL有哪些“饮鸩止渴”提高性能的方法？</strong></h2><p>第一种方法： 先处理掉那些占着连接但是不工作的线程。</p><p>第二种方法： 减少连接过程的消耗。</p><p><strong>慢查询性能问题</strong></p><p>导致慢查询的第一种可能是， 索引没有设计好。</p><p>导致慢查询的第二种可能是， 语句没写好。</p><p><strong>QPS突增问题</strong></p><ol><li>一种是由全新业务的bug导致的。假设你的DB运维是比较规范的，也就是说白名单是一个个加的。这种情况下，如果你能够确定业务方会下掉这个功能，只是时间上没那么快，那么就可以从数据库端直接把白名单去掉。</li><li>如果这个新功能使用的是单独的数据库用户，可以用管理员账号把这个用户删掉，然后断开现有连接。这样，这个新功能的连接不成功，由它引发的QPS就会变成0。</li><li>如果这个新增的功能跟主体功能是部署在一起的，那么我们只能通过处理语句来限制。这时，我们可以使用上面提到的查询重写功能，把压力最大的SQL语句直接重写成”select 1”返回。</li></ol><h2 id="23-MySQL是怎么保证数据不丢的？"><a href="#23-MySQL是怎么保证数据不丢的？" class="headerlink" title="23 | MySQL是怎么保证数据不丢的？"></a><strong>23 | MySQL是怎么保证数据不丢的？</strong></h2><p>【日志】</p><p>只要redo log和binlog保证持久化到磁盘， 就能确保MySQL异常重启后， 数据可以恢复。</p><p><strong>binlog的写入机制</strong></p><p>事务执行过程中， 先把日志写到binlog cache， 事务提交的时候， 再把binlog cache写到binlog文件中。</p><p>一个事务的binlog是不能被拆开的， 因此不论这个事务多大， 也要确保一次性写入。</p><p>系统给binlog cache分配了一片内存， 每个线程一个， 参数 binlog_cache_size用于控制单个线程内binlog cache所占内存的大小。 如果超过了这个参数规定的大小， 就要暂存到磁盘。事务提交的时候， 执行器把binlog cache里的完整事务写入到binlog中， 并清空binlog cache。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421203459314.png" alt></p><p><strong>每个线程有自己binlog cache， 但是共用同一份binlog文件。</strong></p><p>图中的write， 指的就是指把日志写入到文件系统的page cache， 并没有把数据持久化到磁盘， 所以速度比较快。</p><p>图中的fsync， 才是将数据持久化到磁盘的操作。 一般情况下， 我们认为fsync才占磁盘的IOPS。</p><p><strong>redo log的写入机制</strong></p><p>事务在执行过程中， 生成的redolog是要先写到redo log buffer的。 redo log buffer里面的内容， 是不是每次生成后都要直接持久化到磁盘呢？答案是， 不需要。如果事务执行期间MySQL发生异常重启， 那这部分日志就丢了。 由于事务并没有提交， 所以这时日志丢了也不会有损失。事务还没提交的时候， redo log buffer中的部分日志有没有可能被持久化到磁盘呢？答案是， 确实会有。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421203632190.png" alt></p><p>这三种状态分别是：</p><ol><li>存在redo log buffer中，物理上是在MySQL进程内存中，就是图中的红色部分；</li><li>写到磁盘(write)，但是没有持久化（fsync)，物理上是在文件系统的page cache里面，也就是图中的黄色部分；</li><li>持久化到磁盘，对应的是hard disk，也就是图中的绿色部分。</li></ol><p>日志写到redo log buffer是很快的， wirte到page cache也差不多， 但是持久化到磁盘的速度就慢多了。</p><p>为了控制redo log的写入策略，InnoDB提供了innodb_flush_log_at_trx_commit参数，它有三种可能取值：</p><ol><li>设置为0的时候，表示每次事务提交时都只是把redo log留在redo log buffer中;</li><li>设置为1的时候，表示每次事务提交时都将redo log直接持久化到磁盘；</li><li>设置为2的时候，表示每次事务提交时都只是把redo log写到page cache。</li></ol><p>InnoDB有一个后台线程，每隔1秒，就会把redo log buffer中的日志，调用write写到文件系统的page cache，然后调用fsync持久化到磁盘。</p><p>注意，事务执行中间过程的redo log也是直接写在redo log buffer中的，这些redo log也会被后台线程一起持久化到磁盘。也就是说，一个没有提交的事务的redo log，也是可能已经持久化到磁盘的。</p><p>实际上，除了后台线程每秒一次的轮询操作外，还有两种场景会让一个没有提交的事务的redo log写入到磁盘中。</p><ul><li><strong>一种是，redo log buffer占用的空间即将达到 innodb_log_buffer_size一半的时候，后台线程会主动写盘。</strong></li><li><strong>另一种是，并行的事务提交的时候，顺带将这个事务的redo log buffer持久化到磁盘。</strong></li></ul><p>如果把innodb_flush_log_at_trx_commit设置成1，那么redo log在prepare阶段就要持久化一次，因为有一个崩溃恢复逻辑是要依赖于prepare 的redo log，再加上binlog来恢复的。</p><p>每秒一次后台轮询刷盘，再加上崩溃恢复这个逻辑，InnoDB就认为redo log在commit的时候就不需要fsync了，只会write到文件系统的page cache中就够了。</p><p><strong>通常我们说MySQL的“双1”配置，指的就是sync_binlog和innodb_flush_log_at_trx_commit都设置成 1。也就是说，一个事务完整提交前，需要等待两次刷盘，一次是redo log（prepare 阶段），一次是binlog。</strong></p><p>其实到这里，我的理解是本质就是2次刷盘磁盘，但是加了buffer进行优化，提高效率。</p><p><strong>组提交</strong></p><p>三个并发事务(trx1, trx2, trx3)在prepare 阶段， 都写完redo log buffer， 持久化到磁盘的过程， 对应的LSN分别是50、 120 和160。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421203939757.png" alt></p><p>从图中可以看到，</p><ol><li>trx1是第一个到达的，会被选为这组的 leader；</li><li>等trx1要开始写盘的时候，这个组里面已经有了三个事务，这时候LSN也变成了160；</li><li>trx1去写盘的时候，带的就是LSN=160，因此等trx1返回时，所有LSN小于等于160的redo log，都已经被持久化到磁盘；</li><li>这时候trx2和trx3就可以直接返回了。</li></ol><p>所以，一次组提交里面，组员越多，节约磁盘IOPS的效果越好。</p><p>WAL机制主要得益于两个方面：</p><ol><li>redo log 和 binlog都是顺序写，磁盘的顺序写比随机写速度要快；</li><li>组提交机制，可以大幅度降低磁盘的IOPS消耗。【磁盘IOPS：磁盘IOPS是指一秒内磁盘进行多少次I/O读写；】</li></ol><p><strong>如果你的MySQL现在出现了性能瓶颈，</strong> <strong>而且瓶颈在IO上，</strong> <strong>可以通过哪些方法来提升性能呢？</strong></p><ol><li>设置 binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count参数，减少binlog的写盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但没有丢失数据的风险。</li><li>将sync_binlog 设置为大于1的值（比较常见是100~1000）。这样做的风险是，主机掉电时会丢binlog日志。</li><li>将innodb_flush_log_at_trx_commit设置为2。这样做的风险是，主机掉电的时候会丢数据。</li></ol><h2 id="24-MySQL是怎么保证主备一致的？"><a href="#24-MySQL是怎么保证主备一致的？" class="headerlink" title="24 | MySQL是怎么保证主备一致的？"></a><strong>24 | MySQL是怎么保证主备一致的？</strong></h2><p>【日志】</p><p>binlog对主备一致贡献非常的大。</p><p><strong>MySQL主备的基本原理</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421204119341.png" alt></p><p>节点A到B这条线的内部流程是什么样的。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421204125172.png" alt></p><p>主库接收到客户端的更新请求后，执行内部事务的更新逻辑，同时写binlog。</p><p>备库B跟主库A之间维持了一个长连接。主库A内部有一个线程，专门用于服务备库B的这个长连接。一个事务日志同步的完整过程是这样的：</p><ol><li>在备库B上通过change master命令，设置主库A的IP、端口、用户名、密码，以及要从哪个位置开始请求binlog，这个位置包含文件名和日志偏移量。</li><li>在备库B上执行start slave命令，这时候备库会启动两个线程，就是图中的io_thread和sql_thread。其中io_thread负责与主库建立连接。</li><li>主库A校验完用户名、密码后，开始按照备库B传过来的位置，从本地读取binlog，发给B。</li><li>备库B拿到binlog后，写到本地文件，称为中转日志（relay log）。</li><li>sql_thread读取中转日志，解析出日志里的命令，并执行。</li></ol><p><strong>binlog的三种格式</strong></p><p>当binlog_format=statement时， binlog里面记录的就是SQL语句的原文。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421204210641.png" alt></p><p>把binlog的格式改为binlog_format=‘row’</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421204223526.png" alt></p><p>row格式的binlog里没有了SQL语句的原文， 而是替换成了两个event： Table_map和Delete_rows</p><p><strong>为什么会有mixed这种binlog格式的存在场景？</strong></p><ul><li>因为有些statement格式的binlog可能会导致主备不一致，所以要使用row格式。</li><li>但row格式的缺点是，很占空间。比如你用一个delete语句删掉10万行数据，用statement的话就是一个SQL语句被记录到binlog中，占用几十个字节的空间。但如果用row格式的binlog，就要把这10万条记录都写到binlog中。这样做，不仅会占用更大的空间，同时写binlog也要耗费IO资源，影响执行速度。</li><li>所以，MySQL就取了个折中方案，也就是有了mixed格式的binlog。<strong>mixed格式的意思是，MySQL自己会判断这条SQL语句是否可能引起主备不一致，如果有可能，就用row格式，否则就用statement格式。</strong></li></ul><p><strong>循环复制问题</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421204300198.png" alt></p><p>双M结构和M-S结构， 其实区别只是多了一条线， 即： 节点A和B之间总是互为主备关系。 这样在切换的时候就不用再修改主备关系。</p><p>业务逻辑在节点A上更新了一条语句， 然后再把生成的binlog 发给节点B， 节点B执行完这条更新语句后也会生成binlog。如果节点A同时是节点B的备库， 相当于又把节点B新生成的binlog拿过来执行了一次， 然后节点A和B间， 会不断地循环执行这个更新语句， 也就是循环复制了。 这个要怎么解决呢？</p><p>MySQL在binlog中记录了这个命令第一次执行时所在实例的serverid。 因此， 我们可以用下面的逻辑， 来解决两个节点间的循环复制的问题：</p><ol><li>规定两个库的server id必须不同，如果相同，则它们之间不能设定为主备关系；</li><li>一个备库接到binlog并在重放的过程中，生成与原binlog的server id相同的新的binlog；</li><li>每个库在收到从自己的主库发过来的日志后，先判断server id，如果跟自己的相同，表示这个日志是自己生成的，就直接丢弃这个日志。</li></ol><p>按照这个逻辑，如果我们设置了双M结构，日志的执行流就会变成这样：</p><ol><li>从节点A更新的事务，binlog里面记的都是A的server id；</li><li>传到节点B执行一次以后，节点B生成的binlog 的server id也是A的server id；</li><li>再传回给节点A，A判断到这个server id与自己的相同，就不会再处理这个日志。所以，死循环在这里就断掉了。</li></ol><h2 id="25-MySQL是怎么保证高可用的？"><a href="#25-MySQL是怎么保证高可用的？" class="headerlink" title="25 | MySQL是怎么保证高可用的？"></a><strong>25 | MySQL是怎么保证高可用的？</strong></h2><p>【就是主备低延时】</p><p>正常情况下， 只要主库执行更新生成的所有binlog， 都可以传到备库并被正确地执行， 备库就能达到跟主库一致的状态， 这就是最终一致性。</p><p><strong>主备延迟</strong></p><p>主备切换可能是一个主动运维动作， 比如软件升级、 主库所在机器按计划下线等， 也可能是被动操作， 比如主库所在机器掉电。</p><p>与数据同步有关的时间点主要包括以下三个：</p><ol><li>主库A执行完成一个事务，写入binlog，我们把这个时刻记为T1;</li><li>之后传给备库B，我们把备库B接收完这个binlog的时刻记为T2;</li><li>备库B执行完成这个事务，我们把这个时刻记为T3。</li></ol><p>所谓主备延迟， 就是同一个事务， 在备库执行完成的时间和主库执行完成的时间之间的差值， 也就是T3-T1。</p><p>你可以在备库上执行show slave status命令，它的返回结果里面会显示seconds_behind_master，用于表示当前备库延迟了多少秒。</p><p><strong>seconds_behind_master</strong>的计算方法是这样的：</p><ol><li>每个事务的binlog 里面都有一个时间字段，用于记录主库上写入的时间；</li><li>备库取出当前正在执行的事务的时间字段的值，计算它与当前系统时间的差值，得到seconds_behind_master。</li></ol><p>可以看到，其实seconds_behind_master这个参数计算的就是T3-T1。所以，我们可以用seconds_behind_master来作为主备延迟的值，这个值的时间精度是秒。</p><p><strong>主备延迟最直接的表现是，备库消费中转日志（relay log）的速度，比主库生产binlog的速度要慢。</strong></p><p>下面来说说常见的例子。</p><p><strong>主备延迟的来源</strong></p><ol><li>备库所在机器的性能要比主库所在的机器性能差。</li><li>备库的压力大：备库上的查询耗费了大量的CPU资源， 影响了同步速度， 造成主备延迟</li></ol><ul><li>一主多从。除了备库外，可以多接几个从库，让这些从库来分担读的压力。</li><li>通过binlog输出到外部系统，比如Hadoop这类系统，让外部系统提供统计类查询的能力。</li></ul><ol><li>大事务</li></ol><p><strong>可靠性优先策略</strong></p><p>双M结构下， 从状态1到状态2切换的详细过程是这样的：</p><ol><li>判断备库B现在的seconds_behind_master，如果小于某个值（比如5秒）继续下一步，否则持续重试这一步；</li><li>把主库A改成只读状态，即把readonly设置为true；</li><li>判断备库B的seconds_behind_master的值，直到这个值变成0为止；</li><li>把备库B改成可读写状态，也就是把readonly 设置为false；</li><li>把业务请求切到备库B。</li></ol><p>这个切换流程， 一般是由专门的HA系统来完成的， 我们暂时称之为可靠性优先流程。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421204637780.png" alt></p><p><strong>可用性优先策略</strong></p><p>强行把步骤4、 5调整到最开始执行， 也就是说不等主备数据同步， 直接把连接切到备库B， 并且让备库B可以读写， 那么系统几乎就没有不可用时间了。我们把这个切换流程， 暂时称作<strong>可用性优先</strong>流程。 这个切换流程的代价， 就是可能出现数据不一致的情况。</p><p><strong>可用性优先策略，且binlog_format=mixed</strong>时的切换流程和数据结果。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421204731138.png" alt></p><p>现在，我们一起分析下这个切换流程：</p><ol><li>步骤2中，主库A执行完insert语句，插入了一行数据（4,4），之后开始进行主备切换。</li><li>步骤3中，由于主备之间有5秒的延迟，所以备库B还没来得及应用“插入c=4”这个中转日志，就开始接收客户端“插入 c=5”的命令。</li><li>步骤4中，备库B插入了一行数据（4,5），并且把这个binlog发给主库A。</li><li>步骤5中，备库B执行“插入c=4”这个中转日志，插入了一行数据（5,4）。而直接在备库B执行的“插入c=5”这个语句，传到主库A，就插入了一行新数据（5,5）。</li></ol><p>最后的结果就是，主库A和备库B上出现了两行不一致的数据。可以看到，这个数据不一致，是由可用性优先流程导致的。</p><p><strong>可用性优先策略，但设置binlog_format=row</strong>时的切换流程和数据结果。</p><p>因为row格式在记录binlog的时候，会记录新插入的行的所有字段值，所以最后只会有一行不一致。而且，两边的主备同步的应用线程会报错duplicate key error并停止。也就是说，这种情况下，备库B的(5,4)和主库A的(5,5)这两行数据，都不会被对方执行。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421204815379.png" alt></p><p>结论：</p><ol><li>使用row格式的binlog时，数据不一致的问题更容易被发现。而使用mixed或者statement格式的binlog时，数据很可能悄悄地就不一致了。如果你过了很久才发现数据不一致的问题，很可能这时的数据不一致已经不可查，或者连带造成了更多的数据逻辑不一致。</li><li>主备切换的可用性优先策略会导致数据不一致。因此，大多数情况下，我都建议你使用可靠性优先策略。毕竟对数据服务来说的话，数据的可靠性一般还是要优于可用性的。</li></ol><p>MySQL高可用系统的可用性，是依赖于主备延迟的。延迟的时间越小，在主库故障的时候，服务恢复需要的时间就越短，可用性就越高。</p><h2 id="26-备库为什么会延迟好几个小时？"><a href="#26-备库为什么会延迟好几个小时？" class="headerlink" title="26 | 备库为什么会延迟好几个小时？"></a><strong>26 | 备库为什么会延迟好几个小时？</strong></h2><p>【中转日志消费不够快】</p><p>如果备库执行日志的速度持续低于主库生成日志的速度， 那这个延迟就有可能成了小时级别。 而且对于一个压力持续比较高的主库来说， 备库很可能永远都追不上主库的节奏。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421205013154.png" alt></p><p>coordinator在分发的时候， 需要满足以下这两个基本要求：</p><ol><li>不能造成更新覆盖。 这就要求更新同一行的两个事务， 必须被分发到同一个worker中。</li><li>同一个事务不能被拆开， 必须放到同一个worker中。</li></ol><p><strong>MySQL 5.5版本的并行复制策略</strong></p><p><strong>按表分发策略</strong></p><p>按表分发事务的基本思路是， 如果两个事务更新不同的表， 它们就可以并行。 因为数据是存储在表里的， 所以按表分发， 可以保证两个worker不会更新同一行。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421205026348.png" alt></p><p><strong>按行分发策略</strong></p><p>要解决热点表的并行复制问题， 就需要一个按行并行复制的方案。 按行复制的核心思路是： 如果两个事务没有更新相同的行， 它们在备库上可以并行执行。 显然， 这个模式要求binlog格式必须是row。</p><p>相比于按表并行分发策略， 按行并行策略在决定线程分发的时候， 需要消耗更多的计算资源。</p><p><strong>MySQL 5.6版本的并行复制策略</strong></p><p>官方MySQL5.6版本， 支持了并行复制， 只是支持的粒度是按库并行。这个策略的并行效果， 取决于压力模型。 如果在主库上有多个DB， 并且各个DB的压力均衡， 使用这个策略的效果会很好。</p><p><strong>MySQL 5.7的并行复制策略</strong></p><p>MySQL 5.7并行复制策略的思想是：</p><ol><li>同时处于prepare状态的事务， 在备库执行时是可以并行的；</li><li>处于prepare状态的事务， 与处于commit状态的事务之间， 在备库执行时也是可以并行的。</li></ol><p>为什么要有多线程复制呢？ 这是因为单线程复制的能力全面低于多线程复制， 对于更新压力较大的主库， 备库是可能一直追不上主库的。 从现象上看就是， 备库上seconds_behind_master的值越来越大。</p><h2 id="27-主库出问题了，-从库怎么办？"><a href="#27-主库出问题了，-从库怎么办？" class="headerlink" title="27 | 主库出问题了， 从库怎么办？"></a><strong>27 | 主库出问题了，</strong> <strong>从库怎么办？</strong></h2><p>【主备切换，日志从哪开始同步问题】</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421205036452.png" alt></p><p>图中， 虚线箭头表示的是主备关系， 也就是A和A’互为主备， 从库B、 C、 D指向的是主库A。一主多从的设置， 一般用于读写分离， 主库负责所有的写入和一部分读， 其他的读请求则由从库分担。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421205046203.png" alt></p><p>相比于一主一备的切换流程， 一主多从结构在切换完成后， A’会成为新的主库， 从库B、 C、 D也要改接到A’。 正是由于多了从库B、 C、 D重新指向的这个过程， 所以主备切换的复杂性也相应增加了。</p><p><strong>基于位点的主备切换</strong></p><p>之所以需要这个，是因为从库要换连接的主库，我认为这个位点是之后备库A‘和从库开始同步的位置。</p><p>一种取同步位点的方法是这样的：</p><ol><li>等待新主库A’把中转日志（relay log）全部同步完成；</li><li>在A’上执行show master status命令，得到当前A’上最新的File 和 Position；</li><li>取原主库A故障的时刻T；</li><li>用mysqlbinlog工具解析A’的File，得到T时刻的位点。</li></ol><pre><code>mysqlbinlog File --stop-datetime=T --start-datetime=T</code></pre><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421205402957.png" alt></p><p>当然这个值并不精确。为什么呢？</p><p>你可以设想有这么一种情况，假设在T这个时刻，主库A已经执行完成了一个insert 语句插入了一行数据R，并且已经将binlog传给了A’和B，然后在传完的瞬间主库A的主机就掉电了。</p><p>那么，这时候系统的状态是这样的：</p><ol><li>在从库B上，由于同步了binlog， R这一行已经存在；</li><li>在新主库A’上， R这一行也已经存在，日志是写在123这个位置之后的；</li><li>我们在从库B上执行change master命令，指向A’的File文件的123位置，就会把插入R这一行数据的binlog又同步到从库B去执行。</li></ol><p>这时候，从库B的同步线程就会报告 Duplicate entry ‘id_of_R’ for key ‘PRIMARY’ 错误，提示出现了主键冲突，然后停止同步。</p><p>因此，<strong>我们在切换任务的时候，要先主动跳过这些错误，有两种常用的方法。</strong></p><p><strong>一种做法是</strong>，主动跳过一个事务。跳过命令的写法是：</p><pre><code>set global sql_slave_skip_counter=1;start slave;</code></pre><p>因为切换过程中，可能会不止重复执行一个事务，所以我们需要在从库B刚开始接到新主库A’时，持续观察，每次碰到这些错误就停下来，执行一次跳过命令，直到不再出现停下来的情况，以此来跳过可能涉及的所有事务。</p><p><strong>另外一种方式是，</strong>通过设置slave_skip_errors参数，直接设置跳过指定的错误。</p><p>在执行主备切换时，有这么两类错误，是经常会遇到的：</p><ul><li>1062错误是插入数据时唯一键冲突；</li><li>1032错误是删除数据时找不到行。</li></ul><p>因此，我们可以把slave_skip_errors 设置为 “1032,1062”，这样中间碰到这两个错误时就直接跳过。</p><p><strong>GTID</strong></p><p>知道GTID的概念这部分就非常好理解了。</p><p><a href="https://www.bilibili.com/video/BV1rr4y1Q7uy?p=11&vd_source=d6efee335659a376be8deb6c0654e9f7">MySQL5.7 集群管理（主从复制、MHA、GTID、PXC）</a></p><ol><li>全局事务标识∶ global transaction identifiers。</li><li>GTID与事务——对应，并且全局唯一ID。</li><li>一个GTID在一个服务器上只执行一次。</li><li>MySQL-5.6.5开始支持GTID。</li></ol><p>组成：GTID = server_uuid : transaction_id</p><p>binlog和GTID的关系</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421205708126.png" alt></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421205835872.png" alt></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421205853616.png" alt></p><h2 id="28-读写分离有哪些坑？"><a href="#28-读写分离有哪些坑？" class="headerlink" title="28 | 读写分离有哪些坑？"></a><strong>28 | 读写分离有哪些坑？</strong></h2><p>【从库没有同步到位】</p><p>由于主从可能存在延迟，客户端执行完一个更新事务后马上发起查询，如果查询选择的是从库的话，就有可能读到刚刚的事务更新之前的状态。我们称这种读为过期读。</p><p><strong>强制走主库方案</strong></p><p>我们可以将查询请求分为这么两类：</p><ol><li>对于必须要拿到最新结果的请求， 强制将其发到主库上。 比如， 在一个交易平台上， 卖家发布商品以后， 马上要返回主页面， 看商品是否发布成功。 那么， 这个请求需要拿到最新的结果， 就必须走主库。</li><li>对于可以读到旧数据的请求， 才将其发到从库上。 在这个交易平台上， 买家来逛商铺页面，就算晚几秒看到最新发布的商品， 也是可以接受的。 那么， 这类请求就可以走从库。</li></ol><p><strong>Sleep 方案</strong></p><p>主库更新后， 读从库之前先sleep一下。</p><p><strong>判断主备无延迟方案</strong></p><p>第一种确保主备无延迟的方法是， 每次从库执行查询请求前， 先判断seconds_behind_master是否已经等于0。 如果还不等于0 ， 那就必须等到这个参数变为0才能执行查询请求 。</p><p>第二种方法， 对比位点确保主备无延迟 。</p><p>第三种方法， 对比GTID集合确保主备无延迟 。</p><p><strong>等主库位点方案</strong></p><pre><code>select master_pos_wait(file, pos[, timeout]);</code></pre><p>这条命令的逻辑如下：</p><ol><li>它是在从库执行的；</li><li>参数file和pos指的是主库上的文件名和位置；</li><li>timeout可选，设置为正整数N表示这个函数最多等待N秒。</li></ol><p>这个命令正常返回的结果是一个正整数M，表示从命令开始执行，到应用完file和pos表示的binlog位置，执行了多少事务。</p><p>使用逻辑：</p><ol><li>trx1事务更新完成后，马上执行show master status得到当前主库执行到的File和Position；</li><li>选定一个从库执行查询语句；</li><li>在从库上执行select master_pos_wait(File, Position, 1)；</li><li>如果返回值是&gt;=0的正整数，则在这个从库执行查询语句；</li><li>否则，到主库执行查询语句。</li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421210118844.png" alt></p><p><strong>GTID方案</strong></p><pre><code>select wait_for_executed_gtid_set(gtid_set, 1);</code></pre><p>这条命令的逻辑是：</p><ol><li>等待，直到这个库执行的事务中包含传入的gtid_set，返回0；</li><li>超时返回1。</li></ol><p>等GTID的执行流程就变成了：</p><ol><li>trx1事务更新完成后，从返回包直接获取这个事务的GTID，记为gtid1；</li><li>选定一个从库执行查询语句；</li><li>在从库上执行 select wait_for_executed_gtid_set(gtid1, 1)；</li><li>如果返回值是0，则在这个从库执行查询语句；</li><li>否则，到主库执行查询语句。</li></ol><p>跟等主库位点的方案一样，等待超时后是否直接到主库查询，需要业务开发同学来做限流考虑。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421210204444.png" alt></p><h2 id="29-如何判断一个数据库是不是出问题了？"><a href="#29-如何判断一个数据库是不是出问题了？" class="headerlink" title="29 | 如何判断一个数据库是不是出问题了？"></a><strong>29 | 如何判断一个数据库是不是出问题了？</strong></h2><p>主备切换有两种场景， 一种是主动切换， 一种是被动切换。 而其中被动切换， 往往是因为主库出问题了， 由HA系统发起的。</p><p><strong>select 1判断</strong></p><p>实际上，select 1成功返回，只能说明这个库的进程还在，并不能说明主库没问题。</p><p><strong>查表判断</strong></p><p>为了能够检测InnoDB并发线程数过多导致的系统不可用情况， 我们需要找一个访问InnoDB的场景。 一般的做法是， 在系统库（mysql库） 里创建一个表， 比如命名为health_check， 里面只放一行数据， 然后定期执行：</p><pre><code>mysql&gt; select * from mysql.health_check;</code></pre><p>可能出现读没有问题，但是写存在问题，还是排查不够彻底。</p><p><strong>更新判断</strong></p><p>既然要更新，就要放个有意义的字段，常见做法是放一个timestamp字段，用来表示最后一次执行检测的时间。这条更新语句类似于：</p><pre><code>mysql&gt; update mysql.health_check set t_modified=now();</code></pre><p>节点可用性的检测都应该包含主库和备库。如果用更新来检测主库的话，那么备库也要进行更新检测。</p><p>但是这都是外部提供，我们可以通过使用数据库告诉我们内部的真实情况。</p><p><strong>内部统计</strong></p><p>MySQL 5.6版本以后提供的performance_schema库，就在file_summary_by_event_name表里统计了每次IO请求的时间。</p><h2 id="30-答疑文章（二）-：-用动态的观点看加锁"><a href="#30-答疑文章（二）-：-用动态的观点看加锁" class="headerlink" title="30 | 答疑文章（二） ： 用动态的观点看加锁"></a><strong>30 | 答疑文章（二）</strong> <strong>：</strong> <strong>用动态的观点看加锁</strong></h2><p>原则1： 加锁的基本单位是next-keylock。 希望你还记得， next-keylock是前开后闭区间。<br>原则2： 查找过程中访问到的对象才会加锁。<br>优化1： 索引上的等值查询， 给唯一索引加锁的时候， next-keylock退化为行锁。<br>优化2： 索引上的等值查询， 向右遍历时且最后一个值不满足等值条件的时候， next-keylock退化为间隙锁。<br>一个bug： 唯一索引上的范围查询会访问到不满足条件的第一个值为止。</p><h2 id="31-误删数据后除了跑路，-还能怎么办？"><a href="#31-误删数据后除了跑路，-还能怎么办？" class="headerlink" title="31 | 误删数据后除了跑路， 还能怎么办？"></a><strong>31 | 误删数据后除了跑路，</strong> <strong>还能怎么办？</strong></h2><p>先对和MySQL相关的误删数据， 做下分类：</p><ol><li>使用delete语句误删数据行；</li><li>使用drop table或者truncate table语句误删数据表；</li><li>使用drop database语句误删数据库；</li><li>使用rm命令误删整个MySQL实例。</li></ol><p>其实主要就是靠数据库记录的日志恢复。</p><p><strong>误删行</strong></p><p>具体恢复数据时， 对单个事务做如下处理：</p><ol><li>对于insert语句，对应的binlog event类型是Write_rows event，把它改成Delete_rows event即可；</li><li>同理，对于delete语句，也是将Delete_rows event改为Write_rows event；</li><li>而如果是Update_rows的话，binlog里面记录了数据行修改前和修改后的值，对调这两行的位置即可。</li></ol><p><strong>误删库/表</strong></p><p>这种情况下， 要想恢复数据， 就需要使用全量备份， 加增量日志的方式了。 这个方案要求线上有定期的全量备份， 并且实时备份binlog。在这两个条件都具备的情况下， 假如有人中午12点误删了一个库， 恢复数据的流程如下：</p><ol><li>取最近一次全量备份， 假设这个库是一天一备， 上次备份是当天0点；</li><li>用备份恢复出一个临时库；</li><li>从日志备份里面， 取出凌晨0点之后的日志；</li><li>把这些日志， 除了误删除数据的语句外， 全部应用到临时库。</li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421211155332.png" alt></p><p><strong>延迟复制备库</strong></p><p>我们可以考虑<strong>搭建延迟复制的备库。</strong>这个功能是MySQL 5.6版本引入的。</p><p>一般的主备复制结构存在的问题是，如果主库上有个表被误删了，这个命令很快也会被发给所有从库，进而导致所有从库的数据表也都一起被误删了。</p><p>延迟复制的备库是一种特殊的备库，通过 CHANGE MASTER TO MASTER_DELAY = N命令，可以指定这个备库持续保持跟主库有N秒的延迟。</p><p>比如你把N设置为3600，这就代表了如果主库上有数据被误删了，并且在1小时内发现了这个误操作命令，这个命令就还没有在这个延迟复制的备库执行。这时候到这个备库上执行stop slave，再通过之前介绍的方法，跳过误操作命令，就可以恢复出需要的数据。</p><p>这样的话，你就随时可以得到一个，只需要最多再追1小时，就可以恢复出数据的临时实例，也就缩短了整个数据恢复需要的时间。</p><p><strong>预防误删库/表的方法</strong></p><p>第一条建议是，账号分离。第二条建议是，制定操作规范。</p><p><strong>rm删除数据</strong></p><p>只要不是恶意地把整个集群删除， 而只是删掉了其中某一个节点的数据的话， HA系统就会开始工作， 选出一个新的主库， 从而保证整个集群的正常工作。这时， 你要做的就是在这个节点上把数据恢复回来， 再接入整个集群</p><h2 id="32-为什么还有kill不掉的语句？"><a href="#32-为什么还有kill不掉的语句？" class="headerlink" title="32 | 为什么还有kill不掉的语句？"></a><strong>32 | 为什么还有kill不掉的语句？</strong></h2><p>在MySQL中有两个kill命令： 一个是kill query+线程id， 表示终止这个线程中正在执行的语句； 一个是kill connection +线程id， 这里connection可缺省， 表示断开这个线程的连接， 当然如果这个线程有语句正在执行， 也是要先停止正在执行的语句的。不知道你在使用MySQL的时候， 有没有遇到过这样的现象： 使用了kill命令， 却没能断开这个连接。 再执行show processlist命令， 看到这条语句的Command列显示的是Killed。</p><p>kill并不是马上停止的意思， 而是告诉执行线程说， 这条语句已经不需要继续执行了，可以开始“执行停止的逻辑了”。</p><p>MySQL客户端发送请求后， 接收服务端返回结果的方式有两种：</p><ol><li>一种是本地缓存， 也就是在本地开一片内存， 先把结果存起来。 如果你用API开发， 对应的就是mysql_store_result 方法。</li><li>另一种是不缓存， 读一个处理一个。 如果你用API开发， 对应的就是mysql_use_result方法。</li></ol><h2 id="33-我查这么多数据，-会不会把数据库内存打爆？"><a href="#33-我查这么多数据，-会不会把数据库内存打爆？" class="headerlink" title="33 | 我查这么多数据， 会不会把数据库内存打爆？"></a><strong>33 | 我查这么多数据，</strong> <strong>会不会把数据库内存打爆？</strong></h2><p>其实这篇文章主要说的是MySQL是边读边发的，但是我认为和DBMS的buffer pool也有关系。</p><p><strong>全表扫描对server层的影响</strong></p><p>InnoDB的数据是保存在主键索引上的， 所以全表扫描实际上是直接扫描表t的主键索引。 这条查询语句由于没有其他的判断条件， 所以查到的每一行都可以直接放到结果集里面， 然后返回给客户端</p><p>实际上， 服务端并不需要保存一个完整的结果集。 取数据和发数据的流程是这样的：</p><ol><li>获取一行， 写到net_buffer中。 这块内存的大小是由参数net_buffer_length定义的， 默认是16k。</li><li>重复获取行， 直到net_buffer写满， 调用网络接口发出去。</li><li>如果发送成功， 就清空net_buffer， 然后继续取下一行， 并写入net_buffer。</li><li>如果发送函数返回EAGAIN或WSAEWOULDBLOCK， 就表示本地网络栈（socket send buffer） 写满了， 进入等待。 直到网络栈重新可写， 再继续发送。</li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421211458092.png" alt></p><p><strong>MySQL是“边读边发的”</strong>，这个概念很重要。这就意味着，如果客户端接收得慢，会导致MySQL服务端由于结果发不出去，这个事务的执行时间变长。</p><p>在show processlist命令中的State列的值一直处于<strong>“Sending to client”</strong>，就表示服务器端的网络栈写满了。</p><p><strong>对于正常的线上业务来说，如果一个查询的返回结果不会很多的话，我都建议你使用mysql_store_result这个接口，直接把查询结果保存到本地内存。</strong></p><p><strong>Sending data</strong>：它的意思只是“正在执行”。</p><p><strong>全表扫描对InnoDB的影响</strong></p><p>InnoDB内存管理用的是最近最少使用 (Least RecentlyUsed, LRU)算法， 这个算法的核心就是淘汰最久未使用的数据。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421211510369.png" alt></p><p>InnoDB不能直接使用这个LRU算法。 实际上， InnoDB对LRU算法做了改进。在InnoDB实现上， 按照5:3的比例把整个LRU链表分成了young区域和old区域。 图中LRU_old指向的就是old区域的第一个位置， 是整个链表的5/8处。 也就是说， 靠近链表头部的5/8是young区域， 靠近链表尾部的3/8是old区域。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421211516058.png" alt></p><p>改进后的LRU算法执行流程变成了下面这样。</p><ol><li>图7中状态1， 要访问数据页P3， 由于P3在young区域， 因此和优化前的LRU算法一样， 将其移到链表头部， 变成状态2。</li><li>之后要访问一个新的不存在于当前链表的数据页， 这时候依然是淘汰掉数据页Pm， 但是新插入的数据页Px， 是放在LRU_old处。</li><li>处于old区域的数据页， 每次被访问的时候都要做下面这个判断：若这个数据页在LRU链表中存在的时间超过了1秒， 就把它移动到链表头部；如果这个数据页在LRU链表中存在的时间短于1秒， 位置保持不变。 1秒这个时间， 是由参数innodb_old_blocks_time控制的。 其默认值是1000， 单位毫秒。</li></ol><p>我们看看改进后的LRU算法的操作逻辑：</p><ol><li>扫描过程中， 需要新插入的数据页， 都被放到old区域;</li><li>一个数据页里面有多条记录， 这个数据页会被多次访问到， 但由于是顺序扫描， 这个数据页第一次被访问和最后一次被访问的时间间隔不会超过1秒， 因此还是会被保留在old区域；</li><li>再继续扫描后续的数据， 之前的这个数据页之后也不会再被访问到， 于是始终没有机会移到链表头部（也就是young区域） ， 很快就会被淘汰出去。</li></ol><h2 id="34-到底可不可以使用join？"><a href="#34-到底可不可以使用join？" class="headerlink" title="34 | 到底可不可以使用join？"></a><strong>34 | 到底可不可以使用join？</strong></h2><p>在实际生产中， 关于join语句使用的问题， 一般会集中在以下两类：</p><ol><li>我们DBA不让使用join， 使用join有什么问题呢？</li><li>如果有两个大小不同的表做join， 应该用哪个表做驱动表呢？</li></ol><p><strong>Index Nested-Loop Join</strong></p><pre><code>select * from t1 straight_join t2 on (t1.a=t2.a);</code></pre><p>如果直接使用join语句， MySQL优化器可能会选择表t1或t2作为驱动表， 这样会影响我们分析SQL语句的执行过程。 所以， 为了便于分析执行过程中的性能问题， 我改用straight_join让MySQL使用固定的连接方式执行查询， 这样优化器只会按照我们指定的方式去join。 在这个语句里， t1 是驱动表， t2是被驱动表。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421212736792.png" alt></p><p>可以看到， 在这条语句里， 被驱动表t2的字段a上有索引， join过程用上了这个索引， 因此这个语句的执行流程是这样的：</p><ol><li>从表t1中读入一行数据 R；</li><li>从数据行R中， 取出a字段到表t2里去查找；</li><li>取出表t2中满足条件的行， 跟R组成一行， 作为结果集的一部分；</li><li>重复执行步骤1到3， 直到表t1的末尾循环结束。</li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421212800908.png" alt></p><p>对比用单表查询怎么实现。</p><ol><li>执行select * from t1，查出表t1的所有数据，这里有100行；</li><li>循环遍历这100行数据：<ul><li>从每一行R取出字段a的值$R.a；</li><li>执行select * from t2 where a=$R.a；</li><li>把返回的结果和R构成结果集的一行。</li></ul></li></ol><p>可以看到，在这个查询过程，也是扫描了200行，但是总共执行了101条语句，比直接join多了100次交互。除此之外，客户端还要自己拼接SQL语句和结果。</p><p>结论：</p><ol><li>使用join语句， 性能比强行拆成多个单表执行SQL语句的性能要好；</li><li>如果使用join语句的话， 需要让小表做驱动表。</li></ol><p><strong>Simple Nested-Loop Join</strong></p><p>由于表的字段b上没有索引， 因此再用图的执行流程时， 每次到t2去匹配的时候， 就要做一次全表扫描 。</p><p><strong>Block Nested-Loop Join</strong></p><p>这时候， 被驱动表上没有可用的索引， 算法的流程是这样的：</p><ol><li>把表t1的数据读入线程内存join_buffer中， 由于我们这个语句中写的是select *， 因此是把整个表t1放入了内存；</li><li>扫描表t2， 把表t2中的每一行取出来， 跟join_buffer中的数据做对比， 满足join条件的， 作为结果集的一部分返回。</li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421212952835.png" alt></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421213046975.png" alt></p><p>可以看到，在这个过程中，对表t1和t2都做了一次全表扫描，因此总的扫描行数是1100。由于join_buffer是以无序数组的方式组织的，因此对表t2中的每一行，都要做100次判断，总共需要在内存中做的判断次数是：100*1000=10万次。</p><p>假设小表的行数是N，大表的行数是M，那么在这个算法里：</p><ol><li>两个表都做一次全表扫描，所以总的扫描行数是M+N；</li><li>内存中的判断次数是M*N。</li></ol><p>可以看到，调换这两个算式中的M和N没差别，因此这时候选择大表还是小表做驱动表，执行耗时是一样的。</p><p>分段放：join_buffer的大小是由参数join_buffer_size设定的， 默认值是256k。 <strong>如果放不下表t1的所有数据话， 策略很简单， 就是分段放</strong>。 我把join_buffer_size改成1200， 再执行：</p><pre><code>SQL select * from t1 straight_join t2 on (t1.a=t2.b);</code></pre><p>执行过程就变成了：</p><ol><li>扫描表t1， 顺序读取数据行放入join_buffer中， 放完第88行join_buffer满了， 继续第2步；</li><li>扫描表t2， 把t2中的每一行取出来， 跟join_buffer中的数据做对比， 满足join条件的， 作为结果集的一部分返回；</li><li>清空join_buffer；</li><li>继续扫描表t1， 顺序读取最后的12行数据放入join_buffer中， 继续执行第2步。</li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421213008023.png" alt></p><p>我们再来看下， 在这种情况下驱动表的选择问题。</p><p>假设， 驱动表的数据行数是N， 需要分K段才能完成算法流程， 被驱动表的数据行数是M。注意， 这里的K不是常数， N越大K就会越大， 因此把K表示为λ * N， 显然λ的取值范围是(0,1)。所以， 在这个算法的执行过程中：</p><ol><li><p>扫描行数是 N+λ * N * M；</p></li><li><p>内存判断 N * M次。</p><p>显然， 内存判断次数是不受选择哪个表作为驱动表影响的。 而考虑到扫描行数， 在M和N大小确定的情况下， N小一些， 整个算式的结果会更小。所以结论是， 应该让小表当驱动表。当然， 你会发现， 在N+λ<em>N</em>M这个式子里， λ才是影响扫描行数的关键因素， 这个值越小越好。</p></li></ol><p><strong>回答文章开头的两个问题</strong>。</p><p>第一个问题：能不能使用join语句？</p><ol><li>如果可以使用Index Nested-Loop Join算法，也就是说可以用上被驱动表上的索引，其实是没问题的；</li><li>如果使用Block Nested-Loop Join算法，扫描行数就会过多。尤其是在大表上的join操作，这样可能要扫描被驱动表很多次，会占用大量的系统资源。所以这种join尽量不要用。</li></ol><p>所以你在判断要不要使用join语句时，就是看explain结果里面，Extra字段里面有没有出现“Block Nested Loop”字样。</p><p>第二个问题是：如果要使用join，应该选择大表做驱动表还是选择小表做驱动表？</p><ol><li>如果是Index Nested-Loop Join算法，应该选择小表做驱动表；</li><li>如果是Block Nested-Loop Join算法：<ul><li>在join_buffer_size足够大的时候，是一样的；</li><li>在join_buffer_size不够大的时候（这种情况更常见），应该选择小表做驱动表。</li></ul></li></ol><p>所以，这个问题的结论就是，总是应该使用小表做驱动表。</p><p>在决定哪个表做驱动表的时候， 应该是两个表按照各自的条件过滤， 过滤完成之后， 计算参与join的各个字段的总数据量， 数据量小的那个表， 就是“小表”， 应该作为驱动表。</p><p><strong>总结</strong></p><p>通过对Index Nested-Loop Join和Block Nested-Loop Join两个算法执行过程的分析，我们也得到了文章开头两个问题的答案：</p><ol><li>如果可以使用被驱动表的索引，join语句还是有其优势的；</li><li>不能使用被驱动表的索引，只能使用Block Nested-Loop Join算法，这样的语句就尽量不要使用；</li><li>在使用join的时候，应该让小表做驱动表。</li></ol><h2 id="35-join语句怎么优化？"><a href="#35-join语句怎么优化？" class="headerlink" title="35 | join语句怎么优化？"></a><strong>35 | join语句怎么优化？</strong></h2><p><strong>Multi-Range Read优化</strong></p><p>【主要是根据局部一致性原理进行优化的】</p><p>Multi-Range Read优化 (MRR)。 这个优化的主要目的是尽量使用顺序读盘。</p><p>主键索引是一棵B+树， 在这棵树上， 每次只能根据一个主键id查到一行数据。 因此， 回表肯定是一行行搜索主键索引的</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421213400293.png" alt></p><p>如果随着a的值递增顺序查询的话， id的值就变成随机的， 那么就会出现随机访问， 性能相对较差。 虽然“按行查”这个机制不能改， 但是调整查询的顺序， 还是能够加速的。因为大多数的数据都是按照主键递增顺序插入得到的， 所以我们可以认为， 如果按照主键的递增顺序查询的话， 对磁盘的读比较接近顺序读， 能够提升读性能。</p><p>这就是MRR优化的设计思路。 此时， 语句的执行流程变成了这样：</p><ol><li>根据索引a， 定位到满足条件的记录， 将id值放入read_rnd_buffer中;</li><li>将read_rnd_buffer中的id进行递增排序；</li><li>排序后的id数组， 依次到主键id索引中查记录， 并作为结果返回。</li></ol><p><strong>Batched Key Access</strong></p><p>NLJ算法执行的逻辑是： 从驱动表t1， 一行行地取出a的值， 再到被驱动表t2去做join。 也就是说， 对于表t2来说， 每次都是匹配一个值。 这时， MRR的优势就用不上了。</p><p><strong>BNL算法的性能问题</strong></p><p>大表join操作虽然对IO有影响， 但是在语句执行结束后， 对IO的影响也就结束了。 但是，对Buffer Pool的影响就是持续性的， 需要依靠后续的查询请求慢慢恢复内存命中率。</p><p>也就是说， BNL算法对系统的影响主要包括三个方面：</p><ol><li>可能会多次扫描被驱动表， 占用磁盘IO资源；</li><li>判断join条件需要执行M*N次对比（M、 N分别是两张表的行数） ， 如果是大表就会占用非常多的CPU资源；</li><li>可能会导致Buffer Pool的热数据被淘汰， 影响内存命中率。</li></ol><h2 id="36-为什么临时表可以重名？"><a href="#36-为什么临时表可以重名？" class="headerlink" title="36 | 为什么临时表可以重名？"></a><strong>36 | 为什么临时表可以重名？</strong></h2><p><strong>内存表和临时表的概念</strong></p><ul><li>内存表， 指的是使用Memory引擎的表， 建表语法是create table engine=memory。 这种表的数据都保存在内存里， 系统重启的时候会被清空， 但是表结构还在。 除了这两个特性看上去比较“奇怪”外， 从其他的特征上看， 它就是一个正常的表。</li><li>临时表， 可以使用各种引擎类型 。 如果是使用InnoDB引擎或者MyISAM引擎的临时表， 写数据的时候是写到磁盘上的。 当然， 临时表也可以使用Memory引擎。</li></ul><p><strong>临时表的特性</strong></p><p>临时表在使用上有以下几个特点：</p><ol><li>建表语法是create temporary table …。</li><li>一个临时表只能被创建它的session访问， 对其他线程不可见。</li><li>临时表可以与普通表同名。</li><li>session A内有同名的临时表和普通表的时候， show create语句， 以及增删改查语句访问的是临时表。</li><li>show tables命令不显示临时表。</li></ol><p><strong>临时表的应用</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421213557334.png" alt></p><p><strong>为什么临时表可以重名？</strong></p><pre><code>SQL create temporary table temp_t(id int primary key)engine=innodb;</code></pre><p>MySQL要给这个InnoDB表创建一个frm文件保存表结构定义， 还要有地方保存表数据。这个frm文件放在临时文件目录下， 文件名的后缀是.frm， 前缀是“#sql{进程id}_{线程id}_序列号”。 你可以使用select @@tmpdir命令， 来显示实例的临时文件目录。</p><h2 id="37-什么时候会使用内部临时表？"><a href="#37-什么时候会使用内部临时表？" class="headerlink" title="37 | 什么时候会使用内部临时表？"></a><strong>37 | 什么时候会使用内部临时表？</strong></h2><p><strong>union 执行流程</strong></p><pre><code>SQL (select 1000 as f) union (select id from t1 order by id desc limit 2);</code></pre><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421213647330.png" alt></p><ol><li><p>创建一个内存临时表， 这个临时表只有一个整型字段f， 并且f是主键字段。</p></li><li><p>执行第一个子查询， 得到1000这个值， 并存入临时表中。</p></li><li><p>执行第二个子查询：</p><p>i. 拿到第一行id=1000， 试图插入临时表中。 但由于1000这个值已经存在于临时表了， 违反了唯一性约束， 所以插入失败， 然后继续执行；</p><p>Sii. 取到第二行id=999， 插入临时表成功。</p></li><li><p>从临时表中按行取出数据， 返回结果， 并删除临时表， 结果中包含两行数据分别是1000和999。</p></li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421213702537.png" alt></p><p>可以看到， 这里的内存临时表起到了暂存数据的作用， 而且计算过程还用上了临时表主键id的唯一性约束， 实现了union的语义。</p><p><strong>group by 执行流程</strong></p><pre><code>SQL select id%10 as m, count(*) as c from t1 group by m;</code></pre><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421213717901.png" alt></p><p>在Extra字段里面， 我们可以看到三个信息：</p><ul><li>Using index， 表示这个语句使用了覆盖索引， 选择了索引a， 不需要回表；</li><li>Using temporary， 表示使用了临时表；</li><li>Using filesort， 表示需要排序。</li></ul><p>这个语句的执行流程是这样的：</p><ol><li>创建内存临时表， 表里有两个字段m和c， 主键是m；</li><li>扫描表t1的索引a， 依次取出叶子节点上的id值， 计算id%10的结果， 记为x；</li></ol><ul><li>如果临时表中没有主键为x的行， 就插入一个记录(x,1);</li><li>如果表中有主键为x的行， 就将x这一行的c值加1；</li></ul><ol><li>遍历完成后， 再根据字段m做排序， 得到结果集返回给客户端。</li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421213743352.png" alt></p><p><strong>指导原则</strong></p><ol><li>如果对group by语句的结果没有排序要求， 要在语句后面加 order bynull；</li><li>尽量让group by过程用上表的索引， 确认方法是explain结果里没有Using temporary和 Using filesort；</li><li>如果group by需要统计的数据量不大， 尽量只使用内存临时表； 也可以通过适当调大tmp_table_size参数， 来避免用到磁盘临时表；</li><li>如果数据量实在太大， 使用SQL_BIG_RESULT这个提示， 来告诉优化器直接使用排序算法得到group by的结果。</li></ol><p><strong>数据库中已经设置buffer，为什么还要有临时表这个东西，除了存储在磁盘上还有其他的好处吗</strong>?</p><ol><li><strong>缓冲区（Buffer）</strong>：缓冲区是用来存储数据页的内存区域，它的主要作用是提高数据库的性能。当数据库需要读取或写入数据时，首先将数据页加载到内存的缓冲区中，这样数据库可以直接在内存中进行操作，而不必每次都访问磁盘。这样做的好处是减少了磁盘I/O操作的次数，加快了数据的访问速度，提高了数据库的性能。</li><li><strong>临时表（Temporary Table）</strong>：临时表是一种特殊类型的表，它在数据库中的生命周期通常比普通表短暂，它的数据通常不会持久保存，而是在会话结束或者事务提交后被删除。临时表通常用于临时存储数据、中间计算结果等，它们可以帮助简化复杂的查询或者操作，提高查询的可读性和性能。</li></ol><h2 id="38-都说InnoDB好，-那还要不要使用Memory引擎？"><a href="#38-都说InnoDB好，-那还要不要使用Memory引擎？" class="headerlink" title="38 | 都说InnoDB好， 那还要不要使用Memory引擎？"></a><strong>38 | 都说InnoDB好，</strong> <strong>那还要不要使用Memory引擎？</strong></h2><p><strong>内存表的数据组织结构</strong></p><p>假设有以下的两张表t1 和 t2， 其中表t1使用Memory引擎， 表t2使用InnoDB引擎。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421214154359.png" alt></p><p>可以看到， 内存表t1的返回结果里面0在最后一行， 而InnoDB表t2的返回结果里0在第一行。表t2用的是InnoDB引擎， 它的主键索引id的组织方式， 你已经很熟悉了： InnoDB表的数据就放在主键索引树上， 主键索引是B+树。 所以表t2的数据组织方式如下图所示：</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421214201995.png" alt></p><p>与InnoDB引擎不同， Memory引擎的数据和索引是分开的。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421214207021.png" alt></p><p>可见， InnoDB和Memory引擎的数据组织方式是不同的：</p><ul><li>InnoDB引擎把数据放在主键索引上， 其他索引上保存的是主键id。 这种方式， 我们称之为索引组织表（IndexOrganizied Table）</li><li>而Memory引擎采用的是把数据单独存放， 索引上保存数据位置的数据组织形式， 我们称之为堆组织表（Heap Organizied Table）</li></ul><p>从中我们可以看出， 这两个引擎的一些典型不同</p><ol><li>InnoDB表的数据总是有序存放的， 而内存表的数据就是按照写入顺序存放的；</li><li>当数据文件有空洞的时候， InnoDB表在插入新数据的时候， 为了保证数据有序性， 只能在固定的位置写入新值， 而内存表找到空位就可以插入新值；</li><li>数据位置发生变化的时候， InnoDB表只需要修改主键索引， 而内存表需要修改所有索引；</li><li>InnoDB表用主键索引查询时需要走一次索引查找， 用普通索引查询的时候， 需要走两次索引查找。 而内存表没有这个区别， 所有索引的“地位”都是相同的。</li><li>InnoDB支持变长数据类型， 不同记录的长度可能不同； 内存表不支持Blob 和 Text字段， 并且即使定义了varchar(N)， 实际也当作char(N)， 也就是固定长度字符串来存储， 因此内存表的每行数据长度相同。</li></ol><p><strong>hash索引和B-Tree索引</strong></p><p>存表也是支B-Tree索引的。 在id列上创建一个B-Tree索引， SQL语句可以这么写：</p><pre><code>SQL alter table t1 add index a_btree_index using btree (id);</code></pre><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421214257739.png" alt></p><p><strong>内存表的锁</strong></p><p>内存表不支持行锁， 只支持表锁。 因此， 一张表只要有更新， 就会堵住其他所有在这个表上的读写操作。</p><p><strong>数据持久性问题</strong></p><p>数据放在内存中， 是内存表的优势， 但也是一个劣势。 因为， 数据库重启的时候， 所有的内存表都会被清空。内存表并不适合在生产环境上作为普通数据表使用 。</p><ol><li>如果你的表更新量大， 那么并发度是一个很重要的参考指标， InnoDB支持行锁， 并发度比内存表好；</li><li>能放到内存表的数据量都不大。 如果你考虑的是读的性能， 一个读QPS很高并且数据量不大的表， 即使是使用InnoDB， 数据也是都会缓存在InnoDB Buffer Pool里的。 因此， 使用InnoDB表的读性能也不会差。</li></ol><p>建议你把普通内存表都用InnoDB表来代替</p><p>内存临时表刚好可以无视内存表的两个不足， 主要是下面的三个原因：</p><ol><li>临时表不会被其他线程访问， 没有并发性的问题；</li><li>临时表重启后也是需要删除的， 清空数据这个问题不存在；</li><li>备库的临时表也不会影响主库的用户线程。</li></ol><h2 id="39-自增主键为什么不是连续的？"><a href="#39-自增主键为什么不是连续的？" class="headerlink" title="39 | 自增主键为什么不是连续的？"></a><strong>39 | 自增主键为什么不是连续的？</strong></h2><p><strong>自增值保存在哪儿？</strong></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421214411507.png" alt></p><p>可以看到， 表定义里面出现了一个AUTO_INCREMENT=2， 表示下一次插入数据时， 如果需要自动生成自增值， 会生成id=2。其实， 这个输出结果容易引起这样的误解： 自增值是保存在表结构定义里的。 实际上， 表的结构定义存放在后缀名为.frm的文件中， 但是并不会保存自增值。</p><p>不同的引擎对于自增值的保存策<strong>略不同。MyISAM引擎的自增值保存在数据文件中。InnoDB引擎的自增值， 其实是保存在了内存里， 并且到了MySQL 8.0版本后， 才有了“自增值持久化”的能力， 也就是才实现了“如果发生重启， 表的自增值可以恢复为MySQL重启前的值”</strong>。</p><p><strong>自增值修改机制</strong></p><p>在MySQL里面，如果字段id被定义为AUTO_INCREMENT，在插入一行数据的时候，自增值的行为如下：</p><ol><li>如果插入数据时id字段指定为0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT值填到自增字段；</li><li>如果插入数据时id字段指定了具体的值，就直接使用语句里指定的值。</li></ol><p><strong>自增值的修改时机</strong></p><p><strong>唯一键冲突导致自增主键id不连续</strong></p><p>假设，表t里面已经有了(1,1,1)这条记录，这时我再执行一条插入数据命令：</p><pre><code>insert into t values(null, 1, 1); </code></pre><p>这个语句的执行流程就是：</p><ol><li>执行器调用InnoDB引擎接口写入一行，传入的这一行的值是(0,1,1);</li><li>InnoDB发现用户没有指定自增id的值，获取表t当前的自增值2；</li><li>将传入的行的值改成(2,1,1);</li><li>将表的自增值改成3；</li><li>继续执行插入数据操作，由于已经存在c=1的记录，所以报Duplicate key error，语句返回。</li></ol><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421214727022.png" alt></p><p>可以看到，这个表的自增值改成3，是在真正执行插入数据的操作之前。这个语句真正执行的时候，因为碰到唯一键c冲突，所以id=2这一行并没有插入成功，但也没有将自增值再改回去。</p><p><strong>事务回滚导致自增主键id不连续</strong></p><p>同样道理。</p><p>思考：为什么<strong>自增值为什么不能回退？</strong></p><p>【简单来说，在多事务执行下回退会出现重复】</p><p>下面举例子说明。</p><p>假设有两个并行执行的事务，在申请自增值的时候，为了避免两个事务申请到相同的自增id，肯定要加锁，然后顺序申请。</p><ol><li>假设事务A申请到了id=2， 事务B申请到id=3，那么这时候表t的自增值是4，之后继续执行。</li><li>事务B正确提交了，但事务A出现了唯一键冲突。</li><li>如果允许事务A把自增id回退，也就是把表t的当前自增值改回2，那么就会出现这样的情况：表里面已经有id=3的行，而当前的自增id值是2。</li><li>接下来，继续执行的其他事务就会申请到id=2，然后再申请到id=3。这时，就会出现插入语句报错“主键冲突”。</li></ol><p>而为了解决这个主键冲突，有两种方法：</p><ol><li>每次申请id之前，先判断表里面是否已经存在这个id。如果存在，就跳过这个id。但是，这个方法的成本很高。因为，本来申请id是一个很快的操作，现在还要再去主键索引树上判断id是否存在。</li><li>把自增id的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增id。这个方法的问题，就是锁的粒度太大，系统并发能力大大下降。</li></ol><p>可见，这两个方法都会导致性能问题。</p><p><strong>MySQL内部机制</strong></p><p>对于批量插入数据的语句，MySQL有一个批量申请自增id的策略：</p><ol><li>语句执行过程中，第一次申请自增id，会分配1个；</li><li>1个用完以后，这个语句第二次申请自增id，会分配2个；</li><li>2个用完以后，还是这个语句，第三次申请自增id，会分配4个；</li><li>依此类推，同一个语句去申请自增id，每次申请到的自增id个数都是上一次的两倍。</li></ol><p>举个例子，我们一起看看下面的这个语句序列：</p><pre><code>insert into t values(null, 1,1);insert into t values(null, 2,2);insert into t values(null, 3,3);insert into t values(null, 4,4);create table t2 like t;insert into t2(c,d) select c,d from t;insert into t2 values(null, 5,5);</code></pre><p>insert…select，实际上往表t2中插入了4行数据。但是，这四行数据是分三次申请的自增id，第一次申请到了id=1，第二次被分配了id=2和id=3， 第三次被分配到id=4到id=7。</p><p>由于这条语句实际只用上了4个id，所以id=5到id=7就被浪费掉了。之后，再执行insert into t2 values(null, 5,5)，实际上插入的数据就是（8,5,5)。</p><h2 id="40-insert语句的锁为什么这么多？"><a href="#40-insert语句的锁为什么这么多？" class="headerlink" title="40 | insert语句的锁为什么这么多？"></a><strong>40 | insert语句的锁为什么这么多？</strong></h2><p>insert …select 是很常见的在两个表之间拷贝数据的方法。 你需要注意， 在可重复读隔离级别下， 这个语句会给select的表里扫描到的记录和间隙加读锁。</p><p>而如果insert和select的对象是同一个表， 则有可能会造成循环写入。 这种情况下， 我们需要引入用户临时表来做优化。<br>insert 语句如果出现唯一键冲突， 会在冲突的唯一值上加共享的next-keylock(S锁)。 因此， 碰到由于唯一键约束导致报错后， 要尽快提交或回滚事务， 避免加锁时间过长。</p><h2 id="41-怎么最快地复制一张表？"><a href="#41-怎么最快地复制一张表？" class="headerlink" title="41 | 怎么最快地复制一张表？"></a><strong>41 | 怎么最快地复制一张表？</strong></h2><p><strong>mysqldump方法</strong></p><p>SQL mysqldump -hℎ𝑜𝑠𝑡−𝑃port -u$user –add-locks=0 –no-create-info –single-transaction –set-gtid-purged=OFF db1</p><p>这条命令中， 主要参数含义如下：</p><ol><li>–single-transaction的作用是， 在导出数据的时候不需要对表db1.t加表锁， 而是使用STARTTRANSACTION WITH CONSISTENTSNAPSHOT的方法；</li><li>–add-locks设置为0， 表示在输出的文件结果里， 不增加” LOCKTABLES t WRITE;”；</li><li>–no-create-info的意思是， 不需要导出表结构；</li><li>–set-gtid-purged=off表示的是， 不输出跟GTID相关的信息；</li><li>–result-file指定了输出文件的路径， 其中client表示生成的文件是在客户端机器上的。<br>通过这条mysqldump命令生成的t.sql文件中就包含了如图1所示的INSERT语句。</li></ol><p><strong>导出CSV文件</strong></p><p>另一种方法是直接将结果导出成.csv文件。 MySQL提供了下面的语法， 用来将查询结果导出到服务端本地目录：</p><pre><code>SQL select * from db1.t where a&gt;900 into outfile &#39;/server_tmp/t.csv&#39;;</code></pre><p><strong>物理拷贝</strong></p><h2 id="42-grant之后要跟着flush-privileges吗？"><a href="#42-grant之后要跟着flush-privileges吗？" class="headerlink" title="42 | grant之后要跟着flush privileges吗？"></a><strong>42 | grant之后要跟着flush privileges吗？</strong></h2><p>grant之后真的需要执行flush privileges吗？</p><p>如果没有执行这个flush命令的话， 赋权语句真的不能生效吗？grant语句会同时修改数据表和内存， 判断权限的时候使用的是内存数据。 因此， 规范地使用grant和revoke语句， 是不需要随后加上flush privileges语句的。flush privileges语句本身会用数据表的数据重建一份内存权限数据， 所以在权限数据可能存在不一致的情况下再使用。 而这种不一致往往是由于直接用DML语句操作系统权限表导致的， 所以我们尽量不要使用这类语句。</p><h2 id="43-要不要使用分区表？"><a href="#43-要不要使用分区表？" class="headerlink" title="43 | 要不要使用分区表？"></a><strong>43 | 要不要使用分区表？</strong></h2><pre><code>CREATE TABLE `t` (  `ftime` datetime NOT NULL,  `c` int(11) DEFAULT NULL,  KEY (`ftime`)) ENGINE=InnoDB DEFAULT CHARSET=latin1PARTITION BY RANGE (YEAR(ftime))(PARTITION p_2017 VALUES LESS THAN (2017) ENGINE = InnoDB, PARTITION p_2018 VALUES LESS THAN (2018) ENGINE = InnoDB, PARTITION p_2019 VALUES LESS THAN (2019) ENGINE = InnoDB,PARTITION p_others VALUES LESS THAN MAXVALUE ENGINE = InnoDB);insert into t values(&#39;2017-4-1&#39;,1),(&#39;2018-4-1&#39;,1);</code></pre><p>在表t中初始化插入了两行记录， 按照定义的分区规则， 这两行记录分别落在p_2018和p_2019这两个分区上。可以看到， 这个表包含了一个.frm文件和4个.ibd文件， 每个分区对应一个.ibd文件。 也就是说：对于引擎层来说， 这是4个表；对于Server层来说， 这是1个表。</p><p><strong>分区策略</strong></p><ul><li>MyISAM分区表使用的分区策略， 我们称为通用分区策略（generic partitioning） ， 每次访问分区都由server层控制。 通用分区策略， 是MySQL一开始支持分区表的时候就存在的代码， 在文件管理、 表管理的实现上很粗糙， 因此有比较严重的性能问题。</li><li>从MySQL 5.7.9开始， InnoDB引擎引入了本地分区策略（native partitioning） 。 这个策略是在InnoDB内部自己管理打开分区的行为。</li><li>MySQL从5.7.17开始， 将MyISAM分区表标记为即将弃用(deprecated)， 意思是“从这个版本开始不建议这么使用， 请使用替代方案。 在将来的版本中会废弃这个功能”。</li><li>从MySQL 8.0版本开始， 就不允许创建MyISAM分区表了， 只允许创建已经实现了本地分区策略的引擎。 目前来看， 只有InnoDB和NDB这两个引擎支持了本地分区策略。</li></ul><p><strong>分区表的server层行为</strong></p><p>如果从server层看的话， 一个分区表就只是一个表。</p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421215158558.png" alt></p><p><img src="https://penge666blog.oss-cn-beijing.aliyuncs.com/img/image-20240421215203807.png" alt></p><p>可以看到， 虽然session B只需要操作p_2107这个分区， 但是由于session A持有整个表t的MDL锁， 就导致了session B的alter语句被堵住。</p><ol><li>MySQL在第一次打开分区表的时候， 需要访问所有的分区；</li><li>在server层， 认为这是同一张表， 因此所有分区共用同一个MDL锁；</li><li>在引擎层， 认为这是不同的表， 因此MDL锁之后的执行过程， 会根据分区表规则，只访问必要的分区。</li></ol><p>有两个问题需要注意：</p><ol><li>分区并不是越细越好。 实际上， 单表或者单分区的数据一千万行， 只要没有特别大的索引，对于现在的硬件能力来说都已经是小表了。</li><li>分区也不要提前预留太多， 在使用之前预先创建即可。 比如， 如果是按月分区， 每年年底时再把下一年度的12个新分区创建上即可。 对于没有数据的历史分区， 要及时的drop掉。</li></ol><p>至于分区表的其他问题， 比如查询需要跨多个分区取数据， 查询性能就会比较慢， 基本上就不是分区表本身的问题， 而是数据量的问题或者说是使用方式的问题了。</p><h2 id="45-自增id用完怎么办？"><a href="#45-自增id用完怎么办？" class="headerlink" title="45 | 自增id用完怎么办？"></a><strong>45 | 自增id用完怎么办？</strong></h2><p>MySQL里面的几种自增id， 一起分析一下它们的值达到上限以后，会出现什么情况。2^32 -1（4294967295） 不是一个特别大的数， 对于一个频繁插入删除数据的表来说， 是可能会被用完的。 因此在建表的时候你需要考察你的表是否有可能达到这个上限， 如果有可能， 就应该创建成8个字节的bigint unsigned。</p><p><strong>InnoDB系统自增row_id</strong></p><p>如果你创建的InnoDB表没有指定主键， 那么InnoDB会给你创建一个不可见的， 长度为6个字节的row_id。 InnoDB维护了一个全局的dict_sys.row_id值， 所有无主键的InnoDB表， 每插入一行数据， 都将当前的dict_sys.row_id值作为要插入数据的row_id， 然后把dict_sys.row_id的值加1。</p><p>每种自增id有各自的应用场景， 在达到上限后的表现也不同：</p><ol><li>表的自增id达到上限后， 再申请时它的值就不会改变， 进而导致继续插入数据时报主键冲突的错误。</li><li>row_id达到上限后， 则会归0再重新递增， 如果出现相同的row_id， 后写的数据会覆盖之前的数据。</li><li>Xid只需要不在同一个binlog文件中出现重复值即可。 虽然理论上会出现重复值， 但是概率极小， 可以忽略不计。</li><li>InnoDB的max_trx_id 递增值每次MySQL重启都会被保存起来， 所以我们文章中提到的脏读的例子就是一个必现的bug， 好在留给我们的时间还很充裕。</li><li>thread_id是我们使用中最常见的， 而且也是处理得最好的一个自增id逻辑了。</li></ol><h2 id="面试高频知识"><a href="#面试高频知识" class="headerlink" title="面试高频知识"></a><strong>面试高频知识</strong></h2><p>搬运自知乎</p><p>1、一条 sql 语句是如何执行的？也就是说，从客户端执行了一条 sql 命令，服务端会进行哪些处理？（例如验证身份，是否启用缓存啥的）</p><p>2、索引相关：索引是如何实现的？多种引擎的实现区别？聚族索引，非聚族索引，二级索引，唯一索引、最左匹配原则等等（非常重要）</p><p>3、事务相关：例如事务的隔离是如何实现的？事务是如何保证原子性？不同的事务看到的数据怎么就不一样了？难道每个事务都拷贝一份视图？MVCC 的实现原理（重要）等等。</p><p>4、各种锁相关：例如表锁，行锁，间隙锁，共享锁，排他锁。这些锁的出现主要是用来解决哪些问题？（重要）</p><p>5、日志相关：redolog，binlog，undolog，这些日志的实现原理，为了解决怎么问题？日志也是非常重要的吧，面试也问的挺多。</p><p>6、数据库的主从备份、如何保证数据不丢失、如何保证高可用等等。</p><p>7、一些故障排查的命令，例如慢查询，sql 的执行计划，索引统计的刷新等等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;数据库是系统的核心，如果它缓慢那么所有的业务都会受它影响，一个系统的性能很少能超过核心数据库的性能上限。&lt;/p&gt;
&lt;h2 id=&quot;01-基础
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://JoyTsing.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="读书笔记" scheme="https://JoyTsing.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数据库" scheme="https://JoyTsing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>在Linux下为g++链接三方库</title>
    <link href="https://joytsing.github.io/posts/24753/"/>
    <id>https://joytsing.github.io/posts/24753/</id>
    <published>2024-04-27T14:27:36.000Z</published>
    <updated>2024-05-05T16:09:13.630Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>最近在学习Boost网络库，一开始使用的版本是apt源带的1.74.0，大概是20年左右的版本，后面想了一下太老了，同时想配合gcc13体验一下协程，就去下了最新的Boost 1.85.0, 然后在安装的时候没有选择默认安装位置（之前不知道吃大亏），而是自定义了一个地方，这样能够让我们多版本使用，但是无法像之前直接丝滑的<code>#include</code>使用，同时又不想像维护第三方一样每次都写CMakeList，于是怎么让g++(or gcc)识别库就成了一个问题。</p><h2 id="Boost"><a href="#Boost" class="headerlink" title="Boost"></a>Boost</h2><p><img src="/posts/24753/image-20240425223633571.png" alt></p><p>这里选择的方法是使用在<code>.zshrc</code>中export环境变量的方法来使用，下面分别来看这三变量的作用：</p><ul><li><code>BOOST_ROOT</code>:实际上可有可无，主要是在CMakeList中使用<code>find_package</code>查找boost时使用</li><li><code>CPLUS_INCLUDE_PATH</code>: g++查找头文件包含处</li><li><code>LD_LIBRARY_PATH</code>: 动态库连接地址</li></ul><p>常用的话可以直接加在<code>.zshrc</code>中避免繁杂的编写。</p><h2 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h2><p>只能说太折磨了，本来想着一开始或许像Boost一样给他安装完就行了，没想到复杂程度翻了好几个倍，而且还需要像之前一样使用不指定路径直接使用，好在最后折磨了几个小时终于配好了。网上有关的资料实在是太少，最后还是只能靠自己分析出来，果然<code>make your hands dirty</code>才是让工程能力上升的好方式。而且其实最后的答案也并不意外，但是如果没有人跟你说的话自己需要碰壁很久（还是之前boost太好配置形成路径依赖了）。</p><p>如果你只想快速使用，而不需要太新的版本的话那么可以直接通过下面两个命令快速安装学习使用。</p><pre class="line-numbers language-sh"><code class="language-sh">sudo apt install protobuf-compilersudo apt install libprotobuf-dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>至于怎么安装，安装Protobuf可是一大乐子，这里只说如果安装在其他路径而非默认路径怎么添加到我们需要的环境中，在安装完后，需要添加对应的<strong>环境</strong>（重点），找到一些测试的demo，同时生成对应的pb文件，后面我们就需要编译了，首先大概率是这种情况：</p><p><img src="/posts/24753/image-20240428021010055.png" alt="其实一点不意外"></p><p>好的，然后去网络上查找，发现原来需要 <code>-lprotobuf</code>，加上试试，然后会发现<code>ld</code>找不到protobuf库，那么如果说手动指定链接的库能否成功？</p><p><img src="/posts/24753/image-20240428021753549.png" alt="成功了"></p><p>尝试<code>echo</code>一下<code>$LD_LIBRARY_PATH</code>，发现是有对应库的地址的，那么说明问题并不在动态库上，链接有问题而不是动态库，那么只剩下是静态库的问题了，首先添加一下静态库的地址：</p><p><img src="/posts/24753/image-20240428023212566.png" alt></p><ul><li>第一个用于执行protoc</li><li>第二个命令用于寻找pkgconfig，主要用于CMakeLists</li><li>剩下的分别是头文件包含，静态库动态库连接地址</li></ul><p><img src="/posts/24753/image-20240428023335931.png" alt="终于可以不用手动指定链接地址了"></p><h3 id="CMake中使用"><a href="#CMake中使用" class="headerlink" title="CMake中使用"></a>CMake中使用</h3><p>与Boost不同，Boost在设置完环境变量后的使用基本跟std差不多，可以无感使用非常丝滑，但是Protobuf不行，并且Protobuf一般在中大型项目里面我们才会使用（一般要配合CMakeLists），那么怎么在CMakeLists里面使用就成了关键。</p><ul><li><p>方法一：手动指定</p><pre class="line-numbers language-cmake"><code class="language-cmake">set(Protobuf_PREFIX_PATH    "/home/joytsing/makeInstall/protobuf3.21.12/include"                "/home/joytsing/makeInstall/protobuf3.21.12/lib"                 "/home/joytsing/makeInstall/protobuf3.21.12/bin" )list(APPEND CMAKE_PREFIX_PATH "${Protobuf_PREFIX_PATH}")find_package(Protobuf REQUIRED)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/24753/image-20240428024042418.png" alt></p></li><li><p>方法二：利用PkgConfig</p><pre><code>find_package(PkgConfig)pkg_search_module(Protobuf REQUIRED protobuf)</code></pre></li></ul><p>注意，这个方法有缺陷，没法使用<code>protobuf_generate_cpp</code>这些原生指令，简单的工程可以用方法2，复杂的最好就不要用了。</p><p><img src="/posts/24753/image-20240428024120881.png" alt></p><p>在引入库之后就可以正常使用了，可喜可贺。</p><pre class="line-numbers language-cmake"><code class="language-cmake">find_package(Protobuf REQUIRED)  #查找protobuf包include_directories(${Protobuf_INCLUDE_DIRS})  #添加头文件,其实这一步在我们添加完CPLUS_INCLUDE是不需要的add_executable(exe main.cpp test.pb.cc) # 在用file(GLOB_RECURSE)的时候一定要注意是*.cc，找*.cpp无法编译target_link_libraries(exe ${PROTOBUF_LIBRARIES})  #一定要连接库文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="一些疑惑"><a href="#一些疑惑" class="headerlink" title="一些疑惑"></a>一些疑惑</h2><p>其实我挺奇怪为什么boost不需要像Protobuf一样在使用<code>g++</code>命令的时候手动链接，同时不需要添加静态库的地址（最后还是为了以防万一把boost的静态链接给加上了）。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>最好不要把protobuf加到全局里面去配置，大概率会跟grpc冲突。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;最近在学习Boost网络库，一开始使用的版本是apt源带的1.74.0，大概是20年左右的版本，后面想了一下太老了，同时想配合gcc13体验
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>常用二十种设计模式</title>
    <link href="https://joytsing.github.io/posts/59440/"/>
    <id>https://joytsing.github.io/posts/59440/</id>
    <published>2024-04-27T10:11:21.000Z</published>
    <updated>2024-04-27T10:15:33.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>C++中常用的设计模式有很多，设计模式是解决常见问题的经过验证的最佳实践。以下是一些常用的设计模式：</p><ol><li><strong>单例模式（Singleton）</strong>：确保一个类只有一个实例，并提供一个全局访问点。</li><li><strong>工厂模式（Factory）</strong>：用于创建对象，而不需要指定具体类。</li><li><strong>抽象工厂模式（Abstract Factory）</strong>：提供一组相关或相互依赖的对象，而不指定其具体类。</li><li><strong>建造者模式（Builder）</strong>：将一个复杂对象的构建与其表示分离，使相同的构建过程可以创建不同的表示。</li><li><strong>原型模式（Prototype）</strong>：通过克隆已有对象来创建新对象，以避免直接使用构造函数。</li><li><strong>适配器模式（Adapter）</strong>：将一个接口转换成另一个客户希望使用的接口。</li><li><strong>装饰器模式（Decorator）</strong>：动态地给一个对象添加一些额外的职责，而不需要子类化。</li><li><strong>代理模式（Proxy）</strong>：为其他对象提供一个代理以控制对这个对象的访问。</li><li><strong>观察者模式（Observer）</strong>：定义了一种一对多的依赖关系，当一个对象状态改变时，所有依赖它的对象都会得到通知。</li><li><strong>策略模式（Strategy）</strong>：定义一系列算法，封装它们，使它们可以相互替换。</li><li><strong>命令模式（Command）</strong>：将一个请求封装成一个对象，从而允许使用不同的请求、队列或日志请求。</li><li><strong>状态模式（State）</strong>：允许对象在其内部状态改变时改变其行为。</li><li><strong>模板方法模式（Template Method）</strong>：定义算法的骨架，允许子类重写其中的步骤。</li><li><strong>访问者模式（Visitor）</strong>：表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</li><li><strong>组合模式（Composite）</strong>：将对象组合成树形结构以表示“部分-整体”的层次结构。</li><li><strong>迭代器模式（Iterator）</strong>：提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。</li><li><strong>中介者模式（Mediator）</strong>：定义一个对象，封装一系列对象之间的交互，从而降低对象之间的耦合度。</li><li><strong>备忘录模式（Memento）</strong>：不破坏封装的前提下，捕获一个对象的内部状态，并在对象之外保存这个状态。</li><li><strong>桥接模式（Bridge）</strong>：将抽象部分与它的实现部分分离，使它们可以独立变化。</li><li><strong>解释器模式（Interpreter）</strong>：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</li></ol><h2 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1.单例模式"></a>1.单例模式</h2><p><strong>提供所有设计模式的 C++ 示例代码是一个庞大的任务，但我可以为您提供一个示例，演示如何使用 C++ 实现一个常见的设计模式——单例模式（Singleton）。</strong></p><p><strong>单例模式（Singleton） 确保一个类只有一个实例，并提供全局访问点。以下是一个基本的单例模式示例：</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> Singleton<span class="token operator">&amp;</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">static</span> Singleton instance<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 静态局部变量确保只初始化一次</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Singleton is doing something."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 构造函数私有，只能通过 getInstance() 获取实例</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取 Singleton 实例</span>    Singleton<span class="token operator">&amp;</span> singleton <span class="token operator">=</span> Singleton<span class="token operator">::</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    singleton<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，<code>Singleton</code> 类的构造函数是私有的，这意味着外部无法直接创建 <code>Singleton</code> 对象。通过 <code>getInstance()</code> 静态成员函数，我们可以获取到单一的 <code>Singleton</code> 实例。这确保了只有一个实例存在。 单例模式常用于需要共享资源或控制访问某些全局状态的情况。在实际项目中，设计模式的选择会根据具体需求和架构决策，不同的模式可能会以不同的方式被实现和使用。</p><h2 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2.工厂模式"></a>2.工厂模式</h2><p>工厂模式（Factory Pattern）是一种创建型设计模式，用于创建对象而无需指定对象的具体类。工厂模式通过定义一个共同的接口，由不同的工厂子类来实现，并根据不同的情况返回不同的具体对象。</p><p>以下是一个简单的工厂模式的 C++ 示例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token comment" spellcheck="true">// 抽象产品类</span><span class="token keyword">class</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 具体产品类 A</span><span class="token keyword">class</span> <span class="token class-name">ConcreteProductA</span> <span class="token operator">:</span> <span class="token keyword">public</span> Product <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Product A in use."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 具体产品类 B</span><span class="token keyword">class</span> <span class="token class-name">ConcreteProductB</span> <span class="token operator">:</span> <span class="token keyword">public</span> Product <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Product B in use."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 抽象工厂类</span><span class="token keyword">class</span> <span class="token class-name">Factory</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> Product<span class="token operator">*</span> <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 具体工厂类 A，用于创建 ProductA</span><span class="token keyword">class</span> <span class="token class-name">ConcreteFactoryA</span> <span class="token operator">:</span> <span class="token keyword">public</span> Factory <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    Product<span class="token operator">*</span> <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">ConcreteProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 具体工厂类 B，用于创建 ProductB</span><span class="token keyword">class</span> <span class="token class-name">ConcreteFactoryB</span> <span class="token operator">:</span> <span class="token keyword">public</span> Factory <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    Product<span class="token operator">*</span> <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">ConcreteProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 使用具体工厂类 A 创建产品 A</span>    Factory<span class="token operator">*</span> factoryA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ConcreteFactoryA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Product<span class="token operator">*</span> productA <span class="token operator">=</span> factoryA<span class="token operator">-</span><span class="token operator">></span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    productA<span class="token operator">-</span><span class="token operator">></span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 使用具体工厂类 B 创建产品 B</span>    Factory<span class="token operator">*</span> factoryB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ConcreteFactoryB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Product<span class="token operator">*</span> productB <span class="token operator">=</span> factoryB<span class="token operator">-</span><span class="token operator">></span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    productB<span class="token operator">-</span><span class="token operator">></span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> factoryA<span class="token punctuation">;</span>    <span class="token keyword">delete</span> factoryB<span class="token punctuation">;</span>    <span class="token keyword">delete</span> productA<span class="token punctuation">;</span>    <span class="token keyword">delete</span> productB<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，我们定义了抽象产品类 <code>Product</code>，有两个具体的产品类 <code>ConcreteProductA</code> 和 <code>ConcreteProductB</code>，它们都继承自 <code>Product</code>。然后，我们定义了抽象工厂类 <code>Factory</code>，有两个具体工厂类 <code>ConcreteFactoryA</code> 和 <code>ConcreteFactoryB</code>，它们分别负责创建不同的产品。</p><p>通过使用工厂模式，我们可以根据具体的需求选择不同的工厂类来创建产品，而无需关心产品的具体类是什么。这提供了灵活性，允许我们轻松扩展和替换具体产品和工厂类。</p><p>这是一个简单的示例，实际中工厂模式可用于更复杂的对象创建需求。工厂模式常用于创建对象的场景，特别是在代码中需要降低耦合性时非常有用。</p><h2 id="3-抽象工厂模式"><a href="#3-抽象工厂模式" class="headerlink" title="3.抽象工厂模式"></a>3.抽象工厂模式</h2><p>抽象工厂模式（Abstract Factory Pattern）是一种创建型设计模式，它提供了一个接口，用于创建一系列相关或依赖的对象，而不需要指定它们的具体类。抽象工厂模式的核心思想是为每个产品族（相关的一组产品）定义一个抽象工厂，然后在每个具体工厂中实现该抽象工厂。</p><p>以下是一个简单的抽象工厂模式的 C++ 示例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token comment" spellcheck="true">// 抽象产品 A</span><span class="token keyword">class</span> <span class="token class-name">AbstractProductA</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">useA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 具体产品 A1</span><span class="token keyword">class</span> <span class="token class-name">ConcreteProductA1</span> <span class="token operator">:</span> <span class="token keyword">public</span> AbstractProductA <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">useA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Product A1 in use."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 具体产品 A2</span><span class="token keyword">class</span> <span class="token class-name">ConcreteProductA2</span> <span class="token operator">:</span> <span class="token keyword">public</span> AbstractProductA <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">useA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Product A2 in use."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 抽象产品 B</span><span class="token keyword">class</span> <span class="token class-name">AbstractProductB</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">useB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 具体产品 B1</span><span class="token keyword">class</span> <span class="token class-name">ConcreteProductB1</span> <span class="token operator">:</span> <span class="token keyword">public</span> AbstractProductB <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">useB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Product B1 in use."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 具体产品 B2</span><span class="token keyword">class</span> <span class="token class-name">ConcreteProductB2</span> <span class="token operator">:</span> <span class="token keyword">public</span> AbstractProductB <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">useB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Product B2 in use."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 抽象工厂</span><span class="token keyword">class</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> AbstractProductA<span class="token operator">*</span> <span class="token function">createProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> AbstractProductB<span class="token operator">*</span> <span class="token function">createProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 具体工厂 1</span><span class="token keyword">class</span> <span class="token class-name">ConcreteFactory1</span> <span class="token operator">:</span> <span class="token keyword">public</span> AbstractFactory <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    AbstractProductA<span class="token operator">*</span> <span class="token function">createProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">ConcreteProductA1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    AbstractProductB<span class="token operator">*</span> <span class="token function">createProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">ConcreteProductB1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 具体工厂 2</span><span class="token keyword">class</span> <span class="token class-name">ConcreteFactory2</span> <span class="token operator">:</span> <span class="token keyword">public</span> AbstractFactory <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    AbstractProductA<span class="token operator">*</span> <span class="token function">createProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">ConcreteProductA2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    AbstractProductB<span class="token operator">*</span> <span class="token function">createProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">ConcreteProductB2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 使用具体工厂 1 创建产品 A 和 B</span>    AbstractFactory<span class="token operator">*</span> factory1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ConcreteFactory1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    AbstractProductA<span class="token operator">*</span> productA1 <span class="token operator">=</span> factory1<span class="token operator">-</span><span class="token operator">></span><span class="token function">createProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    AbstractProductB<span class="token operator">*</span> productB1 <span class="token operator">=</span> factory1<span class="token operator">-</span><span class="token operator">></span><span class="token function">createProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    productA1<span class="token operator">-</span><span class="token operator">></span><span class="token function">useA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    productB1<span class="token operator">-</span><span class="token operator">></span><span class="token function">useB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 使用具体工厂 2 创建产品 A 和 B</span>    AbstractFactory<span class="token operator">*</span> factory2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ConcreteFactory2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    AbstractProductA<span class="token operator">*</span> productA2 <span class="token operator">=</span> factory2<span class="token operator">-</span><span class="token operator">></span><span class="token function">createProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    AbstractProductB<span class="token operator">*</span> productB2 <span class="token operator">=</span> factory2<span class="token operator">-</span><span class="token operator">></span><span class="token function">createProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    productA2<span class="token operator">-</span><span class="token operator">></span><span class="token function">useA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    productB2<span class="token operator">-</span><span class="token operator">></span><span class="token function">useB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> factory1<span class="token punctuation">;</span>    <span class="token keyword">delete</span> productA1<span class="token punctuation">;</span>    <span class="token keyword">delete</span> productB1<span class="token punctuation">;</span>    <span class="token keyword">delete</span> factory2<span class="token punctuation">;</span>    <span class="token keyword">delete</span> productA2<span class="token punctuation">;</span>    <span class="token keyword">delete</span> productB2<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，我们定义了两个抽象产品类 <code>AbstractProductA</code> 和 <code>AbstractProductB</code>，以及它们的具体实现类。然后，我们定义了抽象工厂类 <code>AbstractFactory</code>，它包括两个工厂方法，分别用于创建产品 A 和产品 B。具体工厂类 <code>ConcreteFactory1</code> 和 <code>ConcreteFactory2</code> 分别实现了 <code>AbstractFactory</code>，用于创建不同的产品族。</p><p>抽象工厂模式允许我们在不知道具体产品类的情况下创建一组相关产品，这对于需要保持产品族之间的一致性非常有用。此模式还支持易于替换整个产品族，以满足不同的需求。</p><h2 id="4-建造者模式"><a href="#4-建造者模式" class="headerlink" title="4.建造者模式"></a>4.建造者模式</h2><p>建造者模式（Builder Pattern）是一种创建型设计模式，用于构建一个复杂对象，将构造过程和表示分离。通常情况下，该模式包括一个 Director（指挥者）类、一个抽象 Builder（建造者）接口和具体的 Builder 实现类。</p><p>以下是一个简单的建造者模式的 C++ 示例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token comment" spellcheck="true">// 产品类，即要构建的复杂对象</span><span class="token keyword">class</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">setPartA</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> partA<span class="token punctuation">)</span> <span class="token punctuation">{</span>        partA_ <span class="token operator">=</span> partA<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">setPartB</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> partB<span class="token punctuation">)</span> <span class="token punctuation">{</span>        partB_ <span class="token operator">=</span> partB<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">setPartC</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> partC<span class="token punctuation">)</span> <span class="token punctuation">{</span>        partC_ <span class="token operator">=</span> partC<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Product parts: "</span> <span class="token operator">&lt;&lt;</span> partA_ <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> partB_ <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> partC_ <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>string partA_<span class="token punctuation">;</span>    std<span class="token operator">::</span>string partB_<span class="token punctuation">;</span>    std<span class="token operator">::</span>string partC_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 抽象 Builder 接口</span><span class="token keyword">class</span> <span class="token class-name">Builder</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">buildPartA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">buildPartB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">buildPartC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> Product <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 具体 Builder 实现</span><span class="token keyword">class</span> <span class="token class-name">ConcreteBuilder</span> <span class="token operator">:</span> <span class="token keyword">public</span> Builder <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">ConcreteBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        product_ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Product</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">buildPartA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        product_<span class="token operator">-</span><span class="token operator">></span><span class="token function">setPartA</span><span class="token punctuation">(</span><span class="token string">"Part A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">buildPartB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        product_<span class="token operator">-</span><span class="token operator">></span><span class="token function">setPartB</span><span class="token punctuation">(</span><span class="token string">"Part B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">buildPartC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        product_<span class="token operator">-</span><span class="token operator">></span><span class="token function">setPartC</span><span class="token punctuation">(</span><span class="token string">"Part C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Product <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">*</span>product_<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    Product<span class="token operator">*</span> product_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 指挥者类，负责构建产品</span><span class="token keyword">class</span> <span class="token class-name">Director</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Director</span><span class="token punctuation">(</span>Builder<span class="token operator">*</span> builder<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">builder_</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    Product <span class="token function">construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        builder_<span class="token operator">-</span><span class="token operator">></span><span class="token function">buildPartA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder_<span class="token operator">-</span><span class="token operator">></span><span class="token function">buildPartB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder_<span class="token operator">-</span><span class="token operator">></span><span class="token function">buildPartC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> builder_<span class="token operator">-</span><span class="token operator">></span><span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    Builder<span class="token operator">*</span> builder_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ConcreteBuilder builder<span class="token punctuation">;</span>    Director <span class="token function">director</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span>    Product product <span class="token operator">=</span> director<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    product<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，我们有一个产品类 <code>Product</code>，包括三个部分。我们定义了抽象 Builder 接口，包括构建每个部分的方法和获取最终产品的方法。具体 Builder 类 <code>ConcreteBuilder</code> 实现了 Builder 接口，构建了 <code>Product</code> 的各个部分。指挥者类 <code>Director</code> 负责指导 Builder 构建产品。</p><p>使用建造者模式，我们可以按照不同的需求构建不同的产品，而不必关心构建的细节。这种模式尤其适用于构建复杂对象，帮助将构建过程和表示分离，提高了可维护性和可扩展性。</p><h2 id="5-原型模式"><a href="#5-原型模式" class="headerlink" title="5.原型模式"></a>5.原型模式</h2><p>原型模式（Prototype Pattern）是一种创建型设计模式，其主要思想是通过复制现有对象（原型）来创建新对象，而不需要从头开始构建。这种模式通常用于创建成本高昂或复杂的对象，同时可以保持对象的不变性。原型模式基于对象的克隆，可以分为浅拷贝和深拷贝两种。</p><p>以下是一个简单的原型模式的 C++ 示例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token comment" spellcheck="true">// 原型类</span><span class="token keyword">class</span> <span class="token class-name">Prototype</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> Prototype<span class="token operator">*</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 具体原型类 A</span><span class="token keyword">class</span> <span class="token class-name">ConcretePrototypeA</span> <span class="token operator">:</span> <span class="token keyword">public</span> Prototype <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    Prototype<span class="token operator">*</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">ConcretePrototypeA</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 深拷贝</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ConcretePrototypeA"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 具体原型类 B</span><span class="token keyword">class</span> <span class="token class-name">ConcretePrototypeB</span> <span class="token operator">:</span> <span class="token keyword">public</span> Prototype <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    Prototype<span class="token operator">*</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">ConcretePrototypeB</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 深拷贝</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ConcretePrototypeB"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Prototype<span class="token operator">*</span> originalA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ConcretePrototypeA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Prototype<span class="token operator">*</span> originalB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ConcretePrototypeB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 克隆原型对象</span>    Prototype<span class="token operator">*</span> cloneA <span class="token operator">=</span> originalA<span class="token operator">-</span><span class="token operator">></span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Prototype<span class="token operator">*</span> cloneB <span class="token operator">=</span> originalB<span class="token operator">-</span><span class="token operator">></span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    originalA<span class="token operator">-</span><span class="token operator">></span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cloneA<span class="token operator">-</span><span class="token operator">></span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    originalB<span class="token operator">-</span><span class="token operator">></span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cloneB<span class="token operator">-</span><span class="token operator">></span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> originalA<span class="token punctuation">;</span>    <span class="token keyword">delete</span> cloneA<span class="token punctuation">;</span>    <span class="token keyword">delete</span> originalB<span class="token punctuation">;</span>    <span class="token keyword">delete</span> cloneB<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，我们定义了一个抽象原型类 <code>Prototype</code>，包括克隆方法 <code>clone</code> 和打印方法 <code>print</code>。然后，我们创建了两个具体的原型类 <code>ConcretePrototypeA</code> 和 <code>ConcretePrototypeB</code>，它们实现了克隆方法，并在打印方法中展示自己的类型。</p><p>在 <code>main</code> 函数中，我们首先创建原型对象 <code>originalA</code> 和 <code>originalB</code>，然后通过调用它们的 <code>clone</code> 方法，创建了相应的克隆对象 <code>cloneA</code> 和 <code>cloneB</code>。这些克隆对象与原型对象具有相同的状态，但是是独立的对象。</p><p>原型模式允许我们根据需要克隆对象，而不必重新创建。这对于创建成本高昂或复杂的对象，以及需要保持对象不变性的情况非常有用。需要注意的是，深拷贝和浅拷贝的选择取决于对象内部的状态和结构。在实际应用中，可能需要自定义克隆方法以适应特定需求。</p><h2 id="6-适配器模式"><a href="#6-适配器模式" class="headerlink" title="6.适配器模式"></a>6.适配器模式</h2><p>适配器模式（Adapter Pattern）是一种结构型设计模式，它允许一个类的接口与另一个类的接口兼容。适配器模式主要用于解决两个已有接口之间的不匹配问题，使它们可以一起工作，而不需要修改它们的源代码。</p><p>适配器模式有两种主要类型：类适配器和对象适配器。</p><p><strong>类适配器</strong> 使用多重继承，它继承了被适配类并实现了目标接口。</p><p><strong>对象适配器</strong> 维护一个被适配类的实例，并实现了目标接口，然后委托被适配类的实例来执行相应的操作。</p><p>以下是一个简单的对象适配器模式的 C++ 示例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token comment" spellcheck="true">// 目标接口</span><span class="token keyword">class</span> <span class="token class-name">Target</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 被适配类</span><span class="token keyword">class</span> <span class="token class-name">Adaptee</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">specificRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Adaptee's specific request."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 对象适配器</span><span class="token keyword">class</span> <span class="token class-name">Adapter</span> <span class="token operator">:</span> <span class="token keyword">public</span> Target <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Adapter</span><span class="token punctuation">(</span>Adaptee<span class="token operator">*</span> adaptee<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">adaptee_</span><span class="token punctuation">(</span>adaptee<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        adaptee_<span class="token operator">-</span><span class="token operator">></span><span class="token function">specificRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    Adaptee<span class="token operator">*</span> adaptee_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Adaptee adaptee<span class="token punctuation">;</span>    Target<span class="token operator">*</span> adapter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Adapter</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>adaptee<span class="token punctuation">)</span><span class="token punctuation">;</span>    adapter<span class="token operator">-</span><span class="token operator">></span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> adapter<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，我们有一个目标接口 <code>Target</code>，包括 <code>request</code> 方法。我们还有一个被适配类 <code>Adaptee</code>，它包括 <code>specificRequest</code> 方法，但它的接口与 <code>Target</code> 不兼容。</p><p>然后，我们创建了一个对象适配器 <code>Adapter</code>，它实现了 <code>Target</code> 接口，并维护了一个 <code>Adaptee</code> 的实例。在 <code>Adapter</code> 的 <code>request</code> 方法中，我们将调用委托给 <code>Adaptee</code> 的 <code>specificRequest</code> 方法，从而使 <code>Adaptee</code> 可以与 <code>Target</code> 接口兼容。</p><p>适配器模式在现实中的应用非常广泛，特别是在将旧系统与新系统集成或者使用第三方库时，它可以起到很好的桥梁作用，以确保不同接口之间的兼容性。</p><p><strong>类适配器</strong></p><p>类适配器模式使用多重继承来实现适配，它继承了被适配类并实现了目标接口。以下是一个简单的类适配器模式的 C++ 示例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token comment" spellcheck="true">// 目标接口</span><span class="token keyword">class</span> <span class="token class-name">Target</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 被适配类</span><span class="token keyword">class</span> <span class="token class-name">Adaptee</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">specificRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Adaptee's specific request."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 类适配器，继承自 Adaptee 和实现 Target 接口</span><span class="token keyword">class</span> <span class="token class-name">Adapter</span> <span class="token operator">:</span> <span class="token keyword">public</span> Adaptee<span class="token punctuation">,</span> <span class="token keyword">public</span> Target <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        <span class="token function">specificRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用 Adaptee 的方法</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Target<span class="token operator">*</span> adapter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Adapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    adapter<span class="token operator">-</span><span class="token operator">></span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> adapter<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，我们有一个目标接口 <code>Target</code>，包括 <code>request</code> 方法。我们还有一个被适配类 <code>Adaptee</code>，它包括 <code>specificRequest</code> 方法，但它的接口与 <code>Target</code> 不兼容。</p><p>然后，我们创建了一个类适配器 <code>Adapter</code>，它继承自 <code>Adaptee</code> 并实现了 <code>Target</code> 接口。在 <code>Adapter</code> 的 <code>request</code> 方法中，我们可以直接调用 <code>specificRequest</code> 方法，因为 <code>Adapter</code> 继承了 <code>Adaptee</code>。</p><p>类适配器模式使用多重继承，这使得它可以同时继承多个类，但也可能引入一些复杂性。适配器模式可用于解决现有系统的接口不兼容问题，同时不需要修改被适配类的源代码。</p><h2 id="7-装饰器模式"><a href="#7-装饰器模式" class="headerlink" title="7.装饰器模式"></a>7.装饰器模式</h2><p>装饰器模式（Decorator Pattern）是一种结构型设计模式，它允许你通过将对象包装在装饰器类的实例中来动态地扩展其行为，而不需要修改其源代码。装饰器模式通常用于以下情况：</p><ol><li>动态地给对象添加功能，而不是静态继承；</li><li>需要遵循开放/封闭原则，即对扩展是开放的，对修改是封闭的；</li><li>需要通过一系列可重用的装饰器来组合不同的行为。</li></ol><p>以下是一个简单的装饰器模式的 C++ 示例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token comment" spellcheck="true">// 抽象组件接口</span><span class="token keyword">class</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 具体组件</span><span class="token keyword">class</span> <span class="token class-name">ConcreteComponent</span> <span class="token operator">:</span> <span class="token keyword">public</span> Component <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ConcreteComponent operation."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 抽象装饰器</span><span class="token keyword">class</span> <span class="token class-name">Decorator</span> <span class="token operator">:</span> <span class="token keyword">public</span> Component <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Decorator</span><span class="token punctuation">(</span>Component<span class="token operator">*</span> component<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">component_</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        component_<span class="token operator">-</span><span class="token operator">></span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    Component<span class="token operator">*</span> component_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 具体装饰器 A</span><span class="token keyword">class</span> <span class="token class-name">ConcreteDecoratorA</span> <span class="token operator">:</span> <span class="token keyword">public</span> Decorator <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">ConcreteDecoratorA</span><span class="token punctuation">(</span>Component<span class="token operator">*</span> component<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Decorator</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        Decorator<span class="token operator">::</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ConcreteDecoratorA operation."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 具体装饰器 B</span><span class="token keyword">class</span> <span class="token class-name">ConcreteDecoratorB</span> <span class="token operator">:</span> <span class="token keyword">public</span> Decorator <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">ConcreteDecoratorB</span><span class="token punctuation">(</span>Component<span class="token operator">*</span> component<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Decorator</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        Decorator<span class="token operator">::</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ConcreteDecoratorB operation."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Component<span class="token operator">*</span> component <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ConcreteComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Component<span class="token operator">*</span> decoratorA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ConcreteDecoratorA</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>    Component<span class="token operator">*</span> decoratorB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ConcreteDecoratorB</span><span class="token punctuation">(</span>decoratorA<span class="token punctuation">)</span><span class="token punctuation">;</span>    component<span class="token operator">-</span><span class="token operator">></span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 基本组件操作</span>    decoratorA<span class="token operator">-</span><span class="token operator">></span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 增加了装饰器 A 的操作</span>    decoratorB<span class="token operator">-</span><span class="token operator">></span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 增加了装饰器 A 和装饰器 B 的操作</span>    <span class="token keyword">delete</span> component<span class="token punctuation">;</span>    <span class="token keyword">delete</span> decoratorA<span class="token punctuation">;</span>    <span class="token keyword">delete</span> decoratorB<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，我们有一个抽象组件接口 <code>Component</code>，包括 <code>operation</code> 方法。具体组件 <code>ConcreteComponent</code> 实现了这个接口。</p><p>然后，我们定义了抽象装饰器 <code>Decorator</code>，它也实现了 <code>Component</code> 接口，但在 <code>operation</code> 方法中调用了包装的组件的 <code>operation</code> 方法。具体装饰器类 <code>ConcreteDecoratorA</code> 和 <code>ConcreteDecoratorB</code> 扩展了 <code>Decorator</code> 类，分别增加了特定的操作。</p><p>在 <code>main</code> 函数中，我们创建了一个基本组件 <code>component</code>，然后依次用装饰器 <code>decoratorA</code> 和 <code>decoratorB</code> 包装它。通过这样的嵌套，我们可以动态地添加不同的行为，而不需要修改组件的源代码。</p><p>装饰器模式允许我们以一种灵活的方式组合对象，以满足不同需求。这可以帮助我们遵循开放/封闭原则，同时保持代码的可维护性和可扩展性。</p><h2 id="8-代理模式"><a href="#8-代理模式" class="headerlink" title="8.代理模式"></a>8.代理模式</h2><p>代理模式（Proxy Pattern）是一种结构型设计模式，它允许你提供一个代理类，控制对其他对象的访问。代理模式通常用于以下情况：</p><ol><li>远程代理：代理对象控制对远程对象的访问，例如通过网络。</li><li>虚拟代理：代理对象控制对创建开销大的对象的访问，只在需要时创建。</li><li>保护代理：代理对象控制对对象的访问权限，用于权限控制等。</li><li>智能引用：代理对象添加额外的逻辑，例如引用计数、懒加载等。</li></ol><p>以下是一个简单的代理模式的 C++ 示例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token comment" spellcheck="true">// 抽象主题</span><span class="token keyword">class</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 具体主题</span><span class="token keyword">class</span> <span class="token class-name">RealSubject</span> <span class="token operator">:</span> <span class="token keyword">public</span> Subject <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"RealSubject handles the request."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 代理</span><span class="token keyword">class</span> <span class="token class-name">Proxy</span> <span class="token operator">:</span> <span class="token keyword">public</span> Subject <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Proxy</span><span class="token punctuation">(</span>Subject<span class="token operator">*</span> realSubject<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">realSubject_</span><span class="token punctuation">(</span>realSubject<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">checkAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            realSubject_<span class="token operator">-</span><span class="token operator">></span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">logAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Access denied."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">checkAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 检查访问权限的逻辑</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">logAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 记录访问日志的逻辑</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Access logged."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Subject<span class="token operator">*</span> realSubject_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    RealSubject realSubject<span class="token punctuation">;</span>    Proxy <span class="token function">proxy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>realSubject<span class="token punctuation">)</span><span class="token punctuation">;</span>    proxy<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，我们有一个抽象主题 <code>Subject</code>，包括 <code>request</code> 方法。具体主题 <code>RealSubject</code> 实现了这个接口，用于处理请求。</p><p>然后，我们创建了代理 <code>Proxy</code>，它也实现了 <code>Subject</code> 接口。在 <code>Proxy</code> 的 <code>request</code> 方法中，我们可以添加额外的逻辑，例如检查访问权限和记录访问日志。如果权限检查通过，它将委托给实际主题 <code>RealSubject</code> 来处理请求。</p><p>代理模式使我们能够控制对对象的访问，同时可以添加各种额外的功能，例如权限控制、懒加载、缓存等。这对于保持代码的可维护性和可扩展性非常有帮助。</p><h2 id="9-观察者模式"><a href="#9-观察者模式" class="headerlink" title="9.观察者模式"></a>9.观察者模式</h2><p>观察者模式（Observer Pattern）是一种行为型设计模式，它定义了一种一对多的依赖关系，使一个对象的状态发生变化时，其所有依赖者（观察者）都会收到通知并自动更新。观察者模式通常用于以下情况：</p><ol><li>当一个对象的状态变化需要通知其他对象，而且这些对象的数量和类型是未知的。</li><li>当一个对象需要在不知道具体操作的情况下通知其他对象。</li><li>当一个对象需要维护一系列依赖关系，以便在状态变化时能够通知所有依赖者。</li></ol><p>观察者模式包含以下几个关键角色：</p><ol><li><strong>主题（Subject）</strong>：主题是被观察的对象，它包含一组观察者对象，并提供方法来添加、删除和通知观察者。</li><li><strong>观察者（Observer）</strong>：观察者是接收主题通知的对象，它定义了更新方法，以便在主题状态发生变化时能够执行相应操作。</li></ol><p>以下是一个简单的观察者模式的 C++ 示例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token comment" spellcheck="true">// 观察者接口</span><span class="token keyword">class</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> message<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 主题接口</span><span class="token keyword">class</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">addObserver</span><span class="token punctuation">(</span>Observer<span class="token operator">*</span> observer<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">removeObserver</span><span class="token punctuation">(</span>Observer<span class="token operator">*</span> observer<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">notifyObservers</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> message<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 具体观察者</span><span class="token keyword">class</span> <span class="token class-name">ConcreteObserver</span> <span class="token operator">:</span> <span class="token keyword">public</span> Observer <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">ConcreteObserver</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> name<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">name_</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> message<span class="token punctuation">)</span> override <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> name_ <span class="token operator">&lt;&lt;</span> <span class="token string">" received message: "</span> <span class="token operator">&lt;&lt;</span> message <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>string name_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 具体主题</span><span class="token keyword">class</span> <span class="token class-name">ConcreteSubject</span> <span class="token operator">:</span> <span class="token keyword">public</span> Subject <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">addObserver</span><span class="token punctuation">(</span>Observer<span class="token operator">*</span> observer<span class="token punctuation">)</span> override <span class="token punctuation">{</span>        observers_<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">removeObserver</span><span class="token punctuation">(</span>Observer<span class="token operator">*</span> observer<span class="token punctuation">)</span> override <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 寻找并移除观察者</span>        <span class="token keyword">auto</span> it <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span>observers_<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> observers_<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> observer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> observers_<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            observers_<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">notifyObservers</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> message<span class="token punctuation">)</span> override <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Observer<span class="token operator">*</span> observer <span class="token operator">:</span> observers_<span class="token punctuation">)</span> <span class="token punctuation">{</span>            observer<span class="token operator">-</span><span class="token operator">></span><span class="token function">update</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>Observer<span class="token operator">*</span><span class="token operator">></span> observers_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ConcreteSubject subject<span class="token punctuation">;</span>    ConcreteObserver <span class="token function">observer1</span><span class="token punctuation">(</span><span class="token string">"Observer 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ConcreteObserver <span class="token function">observer2</span><span class="token punctuation">(</span><span class="token string">"Observer 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    subject<span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>observer1<span class="token punctuation">)</span><span class="token punctuation">;</span>    subject<span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>observer2<span class="token punctuation">)</span><span class="token punctuation">;</span>    subject<span class="token punctuation">.</span><span class="token function">notifyObservers</span><span class="token punctuation">(</span><span class="token string">"Hello, observers!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    subject<span class="token punctuation">.</span><span class="token function">removeObserver</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>observer1<span class="token punctuation">)</span><span class="token punctuation">;</span>    subject<span class="token punctuation">.</span><span class="token function">notifyObservers</span><span class="token punctuation">(</span><span class="token string">"Observers after removal."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，我们定义了观察者接口 <code>Observer</code> 和主题接口 <code>Subject</code>，分别包括添加、移除和通知观察者的方法。然后，我们创建了具体的观察者类 <code>ConcreteObserver</code> 和具体的主题类 <code>ConcreteSubject</code>。</p><p>在 <code>main</code> 函数中，我们创建主题对象 <code>subject</code> 和两个观察者对象 <code>observer1</code> 和 <code>observer2</code>。我们将观察者添加到主题中，然后主题通知观察者时，它们会接收到消息并执行相应的操作。</p><p>观察者模式使对象之间的关系松散，允许主题和观察者之间的独立变化，同时保持了对象之间的协作。这种模式常用于实现事件处理、发布-订阅系统以及任何需要实现对象之间松耦合通信的情况。</p><h2 id="10-策略模式"><a href="#10-策略模式" class="headerlink" title="10.策略模式"></a>10.策略模式</h2><p>策略模式（Strategy Pattern）是一种行为型设计模式，它允许定义一系列算法，并将每个算法封装到独立的策略类中，使这些算法可以互相替换。策略模式的核心思想是将算法的选择与使用分离，从而实现更灵活的算法切换，同时不需要修改上下文类的代码。</p><p>策略模式包含以下几个主要角色：</p><ol><li><strong>上下文（Context）</strong>：上下文类包含一个策略接口的引用，它可以在运行时切换不同的策略对象，以实现不同的行为。上下文类不直接实现算法，而是将算法委托给策略对象。</li><li><strong>策略（Strategy）</strong>：策略是一个接口或抽象类，定义了一个算法族的接口，具体的策略类实现了这个接口，每个策略类代表一个具体的算法。</li></ol><p>使用策略模式的主要优点包括：</p><ul><li>算法的可独立替换性：可以在运行时切换算法，而不需要修改上下文类的代码。</li><li>降低了上下文类的复杂性：上下文类只需要关注如何选择和使用策略，而不需要实现具体算法。</li><li>提高了代码的可维护性和可扩展性：每个策略类可以独立开发和测试，容易新增新的策略。</li></ul><p>以下是一个简单的策略模式的 C++ 示例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token comment" spellcheck="true">// 策略接口</span><span class="token keyword">class</span> <span class="token class-name">Strategy</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">doOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 具体策略 A</span><span class="token keyword">class</span> <span class="token class-name">ConcreteStrategyA</span> <span class="token operator">:</span> <span class="token keyword">public</span> Strategy <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">doOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Using Strategy A"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 具体策略 B</span><span class="token keyword">class</span> <span class="token class-name">ConcreteStrategyB</span> <span class="token operator">:</span> <span class="token keyword">public</span> Strategy <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">doOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Using Strategy B"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 上下文</span><span class="token keyword">class</span> <span class="token class-name">Context</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Context</span><span class="token punctuation">(</span>Strategy<span class="token operator">*</span> strategy<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">strategy_</span><span class="token punctuation">(</span>strategy<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">setStrategy</span><span class="token punctuation">(</span>Strategy<span class="token operator">*</span> strategy<span class="token punctuation">)</span> <span class="token punctuation">{</span>        strategy_ <span class="token operator">=</span> strategy<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">executeStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        strategy_<span class="token operator">-</span><span class="token operator">></span><span class="token function">doOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    Strategy<span class="token operator">*</span> strategy_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ConcreteStrategyA strategyA<span class="token punctuation">;</span>    ConcreteStrategyB strategyB<span class="token punctuation">;</span>    Context <span class="token function">context</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>strategyA<span class="token punctuation">)</span><span class="token punctuation">;</span>    context<span class="token punctuation">.</span><span class="token function">executeStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    context<span class="token punctuation">.</span><span class="token function">setStrategy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>strategyB<span class="token punctuation">)</span><span class="token punctuation">;</span>    context<span class="token punctuation">.</span><span class="token function">executeStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，我们有一个策略接口 <code>Strategy</code>，定义了算法族的接口。然后，我们创建了两个具体策略类 <code>ConcreteStrategyA</code> 和 <code>ConcreteStrategyB</code>，分别实现了不同的算法。</p><p>上下文类 <code>Context</code> 包含一个策略对象的引用，它可以在运行时切换不同的策略。当调用 <code>executeStrategy</code> 方法时，上下文类会委托策略对象执行相应的算法。</p><p>策略模式的应用范围很广，可以用于任何需要动态地选择算法的场景，例如排序算法、计算费用、路由策略等。</p><h2 id="11-命令模式"><a href="#11-命令模式" class="headerlink" title="11.命令模式"></a>11.命令模式</h2><p>命令模式（Command Pattern）是一种行为型设计模式，它将请求封装成一个对象，从而允许你参数化不同的请求、将请求排队、记录请求日志，或者支持可撤销的操作。命令模式的核心思想是将请求的发送者与请求的接收者解耦。</p><p>命令模式包含以下几个主要角色：</p><ol><li><strong>命令（Command）</strong>：命令是一个抽象类或接口，它定义了执行请求的方法 <code>execute</code>。具体的命令类将实现这个接口，将请求参数绑定到接收者，并在 <code>execute</code> 方法中执行具体的操作。</li><li><strong>具体命令（Concrete Command）</strong>：具体命令是命令接口的具体实现，它包括一个接收者对象，负责执行具体的操作。</li><li><strong>接收者（Receiver）</strong>：接收者是具体命令类的执行者，它包含了具体的业务逻辑，命令类将请求委派给接收者来执行。</li><li><strong>调用者（Invoker）</strong>：调用者是负责向命令对象发送请求的对象，它不需要了解命令是如何执行的，只需要将请求发送给命令对象。</li></ol><p>命令模式的主要优点包括：</p><ul><li>解耦命令发送者和命令执行者。</li><li>支持撤销和重做操作。</li><li>支持命令的组合，可以构建复杂的命令序列。</li></ul><p>以下是一个简单的命令模式的 C++ 示例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token comment" spellcheck="true">// 命令接口</span><span class="token keyword">class</span> <span class="token class-name">Command</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 具体命令</span><span class="token keyword">class</span> <span class="token class-name">LightOnCommand</span> <span class="token operator">:</span> <span class="token keyword">public</span> Command <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">LightOnCommand</span><span class="token punctuation">(</span>Light<span class="token operator">&amp;</span> light<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">light_</span><span class="token punctuation">(</span>light<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        light_<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    Light<span class="token operator">&amp;</span> light_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 接收者</span><span class="token keyword">class</span> <span class="token class-name">Light</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">on</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Light is on"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">off</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Light is off"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 调用者</span><span class="token keyword">class</span> <span class="token class-name">RemoteControl</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">setCommand</span><span class="token punctuation">(</span>Command<span class="token operator">*</span> command<span class="token punctuation">)</span> <span class="token punctuation">{</span>        command_ <span class="token operator">=</span> command<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">pressButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        command_<span class="token operator">-</span><span class="token operator">></span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    Command<span class="token operator">*</span> command_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Light livingRoomLight<span class="token punctuation">;</span>    LightOnCommand <span class="token function">livingRoomLightOn</span><span class="token punctuation">(</span>livingRoomLight<span class="token punctuation">)</span><span class="token punctuation">;</span>    RemoteControl remote<span class="token punctuation">;</span>    remote<span class="token punctuation">.</span><span class="token function">setCommand</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>livingRoomLightOn<span class="token punctuation">)</span><span class="token punctuation">;</span>    remote<span class="token punctuation">.</span><span class="token function">pressButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，我们有一个命令接口 <code>Command</code>，定义了 <code>execute</code> 方法。具体命令 <code>LightOnCommand</code> 包含一个接收者对象 <code>Light</code>，在 <code>execute</code> 方法中调用接收者的方法。</p><p>调用者 <code>RemoteControl</code> 通过设置具体命令对象，并调用 <code>pressButton</code> 方法来执行命令。这种方式实现了调用者和接收者的解耦，调用者只需要知道如何发送命令，而不需要知道命令是如何执行的。</p><p>命令模式非常适用于构建可扩展和可维护的系统，特别是需要支持撤销、重做和构建复杂命令序列的情况。</p><h2 id="12-状态模式"><a href="#12-状态模式" class="headerlink" title="12.状态模式"></a>12.状态模式</h2><p>状态模式（State Pattern）是一种行为型设计模式，它允许对象在其内部状态改变时改变其行为。状态模式的核心思想是将不同状态抽象为独立的状态类，使对象能够在运行时切换不同状态，而不需要修改其代码。</p><p>状态模式包含以下几个主要角色：</p><ol><li><strong>上下文（Context）</strong>：上下文类是包含状态的对象，它在运行时可以切换不同的状态对象。上下文类通常包括状态接口的引用，用于与当前状态进行交互。</li><li><strong>状态（State）</strong>：状态是一个抽象类或接口，它定义了一个特定状态的行为。具体的状态类将实现这个接口，每个状态类代表一个具体的状态，并定义了状态下的行为。</li></ol><p>状态模式的主要优点包括：</p><ul><li>将状态的行为封装在独立的状态类中，降低了上下文类的复杂性。</li><li>支持动态切换状态，使对象能够在运行时改变行为。</li><li>易于添加新的状态，同时不需要修改现有代码。</li></ul><p>以下是一个简单的状态模式的 C++ 示例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token comment" spellcheck="true">// 状态接口</span><span class="token keyword">class</span> <span class="token class-name">State</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 具体状态 A</span><span class="token keyword">class</span> <span class="token class-name">ConcreteStateA</span> <span class="token operator">:</span> <span class="token keyword">public</span> State <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Handling state A"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 具体状态 B</span><span class="token keyword">class</span> <span class="token class-name">ConcreteStateB</span> <span class="token operator">:</span> <span class="token keyword">public</span> State <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Handling state B"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 上下文</span><span class="token keyword">class</span> <span class="token class-name">Context</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">setState</span><span class="token punctuation">(</span>State<span class="token operator">*</span> state<span class="token punctuation">)</span> <span class="token punctuation">{</span>        state_ <span class="token operator">=</span> state<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        state_<span class="token operator">-</span><span class="token operator">></span><span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    State<span class="token operator">*</span> state_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ConcreteStateA stateA<span class="token punctuation">;</span>    ConcreteStateB stateB<span class="token punctuation">;</span>    Context context<span class="token punctuation">;</span>    context<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stateA<span class="token punctuation">)</span><span class="token punctuation">;</span>    context<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    context<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stateB<span class="token punctuation">)</span><span class="token punctuation">;</span>    context<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，我们有一个状态接口 <code>State</code>，定义了 <code>handle</code> 方法，具体状态类 <code>ConcreteStateA</code> 和 <code>ConcreteStateB</code> 分别实现了这个接口。</p><p>上下的 <code>Context</code> 包含一个状态对象的引用，它可以在运行时切换不同的状态。当调用 <code>request</code> 方法时，上下文对象会委托给当前状态对象来执行特定的行为。</p><p>状态模式使对象能够根据内部状态的改变而改变行为，这有助于消除大量的条件分支，提高了代码的可维护性和可扩展性。状态模式常用于处理对象的状态机、有限状态机、工作流等场景。</p><h2 id="13-模板方法模式"><a href="#13-模板方法模式" class="headerlink" title="13.模板方法模式"></a>13.模板方法模式</h2><p>模板方法模式（Template Method Pattern）是一种行为型设计模式，它定义了一组算法的骨架，将一些步骤延迟到子类实现。模板方法模式允许子类在不改变算法结构的情况下重新定义算法的某些步骤。</p><p>模板方法模式包含以下几个主要角色：</p><ol><li><strong>模板方法（Template Method）</strong>：模板方法是一个抽象类，它定义了一个算法的骨架，包括一组步骤，其中一些步骤由子类实现。</li><li><strong>具体模板（Concrete Template）</strong>：具体模板类是模板方法的具体实现，它实现了模板方法中定义的具体步骤，其中一些步骤可能由子类实现。</li></ol><p>模板方法模式的主要特点包括：</p><ul><li>定义了一个算法的骨架，其中一些步骤延迟到子类实现。</li><li>子类可以重新定义模板方法中的特定步骤，以满足其特定需求，而无需改变算法的整体结构。</li><li>模板方法模式使得代码重用和扩展变得更加容易。</li></ul><p>以下是一个简单的模板方法模式的 C++ 示例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token comment" spellcheck="true">// 模板方法</span><span class="token keyword">class</span> <span class="token class-name">AbstractClass</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">// 模板方法定义了算法的骨架，包括一组步骤</span>    <span class="token keyword">void</span> <span class="token function">templateMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">step1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">step2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">step3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 具体步骤由子类实现</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">step1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">step2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">step3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 具体模板</span><span class="token keyword">class</span> <span class="token class-name">ConcreteClassA</span> <span class="token operator">:</span> <span class="token keyword">public</span> AbstractClass <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">step1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ConcreteClassA - Step 1"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">step2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ConcreteClassA - Step 2"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">step3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ConcreteClassA - Step 3"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">ConcreteClassB</span> <span class="token operator">:</span> <span class="token keyword">public</span> AbstractClass <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">step1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ConcreteClassB - Step 1"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">step2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ConcreteClassB - Step 2"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">step3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ConcreteClassB - Step 3"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ConcreteClassA a<span class="token punctuation">;</span>    ConcreteClassB b<span class="token punctuation">;</span>    a<span class="token punctuation">.</span><span class="token function">templateMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    b<span class="token punctuation">.</span><span class="token function">templateMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，我们有一个抽象类 <code>AbstractClass</code>，它定义了一个模板方法 <code>templateMethod</code>，包括一组步骤（<code>step1</code>、<code>step2</code>、<code>step3</code>）。具体的步骤由子类实现。具体子类 <code>ConcreteClassA</code> 和 <code>ConcreteClassB</code> 分别实现了这些步骤。</p><p>当我们调用 <code>templateMethod</code> 时，模板方法会按照定义的算法骨架执行各个步骤。不同的子类可以重新定义这些步骤，以满足其特定需求。</p><p>模板方法模式非常适用于需要定义算法骨架但允许某些步骤由子类自定义的情况，例如，创建框架、工作流程或其他多步骤的操作。这有助于提高代码的可复用性和可维护性。</p><h2 id="14-访问者模式（Visitor）"><a href="#14-访问者模式（Visitor）" class="headerlink" title="14.访问者模式（Visitor）"></a>14.访问者模式（Visitor）</h2><p>访问者模式（Visitor Pattern）是一种行为型设计模式，它用于分离数据结构和数据操作，并允许在不修改数据结构的情况下添加新的操作。访问者模式的核心思想是将数据结构和操作分离，使得数据结构可以在不同的操作下表现不同的行为。</p><p>访问者模式包含以下几个主要角色：</p><ol><li><strong>访问者（Visitor）</strong>：访问者是一个抽象类或接口，它定义了一组访问操作，每个操作对应一个具体的元素类型。</li><li><strong>具体访问者（Concrete Visitor）</strong>：具体访问者是访问者接口的具体实现，每个具体访问者实现了一组具体的访问操作。</li><li><strong>元素（Element）</strong>：元素是一个抽象类或接口，它定义了一个 <code>accept</code> 方法，该方法接受一个访问者对象作为参数，允许访问者访问该元素。</li><li><strong>具体元素（Concrete Element）</strong>：具体元素是元素接口的具体实现，每个具体元素实现了 <code>accept</code> 方法，用于调用访问者的相应操作。</li><li><strong>对象结构（Object Structure）</strong>：对象结构是一个包含多个元素的集合，它通常提供一个接受访问者的方法，用于遍历元素并调用访问者的操作。</li></ol><p>访问者模式的主要优点包括：</p><ul><li>分离了数据结构和数据操作，使得可以添加新的操作而无需修改现有数据结构。</li><li>支持对数据结构进行不同的操作，从而提供更多的灵活性和扩展性。</li><li>使得数据结构可以遵循开闭原则（Open/Closed Principle），即对扩展开放，对修改关闭。</li></ul><p>以下是一个简单的访问者模式的 C++ 示例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token comment" spellcheck="true">// 前向声明，让元素类知道访问者类</span><span class="token keyword">class</span> <span class="token class-name">Visitor</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 元素接口</span><span class="token keyword">class</span> <span class="token class-name">Element</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span>Visitor<span class="token operator">&amp;</span> visitor<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 具体元素 A</span><span class="token keyword">class</span> <span class="token class-name">ConcreteElementA</span> <span class="token operator">:</span> <span class="token keyword">public</span> Element <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span>Visitor<span class="token operator">&amp;</span> visitor<span class="token punctuation">)</span> override <span class="token punctuation">{</span>        visitor<span class="token punctuation">.</span><span class="token function">visitElementA</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">operationA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Operation A on ConcreteElementA"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 具体元素 B</span><span class="token keyword">class</span> <span class="token class-name">ConcreteElementB</span> <span class="token operator">:</span> <span class="token keyword">public</span> Element <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span>Visitor<span class="token operator">&amp;</span> visitor<span class="token punctuation">)</span> override <span class="token punctuation">{</span>        visitor<span class="token punctuation">.</span><span class="token function">visitElementB</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">operationB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Operation B on ConcreteElementB"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 访问者接口</span><span class="token keyword">class</span> <span class="token class-name">Visitor</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">visitElementA</span><span class="token punctuation">(</span>ConcreteElementA<span class="token operator">&amp;</span> element<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">visitElementB</span><span class="token punctuation">(</span>ConcreteElementB<span class="token operator">&amp;</span> element<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 具体访问者</span><span class="token keyword">class</span> <span class="token class-name">ConcreteVisitor</span> <span class="token operator">:</span> <span class="token keyword">public</span> Visitor <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">visitElementA</span><span class="token punctuation">(</span>ConcreteElementA<span class="token operator">&amp;</span> element<span class="token punctuation">)</span> override <span class="token punctuation">{</span>        element<span class="token punctuation">.</span><span class="token function">operationA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">visitElementB</span><span class="token punctuation">(</span>ConcreteElementB<span class="token operator">&amp;</span> element<span class="token punctuation">)</span> override <span class="token punctuation">{</span>        element<span class="token punctuation">.</span><span class="token function">operationB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ConcreteElementA elementA<span class="token punctuation">;</span>    ConcreteElementB elementB<span class="token punctuation">;</span>    ConcreteVisitor visitor<span class="token punctuation">;</span>    elementA<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>visitor<span class="token punctuation">)</span><span class="token punctuation">;</span>    elementB<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>visitor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，我们有两种具体元素 <code>ConcreteElementA</code> 和 <code>ConcreteElementB</code>，它们都实现了元素接口，并提供了 <code>accept</code> 方法，以允许访问者访问这些元素。</p><p>具体访问者 <code>ConcreteVisitor</code> 实现了访问者接口中定义的访问操作，其中包括操作 A 和操作 B。</p><p>通过访问者模式，我们可以在不修改元素类的情况下，为元素类添加新的操作（在这个示例中是操作 A 和操作 B）。这种分离数据结构和操作的设计模式使得代码更加灵活和可维护。</p><h2 id="15-组合模式（Composite）"><a href="#15-组合模式（Composite）" class="headerlink" title="15.组合模式（Composite）"></a>15.组合模式（Composite）</h2><p>组合模式（Composite Pattern）是一种结构型设计模式，用于将对象组合成树状结构以表示“部分-整体”的层次结构。组合模式允许客户端以一致的方式处理单个对象和对象组合。</p><p>组合模式包含以下几个主要角色：</p><ol><li><strong>组件（Component）</strong>：组件是一个抽象类或接口，它声明了管理子组件的方法，以及其他操作的接口。</li><li><strong>叶子（Leaf）</strong>：叶子是组件的具体实现，它表示树结构中的叶子节点，不包含子组件。</li><li><strong>容器（Composite）</strong>：容器是组件的具体实现，它表示树结构中的分支节点，可以包含子组件。容器类通常会实现管理子组件的方法。</li></ol><p>组合模式的主要优点包括：</p><ul><li>客户端可以以一致的方式处理单个对象和对象组合，无需知道具体组件的类型。</li><li>可以递归地构建复杂的对象结构，使代码具有更高的可扩展性。</li><li>通过组合模式，可以更容易地添加新的组件类型。</li></ul><p>以下是一个简单的组合模式的 C++ 示例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token comment" spellcheck="true">// 抽象组件</span><span class="token keyword">class</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 叶子组件</span><span class="token keyword">class</span> <span class="token class-name">Leaf</span> <span class="token operator">:</span> <span class="token keyword">public</span> Component <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Leaf operation"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 容器组件</span><span class="token keyword">class</span> <span class="token class-name">Composite</span> <span class="token operator">:</span> <span class="token keyword">public</span> Component <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Composite operation"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 调用子组件的操作</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Component<span class="token operator">*</span> child <span class="token operator">:</span> children_<span class="token punctuation">)</span> <span class="token punctuation">{</span>            child<span class="token operator">-</span><span class="token operator">></span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>Component<span class="token operator">*</span> component<span class="token punctuation">)</span> <span class="token punctuation">{</span>        children_<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>Component<span class="token operator">*</span><span class="token operator">></span> children_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Leaf leaf1<span class="token punctuation">,</span> leaf2<span class="token punctuation">;</span>    Composite composite<span class="token punctuation">;</span>    composite<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>leaf1<span class="token punctuation">)</span><span class="token punctuation">;</span>    composite<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>leaf2<span class="token punctuation">)</span><span class="token punctuation">;</span>    composite<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，我们有一个抽象组件 <code>Component</code>，包括一个操作方法 <code>operation</code>。<code>Leaf</code> 类是叶子组件，它是组件的具体实现，而 <code>Composite</code> 类是容器组件，它可以包含多个子组件。</p><p>在 <code>main</code> 函数中，我们创建了两个叶子组件和一个容器组件，并将叶子组件添加到容器组件中。当调用容器组件的 <code>operation</code> 方法时，它会递归调用其子组件的 <code>operation</code> 方法，从而实现了整体-部分的层次结构。</p><p>组合模式常用于处理树状结构，例如文件系统、图形界面控件、组织架构等情况，其中可以递归地组合和管理各种对象。</p><h2 id="16-迭代器模式"><a href="#16-迭代器模式" class="headerlink" title="16.迭代器模式"></a>16.迭代器模式</h2><p>迭代器模式（Iterator Pattern）是一种行为型设计模式，用于提供一种访问聚合对象中各个元素的方法，而无需暴露聚合对象的内部表示。迭代器模式将遍历聚合对象的操作封装在一个迭代器对象中，使客户端能够以一致的方式遍历不同类型的聚合对象。</p><p>迭代器模式包含以下几个主要角色：</p><ol><li><strong>迭代器（Iterator）</strong>：迭代器是一个抽象接口，它定义了用于遍历聚合对象的方法，包括移动到下一个元素、检查是否还有元素等操作。</li><li><strong>具体迭代器（Concrete Iterator）</strong>：具体迭代器是迭代器接口的具体实现，它实现了在特定聚合对象上的遍历方法。</li><li><strong>聚合（Aggregate）</strong>：聚合是一个抽象接口，它定义了用于创建迭代器的方法。</li><li><strong>具体聚合（Concrete Aggregate）</strong>：具体聚合是聚合接口的具体实现，它包含了一组元素，可以生成相应的具体迭代器。</li></ol><p>迭代器模式的主要优点包括：</p><ul><li>客户端可以通过迭代器以一致的方式遍历不同类型的聚合对象，无需关心具体的数据结构。</li><li>迭代器模式将遍历操作封装在独立的迭代器对象中，使聚合对象的结构保持私有，提高了封装性。</li><li>支持多种迭代方式，例如正向遍历、反向遍历、跳跃式遍历等。</li></ul><p>以下是一个简单的迭代器模式的 C++ 示例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token comment" spellcheck="true">// 抽象迭代器</span><span class="token keyword">class</span> <span class="token class-name">Iterator</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">int</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">bool</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 具体迭代器</span><span class="token keyword">class</span> <span class="token class-name">ConcreteIterator</span> <span class="token operator">:</span> <span class="token keyword">public</span> Iterator <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">ConcreteIterator</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> collection<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">collection_</span><span class="token punctuation">(</span>collection<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">index_</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        <span class="token keyword">return</span> collection_<span class="token punctuation">[</span>index_<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        <span class="token keyword">return</span> index_ <span class="token operator">&lt;</span> collection_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> collection_<span class="token punctuation">;</span>    <span class="token keyword">int</span> index_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 抽象聚合</span><span class="token keyword">class</span> <span class="token class-name">Aggregate</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> Iterator<span class="token operator">*</span> <span class="token function">createIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 具体聚合</span><span class="token keyword">class</span> <span class="token class-name">ConcreteAggregate</span> <span class="token operator">:</span> <span class="token keyword">public</span> Aggregate <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">ConcreteAggregate</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> collection<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">collection_</span><span class="token punctuation">(</span>collection<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    Iterator<span class="token operator">*</span> <span class="token function">createIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">ConcreteIterator</span><span class="token punctuation">(</span>collection_<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> collection_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    ConcreteAggregate <span class="token function">aggregate</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    Iterator<span class="token operator">*</span> iterator <span class="token operator">=</span> aggregate<span class="token punctuation">.</span><span class="token function">createIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token operator">-</span><span class="token operator">></span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> iterator<span class="token operator">-</span><span class="token operator">></span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">delete</span> iterator<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，我们有一个抽象迭代器 <code>Iterator</code>，具体迭代器 <code>ConcreteIterator</code>，抽象聚合 <code>Aggregate</code>，以及具体聚合 <code>ConcreteAggregate</code>。</p><p>具体聚合 <code>ConcreteAggregate</code> 包含了一组整数元素，并提供了创建迭代器的方法。具体迭代器 <code>ConcreteIterator</code> 实现了在集合上的遍历操作。</p><p>在 <code>main</code> 函数中，我们创建了一个包含整数的聚合对象，然后创建了一个迭代器对象，通过迭代器以一致的方式遍历聚合中的元素。这种设计模式使得客户端可以在不关心聚合内部结构的情况下进行遍历操作。</p><h2 id="17-中介者模式（Mediator）"><a href="#17-中介者模式（Mediator）" class="headerlink" title="17.中介者模式（Mediator）"></a>17.中介者模式（Mediator）</h2><p>中介者模式（Mediator Pattern）是一种行为型设计模式，它用于减少对象之间的直接通信，将对象间的交互通过一个中介者对象进行协调和控制。中介者模式有助于降低系统中对象之间的耦合度，使系统更易维护和扩展。</p><p>中介者模式包含以下几个主要角色：</p><ol><li><strong>中介者（Mediator）</strong>：中介者是一个接口或抽象类，它定义了对象之间交互的方法，包括注册、通知、协调等。</li><li><strong>具体中介者（Concrete Mediator）</strong>：具体中介者是中介者接口的具体实现，它协调各个相关对象之间的交互，并维护对象之间的引用。</li><li><strong>同事类（Colleague）</strong>：同事类是相互交互的对象，它们通过中介者来进行通信，而不直接依赖其他同事类。</li></ol><p>中介者模式的主要优点包括：</p><ul><li>降低了对象之间的直接耦合，使系统更加灵活和可维护。</li><li>可以集中控制对象之间的交互，使系统的交互逻辑更清晰。</li><li>支持新增和删除同事类，对系统扩展更加友好。</li></ul><p>以下是一个简单的中介者模式的 C++ 示例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token comment" spellcheck="true">// 抽象中介者</span><span class="token keyword">class</span> <span class="token class-name">Mediator</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> message<span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Colleague</span><span class="token operator">*</span> colleague<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 具体中介者</span><span class="token keyword">class</span> <span class="token class-name">ConcreteMediator</span> <span class="token operator">:</span> <span class="token keyword">public</span> Mediator <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> message<span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Colleague</span><span class="token operator">*</span> colleague<span class="token punctuation">)</span> override <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Message from "</span> <span class="token operator">&lt;&lt;</span> colleague<span class="token operator">-</span><span class="token operator">></span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> message <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 同事类</span><span class="token keyword">class</span> <span class="token class-name">Colleague</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Colleague</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> name<span class="token punctuation">,</span> Mediator<span class="token operator">*</span> mediator<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">name_</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mediator_</span><span class="token punctuation">(</span>mediator<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mediator_<span class="token operator">-</span><span class="token operator">></span><span class="token function">sendMessage</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name_<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>string name_<span class="token punctuation">;</span>    Mediator<span class="token operator">*</span> mediator_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ConcreteMediator mediator<span class="token punctuation">;</span>    Colleague <span class="token function">colleague1</span><span class="token punctuation">(</span><span class="token string">"Colleague 1"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>mediator<span class="token punctuation">)</span><span class="token punctuation">;</span>    Colleague <span class="token function">colleague2</span><span class="token punctuation">(</span><span class="token string">"Colleague 2"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>mediator<span class="token punctuation">)</span><span class="token punctuation">;</span>    colleague1<span class="token punctuation">.</span><span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token string">"Hello from Colleague 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    colleague2<span class="token punctuation">.</span><span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token string">"Hi from Colleague 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，我们有一个抽象中介者 <code>Mediator</code>，具体中介者 <code>ConcreteMediator</code>，以及两个同事类 <code>Colleague</code>。同事类通过中介者来发送消息，而不直接与其他同事类进行通信。</p><p>中介者模式在协调对象之间的交互时非常有用，特别是在大型系统中，当对象之间的交互关系复杂时，可以通过引入中介者来简化和集中控制交互逻辑。这有助于减少系统的复杂性和提高可维护性。</p><h2 id="18-备忘录模式（Memento）"><a href="#18-备忘录模式（Memento）" class="headerlink" title="18.备忘录模式（Memento）"></a>18.备忘录模式（Memento）</h2><p>备忘录模式（Memento Pattern）是一种行为型设计模式，它用于捕获一个对象的内部状态，并将其保存在一个外部对象中，从而可以在以后将对象恢复到先前的状态。备忘录模式的关键思想是在不破坏封装性的前提下，将对象的状态保存和恢复。</p><p>备忘录模式包含以下几个主要角色：</p><ol><li><strong>发起人（Originator）</strong>：发起人是需要保存状态的对象。它有一个创建备忘录和恢复备忘录的方法。发起人的状态可能会变化，可以使用备忘录来保存不同时间点的状态。</li><li><strong>备忘录（Memento）</strong>：备忘录是保存发起人状态的对象。它包含了发起人在某一时刻的状态信息。</li><li><strong>管理者（Caretaker）</strong>：管理者是用于保存和管理备忘录的对象。它可以保存多个备忘录，以便在需要时恢复发起人的状态。</li></ol><p>备忘录模式的主要优点包括：</p><ul><li>允许在不破坏封装性的情况下保存对象的状态，从而可以实现状态的撤销和恢复操作。</li><li>提供了一种简单的方式来保存和管理对象的历史状态，支持多次撤销操作。</li><li>可以降低发起人对象的复杂性，因为状态保存和恢复的逻辑由备忘录和管理者处理。</li></ul><p>以下是一个简单的备忘录模式的 C++ 示例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token comment" spellcheck="true">// 备忘录类</span><span class="token keyword">class</span> <span class="token class-name">Memento</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Memento</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> state<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">state_</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> state_<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>string state_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 发起人类</span><span class="token keyword">class</span> <span class="token class-name">Originator</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">setState</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> state<span class="token punctuation">)</span> <span class="token punctuation">{</span>        state_ <span class="token operator">=</span> state<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> state_<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Memento <span class="token function">createMemento</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">Memento</span><span class="token punctuation">(</span>state_<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">restoreMemento</span><span class="token punctuation">(</span><span class="token keyword">const</span> Memento<span class="token operator">&amp;</span> memento<span class="token punctuation">)</span> <span class="token punctuation">{</span>        state_ <span class="token operator">=</span> memento<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>string state_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 管理者类</span><span class="token keyword">class</span> <span class="token class-name">Caretaker</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">saveMemento</span><span class="token punctuation">(</span><span class="token keyword">const</span> Memento<span class="token operator">&amp;</span> memento<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mementos_<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>memento<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Memento <span class="token function">getMemento</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> index <span class="token operator">&lt;</span> mementos_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> mementos_<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 返回一个空的备忘录以示错误</span>        <span class="token keyword">return</span> <span class="token function">Memento</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>Memento<span class="token operator">></span> mementos_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Originator originator<span class="token punctuation">;</span>    Caretaker caretaker<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 设置初始状态并保存备忘录</span>    originator<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token string">"State 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    caretaker<span class="token punctuation">.</span><span class="token function">saveMemento</span><span class="token punctuation">(</span>originator<span class="token punctuation">.</span><span class="token function">createMemento</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 修改状态并保存备忘录</span>    originator<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token string">"State 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    caretaker<span class="token punctuation">.</span><span class="token function">saveMemento</span><span class="token punctuation">(</span>originator<span class="token punctuation">.</span><span class="token function">createMemento</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 恢复到第一个备忘录状态</span>    originator<span class="token punctuation">.</span><span class="token function">restoreMemento</span><span class="token punctuation">(</span>caretaker<span class="token punctuation">.</span><span class="token function">getMemento</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Current state: "</span> <span class="token operator">&lt;&lt;</span> originator<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，<code>Originator</code> 类表示发起人，它有一个状态需要保存。<code>Memento</code> 类表示备忘录，它可以保存发起人的状态。<code>Caretaker</code> 类表示管理者，它可以保存和管理备忘录。</p><p>在 <code>main</code> 函数中，我们设置了初始状态，并保存了备忘录。然后，修改状态并再次保存备忘录。最后，我们恢复到第一个备忘录状态，从而实现了状态的撤销和恢复操作。备忘录模式非常有用，特别是在需要实现撤销和恢复功能的应用中。</p><h2 id="19-桥接模式"><a href="#19-桥接模式" class="headerlink" title="19.桥接模式"></a>19.桥接模式</h2><p>桥接模式（Bridge Pattern）是一种结构型设计模式，它用于将抽象部分与实现部分分离，以便它们可以独立地变化。桥接模式的目的是将继承关系转化为组合关系，从而减少类之间的耦合度，提高系统的可扩展性。</p><p>桥接模式包含以下几个主要角色：</p><ol><li><strong>抽象部分（Abstraction）</strong>：抽象部分定义了对实现部分的接口，它维护一个对实现部分的引用，并可以通过委托给实现部分来完成具体的操作。</li><li><strong>扩展抽象部分（Refined Abstraction）</strong>：扩展抽象部分是对抽象部分的扩展，通常会增加一些额外的操作。</li><li><strong>实现部分（Implementor）</strong>：实现部分定义了具体操作的接口，它可以是一个抽象类或接口，也可以是具体类。</li><li><strong>具体实现部分（Concrete Implementor）</strong>：具体实现部分是实现部分的具体实现，它实现了实现部分定义的接口。</li></ol><p>桥接模式的主要优点包括：</p><ul><li>分离抽象部分和实现部分，使它们可以独立变化，增加了系统的灵活性。</li><li>对于不同的抽象部分，可以选择不同的实现部分，从而实现了多样化的组合。</li><li>提高了系统的可扩展性，新的抽象部分和实现部分可以方便地添加。</li></ul><p>以下是一个简单的桥接模式的 C++ 示例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token comment" spellcheck="true">// 实现部分接口</span><span class="token keyword">class</span> <span class="token class-name">Implementor</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">operationImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 具体实现部分 A</span><span class="token keyword">class</span> <span class="token class-name">ConcreteImplementorA</span> <span class="token operator">:</span> <span class="token keyword">public</span> Implementor <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">operationImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Concrete Implementor A operation"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 具体实现部分 B</span><span class="token keyword">class</span> <span class="token class-name">ConcreteImplementorB</span> <span class="token operator">:</span> <span class="token keyword">public</span> Implementor <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">operationImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Concrete Implementor B operation"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 抽象部分</span><span class="token keyword">class</span> <span class="token class-name">Abstraction</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Abstraction</span><span class="token punctuation">(</span>Implementor<span class="token operator">*</span> implementor<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">implementor_</span><span class="token punctuation">(</span>implementor<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        implementor_<span class="token operator">-</span><span class="token operator">></span><span class="token function">operationImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    Implementor<span class="token operator">*</span> implementor_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 扩展抽象部分</span><span class="token keyword">class</span> <span class="token class-name">RefinedAbstraction</span> <span class="token operator">:</span> <span class="token keyword">public</span> Abstraction <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">RefinedAbstraction</span><span class="token punctuation">(</span>Implementor<span class="token operator">*</span> implementor<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Abstraction</span><span class="token punctuation">(</span>implementor<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">additionalOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Additional operation"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Implementor<span class="token operator">*</span> implA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ConcreteImplementorA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Implementor<span class="token operator">*</span> implB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ConcreteImplementorB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Abstraction<span class="token operator">*</span> abstraction1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Abstraction</span><span class="token punctuation">(</span>implA<span class="token punctuation">)</span><span class="token punctuation">;</span>    abstraction1<span class="token operator">-</span><span class="token operator">></span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Abstraction<span class="token operator">*</span> abstraction2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">RefinedAbstraction</span><span class="token punctuation">(</span>implB<span class="token punctuation">)</span><span class="token punctuation">;</span>    abstraction2<span class="token operator">-</span><span class="token operator">></span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>RefinedAbstraction<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>abstraction2<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">additionalOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> implA<span class="token punctuation">;</span>    <span class="token keyword">delete</span> implB<span class="token punctuation">;</span>    <span class="token keyword">delete</span> abstraction1<span class="token punctuation">;</span>    <span class="token keyword">delete</span> abstraction2<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，我们有两个实现部分：<code>ConcreteImplementorA</code> 和 <code>ConcreteImplementorB</code>，它们实现了 <code>Implementor</code> 接口。然后，我们有抽象部分 <code>Abstraction</code> 和扩展抽象部分 <code>RefinedAbstraction</code>，它们使用实现部分来完成操作。</p><p>在 <code>main</code> 函数中，我们创建了两个不同的实现部分，然后分别将它们与抽象部分和扩展抽象部分组合。通过这种方式，我们可以轻松地改变抽象部分和实现部分的组合，实现不同的操作。这是桥接模式的典型应用。</p><h2 id="20-解释器模式（Interpreter）"><a href="#20-解释器模式（Interpreter）" class="headerlink" title="20.解释器模式（Interpreter）"></a>20.解释器模式（Interpreter）</h2><p>解释器模式（Interpreter Pattern）是一种行为型设计模式，它用于定义一种语言的文法规则，并提供一个解释器来解释语言中的表达式。该模式将一个句子（语法）分解成一系列的解释动作。解释器模式常用于编译器、解析器和领域特定语言的实现中。</p><p>解释器模式包含以下几个主要角色：</p><ol><li><strong>抽象表达式（Abstract Expression）</strong>：抽象表达式定义了解释器的接口，包含一个 <code>interpret</code> 方法用于解释表达式。</li><li><strong>终结符表达式（Terminal Expression）</strong>：终结符表达式是继承自抽象表达式的类，它实现了 <code>interpret</code> 方法用于解释终结符表达式。</li><li><strong>非终结符表达式（Non-terminal Expression）</strong>：非终结符表达式也是继承自抽象表达式的类，它通常包含多个子表达式，并实现了 <code>interpret</code> 方法用于解释非终结符表达式。</li><li><strong>上下文（Context）</strong>：上下文包含要解释的文法规则的信息，通常包含解释器所需的数据。</li><li><strong>客户端（Client）</strong>：客户端创建并配置解释器，然后使用解释器来解释表达式。</li></ol><p>解释器模式的主要优点是可以扩展语言的语法，以及在一些特定领域中解决问题。然而，它也有一些缺点，例如对于复杂的文法规则，解释器模式可能会变得复杂，难以维护。</p><p>以下是一个简单的解释器模式的 C++ 示例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unordered_map></span></span><span class="token comment" spellcheck="true">// 抽象表达式</span><span class="token keyword">class</span> <span class="token class-name">Expression</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">int</span> <span class="token function">interpret</span><span class="token punctuation">(</span>std<span class="token operator">::</span>unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> context<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 终结符表达式</span><span class="token keyword">class</span> <span class="token class-name">TerminalExpression</span> <span class="token operator">:</span> <span class="token keyword">public</span> Expression <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">TerminalExpression</span><span class="token punctuation">(</span><span class="token keyword">char</span> variable<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">variable_</span><span class="token punctuation">(</span>variable<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">interpret</span><span class="token punctuation">(</span>std<span class="token operator">::</span>unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> context<span class="token punctuation">)</span> override <span class="token punctuation">{</span>        <span class="token keyword">return</span> context<span class="token punctuation">[</span>variable_<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">char</span> variable_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 非终结符表达式</span><span class="token keyword">class</span> <span class="token class-name">NonterminalExpression</span> <span class="token operator">:</span> <span class="token keyword">public</span> Expression <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">NonterminalExpression</span><span class="token punctuation">(</span>Expression<span class="token operator">*</span> left<span class="token punctuation">,</span> Expression<span class="token operator">*</span> right<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">left_</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">right_</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">interpret</span><span class="token punctuation">(</span>std<span class="token operator">::</span>unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> context<span class="token punctuation">)</span> override <span class="token punctuation">{</span>        <span class="token keyword">return</span> left_<span class="token operator">-</span><span class="token operator">></span><span class="token function">interpret</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token operator">+</span> right_<span class="token operator">-</span><span class="token operator">></span><span class="token function">interpret</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    Expression<span class="token operator">*</span> left_<span class="token punctuation">;</span>    Expression<span class="token operator">*</span> right_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> context<span class="token punctuation">;</span>    context<span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    context<span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    Expression<span class="token operator">*</span> expression <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">NonterminalExpression</span><span class="token punctuation">(</span>        <span class="token keyword">new</span> <span class="token function">TerminalExpression</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">new</span> <span class="token function">TerminalExpression</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> result <span class="token operator">=</span> expression<span class="token operator">-</span><span class="token operator">></span><span class="token function">interpret</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Result: "</span> <span class="token operator">&lt;&lt;</span> result <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">delete</span> expression<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，我们创建了一个简单的表达式语言，包括终结符表达式和非终结符表达式。通过解释器模式，我们可以解释这些表达式并计算结果。这个示例是解释器模式的一个简单演示，实际应用中可能会涉及更复杂的语法和解释器。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>设计模式是一种通用的解决问题的模板或蓝图，它们用于解决特定类型的问题，并为软件设计提供了可重用的解决方案。在计算机科学中，有23种广泛接受的经典设计模式，它们通常被分为以下几个类别：</p><ol><li><strong>创建型模式</strong>（Creational Patterns）：这些模式关注对象的创建机制，以便以适当的方式创建对象，隐藏创建的细节。创建型模式包括：</li></ol><ul><li>单例模式（Singleton Pattern）</li><li>工厂模式（Factory Pattern）</li><li>抽象工厂模式（Abstract Factory Pattern）</li><li>建造者模式（Builder Pattern）</li><li>原型模式（Prototype Pattern）</li></ul><p><strong>结构型模式</strong>（Structural Patterns）：这些模式处理对象之间的组合，以便形成更大的结构。结构型模式包括：</p><ul><li>适配器模式（Adapter Pattern）</li><li>桥接模式（Bridge Pattern）</li><li>组合模式（Composite Pattern）</li><li>装饰器模式（Decorator Pattern）</li><li>外观模式（Facade Pattern）</li><li>享元模式（Flyweight Pattern）</li><li>代理模式（Proxy Pattern）</li></ul><p><strong>行为型模式</strong>（Behavioral Patterns）：这些模式关注对象之间的通信、职责分配和协作。行为型模式包括：</p><ul><li>责任链模式（Chain of Responsibility Pattern）</li><li>命令模式（Command Pattern）</li><li>解释器模式（Interpreter Pattern）</li><li>迭代器模式（Iterator Pattern）</li><li>中介者模式（Mediator Pattern）</li><li>备忘录模式（Memento Pattern）</li><li>观察者模式（Observer Pattern）</li><li>状态模式（State Pattern）</li><li>策略模式（Strategy Pattern）</li><li>模板方法模式（Template Method Pattern）</li><li>访问者模式（Visitor Pattern）</li></ul><p>这些经典的设计模式提供了在特定情况下解决问题的有效方法，它们有助于提高软件的可维护性、可扩展性和可重用性。根据应用场景和需求，开发人员可以选择适当的设计模式来构建更健壮、可维护和可扩展的软件系统。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;C++中常用的设计模式有很多，设计模式是解决常见问题的经过验证的最佳实践。以下是一些常用的设计模式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;stron
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="设计模式" scheme="https://JoyTsing.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>2024,F1上海站</title>
    <link href="https://joytsing.github.io/posts/8251/"/>
    <id>https://joytsing.github.io/posts/8251/</id>
    <published>2024-04-26T05:05:15.000Z</published>
    <updated>2024-04-26T07:33:59.705Z</updated>
    
    <content type="html"><![CDATA[<h2 id="20年的道路"><a href="#20年的道路" class="headerlink" title="20年的道路"></a>20年的道路</h2><p>曾经我们有个“奥运三问”：中国什么时候能参加奥运？什么时候能拿到金牌？什么时候我们能举办奥运会？同样的，我们也有个“F1三问”：中国什么时候可以举办F1分站？什么时候可以出一个F1车手？什么时候我们的车手可以拿到F1年度冠军？2024赛季虽然这是周冠宇的第三年，却是中国大奖赛的回归，周冠宇第一次回到主场作战，我们才真切的有“中国出了个F1车手”的实感啊，有了第一个车手，那就会有第二个、第三个。总有一天，我们会拿到第一个分站冠军，乃至拿下年度冠军，总有一天。</p><p><img src="/posts/8251/zhou.jpg" alt="周冠宇"></p><p>很遗憾我没能去现场去看小周这场比赛，但是也许二十年后，新的年轻中国车手可以在领奖台上说，二十年前在上海，中国的第一位F1车手曾激励了我。</p><p><img src="/posts/8251/image-20240426145048589.png" alt="经典窝法乙烷"></p><h2 id="明年还能再见吗"><a href="#明年还能再见吗" class="headerlink" title="明年还能再见吗"></a>明年还能再见吗</h2><p>2024年算是车手合同到期的大年，刘易斯汉密尔顿爵士加盟法拉利绝对是车手市场的震撼级操作，而围场中岁数最大的车手头哥阿隆索跟马丁续约，也让年轻车手们争夺席位的压力变得更大了。席位一共就那么多个，让小周去五大车队或者小红牛是绝对没戏的。2025年，小周如果想继续在F1赛场上奋战，那么希望只在这三小车队索伯、哈斯和威廉姆斯身上，而这希望目前看来并不算大。</p><p>周冠宇留在F1，除了成绩，还需要的是进步和身后赞助商支持。虽然我不想这么说，但周冠宇目前实际上还是属于付费车手一级，并没有征服其他车队。赛季初采访周冠宇的时候他的目标是争取一份长期合同留在围场，这个目标说实话有点难。很多时候周冠宇被诟病的就是不够狠，起步昏厥和极速不够快，当然这里有车的问题(struggle)。</p><p><img src="/posts/8251/image-20240426145841657.png" alt="奥迪只想拿名次"></p><p>从卡丁车到F4，再到需要大量投入的F3和F2，最后走上F1<strong>成为了中国第一位F1正赛车手</strong>。也许你可以说有很多的不完美，阿尔法罗密欧不是强队、带资进组、周冠宇F2表现并没有达到顶尖水平….各种种种，都可以，或许<strong>成绩也许看起来平平，但是却创造了诸多的中国车手的历史</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;20年的道路&quot;&gt;&lt;a href=&quot;#20年的道路&quot; class=&quot;headerlink&quot; title=&quot;20年的道路&quot;&gt;&lt;/a&gt;20年的道路&lt;/h2&gt;&lt;p&gt;曾经我们有个“奥运三问”：中国什么时候能参加奥运？什么时候能拿到金牌？什么时候我们能举办奥运会？同样的，我们
      
    
    </summary>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据库内核学习记录</title>
    <link href="https://joytsing.github.io/posts/41900/"/>
    <id>https://joytsing.github.io/posts/41900/</id>
    <published>2024-04-25T08:57:15.000Z</published>
    <updated>2024-04-25T09:10:18.295Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章-数据库的存储结构"><a href="#第一章-数据库的存储结构" class="headerlink" title="第一章 数据库的存储结构"></a>第一章 数据库的存储结构</h2><h3 id="1-1文件组织结构"><a href="#1-1文件组织结构" class="headerlink" title="1.1文件组织结构"></a>1.1文件组织结构</h3><h4 id="1-1-1文件分页"><a href="#1-1-1文件分页" class="headerlink" title="1.1.1文件分页"></a>1.1.1文件分页</h4><p>DBMS中可以看到数据库是以文件的形式存储在磁盘中的，对目前大部分数据库来说都是将数据存储于磁盘上，对于这类存储介质来说，因为其是非易失性存储，这意味着对于系统而言他的寻址方式是块寻址的，必须先将包含这个值的一个块的数据加载到内存中（目前也有基于NVEM存储开发的数据库）。<br><img src="/posts/41900/image-20230913211052243.png" alt></p><p>主流操作系统提供的通常为无结构的流文件，DBMS会将每个文件再划分为固定大小的数据块，称为页（page）。页是DBMS在磁盘和内存间交换数据的基本单元。如果需要对数据库进行读写操作，DBMS需要先将数据从磁盘读取到内存中的缓冲池内，缓冲池管理器负责在磁盘和内存之间以页为单位进行数据交换。DBMS的执行引擎在语句处理过程中需要使用某个数据页时，会向缓冲池提出请求，缓冲池管理器负责将该页读入内存，并向执行引擎提供该页在内存中的指针。当执行引擎操作那部分内存时，缓冲池管理器必须确保该页面始终驻留在那片内存区域中。</p><blockquote><p>从操作系统的角度来看，一个文件就是一个字节流序列，操作系统并不关心和了解文件的内容以及文件之间的关联性。数据库文件的内容只有创建它的DBMS才知道如何解读，因为它是由DBMS以其特定的方式来组织的。数据库文件的组织和管理由DBMS的存储管理器负责，它将文件划分为页面的集合，并且负责跟踪记录这些页面的使用情况，包括哪些页面存储了什么数据，哪些页面是空闲的等等。页面中可以存储不同类型的数据，比如记录、索引等，但是DBMS通常不会将不同类型的数据混合存储在同一个页面中。</p></blockquote><h4 id="1-1-2页"><a href="#1-1-2页" class="headerlink" title="1.1.2页"></a>1.1.2页</h4><p>每个页面都有唯一的标识符，对于DBMS来说，页因为是对于操作系统存在的抽象层，因此页实际是作为一个间接层提供给DBMS，将对应的页面标识符ID映射成文件路径以及偏移量。</p><blockquote><p>系统上层模块请求一个页面时，先给出页面ID，存储管理器将该页面ID转换为文件路径和偏移量，并由此定位到对应页面。</p></blockquote><p>需要注意区分以下两个关于页的概念:</p><ul><li><strong>硬件页：</strong> 即磁盘块，大小通常为4 KB，是磁盘I/O的基本单位。</li><li><strong>数据库页：</strong> 大小通常为磁盘块大小的整数倍，是DBMS在磁盘和缓冲池之间交换数据的基本单位。</li></ul><blockquote><p>二者的区别在于，对硬件页的写操作是原子的，但是对数据库页的写操作则不一定。换言之，如果硬件页的大小为4KB，那么当系统尝试向磁盘写入一个硬件页时，这4KB数据要么全部写入，要么全部不写入，这一点是由存储设备来保证的。</p><p>但是，如果数据库页大于硬件页，那么DBMS对一个数据库页的写操作将被操作系统分解为对多个硬件页的写操作，此时DBMS必须采取额外措施来确保数据被安全地写入磁盘，因为系统可能会在将一个数据库页写入到磁盘的过程中发生崩溃，从而导致该数据库页的内容出现不一致性错误。</p></blockquote><h5 id="1-1-2-1-OS中的页"><a href="#1-1-2-1-OS中的页" class="headerlink" title="1.1.2.1 OS中的页"></a>1.1.2.1 OS中的页</h5><blockquote><p>由于系统中的物理内存是随分配不断在变化的，有时候这个程序使用，有时候那个程序在使用。如果不使用逻辑地址直接使用物理地址，那当前进程操作的地址被占用，则不能使用内存。通过将连续的逻辑地址映射成不连续的物理地址，程序将只用关系的连续的逻辑地址，而物理地址再通过一些方法找到并映射过去。</p></blockquote><p>将程序的逻辑地址空间分为若干等大的页，称为 <strong>页/页面/虚页</strong> 。同样将物理内存分成若干项大小同虚页大小的页，称为 <strong>块/页帧/实页</strong>。虚页是连续的，实页是不连续的，<strong>页表</strong>就维护了虚页到实页的映射关系，页表中每一项称为<strong>页表项(PTE)</strong>，表示一个虚页到实页是映射关系。每个进程都有自己的页表，称为<strong>进程页表</strong>。</p><p>程序中使用的虚地址大致如下：</p><pre class="line-numbers language-text"><code class="language-text">|页号|页内偏移|<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>页表中的内容大致如下(当然还可以有一些标志信息，如是否有读写权限、是否可用等)：</p><pre class="line-numbers language-text"><code class="language-text">页号1: |标记|物理页号|页号2: |标记|物理页号|页号3: |标记|物理页号|页号4: |标记|物理页号|标注页号仅表示页表项之间的位置关系(连续)，不占用实际内存<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每个进程为了找到自己的进程页表还需要 <strong>页表基地址寄存器(PTBR)</strong> 的帮忙，其指向进程页表的实页号/页表起始地址(<strong>PPN</strong>)。进程切换时会切换PTBR的值。</p><p><strong>注意</strong> ，页号表示页表项之间的位置关系(连续)，实际不占物理内存，通过<strong>PTBR+页号x页表项大小算出目标地址</strong></p><p>由虚地址到实际物理地址的变化叫做内存映射，过程如下：</p><pre class="line-numbers language-text"><code class="language-text">┌────┐    ┌────────┬─────────┐ │PTBR│    │虚拟页号│ 页内偏移│             主存 └─┬──┘    └──┬─────┴────┬────┘        ┌─────────────┐   │          │          │             │             │   │          │          │             │             │   │          │          │             │             │   │          │          │             ├─────────────┤   └──────────+──────────┼────────────►│             │                         │   物理页号  │page table   │                         x─◄───────────┤             │                         │             ├─────────────┤                         │             │             │                         │             │             │                         │             │             │                         │  物理地址   │             │                         └───────────► │             │                                       │             │                                       │             │                                       └─────────────┘<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果对应地址缺页，则会触发缺页中断。进入内核态(异常/中断型)，从磁盘换入或加载内存并填写到内存中，并填写帧号，然后重新进行寻址过程。</p><p>如<code>0x000011a3</code>的地址映射过程</p><ul><li>逻辑地址32位=20位页号+12位页内偏移</li><li>页表项32位=20位块号(与20位页号对应)+12位标记位</li><li>物理地址=20位块号+12为页内偏移</li></ul><p>页表如下:</p><pre class="line-numbers language-text"><code class="language-text">起址：PTBR +页号        |标记| 帧号         |              |----|--------------| +0x00001  -> |    | 0x000f3      |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>第一次访问内存，通过PTBR+0x00001找到对应的页表项的地址，读取物理页号/页帧/实页号。再通过帧号0x000f3<strong>拼接</strong>页内偏移0x1a3得到物理地址(不需要加法，一部分高位，一部分低位，直接拼接更快)，第二次访问内存读取数据。<strong>至少需要两次内存访问</strong></p><h5 id="1-1-2-2-分页机制的优化"><a href="#1-1-2-2-分页机制的优化" class="headerlink" title="1.1.2.2 分页机制的优化"></a>1.1.2.2 分页机制的优化</h5><p>要真正获取一个内存中的内容实际需要加载两次内存，第一次是查页表找到物理页号，第一次是根据物理页号加页内偏移到对应内存,因此可以进行时间上的优化。而每个进程都需要维护一个页表，页表本身也是占内存空间的，因此还可以进行空间优化。</p><h5 id="1-1-2-3-空间优化与多级页表"><a href="#1-1-2-3-空间优化与多级页表" class="headerlink" title="1.1.2.3 空间优化与多级页表"></a>1.1.2.3 空间优化与多级页表</h5><p>引入多级页表有两个原因</p><ul><li><strong>如果页表大小超过了一个页面的大小/容量，则可能将数据存放到两个不同的页面</strong>，将无法通过PTBR+页号的方式找到</li><li>如通常一个页4KB，32位系统中一PTE有32位4B，故PTE数不应超过1k</li><li>进程页表本身也是在内存中的，需要占用内存空间<br>如果不考虑页面容量问题，<strong>假设一个页能容纳所有页表项</strong>。一个32位的系统和程序，如果页内偏移12位，要访问全部4G内存则需要2^20个物理块/物理页面/物理页号，对应就有2^20个页号/虚页号，即2^20个页表项：</li></ul><pre class="line-numbers language-text"><code class="language-text">|12位标记位|20位表示物理页号|<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这么一个页表项32bit=4B，则维护一个进程的页表需要占用2^20x4B=4MB的内存空间。4MB看起来很小，但是操作系统是要运行很多程序的。</p><p>如果使用多级页表，应当<strong>页表大小==页面容量</strong> ，如将32位分为10位，10位，12位的分级方式。为何10位？10位能索引2^10个PTE，而每个PTE占4B，一个页表刚好就4KB，与页容量相同。如果小于页容量会产生内碎片，浪费;如果大于页容量则无法通过页表起址+offset寻址。</p><blockquote><p>64位系统中则常用9位索引页表，64bit=8B，8Bx2^9=4KB，也刚好是一个页的大小。  </p></blockquote><pre class="line-numbers language-text"><code class="language-text">虚地址：| VPN[1] | VPN[0] | 页内偏移 |PTE:| PPN[1] | PPN[0] | 页内偏移 |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>PTBR指向一级页表起始地址，加上VPN[1]可以索引到对应页表项，一级页表中的PPN[1]PPN[0]就是二级页表的起始地址，再通过VPN[0]索引二级也被即可得到物理页号，加上页内偏移得到物理地址。</p><pre class="line-numbers language-text"><code class="language-text">┌────┐   ┌──────┬─────┬───────┐│PTBR│   │ VPN1 │VPN0 │offset │└─┬──┘   └──┬───┴──┬──┴───┬───┘               ┌─────────────┐  │         │      │      │                   │             │  │         │      │      │                   ├─────────────┤  └─────────x──────┼──────┼──────────────────►│xxxxxxxxxxxxx│                   │      │                   │x L0       xx│                   │      │     PPN1,PPN0     │x          xx│                   x──────┼─────◄─────────────┤xxxxxxxxxxxxx│                   │      │                   ├─────────────┤                   │      │                   │             │                   │      │                   │             │                   │      │                   │             │                   │      │                   ├─────────────┤                   └──────┼──────────────────►│xxxxxxxxxxxxx│                          │                   │x L1      xxx│                          │     PPN1,PPN0     │x         xxx│                          x─────◄─────────────┤xxxxxxxxxxxxx│                          │                   ├─────────────┤                          │                   │             │                          │                   │             │                          │                   │             │                          │                   │             │                          │                   │             │                          └──────────────────►│             │                                              │             │                                              │             │                                              │             │                                              │             │                                              │             │                                              └─────────────┘<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果发现第一级只有3项指向第二级，而第二级页表有2^10项，所以一共3个页表需要(2^10+3x2^10)x4B = 16KB的内存空间。当然上限还是2^10x2^10个表项x4B占4M空间。<strong>问题就是内存的访问次数增加了</strong>，前面使用多级页表的方式虽然减少了空间占用，但是内存的访问次数增加了。</p><h5 id="1-1-2-4TLB"><a href="#1-1-2-4TLB" class="headerlink" title="1.1.2.4TLB"></a>1.1.2.4TLB</h5><p>将最常访问的几个(一般8-128个左右)页表项储存到访问速度更快的硬件中，如关联存储器(相当于哈希表)，这个小表的名称为<strong>TLB (Translation Lookaside Buffer)</strong> 或 <strong>快表</strong> 。寻址会同时寻找TLB和页表，如果TLB命中则查页表寻址的操作作废。</p><h5 id="1-1-2-5使用大页"><a href="#1-1-2-5使用大页" class="headerlink" title="1.1.2.5使用大页"></a>1.1.2.5使用大页</h5><p>依旧上述多级页表的例子，但是使用某种机制让大页表地址连续，那么就可以使用起址+offset的方式寻址，而不需要多级页表多次访问内存。</p><pre class="line-numbers language-text"><code class="language-text">虚地址：| VPN[1] | VPN[0] | 页内偏移 |PTE:| PPN[1] | PPN[0] | 页内偏移 |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只是访问一级页表(L0)时其返回PPN[1]作为大页的索引(高10位)，然后使用虚拟地址的<code>&lt;VPN[0],页内偏移&gt;</code>所谓大页的页内偏移。如此一来访问次数就降低了。</p><pre class="line-numbers language-text"><code class="language-text">┌────┐ ┌──────┬─────┬───────┐│PTBR│ │ VPN1 │VPN0 │offset │└─┬──┘ └──┬───┴──┬──┴──┬────┘  │       │      │     │  │       │      └──┬──┘         ┌─────────────┐  │       │         │            │             │  │       │         │            ├─────────────┤  └───────x─────────┼───────────►│xxxxxxxxxxxxx│                    │            │x L0       xx│                    │  PPN1,     │x          xx│                    x───────◄────┤xxxxxxxxxxxxx│                    │            ├─────────────┤                    │            │             │                    │            │             │                    │            │             │                    │            ├─────────────┤                    └───────────►│             │                                 │  huge page  │                                 │             │                                 │             │                                 │             │                                 │             │                                 │             │                                 │             │                                 ├─────────────┤                                 └─────────────┘<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-1-3堆文件"><a href="#1-1-3堆文件" class="headerlink" title="1.1.3堆文件"></a>1.1.3堆文件</h4><p>关系型数据库存储的是关系，关系则是记录的集合，这些记录在数据库中有许多组织形式：</p><ul><li><strong>堆文件组织（ heap file organization）</strong> ：堆文件是页的无序集合，记录在页中以随机的顺序存储。即，一条记录可以放在文件中的任何地方，只要那里有足够的空间存放这条记录，记录间不用考虑先后顺序的。 通常每个关系使用一个单独的堆文件。</li><li>顺序文件组织（sequential file organization）：记录根据其”查找键”的值顺序存储。</li><li><strong>散列文件组织（ hash file organization）</strong> ：在每条记录的某个或某些属性上计算一个散列函数，根据散列的结果来确定将记录放到文件的哪个页面中。</li></ul><p>对于堆存储方式而言，由于这种存储形式对程序员而言是可见的，也就是说可以控制记录的存储。同时这种存储方式不关心记录间存储的顺序，只需要维护堆文件中哪些页面是存储了数据（数据页），哪些是空闲的即可。常见的有两种存储方式：</p><ul><li>链表：以链表的形式将文件中的空闲页和数据页分别勾连起来，并在文件的首页维护两个指针，分别指向空闲页链表和数据页链表的第一个页面。这种方式下，如果想要找到一个特定的数据页，需要从链首开始逐个扫描链表中的页面，直到找到为止，I/O开销较大。</li></ul><p><img src="/posts/41900/image-20230914133809745-1714036106757-59.png" alt></p><ul><li>页目录：维护一种特殊的页面（目录页），在该页中记录每个数据页的位置以及该数据页中剩余的空闲空间大小。页目录将页面的状态信息集中存放在一起，可以提高查找特定页面的速度。<br><img src="/posts/41900/image-20230914133840439.png" alt></li></ul><h4 id="1-1-4块的存储结构"><a href="#1-1-4块的存储结构" class="headerlink" title="1.1.4块的存储结构"></a>1.1.4块的存储结构</h4><p>块在存储中的组织与记录类似，可以简单地看成是由 header + data 数据组成，例如一个块要管理内部所有的记录，需要在块的 header 中保存每个记录的偏移、块最后修改的时间戳、块在存储结构中的位置信息等，因此 header 中的元数据主要是为了方便自身的管理和维护。</p><p>下面我们来看一个块里面是如何存放数据的，这里需要强调的是，块里面存储的地址偏移是相对于虚拟地址的偏移，并非实际物理磁盘的偏移。还需要注意，新插入的记录，是从块的末端往中间增长的，而未使用的空间是从 header 之后往块的末端增长的。<br><img src="/posts/41900/image-20231002155739470.png" alt><br>从图中可以看出记录 1 在最后，记录 4 在最前面，因为记录有可能不等长，无法事先根据记录的长度和块的总长来计算好能插入多少数据。</p><p>示例：假如一个块的大小是 100。</p><ul><li>如果记录都等长，都为 10，那么我们可以算出一个块最多能插入 10 条记录，并且可以从块的起始到末端的方向插入，最后刚好到 100 不会报错。</li><li>如果记录不等长，事先也不知道这个块最多能容纳多少条记录的，如一条长度 10，一条长度 50 的记录，从起始往末端方向编排，如果下一条记录的长度为 50 ，因为不知道块中还有多少空间，也不会提前报错，那必然会插入失败。<br>  但是如果记录是从块的末端往前增长，那在插入 10 和 50 这两条记录后，由于长度为 50 的那条记录的偏移是 40（100 - 10 - 50 = 40），那就能知道当前的空间只剩 40 了，没办法容纳新的记录，然后提前报错然后重新分配块。</li></ul><h3 id="1-2页的组织结构"><a href="#1-2页的组织结构" class="headerlink" title="1.2页的组织结构"></a>1.2页的组织结构</h3><p>页面的内部结构可以粗分为两个部分:</p><ul><li><strong>页头</strong> ：页头登记了关于页面内容的元数据，如页面大小、校验和、DBMS版本、事务可见性、压缩信息等。有些系统（如Oracle）要求页面是自包含的，即关于该页的所有描述信息都可以在该页面中找到。</li><li><strong>数据区</strong> ：存放数据的区域。这里我们只讨论如何在数据区中存放记录。目前DBMS中最常用的方法是采用槽式页面。这种方法将数据区划分为一个个插槽（slot），每个插槽中放置一条记录。<h4 id="1-2-1槽式页面"><a href="#1-2-1槽式页面" class="headerlink" title="1.2.1槽式页面"></a>1.2.1槽式页面</h4>顾名思义，就像一个个slot一样，将记录数据存储到磁盘上，对于这种存储方式而言，需要管理当前页面存储的信息，如最基本的存储记录条数与可用位置，因此需要在页头的位置维护下面信息：<blockquote><ol><li>本页中已使用的槽的数量；</li><li>最后一个已使用的槽的起始位置；</li><li>一个槽数组，登记本页中每个记录的起始位置。</li></ol></blockquote></li></ul><p>并且对于存储的数据库来说，记录数量应该是变长的，也就是说一个页面所存储的记录数量是不确定的，因此槽数组的最大长度是不能决定的，也就是说页头所占的区域大小是不确定的。因此比较合理的做法是，向页中插入记录时，槽数组从前向后增长，而被插入的记录数据则是从页尾向前增长。当槽数组和记录数据相遇时，则认为该页面是满页。<br><img src="/posts/41900/image-20230914134830996.png" alt></p><h4 id="1-2-2插入记录"><a href="#1-2-2插入记录" class="headerlink" title="1.2.2插入记录"></a>1.2.2插入记录</h4><p>向关系中插入一条记录时，对于堆文件，只需要找到一个有足够空闲空间能放得下这条记录的页面，或当所有已分配页面中都没有足够空闲空间时，就申请一个新的空闲页，然后将记录放置在那里。</p><h4 id="1-2-3删除记录"><a href="#1-2-3删除记录" class="headerlink" title="1.2.3删除记录"></a>1.2.3删除记录</h4><p>从页中删除记录时，需要考虑如何回收该记录的空间。一种方法是在页内滑动记录，使得记录间没有空隙，从而保证页面中未使用的区域一定位于槽数组和已使用区域之间。</p><p>如果不滑动记录，则需要在页头维护一个空闲区列表，以保证当向页中插入一条新记录时能知道该页中的空闲区在哪里，有多大。而页头通常不必存储全部空闲区列表，只存列表的链头就够了，然后可以使用空闲区自身的空间存储下一个空闲区的信息。</p><h4 id="1-2-4修改记录"><a href="#1-2-4修改记录" class="headerlink" title="1.2.4修改记录"></a>1.2.4修改记录</h4><p>如果修改的是定长记录，对页面存储没有影响，因为修改后记录占用的空间与修改前完全相同。但是如果修改的是变长记录，就会碰到与插入和删除类似的问题。</p><p>如果修改后的记录比其旧版本长，则需要在当前页面中获得更多的空间，这个过程可能涉及记录的滑动。如果当前页面中的空闲区域不够，还需要将记录移动到其他页面。反之，如果记录由于修改而变短可以像删除记录时那样回收其释放的空间。</p><h3 id="1-3记录的组织形式"><a href="#1-3记录的组织形式" class="headerlink" title="1.3记录的组织形式"></a>1.3记录的组织形式</h3><p>记录本质上就是一个字节序列，如何将这些字节解释为属性类型和值是DBMS的工作。与页面结构类似，记录内部结构也可以分为两部分：</p><ul><li><strong>记录头</strong> ：存放关于记录的元数据，例如DBMS并发控制协议的可见性信息（即哪个事务创建/修改了此记录的信息）、NULL值的位映射等。注意，关于数据库模式的元数据没有必要存储在记录头里。</li><li><strong>记录数据</strong> ：包含记录中各个属性的实际数值。如前所述，大多数DBMS不允许记录的长度超过页面的大小，且一个页面中一般只存放同一个关系的记录。<h4 id="1-3-1定长记录"><a href="#1-3-1定长记录" class="headerlink" title="1.3.1定长记录"></a>1.3.1定长记录</h4>定长记录全部由定长字段组成，是最简单的记录组织形式。定长记录的插入和删除是比较容易实现的，因为被删除的记录留出的可用空间恰好是插入新的记录所需要的空间。</li></ul><blockquote><p>定长记录在组织时需要注意的一个问题是内存对齐问题。很多处理器需要在数据的开始地址为4或8的倍数时才能实现更高效的内存读写，所以DBMS在组织记录数据时通常会根据情况使所有字段的起始地址是4或8的倍数。采用这种做法时，一个字段前可能会存在一些没有被上一个字段使用的空间，这些空间其实是被浪费掉了。但尽管如此，这样做还是有必要的。因为记录虽然是存放在磁盘而不是内存中，但是对记录的操作仍需在内存中进行，所以在组织记录时需要考虑如何让它在内存能够被高效访问。</p></blockquote><h4 id="1-3-2变长记录"><a href="#1-3-2变长记录" class="headerlink" title="1.3.2变长记录"></a>1.3.2变长记录</h4><p>变长记录允许记录中存在一个或多个变长字段。由于变长字段在记录中的偏移位置是不确定的，因此记录中必须包含足够多的信息，让我们能够方便地提取记录的任何字段。变长记录的实现可以采用以下两种方法。</p><blockquote><p>一种简单有效的实现方法，是将所有定长字段放在变长字段之前，然后在记录头写入以下信息：（1）记录长度；（2）除第一个变长字段之外的所有变长字段的偏移位置。之所以不需要存第一个变长字段的偏移位置，是因为我们知道第一个变长字段就紧跟在定长字段之后。一个变长记录的例子如图所示，该记录共包含四个字段，其中有两个变长字段：name和address。</p></blockquote><p><img src="/posts/41900/image-20230914140004897.png" alt></p><p>变长记录的另一种表示方法是保持记录定长，将变长部分放在另一个溢出页中，而在记录本身存储指向每一个变长字段开始位置的指针。</p><p><img src="/posts/41900/image-20230914140423450.png" alt><br>这种做法可以保持记录定长，能够更有效地对记录进行搜索，记录也很容易在页内或页间移动。但是另一方面，将变长部分存储在另一个页中，增加了为检索一条记录的全部数据而需要进行的磁盘I/O次数（损失性能)。</p><p>溢出页不仅可以存储变长字段，还可以用于存储大值数据类型的字段，比如TEXT和BLOB字段，这些数据往往需要使用多个页面来存储。</p><p>有时候变长记录是由具有可变格式的记录导致的，也就是是字段没有固定格式的记录，在数据库的维度来说是指没有具体表结构的数据，是非结构化的数据，例如 XML 文件。</p><p>示例：假设要记录一个人的信息，包括姓名、投资的餐馆等，可能字段固定但是内容不固定。这个时候可以使用标记（如姓名）以及类型（如 string）加上长度来记录，例如下图中的 N 表示 name，S 表示 string 类型，14 表示 name 的长度。这样做的好处是即便不知道存储的格式，但是可以把一些特征标识保存起来，最后根据标识解析出数据。</p><p><img src="/posts/41900/image-20240425170620590.png" alt></p><h4 id="1-3-3大值记录"><a href="#1-3-3大值记录" class="headerlink" title="1.3.3大值记录"></a>1.3.3大值记录</h4><p>所谓大值，是指在一个块中无法存储的记录，大值涉及多个块之间的交互。</p><p>示例：如下图记录 2 存储时，分成了两部分进行存储，分别是记录 2-a 和记录 2-b，其中在存储记录 2-a 的时候，需要额外的存储空间来保存一些数据：一是标识，表明这是一个记录的片段；二是片段的序号，如这是第 1 个片段，或者第 N 个片段；最后还要保存指向下一个片段的指针，用于跨块之间的访问。</p><p><img src="/posts/41900/image-20240425170630765.png" alt></p><h3 id="1-4缓冲池管理"><a href="#1-4缓冲池管理" class="headerlink" title="1.4缓冲池管理"></a>1.4缓冲池管理</h3><p>对于数据库来说，其最大的开销一般是磁盘和内存之间IO交互，也就是将页面传输到内存所耗的那部分，减少磁盘访问次数的一种方法是在内存中保留尽可能多的页面，理想情况下，要访问的页面正好都已经在内存中了，这样就不再需要访问磁盘了。</p><h4 id="1-3-1缓冲池结构"><a href="#1-3-1缓冲池结构" class="headerlink" title="1.3.1缓冲池结构"></a>1.3.1缓冲池结构</h4><p>缓冲池是DBMS内部分配的一块内存区域，用来缓存从磁盘获取的页面。这片内存空间被组织为一个数组，其中每个数组项被称为一个帧（frame），一个帧正好能放置一个页面。类似于操作系统，当请求一个页面的时候首先先到缓冲池里面搜索，如果没有搜索到再从磁盘中获取并存入到缓冲池中的一个帧中。<br><img src="/posts/41900/image-20230914143130161.png" alt><br>同样的，存在一个管理器来维护使用缓冲池所需要的元数据。存在页表，为一个内存哈希表（OS虚拟内存管理页表结构)<code>对于64位系统，当我们得到一64位虚拟地址ip时，将前几位作为虚拟页码（前几位可能与页大小有关），计算虚拟页码的哈希值，计算出哈希值后到哈希表对应条目进行查找，哈希表使用链表来解决碰撞问题，每个链表节点有3个内容，虚拟页码，映射的帧码，下一个节点指针。在查找到帧码后将其与页偏移组合，得到真实物理地址</code>用于登记当前已经在内存中的页面的信息。</p><p>页表将页面ID映射到缓冲池中一个帧的位置。因为缓冲池中页面的顺序不一定反映磁盘上的顺序，所以需要通过这个额外的数据结构来定位页面在缓冲池中的位置。除了最重要的内存地址之外，还需要为每个页面维护一个标志位和引用计数器（用于释放回收）。</p><blockquote><p><strong>脏标志</strong>：脏标志由线程在修改页面时设置。如果一个页面被设置了脏标志，就意味着缓冲池管理器必须将该页写回磁盘，以保证磁盘上的页面副本包含最新的数据。(修改位)</p><p><strong>引用计数</strong>：引用计数表示当前访问该页（读取或修改该页）的线程数。线程在访问该页之前必须增加引用计数。如果页的引用计数大于零，说明该页面正在被使用，此时不允许缓冲池管理器从内存中淘汰该页。</p></blockquote><p>关于缓冲池中的内存空间如何进行分配，一般采取两种策略：</p><blockquote><p><strong>全局策略</strong>：有利于当前整体工作负载的策略。全局策略综合考虑所有活动事务，以找到分配内存的最佳方案。</p><p><strong>本地策略</strong>：以保证单个查询或事务运行得更快为目标的策略。本地策略将一个帧分配给特定事务时，不考虑其他并发事务的行为，即使这样可能对整体工作负载不利。</p></blockquote><h4 id="1-3-2缓冲池替换算法"><a href="#1-3-2缓冲池替换算法" class="headerlink" title="1.3.2缓冲池替换算法"></a>1.3.2缓冲池替换算法</h4><p>DBMS对数据库文件的读写操作需要通过调用操作系统接口来实现，通常，为了优化I/O性能，操作系统自身也维护了一个缓冲区来缓存从磁盘读入的数据块。这个缓冲区和DBMS的缓冲池在功能上显然是重复的，会导致同一个数据库页面的数据在内存中的冗余存储，而且操作系统缓冲区的管理策略还使得DBMS难以控制内存与磁盘之间的页面交互。因此，<strong>大多数DBMS都使用直接I/O绕过操作系统的缓存</strong>。</p><p>因为需要DBMS来控制缓冲池，因此当需要释放一个帧为新页面腾出空间时，必须决定从缓冲池中淘汰掉哪个页面，替换算法的目标是提高正确性、准确性、速度和元数据开销。需要注意的是，引用计数大于零的页面是不能淘汰的。目前最常用的替换算法有最近最少使用（LRU）算法和时钟（CLOCK）算法。</p><blockquote><p><strong>LRU算法</strong>：LRU算法为每个页面维护其最后一次被访问的时间戳，这些时间戳可以存储在一个单独的数据结构（如队列）中，以便对其进行排序来提高效率。需要淘汰页面时，DBMS总是选择淘汰时间戳最早的页面。</p><p><strong>CLOCK算法</strong>：CLOCK算法是一种近似LRU算法，它不需要每个页面都有单独的时间戳，而是为每个页面维护一个引用位。当某个页面被访问时，就将它的引用位的值置为1。想象页面被组织在循环缓冲区中，需要选择淘汰页面时，有一个”时钟指针”在循环缓冲区中扫描，检查页面的引用位是否为1。如果是，则将引用位重新置0并移动指针到下一个页面；否则，淘汰当前页面。</p></blockquote><p>有三种解决方案可以解决LRU和CLOCK算法的缺点:</p><ul><li>第一种解决方案是LRU-K，LRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。它会以时间戳的形式登记最后K次引用的历史，并计算连续引用之间的时间间隔，将此历史记录用于预测页面下一次被访问的时间。<ul><li>相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到K次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。详细实现如下：</li></ul></li></ul><blockquote><ol><li>数据第一次被访问，加入到访问历史列表；</li><li>如果数据在访问历史列表里后没有达到K次访问，则按照一定规则（FIFO，LRU）淘汰；</li><li>当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；</li><li>缓存数据队列中被再次访问后，重新排序；</li><li>需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即：淘汰“倒数第K次访问离现在最久”的数据。</li></ol></blockquote><ul><li><p>第二种解决方案是对每个查询进行局部化，DBMS在每个查询的局部范围内选择要淘汰的页面，这样可以最小化每个查询对缓冲池的污染。</p></li><li><p>最后一种解决方案是优先级提示，它允许事务在查询执行期间根据每个页面的上下文，告诉缓冲池管理器该页面是否重要。在淘汰页面时，对于脏页可以有两种处理方法：</p><ul><li>（1）总是优先淘汰缓冲池中的非脏页面；</li><li>（2）先将脏页写回磁盘以确保其更改被持久化，然后再将其淘汰。后者会降低替换页面的速度；而前者虽然速度快，但是有可能将未来不会被再次访问的脏页留在缓冲池。</li></ul></li></ul><p>避免在淘汰页面时执行页面写出操作的一种方法是后台写。采用这种方法的DBMS会定期遍历页表并将脏页写入磁盘。当脏页被安全写入磁盘后，将该页面的脏标志重新置零。</p><h4 id="1-3-3缓冲池的优化"><a href="#1-3-3缓冲池的优化" class="headerlink" title="1.3.3缓冲池的优化"></a>1.3.3缓冲池的优化</h4><ul><li>（1）多缓冲池<br>DBMS可以维护多个用于不同目的的缓冲池，比如每个数据库使用一个缓冲池，每种页面类型使用一个缓冲池。然后针对其中存储的数据的特点，每个缓冲池可以采用量身定制的管理策略。</li></ul><p>将所需页面映射到缓冲池有两种方法：对象ID和散列。对象ID这种方法需要扩展元数据，使其包含关于每个缓冲池正在管理哪些数据库对象的信息，然后通过对象ID，就可以实现从对象到特定缓冲池的映射。另一种方法是散列，DBMS散列页面ID以选择访问哪个缓冲池。</p><ul><li><p>（2）预取<br>DBMS还可以根据查询计划通过预取页面来进行优化。然后，在处理第一组页面时，系统可以将第二组页面预取到缓冲池中。这种方法通常在顺序访问多个页面时使用。</p></li><li><p>（3）扫描共享<br>查询游标可以重用从磁盘读入的数据或操作符的计算结果，最大程度地减少多次扫描相同数据的开销。这种方法允许将多个查询附加到扫描表的单个游标上。当一个查询开始扫描时，如果已经有另一个查询在扫描，DBMS会将第一个查询附加到第二个查询的游标上。DBMS登记第二个查询加入时的位置，以便在到达数据结构末尾时结束扫描。换而言之，当多个查询需要执行相同的顺序扫描操作时，它们应该尽量共享已经加载到缓冲池中的数据页面，而不是每个查询都重新加载相同的数据。这可以通过缓存共享数据页面的内存块来实现，以便多个查询都可以访问相同的数据，从而减少磁盘 I/O 操作，提高性能。</p></li><li><p>（4）缓冲池旁路<br>为了避免开销，顺序扫描操作符不会将获取的页存储在缓冲池中，而是使用正在运行的查询的本地内存。如果操作符需要读取磁盘上连续的大量页序列，那么这种方法可以很好地工作。缓冲池旁路也可以用于临时数据，如排序、连接。</p></li></ul><h4 id="1-3-4其他内存池"><a href="#1-3-4其他内存池" class="headerlink" title="1.3.4其他内存池"></a>1.3.4其他内存池</h4><p>除了元组和索引，DBMS还需要内存来存放其他东西。这些内存池中的内容可能并不总是来自磁盘或者需要写入磁盘，具体取决于实现。</p><ul><li>排序+连接缓冲区</li><li>查询缓存</li><li>维护缓冲区</li><li>日志缓冲区</li><li>字典缓存</li></ul><h3 id="1-4数据库系统架构"><a href="#1-4数据库系统架构" class="headerlink" title="1.4数据库系统架构"></a>1.4数据库系统架构</h3><p>事务管理器里面可以分为两个部分。</p><ol><li>日志与恢复，所有的 SQL 在对磁盘进行操作的时候都会写一些日志，比如物理日志，逻辑日志，并且会提供一定的恢复功能，该部分负责事务的持久性。</li><li>并发控制，即怎么来控制对数据的事务，并发控制包括锁和 MVCC。并发控制负责保证事务的原子性和孤立性。</li></ol><p>在存储层存在 Buffer Pool（缓冲池），所以不会直接从底层的磁盘中将数据提取出来。很多时候是通过 Buffer Pool 查询 Catalog，然后从 Catalog 中拿到所有的元数据信息，之后再发请求给存储管理器，由存储管理器最后发送到存储，然后从存储中将数据拿取出来。</p><h3 id="1-5LRU-K补充"><a href="#1-5LRU-K补充" class="headerlink" title="1.5LRU-K补充"></a>1.5LRU-K补充</h3><p>可以先去LeetCode把<a href="https://leetcode.cn/problems/lru-cache/">LRU</a>这个数据结构给做了,网上也有不少对应的学习资料。</p><h2 id="第二章-索引结构"><a href="#第二章-索引结构" class="headerlink" title="第二章 索引结构"></a>第二章 索引结构</h2><h3 id="2-1索引结构概述"><a href="#2-1索引结构概述" class="headerlink" title="2.1索引结构概述"></a>2.1索引结构概述</h3><p>对于很多查询来说，只涉及表中的部分记录，例如寻找id为4的人，如果为了找这个人将整个表读取进将会损失很多效率，理想情况下DBMS能够直接定位到该记录。为了支持这种访问方式，需要额外设计一些与表相关联的附加结构，我们称之为索引。DBMS中最常用的索引结构为B+树与散列表。</p><p>索引是这样的数据结构：它以一个或多个属性的值为输入，并能快速地定位具有该值的记录的位置。建立索引的属性（组）称为查找键（search key）。与表一样，索引结构同样存储在数据库文件中。例如，我们可以用一个数据文件来存储一个表，用一个索引文件来存储一个索引。一个数据文件可能拥有一个或多个索引文件。除此之外，由于索引是指定表的附加结构，需要与表的内容保持一致，因此当表更新时，DBMS也需要同步更新表的索引。</p><p>在数据库中存在不同类型的索引结构，这些索引结构各自有自己的优势，评价索引结构一般参考以下指标：</p><ul><li>查找类型：该索引结构能有效支持的查找类型，比如等值查找、范围查找等。</li><li>查找时间：使用该索引结构找到一个特定索引项（集）所需的时间。</li><li>插入时间：插入一个新的索引项所需的时间，包括找到插入这个新索引项的正确位置，以及更新索引结构所需的时间。</li><li>删除时间：删除一个索引项所需的时间，包括找到待删除项所需的时间， 以及更新索引结构所需的时间。</li><li>空间开销：索引结构所占用的存储空间。</li></ul><h3 id="2-2B-树"><a href="#2-2B-树" class="headerlink" title="2.2B+树"></a>2.2B+树</h3><h4 id="2-2-1B-树的结构"><a href="#2-2-1B-树的结构" class="headerlink" title="2.2.1B+树的结构"></a>2.2.1B+树的结构</h4><p>B+树是一种平衡排序树，树中根结点到叶结点的每条路径的长度相同，并且保持键的有序排列。在B+树中进行搜索、顺序访问、插入和删除的时间复杂度均为O(log(n))，它是在数据插入和删除的情况下仍能保持其执行效率的几种使用最广泛的索引结构之一，几乎所有现代DBMS都使用B+树。</p><p>B+树可以定义为具有以下性质的m路搜索树：</p><blockquote><ul><li>除非整棵树只有一个结点，<strong>否则根结点至少有两个子结点；</strong></li><li>除根结点外的<strong>所有内结点至少是半满的</strong>，即有⌈m/2⌉到m个子结点；</li><li>所有叶结点的深度相等；</li><li>叶结点中键的数量必须<strong>大于等于 ⌈(m-1)/2⌉ 且小于等于 m-1</strong> ；</li><li>每个有k个键的内结点都有k+1个非空子结点；</li><li>叶结点中包含所有查找键值。</li></ul></blockquote><p><img src="/posts/41900/image-20230914192825349.png" alt></p><p>树中的每个结点都包含了一个键值对，并且是按键值排序的，一般来说键（key）来自索引的查找键，值则根据结点类型有不同含义。</p><p>如果结点是内结点，那么值则是指向子结点的指针。如果结点是叶结点，则结点汇总的值则可能是记录ID，比如对于DB种的非聚集索引，B+树中存放的就是记录位置的指针；叶结点中的值也可能是记录数据，比如对于聚集索引， B+树中存放的就是记录的实际数据。在树的最底层，叶结点间通过兄弟指针链接起来，形成一个按所有键值大小排序的链表，以便更高效地支持范围查找等顺序处理。</p><p>在上图中的B+树，m取值为4。具体实现上，把B+树索引存储到磁盘文件中的时候，通常是一个页面来存储一个结点，在页面空间能够允许的前提下应该把m取得尽可能的大，让树的高度降低来提高查询的效率。</p><h4 id="2-2-2B-树的查找"><a href="#2-2-2B-树的查找" class="headerlink" title="2.2.2B+树的查找"></a>2.2.2B+树的查找</h4><h5 id="2-2-2-1等值查找"><a href="#2-2-2-1等值查找" class="headerlink" title="2.2.2.1等值查找"></a>2.2.2.1等值查找</h5><p>对于一棵B+树，如果想找出键值为K的记录，则需要执行从根结点到叶结点的递归查找，查找过程为：</p><ol><li>若当前结点为内结点，且结点中的键为<strong>K1，K2，…，Kn</strong>，则根据以下规则来决定下一步对此结点的哪一个子结点进行查找：</li><li>如果<strong>K&lt;K1</strong>，则下一个结点为第1个子结点；</li><li>如果<strong>Ki≤K&lt;Ki+1</strong>，则下一个结点为第i+1个子结点；</li><li>如果<strong>K≥Kn</strong>，则下一个结点为第n+1个子结点。</li></ol><p>递归执行此查找过程，直到查找到叶结点，若当前结点为叶结点，在该结点的键值中查找，若第i个键值为K，则根据第i个值即可找到所需记录；否则查找失败。</p><h5 id="2-2-2-2范围查找"><a href="#2-2-2-2范围查找" class="headerlink" title="2.2.2.2范围查找"></a>2.2.2.2范围查找</h5><p>如果想在B+树中找出在范围[a, b]之间的所有键值，先通过等值查找来查找键a，不论键a在B+树中是否存在，都会到达可能出现a的叶结点，然后在该叶结点中查找等于或大于a的那些键。只要在当前叶结点中不存在比b大的键，就根据兄弟指针找到下一个叶结点，继续查找[a, b]之间的所有键值。</p><p>上面的查找算法在查找范围只有上界或者只有下界时也有效：</p><ol><li>当查找范围为[a,+∞)时，先找到键a可能出现的叶结点，然后从该结点中第一个等于或大于a的键开始，一直到最后一个叶结点的最后一个键。</li><li>当查找范围为(‐∞, b]时，则从B+树的第一个叶结点开始向后查找，直到遇到第一个超过b的键时停止查找。</li></ol><h4 id="2-2-3B-树的插入"><a href="#2-2-3B-树的插入" class="headerlink" title="2.2.3B+树的插入"></a>2.2.3B+树的插入</h4><p>向B+树中插入一个新索引项，必须遍历该树并使用内部结点来确定将键插入到哪个叶结点。在插入过程中，当结点太满时需要对其进行拆分，过程如下：</p><ol><li>找到正确的叶结点L；</li><li>将新索引项按顺序插入到L中：</li><li>如果L有足够的空间，则执行插入操作，算法结束；</li><li>否则，将L平均拆分为L和L2两个结点，并复制L2的第一个键，将其插入到L的父结点中。</li><li>如果父结点中有足够的空间，则执行插入操作，算法结束；否则拆分父结点，将该结点的中间键上移插入到其父结点，然后将剩余的索引项平均拆分为两个结点。递归执行此步骤直到算法结束。</li></ol><p><img src="/posts/41900/image-20230914195822660.png" alt></p><p>上图是向一棵4路B+树分别插入键值10和2的过程。可以看到，插入键值10后，原B+树中最右的叶结点发生了分裂，新增叶结点的第一个键值10被复制并插入到父结点中。插入键值2后，最左的叶结点发生了分裂，新增叶结点的第一个键值3被复制并插入到父结点中，而且还进一步导致了父结点的分裂，其中间键值7被上移并插入到新增的根结点中。</p><h4 id="2-2-4B-树的删除"><a href="#2-2-4B-树的删除" class="headerlink" title="2.2.4B+树的删除"></a>2.2.4B+树的删除</h4><p>在删除过程中，如果因删除索引项导致结点小于半满状态，则必须合并结点。过程如下：</p><ol><li>找到待删除的索引项所在的叶结点L；</li><li>从L中删除该索引项，删除后：</li><li>如果L不低于半满状态，则算法结束；</li><li>否则，通过向兄弟结点借索引项来满足约束条件，如果能成功借到，则算法结束；</li><li>如果兄弟结点也没有多余的索引项可借，则合并L和兄弟结点，删除父结点中指向被合并子结点的索引项。递归执行以上删除操作，直至算法结束。</li></ol><p><img src="/posts/41900/image-20230914205010129.png" alt></p><p>从一棵5路B+树中先后删除键值6和1的过程。可以看到，删除键值6时，原B+树中第二个叶结点中的项数已经无法满足最低要求，因此向左边的兄弟结点借了1项来达到约束条件。删除键值1时，最左的叶结点中项数无法满足最低要求，而且兄弟结点也没有多余的项可借，因此只能对最左的两个结点进行合并。</p><h4 id="2-2-5非唯一查找键"><a href="#2-2-5非唯一查找键" class="headerlink" title="2.2.5非唯一查找键"></a>2.2.5非唯一查找键</h4><p>基于某个查找键来构建索引时，假如表中存在两条或者多条记录在查找键属性上拥有相同的值，那么该查找键称为非唯一查找键。</p><p>非唯一查找键的一个问题在于影响记录删除的效率。假设某个查找键值出现了很多次，当表中拥有该查找键值的某条记录被删除时，为了维护索引与表数据的一致性，删除操作需要在B+树中查看很多个索引项，才能从中找出和被删除记录相对应的那个索引项并删除它，这个过程可能需要遍历多个叶结点。</p><p>解决以上问题的方法有两种：</p><p>一种简单的解决方法是创建包含原始查找键和其他额外属性的复合查找键，确保该复合查找键对于所有记录是唯一的，这种方法通常被大多数数据库系统使用。这个额外属性也叫唯一化属性，它可以是记录ID，或者是在拥有相同查找键值的所有记录中取值唯一的任何其他属性。删除一条记录时，先计算该记录的复合查找键值，然后再用这个复合键值到索引中查找。因为复合查找键值是唯一的，所以不会影响记录删除的效率。在这种方法中，一个查找键值在记录中出现多少次，它在索引中就会被重复存储多少次。</p><p>另一种方法是，每个查找键值在B+树中只存储一次，并且为该查找键值维护一个记录指针的桶（或者列表）来解决非唯一问题。这种方法虽然没有存储冗余信息，但是索引维护和修改起来更加复杂。</p><h3 id="2-3散列表"><a href="#2-3散列表" class="headerlink" title="2.3散列表"></a>2.3散列表</h3><p>散列表也叫哈希表，是一种常见的数据结构，它通过把键值映射到桶数组中的某个位置来加快查找记录的速度。散列表中包含两个关键元素：</p><ul><li><strong>散列函数</strong> ：散列函数h以查找键（散列键）为参数并计算出一个介于0到B-1之间的整数。</li><li><strong>桶数组</strong> ：桶数组是一个编号从0到B-1、长度为B的数组，其中包含B个链表头，每个链表头对应一个桶，用于存储记录。</li></ul><p>构造散列表时，如果一条记录的查找键为K，则将该记录链接到桶号为h(K)的桶中存储。</p><p>散列表在DBMS中被广泛运用，例如基于散列表来组织数据文件、基于散列表来构造索引文件、或者基于散列表进行连接运算等。当散列表的规模大到内存难以容纳时，或者出于数据持久化的目的，就需要将散列表存储在磁盘中。本教程主要讨论散列表在磁盘上的实现。</p><p>磁盘中的散列表与内存中的散列表存在一些区别。首先，桶数组是由页面组成，而不是由指向链表的指针组成；其次，散列到某个桶中的记录是存储在磁盘上的页面而非内存中。因此，磁盘上的散列表在设计时需要考虑访问磁盘的I/O代价以及表规模的扩展问题。</p><h4 id="2-3-1静态散列表"><a href="#2-3-1静态散列表" class="headerlink" title="2.3.1静态散列表"></a>2.3.1静态散列表</h4><p>对于一个散列表，如果其桶数组的规模B（即桶的数量）一旦确定下来就不再允许改变，则称其为静态散列表。</p><h5 id="2-3-1-1散列函数"><a href="#2-3-1-1散列函数" class="headerlink" title="2.3.1.1散列函数"></a>2.3.1.1散列函数</h5><p>由于在设计时无法事先准确知道文件中将存储哪些搜索键值，因此我们希望选择一个具有下列特性的散列函数：</p><ul><li>函数的输出是确定的。相同的搜索键值应该总是生成相同的散列值。</li><li>输出值的分布是随机且均匀的。散列函数应该表现为随机的，即散列值不应与搜索键的任何外部可见的排序相关，且不管搜索键值实际怎样分布，每个桶应分配到的记录数应该几乎相同。</li><li>易于计算。散列函数的执行时间不能太长，因为它需要执行很多次。</li></ul><p>理想的散列函数是能将搜索键值均匀地分布到所有桶中，使每个桶含有相同数目的记录，但是这样的函数往往需要非常长的时间来进行计算。因此，散列函数需要在冲突率和快速执行之间进行权衡。目前最先进的散列函数是Facebook XXHash3。</p><h5 id="2-3-1-2散列表的插入"><a href="#2-3-1-2散列表的插入" class="headerlink" title="2.3.1.2散列表的插入"></a>2.3.1.2散列表的插入</h5><p>当一个查找键为K的新记录需要被插入时，先计算h(K)，找到桶号为h(K)的桶。如果桶内还有空间，我们就把该记录存放到此桶对应的页面中。如果该桶的页面中已经没有空间了，就增加一个新的溢出页，链接到该桶之后，并把新记录存入该页面。这种处理桶溢出问题的方式称为溢出链。<br><img src="/posts/41900/image-20230914210727908.png" alt></p><h5 id="2-3-1-3散列表的删除"><a href="#2-3-1-3散列表的删除" class="headerlink" title="2.3.1.3散列表的删除"></a>2.3.1.3散列表的删除</h5><p>删除查找键值为K的记录与插入操作的方式类似。先找到桶号为h(K)的桶，由于不同的查找键值可能被映射到同一个桶中，因此还需要在桶内搜索，查找键值为K的记录，继而将找到的记录删除。删除记录后，如果允许记录在页面中移动，还可以选择合并同一桶链上的页面来减少链的长度。但是合并页面也有一定的风险，如果交替地往一个桶中插入和删除记录，可能导致页面被反复地创建和删除。</p><h5 id="2-3-1-4散列表的效率"><a href="#2-3-1-4散列表的效率" class="headerlink" title="2.3.1.4散列表的效率"></a>2.3.1.4散列表的效率</h5><p>如果希望达到最好的查找效率，理想情况是散列表中有足够的桶，每个桶只由单个页面组成。如果是这样，那么查询一条记录就只需一次磁盘I/O，且记录的插入和删除也只需两次磁盘I/O。</p><p>为了减少桶溢出的可能性，桶的数量B可选为 (<em>n</em>/<em>f</em>)*(1+<em>d</em>)，其中n是要存储的记录总数，f是一个桶中能存放的记录数，d表示避让因子，一般取值为0.2。这种做法会导致一定的浪费，平均每个桶有20%的空间是空的，好处则是减少了溢出的可能性。</p><p>但是，如果记录不断增长，而桶的数量固定不变，那么最终还是会出现很多桶都包含多个页面的情况。这种情况下，我们就需要在由多个页面构成的桶链中查找记录，每访问一个新的页面就增加一次磁盘I/O，这显然会严重影响散列表的查找效率。</p><h4 id="2-3-2动态散列表"><a href="#2-3-2动态散列表" class="headerlink" title="2.3.2动态散列表"></a>2.3.2动态散列表</h4><p>静态散列表由于其桶的数量不能改变，因此当无法预知记录总数时，难以解决由于记录数不断增长而带来的性能问题。本节我们将讨论两种动态散列表，它们能够以不同的方式动态调整散列表的大小，既不需要重新构建整个表，又能保证每个桶大多只有一个页面，从而最大化读写效率。</p><h5 id="2-3-2-1可扩展散列表"><a href="#2-3-2-1可扩展散列表" class="headerlink" title="2.3.2.1可扩展散列表"></a>2.3.2.1可扩展散列表</h5><p>与静态散列表相比，可扩展散列表在结构上做了以下改变：</p><ul><li>增加了一个间接层，用一个指向页面的指针数组（桶地址表）而非页面数组来表示桶数组。</li><li>指针数组能动态增长，且数组长度总是2的幂，因此数组每增长一次，桶的数量就翻倍。</li><li>并非每个桶都单独拥有一个页面。如果多个桶的记录只需一个页面就能放下，那么这些桶可能共享一个页面，即多个桶指针指向同一个页面。</li><li>散列函数h为每个键计算出一个长度为N的二进制序列，N的值足够大（比如32），但是在某一时刻，这个序列中只有前i位（i≤N）被使用，此时桶的数量为 2i个。<br><img src="/posts/41900/image-20230914211706915.png" alt></li></ul><p>向可扩展散列表中插入键值为K的记录的方法如下：</p><ol><li>计算h(K)，取出该二进制序列的前i位，并找到桶数组中编号与之相等的项，定位到该项对应的页面，假设该页面的编号为j；</li><li>如果页面j中还有剩余空间，则将该记录插入该页面，操作结束；</li><li>如果页面j已满，则需要分裂该页面：<br> a) 如果i＝ij，说明在桶地址表中只有一个表项指向页面j，此时分裂该页，需要增加桶地址表的 大小，以容纳由于分裂而产生的两个桶指针。令i=i+1，使桶地址表的大小翻倍。桶地址表扩 展后，原表中的每个表项都被两个表项替代，且这两个表项都包含和原始表项一样的指针， 所以也应该有两个表项指向页面j。此时，分配一个新的页面n，并让第二个表项指向页面n。 将ij和in的值均置为当前的i值，并将原页面j中的各条记录重新散列，根据前i位来确定该记录 是放在页面j中还是页面n中，然后再次尝试插入新记录。极端情况下，新纪录要插入的页面 可能仍然是满的，说明原页面j中的所有记录在分裂后仍然被散列到了同一个页面中，此时需 要继续上述分裂过程，直至为新纪录找到可存放的空间。<br> b) 如果i&gt; ij，说明在桶地址表中有多个表项指向页面j，此时不需要扩大桶地址表就能分裂页面 j。分配一个新的页面n，将ij和in置为原ij加1后的值；调整桶地址表中原来指向页面j的表项， 其中一半仍指向页面j，另一半则指向新创建的页面n；重新散列页面j中的各条记录，将其分 配到页面j或页面n中，并再次尝试插入新记录。与上一种情况一样，插入仍有可能失败，此 时需继续进行页面分裂的处理。</li></ol><p>以下是一个可扩展散列表的例子。图1所示为一个小型的可扩展散列表，假设其散列函数h能产生4位二进制序列，即N=4。散列表只使用了1位，即i=1。此时桶数组只有2项，一个编号为0，一个编号为1，分别指向两个页面。第一页存放所有散列值以0开头的记录，第二页存放所有散列值以1开头的记录。每个页面上都标注了一个数字，表示由散列函数得到的二进制序列中的前几位用于判定记录在该页面中的成员资格。目前两个页面都只用了1位。</p><p>接下来向表中插人一个散列值为1010序列的记录。因为第一位是1，所以该记录应放入第二个页面，但第二页已经满了，因此需要分裂该页。而此时i2=i=l，因此先要将桶数组翻倍，令i=2，将数组的长度扩展为4。</p><p>扩展桶数组后，以0开头的两个项都指向存放散列值以0开头的记录的第一页，且该页上标注数字仍然为1, 说明该页中记录的成员资格只由其散列值的第一位判定。而原本存放散列值以1开头的记录的页面则需要分裂，把这个页面中以10开头和11开头的记录分别存放到两个页面中。在这两个页面上方标注的数字是2，表示该页面中记录的成员资格需要使用散列值的前两位来判定。改变后的散列表如图2所示。<br><img src="/posts/41900/image-20230914212007010.png" alt><br>可扩展散列表的优点在于每个桶只有一个页面，所以如果桶地址表小到可以驻留在内存的话，查找一个记录最多只需要一次磁盘I/O。但是由于它是以桶数组翻倍的形式扩展的，所以也存在以下缺点：</p><ul><li>随着i的增大，每次桶数组翻倍时需要做的工作将越来越多，而且这些工作还会阻塞对散列表的并发访问，影响插入和并发操作的效率。</li><li>随着i的增大，桶地址表会越来越大，可能无法全部驻留在内存，或者会挤占其他数据在内存中的空间，导致系统中的磁盘I/O操作增多。</li></ul><h5 id="2-3-2-2线性散列表"><a href="#2-3-2-2线性散列表" class="headerlink" title="2.3.2.2线性散列表"></a>2.3.2.2线性散列表</h5><p>针对可扩展散列表存在的问题，下面介绍另一种动态散列表，称为线性散列表。相对于可扩展散列表，线性散列表中桶的增长较为缓慢，它有以下特点：</p><ul><li>桶数n的大小，要能使所有桶中的实际记录总数与其能容纳的记录总数之间的比值保持在一个指定的阈值之下（如80%），如果超过该阈值，则增加一个新桶。</li><li>允许桶有溢出页，但是所有桶的平均溢出页数远小于1。</li><li>若当前的桶数为n，则桶数组项编号的二进制位数i=⌈ log2n⌉。</li></ul><p>令一个线性散列表当前桶数为n，桶数组项编号的二进制位数为i，向线性散列表中插入键值为K的记录的方法如下：</p><ol><li>计算h(K)，取出该二进制序列右端的i位，假设为a1a2…ai，令a1a2…ai对应的二进制整数为m。如果m&lt;n，说明编号为m的桶存在，将记录存入桶m中；如果n≤m&lt;2i，说明编号为m的桶还不存在，则将记录存入编号为(m-2i-1)的桶中，即将a1a2…ai中的a1改为0时对应的桶。</li><li>如果要插入的桶中没有空间，则创建一个溢出页，将其链到该桶上，并将记录就存入该溢出块中。</li><li>插入记录后，计算 (当前实际记录总数r) / (n个桶能容纳的记录总数) 的值，并跟阈值相比，若超过阈值，则增加一个新桶到线性散列表中。注意，新增加的桶和之前发生插入的桶之间没有任何联系。如果新桶编号的二进制表示为la2a3…ai，则分裂桶号为0a2a3…ai的桶中的记录，根据这些记录的散列值的后i-1位分别散列到这两个桶中。</li></ol><p>当n的值超过2i时，需要将i的值加1。理论上，对于现有的桶编号，要在它们的位序列前面增加一个0，来保证跟新的桶编号的位数一致，但是由于桶编号被解释成二进制整数，因此实际上它们只需要保持原样即可。</p><p>以下是一个线性散列表的例子。</p><p>图1所示为一个桶数n=2 的线性散列表，桶编号所需要的二进制位数i = ⌈ log22⌉ = 1，表中的记录数r=3。图中两个桶的编号分别为0和1，每个桶包含一个页面，每个页面能存放两个记录。假设散列函数产生4位二进制序列，用记录散列值的末位来确定该记录所属的桶，所有散列值以0结尾的记录放入第一个桶，以1结尾的记录放入第二个桶。</p><p>在确定桶数n时，本例使用的阈值是85%，即桶的平均充满率不超过总容量的85%。</p><p>下面先插入散列值为0101的记录。因为0101以1结尾，所以记录应放入第二个桶。插入该记录后，两个桶中存放了四个记录，平均充满率为100%，超过了85%，因此需要增加一个新桶，即桶数n=3。i = ⌈log23⌉ = 2，即桶编号需要2位。新增的桶的编号为10。接着，分裂桶00（即原来的桶0），将散列值为0000 （末两位为00）的记录保留在桶00中，散列值为1010（末两位为10）的记录存入桶10中，改变后的散列表如图2所示。</p><p>接下来再插入散列值为0001的记录。因为0001的末两位为01，所以应将该记录存入桶01中。不巧的是，该桶的页面已经装满，所以需要增加一个溢出页来提供存储空间。插入后，3个桶中有5条记录，平均充满率约83%，未超过85%，所以不需要创建新桶。改变后的散列表如图3所示。<br><img src="/posts/41900/image-20230914212247020.png" alt></p><h3 id="2-4B-树补充"><a href="#2-4B-树补充" class="headerlink" title="2.4B+树补充"></a>2.4B+树补充</h3><p>B树和B+树的目的是实现一个自组织的多级索引，B+树与B树相比，B+树的内部节点只存储键值对的键，而不存储数据。所有数据都存储在叶子节点中。叶子节点之间通过指针链接形成一个有序链表，以便支持范围查询。在插入和删除时，B树可能需要在内部节点中进行数据的移动，而B+树只需要在叶子节点中进行操作。</p><p>B+树的通过叶子结点的Pnext指针范围查询时，其IO读取次数不是一次。在B+树中，每一个叶子结点都是一页，即IO单位读取的字节大小，每遍历一个叶子节点时，都会有一次IO读取。</p><p><strong>B+树相比B树减少了IO次数的真正原因</strong>：B+树的索引页不包含数据，因此一个数据页可查询到很多索引，降低下一次去磁盘再拿索引页的可能性。</p><p>对应的B+树也就是类似于操作系统中的多级索引，通过增加索引，用少量的存储空间来换取对应的快速查找，减少访问块拿取数据所耗的时间，使得一个块中尽可能多的包含所需的信息（无论是查找还是所需数据）。</p><p>为什么用B+树？<strong>InnoDB一棵B+树可以存放多少行数据?</strong></p><blockquote><p>这个问题的简单回答是：约2千万行。  </p></blockquote><ul><li>在计算机中，磁盘存储数据最小单元是扇区，一个扇区的大小是512字节。</li><li>文件系统中，最小单位是块，一个块大小就是4k;</li><li>InnoDB存储引擎最小储存单元是页，一页大小就是16k。</li></ul><p><img src="/posts/41900/image-20230915160729536.png" alt></p><p>因为B+树叶子存的是数据，内部节点存的是键值+指针。索引组织表通过非叶子节点的二分查找法以及指针确定数据在哪个页中，进而再去数据页中找到需要的数据;</p><p><img src="/posts/41900/image-20230915160744079.png" alt></p><p>假设B+树的高度为2的话，即有一个根结点和若干个叶子结点。这棵B+树的存放总记录数为=根结点指针数*单个叶子节点记录行数。  </p><ul><li>如果一行记录的数据大小为1k，那么单个叶子节点可以存的记录数 =16k/1k =16.</li><li>非叶子节点内存放多少指针呢?我们假设主键ID为bigint类型，长度为8字节，而指针大小在InnoDB源码中设置为6字节，所以就是8+6=14字节，16k/14B =16*1024B/14B = 1170</li></ul><p>因此，一棵高度为2的B+树，能存放1170 * 16=18720条这样的数据记录。同理一棵高度为3的B+树，能存放1170 *1170 *16 =21902400，也就是说，可以存放两千万左右的记录。B+树高度一般为1-3层，已经满足千万级别的数据存储。</p><h4 id="2-4-1B-树的插入操作"><a href="#2-4-1B-树的插入操作" class="headerlink" title="2.4.1B+树的插入操作"></a>2.4.1B+树的插入操作</h4><p>在B+树中插入关键字时，需要注意以下几点：</p><ul><li>插入的操作全部都在叶子结点上进行，且不能破坏关键字自小而大的顺序；</li><li>由于 B+树中各结点中存储的关键字的个数有明确的范围，做插入操作可能会出现结点中关键字个数超过阶数的情况，此时需要将该结点进行 “分裂”；</li></ul><p>B+树的阶数 <code>M = 3</code> ，且 <code>⌈M/2⌉ = 2（取上限）</code> 、<code>⌊M/2⌋ = 1（取下限）</code>,B+树的阶数是指一个B+树节点中最多可以包含的子节点数量（子树的数量），这个参数决定了B+树的节点大小以及树的结构，其中<strong>键的数量为阶数-1</strong>。</p><p>B+树中做插入关键字的操作，有以下 3 种情况：</p><ul><li>1、 若被插入关键字所在的结点，其含有关键字数目小于阶数 M，则直接插入；</li></ul><p>比如插入关键字 <code>12</code> ，插入关键字所在的结点的 <code>[10，15]</code> 包含两个关键字，小于 <code>M</code> ，则直接插入关键字 <code>12</code> 。</p><p><img src="/posts/41900/v2-386cefe3c3c93b726387ee2abc577691_b.webp" alt></p><ul><li>2、 若被插入关键字所在的结点，其含有关键字数目等于阶数 M，则需要将该结点分裂为两个结点，一个结点包含 <code>⌊M/2⌋</code> ，另一个结点包含 <code>⌈M/2⌉</code> 。同时，将<code>⌈M/2⌉</code>的关键字上移至其双亲结点。假设其双亲结点中包含的关键字个数小于 M，则插入操作完成。</li></ul><p>插入关键字 <code>95</code> ，插入关键字所在结点 <code>[85、91、97]</code> 包含 3 个关键字，等于阶数 <code>M</code> ，则将 <code>[85、91、97]</code> 分裂为两个结点 <code>[85、91]</code> 和结点 <code>[97]</code> , 关键字 <code>95</code> 插入到结点 <code>[95、97]</code> 中，并将关键字 <code>91</code> 上移至其双亲结点中，发现其双亲结点 <code>[72、97]</code> 中包含的关键字的个数 2 小于阶数 <code>M</code> ，插入操作完成。<br><img src="/posts/41900/v2-4e621ab9044dcb42643066f6031226b0_b.webp" alt></p><ul><li>3、在第 2 情况中，如果上移操作导致其双亲结点中关键字个数大于 M，则应继续分裂其双亲结点。</li></ul><p>插入关键字 <code>40</code> ，按照第 2 种情况将结点分裂，并将关键字 <code>37</code> 上移到父结点，发现父结点 <code>[15、37、44、59]</code> 包含的关键字的个数大于 <code>M</code> ，所以将结点 <code>[15、37、44、59]</code> 分裂为两个结点 <code>[15、37]</code> 和结点 <code>[44、59]</code> ，并将关键字 <code>37</code> 上移到父结点中 <code>[37、59、97]</code> . 父结点包含关键字个数没有超过 <code>M</code> ，插入结束。</p><p><img src="/posts/41900/v2-467b2c27f41bad29b01be13e1e5cd1bb_b.webp" alt></p><ul><li>4、若插入的关键字比当前结点中的最大值还大，破坏了B+树中从根结点到当前结点的所有索引值，此时需要及时修正后，再做其他操作。</li></ul><p>插入关键字 <code>100</code>，由于其值比最大值 <code>97</code> 还大，插入之后，从根结点到该结点经过的所有结点中的所有值都要由 <code>97</code> 改为 <code>100</code>。改完之后再做分裂操作。<br><img src="/posts/41900/v2-85fb69b1f6d5134f45808fc884ad2e4a_b.webp" alt></p><h4 id="2-4-2B-树的删除操作"><a href="#2-4-2B-树的删除操作" class="headerlink" title="2.4.2B+树的删除操作"></a>2.4.2B+树的删除操作</h4><p>在 B+树中删除关键字时，有以下几种情况：</p><ul><li>1、 找到存储有该关键字所在的结点时，由于该结点中关键字个数大于<code>⌈M/2⌉</code>，做删除操作不会破坏 B+树，则可以直接删除。</li></ul><p>删除关键字 <code>91</code>，包含关键字 <code>91</code> 的结点 <code>[85、91、97]</code> 中关键字的个数 3 大于 <code>⌈M/2⌉ = 2</code> ，做删除操作不会破坏 B+树的特性，直接删除。</p><p><img src="/posts/41900/v2-7607b34265b14b3527101d53ce9c2b70_b.webp" alt></p><ul><li>2、 当删除某结点中最大或者最小的关键字，就会涉及到更改其双亲结点一直到根结点中所有索引值的更改。</li></ul><p>以删除整颗 B+树中最大的关键字 <code>97</code> 为例，查找并删除关键字 <code>97</code> ， 然后向上回溯，将所有关键字 <code>97</code> 替换为次最大的关键字 <code>91</code> :</p><p><img src="/posts/41900/v2-3aee225a4ba3e3a1b428e3f30e312637_b.webp" alt></p><ul><li>3、 当删除该关键字，导致当前结点中关键字个数小于 <code>⌈M/2⌉</code>，若其兄弟结点中含有多余的关键字，可以从兄弟结点中借关键字完成删除操作。</li></ul><p>当删除某个关键字之后，结点中关键字个数小于 <code>⌈M/2⌉</code> ，则不符合 B+树的特性，则需要按照 3 he 4 两种情况分别处理。以删除关键字 <code>51</code> 为例，由于其兄弟结点 <code>[21、37、44]</code> 中含有 3 个关键字，所以可以选择借一个关键字 <code>44</code>，同时将双亲结点中的索引值 <code>44</code> 修改 <code>37</code> ，删除过程如下图所示：</p><p><img src="/posts/41900/v2-8dae05b8aa006d6d1fc6bb54c24169a5_b.webp" alt></p><ul><li>4、 第 3 种情况中，如果其兄弟结点没有多余的关键字，则需要同其兄弟结点进行合并。</li></ul><p>为了说明这种情况，我们在第 3 种情况最终得到的 B+树之上进行删除操作。第 3 种情况删除关键字 <code>51</code> 之后得到如下所示 B+树：<br><img src="/posts/41900/image-20230915141924729.png" alt></p><p>我们以删除上面这个 B+树中的关键字 <code>59</code> 说明第 4 种情况，首先查找到关键 <code>59</code> 所在结点 <code>[44、59]</code> ，发现该结点的兄弟结点 <code>[21、37]</code> 包含的关键字的个数 2 等于 <code>⌈M/2⌉</code>， 所以删除关键字 <code>59</code> ，并将结点 <code>[21、37]</code> 和 <code>[44]</code> 进行合并 <code>[21、37、44]</code> ，然后向上回溯，将所有关键字 <code>59</code> 替换为次最大的关键字 <code>44</code> :</p><p><img src="/posts/41900/v2-c33a70c8eaa38e96c3052a6bddc9d0d4_b.webp" alt></p><ul><li>5、 当进行合并时，可能会产生因合并使其双亲结点破坏 B+树的结构，需要依照以上规律处理其双亲结点。</li></ul><p>删除关键字 <code>63</code>，当删除关键字后，该结点中只剩关键字 <code>72</code>，且其兄弟结点 <code>[85、91]</code> 中只有 2 个关键字，所以将 <code>[72]</code> 和 <code>[85、91]</code> 进行合并，向上回溯，删除结点 <code>[72、91]</code> 当中的关键字 <code>72</code> ，此时结点中只有关键 <code>91</code> ，不满足 B+树中结点关键字个数要求，但其兄弟结点 <code>[15、44、59]</code> 中包含的 3 个关键字，所以从其兄弟结点当中借一个关键字 <code>59</code> , 再对其兄弟结点的父结点中的关键字进行调整，将关键字 <code>59</code> 替换为 <code>44</code> .</p><p><img src="/posts/41900/v2-ae4011609fdf74e80d10fefb9e47dbb8_b.webp" alt></p><p>总之，在 B+树中做删除关键字的操作，采取如下的步骤：</p><ol><li>删除该关键字，如果不破坏 B+树本身的性质，直接完成删除操作（情况 1）；</li><li>如果删除操作导致其该结点中最大（或最小）值改变，则应相应改动其父结点中的索引值（情况 2）；</li><li>在删除关键字后，如果导致其结点中关键字个数不足，有两种方法：一种是向兄弟结点去借，另外一种是同兄弟结点合并（情况 3、4 和 5）。（注意这两种方式有时需要更改其父结点中的索引值。）</li></ol><h3 id="2-5动态散列表补充"><a href="#2-5动态散列表补充" class="headerlink" title="2.5动态散列表补充"></a>2.5动态散列表补充</h3><p>静态哈希有一个<strong>大前提就是我们事前是知道哈希表需要容纳多少键值对的</strong>，否则如果出现预设的容量过大或者过小问题时对其扩容或者缩容的代价都比较大（可以采用一致性哈希）。</p><p>因此，为了解决这个问题，提出了一些<strong>动态</strong>的哈希方案，即哈希表的运行的过程中<strong>可以按需增长或者减小</strong>。下面介绍三种动态哈希方案：</p><h4 id="2-5-1-链式哈希"><a href="#2-5-1-链式哈希" class="headerlink" title="2.5.1 链式哈希"></a>2.5.1 链式哈希</h4><p>这是最简单的动态哈希方案，也是java或者jvm中默认的哈希方案。链式哈希中，哈希表中数组的成员是buckets的链表，因此，当发生冲突时，将<strong>元素添加到对应Bucket的末尾</strong>即可，<strong>如果Bucket已满，则创建一个新的Bucket即可。</strong><br><img src="/posts/41900/v2-8514108512a37c72b1b7538ff6a4b433_720w.webp" alt></p><h4 id="2-5-2-可扩展哈希"><a href="#2-5-2-可扩展哈希" class="headerlink" title="2.5.2 可扩展哈希"></a>2.5.2 可扩展哈希</h4><p>链式哈希的一种改进，每个桶不<strong>再链式的生长</strong>，而是用<strong>分裂的方式来扩展</strong>，分裂的过程只会移动被分裂的桶中的元素，而不会影响其他的元素。</p><p>如下图所示，可扩展哈希方式<strong>包含一个slot数组和一系列的桶，每个slot中保存对应桶的指针。对于slot数组有一个全局bit位</strong>，记录在这个哈希表中<strong>需要多少位</strong>才能找到对应桶，对于每一个桶，有一个本地bit位，<strong>记录找到本地的桶需要多少位</strong>。<br>[注意]: 公式$$global_{bit} = \max(local_{bit})$$下图全局bit和本地bit的关系。<br><img src="/posts/41900/image-20230916192810224.png" alt></p><ul><li><strong>Global Depth</strong>：假设global depth为n，那么当前的directory必定有 2� 个entry。例如，当前n=2，那么就有4个entry，n=3就有8个entry。同时，给定一个key，需要用global depth取出这个key的低n位的二进制值。例如，一个key的二进制是10111，如果global depth是3，通过<code>IndexOf(key)</code>函数，得到返回值的二进制值是111，即为7。这个值用来索引directory[111]位置的bucket。</li><li><strong>Local Depth</strong>：local depth指的是（假设local depth为n），在当前的bucket之下，每个元素的key的低n位都是相同的。</li></ul><p>两者之间有什么关系呢？</p><ul><li>对于一个bucket来说，如果当前的global depth等于local depth，那说明这个bucket只有一个指针指向它。</li><li>如果当前的global depth大于local depth，必定不止一个指针指向它。</li><li>计算当前bucket有几个指针指向它的公示是$2^{globalDepth-localDepth}$ 。</li></ul><p><img src="/posts/41900/image-20230918171023892.png" alt></p><p>关于对应的entry的增长，这一步有一个很重要的点，新增长的entry怎么分配到对应的bucket？如果和上图的情况一样，从1增长到2，只需要把多出来的一个拉到唯一的bucket上就可以了，但如果从2到4，从4到8呢？多出来的若干个如何处理？其实只需要将多出来的一部分指针完全复制之前的一份就可以了。</p><p>这样做法我觉得是可扩展哈希的比较重要的细节，由于可扩展哈希扩展direcotry时是按照当前大小的两倍进行扩展，新增长出来的部分作为之前directory的对等实体，每一个新的entry都对应了之前对应的entry，指向相同的bucket。唯一的不同就是之前的direcotry的索引最高位是0，扩展出来的最高位是1。</p><p><img src="/posts/41900/image-20230918171031231.png" alt></p><p>一个比较好的解释可以看<a href="https://zhuanlan.zhihu.com/p/622221722">这份实验解说</a>，讨论了可拓展哈希表的一些细节。</p><h4 id="2-5-3-线性哈希"><a href="#2-5-3-线性哈希" class="headerlink" title="2.5.3 线性哈希"></a>2.5.3 线性哈希</h4><p>线性哈希是可扩展哈希的改进，可扩展哈希有一个<strong>小的性能瓶颈</strong>，在桶分裂且需要扩展slot array时，需要对整个slot array加锁直到桶分裂完成。为了解决这个问题，提出了线性哈希方式。哈希表<strong>维护一个指针</strong>，指向下一个准备分裂的桶，并且线性哈希采用<strong>多个哈希函数</strong>来寻找正确的桶。</p><p><strong>当插入过程中</strong>，任何一个桶溢出，都将分裂指针指向桶（无论这个桶是否溢出）。最初，指针指向第一个桶，即当任何一个桶发生溢出时，都分裂第一个桶。且现在只有一个哈希函数。<br><img src="/posts/41900/image-20230916192838988.png" alt></p><p>现需要插入17，发现对应的桶已满，发生了溢出，因此需要分裂第一个桶.</p><p><img src="/posts/41900/image-20230916192850195.png" alt></p><p>现在将第一个桶分裂，就需要增加一个桶，那么哈希表中已经有了5个桶，原来的哈希函数中的n为4，不能满足使用要求，需要增加新的哈希函数$ℎasℎ_2$。然后使用新的哈希函数重新分配第一个桶中的元素。<br><img src="/posts/41900/image-20230916192924840.png" alt></p><p>现在再来观察查询过程，现在需要查询20，首先使用第一个哈希函数，发现哈希值为0，即第一个桶。但是这个哈希值落在了分裂指针的上面，即要查询的值落在一个已经分裂的桶上，而这个桶中的所有键值对已经用第二个哈希函数重新分配位置，因此，需要用第二个哈希函数重新计算哈希值为4，即第五个桶中，然后在这个桶中循序查询即可。<br><img src="/posts/41900/image-20230916192937036.png" alt></p><h3 id="2-6SQL索引背后"><a href="#2-6SQL索引背后" class="headerlink" title="2.6SQL索引背后"></a>2.6SQL索引背后</h3><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。因为数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构就是索引。</p><p><img src="/posts/41900/image-20230915145557510.png" alt></p><p>以上图为例子，左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在(O(log_2n))的复杂度内获取到相应数据。</p><h4 id="2-6-1为什么使用B-Tree"><a href="#2-6-1为什么使用B-Tree" class="headerlink" title="2.6.1为什么使用B+Tree"></a>2.6.1为什么使用B+Tree</h4><p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。下面先介绍内存和磁盘存取原理，然后再结合这些原理分析B-/+Tree作为索引的效率。</p><h5 id="2-6-1-1主存存取原理"><a href="#2-6-1-1主存存取原理" class="headerlink" title="2.6.1.1主存存取原理"></a>2.6.1.1主存存取原理</h5><p>目前计算机使用的主存基本都是随机读写存储器（RAM），现代RAM的结构和存取原理比较复杂，这里本文抛却具体差别，抽象出一个十分简单的存取模型来说明RAM的工作原理。<br><img src="/posts/41900/image-20230915151546160.png" alt><br>从抽象角度看，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。每个存储单元有唯一的地址，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元。</p><p>主存的存取过程如下：</p><ul><li>当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。</li><li>写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。</li><li>这里可以看出，主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的。<h5 id="2-6-1-2磁盘存取原理"><a href="#2-6-1-2磁盘存取原理" class="headerlink" title="2.6.1.2磁盘存取原理"></a>2.6.1.2磁盘存取原理</h5>索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。</li></ul><p>一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）。</p><p><img src="/posts/41900/image-20230915152123723.png" alt></p><p>盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。</p><p>当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。在得到对应块后，再在对应的块内部通过偏移量得到所需的字节。</p><p><strong>局部性原理与磁盘预读</strong></p><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：</p><p>当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p><p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p><h4 id="2-6-2MySQL索引实现"><a href="#2-6-2MySQL索引实现" class="headerlink" title="2.6.2MySQL索引实现"></a>2.6.2MySQL索引实现</h4><p>在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文主要讨论MyISAM和InnoDB两个存储引擎的索引实现方式。</p><h5 id="2-6-2-1-MyISAM索引实现"><a href="#2-6-2-1-MyISAM索引实现" class="headerlink" title="2.6.2.1 MyISAM索引实现"></a>2.6.2.1 MyISAM索引实现</h5><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：<br><img src="/posts/41900/image-20230915152512991.png" alt></p><p>这里设表一共有三列，假设我们以Col1为主键，则图8是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：<br><img src="/posts/41900/image-20230915152644649.png" alt><br>同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p><h5 id="2-6-2-2InnoDB索引实现"><a href="#2-6-2-2InnoDB索引实现" class="headerlink" title="2.6.2.2InnoDB索引实现"></a>2.6.2.2InnoDB索引实现</h5><p><img src="/posts/41900/image-20230916210637354.png" alt></p><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。第一个重大区别是InnoDB的<strong>数据文件本身就是索引文件</strong>。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p><p><img src="/posts/41900/image-20230915153212935.png" alt></p><p>上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p><p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，下图为定义在Col3上的一个辅助索引：<br><img src="/posts/41900/image-20230915154149440.png" alt></p><p>这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p><p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p><ul><li>聚簇索引：数据是按照主键索引组织，也就是行的数据聚集在了主键索引里面。即主键B+树的叶子结点结构和磁盘上存储的文件页是相同的，方便扫描搜索。</li><li>非聚簇索引：主键索引本身是key和数据存储位置，即存储的是页号与slot号的索引。</li></ul><p>对于高效的存储介质，可以把B+树节点大小设置小一点，因为这样可以尽量减少读取的冗余数据。</p><h3 id="2-7LSM-Tree"><a href="#2-7LSM-Tree" class="headerlink" title="2.7LSM-Tree"></a>2.7LSM-Tree</h3><p>LSM-Tree 的全称为日志结构合并树〈Log-Structured Merge Tree)，核心思想是将内存中的缓存数据以记录日志的形式追加写入到存储介质，初衷是为了将小粒度的随机写聚合成大粒度的顺序追加写，从而减少机械磁盘悬臂的频繁机械运动，提升I/O效率。</p><p>具体来说 LSM 的数据更新是日志式的，修改数据时直接追加一条新记录（为被修改数据创建一个新版本），而使用 B/B+ 树的数据库则需要找到数据在磁盘上的位置并在原地进行修改。<br><img src="/posts/41900/image-20231007214850642.png" alt></p><p>LSM-Tree 的基本结构如上图，数据被分成了多层，其中CO存储在内存，其他层存储在外存，数据在每一层按照Key的大小依次排列，并且这些层的容量依次成倍增加。</p><p>LSM 树将离散的随机写请求都转换成批量的顺序写请求（WAL + memtable），以此提高写性能。但也带来了一些问题：</p><ul><li>读放大（Read Amplification）。按照上面【读操作】的描述，读操作有可能会访问大量的文件；</li><li>空间放大（Space Amplification）。因为所有的写入都是顺序写（Append-only）的，不是在对数据进行直接更新（in-place update），所以过期数据不会马上被清理掉</li></ul><p>所以维护和减少 SST 文件数量是很有必要的。RocksDB 会根据配置的不同 Compaction 算法策略，进行 Compaction 操作。<strong>Compaction 操作会删除过期 或者标记为删除/重复的 key，对数据进行重新合并来提高查询效率。</strong></p><p>当键值对写入LSM-Tree时，首先会被插入到位于内存中的C0，当C0满了以后，C0中的数据会和C1中的数据进行合并，合并后的结果会重新写入C1。同理，当Cn满了时，Cn也会和Cn+1合并，合并后的结果写入Cn+1。这些合并操作被称为Compaction操作。</p><p><img src="/posts/41900/image-20231007150101267.png" alt></p><p>比如常见的LevelDB中就使用了这一数据结构，如前文中提到的，对于LSM-Tree而言维护着内存外存两部分，分别是在内存的Memtable（内存表）部分和Inmutable Memtable（只读内存表）两部分，即前文的c0。</p><p>另一部分存储在外存，同时按存储的量级上升，其中外存部分每层有Sorted string table（顺序字符串表）文件，其中k-v数据就存储在这些SSTable文件中，除了L0其他层都是按key的顺序排列的，也就是层间存放的key范围是不重叠的。</p><p>除了数据，LevelDB还有Log、Mainfest以及Current文件：</p><ul><li>Log 文件存储最近的数据更新，采用追加的方式将每次的更新数据写到日志文件的末尾，每个日志文件对应当前的Memtable，更新操作先写入日志文件然后更新内存表。当内存表被写入SSTable 文件后，相应的日志文件会被删除。Log 文件也可做故障恢复。</li><li>Mainfest文件存储当前数据库元数据，如每层包含哪些SSTable文件、每个文件中 key的范围以及其他的元数据信息，如日志文件等。</li><li>Current文件是一个简单的文本文件，记录当前使用的Mainfest文件名，通常通过判断当前文件是否存在来判断数据库是否已经创建。</li></ul><p>Compaction 虽然减少了读放大（减少 SST 文件数量）和空间放大（清理无效数据），但也因此带来了写放大（Write Amplification）的问题（底层 I/O 被 Compaction 操作消耗，会大于上层请求速递）<br><img src="/posts/41900/image-20231007212259173.png" alt></p><p>LevelDB的数据写入流程可以理解为两步:</p><ol><li>追加一条日志记录到Log 文件。</li><li>写入Memtable，其中 Memtable被实现为跳表，跳表的功能和平衡树类似，但实现更为简单，并且维持平衡的操作更轻量。</li></ol><p><img src="/posts/41900/image-20231007152515592.png" alt></p><p>当Memtable容量达到上限时，它会转变为一个Immutable Memtable，只允许读而不允许写，并创建一个新的Memtable 提供写入。Immutable Memtable未来将转换成SSTable文件并flush到L0，为了更快速的下刷，L0的SSTable是直接生成的，因此文件之间是可能重叠的。</p><p>而随着Memtable不断的被转化成SSTable文件并写入L0后，L0的文件数量会超过容量限制，进而触发Compaction操作。</p><p><img src="/posts/41900/image-20231007153153896.png" alt></p><p>同时由于L0层有范围重叠，如上图所示，读取时从L0层读取所有文件，并在L0的下一层，即L1层找到Key范围与L0所读取文件有重叠的所有文件，然后将这些文件中的数据在内存进行合并排序后，重新生成新的SSTable文件写入L1层。由于可能有重复的新旧数据，合并过程中会删除旧数据，因此合并后一般能够减少文件的总量。其他层的合并也是类似的，只是每次只从当前层选取一个SSTable文件与下层进行合并。</p><p>Compaction操作是LSM-Tree内部数据整合的机制，也是其中最复杂的过程之一，具体实现起来有很多细节与优化方法。</p><p>对于查询来说，首先是依次在Memtable和Immutable Memtable 中查询，如果都没有找到，则在外存中继续查找。在外存中查找时，我们会从mainfest文件中读取各层中 SSTable文件的Key范围，然后找出可能包含查询Key 的 SSTable文件，这个信息一般会被缓存在内存中。<br><img src="/posts/41900/image-20231007153432918.png" alt></p><p>除了 L0 层外，其他各层最多只有一个 SSTable 文件可能包含查询键。也就是L0无序，除 L0 外的层都是全局有序的。随后我们将这些文件按所在层排序，位于 L0 层的在前，L0 层内的文件按时间先后逆序排列，然后按照顺序依次在SSTable 文件内查找。</p><p>SSTable 文件内的数据是排序的，并被切割成多个数据块，由内部的索引信息记录者各个数据块中 key 的范围。因此查询一般首先通过索引信息确定可能包含 Key 的数据块，然后在数据块内查找。</p><p>LevelDB 在每个 SSTable 文件中为每个数据块建立了一个布隆过滤器，在数据块内的查找前可以通过布隆过滤器来提前检验，如果确定不存在，则继续到下一个 SSTable 文件进行查找。更具体的详细实现可以看<a href="https://zhuanlan.zhihu.com/p/415799237">这篇LSM总结博客</a>。</p><h3 id="2-8LSM-Tree补充"><a href="#2-8LSM-Tree补充" class="headerlink" title="2.8LSM-Tree补充"></a>2.8LSM-Tree补充</h3><h4 id="LSM-Tree"><a href="#LSM-Tree" class="headerlink" title="LSM-Tree"></a>LSM-Tree</h4><p>LSM 树将离散的随机写请求都转换成批量的顺序写请求（WAL + memtable），以此提高写性能。但也带来了一些问题：</p><ul><li>读放大（Read Amplification）。按照上面【读操作】的描述，读操作有可能会访问大量的文件；</li><li>空间放大（Space Amplification）。因为所有的写入都是顺序写（Append-only）的，不是在对数据进行直接更新（in-place update），所以过期数据不会马上被清理掉</li></ul><p>所以维护和减少 SST 文件数量是很有必要的。<br><strong>定义</strong></p><ol><li>LSM树是一个横跨内存和磁盘的，包含多颗”子树”的一个森林。</li><li>LSM树分为Level 0，Level 1，Level 2 … Level n 多颗子树，其中只有Level 0在内存中，其余Level 1-n在磁盘中。</li><li>内存中的Level 0子树一般采用排序树（红黑树/AVL树）、跳表或者TreeMap等这类有序的数据结构，方便后续顺序写磁盘。</li><li>磁盘中的Level 1-n子树，本质是数据排好序后顺序写到磁盘上的文件，只是叫做树而已。</li><li>每一层的子树都有一个阈值大小，达到阈值后会进行合并，合并结果写入下一层。</li><li>只有内存中数据允许原地更新，磁盘上数据的变更只允许追加写，不做原地更新<br><img src="/posts/41900/image-20231007211728835.png" alt></li></ol><p>WAL (write-ahead log)是一种有利于顺序写的持久化日志文件。很多存储系统中都有类似的设计（如 MySQL 的 redo log/undo log、ZK 的 WAL）；</p><p>RocksDB 每次写数据都会先写入 WAL 再写入 memtable，在发生故障时，通过重放 WAL 恢复内存中的数据，保证数据一致性。</p><p>这种设计有什么好处呢？这样 LSM 树就可以将有易失性（volatile）的内存看做是持久型存储，并且信任内存上的数据。</p><p>至于 WAL 的创建删除时机，每次 flush 一个 CF（列族数据） 后，都会新建一个 WAL。<strong>这并不意味着旧的 WAL 会被删除，因为别的 CF 数据可能还没有落盘，只有所有的 CF 数据都被 flush 且所有的 WAL 有关的 data 都落盘，相关的 WAL 才会被删除</strong>。</p><p>其中SSTable (sorted string table)，全称是 Sorted String Table，存在于磁盘，是一个持久化的、有序的、不可更改的 Map 结构，Key 和 Value 都是任意的 Byte 串。上文提到内存中的 memtable 在满足条件的情况下会执行 flush 操作，SSTable 的 文件结构如下：<br><img src="/posts/41900/image-20231007211940551.png" alt></p><ul><li>数据块 Data Block，存储<strong>有序</strong>键值对，是 SSTable 的数据实体；<strong>为了节省存储空间，并不会为每一对 key-value 对都存储完整的 key 值，而是存储与上一个 key 非共享的部分，避免了 key 重复内容的存储（这种通过 delta encode 的方式节省空间的方式在其他存储中间件底层中也很常见）</strong>。</li><li>Meta Block，存储 Filter 相关信息，用于加快 sst 中查询数据的效率；Filter 通过 <strong>Bloom Filter</strong> 来过滤判断指定的 data block 中是否存在要查询的数据。</li><li>Meta Index Block，对 Meta Block 的索引，它只有一条记录，key 是 meta index 的名字（也就是 Filter 的名字），value 为指向 meta index 的位置；</li><li>Index Block，index block 用来存储所有 data block 的相关索引信息。indexblock 包含若干条记录，每一条记录代表一个 data block 的索引信息；</li><li>Footer，指向各个分区的位置和大小。<strong>Footer 是定长的，读取 SSTable 文件的时候，就是从文件末尾，固定读取字节数，进而得到了 Footer 信息。 Footer 中的信息，</strong>指明了 MetaIndexBlock 和 IndexBlock 的位置，进而找到 MetaBlock 和 DataBlock。****</li></ul><h4 id="读-amp-写"><a href="#读-amp-写" class="headerlink" title="读&amp;写"></a>读&amp;写</h4><p><img src="/posts/41900/dc23c8f5d4fa3fa86dbb9a8852d9dcd7725636a9.png@1256w_972h_!web-article-pic.avif" alt></p><ol><li>在 active memtable 中查找；</li><li>如果 active memtable 没有，则在 immutable memtable 中查找；</li><li>如果 immutable memtable 没有，则在 L0 SSTable 中查找（RocksDB 采用遍历的方法查找 L0 SSTable，为了提高查找效率会控制 L0 文件的个数）；</li><li>如果找不到，则在剩余的 SSTable 中查找（对于 L1 层以及 L1 层以上层级的文件，每个 SSTable 没有交叠，可以使用二分查找快速找到 key 所在的 Level 以及 SSTable）</li></ol><p>每个 SSTable 在查找之前通过 bloom filter 快速判断数据是否存在于当前文件，减少不必要的 IO。  RocksDB 为 SST 中访问频繁的 data blocks 设置了一个读缓存结构 Block cache，并提供了两种开箱即用的实现 LRUCache 和 ClockCache 。</p><p><img src="/posts/41900/aa15606705994a08c8dc307b386b133bf25f1d0d.png@1256w_562h_!web-article-pic.avif" alt></p><ol><li>写操作会先写 WAL 文件，保证数据不丢失；</li><li>完成 WAL 写入后，将数据写入到 内存中的 active memtable 中（为了保证有序性，RocksDB 使用跳表数据结构实现 memtable）；</li><li>然后等 memtable 数据达到一定规模时，会转变成 immutable memtable，同时生成新的 memtable 提供服务；</li><li>在满足落盘条件后，immutable memtable 会被合并刷入到硬盘的 SST 中；</li></ol><p>顺带一提，默认情况下 RocksDB 中的写磁盘行为都是异步写，仅仅把数据写进了操作系统的缓存区就返回了（pageCache），而这些数据被写进磁盘是一个异步的过程。异步写的吞吐率是同步写的一千多倍。<strong>异步写的缺点是机器或者操作系统崩溃时可能丢掉最近一批写请求发出的由操作系统缓存的数据，但是 RocksDB 自身崩溃并不会导致数据丢失。而机器或者操作系统崩溃的概率比较低，所以大部分情况下可以认为异步写是安全的</strong>。</p><h4 id="LSM-树设计思想总结"><a href="#LSM-树设计思想总结" class="headerlink" title="LSM 树设计思想总结"></a>LSM 树设计思想总结</h4><p>LSM 树将对磁盘的随机写入转化为了磁盘友好型的顺序写（无论机械磁盘还是 SSD，随机读写都要远远慢于顺序读写），从而大大提高了写性能。</p><p>那么是怎么转化的呢？核心就是在内存中维护一个有序的内存表（memtable），当内存表大于阈值的时候批量刷入磁盘，生成最新的 SSTable 文件。因为本身 memtable 已经维护了按键排序的键值对，所以这个步骤可以高效地完成。</p><p><strong>写入内存表时先将数据写入 WAL 日志，用以在发生故障时，通过重放 WAL 恢复内存中的数据，保证数据库的数据一致性。</strong></p><p>在这种追加（Append-only）写入模式下，删除数据变成了对数据添加删除标记，更新数据变成了写入新的 value，在同一个时间数据库中会存在同个 key 的新值和旧值。这种影响被称之为 <strong>空间放大（Space Amplification）</strong>。随着数据的写入，底层的 SSTable 文件也会越来越多。</p><p>读请求在这个模式下，变成了先在内存中寻找关键字，如果找不到则在磁盘中按照新-&gt; 旧查找 SSTable 文件。<strong>为了优化这种访问模式的读性能，存储引擎通常使用常见的针对读的优化策略，比如使用额外的 Bloom Filter、读 Cache</strong>。</p><p>这种需要多次读取的过程（或者说影响）被称之为<strong>读放大（Read Amplification）</strong>。很显然，读放大会影响 LSM 树的读性能。为了优化读性能（读放大），同时优化存储空间（空间放大），LSM 树通过在运行合并和压缩过程减少 SSTable 文件数量，删除<strong>无效（被删除或者被覆盖）</strong> 的旧值。这一过程被称之为 <strong>compaction</strong>。</p><p>但是 compaction 也会一些影响，在数据库的生命周期中每次的数据写入实际上会造成多次的磁盘写入。这种影响被称之为写放大（Write Amplification）。在写入繁重的应用程序中，性能瓶颈可能是数据库可以写入磁盘的速度。在这种情况下，写放大会导致直接的性能代价：存储引擎写入磁盘的次数越多，可用磁盘带宽内的每秒写入次数越少。</p><p>这也是我认为 LSM 引擎存储的一个缺点，就是<strong>压缩过程有可能会干扰到正在进行的读写请求</strong>。尽管存储引擎尝试逐步执行压缩而不影响并发访问，但是磁盘资源有限，所以很容易发生请求需要等待磁盘完成昂贵的压缩操作。对吞吐量和平均响应时间的影响通常很小，但是如果是高百分位情况下，有时就会出现查询响应较长的情况。</p><p>具体提到的 RocksDB 实现中，写放大、读放大、空间放大，这三者就像 CAP 定理一样，无法同时达到最优。为此 RocksDB 暴露了很多参数来让使用者进行调优，以适应更多的应用场景。这其中很大一部分工作是在写放大、读放大和空间放大这三个放大因子之间做好 trade off。</p><h3 id="2-9LSM-树-vs-B-树"><a href="#2-9LSM-树-vs-B-树" class="headerlink" title="2.9LSM 树 vs B+ 树"></a>2.9LSM 树 vs B+ 树</h3><h4 id="2-9-1设计理念不同"><a href="#2-9-1设计理念不同" class="headerlink" title="2.9.1设计理念不同"></a>2.9.1设计理念不同</h4><p>虽然像 LSM 树一样，B+ 树保持按键排序的键值对（这允许高效的键值查找和范围查询），但是两者设计理念完全不同。</p><ul><li>LSM 树将数据库分解为可变大小的段，通常是几兆字节或更大的大小，并且总是按顺序编写段。</li><li>相比之下，B+ 树将数据库分解成固定大小的块或页面，传统上大小为 4KB（有时会更大），并且一次只能读取或写入一个页面。这种设计更接近于底层硬件，因为磁盘也被安排在固定大小的块中。</li></ul><h4 id="2-9-2数据的更新和删除方面"><a href="#2-9-2数据的更新和删除方面" class="headerlink" title="2.9.2数据的更新和删除方面"></a>2.9.2数据的更新和删除方面</h4><ul><li>B+树可以做到原地更新和删除（in-place update），这种方式对<strong>数据库事务支持更加友好</strong>，因为一个 key 只会出现一个 Page 页里面；</li><li>但由于 LSM 树只能追加写（out-place update），并且在 L0 层的 SSTable 中会重叠，所以对事务支持较弱，只能在 compaction 的时候进行真正地更新和删除。</li></ul><h4 id="2-9-3性能方面"><a href="#2-9-3性能方面" class="headerlink" title="2.9.3性能方面"></a>2.9.3性能方面</h4><ul><li>LSM 树的优点是支持高吞吐的写（可认为是 O(1)），这个特点在分布式系统上更为看重，当然针对读取普通的 LSM 树结构，读取是 O(n) 的复杂度，在使用索引或者缓存优化后的也可以达到 O（logN）的复杂度。</li><li>B+ 树的优点是支持高效的读（稳定的 O(logN)），但是在大规模的写请求下（复杂度 O(LogN)），效率会变得比较低，因为随着 insert 的操作，为了维护树结构，节点会不断的分裂和合并。操作磁盘的随机读写概率会变大，故导致性能降低。</li></ul><p><strong>通常</strong>来说，我们会说，LSM 树写性能会优于 B 树，而 B 树的读性能会优于 LSM 树。但是请不要忽略 LSM 树写放大的影响，在进行性能判定是要更辩证的思考。<br><img src="/posts/41900/image-20231007214536961.png" alt></p><h2 id="第三章-查询处理"><a href="#第三章-查询处理" class="headerlink" title="第三章 查询处理"></a>第三章 查询处理</h2><h3 id="3-1查询处理概述"><a href="#3-1查询处理概述" class="headerlink" title="3.1查询处理概述"></a>3.1查询处理概述</h3><p><img src="/posts/41900/4-1.png" alt="图 4-1 关系数据库查询处理流程"></p><p>关系数据库管理系统查询处理可以分为4个阶段：查询分析、查询检查、查询优化和查询执行。</p><ol><li><strong>查询分析</strong> ：对用户提交的查询语句进行扫描、词法分析和语法分析，判断是否符合SQL语法规则，若没有语法错误，就会生成一棵语法树。</li><li><strong>查询检查</strong> ：对语法树进行查询检查，首先根据数据字典中的模式信息检查语句中的数据对象，如关系名、属性名是否存在和有效；还要根据数据字典中的用户权限和完整性约束信息对用户的存取权限进行检查。若通过检查，则将数据库对象的外部名称转换成内部表示。这个过程实际上是对语法树进行语义解析的过程，最后语法树被解析为一个具有特定语义的关系代数表达式，其表示形式仍然是一棵树，称为查询树。</li><li><strong>查询优化</strong> ：每个查询都会有多种可供选择的执行策略和操作算法，查询优化就是选择一个能高效执行的查询处理策略。一般将查询优化分为代数优化和物理优化。代数优化指对关系代数表达式进行等价变换，改变代数表达式中操作的次序和组合，使查询执行更高效；物理优化则是指存取路径和底层操作算法的选择，选择依据可以是基于规则、代价、语义的。查询优化之后，形成查询计划。</li><li><strong>查询执行</strong> ：查询计划由一系列操作符构成，每一个操作符实现计划中的一步。查询执行阶段，系统将按照查询计划逐步执行相应的操作序列，得到最终的查询结果。</li></ol><h3 id="3-2-选择运算"><a href="#3-2-选择运算" class="headerlink" title="3.2 选择运算"></a>3.2 选择运算</h3><p>选择操作的典型实现方法有<strong>全表扫描法</strong>和<strong>索引扫描法</strong>。</p><h4 id="3-2-1-全表扫描法"><a href="#3-2-1-全表扫描法" class="headerlink" title="3.2.1 全表扫描法"></a>3.2.1 全表扫描法</h4><p>对查询的基本表顺序扫描，逐一检查每个元组是否满足选择条件，把满足条件的元组作为结果输出。</p><p>假设可以使用的内存为M块，全表扫描的算法思想如下：</p><ol><li>按物理次序读表T的M块到内存；</li><li>检查内存的每个元组t，如果t满足选择条件，则输出t；</li><li>如果表T还有其他块未被处理，重复(1)和(2)。</li></ol><p>这种方法适合小表，对规模大的表要进行顺序扫描，当选择率（即满足条件的元组数占全表比例）较低时，此算法效率很低。</p><h4 id="3-2-2-索引扫描法"><a href="#3-2-2-索引扫描法" class="headerlink" title="3.2.2 索引扫描法"></a>3.2.2 索引扫描法</h4><p>当选择条件中的属性上有索引（例如B+树索引或Hash索引）时，通过索引先找到满足条件的元组指针，再通过元组指针直接在要查询的表中找到元组。</p><p><strong>［例1 ］</strong> 等值查询：<code>select * from t1 where col＝常量</code>，并且col上有索引（B+树索引或Hash索引均可） ，则使用索引得到col为该常量元组的指针，通过元组指针在表t1中检索到结果。</p><p><strong>［例2 ］</strong> 范围查询： <code>select * from t1 where col &gt; 常量</code>，并且col上有B+树索引，使用B+树索引找到col＝常量的索引项，以此为入口点在B+树的顺序集上得到col &gt; 常量的所有元组指针， 通过这些元组指针到t1表中检索满足条件的元组。</p><p><strong>［例 3 ］</strong> 合取条件查询：<code>select * from t1 where col1＝常量a AND col2 &gt;常量b</code>，如果 col1和 col1上有组合索引（col1,col2），则利用此组合索引进行查询筛选；否则，如果 col1和 col2上分别有索引，则：</p><p>方法一：分别利用各自索引查找到满足部分条件的一组元组指针，求这2组指针的交集，再到t1表中检索得到结果。</p><p>方法二：只利用索引查找到满足该部分条件的一组元组指针，通过这些元组指针到t1表中检索，对得到的元组检查另一些选择条件是否满足，把满足条件的元组作为结果输出。</p><p>一般情况下，当选择率较低时，基于索引的选择算法要优于全表扫描。但在某些情况下，如选择率较高、或者要查找的元组均匀分散在表中，这时索引扫描法的性能可能还不如全表扫描法，因为还需要考虑扫描索引带来的额外开销。</p><h3 id="3-3-排序运算"><a href="#3-3-排序运算" class="headerlink" title="3.3 排序运算"></a>3.3 排序运算</h3><p>排序是数据库中的一个基本功能，用户通过Order by子句即能达到将指定的结果集排序的目的，而且不仅仅是Order by子句，Group by、Distinct等子句都会隐含使用排序操作。</p><h4 id="3-3-1-利用索引避免排序"><a href="#3-3-1-利用索引避免排序" class="headerlink" title="3.3.1 利用索引避免排序"></a>3.3.1 利用索引避免排序</h4><p>为了优化查询语句的排序性能，最好的情况是避免排序，合理利用索引是一个不错的方法。因为一些索引本身也是有序的，如B+树，如果在需要排序的字段上面建立了合适的索引，那么就可以跳过排序过程，提高查询速度。</p><p>例如：假设t1表存在B+树索引key1(key_part1, key_part2)，则以下查询可以利用索引来避免排序：</p><pre class="line-numbers language-sql"><code class="language-sql">    <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t1 <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> key_part1<span class="token punctuation">,</span> key_part2<span class="token punctuation">;</span>    <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t1 <span class="token keyword">WHERE</span> key_part1 <span class="token operator">=</span> constant <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> key_part2<span class="token punctuation">;</span>    <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t1 <span class="token keyword">WHERE</span> key_part1 <span class="token operator">></span> constant <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> key_part1<span class="token punctuation">;</span>    <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t1 <span class="token keyword">WHERE</span> key_part1 <span class="token operator">=</span> constant1 <span class="token operator">AND</span> key_part2 <span class="token operator">></span> constant2 <span class="token keyword">ORDER</span> <span class="token keyword">BY</span>     key_part2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果排序字段不在索引中，或者分别存在于多个索引中，或者排序键的字段顺序与组合索引中的字段顺序不一致，则无法利用索引来避免排序。</p><h4 id="3-3-2-数据库内部排序方法"><a href="#3-3-2-数据库内部排序方法" class="headerlink" title="3.3.2 数据库内部排序方法"></a>3.3.2 数据库内部排序方法</h4><p>对于不能利用索引来避免排序的查询，DBMS必须自己实现排序功能以满足用户需求。实现排序的算法可以是文件排序，也可以是内存排序，具体要由排序缓冲区（sort buffer）的大小和结果集的大小来确定。</p><p>数据库内部排序的实现主要涉及3种经典排序算法：快速排序、归并排序和堆排序。对于不能全部放在内存中的关系，需要引入外排序，最常用的就是外部归并排序。外部归并排序分为两个阶段：Phase1 – Sorting，对主存中的数据块进行排序，然后将排序后的数据块写回磁盘；Phase2 – Merging，将已排序的子文件合并成一个较大的文件。</p><h5 id="3-3-2-1-常规排序法"><a href="#3-3-2-1-常规排序法" class="headerlink" title="3.3.2.1 常规排序法"></a>3.3.2.1 常规排序法</h5><p>一般情况下通用的常规排序方法如下：</p><ul><li>(1) 从表t中获取满足WHERE条件的记录；</li><li>(2) 对于每条记录，将记录的主键+排序键(id,colp)取出放入sort buffer；</li><li>(3) 如果sort buffer可以存放所有满足条件的(id,colp)对，则进行排序；否则sort buffer满后，进行排序并固化到临时文件中。（排序算法采用快速排序）；</li><li>(4) 若排序中产生了临时文件，需要利用归并排序算法，保证临时文件中记录是有序的；</li><li>(5) 循环执行上述过程，直到所有满足条件的记录全部参与排序；</li><li>(6) 扫描排好序的(id,colp)对，并利用id去取SELECT需要返回的目标列；</li><li>(7) 将获取的结果集返回给用户。</li></ul><p>从上述流程来看，是否使用文件排序主要看sort buffer是否能容下需要排序的(id,colp)对。此外一次排序涉及两次I/O：第一次是取(id,colp)，第二次是取目标列。由于第一次返回的结果集是按colp排序，因此id是乱序的。通过乱序的id去取目标列时，会产生大量的随机I/O。因此，可以考虑对第二次I/O进行优化，即在取数据之前首先将id排序并放入缓冲区，然后按id顺序去取记录，从而将随机I/O转为顺序I/O。</p><p>为了避免第二次I/O，还可以考虑一次性取出(id,colp,目标列)，当然这样对缓冲区的需求会更大。</p><h5 id="3-3-2-2-堆排序法"><a href="#3-3-2-2-堆排序法" class="headerlink" title="3.3.2.2 堆排序法"></a>3.3.2.2 堆排序法</h5><p>堆排序法适用于形如”order by limit m，n”的这类排序问题，即跳过m条数据，提取n条数据。这种情况下，虽然仍然需要所有元组参与排序，但是只需要m+n个元组的sort buffer空间即可，对于m和n很小的场景，基本不会出现因sort buffer不够而需要使用临时文件进行归并排序的问题。对于升序，采用大顶堆，最终堆中的元素组成了最小的n个元素；对于降序，则采用小顶堆，最终堆中的元素组成了最大的n的元素。</p><h3 id="3-4-连接运算"><a href="#3-4-连接运算" class="headerlink" title="3.4 连接运算"></a>3.4 连接运算</h3><p>连接操作是查询处理中最常用最耗时的操作之一。主要有4种实现方法：嵌套循环、排序-合并、索引连接和散列连接。</p><p>首先引入2个术语：外关系（outer relation）和内关系（inner relation）。外关系是左侧数据集，内关系是右侧数据集。例如：对于A JOIN B，A为外关系，B为内关系。多数情况下，A JOIN B 的成本跟 B JOIN A 的成本是不同的。假定外关系有m个元组，占M个页，内关系有n个元组，占N个页。</p><h4 id="3-4-1-嵌套循环连接"><a href="#3-4-1-嵌套循环连接" class="headerlink" title="3.4.1 嵌套循环连接"></a>3.4.1 嵌套循环连接</h4><p>嵌套循环连接是最简单且通用的连接算法，其执行步骤为：针对外关系的每一行，查看内关系里的所有行来寻找匹配的行。这是一个双重循环，时间复杂度为O(n*m)。</p><p><img src="/posts/41900/4-2.png" alt="图 4-2 嵌套循环连接示意图"></p><p>在磁盘 I/O 方面， 针对外关系的每一行，内部循环需要从内关系读取m行。这个算法需要从磁盘读取 n+ n*m 行。但是，如果外关系足够小，我们可以把它先读入内存，那么就只需要读取 n+m 行。按照这个思路，外关系就应该选更小的那个关系，因为它有更大的机会装入内存。</p><p>当然，内关系如果可以由索引代替，对磁盘 I/O 将更有利。</p><p>当外关系太大无法装入内存时，采用块嵌套循环连接方式，对磁盘 I/O 更加有利。其基本思路是将逐行读取数据，改为以页（块）为单位读取数据。算法如下：</p><ul><li>(1) 从磁盘读取外关系的一个数据页到内存；</li><li>(2) 从磁盘依次读取内关系的所有数据页到内存，与内存中外关系的数据进行比较，保留匹配的结果；</li><li>(3) 从磁盘读取外关系的下一个数据页，并继续执行(2)，直至外关系的最后一个页面。</li></ul><p>与嵌套循环连接算法相比，块嵌套循环连接算法的时间复杂度没有变化，但降低了磁盘访问开销，变为M+M*N。其中，M为外关系的页数，N为内关系的页数。</p><h4 id="3-4-2-索引嵌套循环连接"><a href="#3-4-2-索引嵌套循环连接" class="headerlink" title="3.4.2 索引嵌套循环连接"></a>3.4.2 索引嵌套循环连接</h4><p>在嵌套循环连接中，若在内关系的连接属性上有索引，则可以用索引查找替代文件扫描。对于外关系的每一个元组，可以利用索引查找内关系中与该元组满足连接条件的元组。这种连接方法称为索引嵌套循环连接，它可以在已有索引或者为了计算该连接而专门建立临时索引的情况下使用。</p><p>索引嵌套循环连接的代价可以如下计算。对于外关系的每一个元组，需要先在内关系的索引上进行查找，再检索相关元组。在最坏的情况下，缓冲区只能容纳外关系的一页和索引的一页。此时，读取外关系需M次I/O操作，这里的M指外关系的数据页数；对于外关系中的每个元组，在内关系上进行索引查找，假设索引查找带来的I/O开销为C，则总的I/O开销为：M+(m×C)，其中m为外关系的元组数。</p><p>这个代价计算公式表明，如果两个关系上均有索引时， 一般把元组较少的关系作外关系时效果较好。</p><p><img src="/posts/41900/4-3.png" alt="图4-3 索引连接示意图"></p><h4 id="3-4-3-排序-合并连接"><a href="#3-4-3-排序-合并连接" class="headerlink" title="3.4.3 排序-合并连接"></a>3.4.3 排序-合并连接</h4><p>排序-合并连接算法常用于等值连接，尤其适合参与连接的表已经排好序的情况。其方法如下：</p><p>第一步：如果参与连接的表没有排好序，则根据连接属性排序；</p><p>第二步：sorted_merge：</p><ul><li>(1) 初始化两个指针，分别指向两个关系的第一个元组；</li><li>(2) 比较两个关系的当前元组（当前元组=指针指向的元组）；</li><li>(3) 如果匹配，保留匹配的结果，两个指针均后移一个位置；</li><li>(4) 如果不匹配，就将指向较小元组的那个指针后移一个位置；</li><li>(5) 重复步骤(2)、(3)、(4)，直到其中一个关系的指针移动到末尾。</li></ul><p><img src="/posts/41900/4-4.png" alt="图4-4 排序-合并连接示意图"></p><p>因为两个关系都是已排序的，不需要”回头去找”，所以此方法的时间复杂度为O(n+m)。如果两个关系还需要排序，则还要考虑排序的成本：O(n*Log(n) + m*Log(m))。</p><p>很多情况下，参与连接的数据集已经排好序了，比如：表内部就是有序的，或者参与连接的是查询中已经排好序的中间结果，那么选用排序-合并算法是比较合适的。</p><h4 id="3-4-4-散列连接"><a href="#3-4-4-散列连接" class="headerlink" title="3.4.4 散列连接"></a>3.4.4 散列连接</h4><p>散列连接算法也是适用于等值连接的算法。</p><p>散列连接分成两个阶段：第一步，划分阶段，为较小的关系建立hash表，将连接属性作为hash码；第二步，试探阶段，对另一张表的连接属性用同样的hash函数进行散列，将其与相应桶中匹配的元组连接起来。</p><p>本算法要求内存足够大，小表的hash表如果能全部放进内存，则效果较好。</p><p><img src="/posts/41900/4-5.png" alt="图 4-5 散列连接示意图"></p><p>在时间复杂度方面需要做些假设来简化问题：</p><ul><li>(1) 内关系被划分成 X 个散列桶。散列函数几乎均匀地分布每个关系内数据的散列值，即散列桶大小一致。</li><li>(2) 外关系的元素与散列桶内所有元素的匹配，成本是散列桶内元素的数量。</li></ul><p>算法的开销包括创建散列表的成本(m) +散列函数的计算开销 * n + (m/X) * n。如果散列函数创建的散列桶的规模足够小，则算法复杂度为O(m+n)。</p><h4 id="3-4-5-连接算法的选择"><a href="#3-4-5-连接算法的选择" class="headerlink" title="3.4.5 连接算法的选择"></a>3.4.5 连接算法的选择</h4><p>具体情况下，应该选择以上哪种连接算法，有许多因素要考量：</p><ul><li>(1) 空闲内存：没有足够的内存就无法使用内存中的散列连接。</li><li>(2) 两个数据集的大小。比如，如果一个大表连接一个很小的表，那么嵌套循环连接就比散列连接快，因为后者有创建散列表的高昂成本；如果两个表都非常大，那么嵌套循环连接的CPU成本就很高。</li><li>(3) 是否有索引：如果连接属性上有两个B+树索引的话，合并连接会是很好的选择。</li><li>(4) 关系是否已经排序：这时候合并连接是最好的选择。</li><li>(5) 结果是否需要排序：即使参与连接的是未排序的数据集，也可以考虑使用成本较高的合并连接（带排序的），比如得到排序的结果后，我们还可以将它用于另一个合并联接，或者查询中存在ORDER BY/GROUP BY/DISTINCT等操作符，它们隐式或显式地要求一个排序结果。</li><li>(6) 连接的类型：是等值连接？还是内连接？外连接？笛卡尔积？或者自连接？有些连接算法在某些情况下是不适用的。</li><li>(7) 数据的分布：如果连接条件的数据是倾斜的，用散列连接不是好的选择，因为散列函数将产生分布极不均匀的散列桶。</li><li>(8) 多表连接：连接顺序的选择很重要。</li></ul><p>另外，还可能考虑实现方式问题，比如连接操作使用多线程或多进程的代价考量。因此，DBMS需要通过查询优化器来选择恰当的执行计划。</p><h3 id="3-5-表达式计算"><a href="#3-5-表达式计算" class="headerlink" title="3.5 表达式计算"></a>3.5 表达式计算</h3><p>如何计算包含多个运算步骤的关系代数表达式？有两种方法：物化计算和流水线计算。</p><h4 id="3-5-1-物化计算"><a href="#3-5-1-物化计算" class="headerlink" title="3.5.1 物化计算"></a>3.5.1 物化计算</h4><p>物化计算以适当的顺序每次执行一次操作；每次计算的结果被物化到一个临时关系以备后用。其缺点为：需要构造临时关系，而且这些临时关系必须写到磁盘上（除非很小）。</p><p>表达式的执行顺序可以依据表达式在查询树中的层次而定，从树的底部开始。</p><p><img src="/posts/41900/4-6.png" alt="图4-6 一棵查询树"></p><p>如图所示，此例中只有一个底层运算：department上的选择运算，底层运算的输入是数据库中的关系department。用前面提到的算法执行树中的运算，并将结果存储在临时关系中。在树的高一层中，使用这个临时关系来进行计算，这时输入的要么是临时关系，要么是一个数据库关系。通过重复这一过程，最终可以计算位于树的根节点的运算，从而得到表达式的最终结果。</p><p>由于运算的每个中间结果会被物化用于下一层的运算，此方法称为物化计算。物化计算的代价不仅是那些所涉及的运算代价的总和，还可能包括将中间结果写到磁盘的代价。</p><h4 id="3-5-2-流水线计算"><a href="#3-5-2-流水线计算" class="headerlink" title="3.5.2 流水线计算"></a>3.5.2 流水线计算</h4><p>流水线计算可同时计算多个运算，运算的结果传递给下一个，而不必保存临时关系。这种方法通过减少查询执行中产生的临时文件的数量，来提高查询执行的效率。</p><p>比如在上一章里面，可以将选择、连接操作和投影操作组合起来，放入一条流水线，选择得到一个结果传给连接、连接产生一个结果元组马上传送给投影操作去做处理，避免中间结果的创建，从而直接产生最终结果。</p><p>创建一个操作的流水线可以带来的好处是：</p><ul><li>(1) 消除读和写临时关系的代价，从而减少查询计算代价。</li><li>(2) 流水线产生查询结果，边生成边输出给用户，提高响应时间。</li></ul><p>流水线可按两种方式来执行：</p><ul><li>方式一：需求驱动方式，在操作树的顶端的将数据往上拉。</li><li>方式二：生产者驱动方式，将数据从操作树的底层往上推。</li></ul><p>需求驱动的流水线方法比生产者驱动的流水线方法使用更广泛，因为它更容易实现。但流水线技术限制了能实现操作的可用算法。例如，若连接运算的左端输入来自流水线，则不能使用排序-合并连接，但可以用索引连接算法。由于这些限制，并非所有情况下流水线方法的代价都小于物化方法。</p><h2 id="第四章-查询优化"><a href="#第四章-查询优化" class="headerlink" title="第四章 查询优化"></a>第四章 查询优化</h2><h3 id="4-1-查询优化概述"><a href="#4-1-查询优化概述" class="headerlink" title="4.1 查询优化概述"></a>4.1 查询优化概述</h3><p>查询优化即求解给定查询语句的高效执行计划的过程。它既是关系数据库管理系统实现的关键技术，又是关系系统的优点所在。由DBMS进行查询优化的好处在于：查询优化的优点不仅在于用户不必考虑如何最好的表达查询以获得较高的效率，而且在于系统可以比用户程序的”优化”做得更好。</p><p>查询计划，从形式上看是一颗二叉树，树叶是每个单表对象，两个树叶的父节点是一个连接操作符连接后的中间结果（另外还有一些其他节点如排序等也可以作为中间结果），这个结果是一个临时关系，这样直至根节点。</p><p>从一个查询计划看，涉及的主要”关系节点”包括：</p><ul><li>单表节点：考虑单表的获取方式（全表扫描，或索引获取，或索引定位再I/O到数据块获取数据）。这是一个物理存储到内存解析成逻辑字段的过程。</li><li>两表节点：考虑两表以何种方式连接，代价有多大，连接路径有哪些等。表示内存中的元组如何进行元组间的连接。此时，元组通常已经存在于内存中。这是一个完整用户语义的逻辑操作，但只是局部操作，只涉及两个具体的关系。完成用户全部语义，需要配合多表的连接顺序的操作。</li><li>多表中间节点：考虑多表连接顺序如何构成代价最少的”执行计划”。决定连接执行的顺序。</li></ul><p>查询优化的总目标是选择有效的策略，求得给定关系表达式的值，使得查询代价较小。因为查询优化的搜索空间有时非常大，实际系统选择的策略不一定是最优的，而是较优的。</p><p>查询优化主要包括逻辑优化和物理优化。其中，逻辑优化又可包含语法级查询优化、基于规则的优化等；而物理优化主要指基于代价的优化。语法级优化是基于语法的等价转换；基于规则的优化（如依据关系代数的规则或依据经验的规则等）具有操作简单且能快速确定执行方式的优点，但这种方法只是排除了一部分不好的可能；基于代价的优化是在查询计划生成过程中，计算每条存取路径进行量化比较，从而得到开销最小的情况，但如果组合情况多则开销的判断时间就很多。查询优化器的实现，多是这两种优化策略的组合使用。</p><h3 id="4-2-逻辑优化"><a href="#4-2-逻辑优化" class="headerlink" title="4.2 逻辑优化"></a>4.2 逻辑优化</h3><p>查询优化器在逻辑优化阶段主要解决的问题是：如何找出SQL语句的等价变换形式，使SQL执行更高效。</p><h4 id="4-2-1代数优化"><a href="#4-2-1代数优化" class="headerlink" title="4.2.1代数优化"></a>4.2.1代数优化</h4><p>代数优化是基于关系代数等价变换规则的优化方法。</p><p>代数优化策略是通过对关系代数表达式的等价变换来提高查询效率。所谓关系代数表达式的等价是指用相同的关系代替两个表达式中相应的关系所得到的结果是相同的。两个关系表达式E1和E2是等价的。</p><h5 id="4-2-1-1-关系代数表达式等价变换规则"><a href="#4-2-1-1-关系代数表达式等价变换规则" class="headerlink" title="4.2.1.1 关系代数表达式等价变换规则"></a>4.2.1.1 关系代数表达式等价变换规则</h5><p>常用的关系代数等价变换规则如下：</p><ol><li><strong>连接、笛卡尔积的交换律</strong></li></ol><p>设E1和E2为关系代数表达式，F为连接运算条件，则有：</p><p> E1×E2 ≡ E2×E1</p><p> E1⋈E2 ≡ E2⋈E1</p><p> <img src="/posts/41900/5.2.1.1-1.png" alt="5.2.1.1-1"> ≡ <img src="/posts/41900/5.2.1.1-2.png" alt="5.2.1.1-2"></p><p>对于连接和笛卡尔积运算，可以交换前后位置，其结果不变。例如，两表连接算法中有嵌套循环连接算法，对外表和内表有要求，外表尽可能小则有利于做”基于块的嵌套循环连接”，所以通过交换律可以将元组少的表作为外表。</p><ol><li><strong>连接、笛卡尔积结合律</strong></li></ol><p>设E1、E2、E3为关系代数表达式，F1、F2为连接运算条件。则有：</p><p> (E1×E2)×E3 ≡ E1×(E2×E3)</p><p> (E1⋈E2)⋈E3 ≡ E1⋈(E2⋈E3)</p><p> <img src="/posts/41900/5.2.1.1-3.png" alt="5.2.1.1-3"> ≡ <img src="/posts/41900/5.2.1.1-4.png" alt="5.2.1.1-4"></p><p>对于连接、笛卡尔积运算，如果新的结合有利于减少中间关系的大小，则可以优先处理。</p><ol><li><strong>投影的串接定律</strong></li></ol><p>设E为关系代数表达式，Ai（i=1,2,3,…,n），Bj（j=1,2,3,…,m）是属性名，且{A1,A2,…,An}为{B1,B2,…,Bm}的子集。则有：</p><p> ∏A1,A2,…,An(∏B1,B2,…,Bm(E)) ≡ ∏A1,A2,…,An (E)</p><p>在同一个关系上，只需做一次投影运算，且一次投影时选择多列同时完成。所以许多数据库优化引擎会为一个关系收集齐该关系上的所有列，即目标列和WHERE、GROUP BY等子句中涉及到的所有该关系的列。</p><ol start="2"><li><strong>选择的串接律</strong></li></ol><p>设E为关系代数表达式，F1、F2为选择条件。则有：</p><p> σF1(σF2(E)) ≡ σF1∧F2(E)</p><p>此变换规则对于优化的意义在于：选择条件可以合并，使得一次选择运算就可检查全部条件，而不必多次过滤元组，所以可以把同层的合取条件收集在一起，统一进行判断。</p><ol start="3"><li><strong>选择和投影的交换律</strong></li></ol><p>设E为关系代数表达式，F为选择条件，Ai（i=1,2,3,…,n）是属性名。选择条件F只涉及属性A1,A2,…,An。则有：</p><p> σF(∏A1,A2,…,An (E)) ≡∏A1,A2,…,An(σF(E))</p><p>此变换规则对于优化的意义在于：先投影后选择可以改为先选择后投影，这对于以行为单位来存储关系的主流数据库而言，很有优化意义。按照这种存储方式，系统总是先获取元组，然后才能解析得到其中的列。</p><p>设E为关系代数表达式，F为选择条件，Ai（i=1,2,3…,n）是属性名，选择条件F中有不属于A1,A2,…,An的属性B1,B2,…,Bn。则有：</p><p> ∏A1,A2,…,An(σF(E)) ≡ ∏A1,A2,…,An(σF(∏A1,A2,…,An,B1,B2,…,Bm(E)))</p><p>此变换规则对于优化的意义在于：先选择后投影可以改为先做带有选择条件中的列的投影，然后选择，最后再完成最外层的投影。这样内层的选择和投影可以同时进行，不会增加过多的计算开销，但能减小中间结果集的规模。</p><ol start="4"><li><strong>选择与笛卡尔积的交换律</strong></li></ol><p>设E1、E2为关系代数表达式，F为选择条件，F中涉及的属性都是E1中的属性，则有：</p><p> σF(E1×E2) ≡ σF(E1)×E2</p><p>如果F=F1∧F2，且F1只涉及E1中的属性，F2只涉及E2中的属性，则有：</p><p> σF(E1×E2) ≡ σF1(E1)×σF2(E2)</p><p>此变换规则对于优化的意义在于：条件下推到相关的关系上，先做选择后做笛卡尔积运算，这样可以减小中间结果的大小。</p><ol start="5"><li><strong>选择与并的分配律</strong></li></ol><p>如果E1和E2有相同的属性名，且E= E1∪E2，则有：</p><p> σF(E1∪E2) ≡ σF(E1) ∪σF (E2)</p><p>此变换规则对于优化的意义在于：条件下推到相关的关系上，先选择后做并运算，可以减小每个关系输出结果的大小。</p><ol start="6"><li><strong>选择与差的分配律</strong></li></ol><p>如果E1­和E2有相同的属性名，则：</p><p> σF(E1－E2) ≡ σF(E1)－σF(E2)</p><p>此变换规则对于优化的意义在于：条件下推到相关的关系上，先选择后做差运算，可以减小每个关系输出结果的大小。</p><ol start="7"><li><strong>投影与笛卡尔积的交换律</strong></li></ol><p>设A1,A2,…,An是E1的属性，B1,B2,…,Bm是E2的属性，则有：</p><p> ∏A1,A2,…,An,B1,B2,…,Bm(E1×E2) ≡ ∏A1,A2,…,An(E1)×∏B1,B2,…,Bm(E2)</p><p>此变换规则对于优化的意义在于：先投影后做笛卡尔积，可减少做笛卡尔积前每个元组的长度，使得计算后得到的新元组的长度也变短。</p><ol start="8"><li><strong>投影与并的交换律</strong></li></ol><p>如果E1和E2有相同的属性名，则有：</p><p> ∏A1,A2,…,An (E1∪E2) ≡ ∏A1,A2,…,An (E1)∪∏A1,A2,…,An (E2)</p><p>此变换规则对于优化的意义在于：先投影后做并运算，可减少做并运算前每个元组的长度。</p><h5 id="4-2-1-2-针对不同运算符的优化规则"><a href="#4-2-1-2-针对不同运算符的优化规则" class="headerlink" title="4.2.1.2 针对不同运算符的优化规则"></a>4.2.1.2 针对不同运算符的优化规则</h5><p>针对不同运算符的优化规则如表所示。</p><p>运算符主导的优化:<br><img src="/posts/41900/image-20231003165105278.png" alt></p><ol><li>如WHERE A.a=B.b AND B.b=C.c可以合并为={A.a,B.b,C.c}而不是两个等式={A.a,B.b}和={B.b,C.c}。</li><li>如WHERE A.a=3 OR A.b&gt;8,如果A.a、A.b列上分别有索引，也许SELECT * FROM A WHERE A.a=3 UNION SELECT * FROM A WHERE A.b&gt;8可以分别利用各自的索引提高查询效率。</li></ol><p>选择下推到集合的运算</p><table><thead><tr><th>初始式</th><th>优化后的等价表达式</th><th></th><th></th></tr></thead><tbody><tr><td>等价表达式一</td><td>等价表达式二</td><td>等价表达式三</td><td></td></tr><tr><td>σA(R－S)</td><td>σA(R)－σA(S)</td><td>σA(R)－S</td><td></td></tr><tr><td>σA(R∪S)</td><td>σA(R)∪σA(S)</td><td></td><td></td></tr><tr><td>σA(R∩S)</td><td>σA(R)∩σA (S)</td><td>σA(R)∩S</td><td>R∩σA(S)</td></tr></tbody></table><p>投影下推到集合的运算</p><table><thead><tr><th><strong>初始式</strong></th><th><strong>优化后的等价表达式</strong></th></tr></thead><tbody><tr><td>∏A1,A2,…,An(R－S)</td><td>∏A1,A2,…,An(R)－ ∏A1,A2,…,An(S)</td></tr><tr><td>∏A1,A2,…,An(R∪S)</td><td>∏A1,A2,…,An(R) ∪∏A1,A2,…,An(S)</td></tr><tr><td>∏A1,A2,…,An(R∩S)</td><td>∏A1,A2,…,An(R) ∩∏A1,A2,…,An(S)</td></tr></tbody></table><h5 id="4-2-1-3-查询树启发式规则"><a href="#4-2-1-3-查询树启发式规则" class="headerlink" title="4.2.1.3 查询树启发式规则"></a>4.2.1.3 查询树启发式规则</h5><p>包括：</p><ol><li>选择运算应尽可能先做。</li><li>把投影运算和选择运算同时进行。如有若干投影和选择运算，并且它们都对同一个关系操作，则可以在扫描次关系的同时完成所有这些运算以避免重复扫描关系。</li><li>把投影同其前或后的双目运算结合起来，没有必要为了去掉某些字段而扫描一遍关系。</li><li>把某些选择同在它前面要执行的笛卡尔积结合起来称为一个连接运算。连接（特别是等值连接）运算比笛卡尔积性能高很多。</li><li>找出公共子表达式，将其计算结果缓存起来，避免重复计算。</li></ol><h4 id="4-2-2-语法级查询优化"><a href="#4-2-2-语法级查询优化" class="headerlink" title="4.2.2 语法级查询优化"></a>4.2.2 语法级查询优化</h4><p>语法级优化要解决的主要问题是找出SQL语句的等价变换形式，使得SQL执行更高效，包括：</p><ul><li>子句局部优化。如等价谓词重写、where和having条件简化等。</li><li>关联优化。如子查询优化、连接消除、视图重写等。</li><li>形式变化优化。如嵌套连接消除等。</li></ul><p>以下介绍几种常见的优化方法。</p><h5 id="4-2-2-1-子查询优化"><a href="#4-2-2-1-子查询优化" class="headerlink" title="4.2.2.1 子查询优化"></a>4.2.2.1 子查询优化</h5><p>早期的查询优化器对子查询都采用嵌套执行的方式，即对父查询中的每一行都执行一次子查询，这样效率很低，因此对其进行优化很有必要。例如，将子查询转为连接操作之后，有如下好处：</p><ul><li>子查询不用多次执行；</li><li>优化器可以根据统计信息来选择不同的连接方法和不同的连接顺序；</li><li>子查询中的连接条件、过滤条件分别变成了父查询的连接条件和过滤条件，优化器可以对这些条件进行下推，以提高执行效率。</li></ul><ol><li><strong>常见子查询优化技术</strong></li></ol><p><strong>(1)</strong> <strong>子查询合并</strong></p><p>在语义等价条件下，多个子查询可以合并成一个子查询，这样多次表扫描，多次连接减少为单次表扫描和单次连接。例如：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> t1<span class="token keyword">WHERE</span> <span class="token number">a1</span><span class="token operator">&lt;</span><span class="token number">10</span> <span class="token operator">AND</span> <span class="token punctuation">(</span><span class="token keyword">EXISTS</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token number">a2</span> <span class="token keyword">FROM</span> t2 <span class="token keyword">WHERE</span> t2<span class="token number">.a2</span><span class="token operator">&lt;</span><span class="token number">5</span> <span class="token operator">AND</span> t2<span class="token number">.b2</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">OR</span><span class="token keyword">EXISTS</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token number">a2</span> <span class="token keyword">FROM</span> t2 <span class="token keyword">WHERE</span> t2<span class="token number">.a2</span><span class="token operator">&lt;</span><span class="token number">5</span> <span class="token operator">AND</span> t2<span class="token number">.b2</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可优化为：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> t1<span class="token keyword">WHERE</span> <span class="token number">a1</span><span class="token operator">&lt;</span><span class="token number">10</span> <span class="token operator">AND</span> <span class="token punctuation">(</span><span class="token keyword">EXISTS</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token number">a2</span> <span class="token keyword">FROM</span> t2 <span class="token keyword">WHERE</span> t2<span class="token number">.a2</span><span class="token operator">&lt;</span><span class="token number">5</span> <span class="token operator">AND</span> <span class="token punctuation">(</span>t2<span class="token number">.b2</span><span class="token operator">=</span><span class="token number">1</span> <span class="token operator">OR</span> t2<span class="token number">.b2</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此例中，两个EXISTS子查询合并为一个子查询，查询条件也进行了合并。</p><p><strong>(2)</strong> <strong>子查询展开</strong></p><p>子查询展开又称子查询反嵌套，子查询上拉。实质是把某些子查询重写为等价的多表连接操作。带来好处是，有关的访问路径、连接方法和连接顺序可能被有效使用，使得查询语句的层次尽可能地减少。常见的IN / ANY / SOME / ALL / EXISTS依据情况转为半连接（SEMI JOIN）。例如：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> t1<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t2 <span class="token keyword">WHERE</span> t2<span class="token number">.a2</span><span class="token operator">></span><span class="token number">10</span><span class="token punctuation">)</span> v_t2<span class="token keyword">WHERE</span> t1<span class="token number">.a1</span><span class="token operator">&lt;</span><span class="token number">10</span> <span class="token operator">AND</span> v_t2<span class="token number">.a2</span><span class="token operator">&lt;</span><span class="token number">20</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可优化为：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> t1<span class="token punctuation">,</span> t2<span class="token keyword">WHERE</span> t1<span class="token number">.a1</span><span class="token operator">&lt;</span><span class="token number">10</span> <span class="token operator">AND</span> t2<span class="token number">.a2</span><span class="token operator">&lt;</span><span class="token number">20</span> <span class="token operator">AND</span> t2<span class="token number">.a2</span><span class="token operator">></span><span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此例中，原本的子查询变为了t1、t2表的连接操作，相当于把t2表从子查询中上拉了一层。</p><p>子查询展开是一种最常用的子查询优化技术，如果子查询是只包含选择、投影、连接操作的简单语句，没有聚集函数或者group子句，则可以上拉，前提是上拉后的结果不能带来多余元组，需遵循以下规则：</p><ul><li>如果上层查询结果没有重复（select包含主键），则可以展开子查询，并且展开后的查询的select子句前应加上distinct标志；</li><li>如果上层查询的select语句中有distinct标志，则可以直接子查询展开；</li><li>如果内层查询结果没有重复元组，则可以展开。</li></ul><p>子查询展开的具体步骤如下：</p><ol><li>将子查询和上层查询的from子句连接为同一个from子句，并且修改相应的运行参数；</li><li>将子查询的谓词符号进行相应修改（如IN修改为=ANY）；</li><li>将子查询的where条件作为一个整体与上层查询的where条件进行合并，并用and连接，从而保证新生成的谓词与原谓词的语义相同，成为一个整体。</li></ol><p><strong>(3)</strong> <strong>聚集子查询消除</strong></p><p>这种方法将聚集子查询的计算上推，使得子查询只需计算一次，并与父查询的部分或全表做左外连接。例如：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> t1<span class="token keyword">WHERE</span> t1<span class="token number">.a1</span> <span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">avg</span><span class="token punctuation">(</span>t2<span class="token number">.a2</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> t2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可优化为：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> t1<span class="token punctuation">.</span><span class="token operator">*</span><span class="token keyword">FROM</span> t1<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">avg</span><span class="token punctuation">(</span>t2<span class="token number">.a2</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> t2<span class="token punctuation">)</span> <span class="token keyword">as</span> tm<span class="token punctuation">(</span>avg_a2<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token keyword">WHERE</span> t1<span class="token number">.a1</span> ? tm<span class="token punctuation">.</span>avg_a2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>(4)</strong> <strong>其他</strong></p><p>此外还有利用窗口函数消除子查询、子查询推进等技术</p><ol start="2"><li><strong>针对不同类型子查询的优化方法</strong></li></ol><p><strong>(1) IN类型子查询</strong></p><p>IN类型有３种格式：</p><p>格式一：</p><pre class="line-numbers language-sql"><code class="language-sql">outer_expr <span class="token punctuation">[</span><span class="token operator">not</span><span class="token punctuation">]</span> <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token keyword">select</span> inner_expr <span class="token keyword">from</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">where</span> subquery_where<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>格式二：</p><pre class="line-numbers language-sql"><code class="language-sql">outer_expr <span class="token operator">=</span> <span class="token keyword">any</span> <span class="token punctuation">(</span><span class="token keyword">select</span> inner_expr <span class="token keyword">from</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">where</span> subquery_where<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>格式三：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token punctuation">(</span>oe_1<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> oe_N<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token operator">not</span><span class="token punctuation">]</span> <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token keyword">select</span> ie_1<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> ie_N <span class="token keyword">from</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">where</span> subquery_where<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于in类型子查询的优化，IN类型子查询优化的几种情况</p><p><img src="/posts/41900/5.2.2.1-1.png" alt="5.2.2.1-1"></p><p>情况一：outer_expr和inner_expr均为非NULL值。</p><p>优化后的表达式为：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">exists</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token number">1</span> <span class="token keyword">from</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">where</span> subquery_where <span class="token operator">and</span> outer_expr<span class="token operator">=</span>inner_expr<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>子查询优化需要满足2个条件：</p><ul><li><p>outer_expr和inner_expr不能为NULL；</p></li><li><p>不需要从结果为FALSE的子查询中区分NULL。</p></li></ul><p>情况二：outer_expr是非空值。</p><p>优化后的表达式为：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">exists</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token number">1</span> <span class="token keyword">from</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">where</span> subquery_where <span class="token operator">and</span><span class="token punctuation">(</span>outer_expr<span class="token operator">=</span>inner_expr <span class="token operator">or</span> inner_expr <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>情况三：outer_expr为空值。</p><p>则原表达式等价为：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token boolean">NULL</span> <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token keyword">select</span> inner_expr <span class="token keyword">FROM</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">where</span> subquery_where<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当outer_expr为空时，如果子查询结果为：</p><ul><li>NULL，select语句产生任意行数据；</li><li>FALSE，select语句不产生数据。</li></ul><p>对上面的等价形式，还有2点需说明：</p><ul><li>谓词IN等价于=ANY。如：以下2条SQL语句是等价的。</li></ul><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> col1 <span class="token keyword">from</span> t1 <span class="token keyword">where</span> col1 <span class="token operator">=</span><span class="token keyword">ANY</span> <span class="token punctuation">(</span><span class="token keyword">select</span> col1 <span class="token keyword">from</span> t2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">select</span> col1 <span class="token keyword">from</span> t1 <span class="token keyword">where</span> col1 <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">select</span> col1 <span class="token keyword">from</span> t2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>带有IN谓词的子查询，如果满足上述3种情况，可做等价变换，把外层条件下推到子查询中，变形为EXISTS类型的逻辑表达式判断。而EXISTS子查询可以被半连接算法实现优化。</li></ul><p><strong>(2) ALL/ANY/SOME类型子查询</strong></p><p>ALL/ANY/SOME子查询格式如下：</p><pre class="line-numbers language-sql"><code class="language-sql">outer_expr operator <span class="token keyword">ALL</span> <span class="token punctuation">(</span>subquery<span class="token punctuation">)</span>outer_expr operator <span class="token keyword">ANY</span> <span class="token punctuation">(</span>subquery<span class="token punctuation">)</span>outer_expr operator <span class="token keyword">SOME</span> <span class="token punctuation">(</span>subquery<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中，operator是操作符，可以是&gt;、&gt;=、=、&lt;、&lt;=中任何一个。其中，</p><ul><li>=ANY与IN含义相同，可采用IN子查询优化方法；</li><li>SOME与ANY含义相同；</li><li>NOT IN 与 &lt;&gt;ALL含义相同；</li></ul><p>如果子查询中没有group by子句，也没有聚集函数，则以下表达式可以使用聚集函数MAX/MIN做等价转换：</p><ul><li><code>val&gt;=ALL (select ...)</code> 等价变换为：<code>val&gt;= (select MAX...)</code></li><li><code>val&lt;=ALL (select ...)</code> 等价变换为：<code>val&lt;= (select MAX...)</code></li><li><code>val&gt;=ANY (select ...)</code> 等价变换为：<code>val&gt;= (select MIN...)</code></li><li><code>val&gt;=ANY (select ...)</code> 等价变换为：<code>val&gt;= (select MAX...)</code></li></ul><p><strong>(3) EXISTS类型子查询</strong></p><p>存在谓词子查询格式为：[NOT] EXISTS (subquery)</p><p>需要注意几点：</p><ul><li>EXISTS(subquery)值为TRUE/FALSE，不关心subquery返回的内容。</li><li>EXISTS(subquery)自身有”半连接”的语义，部分DBMS用半连接来实现它；NOT EXISTS通常会被标识为”反半连接”处理。</li><li>IN(subquery)等子查询可以被转换为EXISTS(subquery)格式。</li></ul><p>所谓半连接（Semi Join），是一种特殊的连接类型。如果用”t1.x semi= t2.y”来表示表T1和表T2做半连接，则其含义是：只要在表T2中找到一条记录满足t1.x=t2.y，则马上停止搜索表T2，并直接返回表T1中满足条件t1.x=t2.y的记录，因此半连接的执行效率高于普通的内连接。</p><h5 id="4-2-2-2-等价谓词重写"><a href="#4-2-2-2-等价谓词重写" class="headerlink" title="4.2.2.2 等价谓词重写"></a>4.2.2.2 等价谓词重写</h5><p>等价谓词重写包括：LIKE规则、BETWEEN-AND规则、IN转换OR规则、IN转换ANY规则、OR转换ANY规则、ALL/ANY转换集函数规则、NOT规则等，相关原理比较简单，有兴趣的同学可以自行查找相关查询重写规则。</p><h5 id="4-2-2-3-条件化简"><a href="#4-2-2-3-条件化简" class="headerlink" title="4.2.2.3 条件化简"></a>4.2.2.3 条件化简</h5><p>WHERE、HAVING和ON条件由许多表达式组成，而这些表达式在某些时候彼此间存在一定的联系。利用等式和不等式性质，可将WHERE、HAVING和ON条件简化，但不同数据库的实现可能不完全相同。</p><p>将WHERE、HAVING和ON条件简化的方式通常包括如下几个：</p><ol><li><p>去除表达式中冗余的括号：以减少语法分析时产生的AND和OR树的层次；</p></li><li><p>常量传递：对不同关系可使用条件分离后有效实施”选择下推”，从而减小中间关系的规模。如：</p><p> <code>col1=col2 AND col2=3</code> 可化简为：<code>col1=3 AND col2=3</code></p><p> 操作符=、&lt;、&gt;、&lt;=、&gt;=、&lt;&gt;、LIKE中的任何一个，在<code>col1&lt;操作符&gt;col2</code>条件中都会发生常量传递</p></li><li><p>消除死码。化简条件，将不必要的条件去除。如：</p><p> <code>WHERE (0&gt;1 AND s1=5)</code>, <code>0&gt;1</code>使得<code>AND</code>为恒假，去除即可。</p></li><li><p>表达式变换。化简条件（如反转关系操作符的操作数顺序），从而改变某些表的访问路径。如：-a=3可化简为a=-3，若a上有索引，则可利用。</p></li><li><p>不等式变换。化简条件，将不必要的重复条件去除。如：</p><p> <code>a&gt;10 AND b=6 AND a&gt;2</code> 可化简为：<code>a&gt;10 AND b=6</code>。</p></li><li><p>布尔表达式变换。包括：</p></li></ol><ul><li>谓词传递闭包。如：<code>a&gt;b AND b&gt;2</code>可推导出<code>a&gt;2</code>，减少a、b比较元组数。</li><li>任何一个布尔表达式都能被转换为一个等价的合取范式。一个合取项为假，则整个表达式为假。</li></ul><h3 id="4-3-物理优化"><a href="#4-3-物理优化" class="headerlink" title="4.3 物理优化"></a>4.3 物理优化</h3><p>代数优化改变查询语句中操作的次序和组合，但不涉及底层的存取路径。物理优化就是要选择高效合理的操作算法或存取路径，求得优化的查询计划，达到查询优化的目标。</p><p>查询优化器在物理优化阶段，主要解决的问题是：</p><ul><li>从可选的单表扫描方式中，挑选什么样的单表扫描方式最优？</li><li>对于两表连接，如何连接最优？</li><li>对于多表连接，哪种连接顺序最优？</li><li>对于多表连接，是否需要对每种连接顺序都探索？如果不全部探索，如何找到一种最优组合？</li></ul><p>选择的方法可以是：</p><ol><li>基于规则的启发式优化。</li><li>基于代价估算的优化。</li><li>两者结合的优化方法。常常先使用启发式规则选取若干个较优的候选方案，减少代价估算的工作量，然后分别计算这些候选方案的执行代价，较快地选出最终的优化方法。</li></ol><p>启发式规则优化是定性的选择，比较粗糙，但是实现简单而且优化本身的代价较小，适合解释执行的系统。因为解释执行的系统，其优开销包含在查询总开销之中，在编译执行的系统中，一次编译优化，多次执行，查询优化和查询执行是分开的，因此，可以用精细复杂一些的基于代价的优化方法。</p><h4 id="4-3-1-基于代价的优化"><a href="#4-3-1-基于代价的优化" class="headerlink" title="4.3.1 基于代价的优化"></a>4.3.1 基于代价的优化</h4><h5 id="4-3-1-1-查询代价估算"><a href="#4-3-1-1-查询代价估算" class="headerlink" title="4.3.1.1 查询代价估算"></a>4.3.1.1 查询代价估算</h5><p>查询代价估算基于CPU代价和I/O代价，计算公式如下：</p><pre><code>总代价 = I/O代价 + CPU代价COST = P * a_page_cpu_time + W * T</code></pre><p>其中：</p><p>P是计划运行时访问的页面数，a_page_cpu_time是每个页面读取的时间开销，其乘积反映了I/O开销。</p><p>T为访问的元组数，如果是索引扫描，还要考虑索引读取的开销，反映了数据读取到内存的CPU开销。</p><p>W为权重因子，表明I/O到CPU的相关性，又称选择率（selectivity），用于表示在关系R中，满足条件“A a”的元组数与R的所有元组数N的比值。</p><p>选择率在代价估算模型中占有重要地位，其精确程度直接影响最优计划的选取。选择率计算常用方法如下：</p><ol><li>无参数方法：使用ad hoc（点对点）数据结构或直方图维护属性值的分布，直方图最常用；</li><li>参数法：使用具有一些自由统计参数（参数是预先估计出来的）的数学分布函数逼近真实分布；</li><li>曲线拟合法：为克服参数法的不灵活性，用一般多项式来标准最小方差来逼近属性值的分布；</li><li>抽样法：从数据库中抽取部分样本元组，针对这些样本进行查询，然后收集统计数据；</li><li>综合法：将以上几种方法结合起来，如抽样法和直方图法结合。</li></ol><p>由于其中I/O代价占比最大，通常以I/O代价为主来进行代价估算。</p><ol><li>全表扫描算法的代价估算公式</li></ol><ul><li><p>如果基本表大小为 B 块，全表扫描算法的代价 cost = B；</p></li><li><p>如果选择条件是”码＝值”，则平均搜索代价 cost = B/2。</p><ol start="2"><li>索引扫描算法的代价估算公式</li></ol></li><li><p>如果选择条件为”码=值”，则采用该表的主索引，若为B+树，设索引层数为L，需要存取B+树中从根节点到叶节点L块，再加上基本表中该元组所在的那一块，cost=L+1。</p></li><li><p>如果选择条件涉及非码属性，若为B+树索引，选择条件是相等比较，S为索引选择基数（有S个元组满足条件），假设满足条件的元组保存在不同块上，则最坏情况下cost=L+S。</p></li><li><p>l 若比较条件为&gt;,&gt;=,&lt;,&lt;=，假设有一半元组满足条件，则需要存取一半的叶节点，并通过索引访问一半的表存储块，cost=L+Y/2+B/2。若可以获得更准确的选择基数，可进一步修正Y/2与B/2。</p><p>3.嵌套循环连接算法的代价估算公式</p></li><li><p>嵌套循环连接算法的代价为：cost=Br+BrBs/(K-1), 且K&lt;B(R)&lt;B(S)，其中K表示缓冲区大小为K块；</p></li><li><p>若需要把中间结果写回磁盘，则代价为：cost=Br+BrBs/(K-1) +　(Frs*Nr*Ns)/Mrs。Frs为连接选择率，表示连接结果数的比例，Mrs为块因子，表示每块中可以存放的结果元组数目。</p><p>4.排序合并连接算法的代价估算公式</p></li><li><p>如 果 连 接 表 已 经 按 照 连 接 属 性 排 好 序 ， 则 cost =Br+Bs+(Frs*Nr*Ns)/Mrs。</p></li><li><p>如果必须对文件排序，需要在代价函数中加上排序的代价对 于 包 含 B 个 块 的 文 件 排 序 的 代 价 大 约 是：cost =(2*B)+(2*B*log2B)。</p></li></ul><h5 id="4-3-1-2-基于代价的连接顺序选择"><a href="#4-3-1-2-基于代价的连接顺序选择" class="headerlink" title="4.3.1.2 基于代价的连接顺序选择"></a>4.3.1.2 基于代价的连接顺序选择</h5><p>多表连接算法实现的是在查询路径生成的过程中，根据代价估算，从各种可能的候选路径中找出最优的路径。它需要解决两个问题：</p><ul><li>多表连接的顺序</li><li>多表连接的搜索空间：N个表的连接可能有N！种连接组合，这可能构成一个巨大的搜索空间。如何将搜索空间限制在一个可接受的范围内，并高效生成查询执行计划将成为一个难点。</li></ul><p>多表间的连接顺序表示了查询计划树的基本形态。在1990年，Schneder等人在研究查询树模型时提出了左深树，右深树和紧密树3种形态</p><p><img src="/posts/41900/5-1.png" alt="图5-1 三种树的形态"></p><p>即使是同一种树的生成方式，也有细节需要考虑。如图5-1-a中{A,B}和{B,A}两种连接方式开销可能不同。比如最终连接结果{A,B,C}则需要验证比较6种连接方式，找出最优的一种作为下次和其他表连接的依据。</p><p>多表连接搜索最优查询树，有很多算法，如启发式、分枝界定计划枚举、贪心、动态规划、爬山法、System R优化方法等。其中，常用算法如下。</p><ol><li><p><strong>动态规划</strong></p><p> 在数据库领域，动态规划算法主要解决多表连接的问题。它是自底向上进行的，即从叶子开始做第一层，然后开始对每层的关系做两两连接（如果满足内连接进行两两连接，不满足则不可对全部表进行两两连接），构造出上层，逐次递推到树根。以下介绍具体步骤：</p><p> 初始状态：构造第一层关系，即叶子结点，每个叶子对应一个单表，为每一个待连接的关系计算最优路径（单表的最优路径就是单表的最佳访问方式，通过评估不同的单表的数据扫描方式代价，找出代价最小的作为每个单表的局部最优路径）</p><p> 归纳：当第1层到第n-1层的关系已经生成，那么求解第n层的关系方法为：将第n-1层的关系与第一层中的每个关系连接，生成新的关系（对新关系的大小进行估算），放于第n层，且每一个新关系，均求解最优路径。每层路径的生成都是基于下层生成的最优路径，这满足最优化原理的要求。</p><p> 还有的改进算法，在生成第n层的时候，除了通过第n-1层和第一层连接外，还可以通过第n-2层和第二层连接…。</p><p> PostgreSQL查询优化器求解多表连接时，采用了这种算法。</p></li><li><p><strong>启发式算法</strong></p><p> 启发式算法是相对最优化算法提出的，是一个基于直观或者经验构造的算法，不能保证找到最好的查询计划。在数据库的查询优化器中，启发式一直贯穿于整个查询优化阶段，在逻辑查询优化阶段和物理查询优化阶段，都有一些启发式规则可用。PostgreSQL，MySQL，Oracle等数据库在实现查询优化器时，采用了启发式和其他方式相结合的方式。</p><p> 物理查询优化阶段常用启发式规则如下：</p><ul><li>关系R在列X上建立索引，且对R的选择操作发生在列X上，则采用索引扫描方式；</li><li>R连接S，其中一个关系上的连接列存在索引，则采用索引连接且此关系作为内表；</li><li>R连接S，其中一个关系上的连接列是排序的，则采用排序连接比hash连接好。</li></ul></li><li><p><strong>贪心算法</strong></p><p> 贪心算法最后得到的是局部最优解，不一定全局最优，其实现步骤如下：</p><p> (1) 初始，算法选出的候选对象集合为空；</p><p> (2) 根据选择函数，从剩余候选对象中选出最有可能构成解的对象；</p><p> (3) 如果集合中加上该对象后不可行，那么该对象就被丢弃并不再考虑；</p><p> (4) 如果集合中加上该对象后可行，就加到集合里；</p><p> (5) 扩充集合，检查该集合是否构成解；</p><p> (6) 如果贪心算法正确工作，那么找到的第一个解通常都是最优的，可以终止算法；</p><p> (7) 继续执行第二步。</p><p> MySQL查询优化器求解多表连接时采用了这种算法。</p></li><li><p><strong>System-R算法</strong></p></li></ol><p>对自底向上的动态规划算法进行了改进，主要思想是把子树的查询计划的最优查询计划和次优查询计划保留，用于上层的查询计划生成，以便使得查询计划总体上最优。</p><p>多表连接常用算法比较</p><table><thead><tr><th><strong>算法名称</strong></th><th><strong>特点与适用范围</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td>启发式算法</td><td>适用于任何范围，与其它算法结合，能有效提高整体效率</td><td>不知道得到的解是否最优</td></tr><tr><td>贪婪算法</td><td>非穷举类型的算法。适合解决较多关系的搜索</td><td>得到局部最优解</td></tr><tr><td>爬山法</td><td>适合查询中包含较多关系的搜索，基于贪婪算法</td><td>随机性强，得到局部最优解</td></tr><tr><td>遗传算法</td><td>非穷举类型的算法。适合解决较多关系的搜索</td><td>得到局部最优解</td></tr><tr><td>动态规划算法</td><td>穷举类型的算法。适合查询中包含较少关系的搜索，可得到全局最优解</td><td>搜索空间随关系个数增长呈指数增长</td></tr><tr><td>System R优化</td><td>基于自底向上的动态规划算法，为上层提供更多可能的备选路径，可得到全局最优解</td><td>搜索空间可能比动态规划算法更大一些</td></tr></tbody></table><h4 id="4-3-2-基于规则的优化"><a href="#4-3-2-基于规则的优化" class="headerlink" title="4.3.2 基于规则的优化"></a>4.3.2 基于规则的优化</h4><p>基于代价优化的一个缺点是优化本身的代价。因此，查询优化器使用启发式方法来减少优化代价。</p><ul><li>选择操作的启发式规则：</li></ul><p>1) 对于小关系，全表扫描；</p><p>2) 对于大关系：</p><pre><code>(1) 若选择条件是主码，则可以选择主码索引，因为主码索引一般是被自动建立的；(2) 若选择条件是非主属性的等职查询，并且选择列上有索引，如果选择比例较小（10%）可以使用索引扫描，否则全表扫描；(3) 若选择条件是属性上的非等值查询或者范围查询，同上；(4) 对于用and连接的合取选择条件，若有组合索引，优先用组合索引方法；如果某些属性上有一般索引，则用索引扫描，否则全表扫描；(5) 对于用OR连接的析取选择条件，全表扫描。</code></pre><ul><li>连接操作的启发式规则</li></ul><p>1) 若两个表都已经按连接属性排序，则选用排序-合并算法；</p><p>2) 若一个表在连接属性上有索引，则使用索引连接方法；</p><p>3) 若其中一个表较小，则选用hash join；</p><p>4) 最后可以使用嵌套循环，小表作为外表。</p><h2 id="第五章-事务处理"><a href="#第五章-事务处理" class="headerlink" title="第五章 事务处理"></a>第五章 事务处理</h2><h3 id="5-1-事务概念"><a href="#5-1-事务概念" class="headerlink" title="5.1 事务概念"></a>5.1 事务概念</h3><p>在数据库系统中，事务是指由一系列数据库操作组成的一个完整的逻辑过程。数据库提供了增、删、改、查等几种基础操作，用户可以灵活地组合这几种操作来实现复杂的语义。在很多场景下，用户希望一组操作可以做为一个整体一起生效，这就是事务的产生背景。</p><blockquote><p>例如，一个银行转帐业务，在数据库中需要通过两个修改操作来实现：</p><ol><li>从账户A扣除指定金额；</li><li>向账户B添加指定金额。</li></ol><p>这两个操作构成了一个完整的逻辑过程，不可拆分。如果第一个操作成功而第二个操作失败，说明转账没有成功。在这种情况下，对于银行来说，数据库中的账户数据是处于一种不正确的状态的，必须撤销掉第一个操作对数据库的修改，让账户数据恢复到转账前的状态。由此例可见，事务是数据库状态变更的基本单元，在事务将数据库从一个正确状态变更到另一个正确状态的过程中，数据库的那些中间状态，既不应该被其他事务看到或干扰，也不应该在事务结束后依然保留。</p></blockquote><p>根据以上描述的事务概念，事务应具有四个特性，称为事务的ACID特性。它们分别是：</p><ul><li><strong>原子性</strong> （Atomicity）：一个事务中的所有操作，要么全做，要么全不做。事务如果在执行过程中发生错误，该事务修改过的数据应该被恢复到事务开始前的状态，就像这个事务从来没有执行过一样。</li><li><strong>一致性</strong> （Consistency）：当数据库只包含成功事务提交的结果时，称数据库处于一致性状态。事务执行的结果必须使数据库从一个一致性状态变到另一个一致性状态。由此可见，一致性与原子性是密切相关的。</li><li><strong>隔离性</strong> （Isolation）：一个事务的执行不能被其他事务干扰。DBMS允许多个并发事务同时执行，隔离性可以防止多个事务并发执行时由于相互干扰而导致数据的不一致。</li><li><strong>持久性</strong> （Durability）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><p>在数据库运行过程中，刚插入的数据往往不会直接写入磁盘，而是先缓存在内存中。对于一个运行中的数据库，可以将其地址空间简单分成三个部分:</p><ul><li>1.持久化保存数据的磁盘空间</li><li>2.缓冲区对应的内存或虚拟内存空间</li><li>3.事务的局部地址空间〈也在内存中)</li></ul><p>事务要读取数据，首先要将数据取到缓冲区中，然后缓冲区的数据可以被事务读取到局部空间。事务的写入过程与此相反，先在局部空间中创建新值，然后再将新数据拷贝到缓冲区中。缓冲区中的数据通常是由缓冲区管理器决定何时写入磁盘，而不是立刻持久化到磁盘。</p><p>在SQL中，开始和结束事务的语句如下：</p><ul><li>BEGIN TRANSACTION：开始一个事务。除了用该语句显式地开始一个事务，DBMS也允许隐式的开始一个事务。隐式开始事务时无需执行任何语句，每当用户连接成功，即开始一个事务，前一个事务结束时，即自动开始下一个事务。</li><li>COMMIT：提交一个事务。此语句表示事务正常结束，DBMS应永久保存该事务对数据库的修改。</li><li>ROLLBACK：回滚一个事务。此语句表示事务异常结束，DBMS应撤销该事务对数据库的所有修改。需要注意的是，当事务发生故障时，即使用户没有显式执行ROLLBACK语句，DBMS也应自动回滚事务。</li></ul><p>一个支持事务的DBMS必须能保证事务的ACID特性，这部分工作是由事务处理机制来负责的。事务处理机制又分为并发控制机制和故障恢复机制两部分，以下分别介绍。</p><p><img src="/posts/41900/image-20231009204945330.png" alt></p><h3 id="5-2-并发控制"><a href="#5-2-并发控制" class="headerlink" title="5.2 并发控制"></a>5.2 并发控制</h3><p>所谓并发操作，是指在多用户共享的数据库中，多个事务可能同时对同一数据进行操作。如果对这些操作不加控制，则可能导致数据的不一致问题。因此，为了保证事务的一致性和隔离性，DBMS需要对并发操作进行正确调度。这就是并发控制机制的任务。</p><h4 id="5-2-1-并发错误"><a href="#5-2-1-并发错误" class="headerlink" title="5.2.1 并发错误"></a>5.2.1 并发错误</h4><p>并发操作带来的数据不一致性包括丢失修改、读脏和不可重复读。</p><ol><li><p>丢失修改</p><p> 两个以上事务从数据库中读入同一数据并修改，其中一个事务（后提交的事务）的提交结果破坏了另一事务（先提交的事务）的提交结果，导致先提交的事务对数据库的修改被丢失。</p></li><li><p>读脏</p><p> 事务读取了被其他事务修改且未提交的数据，即从数据库中读到了临时性数据。</p></li><li><p>不可重复读</p><p> 一个事务读取数据后，该数据又被另一事务修改，导致前一事务无法再现前一次的读取结果。</p><p> 不可重复读又可分为两种情况：一种情况是第一次读到的数据的值在第二次读取时发生了变化；还有一种情况是事务第二次按相同条件读取数据时，返回结果中多了或者少了一些记录。后者又被称为幻读。</p></li></ol><h4 id="5-2-2-并发控制的正确性标准"><a href="#5-2-2-并发控制的正确性标准" class="headerlink" title="5.2.2 并发控制的正确性标准"></a>5.2.2 并发控制的正确性标准</h4><p>并发控制机制的任务就是对并发事务进行正确的调度，但是什么样的调度才是正确的呢？我们需要一个正确性的判断标准。</p><h5 id="5-2-2-1-可串行化"><a href="#5-2-2-1-可串行化" class="headerlink" title="5.2.2.1 可串行化"></a>5.2.2.1 可串行化</h5><p>串行调度是指多个事务依序串行执行，仅当一个事务的所有操作执行完后才执行另一个事务。这种调度方式下，不可能出现多个事务同时访问同一数据的问题，自然也就不可能出现并发错误。串行调度显然是正确的，但是串行调度无法充分利用系统资源，因此其效率显然也是用户难以接受的。</p><p>并发调度是指在数据库系统中同时执行多个事务。DBMS对多个并发事务进行调度时，可能产生多个不同的调度序列，从而得到不同的执行结果。如何判断某个调度是不是正确呢？如果这些并发事务的执行结果与它们按某一次序串行执行的结果相同，则认为该并发调度是正确的，我们称之为可串行化调度。</p><h5 id="5-2-2-2-冲突可串行化"><a href="#5-2-2-2-冲突可串行化" class="headerlink" title="5.2.2.2 冲突可串行化"></a>5.2.2.2 冲突可串行化</h5><p>可串行化是并发控制的正确性准则。但是按照可串行化的定义，如果想要判断一个并发调度是不是可串行化调度，需要知道这批事务所有可能的串行调度的结果，然后将该并发调度的结果与这些结果进行比较，这显然是难以实施的。因此，我们需要一种可操作的判断标准，即冲突可串行化。</p><p>冲突可串行化是可串行化的充分条件。如果一个并发调度是冲突可串行化的，那么它一定是可串行化的。在定义冲突可串行化之前，需要先了解什么是冲突操作。</p><p>冲突操作是指不同的事务对同一个数据的读写操作或写写操作。例如，事务1对数据A的读操作”r1(A)”与事务2对数据A的写操作”w2(A)”就是一对冲突操作。</p><p>我们规定，不同事务的冲突操作和同一事务的两个操作是不能交换的。因为如果改变冲突操作的次序，则最后的数据库状态会发生变化。按照这个规定，在保证一个并发调度中的冲突操作次序不变的情况下，如果通过交换两个事务的非冲突操作，能够得到一个串行调度，则称该并发调度是冲突可串行化的。</p><p>例如，对于以下两个并发调度序列：</p><p>SC1：r1(A) w1(B) r2(B) w1(C) w2(B)</p><p>SC2：r1(B) r2(A) w1(A) w2(B)</p><p>SC1就是冲突可串行化的，因为可以通过交换非冲突操作3和4得到一个串行调度序列。而SC2则是非冲突可串行化的，因为操作2和3是冲突操作，无法交换。</p><h4 id="5-2-3-事务隔离级别"><a href="#5-2-3-事务隔离级别" class="headerlink" title="5.2.3 事务隔离级别"></a>5.2.3 事务隔离级别</h4><p>可串行化是一个很严格的正确性标准。在实际应用中，有时候可能会希望降低这个标准，通过牺牲一定的正确性，达到提高并发度的目的。为此，SQL标准将事务的隔离程度划分为四个等级，允许用户根据需要自己指定事务的隔离级。这四种隔离级包括读未提交（Read Uncommitted）、读提交（Read Committed）、可重复读（Repeatable Read）和可串行化（Serializable）。</p><ol><li>读未提交：在该隔离级别，事务可以看到其他未提交事务的执行结果，即允许读脏数据。</li><li>读提交：这是大多数DBMS的默认隔离级别，它要求事务只能看见已提交事务所做的修改，因此可以避免读脏数据。但是由于在某个事务的执行期间，同一个数据可能被另一个事务修改并提交，所以该事务对该数据的两次读取可能会返回不同的值，即出现不可重复读错误。</li><li>可重复读：在该隔离级别，同一事务多次读取同一数据时，总是会读到同样的值。不过理论上，该隔离级不能避免幻读，即使用相同条件多次读取时，满足读取条件的数据的数量可能有变化，比如多出一些满足条件的数据。</li><li>可串行化：这是最高的隔离级别，能够避免所有并发错误。可串行化的概念前面已经介绍过，此处不再赘述。</li></ol><h3 id="5-3-封锁机制"><a href="#5-3-封锁机制" class="headerlink" title="5.3 封锁机制"></a>5.3 封锁机制</h3><h4 id="5-3-1什么是封锁"><a href="#5-3-1什么是封锁" class="headerlink" title="5.3.1什么是封锁"></a>5.3.1什么是封锁</h4><p>封锁机制是一种常用的并发控制手段，它包括三个环节：第一个环节是申请加锁，即事务在操作前对它要使用的数据提出加锁请求；第二个环节是获得锁，即当条件满足时，系统允许事务对数据加锁，使事务获得数据的控制权；第三个环节是释放锁，即完成操作后事务放弃数据的控制权。为了达到并发控制的目的，在使用时事务应选择合适的锁，并遵从一定的封锁协议。</p><p>基本的封锁类型有两种：排它锁（Exclusive Locks，简称X锁）和共享锁（Share Locks，简称S锁）。</p><ol><li><p>排它锁</p><p> 排它锁也称为独占锁或写锁。一旦事务T对数据对象A加上了排它锁（X锁），则其他任何事务不能再对A加任何类型的锁，直到T释放A上的锁为止。</p></li><li><p>共享锁</p><p> 共享锁又称读锁。如果事务T对数据对象A加上了共享锁（S锁），其他事务对A就只能加S锁而不能加X锁，直到事务T释放A上的S锁为止。</p></li></ol><h4 id="5-3-2-封锁协议"><a href="#5-3-2-封锁协议" class="headerlink" title="5.3.2 封锁协议"></a>5.3.2 封锁协议</h4><p>简单地对数据加X锁和S锁并不能保证数据库的一致性。在对数据对象加锁时，还需要约定一些规则，包括何时申请锁、申请什么类型的锁、何时释放锁等，这些规则称为封锁协议。不同的规则形成了各种不同的封锁协议。封锁协议分三级，它们对并发操作带来的丢失修改、读脏和不可重复读等并发错误，可以在不同程度上予以解决。</p><ol><li><p>一级封锁协议</p><p> 一级封锁协议是指事务T在修改数据之前必须先对其加X锁，直到事务结束才释放。</p><p> 一级封锁协议可有效地防止丢失修改，并能够保证事务T的可恢复性。但是，由于一级封锁没有要求对读数据进行加锁，所以不能防止读脏和不可重复读。遵循一级封锁协议的事务可以达到读未提交的事务隔离级。</p></li><li><p>二级封锁协议</p><p> 二级封锁协议是指事务T在修改数据之前必须先加X锁，直到事务结束才释放X锁；在读取数据之前必须先加S锁，读完后即可释放S锁。</p><p> 二级封锁协议不但能够防止丢失修改，还可进一步防止读脏。遵循二级封锁协议的事务可以达到读提交的事务隔离级。</p></li><li><p>三级封锁协议</p><p> 三级封锁协议是事务T在读取数据之前必须先对其加S锁，在修改数据之前必须先对其加X锁，直到事务结束后才释放所有锁。</p><p> 由于三级封锁协议强调即使事务读完数据A之后也不释放S锁，从而使得别的事务无法更改数据A，所以三级封锁协议不但能够防止丢失修改和读脏，而且能够防止不可重复读。遵循三级封锁协议的事务至少可以达到可重复读的事务隔离级，至于是否能到达可串行化级别，则取决于S锁的粒度。比如，如果只对要读取的记录加锁，则无法避免幻读问题；但如果是对整个表加锁，则幻读问题可以避免，代价是并发度的下降。</p></li></ol><h4 id="5-3-3-封锁的实现"><a href="#5-3-3-封锁的实现" class="headerlink" title="5.3.3 封锁的实现"></a>5.3.3 封锁的实现</h4><p>锁管理器可以实现为一个进程或线程，它从事务接受请求消息并反馈结果消息。对于事务的加锁请求消息，锁管理器返回授予锁消息，或者要求事务回滚的消息（发生死锁时）；对于事务的解锁请求消息，只需返回一个确认消息，但可能触发锁管理器向正在等待该事务解锁的其他事务发送授予锁消息。</p><p>锁管理器使用以下数据结构：</p><ul><li>为目前已加锁的每个数据对象维护一个链表，链表中的每个结点代表一个加锁请求，按请求到达的顺序排序。一个加锁请求包含的信息有：提出请求的事务ID，请求的锁的类型，以及该请求是否已被授予锁。</li><li>使用一个以数据对象ID为索引的散列表来查找数据对象（如果有的话），这个散列表叫做锁表。</li></ul><p>下图是一个锁表的示例图，该表包含5个不同的数据对象14、17、123、144和1912的锁。锁表采用溢出链表示法，因此对于锁表的每一个表项都有一个数据对象的链表。每一个数据对象都有一个已授予锁或等待授予锁的事务请求列表，已授予锁的请求用深色阴影方块表示，等待授予锁的请求则用浅色阴影方块表示。 例如，事务T23在数据对象17和1912上已被授予锁，并且正在等待对数据对象14加锁。</p><p><img src="/posts/41900/image-20231003184009931.png" alt></p><p>虽然图没有标示出来，但对锁表还应当维护一个基于事务标识符的索引，这样它可以快速确定一个给定事务持有的锁的集合。</p><p>锁管理器这样处理请求：</p><ul><li>当一条加锁请求消息到达时，如果锁表中存在相应数据对象的链表，则在该链表末尾增加一个请求；否则，新建一个仅包含该请求的链表。对于当前没有加锁的数据对象，总是满足事务对其的第一次加锁请求，但当事务向已被加锁的数据对象申请加锁时，只有当该请求与当前持有的锁相容、并且所有之前的请求都已授予锁的条件下，锁管理器才为该请求授予锁，否则，该请求只能等待。</li><li>当锁管理器收到一个事务的解锁消息时，它先找到对应的数据对象链表，删除其中该事务的请求，然后检查其后的请求，如果有，则看该请求能否被满足，如果能，锁管理器授权该请求，再按相同的方式处理后续的请求。</li><li>如果一个事务被中止，锁管理器首先删除该事务产生的正在等待加锁的所有请求；当系统采取适当动作撤销了该事务后，该中止事务持有的所有锁也将被释放。</li></ul><p>这个算法保证了锁请求无饿死现象，因为在先接收到的请求正在等待加锁时，后来的请求不可能获得授权。</p><p>为了避免消息传递的开销，在许多DBMS中，事务通过直接更新锁表来实现封锁，而不是向锁管理器发送请求消息。事务加锁和解锁的操作逻辑与上述锁管理器的处理方法类似，但是有两个明显的区别：</p><ul><li>由于多个事务可以同时访问锁表，因此必须确保对锁表的互斥访问。</li><li>如果因为锁冲突而不能立刻获得锁，加锁事务需要知道自己何时可以被授予锁，解锁事务需要标记出那些可以被授予锁的事务并通知它们。这个功能可以通过操作系统的信号量机制来实现。</li></ul><h4 id="5-3-4-死锁处理"><a href="#5-3-4-死锁处理" class="headerlink" title="5.3.4 死锁处理"></a>5.3.4 死锁处理</h4><p>封锁机制有可能导致死锁，DBMS必须妥善地解决死锁问题，才能保障系统的正常运行。</p><p>如果事务T1和T2都需要修改数据Rl和R2，并发执行时Tl封锁了数据R1，T2封锁了数据R2；然后T1又请求封锁R2，T2又请求封锁Rl；因T2已封锁了R2，故T1等待T2释放R2上的锁。同理，因T1已封锁了R1，故T2等待T1释放R1上的锁。由于Tl和T2都没有获得全部需要的数据，所以它们不会结束，只能继续等待。这种多事务交错等待的僵持局面称为死锁。</p><p>一般来讲，死锁是不可避免的。DBMS的并发控制子系统一旦检测到系统中存在死锁，就要设法解除。通常采用的方法是选择一个处理死锁代价最小的事务，将其中止，释放此事务持有的所有的锁，使其他事务得以继续运行下去。当然，被中止的事务已经执行的所有数据修改操作都必须被撤销。</p><p>数据库中解决死锁问题主要有两类方法：一类方法是允许发生死锁，然后采用一定手段定期诊断系统中有无死锁，若有则解除之，称为死锁检测；另一类方法是采用一定措施来预防死锁的发生，称为死锁预防。</p><h5 id="5-3-4-1-死锁检测"><a href="#5-3-4-1-死锁检测" class="headerlink" title="5.3.4.1 死锁检测"></a>5.3.4.1 死锁检测</h5><p>锁管理器通过waits-for图记录事务的等待关系，如图6-2所示。其中结点代表事务，有向边代表事务在等待另一个事务解锁。当waits-for图出现环路时，就说明出现了死锁。锁管理器会定时检测waits-for图，如果发现环路，则需要选择一个合适的事务中止它。</p><p><img src="/posts/41900/6-2.png" alt="图6-2 waits-for图示例图"></p><p>图6-2 waits-for图示例图</p><h5 id="5-3-4-2-死锁避免"><a href="#5-3-4-2-死锁避免" class="headerlink" title="5.3.4.2 死锁避免"></a>5.3.4.2 死锁避免</h5><p>当事务请求的锁与其他事务出现锁冲突时，系统为防止死锁，杀死其中一个事务。选择要杀死的事务时，一般持续越久的事务，保留的优先级越高。这种防患于未然的方法不需要waits-for图，但提高了事务被杀死的比率。</p><h4 id="5-3-5-封锁粒度"><a href="#5-3-5-封锁粒度" class="headerlink" title="5.3.5 封锁粒度"></a>5.3.5 封锁粒度</h4><p>封锁粒度是指封锁对象的大小。封锁对象可以是逻辑单元，也可以是物理单元。以关系数据库为例，封锁对象可以是属性值、属性值的集合、记录、表、直至整个数据库；也可以是一些物理单元，例如页（数据页或索引页）、块等。封锁粒度与系统的并发度及并发控制的开销密切相关。封锁的粒度越小，并发度越高，系统开销也越大；封锁的粒度越大，并发度越低，系统开销也越小。</p><p>如果一个DBMS能够同时支持多种封锁粒度供不同的事务选择，这种封锁方法称为多粒度封锁。选择封锁粒度时应该综合考虑封锁开销和并发度两个因素，选择适当的封锁粒度以求得最优的效果。通常，需要处理一个表中大量记录的事务可以以表为封锁粒度；需要处理多个表中大量记录的事务可以以数据库为封锁粒度；而对于只处理少量记录的事务，则以记录为封锁粒度比较合适。</p><h3 id="5-4-故障恢复"><a href="#5-4-故障恢复" class="headerlink" title="5.4 故障恢复"></a>5.4 故障恢复</h3><p>故障恢复机制是在数据库发生故障时确保数据库一致性、事务原子性和持久性的技术。当崩溃发生时，内存中未提交到磁盘的所有数据都有丢失的风险。故障恢复的作用是防止崩溃后的信息丢失。</p><p>故障恢复机制包含两个部分:</p><ul><li>为了确保DBMS能从故障中恢复，在正常事务处理过程中需要执行的操作，如登记日志、备份数据等。</li><li>发生故障后，将数据库恢复到原子性、一致性和持久性状态的操作。</li></ul><h4 id="5-4-1-故障分类"><a href="#5-4-1-故障分类" class="headerlink" title="5.4.1 故障分类"></a>5.4.1 故障分类</h4><p>由于DBMS根据底层存储设备被划分为不同的组件，因此DBMS需要处理许多不同类型的故障。</p><ol><li><p>事务故障</p><p> 一个事务出现错误且必须中止，称其为事务故障。可能导致事务失败的两种错误是逻辑错误和内部状态错误。逻辑错误是指事务由于某些内部条件无法继续正常执行，如非法输入、找不到数据、溢出等；内部状态错误是指系统进入一种不良状态，使当前事务无法继续正常执行，如死锁。</p></li><li><p>系统故障</p><p> 系统故障是指导致系统停止运转、需要重新启动的事件。系统故障可能由软件或硬件的问题引起。软件问题是指由于DBMS的实现问题（如未捕获的除零异常）导致系统不得不停止；硬件问题是指DBMS所在的计算机出现崩溃，如系统突然掉电、CPU故障等。发生系统故障时，内存中的数据会丢失，但外存数据不受影响。</p></li><li><p>介质故障</p><p> 介质故障是指当物理存储损坏时发生的不可修复的故障，如磁盘损坏、磁头碰撞、强磁场干扰等。当存储介质失效时，DBMS必须通过备份版本进行恢复。</p></li></ol><h4 id="5-4-2-缓冲池管理策略"><a href="#5-4-2-缓冲池管理策略" class="headerlink" title="5.4.2 缓冲池管理策略"></a>5.4.2 缓冲池管理策略</h4><p>缓冲池管理策略是指，对于已提交和未提交的事务，它们在内存缓冲池中修改的数据页被写出到磁盘的时机。</p><p>对于已提交事务，存在两种策略：</p><ul><li>FORCE：事务提交时必须强制将其修改的数据页写盘；</li><li>NOFORCE：允许在事务提交后延迟执行写盘操作。</li></ul><p>对于未提交事务，也存在两种策略：</p><ul><li>STEAL：允许在事务提交前就将其修改的数据页写盘；</li><li>NOSTEAL：不允许在事务提交前执行写盘操作。</li></ul><p>对于恢复来说，FORCE+ NOSTEAL是最简单的策略，但是这种策略的一个缺点是要求内存能放下事务需要修改的所有数据，否则该事务将无法执行，因为DBMS不允许在事务提交之前将脏页写入磁盘。</p><p>从高效利用内存和降低磁盘I/O开销的角度出发，NOFORCE+ STEAL策略是最灵活的，这也是很多DBMS采用的策略。在这种策略下，一旦发生故障，恢复机制可能需要执行以下操作：</p><ul><li>UNDO：发生故障时，尚未完成的事务的结果可能已写入磁盘，为保证数据一致性，需要清除这些事务对数据库的修改。</li><li>REDO：发生故障时，已完成事务提交的结果可能尚未写回到磁盘，故障使得这些事务对数据库的修改丢失，这也会使数据库处于不一致状态，因此应将这些事务已提交的结果重新写入磁盘。</li></ul><p>为了保证在恢复时能够得到足够的信息进行UNDO和REDO，DBMS在事务正常执行期间需要登记事务对数据库所做的修改，这就是日志机制。</p><h4 id="5-4-3-日志"><a href="#5-4-3-日志" class="headerlink" title="5.4.3 日志"></a>5.4.3 日志</h4><h5 id="5-4-3-1-日志的原理"><a href="#5-4-3-1-日志的原理" class="headerlink" title="5.4.3.1 日志的原理"></a>5.4.3.1 日志的原理</h5><p>日志是由日志记录构成的文件，几乎所有DBMS都采用基于日志的恢复机制。它的基本思路是：DBMS在对磁盘页面进行修改之前，先将其对数据库所做的所有更改记录到磁盘上的日志文件中，日志文件包含足够的信息来执行必要的UNDO和REDO操作，以便在故障后恢复数据库。DBMS必须先将对数据库对象所做修改的日志记录写入日志文件，然后才能将该对象刷新到磁盘，这一过程称为WAL（Write Ahead Log）。WAL的执行过程如图6-3所示。事务开始后，所有对数据库的修改在发送到缓冲池之前都被记录在内存中的WAL缓冲区中。事务提交时，必须把WAL缓冲区刷新到磁盘。一旦WAL缓冲区被安全地写进磁盘，事务的修改结果就也可以写盘了。</p><p><img src="/posts/41900/6-3.png" alt="图6-3 WAL过程示意图"></p><p>日志文件中应该记录以下信息：</p><ul><li>l 事务开始时，向日志中写入一条该事务的开始记录。</li><li>l 事务结束时，向日志中写入一条该事务的结束记录，结束记录包括两类：正常结束记录，和异常结束记录。</li><li>事务对每个数据对象的修改操作对应一条日志记录，其中包含以下信息:<ul><li>事务ID</li><li>对象ID</li><li>修改前的值（用于UNDO）</li><li>修改后的值（用于REDO）</li></ul></li></ul><p>将日志记录从日志缓冲区写入磁盘的时机有这样几个：</p><ul><li>接收到提交事务的命令后，在返回提交成功的消息之前，DBMS必须将该事务的所有日志记录写入磁盘。系统可以使用”组提交”的方式来批处理多个事务的提交，以降低I/O开销。</li><li>日志缓冲区空间不足的时候，需要将缓冲区中的日子记录写入磁盘。</li><li>在将一个脏数据页写入磁盘之前，与更新该页有关的所有日志记录都必须先被写入磁盘。</li></ul><p>需要注意的是，登记日志时必须严格按事务的操作顺序记录，并且写到磁盘中的日志记录顺序必须与写入日志缓冲区的顺序完全一致。</p><h5 id="5-4-3-2-日志的类型"><a href="#5-4-3-2-日志的类型" class="headerlink" title="5.4.3.2 日志的类型"></a>5.4.3.2 日志的类型</h5><p>根据实现时采用的恢复方法的不同，日志中记录的内容也不一样，分为以下几类。</p><ol><li>物理日志：物理日志中记录的是事务对数据库中特定位置的字节级更改。例如，日志中记录的是事务对指定数据页中从指定位置开始的若干字节的修改。</li><li>逻辑日志：逻辑日志中记录的是事务执行的逻辑操作。例如，日志中记录的是事务执行的UPDATE、DELETE和INSERT语句。与物理日志相比，逻辑日志需要写的数据更少，因为每条日志记录可以在多个页面上更新多个元组。然而，当系统中存在并发事务时，通过逻辑日志实现恢复很困难。</li><li>混合日志：日志中记录的是事务对指定页面中指定槽号内元组的更改，而不是对页中指定偏移位置的更改。</li></ol><h4 id="5-4-4-恢复算法"><a href="#5-4-4-恢复算法" class="headerlink" title="5.4.4 恢复算法"></a>5.4.4 恢复算法</h4><h5 id="5-4-4-1-事务故障的恢复"><a href="#5-4-4-1-事务故障的恢复" class="headerlink" title="5.4.4.1 事务故障的恢复"></a>5.4.4.1 事务故障的恢复</h5><p>事务故障是指事务在运行至正常终止点前被终止，这时恢复子系统应利用日志文件UNDO此事务己对数据库进行的修改。事务故障的恢复应由DBMS自动完成，对用户完全透明。恢复步骤如下：</p><ol><li>反向扫描日志文件，查找该事务的更新日志记录。</li><li>对该事务的更新操作执行逆操作， 即将日志记录中 “更新前的值” 写入数据库。如果记录中是插入操作，则逆操作相当于做删除操作：若记录中是删除操作，则逆操作相当于做插入操作；若是修改操作，则逆操作相当于用修改前的值代替修改后的值。</li><li>继续反向扫描日志文件，查找该事务的其他更新日志记录并做相同处理，直至读到此事务的开始标记。</li></ol><h5 id="5-4-4-2-系统故障的恢复"><a href="#5-4-4-2-系统故障的恢复" class="headerlink" title="5.4.4.2 系统故障的恢复"></a>5.4.4.2 系统故障的恢复</h5><p>系统故障导致数据库处于不一致状态的原因，一方面是未提交事务对数据库的更新已经被写入数据库，另一方面则是已提交事务对数据库的更新没有被完全写入数据库。因此对于系统故障的恢复操作，就是要UNDO故障发生时未提交的事务，REDO已提交的事务。系统故障也是由DBMS在重启时自动完成，对用户完全透明。恢复步骤如下：</p><ol><li>正向扫描日志文件，通过事务开始记录和COMMIT记录找出在故障发生前已提交的事务集合和未提交的事务集合。已提交的事务既有开始记录也有COMMIT记录，未提交的事务则只有开始记录，没有相应的COMMIT记录。将已提交的事务加入重做队列（REDO-LIST），未提交的事务加入撤销队列（UNDO-LIST）。</li><li>反向扫描日志文件，对UNDO-LIST中的各个事务进行UNDO处理。</li><li>正向扫描日志文件，对REDO-LIST中的各个事务进行REDO处理。</li></ol><h5 id="5-4-4-3-介质故障的恢复"><a href="#5-4-4-3-介质故障的恢复" class="headerlink" title="5.4.4.3 介质故障的恢复"></a>5.4.4.3 介质故障的恢复</h5><p>发生介质故障后，磁盘上的物理数据和日志文件被破坏，这是最严重的一种故障，恢复方法是重装数据库，然后重做已完成的事务。介质故障的恢复需要用户人工介入，由DBA装入最新的数据库备份及日志文件备份，然后执行系统提供的恢复命令。</p><p>DBA装入相关备份文件后，系统执行的恢复过程与系统故障的恢复过程类似，也是通过扫描日志文件构造REDO-LIST和UNDO-LIST，然后对REDO-LIST和UNDO-LIST中的事务分别进行REDO和UNDO处理，这样就可以将数据库恢复到最近一次备份时的一致性状态。</p><h4 id="5-4-5-检查点"><a href="#5-4-5-检查点" class="headerlink" title="5.4.5 检查点"></a>5.4.5 检查点</h4><p>以上讨论的基于日志的恢复算法存在两个问题：1. 构造REDO-LIST和UNDO-LIST需要搜索整个日志文件，耗费大量的时间；2.处理REDO-LIST时，很多事务的修改实际上已经写入了磁盘，但是仍然不得不进行REDO处理，浪费大量时间。为了解决上述问题，提高恢复效率，很多DBMS都采用了检查点技术，通过周期性地对日志做检查点来避免故障恢复时检查整个日志。</p><p>检查点技术的基本思路是：在日志文件中增加一类记录——检查点记录，并增加一个文件——重新开始文件。恢复子系统周期性地执行以下操作：</p><ol><li>将日志缓冲区中的日志记录全部写入磁盘中的日志文件；</li><li>在日志文件中写入一个检查点记录；</li><li>将数据缓冲区中的数据写入磁盘；</li><li>将检查点记录在日志文件中的地址写入重新开始文件。</li></ol><p>其中，检查点记录中包含以下信息：</p><ul><li>检查点时刻，当前所有正在执行的事务清单</li><li>清单中每个事务最近一个日志记录的地址</li></ul><p><img src="/posts/41900/6-4.png" alt="图6-4 带检查点的日志文件和重新开始文件"></p><p>由检查点时刻系统执行的操作可知，如果一个事务在一个检查点之前已经提交了，那么它对数据库所做的修改一定都被写入了磁盘，因此在进行恢复处理时，就没有必要再对该事务执行REDO操作了。</p><p>增加了检查点之后，基于日志的恢复步骤如下：</p><ol><li>从重新开始文件中找到最后一个检查点记录在日志文件中的地址，根据该地址在日志文件中找到最后一个检查点记录。</li><li>由该检查点记录得到检查点时刻正在执行的事务清单ACTIVE-LIST。初始化两个事务队列UNDO-LIST和REDO-LIST，令UNDO-LIST = ACTIVE-LIST，令REDO队列为空。</li><li>从检查点开始正向扫描日志文件直到日志文件结束，如有新开始的事务，则将其放入UNDO-LIST，如有提交的事务，则将其从UNDO-LIST队列移到REDO-LIST队列。</li><li>对UNDO-LIST和REDO-LIST中的每个事务，分别执行UNDO和REDO操作。</li></ol><h2 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h2><h3 id="火山模型"><a href="#火山模型" class="headerlink" title="火山模型"></a>火山模型</h3><p>火山模型是数据库界已经很成熟的解释计算模型，该计算模型将关系代数中每一种操作抽象为一个 Operator，将整个 SQL 构建成一个 Operator 树，从根节点到叶子结点自上而下地递归调用 next() 函数。这里的一个造作也可以视作为一个算子。作为一个树节点，往往会存在父节点和子节点，当作为父节点时，他需要调用子节点的操作，而作为子节点则需要在被父节点调用的时候，提供数据返回给父节点。</p><p>这种设计的优点在于每一个节点（Operator），不需要关心自己的父节点和子节点是什么类型的算子和具体的实现，他只需要提供相应的接口和调用即可。树的结构是千变万化的，那么即使是有限的算子，也可以通过组成各种各样的树结构来支持复杂的查询计划。同时如果想要新增算子，也只需要实现该算子的相应接口，并加入到构建中即可，有着良好的可扩展性。</p><ul><li>一般Operator的next() 接口实现分为三步<br>  （1）调用子节点Operator的next() 接口获取一行数据(tuple)<br>  （2）对tuple进行Operator特定的处理(如filter 或project 等)<br>  （3）返回处理后的tuple。</li></ul><p>所以经常能在代码中看到这样的代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Operator<span class="token punctuation">.</span>Children<span class="token punctuation">.</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如 SQL：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> Id<span class="token punctuation">,</span> Name<span class="token punctuation">,</span> Age<span class="token punctuation">,</span> <span class="token punctuation">(</span>Age <span class="token operator">-</span> <span class="token number">30</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">50</span> <span class="token keyword">AS</span> Bonus<span class="token keyword">FROM</span> People<span class="token keyword">WHERE</span> Age <span class="token operator">></span> <span class="token number">30</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对应火山模型如下：</p><p><img src="/posts/41900/image-20231008164342333.png" alt></p><ul><li>User：客户端。负责获取用户的sql，也负责发送给客户端sql的执行结果。</li><li>Project：垂直分割（投影），选择字段。对应于sql为：“SELECT Id, Name, Age, (Age - 30) * 50 AS Bonus”，接收子节点数据后，通过处理，得到需要返回给上层的结果值。</li><li>Select（或 Filter）：水平分割（选择)，用于过滤行，也称为谓词。对应于sql为：“WHERE Age &gt; 30”，接收子节点数据后，过滤掉不符合条件的数据。</li><li>Scan：扫描数据。将数据从存储层拉到计算层。比如将People的表数据从磁盘拉到内存。对应sql为：“FROM People”</li></ul><blockquote><p>这里包含了 3 个 Operator，首先 User 调用最上方的 Operator（Project）希望得到 next tuple，Project 调用子节点（Select），而 Select 又调用子节点（Scan），Scan 获得表中的 tuple 返回给 Select，Select 会检查是否满足过滤条件，如果满足则返回给 Project，如果不满足则请求 Scan 获取 next tuple。Project 会对每一个 tuple 选择需要的字段或者计算新字段并返回新的 tuple 给 User。当 Scan 发现没有数据可以获取时，则返回一个结束标记告诉上游已结束。</p></blockquote><p>为了更好地理解一个 Operator 中发生了什么，下面通过伪代码来理解 Select Operator：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Tuple Select<span class="token operator">::</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Tuple candidate <span class="token operator">=</span> child<span class="token operator">-</span><span class="token operator">></span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 从子节点中获取 next tuple</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>candidate <span class="token operator">==</span> EndOfStream<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 是否得到结束标记</span>            <span class="token keyword">return</span> EndOfStream<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token operator">-</span><span class="token operator">></span><span class="token function">check</span><span class="token punctuation">(</span>candidate<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 是否满足过滤条件</span>            <span class="token keyword">return</span> candidate<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回 tuple</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考一个案例： select name from student where teacher = ‘Karim’<br><img src="/posts/41900/image-20231008161654927.png" alt></p><p>从上面的图和右边的代码可以简单的了解下火山模型的调用和实现的思路。</p><ul><li>Projection: 投影算子，用于获取数据中的具体需要的字段，在该案例中是Name字段。Next()中的实现会首先调用 Children的Next()方法，获取数据，并取出Name这一列返回。</li><li>Selection：过滤算子，用于将数据中 Teacher = ‘Karim’ 的记录过滤出来，返回给上一层。Next()中的实现同样是先调用Children的Next()方法来获取数据。</li><li>Scan：扫描算子，用于从存储节点中获取所有的数据，并返回到父节点。因为Scan一般都是叶子节点，不需要再继续要调用Children的Next()方法。</li></ul><p>通过这种设计思路，将每个算子封装成一个Operator来独自处理，配合树结构的执行策略，有着非常优秀的可扩展性，同时兄弟节点之间的操作可以并行处理，所以火山模型同样也有着一定的并行处理能力。</p><p>在上面代码中，可以关注一个细节，也就是Next方法中其实都是只处理一行数据的，这种方式在当时是为了对内存使用的优化，那个年代的内存资源是非常昂贵的，而相比CPU的执行效率，IO执行效率会更低，所以火山模型将内存资源更多的放在IO上，而不是CPU的执行优化上。</p><p>但是现在看来，这种处理方式也会有着些许缺点，每次一整个Next调用链只会处理一行数据，效率非常的低，而同时一行数据处理就得调用多次Next()方法，大量数据处理下，函数调用的开销也会非常的大</p><h4 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h4><p><strong>首先</strong>，考虑到大量虚函数的调用，那我能否写一个循环去执行 Operator 中的计算逻辑呢？执行完成后再向上传递，这样将之前的自上而下的拉模型改成了自下而上的推模型。</p><p><strong>其次</strong>，火山模型中一次只取一条数据，如果每次取多条数据呢？因为可以将每次 next 带来的 CPU 开销被一组数据给分摊。这样当 CPU 访问元组中的某个列时会将该元组加载到 CPU Cache（如果该元组大小小于 CPU Cache 缓存行的大小）, 访问后继的列将直接从 CPU Cache 中获取，从而具有较高的 CPU Cache 命中率，然而如果只访问一个列或者少数几个列时 CPU 命中率仍然不理想。即<strong>向量化/批处理模型（Vectorized / Batch Model）</strong>，<strong>向量化模型 和 火山模型 类似，每个 operator 需要实现一个 next() 函数，但是每次调用 next() 函数会返回一批的元组（tuples），而不是一个元组，所以向量化模型也可称为批处理模型。</strong> 目前很多数据库采取的都是这种处理模式。</p><p>在算子间传递数据不再是一条一条记录，而是一批数据，算子每次执行的时候都会在内部攒一批数据，数据大小尽可能和CPU cache对齐，不仅大大提高了cache命中率，而且有效了减少了函数调用次数。</p><p>另外，我们再想想什么时候可以做到取多条数据同时计算呢？当然是同一列的时候，所以针对的是<strong>列存</strong>的场景，因为输入是同列的一组数据，面对的是相同的操作，这正是向量寄存器干的事情，这是 CPU 层面计算性能的优化，因此称为向量化。并且如果每次只取一列的部分数据，返回一个可以放到 CPU Cache 的向量，那么又可以利用到 CPU Cache。</p><h4 id="火山模型中的查询并行实现"><a href="#火山模型中的查询并行实现" class="headerlink" title="火山模型中的查询并行实现"></a>火山模型中的查询并行实现</h4><p>关系查询处理引擎中实现并行查询主要包括以下两个方向：</p><ol><li><strong>算子间并行（inter-operator parallelism）</strong>：查询处理使用 operator 树执行，这些 operator 可以划分为多条 pipeline 在独立的进程或处理器上运行，称为算子间的并行。  </li><li><strong>算子内并行（intra-operator parallelism）</strong>：每个 operator 的 input 数据可以被划分为不相交的子集，从而同时执行相同的 operator，称为算子内部的并行。  </li></ol><p><strong>火山模型中负责实现并行执行的是 Exchange 运算符，它是一个有</strong> <strong><em>open, next, close</em></strong> <strong>方法的 iterator，可以被插到查询执行树中的任何一个或多个位置</strong>。<br><img src="/posts/41900/image-20231008161923746.png" alt></p><h4 id="算子间并行（inter-operator-parallelism）"><a href="#算子间并行（inter-operator-parallelism）" class="headerlink" title="算子间并行（inter-operator parallelism）"></a>算子间并行（inter-operator parallelism）</h4><p>Exchange 的 <em>open</em> 方法用于创建进程，Exchange 算子上方作为父进程，下方作为子进程，例如图5中的查询树执行 <em>open</em> 方法后，创建的进程将如图所示。</p><p><img src="/posts/41900/image-20231008162040948.png" alt></p><p>Exchange 采用<strong>生产者消费者模型，父进程会作为消费者，子进程会作为生产者</strong>，同时在共享内存中创建一个数据结构 <strong><em>port</em></strong> 用于同步和数据交换。例如 Scan 算子会作为生产者，上方的 Join 算子作为消费者。</p><p><strong>生产者端的 exchange 算子会作为 driver 驱动查询执行</strong>，其输出会放到 <strong><em>packet</em></strong> 里面。 <em>packet</em> 被填满后，会被放到 <strong><em>port</em></strong> 中，同时发送一个信号量来提醒消费者。</p><p><strong>消费者端的 exchange 算子就和普通的迭代器一样</strong>，只不过它接收输入时会通过进程间的通信而不是内部的方法调用。</p><p>注意，<strong>火山模型中所有其他模块都是基于 demand-driven</strong>，即 iterator 调用 Next() 方法后，数据流再从下游传到上游，控制流和数据流的方向相反。而 **Exchange 算子则是基于data-driven，生产者侧的数据就绪后再通知消费者执行，数据流和控制流的方向相同。可参见下图的 Pull 模型和 Push 模型的比较，容易理解。这主要有两方面的原因：</p><ol><li>Data-driven 的方式更容易实现算子内的并行，因为算子内并行需要对数据进行分区，然后基于不交叉的数据进行; </li><li>这种模式避免了多余的控制流来 Request data，进程间通信时这些不避免要的控制流会导致延迟。</li></ol><p><img src="/posts/41900/image-20231008162354074.png" alt></p><p>同时，<strong>data-driven 的模式下允许流量控制（flow control） 或者说反压（back pressure）</strong>。比如说，当生产者的生产速度大于消费者的消费速度时，会导致数据堆积，占用较大内存的问题。这时可以通过消费者端发送一个信号量，告诉生产者降低生产速度或停止生产，等消费者消费完后再进行，从而解决问题。即改用拉取模型和推送模型。</p><h4 id="算子内并行（intra-operator-parallelism）"><a href="#算子内并行（intra-operator-parallelism）" class="headerlink" title="算子内并行（intra-operator parallelism）"></a>算子内并行（intra-operator parallelism）</h4><p><strong>算子内的并行需要对输入数据进行分区，输入数据主要包括数据存储和中间结果。</strong></p><ul><li>数据存储的分区主要依赖物理分区，比如不同设备，不同文件。  </li><li>中间结果分区则主要依靠在 <em>port</em> 中使用不同的队列。生产者使用分区 support function 来决定放到哪个队列里。  </li></ul><p>图7中展示了为了实现算子内并行创建的进程，Join 算子有三个进程执行，Scan 算子由一个或两个进程执行。<strong>通过规定_并发_度（degree of parallelism）来确定执行的进程数。</strong>因为同时有三个进程在执行 Join 算子，因此必须对 Scan 得到的数据进行重分区，以交给不同的进程执行。</p><p><img src="/posts/41900/v2-47a15bb24240e083e5eaed813e5e7a61_720w.webp" alt></p><p>所有的 Scan 进程都可以传递数据给所有的 Join 进程，但是 <strong>Join 算子间的数据传递只允许在每个 Join 进程内部进行</strong>。此时，如果使用了基于分区的并行 Join 方法，且图7中两个 Join 是针对不同属性进行的，则会导致出现问题。因为第一个 Join 是用属性 1 做的分区，此时属性2 相同的 tuple 可能落在不同的 Join 进程中。这个问题可以使用 exchange 算子的变式来解决，称为 <strong><em>inter-change</em></strong>.</p><h4 id="Exchange-算子的变式"><a href="#Exchange-算子的变式" class="headerlink" title="Exchange 算子的变式"></a>Exchange 算子的变式</h4><p>目前，我们提到的 exchange 算子都只能在一个进程的顶部或底部出现（要么提供输入，要么进行输出）。除此之外，<strong>Exchange 还可以在一个进程的 operator tree 的中间出现，其功能只限于提供一个数据交换的窗口。其 next 方法从下游的算子中获取输入，并可能把它发送给同一个 Group 的其他进程（如果属于自己的分区就自己用）。</strong>这种操作模式称为 <em>inter-change</em>.</p><p>另外，还有能把输出广播给所有消费者的 exchange 算子， 比如 HashJoin 中广播小表构建的哈希表；根据 producer 把 input 分别存储的 exchange 算子，以便上游可以区分输入的来源。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://link.zhihu.com/?target=https%3A//paperhub.s3.amazonaws.com/dace52a42c07f7f8348b08dc2b186061.pdf">Volcano - An Extensible and Parallel Query Evaluation System</a><br><a href="https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1610.09166">Push vs. Pull-Based Loop Fusion in Query Engines</a><br><a href="https://link.zhihu.com/?target=https%3A//databricks.com/blog/2016/05/23/apache-spark-as-a-compiler-joining-a-billion-rows-per-second-on-a-laptop.html">Apache Spark as a Compiler: Joining a Billion Rows per Second on a Laptop</a><br><a href="https://zhuanlan.zhihu.com/p/72953129">为什么向量化计算(vectorization)会这么快？</a><br><a href="https://link.zhihu.com/?target=http%3A//mysql.taobao.org/monthly/2017/01/06/">PgSQL · 引擎介绍 · 向量化执行引擎简介</a><br><a href="https://link.zhihu.com/?target=https%3A//io-meter.com/2018/11/01/sql-query-optimization-volcano/">SQL 查询优化原理与 Volcano Optimizer 介绍</a><br><a href="https://link.zhihu.com/?target=https%3A//www.infoq.cn/article/an-article-mastering-sql-on-hadoop-core-technology">一篇文章掌握 Sql-On-Hadoop 核心技术</a><br><a href="https://www.zhihu.com/question/52220920/answer/340220500">知乎问答-马晓宇-PinCAP</a><br><a href="https://link.zhihu.com/?target=https%3A//zhewuzhou.github.io/2018/09/13/SQL_Compilation_Technology_For_Performance/">数据库性能之翼：SQL 语句运行时编译</a><br><a href="https://link.zhihu.com/?target=https%3A//chenyansong.site/2017/04/18/bigdata/spark%25E4%25BB%258E%25E5%2585%25A5%25E9%2597%25A8%25E5%2588%25B0%25E7%25B2%25BE%25E9%2580%259A_%25E7%25AC%2594%25E8%25AE%25B0/Spark2.0%25E6%2596%25B0%25E7%2589%25B9%25E6%2580%25A7%25E4%25B9%258BVolcano%2520Iterator%2520Model%28%25E7%2581%25AB%25E5%25B1%25B1%25E8%25BF%25AD%25E4%25BB%25A3%25E5%2599%25A8%25E6%25A8%25A1%25E5%259E%258B%29/">Spark2.0新特性之spark1.x的Volcano Iterator Model(火山迭代器模型)</a><br><a href="https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/fe7d5e2d66e7">向量化与编译执行浅析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一章-数据库的存储结构&quot;&gt;&lt;a href=&quot;#第一章-数据库的存储结构&quot; class=&quot;headerlink&quot; title=&quot;第一章 数据库的存储结构&quot;&gt;&lt;/a&gt;第一章 数据库的存储结构&lt;/h2&gt;&lt;h3 id=&quot;1-1文件组织结构&quot;&gt;&lt;a href=&quot;#1-1文
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://JoyTsing.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://JoyTsing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
