<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="Shell编程小结, 博客 joytsing blog"><meta name="description" content="Keep It Simple, Stupid"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="theme-color" content="white"><title>Shell编程小结 | JoyTsing</title><link rel="apple-touch-icon" href="/"><link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="/favicon.ico"><link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css"><link rel="stylesheet" type="text/css" href="/libs/aos/aos.css"><link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css"><link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" type="text/css" href="/css/matery.css"><link rel="stylesheet" type="text/css" href="/css/my.css"><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style><script src="/libs/jquery/jquery.min.js"></script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="JoyTsing" type="application/atom+xml"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><img src="/apple-touch-icon.png" class="logo-img" alt="LOGO"> <span class="logo-span">JoyTsing</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fa fa-home"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-tags"></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-bookmark"></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-archive"></i> <span>归档</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa fa-user-circle-o"></i> <span>关于</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa fa-envelope"></i> <span>留言</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa fa-address-book"></i> <span>友链</span></a></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fa fa-search" title="搜索"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="/medias/avatars/touxiang2.jpg" class="logo-img circle responsive-img"><div class="logo-name">JoyTsing</div><div class="logo-desc">joytsing的个人博客</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="m-nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-fw fa-bookmark"></i> 分类</a></li><li class="m-nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li class="m-nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa fa-fw fa-user-circle-o"></i> 关于</a></li><li class="m-nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa fa-fw fa-envelope"></i> 留言</a></li><li class="m-nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa fa-fw fa-address-book"></i> 友链</a></li><li><div class="divider"></div></li><li><a href="https://github.com/JoyTsing" class="waves-effect waves-light" target="_blank"><i class="fa fa-github-square fa-fw"></i>Follow Me</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#000;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href="https://github.com/JoyTsing" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Follow Me" data-position="left" data-delay="50"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a></nav></header><div class="bg-cover pd-header post-cover" style="background-image:url(/medias/featureimages/20.jpg)"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">Shell编程小结</h1></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{width:345px;padding-left:20px}.toc-widget .toc-title{margin:35px 0 15px 0;padding-left:17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content{height:calc(100vh - 250px);overflow:auto}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px;position:absolute;right:23.5vw;display:block}#toc-content .is-active-link{color:#42b983}#floating-toc-btn{position:fixed;right:15px;bottom:76px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/Linux/"><span class="chip bg-color">Linux</span> </a><a href="/tags/Shell/"><span class="chip bg-color">Shell</span> </a><a href="/tags/%E6%95%99%E7%A8%8B/"><span class="chip bg-color">教程</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/Linux/" class="post-category">Linux</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp; 2020-12-18</div><div class="post-date info-break-policy"><i class="fa fa-calendar-check-o fa-fw"></i>更新日期:&nbsp;&nbsp; 2024-03-11</div><div class="info-break-policy"><i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp; 23.5k</div><div class="info-break-policy"><i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp; 93 分</div><div id="busuanzi_container_page_pv" class="info-break-policy"><i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp; <span id="busuanzi_value_page_pv"></span></div></div></div><hr class="clearfix"><div class="card-content article-card-content"><div id="articleContent"><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote><p>为了系统地学习和总结 Shell 编程，制定了一个 Shell 编程范例的总结计划，不会专门介绍 Shell 的语法， 而是假设对 Shell 编程有了一定的基础。另外，该系列涵盖：数值、逻辑值、字符串、文件、进程、文件系统等所有我们可以操作的“对象”，这个操作对象也将从低级到高级，进而上升到网络层面，整个通过各种方式连接起来的计算机的集合。实际上这也未尝不是在摸索 UNIX 的哲学，那”K.I.S.S”（Keep It Simple, Stupid）蕴藏的巨大能量。</p></blockquote><h3 id="什么是Shell"><a href="#什么是Shell" class="headerlink" title="什么是Shell"></a>什么是Shell</h3><p>首先让我们从下图看看 Shell 在整个操作系统中所处的位置吧，该图的外圆描述了整个操作系统（比如 <code>Debian/Ubuntu/Slackware</code> 等），内圆描述了操作系统的核心（比如 <code>Linux Kernel</code>），而 <code>Shell</code> 和 <code>GUI</code> 一样作为用户和操作系统之间的接口。</p><p><code>GUI</code> 提供了一种图形化的用户接口，使用起来非常简便易学；而 <code>Shell</code> 则为用户提供了一种命令行的接口，接收用户的键盘输入，并分析和执行输入字符串中的命令，然后给用户返回执行结果，使用起来可能会复杂一些，但是由于占用的资源少，而且在操作熟练以后可能会提高工作效率，而且具有批处理的功能，因此在某些应用场合还非常流行。</p><p><code>Shell</code> 作为一种用户接口，它实际上是一个能够解释和分析用户键盘输入，执行输入中的命令，然后返回结果的一个解释程序（Interpreter，例如在 <code>linux</code> 下比较常用的 <code>Bash</code>），我们可以通过下面的命令查看当前的 <code>Shell</code> ：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$SHELL</span>
/bin/bash
$ <span class="token function">ls</span> -l /bin/bash
-rwxr-xr-x 1 root root 702160 2020-06-18 02:33 /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>该解释程序不仅能够解释简单的命令，而且可以解释一个具有特定语法结构的文件，这种文件被称作脚本（Script）。它具体是如何解释这些命令和脚本文件的，这里不深入分析。</p><h3 id="搭建运行环境"><a href="#搭建运行环境" class="headerlink" title="搭建运行环境"></a>搭建运行环境</h3><p>为了方便后面的练习，我们先搭建一个基本运行环境：在一个 Linux 操作系统中，有一个运行有 <code>Bash</code> 的命令行在等待我们键入命令，这个命令行可以是图形界面下的 <code>Terminal</code> （例如 <code>Ubuntu</code> 下非常厉害的 <code>Terminator</code>），也可以是字符界面的 <code>Console</code> （可以用 <code>CTRL+ALT+F1~6</code> 切换），如果你发现当前 <code>Shell</code> 不是 <code>Bash</code>，请用下面的方法替换它：</p><pre class="line-numbers language-bash"><code class="language-bash">$ chsh <span class="token variable">$USER</span> -s /bin/bash
$ <span class="token function">su</span> <span class="token variable">$USER</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>或者是简单地键入Bash：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">bash</span>
$ <span class="token keyword">echo</span> <span class="token variable">$SHELL</span>  <span class="token comment" spellcheck="true"># 确认一下</span>
/bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>有了基本的运行环境，那么如何来运行用户键入的命令或者是用户编写好的脚本文件呢 <code>?</code></p><p>假设我们编写好了一个 Shell 脚本，叫 <code>test.sh</code> 。</p><p>第一种方法是确保我们执行的命令具有可执行权限，然后直接键入该命令执行它：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">chmod</span> +x /path/to/test.sh
$ /path/to/test.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第二种方法是直接把脚本作为 <code>Bash</code> 解释器的参数传入：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">bash</span> /path/to/test.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">source</span> /path/to/test.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">.</span> /path/to/test.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="基本语法介绍"><a href="#基本语法介绍" class="headerlink" title="基本语法介绍"></a>基本语法介绍</h3><p>先来一个 <code>Hello, World</code> 程序。</p><p>下面来介绍一个 Shell 程序的基本结构，以 <code>Hello, World</code> 为例：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span> -v
<span class="token comment" spellcheck="true"># test.sh</span>
<span class="token keyword">echo</span> <span class="token string">"Hello, World"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>把上述代码保存为 <code>test.sh</code>，然后通过上面两种不同方式运行，可以看到如下效果。</p><p>方法一：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">chmod</span> +x test.sh
$ ./test.sh
 ./test.sh
 <span class="token comment" spellcheck="true">#!/bin/bash -v</span>

 <span class="token keyword">echo</span> <span class="token string">"Hello, World"</span>
 Hello, World<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法二：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">bash</span> test.sh
Hello, World

$ <span class="token function">source</span> test.sh
Hello, World

$ <span class="token keyword">.</span> test.sh
Hello, World<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们发现两者运行结果有区别，为什么呢？这里我们需要关注一下 <code>test.sh</code> 文件的内容，它仅仅有两行，第二行打印了 <code>Hello, World</code>，两种方法都达到了目的，但是第一种方法却多打印了脚本文件本身的内容，为什么呢？</p><p>原因在该文件的第一行，当我们直接运行该脚本文件时，该行告诉操作系统使用用<code>#!</code> 符号之后面的解释器以及相应的参数来解释该脚本文件，通过分析第一行，我们发现对应的解释器以及参数是 <code>/bin/bash -v</code>，而 <code>-v</code> 刚好就是要打印程序的源代码；但是我们在用第二种方法时没有给 <code>Bash</code> 传递任何额外的参数，因此，它仅仅解释了脚本文件本身。</p><p>其他语法细节请直接看每一章小结后的附录。</p><h3 id="Shell-程序设计过程"><a href="#Shell-程序设计过程" class="headerlink" title="Shell 程序设计过程"></a>Shell 程序设计过程</h3><p>Shell 语言作为解释型语言，它的程序设计过程跟编译型语言有些区别，其基本过程如下：</p><ul><li>设计算法</li><li>用 Shell 编写脚本程序实现算法</li><li>直接运行脚本程序</li></ul><p>可见它没有编译型语言的”麻烦的”编译和链接过程，不过正是因为这样，它出错时调试起来不是很方便，因为语法错误和逻辑错误都在运行时出现。下面我们简单介绍一下调试方法。</p><h3 id="调试方法介绍"><a href="#调试方法介绍" class="headerlink" title="调试方法介绍"></a>调试方法介绍</h3><p>可以直接参考资料：<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-shell-debug/index.html">Shell 脚本调试技术</a> 或者 <a href="http://www.tinylab.org/bash-debugging-tools/">BASH 的调试手段</a>。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Shell 语言作为一门解释型语言，可以使用大量的现有工具，包括数值计算、符号处理、文件操作、网络操作等，因此，编写过程可能更加高效，但是因为它是解释型的，需要在执行过程中从磁盘上不断调用外部的程序并进行进程之间的切换，在运行效率方面可能有劣势，所以我们应该根据应用场合选择使用 Shell 或是用其他的语言来编程。</p><h2 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这一小节开始，打算结合平时积累和进一步实践，通过一些范例来介绍Shell编程。因为范例往往能够给人以学有所用的感觉，而且给人以动手实践的机会，从而激发人的学习热情。</p><p>考虑到易读性，这些范例将非常简单，但是实用，希望它们能够成为我们解决日常问题的参照物或者是“茶余饭后”的小点心，当然这些“点心”肯定还有值得探讨、优化的地方。</p><p>概要：</p><ul><li>目的：享受用 Shell 解决问题的乐趣；和朋友们一起交流和探讨。</li><li>读者：熟悉 Linux 基本知识，如文件系统结构、常用命令行工具、Shell 编程基础等。</li><li>补充：看范例时，可参考<a href="http://bbs.chinaunix.net/forum.php?mod=viewthread&tid=2198159">《Shell基础十二篇》</a>和<a href="http://bbs.chinaunix.net/thread-218853-1-1.html">《Shell十三问》</a>。</li><li>环境：如没特别说明，该系列使用的 Shell 将特指 Bash，版本在 3.1.17 以上。</li><li>说明：该系列不是依据 Shell 语法组织，而是面向某些潜在的操作对象和操作本身，它们反应了现实应用。当然，在这个过程中肯定会涉及到 Shell 的语法。</li></ul><p>这一小节打算讨论一下 Shell 编程中的基本数值运算，这类运算包括：</p><ul><li>数值（包括整数和浮点数）间的加、减、乘、除、求幂、求模等</li><li>产生指定范围的随机数</li><li>产生指定范围的数列</li></ul><p>Shell 本身可以做整数运算，复杂一些的运算要通过外部命令实现，比如 <code>expr</code>，<code>bc</code>，<code>awk</code> 等。另外，可通过 <code>RANDOM</code> 环境变量产生一个从 0 到 32767 的随机数，一些外部工具，比如 <code>awk</code> 可以通过 <code>rand()</code> 函数产生随机数。而 <code>seq</code> 命令可以用来产生一个数列。下面对它们分别进行介绍。</p><h3 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h3><h4 id="范例：对某个数加-1"><a href="#范例：对某个数加-1" class="headerlink" title="范例：对某个数加 1"></a>范例：对某个数加 1</h4><pre class="line-numbers language-bash"><code class="language-bash">$ i<span class="token operator">=</span>0<span class="token punctuation">;</span>
$ <span class="token variable"><span class="token punctuation">((</span>i<span class="token operator">++</span><span class="token punctuation">))</span></span>
$ <span class="token keyword">echo</span> <span class="token variable">$i</span>
1

$ <span class="token keyword">let</span> i++
$ <span class="token keyword">echo</span> <span class="token variable">$i</span>
2

$ <span class="token function">expr</span> <span class="token variable">$i</span> + 1
3
$ <span class="token keyword">echo</span> <span class="token variable">$i</span>
2

$ <span class="token keyword">echo</span> <span class="token variable">$i</span> 1 <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{printf <span class="token variable">$1</span>+<span class="token variable">$2</span>}'</span>
3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明： <code>expr</code> 之后的 <code>$i</code>，<code>+</code>，1 之间有空格分开。如果进行乘法运算，需要对运算符进行转义，否则 Shell 会把乘号解释为通配符，导致语法错误； <code>awk</code> 后面的 <code>$1</code> 和 <code>$2</code> 分别指 <code>$i</code> 和 1，即从左往右的第 1 个和第 2 个数。</p><p>用 Shell 的内置命令查看各个命令的类型如下：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">type</span> <span class="token function">type</span>
<span class="token function">type</span> is a shell <span class="token function">builtin</span>
$ <span class="token function">type</span> <span class="token keyword">let</span>
<span class="token keyword">let</span> is a shell <span class="token function">builtin</span>
$ <span class="token function">type</span> <span class="token function">expr</span>
<span class="token function">expr</span> is hashed <span class="token punctuation">(</span>/usr/bin/expr<span class="token punctuation">)</span>
$ <span class="token function">type</span> <span class="token function">bc</span>
<span class="token function">bc</span> is hashed <span class="token punctuation">(</span>/usr/bin/bc<span class="token punctuation">)</span>
$ <span class="token function">type</span> <span class="token function">awk</span>
<span class="token function">awk</span> is /usr/bin/awk<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上述演示可看出： <code>let</code> 是 Shell 内置命令，其他几个是外部命令，都在 <code>/usr/bin</code> 目录下。而 <code>expr</code> 和 <code>bc</code> 因为刚用过，已经加载在内存的 <code>hash</code> 表中。这将有利于我们理解在上一章介绍的脚本多种执行方法背后的原理。</p><p>说明：如果要查看不同命令的帮助，对于 <code>let</code> 和 <code>type</code> 等 Shell 内置命令，可以通过 Shell 的一个内置命令 <code>help</code> 来查看相关帮助，而一些外部命令可以通过 Shell 的一个外部命令 <code>man</code> 来查看帮助，用法诸如 <code>help let</code>，<code>man expr</code> 等。</p><h4 id="范例：从-1-加到某个数"><a href="#范例：从-1-加到某个数" class="headerlink" title="范例：从 1 加到某个数"></a>范例：从 1 加到某个数</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token comment" spellcheck="true"># calc.sh</span>

i<span class="token operator">=</span>0<span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token variable">$i</span> -lt 10000 <span class="token punctuation">]</span>
<span class="token keyword">do</span>
    <span class="token variable"><span class="token punctuation">((</span>i<span class="token operator">++</span><span class="token punctuation">))</span></span>
<span class="token keyword">done</span>
<span class="token keyword">echo</span> <span class="token variable">$i</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：这里通过 <code>while [ 条件表达式 ]; do .... done</code> 循环来实现。<code>-lt</code> 是小于号 <code>&lt;</code>，具体见 <code>test</code> 命令的用法：<code>help test</code>。</p><p>如何执行该脚本？</p><p>办法一：直接把脚本文件当成子 Shell （Bash）的一个参数传入</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">bash</span> calc.sh
$ <span class="token function">type</span> <span class="token function">bash</span>
<span class="token function">bash</span> is hashed <span class="token punctuation">(</span>/bin/bash<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>办法二：是通过 <code>bash</code> 的内置命令 <code>.</code> 或 <code>source</code> 执行</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">.</span> ./calc.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">source</span> ./calc.sh
$ <span class="token function">type</span> <span class="token keyword">.</span>
<span class="token keyword">.</span> is a shell <span class="token function">builtin</span>
$ <span class="token function">type</span> <span class="token function">source</span>
<span class="token function">source</span> is a shell <span class="token function">builtin</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>办法三：是修改文件为可执行，直接在当前 Shell 下执行</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">chmod</span> ./calc.sh
$ ./calc.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>下面，逐一演示用其他方法计算变量加一，即把 <code>((i++))</code> 行替换成下面的某一个：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">let</span> i++<span class="token punctuation">;</span>
i<span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">expr</span> $i + 1<span class="token variable">)</span></span>
i<span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token keyword">echo</span> $i+1<span class="token operator">|</span><span class="token function">bc</span><span class="token variable">)</span></span>
i<span class="token operator">=</span><span class="token punctuation">$(</span>echo <span class="token string">"<span class="token variable">$i</span> 1"</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{printf <span class="token variable">$1</span>+<span class="token variable">$2</span>;}'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>比较计算时间如下：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">time</span> calc.sh
10000

real    0m1.319s
user    0m1.056s
sys     0m0.036s
$ <span class="token function">time</span> calc_let.sh
10000

real    0m1.426s
user    0m1.176s
sys     0m0.032s
$  <span class="token function">time</span> calc_expr.sh
1000

real    0m27.425s
user    0m5.060s
sys     0m14.177s
$ <span class="token function">time</span> calc_bc.sh
1000

real    0m56.576s
user    0m9.353s
sys     0m24.618s
$ <span class="token function">time</span> ./calc_awk.sh
100

real    0m11.672s
user    0m2.604s
sys     0m2.660s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明： <code>time</code> 命令可以用来统计命令执行时间，这部分时间包括总的运行时间，用户空间执行时间，内核空间执行时间，它通过 <code>ptrace</code> 系统调用实现。</p><p>通过上述比较可以发现 <code>(())</code> 的运算效率最高。而 <code>let</code> 作为 Shell 内置命令，效率也很高，但是 <code>expr</code>，<code>bc</code>，<code>awk</code> 的计算效率就比较低。所以，在 Shell 本身能够完成相关工作的情况下，建议优先使用 Shell 本身提供的功能。但是 Shell 本身无法完成的功能，比如浮点运算，所以就需要外部命令的帮助。另外，考虑到 Shell 脚本的可移植性，在性能不是很关键的情况下，不要使用某些 Shell 特有的语法。</p><p><code>let</code>，<code>expr</code>，<code>bc</code> 都可以用来求模，运算符都是 <code>%</code>，而 <code>let</code> 和 <code>bc</code> 可以用来求幂，运算符不一样，前者是 <code>**</code>，后者是 <code>^</code> 。例如：</p><h4 id="范例：求模"><a href="#范例：求模" class="headerlink" title="范例：求模"></a>范例：求模</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">expr</span> 5 % 2
1

$ <span class="token keyword">let</span> i<span class="token operator">=</span>5%2
$ <span class="token keyword">echo</span> <span class="token variable">$i</span>
1

$ <span class="token keyword">echo</span> 5 % 2 <span class="token operator">|</span> <span class="token function">bc</span>
1

$ <span class="token variable"><span class="token punctuation">((</span>i<span class="token operator">=</span><span class="token number">5</span><span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">))</span></span>
$ <span class="token keyword">echo</span> <span class="token variable">$i</span>
1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="范例：求幂"><a href="#范例：求幂" class="headerlink" title="范例：求幂"></a>范例：求幂</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">let</span> i<span class="token operator">=</span>5**2
$ <span class="token keyword">echo</span> <span class="token variable">$i</span>
25

$ <span class="token variable"><span class="token punctuation">((</span>i<span class="token operator">=</span><span class="token number">5</span><span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">))</span></span>
$ <span class="token keyword">echo</span> <span class="token variable">$i</span>

25
$ <span class="token keyword">echo</span> <span class="token string">"5^2"</span> <span class="token operator">|</span> <span class="token function">bc</span>
25<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="范例：进制转换"><a href="#范例：进制转换" class="headerlink" title="范例：进制转换"></a>范例：进制转换</h4><p>进制转换也是比较常用的操作，可以用 <code>Bash</code> 的内置支持也可以用 <code>bc</code> 来完成，例如把 8 进制的 11 转换为 10 进制，则可以：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token string">"obase=10;ibase=8;11"</span> <span class="token operator">|</span> <span class="token function">bc</span> -l
9

$ <span class="token keyword">echo</span> <span class="token punctuation">$((</span>8<span class="token comment" spellcheck="true">#11))</span>
9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面都是把某个进制的数转换为 10 进制的，如果要进行任意进制之间的转换还是 <code>bc</code> 比较灵活，因为它可以直接用 <code>ibase</code> 和 <code>obase</code> 分别指定进制源和进制转换目标。</p><h4 id="范例：ascii-字符编码"><a href="#范例：ascii-字符编码" class="headerlink" title="范例：ascii 字符编码"></a>范例：ascii 字符编码</h4><p>如果要把某些字符串以特定的进制表示，可以用 <code>od</code> 命令，例如默认的分隔符 <code>IFS</code> 包括空格、 <code>TAB</code> 以及换行，可以用 <code>man ascii</code> 佐证。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> -n <span class="token string">"<span class="token variable">$IFS</span>"</span> <span class="token operator">|</span> od -c
0000000      t  n
0000003
$ <span class="token keyword">echo</span> -n <span class="token string">"<span class="token variable">$IFS</span>"</span> <span class="token operator">|</span> od -b
0000000 040 011 012
0000003<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h3><p><code>let</code> 和 <code>expr</code> 都无法进行浮点运算，但是 <code>bc</code> 和 <code>awk</code> 可以。</p><h4 id="范例：求-1-除以-13，保留-3-位有效数字"><a href="#范例：求-1-除以-13，保留-3-位有效数字" class="headerlink" title="范例：求 1 除以 13，保留 3 位有效数字"></a>范例：求 1 除以 13，保留 3 位有效数字</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token string">"scale=3; 1/13"</span>  <span class="token operator">|</span> <span class="token function">bc</span>
.076

$ <span class="token keyword">echo</span> <span class="token string">"1 13"</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{printf("%0.3f\n",<span class="token variable">$1</span>/<span class="token variable">$2</span>)}'</span>
0.077<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明： <code>bc</code> 在进行浮点运算时需指定精度，否则默认为 0，即进行浮点运算时，默认结果只保留整数。而 <code>awk</code> 在控制小数位数时非常灵活，仅仅通过 <code>printf</code> 的格式控制就可以实现。</p><p>补充：在用 <code>bc</code> 进行运算时，如果不用 <code>scale</code> 指定精度，而在 <code>bc</code> 后加上 <code>-l</code> 选项，也可以进行浮点运算，只不过这时的默认精度是 20 位。例如：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> 1/13100 <span class="token operator">|</span> <span class="token function">bc</span> -l
.00007633587786259541<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="范例：余弦值转角度"><a href="#范例：余弦值转角度" class="headerlink" title="范例：余弦值转角度"></a>范例：余弦值转角度</h4><p>用 <code>bc -l</code> 计算，可以获得高精度：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">export</span> cos<span class="token operator">=</span>0.996293<span class="token punctuation">;</span> <span class="token keyword">echo</span> <span class="token string">"scale=100; a(sqrt(1-<span class="token variable">$cos</span>^2)/<span class="token variable">$cos</span>)*180/(a(1)*4)"</span> <span class="token operator">|</span> <span class="token function">bc</span> -l
4.934954755411383632719834036931840605159706398655243875372764917732
5495504159766011527078286004072131<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当然也可以用 <code>awk</code> 来计算：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> 0.996293 <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{ printf("%s\n", atan2(sqrt(1-<span class="token variable">$1</span>^2),<span class="token variable">$1</span>)*180/3.1415926535);}'</span>
4.93495<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="范例：有一组数据，求人均月收入最高家庭"><a href="#范例：有一组数据，求人均月收入最高家庭" class="headerlink" title="范例：有一组数据，求人均月收入最高家庭"></a>范例：有一组数据，求人均月收入最高家庭</h4><p>在这里随机产生了一组测试数据，文件名为 <code>income.txt</code>。</p><pre class="line-numbers language-bash"><code class="language-bash">1 3 4490
2 5 3896
3 4 3112
4 4 4716
5 4 4578
6 6 5399
7 3 5089
8 6 3029
9 4 6195
10 5 5145<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：上面的三列数据分别是家庭编号、家庭人数、家庭月总收入。</p><p>分析：为了求月均收入最高家庭，需要对后面两列数进行除法运算，即求出每个家庭的月均收入，然后按照月均收入排序，找出收入最高家庭。</p><p>实现：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token comment" spellcheck="true"># gettopfamily.sh</span>

<span class="token punctuation">[</span> $<span class="token comment" spellcheck="true"># -lt 1 ] &amp;&amp; echo "please input the income file" &amp;&amp; exit -1</span>
<span class="token punctuation">[</span> <span class="token operator">!</span> -f <span class="token variable">$1</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">echo</span> <span class="token string">"<span class="token variable">$1</span> is not a file"</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">exit</span> -1

income<span class="token operator">=</span><span class="token variable">$1</span>
<span class="token function">awk</span> <span class="token string">'{
    printf("%d %0.2f\n", <span class="token variable">$1</span>, <span class="token variable">$3</span>/<span class="token variable">$2</span>);
}'</span> <span class="token variable">$income</span> <span class="token operator">|</span> <span class="token function">sort</span> -k 2 -n -r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><ul><li><code>[ $# -lt 1 ]</code>：要求至少输入一个参数，<code>$#</code> 是 Shell 中传入参数的个数</li><li><code>[ ! -f $1 ]</code>：要求输入参数是一个文件，<code>-f</code> 的用法见 <code>test</code> 命令，<code>help test</code></li><li><code>income=$1</code>：把输入参数赋给 income 变量，再作为 <code>awk</code> 的参数，即需处理的文件</li><li><code>awk</code>：用文件第三列除以第二列，求出月均收入，考虑到精确性，保留了两位精度</li><li><code>sort -k 2 -n -r</code>：这里对结果的 <code>awk</code> 结果的第二列 <code>-k 2</code>，即月均收入进行排序，按照数字排序 <code>-n</code>，并按照递减的顺序排序 <code>-r</code>。</li></ul><p>演示：</p><pre class="line-numbers language-bash"><code class="language-bash">$ ./gettopfamily.sh income.txt
7 1696.33
9 1548.75
1 1496.67
4 1179.00
5 1144.50
10 1029.00
6 899.83
2 779.20
3 778.00
8 504.83<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>补充：之前的 <code>income.txt</code> 数据是随机产生的。在做一些实验时，往往需要随机产生一些数据，在下一小节，我们将详细介绍它。这里是产生 <code>income.txt</code> 数据的脚本：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token comment" spellcheck="true"># genrandomdata.sh</span>

<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">seq</span> 1 10<span class="token variable">)</span></span>
<span class="token keyword">do</span>
    <span class="token keyword">echo</span> <span class="token variable">$i</span> <span class="token variable"><span class="token variable">$((</span>$RANDOM<span class="token operator">/</span><span class="token number">8192</span><span class="token operator">+</span><span class="token number">3</span><span class="token variable">))</span></span> <span class="token variable"><span class="token variable">$((</span>RANDOM<span class="token operator">/</span><span class="token number">10</span><span class="token operator">+</span><span class="token number">3000</span><span class="token variable">))</span></span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：上述脚本中还用到<code>seq</code>命令产生从1到10的一列数，这个命令的详细用法在该篇最后一节也会进一步介绍。</p><h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><p>环境变量 <code>RANDOM</code> 产生从 0 到 32767 的随机数，而 <code>awk</code> 的 <code>rand()</code> 函数可以产生 0 到 1 之间的随机数。</p><h4 id="范例：获取一个随机数"><a href="#范例：获取一个随机数" class="headerlink" title="范例：获取一个随机数"></a>范例：获取一个随机数</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$RANDOM</span>
81

$ <span class="token keyword">echo</span> <span class="token string">""</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{srand(); printf("%f", rand());}'</span>
0.237788<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明： <code>srand()</code> 在无参数时，采用当前时间作为 <code>rand()</code> 随机数产生器的一个 <code>seed</code> 。</p><h4 id="范例：随机产生一个从-0-到-255-之间的数字"><a href="#范例：随机产生一个从-0-到-255-之间的数字" class="headerlink" title="范例：随机产生一个从 0 到 255 之间的数字"></a>范例：随机产生一个从 0 到 255 之间的数字</h4><p>可以通过 <code>RANDOM</code> 变量的缩放和 <code>awk</code> 中 <code>rand()</code> 的放大来实现。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">expr</span> <span class="token variable">$RANDOM</span> / 128

$ <span class="token keyword">echo</span> <span class="token string">""</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{srand(); printf("%d\n", rand()*255);}'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>思考：如果要随机产生某个 IP 段的 IP 地址，该如何做呢？看例子：友善地获取一个可用的 IP 地址。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token comment" spellcheck="true"># getip.sh -- get an usable ipaddress automatically</span>
<span class="token comment" spellcheck="true"># author: falcon &amp;lt;zhangjinw@gmail.com></span>
<span class="token comment" spellcheck="true"># update: Tue Oct 30 23:46:17 CST 2007</span>

<span class="token comment" spellcheck="true"># set your own network, default gateway, and the time out of "ping" command</span>
net<span class="token operator">=</span><span class="token string">"192.168.1"</span>
default_gateway<span class="token operator">=</span><span class="token string">"192.168.1.1"</span>
over_time<span class="token operator">=</span>2

<span class="token comment" spellcheck="true"># check the current ipaddress</span>
<span class="token function">ping</span> -c 1 <span class="token variable">$default_gateway</span> -W <span class="token variable">$over_time</span>
<span class="token punctuation">[</span> <span class="token variable">$?</span> -eq 0 <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">echo</span> <span class="token string">"the current ipaddress is okey!"</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">exit</span> -1<span class="token punctuation">;</span>

<span class="token keyword">while</span> <span class="token keyword">:</span><span class="token punctuation">;</span> <span class="token keyword">do</span>
    <span class="token comment" spellcheck="true"># clear the current configuration</span>
    <span class="token function">ifconfig</span> eth0 down
    <span class="token comment" spellcheck="true"># configure the ip address of the eth0</span>
    <span class="token function">ifconfig</span> eth0 \
        <span class="token variable">$net</span><span class="token keyword">.</span><span class="token variable"><span class="token variable">$((</span>$RANDOM <span class="token operator">/</span><span class="token number">130</span> <span class="token operator">+</span><span class="token number">2</span><span class="token variable">))</span></span> \
        up
    <span class="token comment" spellcheck="true"># configure the default gateway</span>
    route add default gw <span class="token variable">$default_gateway</span>
    <span class="token comment" spellcheck="true"># check the new configuration</span>
    <span class="token function">ping</span> -c 1 <span class="token variable">$default_gateway</span> -W <span class="token variable">$over_time</span>
    <span class="token comment" spellcheck="true"># if work, finish</span>
    <span class="token punctuation">[</span> <span class="token variable">$?</span> -eq 0 <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">break</span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：如果你的默认网关地址不是 <code>192.168.1.1</code>，请自行配置 <code>default_gateway</code>（可以用 <code>route -n</code> 命令查看），因为用 <code>ifconfig</code> 配置地址时不能配置为网关地址，否则你的IP地址将和网关一样，导致整个网络不能正常工作。</p><h3 id="其他运算"><a href="#其他运算" class="headerlink" title="其他运算"></a>其他运算</h3><p>其实通过一个循环就可以产生一系列数，但是有相关工具为什么不用呢！<code>seq</code> 就是这么一个小工具，它可以产生一系列数，你可以指定数的递增间隔，也可以指定相邻两个数之间的分割符。</p><h4 id="范例：获取一系列数"><a href="#范例：获取一系列数" class="headerlink" title="范例：获取一系列数"></a>范例：获取一系列数</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">seq</span> 5
1
2
3
4
5
$ <span class="token function">seq</span> 1 5
1
2
3
4
5
$ <span class="token function">seq</span> 1 2 5
1
3
5
$ <span class="token function">seq</span> -s: 1 2 5
1:3:5
$ <span class="token function">seq</span> 1 2 14
1
3
5
7
9
11
13
$ <span class="token function">seq</span> -w 1 2 14
01
03
05
07
09
11
13
$ <span class="token function">seq</span> -s: -w 1 2 14
01:03:05:07:09:11:13
$ <span class="token function">seq</span> -f <span class="token string">"0x%g"</span> 1 5
0x1
0x2
0x3
0x4
0x5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个比较典型的使用 <code>seq</code> 的例子，构造一些特定格式的链接，然后用 <code>wget</code> 下载这些内容：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">for</span> i <span class="token keyword">in</span> `seq -f<span class="token string">"http://thns.tsinghua.edu.cn/thnsebooks/ebook73/%02g.pdf"</span> 1 21`<span class="token punctuation">;</span><span class="token keyword">do</span> <span class="token function">wget</span> -c <span class="token variable">$i</span><span class="token punctuation">;</span> <span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token variable"><span class="token variable">`</span><span class="token function">seq</span> -w 1 21<span class="token variable">`</span></span><span class="token punctuation">;</span><span class="token keyword">do</span> <span class="token function">wget</span> -c <span class="token string">"http://thns.tsinghua.edu.cn/thnsebooks/ebook73/<span class="token variable">$i</span>"</span><span class="token punctuation">;</span> <span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>补充：在 <code>Bash</code> 版本 3 以上，在 <code>for</code> 循环的 <code>in</code> 后面，可以直接通过 <code>{1..5}</code> 更简洁地产生自 1 到 5 的数字（注意，1 和 5 之间只有两个点），例如：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token punctuation">{</span>1<span class="token punctuation">..</span>5<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token keyword">echo</span> -n <span class="token string">"<span class="token variable">$i</span> "</span><span class="token punctuation">;</span> <span class="token keyword">done</span>
1 2 3 4 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="范例：统计字符串中各单词出现次数"><a href="#范例：统计字符串中各单词出现次数" class="headerlink" title="范例：统计字符串中各单词出现次数"></a>范例：统计字符串中各单词出现次数</h4><p>我们先给单词一个定义：由字母组成的单个或者多个字符系列。</p><p>首先，统计每个单词出现的次数：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">wget</span> -c http://tinylab.org
$ <span class="token function">cat</span> index.html <span class="token operator">|</span> <span class="token function">sed</span> -e <span class="token string">"s/[^a-zA-Z]/\n/g"</span> <span class="token operator">|</span> <span class="token function">grep</span> -v ^$ <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">uniq</span> -c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>接着，统计出现频率最高的前10个单词：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">wget</span> -c http://tinylab.org
$ <span class="token function">cat</span> index.html <span class="token operator">|</span> <span class="token function">sed</span> -e <span class="token string">"s/[^a-zA-Z]/\n/g"</span> <span class="token operator">|</span> <span class="token function">grep</span> -v ^$ <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">uniq</span> -c <span class="token operator">|</span> <span class="token function">sort</span> -n -k 1 -r <span class="token operator">|</span> <span class="token function">head</span> -10
    524 a
    238 tag
    205 href
    201 class
    193 http
    189 org
    175 tinylab
    174 www
    146 div
    128 title<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><ul><li><code>cat index.html</code>: 输出 index.html 文件里的内容</li><li><code>sed -e &quot;s/[^a-zA-Z]/\n/g&quot;</code>: 把非字母字符替换成空格，只保留字母字符</li><li><code>grep -v ^$</code>: 去掉空行</li><li><code>sort</code>: 排序</li><li><code>uniq -c</code>：统计相同行的个数，即每个单词的个数</li><li><code>sort -n -k 1 -r</code>：按照第一列 <code>-k 1</code> 的数字 <code>-n</code> 逆序 <code>-r</code> 排序</li><li><code>head -10</code>：取出前十行</li></ul><h4 id="范例：统计指定单词出现次数"><a href="#范例：统计指定单词出现次数" class="headerlink" title="范例：统计指定单词出现次数"></a>范例：统计指定单词出现次数</h4><p>可以考虑采取两种办法：</p><ul><li>只统计那些需要统计的单词</li><li>用上面的算法把所有单词的个数都统计出来，然后再返回那些需要统计的单词给用户</li></ul><p>不过，这两种办法都可以通过下面的结构来实现。先看办法一：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token comment" spellcheck="true"># statistic_words.sh</span>

<span class="token keyword">if</span> <span class="token punctuation">[</span> $<span class="token comment" spellcheck="true"># -lt 1 ]; then</span>
    <span class="token keyword">echo</span> <span class="token string">"Usage: basename <span class="token variable">$0</span> FILE WORDS ...."</span>
    <span class="token keyword">exit</span> -1
<span class="token keyword">fi</span>

FILE<span class="token operator">=</span><span class="token variable">$1</span>
<span class="token punctuation">((</span>WORDS_NUM<span class="token operator">=</span>$<span class="token comment" spellcheck="true">#-1))</span>

<span class="token keyword">for</span> n <span class="token keyword">in</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">seq</span> $WORDS_NUM<span class="token variable">)</span></span>
<span class="token keyword">do</span>
    <span class="token function">shift</span>
    <span class="token function">cat</span> <span class="token variable">$FILE</span> <span class="token operator">|</span> <span class="token function">sed</span> -e <span class="token string">"s/[^a-zA-Z]/\n/g"</span> \
        <span class="token operator">|</span> <span class="token function">grep</span> -v ^$ <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">grep</span> ^<span class="token variable">$1</span>$ <span class="token operator">|</span> <span class="token function">uniq</span> -c
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><ul><li><code>if 条件部分</code>：要求至少两个参数，第一个单词文件，之后参数为要统计的单词</li><li><code>FILE=$1</code>: 获取文件名，即脚本之后的第一个字符串</li><li><code>((WORDS_NUM=$#-1))</code>：获取单词个数，即总的参数个数 <code>$#</code> 减去文件名参数（1个）</li><li><code>for 循环部分</code>：首先通过 <code>seq</code> 产生需要统计的单词个数系列，<code>shift</code> 是 Shell 内置变量（请通过 <code>help shift</code> 获取帮助)，它把用户从命令行中传入的参数依次往后移动位置，并把当前参数作为第一个参数即 <code>$1</code>，这样通过 <code>$1</code>就可以遍历用户所有输入的单词（仔细一想，这里貌似有数组下标的味道）。你可以考虑把 <code>shift</code> 之后的那句替换成 <code>echo $1</code> 测试 <code>shift</code> 的用法</li></ul><p>演示：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">chmod</span> +x statistic_words.sh
$ ./statistic_words.sh index.html tinylab linux python
    175 tinylab
     43 linux
      3 python<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再看办法二，我们只需要修改 <code>shift</code> 之后的那句即可：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token comment" spellcheck="true"># statistic_words.sh</span>

<span class="token keyword">if</span> <span class="token punctuation">[</span> $<span class="token comment" spellcheck="true"># -lt 1 ]; then</span>
    <span class="token keyword">echo</span> <span class="token string">"ERROR: you should input 2 words at least"</span><span class="token punctuation">;</span>
    <span class="token keyword">echo</span> <span class="token string">"Usage: basename <span class="token variable">$0</span> FILE WORDS ...."</span>
    <span class="token keyword">exit</span> -1
<span class="token keyword">fi</span>

FILE<span class="token operator">=</span><span class="token variable">$1</span>
<span class="token punctuation">((</span>WORDS_NUM<span class="token operator">=</span>$<span class="token comment" spellcheck="true">#-1))</span>

<span class="token keyword">for</span> n <span class="token keyword">in</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">seq</span> $WORDS_NUM<span class="token variable">)</span></span>
<span class="token keyword">do</span>
    <span class="token function">shift</span>
    <span class="token function">cat</span> <span class="token variable">$FILE</span> <span class="token operator">|</span> <span class="token function">sed</span> -e <span class="token string">"s/[^a-zA-Z]/\n/g"</span> \
        <span class="token operator">|</span> <span class="token function">grep</span> -v ^$ <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">uniq</span> -c <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">" <span class="token variable">$1</span>$"</span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>演示：</p><pre class="line-numbers language-bash"><code class="language-bash">$ ./statistic_words.sh index.html tinylab linux python
    175 tinylab
     43 linux
      3 python<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>说明：很明显，办法一的效率要高很多，因为它提前找出了需要统计的单词，然后再统计，而后者则不然。实际上，如果使用 <code>grep</code> 的 <code>-E</code> 选项，我们无须引入循环，而用一条命令就可以搞定：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> index.html <span class="token operator">|</span> <span class="token function">sed</span> -e <span class="token string">"s/[^a-zA-Z]/\n/g"</span> <span class="token operator">|</span> <span class="token function">grep</span> -v ^$ <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">grep</span> -E <span class="token string">"^tinylab$|^linux$"</span> <span class="token operator">|</span> <span class="token function">uniq</span> -c
     43 linux
    175 tinylab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> index.html <span class="token operator">|</span> <span class="token function">sed</span> -e <span class="token string">"s/[^a-zA-Z]/\n/g"</span> <span class="token operator">|</span> <span class="token function">grep</span> -v ^$ <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">egrep</span>  <span class="token string">"^tinylab$|^linux$"</span> <span class="token operator">|</span> <span class="token function">uniq</span> -c
     43 linux
    175 tinylab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>说明：需要注意到 <code>sed</code> 命令可以直接处理文件，而无需通过 <code>cat</code> 命令输出以后再通过管道传递，这样可以减少一个不必要的管道操作，所以上述命令可以简化为：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sed</span> -e <span class="token string">"s/[^a-zA-Z]/\n/g"</span> index.html <span class="token operator">|</span> <span class="token function">grep</span> -v ^$ <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">egrep</span>  <span class="token string">"^tinylab$|^linux$"</span> <span class="token operator">|</span> <span class="token function">uniq</span> -c
     43 linux
    175 tinylab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>所以，可见这些命令 <code>sed</code>，<code>grep</code>，<code>uniq</code>，<code>sort</code> 是多么有用，它们本身虽然只完成简单的功能，但是通过一定的组合，就可以实现各种五花八门的事情啦。对了，统计单词还有个非常有用的命令 <code>wc -w</code>，需要用到的时候也可以用它。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>到这里，Shell 编程范例之数值计算就结束啦。该小节主要介绍了：</p><ul><li>Shell 编程中的整数运算、浮点运算、随机数的产生、数列的产生</li><li>Shell 的内置命令、外部命令的区别，以及如何查看他们的类型和帮助</li><li>Shell 脚本的几种执行办法</li><li>几个常用的 Shell 外部命令： <code>sed</code>，<code>awk</code>，<code>grep</code>，<code>uniq</code>，<code>sort</code> 等</li><li>范例：数字递增；求月均收入；自动获取 <code>IP</code> 地址；统计单词个数</li><li>其他：相关用法如命令列表，条件测试等在上述范例中都已涉及，请认真阅读之</li></ul><h2 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>在 Bash 里有这样的常量(实际上是两个内置命令，在这里我们姑且这么认为，后面将介绍)，即 true 和 false，一个表示真，一个表示假。对它们可以进行与、或、非运算等常规的逻辑运算，在这一节，我们除了讨论这些基本逻辑运算外，还将讨论Shell编程中的<strong>条件测试</strong>和<strong>命令列表</strong>，并介绍它们和布尔运算的关系。</p><h3 id="常规的布尔运算"><a href="#常规的布尔运算" class="headerlink" title="常规的布尔运算"></a>常规的布尔运算</h3><p>这里主要介绍 <code>Bash</code> 里头常规的逻辑运算，与、或、非。</p><h4 id="在-Shell-下如何进行逻辑运算"><a href="#在-Shell-下如何进行逻辑运算" class="headerlink" title="在 Shell 下如何进行逻辑运算"></a>在 Shell 下如何进行逻辑运算</h4><h5 id="范例：true-or-false"><a href="#范例：true-or-false" class="headerlink" title="范例：true or false"></a>范例：true or false</h5><p>单独测试 <code>true</code> 和 <code>false</code>，可以看出 <code>true</code> 是真值，<code>false</code> 为假</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">if</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
YES
$ <span class="token keyword">if</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
NO<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="范例：与运算"><a href="#范例：与运算" class="headerlink" title="范例：与运算"></a>范例：与运算</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">if</span> <span class="token boolean">true</span> <span class="token operator">&amp;&amp;</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
YES
$ <span class="token keyword">if</span> <span class="token boolean">true</span> <span class="token operator">&amp;&amp;</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
NO
$ <span class="token keyword">if</span> <span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
NO
$ <span class="token keyword">if</span> <span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
NO<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="范例：或运算"><a href="#范例：或运算" class="headerlink" title="范例：或运算"></a>范例：或运算</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">if</span> <span class="token boolean">true</span> <span class="token operator">||</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
YES
$ <span class="token keyword">if</span> <span class="token boolean">true</span> <span class="token operator">||</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
YES
$ <span class="token keyword">if</span> <span class="token boolean">false</span> <span class="token operator">||</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
YES
$ <span class="token keyword">if</span> <span class="token boolean">false</span> <span class="token operator">||</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
NO<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="范例：非运算，即取反"><a href="#范例：非运算，即取反" class="headerlink" title="范例：非运算，即取反"></a>范例：非运算，即取反</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">if</span> <span class="token operator">!</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
YES
$ <span class="token keyword">if</span> <span class="token operator">!</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
NO<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出 <code>true</code> 和 <code>false</code> 按照我们对逻辑运算的理解进行着，但是为了能够更好的理解 Shell 对逻辑运算的实现，我们还得弄清楚，<code>true</code> 和 <code>false</code> 是怎么工作的？</p><h4 id="Bash-里头的-true-和-false-是我们通常认为的-1-和-0-么？"><a href="#Bash-里头的-true-和-false-是我们通常认为的-1-和-0-么？" class="headerlink" title="Bash 里头的 true 和 false 是我们通常认为的 1 和 0 么？"></a>Bash 里头的 true 和 false 是我们通常认为的 1 和 0 么？</h4><p>回答是：否。</p><h5 id="范例：返回值-v-s-逻辑值"><a href="#范例：返回值-v-s-逻辑值" class="headerlink" title="范例：返回值 v.s. 逻辑值"></a>范例：返回值 v.s. 逻辑值</h5><p><code>true</code> 和 <code>false</code> 它们本身并非逻辑值，它们都是 Shell 的内置命令，只是它们的返回值是一个“逻辑值”：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token boolean">true</span>
$ <span class="token keyword">echo</span> <span class="token variable">$?</span>
0
$ <span class="token boolean">false</span>
$ <span class="token keyword">echo</span> <span class="token variable">$?</span>
1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到 <code>true</code> 返回了 0，而 <code>false</code> 则返回了 1 。跟我们离散数学里学的真值 1 和 0 并不是对应的，而且相反的。</p><h5 id="范例：查看-true-和-false-帮助和类型"><a href="#范例：查看-true-和-false-帮助和类型" class="headerlink" title="范例：查看 true 和 false 帮助和类型"></a>范例：查看 true 和 false 帮助和类型</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">help</span> <span class="token boolean">true</span> <span class="token boolean">false</span>
true: <span class="token boolean">true</span>
     Return a successful result.
false: <span class="token boolean">false</span>
     Return an unsuccessful result.
$ <span class="token function">type</span> <span class="token boolean">true</span> <span class="token boolean">false</span>
<span class="token boolean">true</span> is a shell <span class="token function">builtin</span>
<span class="token boolean">false</span> is a shell <span class="token function">builtin</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：<code>$?</code> 是一个特殊变量，存放有上一次进程的结束状态（退出状态码）。</p><p>从上面的操作不难联想到在 C 语言程序设计中为什么会强调在 <code>main</code> 函数前面加上 <code>int</code>，并在末尾加上 <code>return 0</code> 。因为在 Shell 里，将把 0 作为程序是否成功结束的标志，这就是 Shell 里头 <code>true</code> 和 <code>false</code> 的实质，它们用以反应某个程序是否正确结束，而并非传统的真假值（1 和 0），相反地，它们返回的是 0 和 1 。不过庆幸地是，我们在做逻辑运算时，无须关心这些。</p><h3 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h3><p>从上节中，我们已经清楚地了解了 Shell 下的“逻辑值”是什么：是进程退出时的返回值，如果成功返回，则为真，如果不成功返回，则为假。</p><p>而条件测试正好使用了 <code>test</code> 这么一个指令，它用来进行数值测试（各种数值属性测试）、字符串测试（各种字符串属性测试）、文件测试（各种文件属性测试），我们通过判断对应的测试是否成功，从而完成各种常规工作，再加上各种测试的逻辑组合后，将可以完成更复杂的工作。</p><h4 id="条件测试基本使用"><a href="#条件测试基本使用" class="headerlink" title="条件测试基本使用"></a>条件测试基本使用</h4><h5 id="范例：数值测试"><a href="#范例：数值测试" class="headerlink" title="范例：数值测试"></a>范例：数值测试</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">if</span> <span class="token function">test</span> 5 -eq 5<span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
YES
$ <span class="token keyword">if</span> <span class="token function">test</span> 5 -ne 5<span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
NO<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="范例：字符串测试"><a href="#范例：字符串测试" class="headerlink" title="范例：字符串测试"></a>范例：字符串测试</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">if</span> <span class="token function">test</span> -n <span class="token string">"not empty"</span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
YES
$ <span class="token keyword">if</span> <span class="token function">test</span> -z <span class="token string">"not empty"</span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
NO
$ <span class="token keyword">if</span> <span class="token function">test</span> -z <span class="token string">""</span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
YES
$ <span class="token keyword">if</span> <span class="token function">test</span> -n <span class="token string">""</span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
NO<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="范例：文件测试"><a href="#范例：文件测试" class="headerlink" title="范例：文件测试"></a>范例：文件测试</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">if</span> <span class="token function">test</span> -f /boot/System.map<span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
YES
$ <span class="token keyword">if</span> <span class="token function">test</span> -d /boot/System.map<span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
NO<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="各种逻辑测试的组合"><a href="#各种逻辑测试的组合" class="headerlink" title="各种逻辑测试的组合"></a>各种逻辑测试的组合</h4><h5 id="范例：如果-a，b，c-都等于下面对应的值，那么打印-YES，通过-a-进行”与”测试"><a href="#范例：如果-a，b，c-都等于下面对应的值，那么打印-YES，通过-a-进行”与”测试" class="headerlink" title="范例：如果 a，b，c 都等于下面对应的值，那么打印 YES，通过 -a 进行”与”测试"></a>范例：如果 a，b，c 都等于下面对应的值，那么打印 YES，通过 -a 进行”与”测试</h5><pre class="line-numbers language-bash"><code class="language-bash">$ a<span class="token operator">=</span>5<span class="token punctuation">;</span>b<span class="token operator">=</span>4<span class="token punctuation">;</span>c<span class="token operator">=</span>6<span class="token punctuation">;</span>
$ <span class="token keyword">if</span> <span class="token function">test</span> <span class="token variable">$a</span> -eq 5 -a <span class="token variable">$b</span> -eq 4 -a <span class="token variable">$c</span> -eq 6<span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
YES<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="范例：测试某个“东西”是文件或者目录，通过-o-进行“或”运算"><a href="#范例：测试某个“东西”是文件或者目录，通过-o-进行“或”运算" class="headerlink" title="范例：测试某个“东西”是文件或者目录，通过 -o 进行“或”运算"></a>范例：测试某个“东西”是文件或者目录，通过 -o 进行“或”运算</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">if</span> <span class="token function">test</span> -f /etc/profile -o -d /etc/profile<span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
YES<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="范例：测试某个“东西”是否为文件，测试-非运算"><a href="#范例：测试某个“东西”是否为文件，测试-非运算" class="headerlink" title="范例：测试某个“东西”是否为文件，测试 ! 非运算"></a>范例：测试某个“东西”是否为文件，测试 <code>!</code> 非运算</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">if</span> <span class="token function">test</span> <span class="token operator">!</span> -f /etc/profile<span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
NO<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面仅仅演示了 <code>test</code> 命令一些非常简单的测试，你可以通过 <code>help test</code> 获取 <code>test</code> 的更多用法。需要注意的是，<code>test</code> 命令内部的逻辑运算和 Shell 的逻辑运算符有一些区别，对应的为 <code>-a</code> 和 <code>&amp;&amp;</code>，<code>-o</code> 与 <code>||</code>，这两者不能混淆使用。而非运算都是 <code>!</code>，下面对它们进行比较。</p><h4 id="比较-a-与-amp-amp-o-与-，-test-与-test"><a href="#比较-a-与-amp-amp-o-与-，-test-与-test" class="headerlink" title="比较 -a 与 &amp;&amp;, -o 与 ||， ! test 与 test !"></a>比较 -a 与 &amp;&amp;, -o 与 ||， ! test 与 test !</h4><h5 id="范例：要求某文件可执行且有内容，用-a-和-amp-amp-分别实现"><a href="#范例：要求某文件可执行且有内容，用-a-和-amp-amp-分别实现" class="headerlink" title="范例：要求某文件可执行且有内容，用 -a 和 &amp;&amp; 分别实现"></a>范例：要求某文件可执行且有内容，用 -a 和 &amp;&amp; 分别实现</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> <span class="token operator">></span> test.sh
<span class="token comment" spellcheck="true">#!/bin/bash</span>
<span class="token keyword">echo</span> <span class="token string">"test"</span>
<span class="token punctuation">[</span>CTRL+D<span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 按下组合键CTRL与D结束cat输入，后同，不再注明</span>
$ <span class="token function">chmod</span> +x test.sh
$ <span class="token keyword">if</span> <span class="token function">test</span> -s test.sh -a -x test.sh<span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
YES
$ <span class="token keyword">if</span> <span class="token function">test</span> -s test.sh <span class="token operator">&amp;&amp;</span> <span class="token function">test</span> -x test.sh<span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
YES<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="范例：要求某个字符串要么为空，要么和某个字符串相等"><a href="#范例：要求某个字符串要么为空，要么和某个字符串相等" class="headerlink" title="范例：要求某个字符串要么为空，要么和某个字符串相等"></a>范例：要求某个字符串要么为空，要么和某个字符串相等</h5><pre class="line-numbers language-bash"><code class="language-bash">$ str1<span class="token operator">=</span><span class="token string">"test"</span>
$ str2<span class="token operator">=</span><span class="token string">"test"</span>
$ <span class="token keyword">if</span> <span class="token function">test</span> -z <span class="token string">"<span class="token variable">$str2</span>"</span> -o <span class="token string">"<span class="token variable">$str2</span>"</span> <span class="token operator">==</span> <span class="token string">"<span class="token variable">$str1</span>"</span><span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
YES
$ <span class="token keyword">if</span> <span class="token function">test</span> -z <span class="token string">"<span class="token variable">$str2</span>"</span> <span class="token operator">||</span> <span class="token function">test</span> <span class="token string">"<span class="token variable">$str2</span>"</span> <span class="token operator">==</span> <span class="token string">"<span class="token variable">$str1</span>"</span><span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
YES<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="范例：测试某个数字不满足指定的所有条件"><a href="#范例：测试某个数字不满足指定的所有条件" class="headerlink" title="范例：测试某个数字不满足指定的所有条件"></a>范例：测试某个数字不满足指定的所有条件</h5><pre class="line-numbers language-bash"><code class="language-bash">$ i<span class="token operator">=</span>5
$ <span class="token keyword">if</span> <span class="token function">test</span> <span class="token operator">!</span> <span class="token variable">$i</span> -lt 5 -a <span class="token variable">$i</span> -ne 6<span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
YES
$ <span class="token keyword">if</span> <span class="token operator">!</span> <span class="token function">test</span> <span class="token variable">$i</span> -lt 5 -a <span class="token variable">$i</span> -eq 6<span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
YES<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很容易找出它们的区别，<code>-a</code> 和 <code>-o</code> 作为测试命令的参数用在测试命令的内部，而 <code>&amp;&amp;</code> 和 <code>||</code> 则用来运算测试的返回值，<code>!</code> 为两者通用。需要关注的是：</p><ul><li>有时可以不用 <code>!</code> 运算符，比如 <code>-eq</code> 和 <code>-ne</code> 刚好相反，可用于测试两个数值是否相等； <code>-z</code> 与 <code>-n</code> 也是对应的，用来测试某个字符串是否为空</li><li>在 <code>Bash</code> 里，<code>test</code> 命令可以用[] 运算符取代，但是需要注意，[<code>之后与</code>] 之前需要加上额外的空格</li><li>在测试字符串时，所有变量建议用双引号包含起来，以防止变量内容为空时出现仅有测试参数，没有测试内容的情况</li></ul><p>下面我们用实例来演示上面三个注意事项：</p><ul><li><p><code>-ne</code> 和 <code>-eq</code> 对应的，我们有时候可以免去 <code>!</code> 运算</p><pre class="line-numbers language-bash"><code class="language-bash">$ i<span class="token operator">=</span>5
$ <span class="token keyword">if</span> <span class="token function">test</span> <span class="token variable">$i</span> -eq 5<span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
YES
$ <span class="token keyword">if</span> <span class="token function">test</span> <span class="token variable">$i</span> -ne 5<span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
NO
$ <span class="token keyword">if</span> <span class="token function">test</span> <span class="token operator">!</span> <span class="token variable">$i</span> -eq 5<span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
NO<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>用 <code>[ ]</code> 可以取代 <code>test</code>，这样看上去会“美观”很多</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$i</span> -eq 5 <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
YES
$ <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$i</span> -gt 4 <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">[</span> <span class="token variable">$i</span> -lt 6 <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
YES<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>记得给一些字符串变量加上 <code>&quot;&quot;</code>，记得 <code>[</code> 之后与 <code>]</code> 之前多加一个空格</p><pre class="line-numbers language-bash"><code class="language-bash">$ str<span class="token operator">=</span><span class="token string">""</span>
$ <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$str</span>"</span> <span class="token operator">=</span> <span class="token string">"test"</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
-bash: <span class="token punctuation">[</span>: missing `<span class="token punctuation">]</span>'
NO
$ <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$str</span> <span class="token operator">=</span> <span class="token string">"test"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
-bash: <span class="token punctuation">[</span>: <span class="token operator">=</span>: unary operator expected
NO
$ <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$str</span>"</span> <span class="token operator">=</span> <span class="token string">"test"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
NO<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>到这里，<strong>条件测试</strong>就介绍完了，下面介绍<strong>命令列表</strong>，实际上在上面我们已经使用过了，即多个test命令的组合，通过 <code>&amp;&amp;</code>，<code>||</code> 和 <code>!</code> 组合起来的命令序列。这种命令序列可以有效替换 <code>if/then</code> 的条件分支结构。这不难想到我们在 C 语言程序设计中经常做的如下的选择题（很无聊的例子，但是有意义）：下面是否会打印 <code>j</code>，如果打印，将打印什么？</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>

    i<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很容易知道将打印数字 5，因为 <code>i==5</code> 这个条件成立，而且随后是 <code>&amp;&amp;</code>，要判断整个条件是否成立，我们得进行后面的判断，可是这个判断并非常规的判断，而是先把 <code>j</code> 修改为 5，再转换为真值，所以条件为真，打印出 5 。因此，这句可以解释为：如果 <code>i</code> 等于 5，那么把 <code>j</code> 赋值为 5，如果 <code>j</code> 大于 1 （因为之前已经为真），那么打印出 <code>j</code> 的值。这样用 <code>&amp;&amp;</code> 连结起来的判断语句替代了两个 <code>if</code> 条件分支语句。</p><p>正是基于逻辑运算特有的性质，我们可以通过 <code>&amp;&amp;</code>，<code>||</code> 来取代 <code>if/then</code> 等条件分支结构，这样就产生了命令列表。</p><h3 id="命令列表"><a href="#命令列表" class="headerlink" title="命令列表"></a>命令列表</h3><h4 id="命令列表的执行规律"><a href="#命令列表的执行规律" class="headerlink" title="命令列表的执行规律"></a>命令列表的执行规律</h4><p>命令列表的执行规律符合逻辑运算的运算规律，用 <code>&amp;&amp;</code> 连接起来的命令，如果前者成功返回，将执行后面的命令，反之不然；用 <code>||</code> 连接起来的命令，如果前者成功返回，将不执行后续命令，反之不然。</p><h5 id="范例：如果-ping-通-https-www-uestc-edu-cn-那么打印连通信息"><a href="#范例：如果-ping-通-https-www-uestc-edu-cn-那么打印连通信息" class="headerlink" title="范例：如果 ping 通 https://www.uestc.edu.cn/  ,那么打印连通信息"></a>范例：如果 ping 通 <a href="https://www.uestc.edu.cn/">https://www.uestc.edu.cn/</a> ,那么打印连通信息</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ping</span> -c 1 https://www.uestc.edu.cn/ -W 1 <span class="token operator">&amp;&amp;</span> <span class="token keyword">echo</span> <span class="token string">"=======connected======="</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>非常有趣的问题出来了，即我们上面已经提到的：为什么要让 C 程序在 <code>main()</code> 函数的最后返回 0 ？如果不这样，把这种程序放入命令列表会有什么样的结果？你自己写个简单的 C 程序，然后放入命令列表看看。</p><h4 id="命令列表的作用"><a href="#命令列表的作用" class="headerlink" title="命令列表的作用"></a>命令列表的作用</h4><p>有时用命令列表取代 <code>if/then</code> 等条件分支结构可以省掉一些代码，而且使得程序比较美观、易读，例如：</p><h5 id="范例：在脚本里判断程序的参数个数，和参数类型"><a href="#范例：在脚本里判断程序的参数个数，和参数类型" class="headerlink" title="范例：在脚本里判断程序的参数个数，和参数类型"></a>范例：在脚本里判断程序的参数个数，和参数类型</h5><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token keyword">echo</span> $<span class="token comment" spellcheck="true">#</span>
<span class="token keyword">echo</span> <span class="token variable">$1</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> $<span class="token comment" spellcheck="true"># -eq 1 ] &amp;&amp; (echo $1 | grep '^[0-9]*$' >/dev/null);then</span>
    <span class="token keyword">echo</span> <span class="token string">"YES"</span>
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：上例要求参数个数为 1 并且类型为数字。</p><p>再加上 <code>exit 1</code>，我们将省掉 <code>if/then</code> 结构</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token keyword">echo</span> $<span class="token comment" spellcheck="true">#</span>
<span class="token keyword">echo</span> <span class="token variable">$1</span>
<span class="token operator">!</span> <span class="token punctuation">(</span><span class="token punctuation">[</span> $<span class="token comment" spellcheck="true"># -eq 1 ] &amp;&amp; (echo $1 | grep '^[0-9]*$' >/dev/null)) &amp;&amp; exit 1</span>

<span class="token keyword">echo</span> <span class="token string">"YES"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样处理后，对程序参数的判断仅仅需要简单的一行代码，而且变得更美观。</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>这一节介绍了 Shell 编程中的逻辑运算，条件测试和命令列表。</p><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h3><p>之前已经完成数值运算和布尔运算，这次轮到介绍<em>字符串操作</em> 。咱们先得弄明白两个内容：</p><ul><li><p>什么是字符串？</p></li><li><p>对字符串有哪些操作？</p></li><li><p>什么是字符串？</p></li><li><p>对字符串有哪些操作？</p></li></ul><p>下面是”在线新华字典”的解释：</p><blockquote><p>字符串: 简称“串”。有限字符的序列。数据元素为字符的线性表，是一种数据的逻辑结构。在计算机中可有不同的存储结构。在串上可进行求子串、插入字符、删除字符、置换字符等运算。</p></blockquote><p>而字符呢？</p><blockquote><p>字符: 计算机程序设计及操作时使用的符号。包括字母、数字、空格符、提示符及各种专用字符等。</p></blockquote><p>照这样说，之前介绍的中的数字，布尔运算中的真假值，都是以字符的形式呈现出来的，是一种特别的字符，对它们的运算只不过是字符操作的特例罢了。而这里将研究一般字符的运算，它具有非常重要的意义，因为对我们来说，一般的工作都是处理字符而已。这些运算实际上将围绕上述两个定义来做，它们包括：</p><ul><li>找出字符或者字符串的类型，是数字、字母还是其他特定字符，是可打印字符，还是不可打印字符（一些控制字符）。</li><li>找出组成字符串的字符个数和字符串的存储结构（比如数组）。</li><li>对串的常规操作：求子串、插入字符、删除字符、置换字符、字符串的比较等。</li><li>对串的一些比较复杂而有趣的操作，这里将在最后介绍一些有趣的范例。</li></ul><h3 id="字符串的属性"><a href="#字符串的属性" class="headerlink" title="字符串的属性"></a>字符串的属性</h3><h4 id="字符串的类型"><a href="#字符串的类型" class="headerlink" title="字符串的类型"></a>字符串的类型</h4><p>字符有可能是数字、字母、空格、其他特殊字符，而字符串有可能是它们中的一种或者多种的组合，在组合之后还可能形成具有特定意义的字符串，诸如邮件地址，URL地址等。</p><h5 id="范例：数字或者数字组合"><a href="#范例：数字或者数字组合" class="headerlink" title="范例：数字或者数字组合"></a>范例：数字或者数字组合</h5><pre class="line-numbers language-bash"><code class="language-bash">$ i<span class="token operator">=</span>5<span class="token punctuation">;</span>j<span class="token operator">=</span>9423483247234<span class="token punctuation">;</span>
$ <span class="token keyword">echo</span> <span class="token variable">$i</span> <span class="token operator">|</span> <span class="token function">grep</span> -q <span class="token string">"^[0-9]$"</span>
$ <span class="token keyword">echo</span> <span class="token variable">$?</span>
0
$ <span class="token keyword">echo</span> <span class="token variable">$j</span> <span class="token operator">|</span> <span class="token function">grep</span> -q <span class="token string">"^[0-9]\+$"</span>
$ <span class="token keyword">echo</span> <span class="token variable">$?</span>
0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="范例：字符组合（小写字母、大写字母、两者的组合）"><a href="#范例：字符组合（小写字母、大写字母、两者的组合）" class="headerlink" title="范例：字符组合（小写字母、大写字母、两者的组合）"></a>范例：字符组合（小写字母、大写字母、两者的组合）</h5><pre class="line-numbers language-bash"><code class="language-bash">$ c<span class="token operator">=</span><span class="token string">"A"</span><span class="token punctuation">;</span> d<span class="token operator">=</span><span class="token string">"fwefewjuew"</span><span class="token punctuation">;</span> e<span class="token operator">=</span><span class="token string">"fewfEFWefwefe"</span>
$ <span class="token keyword">echo</span> <span class="token variable">$c</span> <span class="token operator">|</span> <span class="token function">grep</span> -q <span class="token string">"^[A-Z]$"</span>
$ <span class="token keyword">echo</span> <span class="token variable">$d</span> <span class="token operator">|</span> <span class="token function">grep</span> -q <span class="token string">"^[a-z]\+$"</span>
$ <span class="token keyword">echo</span> <span class="token variable">$e</span> <span class="token operator">|</span> <span class="token function">grep</span> -q <span class="token string">"^[a-zA-Z]\+$"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="范例：字母和数字的组合"><a href="#范例：字母和数字的组合" class="headerlink" title="范例：字母和数字的组合"></a>范例：字母和数字的组合</h5><pre class="line-numbers language-bash"><code class="language-bash">$ ic<span class="token operator">=</span><span class="token string">"432fwfwefeFWEwefwef"</span>
$ <span class="token keyword">echo</span> <span class="token variable">$ic</span> <span class="token operator">|</span> <span class="token function">grep</span> -q <span class="token string">"^[0-9a-zA-Z]\+$"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="范例：空格或者-Tab-键等"><a href="#范例：空格或者-Tab-键等" class="headerlink" title="范例：空格或者 Tab 键等"></a>范例：空格或者 Tab 键等</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token string">" "</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">" "</span>
$ <span class="token keyword">echo</span> -e <span class="token string">"\t"</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"[[:space:]]"</span> <span class="token comment" spellcheck="true">#[[:space:]]会同时匹配空格和TAB键</span>
$ <span class="token keyword">echo</span> -e <span class="token string">" \t"</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"[[:space:]]"</span>
$ <span class="token keyword">echo</span> -e <span class="token string">"\t"</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">""</span> <span class="token comment" spellcheck="true">#为在键盘上按下TAB键，而不是字符</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="范例：匹配邮件地址"><a href="#范例：匹配邮件地址" class="headerlink" title="范例：匹配邮件地址"></a>范例：匹配邮件地址</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token string">"test2007@lzu.cn"</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"[0-9a-zA-Z\.]*@[0-9a-zA-Z\.]*"</span>
test2007@lzu.cn<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="范例：匹配-URL-地址-以-http-链接为例）"><a href="#范例：匹配-URL-地址-以-http-链接为例）" class="headerlink" title="范例：匹配 URL 地址(以 http 链接为例）"></a>范例：匹配 URL 地址(以 http 链接为例）</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token string">"http://news.lzu.edu.cn/article.jsp?newsid=10135"</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"^http://[0-9a-zA-Z\./=?]\+$"</span>
http://news.lzu.edu.cn/article.jsp?newsid<span class="token operator">=</span>10135<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>说明：</p><ul><li><code>/dev/null</code> 和 <code>/dev/zero</code> 设备非常有趣，都犹如黑洞，什么东西掉进去都会消失殆尽；后者还是个能源箱，总能从那里取到0，直到退出</li><li><code>[[:space:]]</code> 是 <code>grep</code> 用于匹配空格或 TAB 键字符的标记，其他标记请查帮助：<code>man grep</code></li><li>上面都是用 <code>grep</code> 来进行模式匹配，实际上 <code>sed</code>，<code>awk</code> 都可用来做模式匹配，关于匹配中用到的正则表达式知识，请参考后面的相关资料</li><li>如果想判断字符串是否为空，可判断其长度是否为零，可通过 <code>test</code> 命令的 <code>-z</code> 选项来实现，具体用法见 <code>test</code> 命令，<code>help test</code></li></ul><h5 id="范例：判断字符是否为可打印字符"><a href="#范例：判断字符是否为可打印字符" class="headerlink" title="范例：判断字符是否为可打印字符"></a>范例：判断字符是否为可打印字符</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token string">"\t\n"</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"[[:print:]]"</span>
\t\n
$ <span class="token keyword">echo</span> <span class="token variable">$?</span>
0
$ <span class="token keyword">echo</span> -e <span class="token string">"\t\n"</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"[[:print:]]"</span>
$ <span class="token keyword">echo</span> <span class="token variable">$?</span>
1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字符串的长度"><a href="#字符串的长度" class="headerlink" title="字符串的长度"></a>字符串的长度</h4><p>除了组成字符串的字符类型外，字符串还有哪些属性呢？组成字符串的字符个数。</p><p>下面我们来计算字符串的长度，即所有字符的个数，并简单介绍几种求字符串中指定字符个数的方法。</p><h5 id="范例：计算某个字符串的长度"><a href="#范例：计算某个字符串的长度" class="headerlink" title="范例：计算某个字符串的长度"></a>范例：计算某个字符串的长度</h5><p>即计算所有字符的个数，计算方法五花八门，择其优着而用之：</p><pre class="line-numbers language-bash"><code class="language-bash">$ var<span class="token operator">=</span><span class="token string">"get the length of me"</span>
$ <span class="token keyword">echo</span> <span class="token variable">${var}</span>     <span class="token comment" spellcheck="true"># 这里等同于$var</span>
get the length of me
$ <span class="token keyword">echo</span> <span class="token variable">${#var}</span>
20
$ <span class="token function">expr</span> length <span class="token string">"<span class="token variable">$var</span>"</span>
20
$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{printf("%d\n", length(<span class="token variable">$0</span>));}'</span>
20
$ <span class="token keyword">echo</span> -n <span class="token variable">$var</span> <span class="token operator">|</span>  <span class="token function">wc</span> -c
20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="范例：计算某些指定字符或者字符组合的个数"><a href="#范例：计算某些指定字符或者字符组合的个数" class="headerlink" title="范例：计算某些指定字符或者字符组合的个数"></a>范例：计算某些指定字符或者字符组合的个数</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">tr</span> -cd g <span class="token operator">|</span> <span class="token function">wc</span> -c
2
$ <span class="token keyword">echo</span> -n <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">sed</span> -e <span class="token string">'s/[^g]//g'</span> <span class="token operator">|</span> <span class="token function">wc</span> -c
2
$ <span class="token keyword">echo</span> -n <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">sed</span> -e <span class="token string">'s/[^gt]//g'</span> <span class="token operator">|</span> <span class="token function">wc</span> -c
5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="范例：统计单词个数"><a href="#范例：统计单词个数" class="headerlink" title="范例：统计单词个数"></a>范例：统计单词个数</h5><p>更多相关信息见之前<em>单词统计</em> 相关范例。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">wc</span> -w
5
$ <span class="token keyword">echo</span> <span class="token string">"<span class="token variable">$var</span>"</span> <span class="token operator">|</span> <span class="token function">tr</span> <span class="token string">" "</span> <span class="token string">"\n"</span> <span class="token operator">|</span> <span class="token function">grep</span> get <span class="token operator">|</span> <span class="token function">uniq</span> -c
1
$ <span class="token keyword">echo</span> <span class="token string">"<span class="token variable">$var</span>"</span> <span class="token operator">|</span> <span class="token function">tr</span> <span class="token string">" "</span> <span class="token string">"\n"</span> <span class="token operator">|</span> <span class="token function">grep</span> get <span class="token operator">|</span> <span class="token function">wc</span> -l
1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><p><code>${}</code> 操作符在 Bash 里头是一个“大牛”，能胜任相当多的工作，具体就看网中人的<a href="http://bbs.chinaunix.net/forum.php?mod=viewthread&tid=218853&page=7#pid1617953">《Shell十三问》之<code>$(())</code>与<code>$()</code> 还有<code>${}</code>差在哪？”</a>吧。</p><h3 id="字符串的显示"><a href="#字符串的显示" class="headerlink" title="字符串的显示"></a>字符串的显示</h3><p>接下来讨论如何控制字符在终端的显示。</p><h4 id="范例：在屏幕控制字符显示位置、颜色、背景等"><a href="#范例：在屏幕控制字符显示位置、颜色、背景等" class="headerlink" title="范例：在屏幕控制字符显示位置、颜色、背景等"></a>范例：在屏幕控制字符显示位置、颜色、背景等</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> -e <span class="token string">"\033[31;40m"</span> <span class="token comment" spellcheck="true">#设置前景色为黑色，背景色为红色</span>
$ <span class="token keyword">echo</span> -e <span class="token string">'\033[11;29H Hello, World!'</span> <span class="token comment" spellcheck="true">#在屏幕的第11行，29列开始打印字符串Hello,World!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="范例：在屏幕的某个位置动态显示当前系统时间"><a href="#范例：在屏幕的某个位置动态显示当前系统时间" class="headerlink" title="范例：在屏幕的某个位置动态显示当前系统时间"></a>范例：在屏幕的某个位置动态显示当前系统时间</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">while</span> <span class="token keyword">:</span><span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token keyword">echo</span> -e <span class="token string">"\033[11;29H "</span><span class="token punctuation">$(</span>date <span class="token string">"+%Y-%m-%d %H:%M:%S"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="范例：过滤掉某些控制字符串"><a href="#范例：过滤掉某些控制字符串" class="headerlink" title="范例：过滤掉某些控制字符串"></a>范例：过滤掉某些控制字符串</h4><p>用 <code>col</code> 命令过滤某些控制字符，在处理诸如 <code>script</code>，<code>screen</code> 等截屏命令的输出结果时，很有用。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">screen</span> -L
$ <span class="token function">cat</span> /bin/cat
$ <span class="token keyword">exit</span>
$ <span class="token function">cat</span> screenlog.0 <span class="token operator">|</span> col -b   <span class="token comment" spellcheck="true"># 把一些控制字符过滤后，就可以保留可读的操作日志</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字符串的存储"><a href="#字符串的存储" class="headerlink" title="字符串的存储"></a>字符串的存储</h3><p>在我们看来，字符串是一连串的字符而已，但是为了操作方便，我们往往可以让字符串呈现出一定的结构。在这里，我们不关心字符串在内存中的实际存储结构，仅仅关系它呈现出来的逻辑结构。比如，这样一个字符串： <code>&quot;get the length of me&quot;</code>，我们可以从不同的方面来呈现它。</p><ul><li>通过字符在串中的位置来呈现它</li></ul><p>这样我们就可以通过指定位置来找到某个子串。这在 C 语言中通常可以利用指针来做。而在 Shell 编程中，有很多可用的工具，诸如 <code>expr</code>，<code>awk</code> 都提供了类似方法来实现子串的查询动作。两者都几乎支持模式匹配 <code>match</code> 和完全匹配 <code>index</code>。这在后面的字符串操作中将详细介绍。</p><ul><li>根据某个分割符来取得字符串的各个部分</li></ul><p>这里最常见的就是行分割符、空格或者 <code>TAB</code> 分割符了，前者用来当行号，我们似乎已经司空见惯了，因为我们的编辑器就这样“莫名”地处理着行分割符（在 UNIX 下为 <code>\n</code>，在其他系统下有一些不同，比如 Windows 下为 <code>\r\n</code> ）。而空格或者 <code>TAB</code> 键经常用来分割数据库的各个字段，这似乎也是司空见惯的事情。</p><p>正因为这样，所以产生了大量优秀的行编辑工具，诸如 <code>grep</code>，<code>awk</code>，<code>sed</code> 等。在“行内”（姑且这么说吧，就是处理单行，即字符串中不再包含行分割符）的字符串分割方面，<code>cut</code> 和 <code>awk</code> 提供了非常优越的“行内”（处理单行）处理能力。</p><ul><li>更方便地处理用分割符分割好的各个部分</li></ul><p>同样是用到分割符，但为了更方便的操作分割以后的字符串的各个部分，我们抽象了“数组”这么一个数据结构，从而让我们更加方便地通过下标来获取某个指定的部分。 <code>bash</code> 提供了这么一种数据结构，而优秀的 <code>awk</code> 也同样提供了它，我们这里将简单介绍它们的用法。</p><h4 id="范例：把字符串拆分成字符串数组"><a href="#范例：把字符串拆分成字符串数组" class="headerlink" title="范例：把字符串拆分成字符串数组"></a>范例：把字符串拆分成字符串数组</h4><ul><li><p>Bash 提供的数组数据结构，以数字为下标的，和 C 语言从 0 开始的下标一样</p><pre class="line-numbers language-bash"><code class="language-bash">$ var<span class="token operator">=</span><span class="token string">"get the length of me"</span>
$ var_arr<span class="token operator">=</span><span class="token punctuation">(</span><span class="token variable">$var</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#把字符串var存放到字符串数组var_arr中，默认以空格作为分割符</span>
$ <span class="token keyword">echo</span> <span class="token variable">${var_arr[0]}</span> <span class="token variable">${var_arr[1]}</span> <span class="token variable">${var_arr[2]}</span> <span class="token variable">${var_arr[3]}</span> <span class="token variable">${var_arr[4]}</span>
get the length of me
$ <span class="token keyword">echo</span> <span class="token variable">${var_arr[@]}</span>    <span class="token comment" spellcheck="true">#整个字符串，可以用*代替@，下同</span>
get the length of me
$ <span class="token keyword">echo</span> <span class="token variable">${#var_arr[@]}</span>   <span class="token comment" spellcheck="true">#类似于求字符串长度，`#`操作符也可用来求数组元素个数</span>
5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以直接给某个数组元素赋值</p><pre class="line-numbers language-bash"><code class="language-bash">$ var_arr<span class="token punctuation">[</span>5<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"new_element"</span>
$ <span class="token keyword">echo</span> <span class="token variable">${#var_arr[@]}</span>
6
$ <span class="token keyword">echo</span> <span class="token variable">${var_arr[5]}</span>
new_element<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Bash 实际上还提供了一种类似于“数组”的功能，即 <code>for i in</code>，它可以很方便地获取某个字符串的各个部分，例如：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token variable">$var</span><span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token keyword">echo</span> -n <span class="token variable">$i</span><span class="token string">"_"</span><span class="token punctuation">;</span> <span class="token keyword">done</span>
get_the_length_of_me_<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>awk</code> 里的数组，注意比较它和 <code>Bash</code> 里的数组的异同</p><p><code>split</code> 把一行按照空格分割，存放到数组 <code>var_arr</code> 中，并返回数组长度。注意：这里第一个元素下标不是 0，而是 1</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{printf("%d %s\n", split(<span class="token variable">$0</span>, var_arr, " "), var_arr[1]);}'</span>
5 get<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>实际上，上述操作很类似 <code>awk</code> 自身的行处理功能： <code>awk</code> 默认把一行按照空格分割为多个域，并可以通过 <code>$1</code>，<code>$2</code>，<code>$3</code> <code>...</code> 来获取，<code>$0</code> 表示整行。</p><p>这里的 <code>NF</code> 是该行的域的总数，类似于上面数组的长度，它同样提供了一种通过类似“下标”访问某个字符串的功能。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{printf("%d | %s %s %s %s %s | %s\n", NF, <span class="token variable">$1</span>, <span class="token variable">$2</span>, <span class="token variable">$3</span>, <span class="token variable">$4</span>, <span class="token variable">$5</span>, <span class="token variable">$0</span>);}'</span>
5 <span class="token operator">|</span> get the length of me <span class="token operator">|</span> get the length of me<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>awk</code> 的“数组”功能何止于此呢，看看它的 <code>for</code> 引用吧，注意，这个和 <code>Bash</code> 里头的 <code>for</code> 不太一样，<code>i</code> 不是元素本身，而是下标：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{split(<span class="token variable">$0</span>, var_arr, " "); for(i in var_arr) printf("%s ",var_arr[i]);}'</span>
of me get the length
4 5 1 2 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>另外，从上述结果可以看到，经过 <code>for</code> 处理后，整个结果没有按照原理的字符顺序排列，不过如果仅仅是迭代出所有元素这个同样很有意义。</p></li></ul><p><code>awk</code> 还有更“厉害”的处理能力，它的下标可以不是数字，可以是字符串，从而变成了“关联”数组，这种“关联”在某些方面非常方便。 比如，把某个文件中的某个系统调用名根据另外一个文件中的函数地址映射表替换成地址，可以这么实现：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> symbol
sys_exit
sys_read
sys_close
$ <span class="token function">ls</span> /boot/System.map*
/boot/System.map-2.6.20-16-generic
$ <span class="token function">awk</span> <span class="token string">'{if(FILENAME ~ "System.map") map[<span class="token variable">$3</span>]=<span class="token variable">$1</span>; else {printf("%s\n", map[<span class="token variable">$1</span>])}}'</span> \
    /boot/System.map-2.6.20-16-generic symbol
c0129a80
c0177310
c0175d80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外，awk还支持用delete函数删除某个数组元素。如果某些场合有需要的话，别忘了awk还支持二维数组。</p><h3 id="字符串常规操作"><a href="#字符串常规操作" class="headerlink" title="字符串常规操作"></a>字符串常规操作</h3><p>字符串操作包括取子串、查询子串、插入子串、删除子串、子串替换、子串比较、子串排序、子串进制转换、子串编码转换等。</p><h4 id="取子串"><a href="#取子串" class="headerlink" title="取子串"></a>取子串</h4><p>取子串的方法主要有：</p><ul><li>直接到指定位置求子串</li><li>字符匹配求子串</li></ul><h5 id="范例：按照位置取子串"><a href="#范例：按照位置取子串" class="headerlink" title="范例：按照位置取子串"></a>范例：按照位置取子串</h5><p>比如从什么位置开始，取多少个字符</p><pre class="line-numbers language-bash"><code class="language-bash">$ var<span class="token operator">=</span><span class="token string">"get the length of me"</span>
$ <span class="token keyword">echo</span> <span class="token variable">${var:0:3}</span>
get
$ <span class="token keyword">echo</span> <span class="token variable">${var:(-2)}</span>   <span class="token comment" spellcheck="true"># 方向相反呢</span>
me

$ <span class="token keyword">echo</span> `expr substr <span class="token string">"<span class="token variable">$var</span>"</span> 5 3` <span class="token comment" spellcheck="true">#记得把$var引起来，否则expr会因为空格而解析错误</span>
the

$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{printf("%s\n", substr(<span class="token variable">$0</span>, 9, 6))}'</span>
length
<span class="token function">awk</span><span class="token variable"><span class="token variable">`</span> 把 <span class="token variable">`</span></span><span class="token variable">$var</span><span class="token variable"><span class="token variable">`</span> 按照空格分开为多个变量，依次为 <span class="token variable">`</span></span><span class="token variable">$1</span><span class="token variable"><span class="token variable">`</span>，<span class="token variable">`</span></span><span class="token variable">$2</span><span class="token variable"><span class="token variable">`</span>，<span class="token variable">`</span></span><span class="token variable">$3</span><span class="token variable"><span class="token variable">`</span>，<span class="token variable">`</span></span><span class="token variable">$4</span><span class="token variable"><span class="token variable">`</span>，<span class="token variable">`</span></span><span class="token variable">$5</span>
$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{printf("%s\n", <span class="token variable">$1</span>);}'</span>
get
$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{printf("%s\n", <span class="token variable">$5</span>);}'</span>
me<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>差点略掉<code>cut</code>小工具，它用起来和awk类似，<code>-d</code>指定分割符，如同<code>awk</code>用<code>-F</code>指定分割符一样；<code>-f</code>指定“域”，如同awk的<code>$数字</code>。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">cut</span> -d<span class="token string">" "</span> -f 5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="范例：匹配字符求子串"><a href="#范例：匹配字符求子串" class="headerlink" title="范例：匹配字符求子串"></a>范例：匹配字符求子串</h5><p>用 Bash 内置支持求子串：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">${var%% *}</span> <span class="token comment" spellcheck="true">#从右边开始计算，删除最左边的空格右边的所有字符</span>
get
$ <span class="token keyword">echo</span> <span class="token variable">${var% *}</span> <span class="token comment" spellcheck="true">#从右边开始计算，删除第一个空格右边的所有字符</span>
get the length of
$ <span class="token keyword">echo</span> $<span class="token punctuation">{</span>var<span class="token comment" spellcheck="true">##* }  #从左边开始计算，删除最右边的空格左边的所有字符</span>
me
$ <span class="token keyword">echo</span> $<span class="token punctuation">{</span>var<span class="token comment" spellcheck="true">#* }  #从左边开始计算，删除第一个空格左边的所有字符</span>
the length of me<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>删除所有 <code>空格＋字母组合</code> 的字符串：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'s/ [a-z]*//g'</span>
get
$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'s/[a-z]* //g'</span>
me<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>sed</code> 有按地址（行）打印(p)的功能，记得先用 <code>tr</code> 把空格换成行号：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">tr</span> <span class="token string">" "</span> <span class="token string">"\n"</span> <span class="token operator">|</span> <span class="token function">sed</span> -n 1p
get
$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">tr</span> <span class="token string">" "</span> <span class="token string">"\n"</span> <span class="token operator">|</span> <span class="token function">sed</span> -n 5p
me<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>tr</code> 也可以用来取子串，它可以类似<code>#</code>和 <code>%</code> 来“拿掉”一些字符串来实现取子串：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">tr</span> -d <span class="token string">" "</span>
getthelengthofme
$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">tr</span> -cd <span class="token string">"[a-z]"</span> <span class="token comment" spellcheck="true">#把所有的空格都拿掉了，仅仅保留字母字符串，注意-c和-d的用法</span>
getthelengthofme<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><ul><li><code>%</code> 和<code>#</code>删除字符的方向不一样，前者在右，后者在左，<code>%%</code> 和 <code>%</code>， <code>##</code> 和 <code>#</code> 的方向是前者是最大匹配，后者是最小匹配。（好的记忆方法见网中人的键盘记忆法：<code>#</code>，<code>$</code>，<code>%</code> 是键盘依次从左到右的三个键）</li><li><code>tr</code> 的 <code>-c</code> 选项是 <code>complement</code> 的缩写，即 <code>invert</code>，而 <code>-d</code> 选项是删除，<code>tr -cd &quot;[a-z]&quot;</code> 这样一来就变成保留所有的字母</li></ul><p>对于字符串的截取，实际上还有一些命令，如果 <code>head</code>，<code>tail</code> 等可以实现有意思的功能，可以截取某个字符串的前面、后面指定的行数或者字节数。例如：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token string">"abcdefghijk"</span> <span class="token operator">|</span> <span class="token function">head</span> -c 4
abcd
$ <span class="token keyword">echo</span> -n <span class="token string">"abcdefghijk"</span> <span class="token operator">|</span> <span class="token function">tail</span> -c 4
hijk<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="查询子串"><a href="#查询子串" class="headerlink" title="查询子串"></a>查询子串</h4><p>子串查询包括：</p><ul><li>返回符合某个模式的子串本身</li><li>返回子串在目标串中的位置</li></ul><p>准备：在进行下面的操作之前，请准备一个文件 test.txt，里头有内容 “consists of”，用于下面的范例。</p><h5 id="范例：查询子串在目标串中的位置"><a href="#范例：查询子串在目标串中的位置" class="headerlink" title="范例：查询子串在目标串中的位置"></a>范例：查询子串在目标串中的位置</h5><p><code>expr index</code>貌似仅仅可以返回某个字符或者多个字符中第一个字符出现的位置</p><pre class="line-numbers language-bash"><code class="language-bash">$ var<span class="token operator">=</span><span class="token string">"get the length of me"</span>
$ <span class="token function">expr</span> index <span class="token string">"<span class="token variable">$var</span>"</span> t
3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>awk却能找出字串，match还可以匹配正则表达式</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{printf("%d\n", match(<span class="token variable">$0</span>,"the"));}'</span>
5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="范例：查询子串，返回包含子串的行"><a href="#范例：查询子串，返回包含子串的行" class="headerlink" title="范例：查询子串，返回包含子串的行"></a>范例：查询子串，返回包含子串的行</h5><p><code>awk</code>，<code>sed</code> 都可以实现这些功能，但是 <code>grep</code> 最擅长</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">grep</span> <span class="token string">"consists of"</span> test.txt   <span class="token comment" spellcheck="true"># 查询文件包含consists of的行，并打印这些行</span>
$ <span class="token function">grep</span> <span class="token string">"consists[[:space:]]of"</span> -n -H test.txt <span class="token comment" spellcheck="true"># 打印文件名，子串所在行的行号和该行的内容</span>
$ <span class="token function">grep</span> <span class="token string">"consists[[:space:]]of"</span> -n -o test.txt <span class="token comment" spellcheck="true"># 仅仅打印行号和匹配到的子串本身的内容</span>

$ <span class="token function">awk</span> <span class="token string">'/consists of/{ printf("%s:%d:%s\n",FILENAME, FNR, <span class="token variable">$0</span>)}'</span> text  <span class="token comment" spellcheck="true">#看到没？和grep的结果一样</span>
$ <span class="token function">sed</span> -n -e <span class="token string">'/consists of/=;/consists of/p'</span> text <span class="token comment" spellcheck="true">#同样可以打印行号</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><ul><li><code>awk</code>，<code>grep</code>，<code>sed</code> 都能通过模式匹配查找指定字符串，但它们各有所长，将在后续章节中继续使用和比较它们，进而发现各自优点</li><li>在这里姑且把文件内容当成了一个大的字符串，在后面章节中将专门介绍文件操作，所以对文件内容中存放字符串的操作将会有更深入的分析和介绍</li></ul><h4 id="子串替换"><a href="#子串替换" class="headerlink" title="子串替换"></a>子串替换</h4><p>子串替换就是把某个指定的子串替换成其他的字符串，这里蕴含了“插入子串”和“删除子串”的操作。例如，想插入某个字符串到某个子串之前，就可以把原来的子串替换成”子串+新的字符串“，如果想删除某个子串，就把子串替换成空串。不过有些工具提供了一些专门的用法来做插入子串和删除子串的操作，所以呆伙还会专门介绍。另外，要想替换掉某个子串，一般都是先找到子串（查询子串），然后再把它替换掉，实质上很多工具在使用和设计上都体现了这么一点。</p><h5 id="范例：把变量-var-中的空格替换成下划线"><a href="#范例：把变量-var-中的空格替换成下划线" class="headerlink" title="范例：把变量 var 中的空格替换成下划线"></a>范例：把变量 var 中的空格替换成下划线</h5><p>用 <code>{}</code> 运算符，还记得么？网中人的教程</p><pre class="line-numbers language-bash"><code class="language-bash">$ var<span class="token operator">=</span><span class="token string">"get the length of me"</span>
$ <span class="token keyword">echo</span> <span class="token variable">${var/ /_}</span>        <span class="token comment" spellcheck="true">#把第一个空格替换成下划线</span>
get_the length of me
$ <span class="token keyword">echo</span> <span class="token variable">${var// /_}</span>       <span class="token comment" spellcheck="true">#把所有空格都替换成下划线</span>
get_the_length_of_me<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用 <code>awk</code>，<code>awk</code> 提供了转换的最小替换函数 <code>sub</code> 和全局替换函数 <code>gsub</code>，类似 <code>/</code> 和 <code>//</code></p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{sub(" ", "_", <span class="token variable">$0</span>); printf("%s\n", <span class="token variable">$0</span>);}'</span>
get_the length of me
$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{gsub(" ", "_", <span class="token variable">$0</span>); printf("%s\n", <span class="token variable">$0</span>);}'</span>
get_the_length_of_me<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>用 <code>sed</code>，子串替换可是 <code>sed</code> 的特长：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">sed</span> -e <span class="token string">'s/ /_/'</span>    <span class="token comment" spellcheck="true">#s &lt;= substitude</span>
get_the length of me
$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">sed</span> -e <span class="token string">'s/ /_/g'</span>   <span class="token comment" spellcheck="true">#看到没有，简短两个命令就实现了最小匹配和最大匹配g &lt;= global</span>
get_the_length_of_me<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>有忘记 <code>tr</code> 命令么？可以用替换单个字符的：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">tr</span> <span class="token string">" "</span> <span class="token string">"_"</span>
get_the_length_of_me
$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">tr</span> <span class="token string">'[a-z]'</span> <span class="token string">'[A-Z]'</span>   <span class="token comment" spellcheck="true">#这个可有意思了，把所有小写字母都替换为大写字母</span>
GET THE LENGTH OF ME<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>说明： <code>sed</code> 还有很有趣的标签用法呢，下面再介绍吧。</p><p>有一种比较有意思的字符串替换是：整个文件行的倒置，这个可以通过 <code>tac</code> 命令实现，它会把文件中所有的行全部倒转过来。在某种意义上来说，排序实际上也是一个字符串替换。</p><h4 id="插入子串"><a href="#插入子串" class="headerlink" title="插入子串"></a>插入子串</h4><p>在指定位置插入子串，这个位置可能是某个子串的位置，也可能是从某个文件开头算起的某个长度。通过上面的练习，我们发现这两者之间实际上是类似的。</p><p>公式：插入子串=把”old子串”替换成”old子串+new子串”或者”new子串+old子串”</p><h5 id="范例：在-var-字符串的空格之前或之后插入一个下划线"><a href="#范例：在-var-字符串的空格之前或之后插入一个下划线" class="headerlink" title="范例：在 var 字符串的空格之前或之后插入一个下划线"></a>范例：在 var 字符串的空格之前或之后插入一个下划线</h5><p>用{}：</p><pre class="line-numbers language-bash"><code class="language-bash">$ var<span class="token operator">=</span><span class="token string">"get the length of me"</span>
$ <span class="token keyword">echo</span> <span class="token variable">${var/ /_ }</span>        <span class="token comment" spellcheck="true">#在指定字符串之前插入一个字符串</span>
get_ the length of me
$ <span class="token keyword">echo</span> <span class="token variable">${var// /_ }</span>
get_ the_ length_ of_ me
$ <span class="token keyword">echo</span> <span class="token variable">${var/ / _}</span>        <span class="token comment" spellcheck="true">#在指定字符串之后插入一个字符串</span>
get _the length of me
$ <span class="token keyword">echo</span> <span class="token variable">${var// / _}</span>
get _the _length _of _me<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其他的还用演示么？这里主要介绍sed怎么用来插入字符吧，因为它的标签功能很有趣 说明：<code>(</code> 和 <code>)</code> 将匹配到的字符串存放为一个标签，按匹配顺序为<code>\1</code>,<code>\2</code>…</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">sed</span> -e <span class="token string">'s/\( \)/_\1/'</span>
get_ the length of me
$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">sed</span> -e <span class="token string">'s/\( \)/_\1/g'</span>
get_ the_ length_ of_ me
$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">sed</span> -e <span class="token string">'s/\( \)/\1_/'</span>
get _the length of me
$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">sed</span> -e <span class="token string">'s/\( \)/\1_/g'</span>
get _the _length _of _me<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看看 <code>sed</code> 的标签的顺序是不是 <code>\1</code>,<code>\2</code>…，看到没？<code>\2</code> 和 <code>\1</code> 调换位置后，<code>the</code> 和 <code>get</code> 的位置掉换了：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">sed</span> -e <span class="token string">'s/\([a-z]*\) \([a-z]*\) /\2 \1 /g'</span>
the get of length me<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>sed</code> 还有专门的插入指令，<code>a</code> 和 <code>i</code>，分别表示在匹配的行后和行前插入指定字符</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'/get/a test'</span>
get the length of me
<span class="token function">test</span>
$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'/get/i test'</span>
<span class="token function">test</span>
get the length of me<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="删除子串"><a href="#删除子串" class="headerlink" title="删除子串"></a>删除子串</h4><p>删除子串：应该很简单了吧，把子串替换成“空”（什么都没有）不就变成了删除么。还是来简单复习一下替换吧。</p><h5 id="范例：把-var-字符串中所有的空格给删除掉"><a href="#范例：把-var-字符串中所有的空格给删除掉" class="headerlink" title="范例：把 var 字符串中所有的空格给删除掉"></a>范例：把 var 字符串中所有的空格给删除掉</h5><p>鼓励：这样一替换不知道变成什么单词啦，谁认得呢？但是中文却是连在一起的，所以中文有多难，你想到了么？原来你也是个语言天才，而英语并不可怕，你有学会它的天赋，只要有这个打算。</p><p>再用 <code>{}</code></p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">${var// /}</span>
getthelengthofme<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>再用 <code>awk</code></p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{gsub(" ","",<span class="token variable">$0</span>); printf("%s\n", <span class="token variable">$0</span>);}'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再用 <code>sed</code></p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'s/ //g'</span>
getthelengthofme<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>还有更简单的 <code>tr</code> 命令，<code>tr</code> 也可以把空格给删除掉，看</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">tr</span> -d <span class="token string">" "</span>
getthelengthofme<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果要删除第一个空格后面所有的字符串该怎么办呢？还记得 <code>{}</code> 的 <code>#</code> 和 <code>%</code> 用法么？如果不记得，回到这节的开头开始复习吧。（实际上删除子串和取子串未尝不是两种互补的运算呢，删除掉某些不想要的子串，也就同时取得另外那些想要的子串——这个世界就是一个“二元”的世界，非常有趣）</p><h4 id="子串比较"><a href="#子串比较" class="headerlink" title="子串比较"></a>子串比较</h4><p>这个很简单：还记得 <code>test</code> 命令的用法么？ <code>help test</code> 。它可以用来判断两个字符串是否相等。另外，有发现“字符串是否相等”和“字符串能否跟另外一个字符串匹配 <code>&quot;</code> 两个问题之间的关系吗？如果两个字符串完全匹配，那么这两个字符串就相等了。所以呢，上面用到的字符串匹配方法，也同样可以用到这里。</p><h4 id="子串排序"><a href="#子串排序" class="headerlink" title="子串排序"></a>子串排序</h4><p>差点忘记这个重要内容了，子串排序可是经常用到，常见的有按字母序、数字序等正序或反序排列。 <code>sort</code> 命令可以用来做这个工作，它和其他行处理命令一样，是按行操作的，另外，它类似 <code>cut</code> 和 <code>awk</code>，可以指定分割符，并指定需要排序的列。</p><pre class="line-numbers language-bash"><code class="language-bash">$ var<span class="token operator">=</span><span class="token string">"get the length of me"</span>
$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">tr</span> <span class="token string">' '</span> <span class="token string">'\n'</span> <span class="token operator">|</span> <span class="token function">sort</span>   <span class="token comment" spellcheck="true">#正序排</span>
get
length
me
of
the
$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">tr</span> <span class="token string">' '</span> <span class="token string">'\n'</span> <span class="token operator">|</span> <span class="token function">sort</span> -r <span class="token comment" spellcheck="true">#反序排</span>
the
of
me
length
get
$ <span class="token function">cat</span> <span class="token operator">></span> data.txt
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
41 45 44 44 26 44 42 20 20 38 37 25 45 45 45
16 17 18 19 20 21 22 23 24 25 26 27 28 29 30
44 20 30 39 35 38 38 28 25 30 36 20 24 32 33
31 32 33 34 35 36 37 38 39 40 41 42 43 44 45
41 33 51 39 20 20 44 37 38 39 42 40 37 50 50
46 47 48 49 50 51 52 53 54 55 56
42 43 41 42 45 42 19 39 75 17 17
$ <span class="token function">cat</span> data.txt <span class="token operator">|</span> <span class="token function">sort</span> -k 2 -n
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
16 17 18 19 20 21 22 23 24 25 26 27 28 29 30
44 20 30 39 35 38 38 28 25 30 36 20 24 32 33
31 32 33 34 35 36 37 38 39 40 41 42 43 44 45
41 33 51 39 20 20 44 37 38 39 42 40 37 50 50
42 43 41 42 45 42 19 39 75 17 17
41 45 44 44 26 44 42 20 20 38 37 25 45 45 45
46 47 48 49 50 51 52 53 54 55 56<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="子串进制转换"><a href="#子串进制转换" class="headerlink" title="子串进制转换"></a>子串进制转换</h4><p>如果字母和数字字符用来计数，那么就存在进制转换的问题。在数值计算一节，已经介绍了 <code>bc</code> 命令，这里再复习一下。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token string">"ibase=10;obase=16;10"</span> <span class="token operator">|</span> <span class="token function">bc</span>
A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>说明： <code>ibase</code> 指定输入进制，<code>obase</code> 指出输出进制，这样通过调整 <code>ibase</code> 和 <code>obase</code>，你想怎么转就怎么转啦！</p><h4 id="子串编码转换"><a href="#子串编码转换" class="headerlink" title="子串编码转换"></a>子串编码转换</h4><p>什么是字符编码？这个就不用介绍了吧，看过那些乱七八糟显示的网页么？大多是因为浏览器显示时的”编码“和网页实际采用的”编码“不一致导致的。字符编码通常是指：把一序列”可打印“字符转换成二进制表示，而字符解码呢则是执行相反的过程，如果这两个过程不匹配，则出现了所谓的”乱码“。</p><p>为了解决”乱码“问题呢？就需要进行编码转换。在 Linux 下，我们可以使用 <code>iconv</code> 这个工具来进行相关操作。这样的情况经常在不同的操作系统之间移动文件，不同的编辑器之间交换文件的时候遇到，目前在 Windows 下常用的汉字编码是 <code>gb2312</code>，而在 Linux 下则大多采用 <code>utf8</code> 。</p><pre class="line-numbers language-bash"><code class="language-bash">$ nihao_utf8<span class="token operator">=</span><span class="token punctuation">$(</span>echo <span class="token string">"你好"</span><span class="token punctuation">)</span>
$ nihao_gb2312<span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token keyword">echo</span> $nihao_utf8 <span class="token operator">|</span> <span class="token function">iconv</span> -f utf8 -t gb2312<span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="字符串操作进阶"><a href="#字符串操作进阶" class="headerlink" title="字符串操作进阶"></a>字符串操作进阶</h3><p>实际上，在用 Bash 编程时，大部分时间都是在处理字符串，因此把这一节熟练掌握非常重要。</p><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><h5 id="范例：处理-URL-地址"><a href="#范例：处理-URL-地址" class="headerlink" title="范例：处理 URL 地址"></a>范例：处理 URL 地址</h5><p>URL 地址(URL（Uniform Resoure Locator：统一资源定位器）是WWW页的地址)几乎是我们日常生活的玩伴，我们已经到了无法离开它的地步啦，对它的操作很多，包括判断 URL 地址的有效性，截取地址的各个部分（服务器类型、服务器地址、端口、路径等）并对各个部分进行进一步的操作。</p><p>下面我们来具体处理这个URL地址：<a href="ftp://anonymous:ftp@mirror.lzu.edu.cn/software/scim-1.4.7.tar.gz">ftp://anonymous:ftp@mirror.lzu.edu.cn/software/scim-1.4.7.tar.gz</a></p><pre class="line-numbers language-bash"><code class="language-bash">$ url<span class="token operator">=</span><span class="token string">"ftp://anonymous:ftp@mirror.lzu.edu.cn/software/scim-1.4.7.tar.gz"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>匹配URL地址，判断URL地址的有效性</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$url</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"ftp://[a-z]*:[a-z]*@[a-z\./-]*"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>截取服务器类型</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">${url%%:*}</span>
<span class="token function">ftp</span>
$ <span class="token keyword">echo</span> <span class="token variable">$url</span> <span class="token operator">|</span> <span class="token function">cut</span> -d<span class="token string">":"</span> -f 1
<span class="token function">ftp</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>截取域名</p><pre class="line-numbers language-bash"><code class="language-bash">$ tmp<span class="token operator">=</span>$<span class="token punctuation">{</span>url<span class="token comment" spellcheck="true">##*@} ; echo ${tmp%%/*}</span>
mirror.lzu.edu.cn<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>截取路径</p><pre class="line-numbers language-bash"><code class="language-bash">$ tmp<span class="token operator">=</span>$<span class="token punctuation">{</span>url<span class="token comment" spellcheck="true">##*@} ; echo ${tmp%/*}</span>
mirror.lzu.edu.cn/software<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>截取文件名</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">basename</span> <span class="token variable">$url</span>
scim-1.4.7.tar.gz
$ <span class="token keyword">echo</span> $<span class="token punctuation">{</span>url<span class="token comment" spellcheck="true">##*/}</span>
scim-1.4.7.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>截取文件类型（扩展名）</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$url</span> <span class="token operator">|</span> <span class="token function">sed</span> -e <span class="token string">'s/.*[0-9].\(.*\)/\1/g'</span>
tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="范例：匹配某个文件中的特定范围的行"><a href="#范例：匹配某个文件中的特定范围的行" class="headerlink" title="范例：匹配某个文件中的特定范围的行"></a>范例：匹配某个文件中的特定范围的行</h5><p>先准备一个测试文件README</p><pre class="line-numbers language-bash"><code class="language-bash">Chapter 7 -- Exercises

7.1 please execute the program: mainwithoutreturn, and print the <span class="token keyword">return</span> value
of it with the <span class="token function">command</span> <span class="token string">"echo <span class="token variable">$?</span>"</span>, and <span class="token keyword">then</span> compare the <span class="token keyword">return</span> of the <span class="token function">printf</span>
function, they are the same.

7.2 it will depend on the exection mode, interactive or redirection to a file,
<span class="token keyword">if</span> interactive, the <span class="token string">"output"</span> action will accur after the \n char with the line
buffer mode, else, it will be really <span class="token string">"printed"</span> after all of the strings have
been stayed <span class="token keyword">in</span> the buffer.

7.3 there is no another effective method <span class="token keyword">in</span> <span class="token function">most</span> OS. because argc and argv are
not global variables like environ.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后开始实验，</p><p>打印出答案前指定行范围：第 7 行到第 9 行，刚好找出了第 2 题的答案</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sed</span> -n 7,9p README
7.2 it will depend on the exection mode, interactive or redirection to a file,
<span class="token keyword">if</span> interactive, the <span class="token string">"output"</span> action will accur after the \n char with the line
buffer mode, else, it will be really <span class="token string">"printed"</span> after all of the strings have<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其实，因为这个文件内容格式很有特色，有更简单的办法</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">awk</span> <span class="token string">'/7.2/,/^$/ {printf("%s\n", <span class="token variable">$0</span>);}'</span> README
7.2 it will depend on the exection mode, interactive or redirection to a file,
<span class="token keyword">if</span> interactive, the <span class="token string">"output"</span> action will accur after the \n char with the line
buffer mode, else, it will be really <span class="token string">"printed"</span> after all of the strings have
been stayed <span class="token keyword">in</span> the buffer.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了上面的知识，就可以非常容易地进行这些工作啦：修改某个文件的文件名，比如调整它的编码，下载某个网页里头的所有 <code>pdf</code> 文档等。这些就作为练习自己做吧。</p><h4 id="处理格式化的文本"><a href="#处理格式化的文本" class="headerlink" title="处理格式化的文本"></a>处理格式化的文本</h4><p>平时做工作，大多数时候处理的都是一些“格式化”的文本，比如类似 <code>/etc/passwd</code> 这样的有固定行和列的文本，也有类似 <code>tree</code> 命令输出的那种具有树形结构的文本，当然还有其他具有特定结构的文本。</p><p>实际上，只要把握好特性结构的一些特点，并根据具体的应用场合，处理起来就不会困难。</p><p>下面来介绍具体文本的操作，以 <code>/etc/passwd</code> 文件为例。关于这个文件的帮忙和用法，请通过 <code>man 5 passwd</code> 查看。下面对这个文件以及相关的文件进行一些有意义的操作。</p><h5 id="范例：选取指定列"><a href="#范例：选取指定列" class="headerlink" title="范例：选取指定列"></a>范例：选取指定列</h5><p>选取/etc/passwd文件中的用户名和组ID两列</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> /etc/passwd <span class="token operator">|</span> <span class="token function">cut</span> -d<span class="token string">":"</span> -f1,4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>选取/etc/group文件中的组名和组ID两列</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> /etc/group <span class="token operator">|</span> <span class="token function">cut</span> -d<span class="token string">":"</span> -f1,3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="范例：文件关联操作"><a href="#范例：文件关联操作" class="headerlink" title="范例：文件关联操作"></a>范例：文件关联操作</h5><p>如果想找出所有用户所在的组，怎么办？</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">join</span> -o 1.1,2.1 -t<span class="token string">":"</span> -1 4 -2 3 /etc/passwd /etc/group
root:root
bin:bin
daemon:daemon
adm:adm
lp:lp
pop:pop
nobody:nogroup
falcon:users<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明： <code>join</code> 命令用来连接两个文件，有点类似于数据库的两个表的连接。 <code>-t</code> 指定分割符，<code>-1 4 -2 3</code> 指定按照第一个文件的第 4 列和第二个文件的第 3 列，即组 <code>ID</code> 进行连接，<code>-o</code> <code>1.1,2.1</code> 表示仅仅输出第一个文件的第一列和第二个文件的第一列，这样就得到了我们要的结果，不过，可惜的是，这个结果并不准确，再进行下面的操作，你就会发现：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> /etc/passwd <span class="token operator">|</span> <span class="token function">sort</span> -t<span class="token string">":"</span> -n -k 4 <span class="token operator">></span> /tmp/passwd
$ <span class="token function">cat</span> /etc/group <span class="token operator">|</span> <span class="token function">sort</span> -t<span class="token string">":"</span> -n -k 3 <span class="token operator">></span> /tmp/group
$ <span class="token function">join</span> -o 1.1,2.1 -t<span class="token string">":"</span> -1 4 -2 3 /tmp/passwd /tmp/group
halt:root
operator:root
root:root
shutdown:root
sync:root
bin:bin
daemon:daemon
adm:adm
lp:lp
pop:pop
nobody:nogroup
falcon:users
games:users<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到这个结果才是正确的，所以以后使用 <code>join</code> 千万要注意这个问题，否则采取更保守的做法似乎更能保证正确性，更多关于文件连接的讨论见参考后续资料。</p><p>上面涉及到了处理某格式化行中的指定列，包括截取（如 <code>SQL</code> 的 <code>select</code> 用法），连接（如 <code>SQL</code> 的 <code>join</code> 用法），排序（如 <code>SQL</code> 的 <code>order by</code> 用法），都可以通过指定分割符来拆分某个格式化的行，另外，“截取”的做法还有很多，不光是 <code>cut</code>，<code>awk</code>，甚至通过 <code>IFS</code> 指定分割符的 <code>read</code> 命令也可以做到，例如：</p><pre class="line-numbers language-bash"><code class="language-bash">$ IFS<span class="token operator">=</span><span class="token string">":"</span><span class="token punctuation">;</span> <span class="token function">cat</span> /etc/group <span class="token operator">|</span> <span class="token keyword">while</span> <span class="token function">read</span> C1 C2 C3 C4<span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token keyword">echo</span> <span class="token variable">$C1</span> <span class="token variable">$C3</span><span class="token punctuation">;</span> <span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因此，熟悉这些用法，我们的工作将变得非常灵活有趣。</p><p>到这里，需要做一个简单的练习，如何把按照列对应的用户名和用户 ID 转换成按照行对应的，即把类似下面的数据：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> /etc/passwd <span class="token operator">|</span> <span class="token function">cut</span> -d<span class="token string">":"</span> -f1,3 --output-delimiter<span class="token operator">=</span><span class="token string">" "</span>
root 0
bin 1
daemon 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>转换成：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> a
root    bin     daemon
0       1       2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>并转换回去，有什么办法呢？记得诸如 <code>tr</code>，<code>paste</code>，<code>split</code> 等命令都可以使用。</p><p>参考方法：</p><ul><li>正转换：先截取用户名一列存入文件 <code>user</code>，再截取用户 <code>ID</code> 存入 <code>id</code>，再把两个文件用 <code>paste -s</code> 命令连在一起，这样就完成了正转换</li><li>逆转换：先把正转换得到的结果用 <code>split -1</code> 拆分成两个文件，再把两个拆分后的文件用 <code>tr</code> 把分割符 <code>\t</code> 替换成 <code>\n</code>，只有用 <code>paste</code> 命令把两个文件连在一起，这样就完成了逆转换。</li></ul><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="前言-3"><a href="#前言-3" class="headerlink" title="前言"></a>前言</h3><p>在日常学习和工作中，总是在不断地和各种文件打交道，这些文件包括普通文本文件，可以执行的程序，带有控制字符的文档、存放各种文件的目录、网络套接字文件、设备文件等。这些文件又具有诸如属主、大小、创建和修改日期等各种属性。文件对应文件系统的一些数据块，对应磁盘等存储设备的一片连续空间，对应于显示设备却是一些具有不同形状的字符集。</p><p>在这一节，为了把关注点定位在文件本身，不会深入探讨文件系统以及存储设备是如何组织文件的（在后续章节再深入探讨），而是探讨对它最熟悉的一面，即把文件当成是一系列的字符（一个 <code>byte</code>）集合看待。因此之前介绍的字符串操作在这里将会得到广泛的应用，关于普通文件的读写操作已经非常熟练，那就是“重定向”，这里会把这部分独立出来介绍。关于文件在 Linux 下的“数字化”（文件描述符）高度抽象，“一切皆为文件”的哲学在 Shell 编程里也得到了深刻的体现。</p><p>下面先来介绍文件的各种属性，然后介绍普通文件的一般操作。</p><h3 id="文件的各种属性"><a href="#文件的各种属性" class="headerlink" title="文件的各种属性"></a>文件的各种属性</h3><p>首先通过文件的结构体来看看文件到底有哪些属性：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> stat <span class="token punctuation">{</span>
    dev_t st_dev<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 设备   */</span>
    ino_t st_ino<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 节点   */</span>
    mode_t st_mode<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 模式   */</span>
    nlink_t st_nlink<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 硬连接 */</span>
    uid_t st_uid<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 用户ID */</span>
    gid_t st_gid<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 组ID   */</span>
    dev_t st_rdev<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 设备类型 */</span>
    off_t st_off<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 文件字节数 */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>  st_blksize<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 块大小 */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> st_blocks<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 块数   */</span>
    time_t st_atime<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 最后一次访问时间 */</span>
    time_t st_mtime<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 最后一次修改时间 */</span>
    time_t st_ctime<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 最后一次改变时间(指属性) */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面逐次来了解这些属性，如果需要查看某个文件属性，用 <code>stat</code> 命令就可，它会按照上面的结构体把信息列出来。另外，<code>ls</code> 命令在跟上一定参数后也可以显示文件的相关属性，比如 <code>-l</code> 参数。</p><h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h4><p>文件类型对应于上面的 <code>st_mode</code>, 文件类型有很多，比如常规文件、符号链接（硬链接、软链接）、管道文件、设备文件(符号设备、块设备)、socket文件等，不同的文件类型对应不同的功能和作用。</p><h5 id="范例：在命令行简单地区分各类文件"><a href="#范例：在命令行简单地区分各类文件" class="headerlink" title="范例：在命令行简单地区分各类文件"></a>范例：在命令行简单地区分各类文件</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ls</span> -l
total 12
drwxr-xr-x 2 root root 4096 2007-12-07 20:08 directory_file
prw-r--r-- 1 root root    0 2007-12-07 20:18 fifo_pipe
brw-r--r-- 1 root root 3, 1 2007-12-07 21:44 hda1_block_dev_file
crw-r--r-- 1 root root 1, 3 2007-12-07 21:43 null_char_dev_file
-rw-r--r-- 2 root root  506 2007-12-07 21:55 regular_file
-rw-r--r-- 2 root root  506 2007-12-07 21:55 regular_file_hard_link
lrwxrwxrwx 1 root root   12 2007-12-07 20:15 regular_file_soft_link -<span class="token operator">></span> regular_file
$ <span class="token function">stat</span> directory_file/
  File: `directory_file/<span class="token string">'
  Size: 4096            Blocks: 8          IO Block: 4096   directory
Device: 301h/769d       Inode: 521521      Links: 2
Access: (0755/drwxr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2007-12-07 20:08:18.000000000 +0800
Modify: 2007-12-07 20:08:18.000000000 +0800
Change: 2007-12-07 20:08:18.000000000 +0800
$ stat null_char_dev_file
  File: `null_char_dev_file'</span>
  Size: 0               Blocks: 0          IO Block: 4096   character special <span class="token function">file</span>
Device: 301h/769d       Inode: 521240      Links: 1     Device type: 1,3
Access: <span class="token punctuation">(</span>0644/crw-r--r--<span class="token punctuation">)</span>  Uid: <span class="token punctuation">(</span>    0/    root<span class="token punctuation">)</span>   Gid: <span class="token punctuation">(</span>    0/    root<span class="token punctuation">)</span>
Access: 2007-12-07 21:43:38.000000000 +0800
Modify: 2007-12-07 21:43:38.000000000 +0800
Change: 2007-12-07 21:43:38.000000000 +0800<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：通过 <code>ls</code> 命令结果每行的第一个字符可以看到，它们之间都不相同，这正好反应了不同文件的类型。 <code>d</code> 表示目录，<code>-</code> 表示普通文件（或者硬链接），<code>l</code> 表示符号链接，<code>p</code> 表示管道文件，<code>b</code> 和 <code>c</code> 分别表示块设备和字符设备（另外 <code>s</code> 表示 <code>socket</code> 文件）。在 <code>stat</code> 命令的结果中，可以在第二行的最后找到说明，从上面的操作可以看出，<code>directory_file</code> 是目录，<code>stat</code> 命令的结果中用 <code>directory</code> 表示，而 <code>null_char_dev_file</code> 它则用 <code>character special file</code> 说明。</p><h5 id="范例：简单比较它们的异同"><a href="#范例：简单比较它们的异同" class="headerlink" title="范例：简单比较它们的异同"></a>范例：简单比较它们的异同</h5><p>通常只会用到目录、普通文件、以及符号链接，很少碰到其他类型的文件，不过这些文件还是各有用处的，如果要做嵌入式开发或者进程通信等，可能会涉及到设备文件、有名管道（FIFO）。下面通过简单的操作来反应它们之间的区别（具体原理会在下一节介绍，如果感兴趣，也可以提前到网上找找设备文件的作用、块设备和字符设备的区别、以及驱动程序中如何编写相关设备驱动等）。</p><p>对于普通文件：就是一系列字符的集合，所以可以读、写等</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token string">"hello, world"</span> <span class="token operator">></span> regular_file
$ <span class="token function">cat</span> regular_file
hello, world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在目录中可以创建新文件，所以目录还有叫法：文件夹，到后面会分析目录文件的结构体，它实际上存放了它下面的各个文件的文件名。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cd</span> directory_file
$ <span class="token function">touch</span> file1 file2 file3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对于有名管道，操作起来比较有意思：如果要读它，除非有内容，否则阻塞；如果要写它，除非有人来读，否则阻塞。它常用于进程通信中。可以打开两个终端 <code>terminal1</code> 和 <code>terminal2</code>，试试看：</p><pre class="line-numbers language-bash"><code class="language-bash">terminal1$ <span class="token function">cat</span> fifo_pipe <span class="token comment" spellcheck="true">#刚开始阻塞在这里，直到下面的写动作发生，才打印test字符串</span>
terminal2$ <span class="token keyword">echo</span> <span class="token string">"test"</span> <span class="token operator">></span> fifo_pipe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>关于块设备，字符设备，设备文件对应于 <code>/dev/hda1</code> 和 <code>/dev/null</code>，如果用过 U 盘，或者是写过简单的脚本的话，这样的用法应该用过： :-)</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">mount</span> hda1_block_dev_file /mnt <span class="token comment" spellcheck="true">#挂载硬盘的第一个分区到/mnt下（关于挂载的原理，在下一节讨论）</span>
$ <span class="token keyword">echo</span> <span class="token string">"fewfewfef"</span> <span class="token operator">></span> /dev/null   <span class="token comment" spellcheck="true">#/dev/null像个黑洞，什么东西丢进去都消失殆尽</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>最后两个文件分别是 <code>regular_file</code> 文件的硬链接和软链接，去读写它们，他们的内容是相同的，不过去删除它们，他们却互不相干，硬链接和软链接又有何不同呢？前者可以说就是原文件，后者呢只是有那么一个 <code>inode</code>，但没有实际的存储空间，建议用 <code>stat</code> 命令查看它们之间的区别，包括它们的 <code>Blocks</code>，<code>inode</code> 等值，也可以考虑用 <code>diff</code> 比较它们的大小。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ls</span> regular_file*
<span class="token function">ls</span> regular_file* -l
-rw-r--r-- 2 root root 204800 2007-12-07 22:30 regular_file
-rw-r--r-- 2 root root 204800 2007-12-07 22:30 regular_file_hard_link
lrwxrwxrwx 1 root root     12 2007-12-07 20:15 regular_file_soft_link -<span class="token operator">></span> regular_file
$ <span class="token function">rm</span> regular_file      <span class="token comment" spellcheck="true"># 删除原文件</span>
$ <span class="token function">cat</span> regular_file_hard_link   <span class="token comment" spellcheck="true"># 硬链接还在，而且里头的内容还有呢</span>
fefe
$ <span class="token function">cat</span> regular_file_soft_link
cat: regular_file_soft_link: No such <span class="token function">file</span> or directory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然软链接文件本身还在，不过因为它本身不存储内容，所以读不到东西，这就是软链接和硬链接的区别。</p><p>需要注意的是，硬链接不可以跨文件系统，而软链接则可以。另外，也不允许给目录创建硬链接。</p><h5 id="范例：普通文件再分类"><a href="#范例：普通文件再分类" class="headerlink" title="范例：普通文件再分类"></a>范例：普通文件再分类</h5><p>文件类型从 Linux 文件系统那么一个级别分了以上那么多类型，不过普通文件还是可以再分的（根据文件内容的”数据结构“分），比如常见的文本文件，可执行的 <code>ELF</code> 文件，<code>odt</code> 文档，<code>jpg</code> 图片格式，<code>swap</code> 分区文件，<code>pdf</code> 文件。除了文本文件外，它们大多是二进制文件，有特定的结构，因此需要有专门的工具来创建和编辑它们。关于各类文件的格式，可以参考相关文档标准。不过非常值得深入了解 Linux 下可执行的 <code>ELF</code> 文件的工作原理，如果有兴趣，建议阅读一下参考资料中和 <code>ELF</code> 文件相关部分，这一部分对于嵌入式 Linux 工程师至关重要。</p><p>虽然各类普通文件都有专属的操作工具，但是还是可以直接读、写它们，这里先提到这么几个工具，回头讨论细节。</p><ul><li><code>od</code> ：以八进制或者其他格式“导出”文件内容。</li><li><code>strings</code> ：读出文件中的字符（可打印的字符）</li><li><code>gcc</code>，<code>gdb</code>，<code>readelf</code>，objdump<code>等：</code>ELF<code>文件分析、处理工具（</code>gcc<code>编译器、</code>gdb<code>调试器、</code>readelf<code>分析 ELF 文件，</code>objdump` 反编译工具）</li></ul><p>再补充一个非常重要的命令，<code>file</code>，这个命令用来查看各类文件的属性。和 <code>stat</code> 命令相比，它可以进一步识别普通文件，即 <code>stat</code> 命令显示的 <code>regular file</code> 。因为 <code>regular file</code> 可以有各种不同的结构，因此在操作系统的支持下得到不同的解释，执行不同的动作。虽然，Linux 下，文件也会加上特定的后缀以便用户能够方便地识别文件的类型，但是 Linux 操作系统根据文件头识别各类文件，而不是文件后缀，这样在解释相应的文件时就更不容易出错。下面简单介绍 <code>file</code> 命令的用法。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">file</span> ./
./: directory
$ <span class="token function">file</span> /etc/profile
/etc/profile: ASCII English text
$ <span class="token function">file</span> /lib/libc-2.5.so
/lib/libc-2.5.so: ELF 32-bit LSB shared object, Intel 80386, version 1 <span class="token punctuation">(</span>SYSV<span class="token punctuation">)</span>, not stripped
$ <span class="token function">file</span> /bin/test
/bin/test: ELF 32-bit LSB executable, Intel 80386, version 1 <span class="token punctuation">(</span>SYSV<span class="token punctuation">)</span>, dynamically linked <span class="token punctuation">(</span>uses shared libs<span class="token punctuation">)</span>, stripped
$ <span class="token function">file</span> /dev/hda
/dev/hda: block special <span class="token punctuation">(</span>3/0<span class="token punctuation">)</span>
$ <span class="token function">file</span> /dev/console
/dev/console: character special <span class="token punctuation">(</span>5/1<span class="token punctuation">)</span>
$ <span class="token function">cp</span> /etc/profile <span class="token keyword">.</span>
$ <span class="token function">tar</span> zcf profile.tar.gz profile
$ <span class="token function">file</span> profile.tar.gz
profile.tar.gz: <span class="token function">gzip</span> compressed data, from Unix, last modified: Tue Jan  4 18:53:53 2000
$ <span class="token function">mkfifo</span> fifo_test
$ <span class="token function">file</span> fifo_test
fifo_test: fifo <span class="token punctuation">(</span>named pipe<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更多用法见 <code>file</code> 命令的手册，关于 <code>file</code> 命令的实现原理，请参考 <code>magic</code> 的手册（看看 <code>/etc/file/magic</code> 文件，了解什么是文件的 <code>magic number</code> 等）。</p><h4 id="文件属主"><a href="#文件属主" class="headerlink" title="文件属主"></a>文件属主</h4><p>Linux 作为一个多用户系统，为多用户使用同一个系统提供了极大的方便，比如对于系统上的文件，它通过属主来区分不同的用户，以便分配它们对不同文件的操作权限。为了更方便地管理，文件属主包括该文件所属用户，以及该文件所属的用户组，因为用户可以属于多个组。先来简单介绍 Linux 下用户和组的管理。</p><p>Linux 下提供了一组命令用于管理用户和组，比如用于创建用户的 <code>useradd</code> 和 <code>groupadd</code>，用于删除用户的 <code>userdel</code> 和 <code>groupdel</code>，另外，<code>passwd</code> 命令用于修改用户密码。当然，Linux 还提供了两个相应的配置，即 <code>/etc/passwd</code> 和 <code>/etc/group</code>，另外，有些系统还把密码单独放到了配置文件 <code>/etc/shadow</code> 中。关于它们的详细用法请参考后面的资料，这里不再介绍，仅介绍文件和用户之间的一些关系。</p><h5 id="范例：修改文件的属主"><a href="#范例：修改文件的属主" class="headerlink" title="范例：修改文件的属主"></a>范例：修改文件的属主</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">chown</span> 用户名:组名 文件名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果要递归地修改某个目录下所有文件的属主，可以添加 <code>-R</code> 选项。</p><p>从本节开头列出的文件结构体中，可以看到仅仅有用户 <code>ID</code> 和组 <code>ID</code> 的信息，但 <code>ls -l</code> 的结果却显示了用户名和组名信息，这个是怎么实现的呢？下面先看看 <code>-n</code> 的结果：</p><h5 id="范例：查看文件的属主"><a href="#范例：查看文件的属主" class="headerlink" title="范例：查看文件的属主"></a>范例：查看文件的属主</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ls</span> -n regular_file
-rw-r--r-- 1 0 0 115 2007-12-07 23:45 regular_file
$ <span class="token function">ls</span> -l regular_file
-rw-r--r-- 1 root root 115 2007-12-07 23:45 regular_file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="范例：分析文件属主实现的背后原理"><a href="#范例：分析文件属主实现的背后原理" class="headerlink" title="范例：分析文件属主实现的背后原理"></a>范例：分析文件属主实现的背后原理</h5><p>可以看到，<code>ls -n</code> 显示了用户 <code>ID</code> 和组 <code>ID</code>，而 <code>ls -l</code> 显示了它们的名字。还记得上面提到的两个配置文件 <code>/etc/passwd</code> 和 <code>/etc/group</code> 文件么？它们分别存放了用户 <code>ID</code> 和用户名，组 <code>ID</code> 和组名的对应关系，因此很容易想到 <code>ls -l</code> 命令在实现时是如何通过文件结构体的 <code>ID</code> 信息找到它们对应的名字信息的。如果想对 <code>ls -l</code> 命令的实现有更进一步的了解，可以用 <code>strace</code> 跟踪看看它是否读取了这两个配置文件。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">strace</span> -f -o strace.log <span class="token function">ls</span> -l regular_file
$ <span class="token function">cat</span> strace.log <span class="token operator">|</span> <span class="token function">egrep</span> <span class="token string">"passwd|group|shadow"</span>
2989  open<span class="token punctuation">(</span><span class="token string">"/etc/passwd"</span>, O_RDONLY<span class="token punctuation">)</span>     <span class="token operator">=</span> 3
2989  open<span class="token punctuation">(</span><span class="token string">"/etc/group"</span>, O_RDONLY<span class="token punctuation">)</span>      <span class="token operator">=</span> 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>说明： <code>strace</code> 可以用来跟踪系统调用和信号。如同 <code>gdb</code> 等其他强大的工具一样，它基于系统的 <code>ptrace</code> 系统调用实现。</p><p>实际上，把属主和权限分开介绍不太好，因为只有它们两者结合才使得多用户系统成为可能，否则无法隔离不同用户对某个文件的操作，所以下面来介绍文件操作权限。</p><h4 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h4><p>从 <code>ls -l</code> 命令的结果的第一列的后 9 个字符中，可以看到类似这样的信息 <code>rwxr-xr-x</code>，它们对应于文件结构体的 <code>st_mode</code> 部分（<code>st_mode</code> 包含文件类型信息和文件权限信息两部分）。这类信息可以分成三部分，即 <code>rwx</code>，<code>r-x</code>，<code>r-x</code>，分别对应该文件所属用户、所属组、其他组对该文件的操作权限，如果有 <code>rwx</code> 中任何一个表示可读、可写、可执行，如果为 <code>-</code> 表示没有这个权限。对应地，可以用八进制来表示它，比如 <code>rwxr-xr-x</code> 就可表示成二进制 111101101，对应的八进制则为 755 。正因为如此，要修改文件的操作权限，也可以有多种方式来实现，它们都可通过 <code>chmod</code> 命令来修改。</p><h5 id="范例：给文件添加读、写、可执行权限"><a href="#范例：给文件添加读、写、可执行权限" class="headerlink" title="范例：给文件添加读、写、可执行权限"></a>范例：给文件添加读、写、可执行权限</h5><p>比如，把 <code>regular_file</code> 的文件权限修改为所有用户都可读、可写、可执行，即 <code>rwxrwxrwx</code>，也可表示为 111111111，翻译成八进制，则为 777 。这样就可以通过两种方式修改这个权限。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">chmod</span> a+rwx regular_file<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">chmod</span> 777 regular_file<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>说明： <code>a</code> 指所有用户，如果只想给用户本身可读可写可执行权限，那么可以把 <code>a</code> 换成 <code>u</code> ；而 <code>+</code> 就是添加权限，相反的，如果想去掉某个权限，用 <code>-</code>，而 <code>rwx</code> 则对应可读、可写、可执行。更多用法见 <code>chmod</code> 命令的帮助。</p><p>实际上除了这些权限外，还有两个涉及到安全方面的权限，即 <code>setuid/setgid</code> 和只读控制等。</p><p>如果设置了文件（程序或者命令）的 <code>setuid/setgid</code> 权限，那么用户将可用 <code>root</code> 身份去执行该文件，因此，这将可能带来安全隐患；如果设置了文件的只读权限，那么用户将仅仅对该文件将有可读权限，这为避免诸如 <code>rm -rf</code> 的“可恶”操作带来一定的庇佑。</p><h5 id="范例：授权普通用户执行root所属命令"><a href="#范例：授权普通用户执行root所属命令" class="headerlink" title="范例：授权普通用户执行root所属命令"></a>范例：授权普通用户执行root所属命令</h5><p>默认情况下，系统是不允许普通用户执行 <code>passwd</code> 命令的，通过 <code>setuid/setgid</code>，可以授权普通用户执行它。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ls</span> -l /usr/bin/passwd
-rwx--x--x 1 root root 36092 2007-06-19 14:59 /usr/bin/passwd
$ <span class="token function">su</span>      <span class="token comment" spellcheck="true">#切换到root用户，给程序或者命令添加“粘着位”</span>
$ <span class="token function">chmod</span> +s /usr/bin/passwd
$ <span class="token function">ls</span> -l /usr/bin/passwd
-rws--s--x 1 root root 36092 2007-06-19 14:59 /usr/bin/passwd
$ <span class="token keyword">exit</span>
$ <span class="token function">passwd</span> <span class="token comment" spellcheck="true">#普通用户通过执行该命令，修改自己的密码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><blockquote><p><code>setuid</code> 和 <code>setgid</code> 位是让普通用户可以以 <code>root</code> 用户的角色运行只有 <code>root</code> 帐号才能运行的程序或命令。</p></blockquote><p>虽然这在一定程度上为管理提供了方便，比如上面的操作让普通用户可以修改自己的帐号，而不是要 <code>root</code> 帐号去为每个用户做这些工作。关于 <code>setuid/setgid</code> 的更多详细解释，请参考最后推荐的资料。</p><h5 id="范例：给重要文件加锁"><a href="#范例：给重要文件加锁" class="headerlink" title="范例：给重要文件加锁"></a>范例：给重要文件加锁</h5><p>只读权限示例：给重要文件加锁（添加不可修改位 [immutable]))，以避免各种误操作带来的灾难性后果（例如 <code>:</code> <code>rm -rf</code>）</p><pre class="line-numbers language-bash"><code class="language-bash">$ chattr +i regular_file
$ lsattr regular_file
----i-------- regular_file
$ <span class="token function">rm</span> regular_file    <span class="token comment" spellcheck="true">#加immutable位后就无法对文件进行任何“破坏性”的活动啦</span>
rm: remove write-protected regular <span class="token function">file</span> `regular_file<span class="token string">'? y
rm: cannot remove `regular_file'</span><span class="token keyword">:</span> Operation not permitted
$ chattr -i regular_file <span class="token comment" spellcheck="true">#如果想对它进行常规操作，那么可以把这个位去掉</span>
$ <span class="token function">rm</span> regular_file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明： <code>chattr</code> 可以用于设置文件的特殊权限，更多用法请参考 <code>chattr</code> 的帮助。</p><h4 id="文件大小"><a href="#文件大小" class="headerlink" title="文件大小"></a>文件大小</h4><p>文件大小对于普通文件而言就是文件内容的大小，而目录作为一个特殊的文件，它存放的内容是以目录结构体组织的各类文件信息，所以目录的大小一般都是固定的，它存放的文件个数自然也就有上限，即它的大小除以文件名的长度。设备文件的“文件大小”则对应设备的主、次设备号，而有名管道文件因为特殊的读写性质，所以大小常是 0 。硬链接（目录文件不能创建硬链接）实质上是原文件的一个完整的拷贝，因此，它的大小就是原文件的大小。而软链接只是一个 <code>inode</code>，存放了一个指向原文件的指针，因此它的大小仅仅是原文件名的字节数。下面我们通过演示增加记忆。</p><h5 id="范例：查看普通文件和链接文件"><a href="#范例：查看普通文件和链接文件" class="headerlink" title="范例：查看普通文件和链接文件"></a>范例：查看普通文件和链接文件</h5><p>原文件，链接文件文件大小的示例：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> -n <span class="token string">"abcde"</span> <span class="token operator">></span> regular_file   <span class="token comment" spellcheck="true">#往regular_file写入5字节</span>
$ <span class="token function">ls</span> -l regular_file*
-rw-r--r-- 2 root root  5 2007-12-08 15:28 regular_file
-rw-r--r-- 2 root root  5 2007-12-08 15:28 regular_file_hard_file
lrwxrwxrwx 1 root root 12 2007-12-07 20:15 regular_file_soft_link -<span class="token operator">></span> regular_file
lrwxrwxrwx 1 root root 22 2007-12-08 15:21 regular_file_soft_link_link -<span class="token operator">></span> regular_file_soft_link
$ i<span class="token operator">=</span><span class="token string">"regular_file"</span>
$ j<span class="token operator">=</span><span class="token string">"regular_file_soft_link"</span>
$ <span class="token keyword">echo</span> <span class="token variable">${#i}</span> <span class="token variable">${#j}</span>   <span class="token comment" spellcheck="true">#软链接存放的刚好是它们指向的原文件的文件名的字节数</span>
12 22<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="范例：查看设备文件"><a href="#范例：查看设备文件" class="headerlink" title="范例：查看设备文件"></a>范例：查看设备文件</h5><p>设备号对应的文件大小：主、次设备号</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ls</span> -l hda1_block_dev_file
brw-r--r-- 1 root root 3, 1 2007-12-07 21:44 hda1_block_dev_file
$ <span class="token function">ls</span> -l null_char_dev_file
crw-r--r-- 1 root root 1, 3 2007-12-07 21:43 null_char_dev_file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>补充：主 <code>(major)、次</code>(minor)设备号的作用有不同。当一个设备文件被打开时，内核会根据主设备号（<code>major number</code>）去查找在内核中已经以主设备号注册的驱动（可以 <code>cat /proc/devices</code> 查看已经注册的驱动号和主设备号的对应情况），而次设备号（<code>minor number</code>）则是通过内核传递给了驱动本身（参考《The Linux Primer》第十章）。因此，对于内核而言，通过主设备号就可以找到对应的驱动去识别某个设备，而对于驱动而言，为了能够更复杂地访问设备，比如访问设备的不同部分（如硬件通过分区分成不同部分，而出现 <code>hda1</code>，<code>hda2</code>，<code>hda3</code> 等），比如产生不同要求的随机数（如 <code>/dev/random</code> 和 <code>/dev/urandom</code> 等）。</p><h5 id="范例：查看目录"><a href="#范例：查看目录" class="headerlink" title="范例：查看目录"></a>范例：查看目录</h5><p>目录文件的大小，为什么是这样呢？看看下面的目录结构体的大小，目录文件的 Block 中存放了该目录下所有文件名的入口。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ls</span> -ld directory_file/
drwxr-xr-x 2 root root 4096 2007-12-07 23:14 directory_file/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>目录的结构体如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> dirent <span class="token punctuation">{</span>
    <span class="token keyword">long</span> d_ino<span class="token punctuation">;</span>
    off_t d_off<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> d_reclen<span class="token punctuation">;</span>
    <span class="token keyword">char</span> d_name<span class="token punctuation">[</span>NAME_MAX<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 文件名称 */</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="文件访问、更新、修改时间"><a href="#文件访问、更新、修改时间" class="headerlink" title="文件访问、更新、修改时间"></a>文件访问、更新、修改时间</h4><p>文件的时间属性可以记录用户对文件的操作信息，在系统管理、判断文件版本信息等情况下将为管理员提供参考。因此，在阅读文件时，建议用 <code>cat</code> 等阅读工具，不要用编辑工具 <code>vim</code> 去阅读，因为即使没有做任何修改操作，一旦执行了保存命令，将修改文件的时间戳信息。</p><h4 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h4><p>文件名并没有存放在文件结构体内，而是存放在它所在的目录结构体中。所以，在目录的同一级别中，文件名必须是唯一的。</p><h3 id="文件的基本操作"><a href="#文件的基本操作" class="headerlink" title="文件的基本操作"></a>文件的基本操作</h3><p>对于文件，常见的操作包括创建、删除、修改、读、写等。关于各种操作对应的“背后动作”将在下一节详细分析。</p><h4 id="范例：创建文件"><a href="#范例：创建文件" class="headerlink" title="范例：创建文件"></a>范例：创建文件</h4><p><code>socket</code> 文件是一类特殊的文件，可以通过 C 语言创建，这里不做介绍（暂时不知道是否可以用命令直接创建），其他文件将通过命令创建。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">touch</span> regular_file      <span class="token comment" spellcheck="true">#创建普通文件</span>
$ <span class="token function">mkdir</span> directory_file     <span class="token comment" spellcheck="true">#创建目录文件，目录文件里头可以包含更多文件</span>
$ <span class="token function">ln</span> regular_file regular_file_hard_link  <span class="token comment" spellcheck="true">#硬链接，是原文件的一个完整拷比</span>
$ <span class="token function">ln</span> -s regular_file regular_file_soft_link  <span class="token comment" spellcheck="true">#类似一个文件指针，指向原文件</span>
$ <span class="token function">mkfifo</span> fifo_pipe   <span class="token comment" spellcheck="true">#或者通过 "mknod fifo_pipe p" 来创建，FIFO满足先进先出的特点</span>
$ <span class="token function">mknod</span> hda1_block_dev_file b 3 1  <span class="token comment" spellcheck="true">#块设备</span>
$ <span class="token function">mknod</span> null_char_dev_file c 1 3   <span class="token comment" spellcheck="true">#字符设备</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建一个文件实际上是在文件系统中添加了一个节点（<code>inode)，该节点信息将保存到文件系统的节点表中。更形象地说，就是在一颗树上长了一颗新的叶子（文件）或者枝条（目录文件，上面还可以长叶子的那种），这些可以通过</code>tree<code>命令或者</code>ls` 命令形象地呈现出来。文件系统从日常使用的角度，完全可以当成一颗倒立的树来看，因为它们太像了，太容易记忆啦。</p><pre class="line-numbers language-bash"><code class="language-bash">$ tree 当前目录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ls</span> 当前目录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="范例：删除文件"><a href="#范例：删除文件" class="headerlink" title="范例：删除文件"></a>范例：删除文件</h4><p>删除文件最直接的印象是这个文件再也不存在了，这同样可以通过 <code>ls</code> 或者 <code>tree</code> 命令呈现出来，就像树木被砍掉一个分支或者摘掉一片叶子一样。实际上，这些文件删除之后，并不是立即消失了，而是仅仅做了删除标记，因此，如果删除之后，没有相关的磁盘写操作把相应的磁盘空间“覆盖”，那么原理上是可以恢复的（虽然如此，但是这样的工作往往很麻烦，所以在删除一些重要数据时，请务必三思而后行，比如做好备份工作），相应的做法可以参考后续资料。</p><p>具体删除文件的命令有 <code>rm</code>，如果要删除空目录，可以用 <code>rmdir</code> 命令。例如：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">rm</span> regular_file
$ <span class="token function">rmdir</span> directory_file
$ <span class="token function">rm</span> -r directory_file_not_empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>rm</code> 有两个非常重要的参数，一个是 <code>-f</code>，这个命令是非常“野蛮的”，它估计给很多 Linux user 带来了痛苦，另外一个是 <code>-i</code>，这个命令是非常“温柔的”，它估计让很多用户感觉烦躁不已。用哪个还是根据您的“心情”吧，如果做好了充分的备份工作，或者采取了一些有效避免灾难性后果的动作的话，您在做这些工作的时候就可以放心一些啦。</p><h4 id="范例：复制文件"><a href="#范例：复制文件" class="headerlink" title="范例：复制文件"></a>范例：复制文件</h4><p>文件的复制通常是指文件内容的“临时”复制。通过这一节开头的介绍，我们应该了解到，文件的硬链接和软链接在某种意义上说也是“文件的复制”，前者同步复制文件内容，后者在读写的情况下同步“复制”文件内容。例如：</p><p>用 <code>cp</code> 命令常规地复制文件（复制目录需要 <code>-r</code> 选项）</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cp</span> regular_file regular_file_copy
$ <span class="token function">cp</span> -r diretory_file directory_file_copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>创建硬链接（<code>link</code> 和 <code>copy</code> 不同之处是：<code>link</code> 为同步更新，<code>copy</code> 则不然，复制之后两者不再相关）</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ln</span> regular_file regular_file_hard_link<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建软链接</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ln</span> -s regular_file regluar_file_soft_link<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="范例：修改文件名"><a href="#范例：修改文件名" class="headerlink" title="范例：修改文件名"></a>范例：修改文件名</h4><p>修改文件名实际上仅仅修改了文件名标识符。可以通过 <code>mv</code> 命令来实现修改文件名操作（即重命名）。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">mv</span> regular_file regular_file_new_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="范例：编辑文件"><a href="#范例：编辑文件" class="headerlink" title="范例：编辑文件"></a>范例：编辑文件</h4><p>编辑文件实际上是操作文件的内容，对应普通文本文件的编辑，这里主要涉及到文件内容的读、写、追加、删除等。这些工作通常会通过专门的编辑器来做，这类编辑器有命令行下的 <code>vim</code> 、 <code>emacs</code> 和图形界面下的 <code>gedit,kedit</code> 等。如果是一些特定的文件，会有专门的编辑和处理工具，比如图像处理软件 <code>gimp</code>，文档编辑软件 <code>OpenOffice</code> 等。这些工具一般都会有专门的教程。</p><p>下面主要简单介绍 Linux 下通过重定向来实现文件的这些常规的编辑操作。</p><p>创建一个文件并写入 <code>abcde</code></p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token string">"abcde"</span> <span class="token operator">></span> new_regular_file<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再往上面的文件中追加一行 <code>abcde</code></p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token string">"abcde"</span> <span class="token operator">>></span> new_regular_file<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>按行读一个文件</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">while</span> <span class="token function">read</span> LINE<span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token keyword">echo</span> <span class="token variable">$LINE</span><span class="token punctuation">;</span> <span class="token keyword">done</span> <span class="token operator">&lt;</span> test.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>提示：如果要把包含重定向的字符串变量当作命令来执行，请使用 <code>eval</code> 命令，否则无法解释重定向。例如，</p><pre class="line-numbers language-bash"><code class="language-bash">$ redirect<span class="token operator">=</span><span class="token string">"echo \"abcde\" >test_redirect_file"</span>
$ <span class="token variable">$redirect</span>   <span class="token comment" spellcheck="true">#这里会把>当作字符 > 打印出来，而不会当作 重定向 解释</span>
<span class="token string">"abcde"</span> <span class="token operator">></span>test_redirect_file
$ <span class="token function">eval</span> <span class="token variable">$redirect</span>    <span class="token comment" spellcheck="true">#这样才会把 > 解释成 重定向</span>
$ <span class="token function">cat</span> test_redirect_file
abcde<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="范例：压缩／解压缩文件"><a href="#范例：压缩／解压缩文件" class="headerlink" title="范例：压缩／解压缩文件"></a>范例：压缩／解压缩文件</h4><p>压缩和解压缩文件在一定意义上来说是为了方便文件内容的传输，不过也可能有一些特定的用途，比如内核和文件系统的映像文件等（更多相关的知识请参考后续资料）。</p><p>这里仅介绍几种常见的压缩和解压缩方法：</p><p>tar</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">tar</span> -cf file.tar <span class="token function">file</span>   <span class="token comment" spellcheck="true">#压缩</span>
$ <span class="token function">tar</span> -xf file.tar    <span class="token comment" spellcheck="true">#解压</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>gz</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">gzip</span>  -9 <span class="token function">file</span>
$ gunzip <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>tar.gz</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">tar</span> -zcf file.tar.gz <span class="token function">file</span>
$ <span class="token function">tar</span> -zxf file.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>bz2</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">bzip2</span> <span class="token function">file</span>
$ bunzip2 <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>tar.bz2</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">tar</span> -jcf file.tar.bz2 <span class="token function">file</span>
$ <span class="token function">tar</span> -jxf file.tar.bz2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过上面的演示，应该已经非常清楚 <code>tar</code>，<code>bzip2，</code>bunzip2，<code>gzip，</code>gunzip<code>命令的角色了吧？如果还不清楚，多操作和比较一些上面的命令，并查看它们的手册：</code>man tar`…</p><h4 id="范例：文件搜索（文件定位）"><a href="#范例：文件搜索（文件定位）" class="headerlink" title="范例：文件搜索（文件定位）"></a>范例：文件搜索（文件定位）</h4><p>文件搜索是指在某个目录层次中找出具有某些属性的文件在文件系统中的位置，这个位置如果扩展到整个网络，那么可以表示为一个 <code>URL</code> 地址，对于本地的地址，可以表示为 <code>file://+</code> 本地路径。本地路径在 Linux 系统下是以 <code>/</code> 开头，例如，每个用户的家目录可以表示为： <code>file:///home/</code> 。下面仅仅介绍本地文件搜索的一些办法。</p><p><code>find</code> 命令提供了一种“及时的”搜索办法，它根据用户的请求，在指定的目录层次中遍历所有文件直到找到需要的文件为止。而 <code>updatedb+locate</code> 提供了一种“快速的”的搜索策略，<code>updatedb</code> 更新并产生一个本地文件数据库，而 <code>locate</code> 通过文件名检索这个数据库以便快速找到相应的文件。前者支持通过各种文件属性进行搜索，并且提供了一个接口（<code>-exec</code> 选项）用于处理搜索后的文件。因此为“单条命令”脚本的爱好者提供了极大的方便，不过对于根据文件名的搜索而言，<code>updatedb+locate</code> 的方式在搜索效率上会有明显提高。下面简单介绍这两种方法：</p><p><code>find</code> 命令基本使用演示</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">find</span> ./ -name <span class="token string">"*.c"</span> -o -name <span class="token string">"*.h"</span>  <span class="token comment" spellcheck="true">#找出所有的C语言文件，-o是或者</span>
$ <span class="token function">find</span> ./ \<span class="token punctuation">(</span> -name <span class="token string">"*.c"</span> -o -name <span class="token string">"*.h"</span> \<span class="token punctuation">)</span> -exec <span class="token function">mv</span> <span class="token string">'{}'</span> ./c_files/ \<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true"># 把找到的文件移到c_files下，这种用法非常有趣</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面的用法可以用 <code>xargs</code> 命令替代</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">find</span> ./ -name <span class="token string">"*.c"</span> -o -name <span class="token string">"*.h"</span> <span class="token operator">|</span> <span class="token function">xargs</span> -i <span class="token function">mv</span> <span class="token string">'{}'</span> ./c_files/
<span class="token comment" spellcheck="true"># 如果要对文件做更复杂的操作，可以考虑把mv改写为你自己的处理命令，例如，我需要修</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>改所有的文件名后缀为大写。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">find</span> ./ -name <span class="token string">"*.c"</span> -o -name <span class="token string">"*.h"</span> <span class="token operator">|</span> <span class="token function">xargs</span> -i ./toupper.sh <span class="token string">'{}'</span> ./c_files/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>toupper.sh</code> 就是我们需要实现的转换小写为大写的一个处理文件，具体实现如下：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> toupper.sh
<span class="token comment" spellcheck="true">#!/bin/bash</span>

<span class="token comment" spellcheck="true"># the {} will be expended to the current line and becomen the first argument of this script</span>
FROM<span class="token operator">=</span><span class="token variable">$1</span>
BASENAME<span class="token operator">=</span>$<span class="token punctuation">{</span>FROM<span class="token comment" spellcheck="true">##*/}</span>

BASE<span class="token operator">=</span><span class="token variable">${BASENAME%.*}</span>
SUFFIX<span class="token operator">=</span>$<span class="token punctuation">{</span>BASENAME<span class="token comment" spellcheck="true">##*.}</span>

TOSUFFIX<span class="token operator">=</span><span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token keyword">echo</span> $SUFFIX <span class="token operator">|</span> <span class="token function">tr</span> '<span class="token punctuation">[</span>a-z<span class="token punctuation">]</span>' '<span class="token punctuation">[</span>A-Z<span class="token punctuation">]</span>'<span class="token variable">)</span></span>"</span>
TO<span class="token operator">=</span><span class="token variable">$2</span>/<span class="token variable">$BASE</span><span class="token keyword">.</span><span class="token variable">$TOSUFFIX</span>
COM<span class="token operator">=</span><span class="token string">"mv <span class="token variable">$FROM</span> <span class="token variable">$TO</span>"</span>
<span class="token keyword">echo</span> <span class="token variable">$COM</span>
<span class="token function">eval</span> <span class="token variable">$COM</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>updatedb+locate</code> 基本使用演示</p><pre class="line-numbers language-bash"><code class="language-bash">$ updatedb <span class="token comment" spellcheck="true">#更新库</span>
$ <span class="token function">locate</span> find*.gz <span class="token comment" spellcheck="true">#查找包含find字符串的所有gz压缩包</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>实际上，除了上面两种命令外，Linux 下还有命令查找工具：<code>which</code> 和 <code>whereis</code>，前者用于返回某个命令的全路径，而后者用于返回某个命令、源文件、<code>man 文件的路径。例如，查找</code>find` 命令的绝对路径：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">which</span> <span class="token function">find</span>
/usr/bin/find
$ <span class="token function">whereis</span> <span class="token function">find</span>
find: /usr/bin/find /usr/X11R6/bin/find /usr/bin/X11/find /usr/X11/bin/find /usr/man/man1/find.1.gz /usr/share/man/man1/find.1.gz /usr/X11/man/man1/find.1.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>需要提到的是，如果想根据文件的内容搜索文件，那么 <code>find</code> 和 <code>updatedb+locate</code> 以及 <code>which</code>，<code>whereis</code> 都无能为力啦，可选的方法是 <code>grep</code>，<code>sed</code> 等命令，前者在加上 <code>-r</code> 参数以后可以在指定目录下文件中搜索指定的文件内容，后者再使用 <code>-i</code> 参数后，可以对文件内容进行替换。它们的基本用法在前面的章节中已经详细介绍了，这里就不再赘述。</p><p>值得强调的是，这些命令对文件的操作非常有意义。它们在某个程度上把文件系统结构给抽象了，使得对整个文件系统的操作简化为对单个文件的操作，而单个文件如果仅仅考虑文本部分，那么最终却转化成了之前的字符串操作，即上一节讨论过的内容。为了更清楚地了解文件的组织结构，文件之间的关系，在下一节将深入探讨文件系统。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-vfs/">从文件 I/O 看 Linux 的虚拟文件系统</a></li><li><a href="http://www.ibm.com/developerworks/cn/linux/l-linux-filesystem/index.html?ca=drs-cn">Linux 文件系统剖析</a></li><li><a href="http://lwn.net/Kernel/LDD3/">Linux Device Drivers, 3rd Edition</a></li><li><a href="http://www.ibm.com/developerworks/cn/linux/l-iotips/index.html">技巧：Linux I/O 重定向的一些小技巧</a></li><li>Intel 平台下 Linux 中 ELF 文件动态链接的加载、解析及实例分析:<ul><li><a href="http://www.ibm.com/developerworks/cn/linux/l-elf/part1/index.html">part1</a>,</li><li><a href="http://www.ibm.com/developerworks/cn/linux/l-elf/part2/index.html">part2</a></li></ul></li><li><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-shell-debug/index.html">Shell 脚本调试技术</a></li><li><a href="http://www.linuxsir.org/bbs/thread206356.html">ELF 文件格式及程序加载执行过程总汇</a></li><li><a href="http://fanqiang.chinaunix.net/a4/b2/20010508/113315.html">Linux下 C 语言编程——文件的操作</a></li><li><a href="http://www.mwjx.com/aboutfish/private/book/linux_c.txt">“Linux下 C 语言编程” 的 文件操作部分</a></li><li><a href="http://www.pathname.com/fhs/pub/fhs-2.3.html#INTRODUCTION">Filesystem Hierarchy Standard</a></li><li><a href="http://tech.ccidnet.com/art/237/20070720/1150559_1.html">学会恢复 Linux系统里被删除的 Ext3 文件</a></li><li><a href="http://bbs.tech.ccidnet.com/read.php?tid=48372">使用mc恢复被删除文件</a></li><li><a href="http://www.linuxdiyf.com/viewarticle.php?id=30866">linux ext3 误删除及恢复原理</a></li><li><a href="http://www.cnblogs.com/eoiioe/archive/2008/09/20/1294681.html">Linux压缩／解压缩方式大全</a></li><li><a href="http://www.reteam.org/papers/e56.pdf">Everything is a byte</a></li></ul><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><ul><li>考虑到文件和文件系统的重要性，将把它分成三个小节来介绍：文件、文件系统、程序与进程。在“文件”这一部分，主要介绍文件的基本属性和常规操作，在“文件系统”那部分，将深入探讨 Linux 文件系统的各个部分（包括 Linux 文件系统的结构、具体某个文件系统的大体结构分析、底层驱动的工作原理），在“程序与进程”一节将专门讨论可执行文件的相关内容（包括不同的程序类型、加载执行过程、不同进程之间的交互[命令管道和无名管道、信号通信]、对进程的控制等）</li><li>有必要讨论清楚 目录大小 的含义，另外，最好把一些常规的文件操作全部考虑到，包括文件的读、写、执行、删除、修改、复制、压缩／解压缩等</li></ul></div><hr><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/tags/Linux/"><span class="chip bg-color">Linux</span> </a><a href="/tags/Shell/"><span class="chip bg-color">Shell</span> </a><a href="/tags/%E6%95%99%E7%A8%8B/"><span class="chip bg-color">教程</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="wechat,qq,weibo,twitter,facebook,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="/libs/share/js/social-share.min.js"></script></div></div></div></div></div><style>.valine-card{margin:1.5rem auto}.valine-card .card-content{padding:20px 20px 5px 20px}#vcomments textarea{box-sizing:border-box;background:url(/medias/comment_bg.png) 100% 100% no-repeat}#vcomments p{margin:2px 2px 10px;font-size:1.05rem;line-height:1.78rem}#vcomments blockquote p{text-indent:.2rem}#vcomments a{padding:0 2px;color:#4cbf30;font-weight:500;text-decoration:none}#vcomments img{max-width:100%;height:auto;cursor:pointer}#vcomments ol li{list-style-type:decimal}#vcomments ol,ul{display:block;padding-left:2em;word-spacing:.05rem}#vcomments ul li,ol li{display:list-item;line-height:1.8rem;font-size:1rem}#vcomments ul li{list-style-type:disc}#vcomments ul ul li{list-style-type:circle}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}#vcomments table,td,th{border:0}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments h1{font-size:1.85rem;font-weight:700;line-height:2.2rem}#vcomments h2{font-size:1.65rem;font-weight:700;line-height:1.9rem}#vcomments h3{font-size:1.45rem;font-weight:700;line-height:1.7rem}#vcomments h4{font-size:1.25rem;font-weight:700;line-height:1.5rem}#vcomments h5{font-size:1.1rem;font-weight:700;line-height:1.4rem}#vcomments h6{font-size:1rem;line-height:1.3rem}#vcomments p{font-size:1rem;line-height:1.5rem}#vcomments hr{margin:12px 0;border:0;border-top:1px solid #ccc}#vcomments blockquote{margin:15px 0;border-left:5px solid #42b983;padding:1rem .8rem .3rem .8rem;color:#666;background-color:rgba(66,185,131,.1)}#vcomments pre{font-family:monospace,monospace;padding:1.2em;margin:.5em 0;background:#272822;overflow:auto;border-radius:.3em;tab-size:4}#vcomments code{font-family:monospace,monospace;padding:1px 3px;font-size:.92rem;color:#e96900;background-color:#f8f8f8;border-radius:2px}#vcomments pre code{font-family:monospace,monospace;padding:0;color:#e8eaf6;background-color:#272822}#vcomments pre[class*=language-]{padding:1.2em;margin:.5em 0}#vcomments code[class*=language-],pre[class*=language-]{color:#e8eaf6}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}#vcomments b,strong{font-weight:700}#vcomments dfn{font-style:italic}#vcomments small{font-size:85%}#vcomments cite{font-style:normal}#vcomments mark{background-color:#fcf8e3;padding:.2em}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}.v .vlist .vcard{padding-top:2.5em!important}</style><div class="card valine-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;left:20px;top:15px;padding-bottom:5px"><i class="fa fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="vcomments" class="card-content" style="display:grid"></div></div><script src="/libs/valine/av-min.js"></script><script src="/libs/valine/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"98JpzSGcrl9jFqHO13vqxHvX-gzGzoHsz",appKey:"mDmr2h9PB20xvPMNqgyRnNIC",notify:!0,verify:!0,visitor:!0,avatar:"mm",pageSize:"10",lang:"zh-cn",placeholder:"just go go"})</script><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fa fa-chevron-left"></i>&nbsp;上一篇</div><div class="card"><a href="/posts/50641/"><div class="card-image"><img src="/medias/featureimages/12.jpg" class="responsive-img" alt="Shell基础学习"> <span class="card-title">Shell基础学习</span></div></a><div class="card-content article-content"><div class="summary block-with-text">之前也有一些关于这方面的笔记，但过于零碎，特地整理。</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2020-12-18 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/Linux/" class="post-category">Linux</a></span></div></div><div class="card-action article-tags"><a href="/tags/Linux/"><span class="chip bg-color">Linux</span> </a><a href="/tags/Shell/"><span class="chip bg-color">Shell</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fa fa-chevron-right"></i></div><div class="card"><a href="/posts/61063/"><div class="card-image"><img src="/medias/featureimages/1.jpg" class="responsive-img" alt="进程的内存映像"> <span class="card-title">进程的内存映像</span></div></a><div class="card-content article-content"><div class="summary block-with-text">前言APUE的第 14 章时，看到一个“打印不同类型的数据所存放的位置”的例子，它非常清晰地从程序内部反应了“进程的内存映像”，通过结合它与Gcc 编译的背后和缓冲区溢出与注入分析的相关内容，可以更好地辅助理解相关的内容。 进程内存映像表首</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2020-12-17 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/C/" class="post-category">C</a></span></div></div><div class="card-action article-tags"><a href="/tags/C/"><span class="chip bg-color">C</span> </a><a href="/tags/Linux/"><span class="chip bg-color">Linux</span></a></div></div></div></div></article></div><script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script><script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script><script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script><script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget"><div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fa fa-list"></i></a></div><script src="/libs/tocbot/tocbot.min.js"></script><script>$(function(){tocbot.init({tocSelector:"#toc-content",contentSelector:"#articleContent",headingsOffset:-(.4*$(window).height()-45),headingSelector:"h2, h3, h4, h5"});let t=0;var e="toc-heading-";$("#toc-content a").each(function(){$(this).attr("href","#"+e+ ++t)}),t=0,$("#articleContent").children("h2, h3, h4, h5").each(function(){$(this).attr("id",e+ ++t)});var n=parseInt(.4*$(window).height()-64);let o=$(".toc-widget");$(window).scroll(function(){var t=$(window).scrollTop();n<t?o.addClass("toc-fixed"):o.removeClass("toc-fixed")});var i="expanded";let a=$("#toc-aside"),c=$("#main-content");$("#floating-toc-btn .btn-floating").click(function(){a.hasClass(i)?(a.removeClass(i).hide(),c.removeClass("l9")):(a.addClass(i).show(),c.addClass("l9")),function(){let e=$("#artDetail");if(0!==e.length){let t=e.width();450<=t?t+=21:350<=t&&t<450?t+=18:300<=t&&t<350?t+=16:t+=14,$("#prenext-posts").width(t)}}()})})</script></main><footer class="page-footer bg-color"><div class="container row center-align"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2019</span> <a href="/about" rel="external nofollow noreferrer">JoyTsing</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br><span id="sitetime">载入运行时间...</span> <span id="busuanzi_container_site_pv">|&nbsp;<i class="fa fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span>&nbsp;次 </span><span id="busuanzi_container_site_uv">|&nbsp;<i class="fa fa-user"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv" class="white-color"></span>&nbsp;人</span><br><script type="text/javascript">var cnzz_protocol="https:"==document.location.protocol?"https://":"http://";document.write(unescape("%3Cspan id='cnzz_stat_icon_1278523400'%3E%3C/span%3E%3Cscript src='"+cnzz_protocol+"s4.cnzz.com/z_stat.php%3Fid%3D1278523400%26online%3D1%26show%3Dline' type='text/javascript'%3E%3C/script%3E"))</script><br>&nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;<span class="white-color">417.3k</span>&nbsp;字<script>function siteTime(){var e=864e5,t="2019",n=(m=new Date).getFullYear(),o=m.getMonth()+1,r=m.getDate(),a=m.getHours(),i=m.getMinutes(),l=m.getSeconds(),m=Date.UTC(t,"7","24","0","0","0"),r=Date.UTC(n,o,r,a,i,l)-m,a=Math.floor(r/31536e6),i=Math.floor(r/e-365*a),l=Math.floor((r-(365*a+i)*e)/36e5),m=Math.floor((r-(365*a+i)*e-36e5*l)/6e4),M=Math.floor((r-(365*a+i)*e-36e5*l-6e4*m)/1e3);t==n?(document.getElementById("year").innerHTML=n,document.getElementById("sitetime").innerHTML="本站已安全运行 "+i+" 天 "+l+" 小时 "+m+" 分钟 "+M+" 秒"):(document.getElementById("year").innerHTML=t+" - "+n,document.getElementById("sitetime").innerHTML="本站已安全运行 "+a+" 年 "+i+" 天 "+l+" 小时 "+m+" 分钟 "+M+" 秒")}setInterval(siteTime,1e3)</script></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/JoyTsing" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fa fa-github"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script src="/js/search.js"></script><script type="text/javascript">$(function(){searchFunc("/search.xml","searchInput","searchResult")})</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fa fa-angle-up"></i></a></div><script src="/libs/materialize/materialize.min.js"></script><script src="/libs/masonry/masonry.pkgd.min.js"></script><script src="/libs/aos/aos.js"></script><script src="/libs/scrollprogress/scrollProgress.min.js"></script><script src="/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="/js/matery.js"></script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?3a39d92b69933ae56c7eb41ffb9aa2e0";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js",(e=document.getElementsByTagName("script")[0]).parentNode.insertBefore(t,e)}()</script><script async src="/libs/others/busuanzi.pure.mini.js"></script><script type="text/javascript">var st,OriginTitile=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="(oﾟvﾟ)ノ Hi",clearTimeout(st)):(document.title="(*´∇｀*) 欢迎回来！",st=setTimeout(function(){document.title=OriginTitile},3e3))})</script><script type="text/javascript" color="0,0,255" pointcolor="0,0,255" opacity="0.8" zindex="-1" count="150" src="/libs/background/canvas-nest.js"></script><script src="/libs/instantpage/instantpage.js" type="module"></script><script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script><script>const hasAttr = (e,a) => a.some(_=> e.attr(_)!==undefined);
        $('a').each(function() {
          const $this = $(this);
          if(hasAttr($this,["data-fancybox","ignore-external-link"])) return;
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== '' || window.location.host) {
                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":150,"height":200},"mobile":{"show":false},"react":{"opacity":0.7}});</script></body></html>