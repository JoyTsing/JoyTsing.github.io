<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="More Effective-CPP:读书笔记, joytsing blog"><meta name="description" content="Cpp进阶书本系列补全"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="theme-color" content="white"><title>More Effective-CPP:读书笔记 | JoyTsing</title><link rel="apple-touch-icon" href="/"><link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="/favicon.ico"><link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css"><link rel="stylesheet" type="text/css" href="/libs/aos/aos.css"><link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css"><link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" type="text/css" href="/css/matery.css"><link rel="stylesheet" type="text/css" href="/css/my.css"><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style><script src="/libs/jquery/jquery.min.js"></script><script src="https://cdn-go.cn/aegis/aegis-sdk/latest/aegis.min.js"></script><script>const aegis=new Aegis({id:"6ojk8FlnQlqWeL6vQo",uin:"joyblog",reportApiSpeed:!0,reportAssetSpeed:!0,spa:!0,hostUrl:"https://rumt-sg.com"});console.log("aegis load")</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="JoyTsing" type="application/atom+xml"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><img src="/apple-touch-icon.png" class="logo-img" alt="LOGO"> <span class="logo-span">JoyTsing</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fa fa-home"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-tags"></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-bookmark"></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-archive"></i> <span>归档</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa fa-user-circle-o"></i> <span>关于</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa fa-envelope"></i> <span>留言</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa fa-address-book"></i> <span>友链</span></a></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fa fa-search" title="搜索"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="/medias/avatars/touxiang2.jpg" class="logo-img circle responsive-img"><div class="logo-name">JoyTsing</div><div class="logo-desc">joytsing的个人网站</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="m-nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-fw fa-bookmark"></i> 分类</a></li><li class="m-nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li class="m-nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa fa-fw fa-user-circle-o"></i> 关于</a></li><li class="m-nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa fa-fw fa-envelope"></i> 留言</a></li><li class="m-nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa fa-fw fa-address-book"></i> 友链</a></li><li><div class="divider"></div></li><li><a href="https://github.com/JoyTsing" class="waves-effect waves-light" target="_blank"><i class="fa fa-github-square fa-fw"></i>Follow Me</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#000;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href="https://github.com/JoyTsing" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Follow Me" data-position="left" data-delay="50"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a></nav></header><div class="bg-cover pd-header post-cover" style="background-image:url(/medias/featureimages/5.jpg)"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">More Effective-CPP:读书笔记</h1></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{width:345px;padding-left:20px}.toc-widget .toc-title{margin:35px 0 15px 0;padding-left:17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content{height:calc(100vh - 250px);overflow:auto}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px;position:absolute;right:23.5vw;display:block}#toc-content .is-active-link{color:#42b983}#floating-toc-btn{position:fixed;right:15px;bottom:76px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/Cpp/"><span class="chip bg-color">Cpp</span> </a><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="chip bg-color">读书笔记</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="post-category">读书笔记</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp; 2024-03-11</div><div class="post-date info-break-policy"><i class="fa fa-calendar-check-o fa-fw"></i>更新日期:&nbsp;&nbsp; 2024-03-21</div><div class="info-break-policy"><i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp; 5.3k</div><div class="info-break-policy"><i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp; 22 分</div><div id="busuanzi_container_page_pv" class="info-break-policy"><i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp; <span id="busuanzi_value_page_pv"></span></div></div></div><hr class="clearfix"><div class="card-content article-card-content"><div id="articleContent"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>虽然早在4年前的大二时期就看过并且实践在工程作业里面，但一直没有一个完整的记录，想着别的几本都有了干脆补全一下吧，个人总结，难免会出现一些不太准确的地方，欢迎各位指正。</p><h2 id="条款1：仔细区别-pointers-和-references"><a href="#条款1：仔细区别-pointers-和-references" class="headerlink" title="条款1：仔细区别 pointers 和 references"></a>条款1：仔细区别 pointers 和 references</h2><ul><li>reference 不能为 null。</li><li>一般而言，当你需要考虑“不指向任何对象”的可能性时，或是考虑“在不同事件指向不同对象”的能力时，你就应该采用 pointer。</li><li>当你知道你需要指向某个东西，而且绝不会改变指向其他东西，或是当你实现一个操作符而其语法需求无法由 pointers 达成，你就应该选择 reference。任何其他时候，请采用 pointers。</li></ul><h2 id="条款2：最好使用-C-转型操作符"><a href="#条款2：最好使用-C-转型操作符" class="headerlink" title="条款2：最好使用 C++ 转型操作符"></a>条款2：最好使用 C++ 转型操作符</h2><h3 id="1-static-cast"><a href="#1-static-cast" class="headerlink" title="1 static_cast"></a>1 static_cast</h3><p>使用 <code>static_cast&lt;type&gt;(expression)</code>代替 (type)expression</p><h3 id="2-const-cast"><a href="#2-const-cast" class="headerlink" title="2 const_cast"></a>2 const_cast</h3><p>将某个对象的常量性去除掉</p><h3 id="3-dynamic-cast"><a href="#3-dynamic-cast" class="headerlink" title="3 dynamic_cast"></a>3 dynamic_cast</h3><ul><li>利用<code>dynamic_cast</code>，将“指向 base class objects 的 pointers 或 references”转型为“指向derived（或 sibling base）class objects 的 pointers 或 references”， 并得知转型是否成功。</li><li>如果转型失败，会以一个 null 指针（当转型对象是指针）或一个 exception （当转型对象是 reference）表现出来。</li></ul><h3 id="4-reinterpret-cast"><a href="#4-reinterpret-cast" class="headerlink" title="4 reinterpret_cast"></a>4 reinterpret_cast</h3><p>最常用用途是转换“函数指针”类型，对应C里面的强制转换</p><h2 id="条款3：绝对不要以多态（polymorphically）方式处理数组"><a href="#条款3：绝对不要以多态（polymorphically）方式处理数组" class="headerlink" title="条款3：绝对不要以多态（polymorphically）方式处理数组"></a>条款3：绝对不要以多态（polymorphically）方式处理数组</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">base</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">base</span><span class="token punctuation">(</span><span class="token keyword">int</span> p1<span class="token punctuation">,</span> <span class="token keyword">int</span> p2<span class="token punctuation">)</span>
        <span class="token operator">:</span><span class="token function">p1</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">p2</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> p1<span class="token punctuation">,</span> p2<span class="token punctuation">;</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> p1 <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> p2 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">derived</span> <span class="token operator">:</span> <span class="token keyword">public</span> base<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">derived</span><span class="token punctuation">(</span><span class="token keyword">int</span> p1<span class="token punctuation">,</span> <span class="token keyword">int</span> p2<span class="token punctuation">,</span> <span class="token keyword">int</span> p3<span class="token punctuation">)</span>
        <span class="token operator">:</span> <span class="token function">base</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">p3</span><span class="token punctuation">(</span>p3<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> p3<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override<span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> p1 <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> p2 <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> p3 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>base array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">"th item's size is: "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
        array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    base    <span class="token function">b1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span>  <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    derived <span class="token function">d1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>   <span class="token number">2</span><span class="token punctuation">,</span>  <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    base    <span class="token function">b2</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">,</span>  <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    derived <span class="token function">d2</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span>   <span class="token number">5</span><span class="token punctuation">,</span>  <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    base array<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>d1<span class="token punctuation">,</span> b1<span class="token punctuation">,</span> d2<span class="token punctuation">,</span> b2<span class="token punctuation">}</span><span class="token punctuation">;</span>

    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sizeof(base): "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>b1<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\tsizeof(derived): "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>d1<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// sizeof(base): 8 sizeof(derived): 12</span>

    <span class="token function">print</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 0th item's size is: 8    1, 2</span>
    <span class="token comment" spellcheck="true">// 1th item's size is: 8    10, 20</span>
    <span class="token comment" spellcheck="true">// 2th item's size is: 8    4, 5</span>
    <span class="token comment" spellcheck="true">// 3th item's size is: 8    40, 50</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你交给printBaseArray函数一个包含derived对象组成的数组，你的编译器就会被误导。这种情况下它仍假设数组中的每一个元素的大小是base的大小，但其实每一个元素的大小是不一样的。</p><h2 id="条款4：非必要不提供-default-constructor"><a href="#条款4：非必要不提供-default-constructor" class="headerlink" title="条款4：非必要不提供 default constructor"></a>条款4：非必要不提供 default constructor</h2><ul><li>在一个完美的世界中，凡可以“合理地从无到有生成对象”的 classes，都应该内含 default constructors，“必须有某些外来信息才能生成对象” 的 classes，则不必拥有 default constructors。</li><li>在进退维谷的情况下，最后一个考虑点和 virtual base classes 有关。 Virtual base classes 如果缺乏 default constructors，与之合作将会是一种刑法。</li><li>添加无意义的 constructors，也会影响 classes 的效率。</li></ul><h2 id="条款5：对定制的-“类型转换函数”-保持警觉"><a href="#条款5：对定制的-“类型转换函数”-保持警觉" class="headerlink" title="条款5：对定制的 “类型转换函数” 保持警觉"></a>条款5：对定制的 “类型转换函数” 保持警觉</h2><p>下述代码根本的原因在于，在你从未打算也未预期的情况下，此函数可能会被调用，而其结果可能是不正确.不直观的程序行为很难发现调试。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Rational</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Rational</span><span class="token punctuation">(</span><span class="token keyword">int</span> numerator <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">int</span> denominator <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">operator</span> <span class="token keyword">double</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    <span class="token keyword">friend</span> std<span class="token operator">::</span>ostream <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>std<span class="token operator">::</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> Rational <span class="token operator">&amp;</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> numerator<span class="token punctuation">;</span>
    <span class="token keyword">int</span> denominator<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Rational<span class="token operator">::</span><span class="token function">Rational</span><span class="token punctuation">(</span><span class="token keyword">int</span> numerator<span class="token punctuation">,</span> <span class="token keyword">int</span> denominator<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>numerator <span class="token operator">=</span> numerator<span class="token punctuation">;</span>
     <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>denominator <span class="token operator">=</span> denominator<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

Rational<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">double</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>numerator<span class="token punctuation">)</span><span class="token operator">/</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>denominator<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

std<span class="token operator">::</span>ostream <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>std<span class="token operator">::</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> Rational <span class="token operator">&amp;</span>r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    os <span class="token operator">&lt;&lt;</span> r<span class="token punctuation">.</span>numerator <span class="token operator">&lt;&lt;</span> <span class="token string">"/"</span> <span class="token operator">&lt;&lt;</span> r<span class="token punctuation">.</span>denominator <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> os<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   Rational <span class="token function">r</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> r<span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// 1/2</span>

   <span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">0.5</span> <span class="token operator">*</span> r<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 0.25</span>
   std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> d <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假设你忘了为 Rational 写一个 operator&lt;&lt;，你或许以为上述的 std::cout &lt;&lt; r; 不会成功，因为没有适当的 operator&lt;&lt; 可以调用。但是你错了，你的编译器面对上述动作，发现不存在任何 operator&lt;&lt; 可以接受一个 Rational，但它会想尽各种办法（包括找出一系列可接受的隐式类型转换）让函数调用动作成功。即进行了隐式类型转换，导致（非预期）的函数被调用。</p><p>解决这个问题，可以采用:</p><ul><li>以功能对等的另一个函数取代类型转换操作符</li><li>使用关键字 explicit</li></ul><h2 id="条款6：区别-increment-decrement-操作符的前置-prefix-和后置-postfix-形式"><a href="#条款6：区别-increment-decrement-操作符的前置-prefix-和后置-postfix-形式" class="headerlink" title="条款6：区别 increment/decrement 操作符的前置(prefix)和后置(postfix)形式"></a>条款6：区别 increment/decrement 操作符的前置(prefix)和后置(postfix)形式</h2><pre class="line-numbers language-c++"><code class="language-c++">class UPInt{
public:
    UPInt(int i)                    //提供一个构造函数
        :val(i){};

    UPInt& operator++();            //前置++
    const UPInt operator++(int);    //后置++

    UPInt& operator--();            //前置--
    const UPInt operator--(int);    //后置--

    UPInt& operator+=(const int i); //+=操作符
    //...

    int val;
};

//前置++，返回reference
UPInt &UPInt::operator++() {
    *this += 1;
    return *this;
}

//后置++，返回一个const对象
const UPInt UPInt::operator++(int) {
    UPInt oldValue = *this;
    ++(*this);
    return oldValue;
}

//前置--，返回reference
UPInt &UPInt::operator--() {
    *this += -1;
    return *this;
}

//后置--，返回一个const对象
const UPInt UPInt::operator--(int) {
    UPInt oldValue = *this;
    --(*this);
    return oldValue;
}

//+=操作符，看需求，这里返回一个 reference
UPInt &UPInt::operator+=(const int i) {
    this->val = this->val + i;
    return *this;
}

//这里帮助打印UPint里的val值
void print(const UPInt &up) { std::cout << up.val <<std::endl; }

int main()
{
    UPInt i(0);
    print(i);       // 0

    print(++i);     // 1
    print(i++);     // 1
    print(i);       // 2

    print(--i);     // 1
    print(i--);     // 1
    print(i);       // 0
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为什么后置++或–返回的是一个const值呢？如果不是一个const值的话，那么下面的动作就是合法的。</p><pre class="line-numbers language-cpp"><code class="language-cpp">    UPInt <span class="token function">i</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    i<span class="token operator">++</span><span class="token operator">++</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>处理用户定制类型时，应尽可能使用前置式 increment，因为它天生体质较佳。</p><h2 id="条款7：千万不要重载-amp-amp-，-和-操作符"><a href="#条款7：千万不要重载-amp-amp-，-和-操作符" class="headerlink" title="条款7：千万不要重载 &amp;&amp;，|| 和 , 操作符"></a>条款7：千万不要重载 &amp;&amp;，|| 和 , 操作符</h2><p>C++ 对于“真假值表达式”采用所谓的“骤死式”评估方式。意思是一旦该表达式的真假值确定，即使表达式中还有部分尚未检验，整个评估工作仍结束。</p><p>如果你决定重载 operator&amp;&amp; 或 operator||，你必须知道，你正在从根本层面改变整个游戏规则，因为从此“函数调用”语义会取代“骤死式”语义。</p><p>如果你将 &amp;&amp; 或 || 重载，就没有办法提供程序员预期（甚至依赖）的某种行为模式。</p><p><strong>如果你没有什么好的理由将某个操作符重载，就不要去做。</strong></p><h2 id="条款8：了解各种不同意义的-new-和-delete"><a href="#条款8：了解各种不同意义的-new-和-delete" class="headerlink" title="条款8：了解各种不同意义的 new 和 delete"></a>条款8：了解各种不同意义的 new 和 delete</h2><h3 id="new-operator"><a href="#new-operator" class="headerlink" title="new operator"></a>new operator</h3><p>举个例子，当你写出这样的代码，就是使用了所谓的 new operator</p><p>string *ps = new string(“Hello World!”);<br>分配足够的内存，用来放置某类型的对象<br>调用一个constructor，为上一步中分配的内存中的那个对象设定初始值。<br>new operator 总是做这两件事，无论如何你不能改变其行为。</p><h3 id="operator-new"><a href="#operator-new" class="headerlink" title="operator new"></a>operator new</h3><p>举个例子，函数 operator new 通常声明如下</p><blockquote><p>void *operator new(size_t size);</p></blockquote><p>上述返回值类型是 void*。此函数返回一个指针，直线一块原始的、未设初始值的内存。函数中的 size_t 参数表示需要分配多少内存。你可以将 operator new 重载，加上额外的参数，但第一参数的类型必须总是 size_t。</p><p>举个例子</p><blockquote><p>void *rawMemory = operator new(sizeof(string))</p></blockquote><p>这里的 operator new 将返回指针，指向一块足够容纳一个 string 对象的内存。和 malloc 一样 operator new 的唯一任务就是分配内存。</p><h3 id="placement-new"><a href="#placement-new" class="headerlink" title="placement new"></a>placement new</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">new</span><span class="token punctuation">(</span>内存地址<span class="token punctuation">)</span> 类<span class="token punctuation">(</span><span class="token punctuation">[</span>实参<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">base</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">base</span><span class="token punctuation">(</span><span class="token keyword">int</span> p1<span class="token punctuation">)</span>
        <span class="token operator">:</span><span class="token function">p1</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> p1<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>base<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 4</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 1</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>memory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>base<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// address: 0xdb3278</span>

    base <span class="token operator">*</span>b1 <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>memory<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">base</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// address:0xdb3278    val:e8 03 00 00     03e8    = 1000</span>
    base <span class="token operator">*</span>b2 <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>memory<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">base</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// address:0xdb327c    val:02 00 00 00     02      = 2</span>
    base <span class="token operator">*</span>b3 <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>memory<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">base</span><span class="token punctuation">(</span><span class="token number">9999999</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// address:0xdb3280    val:7f 96 98 00     98967f  = 9999999</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简而言之，如果你有一些分配好的内存，且需要在上面构建对象。那么可以使用 placement new。</p><table><thead><tr><th></th><th>分配内存</th><th>构造</th></tr></thead><tbody><tr><td>new operator</td><td>√</td><td>√</td></tr><tr><td>operator new</td><td>√</td><td>×</td></tr><tr><td>placement new</td><td>×</td><td>√</td></tr></tbody></table><p>至于delete也是同理，不在这过多描述(很少使用)。</p><h2 id="条款9：利用-deconstructors-避免泄露资源"><a href="#条款9：利用-deconstructors-避免泄露资源" class="headerlink" title="条款9：利用 deconstructors 避免泄露资源"></a>条款9：利用 deconstructors 避免泄露资源</h2><ul><li>使用析构函数</li><li>使用智能指针</li></ul><p>当然，到了现在一般更喜欢依赖RAII来对资源进行自动管理，也更加优雅。</p><h2 id="条款10：在-constructors-内阻止资源泄露"><a href="#条款10：在-constructors-内阻止资源泄露" class="headerlink" title="条款10：在 constructors 内阻止资源泄露"></a>条款10：在 constructors 内阻止资源泄露</h2><ul><li>C++ 只会析构已构造完成的对象</li><li>对于在构造期抛出 exceptions 的对象，C++不会自动清理，所以你必须设计你的 constructors 使它们能够在那种情况下也能自我清理。</li><li>一个更好的解答是，接受条款9的忠告，将point data members所指对象视为资源，交给局部对象管理（即使用智能指针）。</li></ul><h2 id="条款11：禁止异常（exceptions）流出-destructors-之外"><a href="#条款11：禁止异常（exceptions）流出-destructors-之外" class="headerlink" title="条款11：禁止异常（exceptions）流出 destructors 之外"></a>条款11：禁止异常（exceptions）流出 destructors 之外</h2><p>两种情况下 destructor <strong>会被调用</strong>：</p><ul><li>当对象在正常状态下被销毁，也就是当它离开了它的生存空间(scope)或是被明确地删除。</li><li>当对象被 exception 处理机制——也就是 exception 传播过程中的 stk-unwinding(栈展开)机制——销毁。</li></ul><p><strong>危害</strong>：</p><ul><li>如果控制权基于 exception 的因素离开 destructor，而此时正有另一个 exception 处于作用状态，C++ 会调用 terminate 函数。此函数会将你的程序结束掉——它会立刻动手，甚至不等局部对象被销毁。</li></ul><p>全力阻止 exceptions 传出 destructors 的好处：</p><ul><li>避免 terminate 函数在 exception 传播过程的栈展开(stack-unwinding)机制中被调用。</li><li>协助确保 destructors 完成其应该完成的所有事情。</li></ul><p>换句话说，一定要保证析构函数是nonexpection的。</p><h2 id="条款12：了解“抛出一个-exception”-与-“传递一个参数”-或-“调用一个虚函数”-之间的差异"><a href="#条款12：了解“抛出一个-exception”-与-“传递一个参数”-或-“调用一个虚函数”-之间的差异" class="headerlink" title="条款12：了解“抛出一个 exception” 与 “传递一个参数” 或 “调用一个虚函数” 之间的差异"></a>条款12：了解“抛出一个 exception” 与 “传递一个参数” 或 “调用一个虚函数” 之间的差异</h2><p>函数参数和 exceptions 的传递方式有3种:</p><ul><li>by value</li><li>by reference</li><li>by pointer</li></ul><p>区别1：当你调用一个函数，控制器最终会回到调用端（除非函数失败以至于无法返回），但是当你抛出一个 exception ，控制权不会再回到抛出端。而且一个对象被抛出作为 exception 时，总是会发生复制(copy)。</p><p>区别2：“抛出exception”比“传递参数”慢。因为“exception objects 必定会造成复制行为”这一事实，所以解释了“抛出exception”常常比“传递参数”慢。复制动作永远是以静态类型为本。</p><p>区别3：函数调用过程中将一个临时对象传递给一个 non-const reference 参数是不允许的，但是对 exceptions 则属合法。一个被抛出的对象（必为临时对象）可以简单地用 by reference 的方式捕捉，不需要以 by reference-to-const 的方式捕捉。</p><p>区别4：“抛出exception” 比 “传递函数参数”多构造一个“被抛出物”的副本（并于稍后析构），千万不要抛出一个指向局部对象的指针，因为该局部对象会在 exception 传离其 scope 时被销毁，因此 catch 子句会获得一个指向“已被销毁的对象”的指针。这正时“义务性复制(copy)规则”的设计要避免的情况。</p><p>区别5：“自变量传递”与“exception 传播”两动作有着互异的做法。</p><p>区别6：catch 子句总是依出现顺序做匹配尝试。</p><p><strong>总结</strong>：“传递对象到函数去，或是以对象调用虚函数”和“将对象抛出成为一个exception”之间，有3个主要差异</p><ul><li>exception objects 总是会被复制，如果以 by value 方式捕捉，它们甚至被复制两次。至于传递给函数参数的对象则不一定得复制。</li><li>被抛出成为 exceptions 的对象，其被允许的类型转换动作，比“被传递到函数去”的对象少。</li><li>catch 子句以其“出现于源代码的顺序”被编译器检验对比，其中第一个匹配成功者变执行；而当我们以某对象调用一个虚函数，被选中执行的是那个“与对象类型最佳吻合”的函数，不论它是不是源代码所列的第一个。</li></ul><h2 id="条款13：以-by-reference-方式捕捉-exceptions"><a href="#条款13：以-by-reference-方式捕捉-exceptions" class="headerlink" title="条款13：以 by reference 方式捕捉 exceptions"></a>条款13：以 by reference 方式捕捉 exceptions</h2><ul><li>避开 exception objects 的切割（slicing）的问题</li><li>保留捕捉标准 exceptions 的能力</li><li>约束了exception objects 需被复制的次数</li></ul><h2 id="条款14：明智运用-exception-specifications"><a href="#条款14：明智运用-exception-specifications" class="headerlink" title="条款14：明智运用 exception specifications"></a>条款14：明智运用 exception specifications</h2><p>告诉编译器函数不引发任何异常。 但是，在 std:c++14 模式下，如果函数确实引发异常，这可能会导致未定义的行为。 因此，建议使用 noexcept 运算符：</p><h2 id="条款15：了解异常处理（exception-handling）的成本"><a href="#条款15：了解异常处理（exception-handling）的成本" class="headerlink" title="条款15：了解异常处理（exception handling）的成本"></a>条款15：了解异常处理（exception handling）的成本</h2><p>只要你用上那么一个，也就是说一旦你决定捕捉 exceptions，你就得付出那样的成本。不同的编译器以不同的方法实现 try 语句块，代码大约整体膨胀 5%~10%，执行速度亦下降这个数。</p><p><strong>为了将此成本最小化，你应该避免非必要的 try 语句块</strong>。</p><h2 id="条款16：谨记-80-20-法则"><a href="#条款16：谨记-80-20-法则" class="headerlink" title="条款16：谨记 80-20 法则"></a>条款16：谨记 80-20 法则</h2><p>软件的证一性能几乎总是由其构成要素（代码）的一小部分决定。</p><h2 id="条款17：考虑使用-lazy-evaluation（缓式评估）"><a href="#条款17：考虑使用-lazy-evaluation（缓式评估）" class="headerlink" title="条款17：考虑使用 lazy evaluation（缓式评估）"></a>条款17：考虑使用 lazy evaluation（缓式评估）</h2><ul><li>Reference Counting（引用计数）：在你真正需要之前，不必着急为某物做一个副本——可避免非必要的对象复制</li><li>区分读和写：可区别 operator[]的读和写的动作</li><li>Lazy Fatching（缓式取出）：可避免非必要的数据库读取动作</li><li>Lazy Expression Evaluation（表达式缓评估）：可避免非必要的数值计算动作</li></ul><p><strong>总结</strong><br>如果你的计算是必要的，lazy evaluation 并不会为你的程序节省人和工作或任何时间。只有当“你的软件被要求执行某些计算，而那些计算其实可以避免”的情况下，lazy evaluation 才有用处。</p><h2 id="条款18：分期摊还预期的计算成本"><a href="#条款18：分期摊还预期的计算成本" class="headerlink" title="条款18：分期摊还预期的计算成本"></a>条款18：分期摊还预期的计算成本</h2><p>简单来说，就是使用缓存。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">findCubicleNumber</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>employeeName<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">typedef</span> map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> CubicleMap<span class="token punctuation">;</span>
    <span class="token keyword">static</span> CubicleMap cubes<span class="token punctuation">;</span>

    CubicleMap<span class="token operator">::</span>iterator it <span class="token operator">=</span> cubes<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>employeeName<span class="token punctuation">)</span>  <span class="token punctuation">;</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span>it <span class="token operator">==</span> cubes<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">int</span> cubicle <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   <span class="token comment" spellcheck="true">// 这里逻辑处理</span>

        cubes<span class="token punctuation">[</span>employeeName<span class="token punctuation">]</span> <span class="token operator">=</span> cubicle<span class="token punctuation">;</span>
        <span class="token keyword">return</span> cubicle<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后一个语句返回 (*it).second 而非传统的 it-&gt;second，为什么？答案关系到STL实行的规矩。简单地说，iterator本身是对象，不是指针，所以并不能保证 -&gt; 可施行于 it 身上。但STL明确要求 . 和 * 对 iterators 必须有效，所以 (*it).second 虽然语法上笨拙，却保证能够有效运行。</p><h2 id="条款19：了解临时对象的来源"><a href="#条款19：了解临时对象的来源" class="headerlink" title="条款19：了解临时对象的来源"></a>条款19：了解临时对象的来源</h2><p>临时对象可能很耗成本，所以你应该尽可能消除它们。这本书写成的时候比较早，到现在有了std::move和移动构造，移动赋值，就转换成了左值和右值的问题。</p><h2 id="条款20：协助完成“返回值优化-RVO"><a href="#条款20：协助完成“返回值优化-RVO" class="headerlink" title="条款20：协助完成“返回值优化(RVO)"></a>条款20：协助完成“返回值优化(RVO)</h2><p>函数返回对象，背后隐藏着 constructor 和 destructor。如果是为了行为正确而不得不这么做，是可以返回一个对象的；否则就不要那么做。</p><p>有人企图采用某些方法消除 by-value的返回方式</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const</span> Rational<span class="token operator">*</span> <span class="token keyword">operator</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>

Rational a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
Rational c <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>a <span class="token operator">*</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样会使得整个调用流程显得不自然，同时调用者也需要手动删除此函数返回的指针，不然会导致资源泄露。</p><p>有些人试图返回 references, 于是就有了</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//h</span>
<span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//cpp</span>
<span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">{</span>
    Rational <span class="token function">result</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span><span class="token function">numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> rhs<span class="token punctuation">.</span><span class="token function">numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lhs<span class="token punctuation">.</span>denominator <span class="token operator">*</span> rhs<span class="token punctuation">.</span><span class="token function">denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//use</span>
Rational a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
Rational c <span class="token operator">=</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这看起来似乎没有问题，但是当局部变量 result 离开了 const Rational&amp; operator* 之后，就被自动销毁了。所以 const Rational&amp; operator* 实际返回的 reference 指向的是一个不在存活的对象。</p><h2 id="条款21：利用重载技术（overload）避免隐式类型转换"><a href="#条款21：利用重载技术（overload）避免隐式类型转换" class="headerlink" title="条款21：利用重载技术（overload）避免隐式类型转换"></a>条款21：利用重载技术（overload）避免隐式类型转换</h2><p>假设我们有这么一个结构</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">UPInt</span><span class="token punctuation">{</span>
    <span class="token function">UPInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">UPInt</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

UPInt <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> UPInt<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> UPInt<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当我们调用</p><pre class="line-numbers language-cpp"><code class="language-cpp">UPInt upi1<span class="token punctuation">,</span> upi2<span class="token punctuation">,</span> upi3<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

upi3 <span class="token operator">=</span> upi1 <span class="token operator">+</span> upi2<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 成功，调用了 UPInt operator+(const UPInt&amp; lhs, const UPInt&amp; rhs);</span>
upi3 <span class="token operator">=</span> upi1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 成功，生成了临时对象</span>
upi3 <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> upi1<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 成功，生成了临时对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 upi1 + 1 与 1 + upi1 都会进行隐式类型转换，这里会有一点成本。为了避免隐式类型转换带来的开销，我们可以重载 UPInt operator+ 这个函数</p><pre class="line-numbers language-cpp"><code class="language-cpp">UPInt <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> UPInt<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
UPInt <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> UPInt<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>来消除类型转换。但是我们不能狂热过度写出下面的函数</p><blockquote><p>UPInt operator+(const int lhs, const int rhs);</p></blockquote><p>这会导致可怕的灾难。</p><h2 id="条款22：考虑以操作符符合形式（op-）取代其独身形式（op）"><a href="#条款22：考虑以操作符符合形式（op-）取代其独身形式（op）" class="headerlink" title="条款22：考虑以操作符符合形式（op=）取代其独身形式（op）"></a>条款22：考虑以操作符符合形式（op=）取代其独身形式（op）</h2><p>到目前为止 C++ 并不考虑在 operator+，operator= 和 operator+= 之间设立任何互动关系。如果你希望这三个操作符都存在并且有着你所期望的互动关系，你必须自己实现。</p><p><strong>三个于效率有关的情况需要注意</strong></p><ol><li>一般而言，符合操作符比起对应的独身版本效率高，因为独身版通常必须返回一个新对象，而我们必须因此负担一个临时对象的构造成本和析构成本。至于复合版本则是直接将结果写入其左端自变量，所以不需要产生一个临时对象来放置返回值。</li><li>如果同提供某个操作符的复合形式和独身形式，便允许你的客户在效率与便利性之间做取舍。</li></ol><p>下面的两个例子中，第二个虽然更容易理解，但是却比第一个多构造了一个临时对象。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//Good</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">const</span> T <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>
<span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">T</span><span class="token punctuation">(</span>lhs<span class="token punctuation">)</span> <span class="token operator">+</span> rhs<span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//Not Good</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">const</span> T <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>
<span class="token punctuation">{</span> 
    T <span class="token function">result</span><span class="token punctuation">(</span>lhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result <span class="token operator">+</span><span class="token operator">=</span> rhs<span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>身为一位程序库设计者，你应该为两者都提供。</p><h2 id="条款23：考虑使用其他程序库"><a href="#条款23：考虑使用其他程序库" class="headerlink" title="条款23：考虑使用其他程序库"></a>条款23：考虑使用其他程序库</h2><p>由于不同的程序库将效率、扩充性、移植性、类型安全性等的不同设计具体化，有时候你可以找找看是否存在另一个功能相近的程序库而其在效率上有较高的设计权重。</p><h2 id="条款24：了解虚函数、多重继承、虚基类和运行类型的成本"><a href="#条款24：了解虚函数、多重继承、虚基类和运行类型的成本" class="headerlink" title="条款24：了解虚函数、多重继承、虚基类和运行类型的成本"></a>条款24：了解虚函数、多重继承、虚基类和运行类型的成本</h2><ol><li>虚函数<br>当一个虚函数被调用，执行的代码必须对应于“调用者（对象）的动态类型”。大部分编译器使用所谓的 virtual tables 和 virtual table pointers —— 此二者通常被简写为 vtabls 和 vptrs。</li></ol><p><strong>虚函数成本：</strong></p><ul><li>你必须为每个拥有虚函数的 class 耗费一个 vtable 空间，其大小视虚函数的个数（包括继承而来的）而定。</li><li>你必须在每一个拥有虚函数的对象内付出“一个额外指针”的代价。调用一个虚函数的成本，基本上和”通过一个函数指针来调用函数“相同。虚函数本身并不构成性能上的瓶颈。</li><li>你事实上废弃了 inlining。虚函数不应该 inlined。因为 inline 意味“在编译期，将调用端的调用动作被调用函数的函数本身取代”，而 virtual 则意味着“等待，知道运行时期才知道哪个函数被调用”。</li></ul><ol start="2"><li><p>多重继承<br>多重继承问我导致 virtual base classes（虚拟基类）的需求。<br>在 non-virtual base class 的情况下，如果 derived class 在其 base class 有多条继承路径，则此 base class 的 data members 会在每一个 derived class object 体内复制滋生，每一个副本对应 “derived class 和 base class 之间的一条继承路线”。</p></li><li><p>虚拟继承<br>让base class 成为 virtual，可以消除这样的复制现象，<a href="https://blog.csdn.net/qq_45615577/article/details/115345490">学习资料</a>。</p></li><li><p>RTTI<br><a href="https://zhuanlan.zhihu.com/p/509453699">RTTI</a> 让我们得以在运行时获得 objects 和 classes 的相关信息，他们被存发在类型为 type_info 的对象内。一个 class 只需要一份 RTTI 信息就好，但是必须有某种办法让其下属的每个对象都能取用它。只有当某种类型拥有至少一个虚函数，才保证我们能够检验该类型对象的动态类型。</p></li></ol><table><thead><tr><th>性质</th><th>对象大小增加</th><th>Class数据量增加</th><th>Inlining 几率低</th></tr></thead><tbody><tr><td>虚函数 Virtual Functions</td><td>是</td><td>是</td><td>是</td></tr><tr><td>多重继承Multiple Inheritance</td><td>是</td><td>是</td><td>否</td></tr><tr><td>虚拟基类 Virtual Base Classes</td><td>往往如此</td><td>有时候</td><td>否</td></tr><tr><td>运行时期类型辨识</td><td>RTTI</td><td>否</td><td>是</td></tr></tbody></table><h2 id="条款25：将-constructor-和-non-member-functions-虚化"><a href="#条款25：将-constructor-和-non-member-functions-虚化" class="headerlink" title="条款25：将 constructor 和 non-member functions 虚化"></a>条款25：将 constructor 和 non-member functions 虚化</h2><p>constructor 虚化其实不是真正的虚化构造函数，书中所讲不是很好理解，可以参考下面的例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Shape</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>                 <span class="token comment" spellcheck="true">// A virtual destructor</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// A pure virtual function</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">move</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// ...</span>
  <span class="token keyword">virtual</span> Shape<span class="token operator">*</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// Uses the copy constructor</span>
  <span class="token keyword">virtual</span> Shape<span class="token operator">*</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// Uses the default constructor</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Circle</span> <span class="token operator">:</span> <span class="token keyword">public</span> Shape <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
  Circle<span class="token operator">*</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">const</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// Covariant Return Types; see below</span>
  Circle<span class="token operator">*</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// Covariant Return Types; see below</span>
  <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
Circle<span class="token operator">*</span> Circle<span class="token operator">::</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">Circle</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
Circle<span class="token operator">*</span> Circle<span class="token operator">::</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">Circle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过调用 clone() 或 create()虚函数来间接地调用构造函数与拷贝构造。即虚假的构造函数与真正的构造函数。</p><p>而至于non-member functions 的虚化十分容易：写一个虚函数做实际工作，再写一个什么都不做的非虚函数，只负责调用虚函数。</p><h2 id="条款26：限制某个class所能产生的对象数量"><a href="#条款26：限制某个class所能产生的对象数量" class="headerlink" title="条款26：限制某个class所能产生的对象数量"></a>条款26：限制某个class所能产生的对象数量</h2><h3 id="1-允许零个或一个对象"><a href="#1-允许零个或一个对象" class="headerlink" title="1.允许零个或一个对象"></a>1.允许零个或一个对象</h3><h4 id="1-1-零个对象"><a href="#1-1-零个对象" class="headerlink" title="1.1.零个对象"></a>1.1.零个对象</h4><p>每当即将产生一个对象，就会有一个 <code>constructor</code> 被调用。阻止某个 <code>class</code> 产出对象的最简单方法就是将其 <code>constructors</code> 声明为 <code>private</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">CantBeInstantiated</span> <span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token function">CatBeInstantiated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">CantBeInstantiated</span><span class="token punctuation">(</span><span class="token keyword">const</span> CantBeInstantiated<span class="token operator">&amp;</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-封装对象在函数内"><a href="#1-2-封装对象在函数内" class="headerlink" title="1.2.封装对象在函数内"></a>1.2.封装对象在函数内</h4><p>我们可以将对象封装在某个函数内，如此一来只有唯一一个对象被产生.<br>接下使用打印机的例子来说明。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">PrintJob</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Printer</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">submitJob</span><span class="token punctuation">(</span><span class="token keyword">const</span> PrintJob<span class="token operator">&amp;</span> job<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">performSelfTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">friend</span> Printer<span class="token operator">&amp;</span> <span class="token function">thePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token keyword">const</span> Printer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Printer<span class="token operator">&amp;</span> <span class="token function">thePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">static</span> Printer p<span class="token punctuation">;</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//唯一一个打印机对象</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里有三个点值得注意</p><ul><li><code>Printer class</code> 的 <code>constructors</code> 属性 <code>private</code>，可以压制对象的诞生。</li><li>全局函数 <code>thePrinter</code> 被声明在此 <code>class</code> 的一个 <code>friend</code>，致使 <code>thePrinter</code> 不受 <code>private constructors</code> 的约束。</li><li><code>thePrinter</code> 内含一个 <code>static Printer</code> 对象，意思只有一个 <code>Printer</code> 对象被产生出来。</li></ul><p>在使用的时候，只需要调用 <code>thePrinter().</code> 就可以</p><h4 id="1-2-消除firend"><a href="#1-2-消除firend" class="headerlink" title="1.2.消除firend"></a>1.2.消除<code>firend</code></h4><p>以上方的例子为例，我们可以让 <code>thePrinter</code> 成为 <code>Printer</code> 的一个 <code>static member function</code>，消除 <code>friend</code> 的必要性。我们就能获得接下来的代码</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Printer</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token keyword">static</span> Printer<span class="token operator">&amp;</span> <span class="token function">thePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token keyword">const</span> Printer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Printer<span class="token operator">&amp;</span> Printer<span class="token operator">::</span><span class="token function">thePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">static</span> Printer p<span class="token punctuation">;</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在用户调用 <code>Printer</code>时，会显得冗长</p><pre class="line-numbers language-cpp"><code class="language-cpp">Printer<span class="token operator">::</span><span class="token function">thePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="1-3-使用namespace"><a href="#1-3-使用namespace" class="headerlink" title="1.3.使用namespace"></a>1.3.使用<code>namespace</code></h4><p>另一个做法是把 <code>Printer</code> 和 <code>thePrinter</code> 从全局空间移走，放进一个 <code>namespace</code> 内。我们就可以得到以下代码</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">namespace</span> PrintingStuff<span class="token punctuation">{</span>
    <span class="token keyword">class</span> <span class="token class-name">Printer</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">//这个class 位于 PrintingStuff namespace 内</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token keyword">void</span> <span class="token function">submitJob</span><span class="token punctuation">(</span><span class="token keyword">const</span> PrintJob<span class="token operator">&amp;</span> job<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">void</span> <span class="token function">performSelfTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    <span class="token keyword">friend</span> Printer<span class="token operator">&amp;</span> <span class="token function">thePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span><span class="token operator">:</span>
        <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token keyword">const</span> Printer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    Printer<span class="token operator">&amp;</span> <span class="token function">thePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   这个函数也位于 PrintingStuff <span class="token keyword">namespace</span> 内
    <span class="token punctuation">{</span>
        <span class="token keyword">static</span> Printer p<span class="token punctuation">;</span>
        <span class="token keyword">return</span> p<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//唯一一个打印机对象</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了这个 <code>namespace</code>，用户就能使用完全限定名来取用 <code>thePrinter</code>:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> PrintingStuff<span class="token operator">::</span>theprinter<span class="token punctuation">;</span>

<span class="token function">thePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在此代码实现中，又两个精细的地方值得探讨。</p><ul><li>形成唯一一个 <code>Printer</code> 对象的，是函数中的 <code>static</code> 对象，而非 <code>class</code> 中的 <code>static</code> 对象。<br>C++ 的一个设计哲学基础是你不应该为你并不使用的东西付出任何代价。<br><code>function static</code>的初始时机：在该函数第一次被调用时。<br><code>class static</code> 则不一定在什么时候初始化。</li><li>函数的 <code>static</code> 对象与 <code>inlining</code> 的互动。</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp">Printer<span class="token operator">&amp;</span> <span class="token function">thePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
 <span class="token keyword">static</span> Printer p<span class="token punctuation">;</span>
 <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果上方的函数被声明为 <code>inline</code>，那么你的程序可能会拥有多份该 <code>static</code> 对象的副本。因为 <code>inline</code> 意味着编译器应该将每一个调用动作以函数本身取代。<br>千万不要产生内含 <code>local static</code> 对象的 <code>inline non-member functions</code>。</p><h4 id="1-4-使用抛出异常提示产生了过多的对象"><a href="#1-4-使用抛出异常提示产生了过多的对象" class="headerlink" title="1.4.使用抛出异常提示产生了过多的对象"></a>1.4.使用抛出异常提示产生了过多的对象</h4><p>我们继续改进我们的 <code>Printer</code>,给定一个函数来抛出一个类型为 <code>TooManyObjects</code> 的 <code>exception</code></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Printer</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">class</span> <span class="token class-name">TooManyObjects</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">~</span><span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">static</span> size_t numberObjects<span class="token punctuation">;</span>
    <span class="token function">Printer</span><span class="token punctuation">(</span>cosnt Printer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//我们限制只有一个打印机，所以绝不允许复制行为，所以放在private区</span>
<span class="token punctuation">}</span>

size_t Printer<span class="token operator">::</span>numberObjects <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

Printer<span class="token operator">::</span><span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>numObjects <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">)</span>    
    <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token function">TooManyObjects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 这里处理一般的构造</span>
    <span class="token operator">++</span>numObjects<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

Printer<span class="token operator">::</span><span class="token operator">~</span><span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 这里处理析构</span>
    <span class="token operator">--</span>numObjects<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个非常简单直观。</p><h3 id="2-不同的对象构造状态"><a href="#2-不同的对象构造状态" class="headerlink" title="2.不同的对象构造状态"></a>2.不同的对象构造状态</h3><h4 id="2-1-继承问题"><a href="#2-1-继承问题" class="headerlink" title="2.1.继承问题"></a>2.1.继承问题</h4><p>假设我们有一台彩色打印机</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">ColorPrinter</span><span class="token operator">:</span> <span class="token keyword">public</span> Printer<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当我们调用下面的代码时</p><pre class="line-numbers language-cpp"><code class="language-cpp">Printer p<span class="token punctuation">;</span>
ColorPrinter cp<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们其实构造了两个Printer对象，这个时候就会有 <code>TooManyObjects exception</code> 被抛出。</p><h4 id="2-2-对象包含问题"><a href="#2-2-对象包含问题" class="headerlink" title="2.2.对象包含问题"></a>2.2.对象包含问题</h4><p>当我们有对象包含<code>Printer</code>时，就会出现这样的代码</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Machine</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//这是一个机器，处理打印、传真等功能</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    Printer p<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 针对打印功能</span>
    FaxMachine f<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 针对传真功能</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 这里调用</span>
Machine m1<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 没有问题</span>
Machine m2<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 抛出 TooManyObjects exception</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，当我们构造 <code>m2</code> 的时候，就出现问题了，因为此时 <code>Printer</code> 对象位于较大对象当中</p><h4 id="2-3-阻止继承"><a href="#2-3-阻止继承" class="headerlink" title="2.3.阻止继承"></a>2.3.阻止继承</h4><p>为了阻止上述的继承导致的问题，我们可以通过把 <code>constructors</code> 变为 <code>private</code> 来实现禁止派生。</p><h3 id="3-允许对象生生灭灭"><a href="#3-允许对象生生灭灭" class="headerlink" title="3.允许对象生生灭灭"></a>3.允许对象生生灭灭</h3><p>到这里我们已经能得到一个较好的版本了，可以限制对象生成的数量。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Printer</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">class</span> <span class="token class-name">TooManyObjects</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">static</span> Printer <span class="token operator">*</span><span class="token function">MakePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
    <span class="token operator">~</span><span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token function">submitJob</span><span class="token punctuation">(</span>cibst PrintJob <span class="token operator">&amp;</span>job<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这里是一些外部调用的接口</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">static</span> size_t<span class="token operator">::</span>numObjects<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 用于记录已经生成的Printer对象</span>
    <span class="token keyword">const</span> size_t Printer<span class="token operator">::</span>maxObject <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 用于限制最大的对象数量</span>

    <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                              <span class="token comment" spellcheck="true">// 我们不允许继承，所以放置再private区</span>
    <span class="token function">Printer</span><span class="token punctuation">(</span>cosnt Printer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 我们不允许直接调用拷贝构造，所以放在private区</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

Printer<span class="token operator">::</span><span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>numObjects <span class="token operator">>=</span> maxObjects<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token function">TooManyObjects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 这里处理一般的构造</span>
    <span class="token operator">++</span>numObjects<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

Printer<span class="token operator">::</span><span class="token function">Printer</span><span class="token punctuation">(</span>cosnt Printer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>
<span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">// 这里处理和默认构造函数一致</span>
<span class="token punctuation">}</span>

Printer<span class="token operator">::</span><span class="token operator">~</span><span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 这里处理析构</span>
    <span class="token operator">--</span>numObjects<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

Printer <span class="token operator">*</span>Printer<span class="token operator">::</span><span class="token function">makePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">new</span> Printer<span class="token punctuation">;</span> <span class="token punctuation">}</span>

Printer <span class="token operator">*</span>Printer<span class="token operator">::</span><span class="token function">MakePrinter</span><span class="token punctuation">(</span><span class="token keyword">const</span> Printer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>
<span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">Printer</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-一个用来计算对象个数的-Base-Class"><a href="#4-一个用来计算对象个数的-Base-Class" class="headerlink" title="4.一个用来计算对象个数的 Base Class"></a>4.一个用来计算对象个数的 <code>Base Class</code></h3><p>接下来我们使用 <code>template</code> 来实现</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">BeingCounted</span><span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">Counted</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">class</span> <span class="token class-name">TooManyObjects</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">objectCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> numObjects<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token function">Counted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Counted</span><span class="token punctuation">(</span><span class="token keyword">const</span> Counted <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">~</span><span class="token function">Counted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">--</span>numObjects<span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> numObjects<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">const</span> size_t maxObjects<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 用以避免 ctor 码重复出现</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">BeingCounted</span><span class="token operator">></span>
Counted<span class="token operator">&lt;</span>BeingCounted<span class="token operator">></span><span class="token operator">::</span><span class="token function">Counted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">BeingCounted</span><span class="token operator">></span>
Counted<span class="token operator">&lt;</span>BeingCounted<span class="token operator">></span><span class="token operator">::</span><span class="token function">Counted</span><span class="token punctuation">(</span><span class="token keyword">const</span> Counted<span class="token operator">&lt;</span>BeingCounted<span class="token operator">></span><span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">BeingCounted</span><span class="token operator">></span>
<span class="token keyword">void</span> Counted<span class="token operator">&lt;</span>BeingCounted<span class="token operator">></span><span class="token operator">::</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>numObjects <span class="token operator">>=</span> maxObjects<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token function">TooManyObjects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">++</span>numObjects<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 下面我们要使用上面的模板，实现一个只能构造 10 个对象的打印机</span>

<span class="token keyword">const</span> size_t Counted<span class="token operator">&lt;</span>Printer<span class="token operator">></span><span class="token operator">::</span>maxObjects <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Printer</span> <span class="token operator">:</span> <span class="token keyword">private</span> Counted<span class="token operator">&lt;</span>Printer<span class="token operator">></span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment" spellcheck="true">// pseudo-constructors</span>
    <span class="token keyword">static</span> Printer <span class="token operator">*</span><span class="token function">makePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> Printer <span class="token operator">*</span><span class="token function">makePrinter</span><span class="token punctuation">(</span><span class="token keyword">const</span> Printer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>
    <span class="token operator">~</span><span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token function">submitJob</span><span class="token punctuation">(</span><span class="token keyword">const</span> PrintJob<span class="token operator">&amp;</span> job<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">performSelfTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    <span class="token keyword">using</span> Counted<span class="token operator">&lt;</span>Printer<span class="token operator">></span><span class="token operator">::</span>objectCount<span class="token punctuation">;</span>
    <span class="token keyword">using</span> Counted<span class="token operator">&lt;</span>Printer<span class="token operator">></span><span class="token operator">::</span>TooManyObjects<span class="token punctuation">;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token keyword">const</span> Printer <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="条款27：要求（或禁止）对象产生于-heap-中"><a href="#条款27：要求（或禁止）对象产生于-heap-中" class="headerlink" title="条款27：要求（或禁止）对象产生于 heap 中"></a>条款27：要求（或禁止）对象产生于 heap 中</h2><h3 id="要求对象产生于-heap-之中（Heap-Based-Objects）"><a href="#要求对象产生于-heap-之中（Heap-Based-Objects）" class="headerlink" title="要求对象产生于 heap 之中（Heap-Based Objects）"></a>要求对象产生于 <code>heap 之中</code>（<code>Heap-Based Objects</code>）</h3><p>只要限制 <code>destructor</code> 或 <code>constructors</code> 的运用，便可阻止 <code>non-heap object</code> 的诞生。但是他同时也妨碍了继承（<code>inheritance</code>）和包含（<code>containment</code>）</p><h3 id="禁止对象产生于-heap-中"><a href="#禁止对象产生于-heap-中" class="headerlink" title="禁止对象产生于 heap 中"></a>禁止对象产生于 <code>heap</code> 中</h3><p>首先我们需要知道有三种情况下，对象可能被产生于 <code>heap</code> 中</p><ol><li>对象被直接实例化</li><li>对象被实例化为 <code>derived class objects</code> 内的 “base class 成分”</li><li>对象被内嵌于其他对象之中</li></ol><p>简单来说，可以直接设置 <code>operator new</code> 和 <code>operator delete</code> 为 <code>private</code> 即可</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">UPNumber</span><span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你也像禁止“由 <code>UPNumber</code> 对象所组成的数组” 位于 <code>heap</code> 内，可以将 <code>operator new[]</code> 和 <code>operator delete[]</code> 亦声明为 <code>private</code>。当然现在更推荐直接delete掉。</p><h2 id="条款28：Smart-Pointers（智能指针）"><a href="#条款28：Smart-Pointers（智能指针）" class="headerlink" title="条款28：Smart Pointers（智能指针）"></a>条款28：Smart Pointers（智能指针）</h2><p>这里的智能指针比较早，包括了auto_ptr，可以单独了解，本书内容有点过时了。</p><h2 id="条款29：Reference-counting（引用计数）"><a href="#条款29：Reference-counting（引用计数）" class="headerlink" title="条款29：Reference counting（引用计数）"></a>条款29：Reference counting（引用计数）</h2><p>总体意思需要结合上一个条款中谈到的 <code>smart ptr</code> 来实现引用计数。有几个方面需要考虑</p><ul><li>需要有一个结构体即存储引用次数，也要存储数据</li><li>上述需要生成在堆中，通过指针访问地址</li><li>正确且自动处理引用增加及减少情况<ul><li>构造函数（包括拷贝构造等）</li><li>析构函数</li><li>赋值</li></ul></li><li>修改对象数据时需要调整引用及分享权限（也就是 <code>copy on write</code>）</li><li>避免内存泄漏</li></ul><h2 id="条款30：Proxy-classes（替身类、代理类）"><a href="#条款30：Proxy-classes（替身类、代理类）" class="headerlink" title="条款30：Proxy classes（替身类、代理类）"></a>条款30：Proxy classes（替身类、代理类）</h2><p>简单来说，如果我们有一个 <code>string a = &quot;123&quot;;</code> 此时我们想用 <code>a[0]</code> 取得 <code>&#39;1&#39;</code>。然而我们这里取得<code>&#39;1&#39;</code>之后，我们会有以下一种行为</p><ol><li>只读，此时我们不需要修改 <code>reference count</code></li><li>写入，此时我们需要修改 <code>reference count</code></li></ol><p>所以我们这里返回的时候可以不返回一个 <code>char</code> 而是返回一个结构体，且只要这个结构体能够转换为<code>char</code>就行了。这个和之前所讲的 条款17：缓式评估 有相同的实现思路，可以折回去参考一下。</p><h2 id="条款31：让函数根据一个以上的对象类型来决定如何虚化"><a href="#条款31：让函数根据一个以上的对象类型来决定如何虚化" class="headerlink" title="条款31：让函数根据一个以上的对象类型来决定如何虚化"></a>条款31：让函数根据一个以上的对象类型来决定如何虚化</h2><p>这里指出了一个情况，例如我们有三种物体，且都继承<code>GameObject</code></p><ul><li><code>SpaceShip</code> 飞船</li><li><code>SpaceStation</code> 空间站</li><li><code>Asteroid</code> 陨石</li></ul><p>不同的物体会相撞，且会产生不同的结果。例如飞船和空间站相撞，飞船能进入到空间站内；飞船和陨石相撞，两者都会摧毁。<br>这个时候，我们需要一个方法，传入任意俩个<code>GameObject</code>都可以处理。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">processCollision</span><span class="token punctuation">(</span>GameObject<span class="token operator">&amp;</span> object1<span class="token punctuation">,</span> GameObject<span class="token operator">&amp;</span> object2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>书中讨论了一套方法，是一个不错的方法，但是感觉还不是很完美。目前就整理一下代码，记录下来。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;map></span></span>

<span class="token keyword">class</span> <span class="token class-name">GameObject</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">GameObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//基类里面有虚函数，派生类继承后，使用typeid().name才能取得对应的class name</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">SpaceShip</span> <span class="token operator">:</span> <span class="token keyword">public</span> GameObject <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">SpaceStation</span> <span class="token operator">:</span> <span class="token keyword">public</span> GameObject <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Asteroid</span> <span class="token operator">:</span> <span class="token keyword">public</span> GameObject <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//匿名namespace</span>
<span class="token keyword">namespace</span> <span class="token punctuation">{</span>
    <span class="token keyword">using</span> std<span class="token operator">::</span>string<span class="token punctuation">;</span>
    <span class="token keyword">using</span> std<span class="token operator">::</span>map<span class="token punctuation">;</span>
    <span class="token keyword">using</span> std<span class="token operator">::</span>make_pair<span class="token punctuation">;</span>
    <span class="token keyword">using</span> std<span class="token operator">::</span>pair<span class="token punctuation">;</span>
    <span class="token keyword">using</span> std<span class="token operator">::</span>cout<span class="token punctuation">;</span>
    <span class="token keyword">using</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token function">shipAsteroid</span><span class="token punctuation">(</span>GameObject<span class="token operator">&amp;</span> spaceShip<span class="token punctuation">,</span> GameObject<span class="token operator">&amp;</span> asteroid<span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"spaceShip collide with asteroid"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">shipStation</span><span class="token punctuation">(</span>GameObject<span class="token operator">&amp;</span> spaceShip<span class="token punctuation">,</span> GameObject<span class="token operator">&amp;</span> spaceStation<span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"spaceShip collide with spaceStation"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">asteroidStation</span><span class="token punctuation">(</span>GameObject<span class="token operator">&amp;</span> asteroid<span class="token punctuation">,</span> GameObject<span class="token operator">&amp;</span> spaceStation<span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"asteroid collide with spaceStation"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token function">asteroidShip</span><span class="token punctuation">(</span>GameObject<span class="token operator">&amp;</span> asteroid<span class="token punctuation">,</span> GameObject<span class="token operator">&amp;</span> spaceShip<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">shipAsteroid</span><span class="token punctuation">(</span>spaceShip<span class="token punctuation">,</span> asteroid<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">stationShip</span><span class="token punctuation">(</span>GameObject<span class="token operator">&amp;</span> spaceStation<span class="token punctuation">,</span> GameObject<span class="token operator">&amp;</span> spaceShip<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">shipStation</span><span class="token punctuation">(</span>spaceShip<span class="token punctuation">,</span> spaceStation<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">stationAsteroid</span><span class="token punctuation">(</span>GameObject<span class="token operator">&amp;</span> spaceStation<span class="token punctuation">,</span> GameObject<span class="token operator">&amp;</span> asteroid<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">asteroidStation</span><span class="token punctuation">(</span>asteroid<span class="token punctuation">,</span> spaceStation<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//碰撞map</span>
<span class="token keyword">class</span> <span class="token class-name">CollisionMap</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment" spellcheck="true">//这里使用单例</span>
    <span class="token keyword">static</span> CollisionMap<span class="token operator">*</span> <span class="token function">theCollisionMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">static</span> CollisionMap CM<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">&amp;</span>CM<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>HitFunctionPtr<span class="token punctuation">)</span><span class="token punctuation">(</span>GameObject<span class="token operator">&amp;</span><span class="token punctuation">,</span> GameObject<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//这里添加新的碰撞处理函数，成对处理</span>
    <span class="token keyword">void</span> <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> type1<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> type2<span class="token punctuation">,</span> HitFunctionPtr collisionFunction<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>collisionMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">make_pair</span><span class="token punctuation">(</span>type1<span class="token punctuation">,</span> type2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> collisionMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">//成对添加</span>
        collisionMap<span class="token punctuation">[</span>std<span class="token operator">::</span><span class="token function">make_pair</span><span class="token punctuation">(</span>type1<span class="token punctuation">,</span> type2<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> collisionFunction<span class="token punctuation">;</span>
        collisionMap<span class="token punctuation">[</span>std<span class="token operator">::</span><span class="token function">make_pair</span><span class="token punctuation">(</span>type2<span class="token punctuation">,</span> type1<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> collisionFunction<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">//这里移除碰撞函数</span>
    <span class="token keyword">void</span> <span class="token function">removeEntry</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> type1<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> type2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>collisionMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">make_pair</span><span class="token punctuation">(</span>type1<span class="token punctuation">,</span> type2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> collisionMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">//成对移除</span>
        collisionMap<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">make_pair</span><span class="token punctuation">(</span>type1<span class="token punctuation">,</span> type2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        collisionMap<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">make_pair</span><span class="token punctuation">(</span>type2<span class="token punctuation">,</span> type1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">//查找有没有对应的碰撞函数</span>
    HitFunctionPtr <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> class1<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> class2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        HitMap<span class="token operator">::</span>iterator it <span class="token operator">=</span> collisionMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span>class1<span class="token punctuation">,</span> class2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>it <span class="token operator">==</span> collisionMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">typedef</span> map<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> string<span class="token operator">></span><span class="token punctuation">,</span> HitFunctionPtr<span class="token operator">></span> HitMap<span class="token punctuation">;</span>
    HitMap collisionMap<span class="token punctuation">;</span>

    <span class="token function">CollisionMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">initializeCollisionMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">CollisionMap</span><span class="token punctuation">(</span><span class="token keyword">const</span> CollisionMap<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 这里可以内部初始化，也可以改为一个函数，来注册一下函数</span>
    <span class="token keyword">void</span> <span class="token function">initializeCollisionMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        collisionMap<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token string">"class SpaceShip"</span><span class="token punctuation">,</span> <span class="token string">"class Asteroid"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>shipAsteroid<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token string">"class SpaceShip"</span><span class="token punctuation">,</span> <span class="token string">"class SpaceStation"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>shipStation<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//匿名namespace</span>
<span class="token keyword">namespace</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//这里处理碰撞，会查找碰撞map，如果有函数就执行，没有的话就抛出异常</span>
    <span class="token keyword">void</span> <span class="token function">processCollision</span><span class="token punctuation">(</span>GameObject<span class="token operator">&amp;</span> object1<span class="token punctuation">,</span> GameObject<span class="token operator">&amp;</span> object2<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        CollisionMap<span class="token operator">*</span> CM <span class="token operator">=</span> CollisionMap<span class="token operator">::</span><span class="token function">theCollisionMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        CollisionMap<span class="token operator">::</span>HitFunctionPtr phf <span class="token operator">=</span> CM<span class="token operator">-</span><span class="token operator">></span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">typeid</span><span class="token punctuation">(</span>object1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>object2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>phf<span class="token punctuation">)</span> <span class="token function">phf</span><span class="token punctuation">(</span>object1<span class="token punctuation">,</span> object2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"UnkowCollision! "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>object1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" - "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>object2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    SpaceShip spaceShip<span class="token punctuation">;</span>
    Asteroid asteroid<span class="token punctuation">;</span>
    SpaceStation spaceStation<span class="token punctuation">;</span>

    <span class="token function">processCollision</span><span class="token punctuation">(</span>spaceShip<span class="token punctuation">,</span> asteroid<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//spaceShip collide with asteroid</span>
    <span class="token function">processCollision</span><span class="token punctuation">(</span>asteroid<span class="token punctuation">,</span> spaceShip<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//UnkowCollision! class Asteroid - class SpaceShip</span>
    <span class="token function">processCollision</span><span class="token punctuation">(</span>spaceShip<span class="token punctuation">,</span> spaceStation<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//spaceShip collide with spaceStation</span>
    <span class="token function">processCollision</span><span class="token punctuation">(</span>asteroid<span class="token punctuation">,</span> spaceStation<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//UnkowCollision! class Asteroid - class SpaceStation</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="条款32：在未来时态下发展程序"><a href="#条款32：在未来时态下发展程序" class="headerlink" title="条款32：在未来时态下发展程序"></a>条款32：在未来时态下发展程序</h2><p>对于未来式思维，作者希望我们多考虑一些东西：</p><ul><li>提供玩真的<code>class</code> —— 即使某些部分目前用不到。当心的需求进来，你不太需要回头去修改那些 <code>classes</code>。</li><li>设计你的接口，使有利于共同的操作行为，阻止共同的错误。让这些 <code>classes</code> 轻易地被正确运用，难以被错误运用。</li><li>尽量使你都代码一般化（泛化），除非有不良的巨大后果。</li></ul><p>但是注意在之前的effective c++中提到的，过早优化是性能恶化之源。</p><h2 id="条款33：将非尾端类-non-leaf-classes-设计为-抽象类-abstract-classes"><a href="#条款33：将非尾端类-non-leaf-classes-设计为-抽象类-abstract-classes" class="headerlink" title="条款33：将非尾端类(non-leaf classes) 设计为 抽象类(abstract classes)"></a>条款33：将非尾端类(non-leaf classes) 设计为 抽象类(abstract classes)</h2><p>继承体系中的 <code>non-leaf</code>(非尾端)类应该使抽象类。如果 使用外界供应的程序库，你或许可以对其法则做点变通；单如果代码完全在你掌控之下，坚持这个法则，可以为你带来许多好处，并提升整个软件的可靠度、健壮度、精巧度、扩充度。</p><p>当然了，现在的设计思路一般都是组合优于继承，继承能干的组合就能够解决。</p><h2 id="条款34：如何在同一程序中结合-C-和-C"><a href="#条款34：如何在同一程序中结合-C-和-C" class="headerlink" title="条款34：如何在同一程序中结合 C++ 和 C"></a>条款34：如何在同一程序中结合 C++ 和 C</h2><ul><li><code>Name Mangling</code>(名命重整)</li><li><code>Statics</code> 的初始化</li><li>动态内存分配</li><li>数据结构的兼容性</li></ul><p>并指明了以下守则</p><ul><li>确定你的 C++ 和 C 编译器产出兼容的目标文件(<code>object files</code>)。</li><li>将双方都使用的函数声明为 <code>extern &quot;C&quot;</code>。</li><li>如果可能，尽可能在 C++ 中撰写 <code>main</code>。</li><li>总是以 <code>delete</code> 删除 <code>new</code> 返回的内存：总是以 <code>free</code> 释放 <code>malloc</code> 放回的内存。</li><li>将两个语言间的“数据结构传递”限制于 C 所能了解的形式；C++ <code>structs</code> 如果内含非虚函数，但是不受此限。</li></ul><h2 id="条款35：让自己习惯于标准-C-语言"><a href="#条款35：让自己习惯于标准-C-语言" class="headerlink" title="条款35：让自己习惯于标准 C++ 语言"></a>条款35：让自己习惯于标准 C++ 语言</h2><p>拥抱新的c++标准。</p></div><hr><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/tags/Cpp/"><span class="chip bg-color">Cpp</span> </a><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="chip bg-color">读书笔记</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="wechat,qq" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="/libs/share/js/social-share.min.js"></script></div></div></div></div></div><style>.valine-card{margin:1.5rem auto}.valine-card .card-content{padding:20px 20px 5px 20px}#vcomments textarea{box-sizing:border-box;background:url(/medias/comment_bg.png) 100% 100% no-repeat}#vcomments p{margin:2px 2px 10px;font-size:1.05rem;line-height:1.78rem}#vcomments blockquote p{text-indent:.2rem}#vcomments a{padding:0 2px;color:#4cbf30;font-weight:500;text-decoration:none}#vcomments img{max-width:100%;height:auto;cursor:pointer}#vcomments ol li{list-style-type:decimal}#vcomments ol,ul{display:block;padding-left:2em;word-spacing:.05rem}#vcomments ul li,ol li{display:list-item;line-height:1.8rem;font-size:1rem}#vcomments ul li{list-style-type:disc}#vcomments ul ul li{list-style-type:circle}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}#vcomments table,td,th{border:0}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments h1{font-size:1.85rem;font-weight:700;line-height:2.2rem}#vcomments h2{font-size:1.65rem;font-weight:700;line-height:1.9rem}#vcomments h3{font-size:1.45rem;font-weight:700;line-height:1.7rem}#vcomments h4{font-size:1.25rem;font-weight:700;line-height:1.5rem}#vcomments h5{font-size:1.1rem;font-weight:700;line-height:1.4rem}#vcomments h6{font-size:1rem;line-height:1.3rem}#vcomments p{font-size:1rem;line-height:1.5rem}#vcomments hr{margin:12px 0;border:0;border-top:1px solid #ccc}#vcomments blockquote{margin:15px 0;border-left:5px solid #42b983;padding:1rem .8rem .3rem .8rem;color:#666;background-color:rgba(66,185,131,.1)}#vcomments pre{font-family:monospace,monospace;padding:1.2em;margin:.5em 0;background:#272822;overflow:auto;border-radius:.3em;tab-size:4}#vcomments code{font-family:monospace,monospace;padding:1px 3px;font-size:.92rem;color:#e96900;background-color:#f8f8f8;border-radius:2px}#vcomments pre code{font-family:monospace,monospace;padding:0;color:#e8eaf6;background-color:#272822}#vcomments pre[class*=language-]{padding:1.2em;margin:.5em 0}#vcomments code[class*=language-],pre[class*=language-]{color:#e8eaf6}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}#vcomments b,strong{font-weight:700}#vcomments dfn{font-style:italic}#vcomments small{font-size:85%}#vcomments cite{font-style:normal}#vcomments mark{background-color:#fcf8e3;padding:.2em}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}.v .vlist .vcard{padding-top:2.5em!important}</style><div class="card valine-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;left:20px;top:15px;padding-bottom:5px"><i class="fa fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="vcomments" class="card-content" style="display:grid"></div></div><script src="/libs/valine/av-min.js"></script><script src="/libs/valine/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"98JpzSGcrl9jFqHO13vqxHvX-gzGzoHsz",appKey:"mDmr2h9PB20xvPMNqgyRnNIC",notify:!0,verify:!0,visitor:!0,avatar:"mm",pageSize:"10",lang:"zh-cn",placeholder:"just go go"})</script><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fa fa-chevron-left"></i>&nbsp;上一篇</div><div class="card"><a href="/posts/30790/"><div class="card-image"><img src="/medias/featureimages/19.jpg" class="responsive-img" alt="Cpp 中如何优雅进行 enum 到 string 的转换"> <span class="card-title">Cpp 中如何优雅进行 enum 到 string 的转换</span></div></a><div class="card-content article-content"><div class="summary block-with-text">拒绝硬编码从我做起</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2024-03-11 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/Cpp/" class="post-category">Cpp</a></span></div></div><div class="card-action article-tags"><a href="/tags/Cpp/"><span class="chip bg-color">Cpp</span> </a><a href="/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"><span class="chip bg-color">工程经验</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fa fa-chevron-right"></i></div><div class="card"><a href="/posts/23555/"><div class="card-image"><img src="/medias/featureimages/21.jpg" class="responsive-img" alt="Cpp工程实践必备技能"> <span class="card-title">Cpp工程实践必备技能</span></div></a><div class="card-content article-content"><div class="summary block-with-text">现代工程的一些不教但是你得知道的东西</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2024-03-06 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/Cpp/" class="post-category">Cpp</a></span></div></div><div class="card-action article-tags"><a href="/tags/Cpp/"><span class="chip bg-color">Cpp</span> </a><a href="/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"><span class="chip bg-color">工程经验</span></a></div></div></div></div></article></div><script>$("#articleContent").on("copy",function(e){var n,t,o,i;void 0!==window.getSelection&&((""+(n=window.getSelection())).length<Number.parseInt("120")||(t=document.getElementsByTagName("body")[0],(o=document.createElement("div")).style.position="absolute",o.style.left="-99999px",t.appendChild(o),o.appendChild(n.getRangeAt(0).cloneContents()),"PRE"===n.getRangeAt(0).commonAncestorContainer.nodeName&&(o.innerHTML="<pre>"+o.innerHTML+"</pre>"),i=document.location.href,o.innerHTML+='<br />来源: JoyTsing<br />文章作者: JoyTsing<br />文章链接: <a href="'+i+'">'+i+"</a><br />本文章著作权归作者joytsing所有，请任何形式的转载都请注明出处并在文章评论区处告知。",n.selectAllChildren(o),window.setTimeout(function(){t.removeChild(o)},200)))})</script><script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script><script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script><script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script><script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget"><div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fa fa-list"></i></a></div><script src="/libs/tocbot/tocbot.min.js"></script><script>$(function(){tocbot.init({tocSelector:"#toc-content",contentSelector:"#articleContent",headingsOffset:-(.4*$(window).height()-45),headingSelector:"h2, h3, h4, h5"});let t=0;var e="toc-heading-";$("#toc-content a").each(function(){$(this).attr("href","#"+e+ ++t)}),t=0,$("#articleContent").children("h2, h3, h4, h5").each(function(){$(this).attr("id",e+ ++t)});var n=parseInt(.4*$(window).height()-64);let o=$(".toc-widget");$(window).scroll(function(){var t=$(window).scrollTop();n<t?o.addClass("toc-fixed"):o.removeClass("toc-fixed")});var i="expanded";let a=$("#toc-aside"),c=$("#main-content");$("#floating-toc-btn .btn-floating").click(function(){a.hasClass(i)?(a.removeClass(i).hide(),c.removeClass("l9")):(a.addClass(i).show(),c.addClass("l9")),function(){let e=$("#artDetail");if(0!==e.length){let t=e.width();450<=t?t+=21:350<=t&&t<450?t+=18:300<=t&&t<350?t+=16:t+=14,$("#prenext-posts").width(t)}}()})})</script></main><footer class="page-footer bg-color"><div class="container row center-align"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2019</span> <a href="/about" rel="external nofollow noreferrer">JoyTsing</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br><span id="sitetime">载入运行时间...</span> <span id="busuanzi_container_site_pv">|&nbsp;<i class="fa fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span>&nbsp;次 </span><span id="busuanzi_container_site_uv">|&nbsp;<i class="fa fa-user"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv" class="white-color"></span>&nbsp;人</span><br>&nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;<span class="white-color">834k</span>&nbsp;字 <span id="icp"><img src="/medias/icp.png" style="vertical-align:text-bottom" alt="icp"> <a href="https://beian.miit.gov.cn/" target="_blank">陕公网安备61019002002862号 滇ICP备2024026466号-1</a></span><script>function siteTime(){var e=864e5,t="2019",n=(m=new Date).getFullYear(),o=m.getMonth()+1,r=m.getDate(),a=m.getHours(),i=m.getMinutes(),l=m.getSeconds(),m=Date.UTC(t,"7","24","0","0","0"),r=Date.UTC(n,o,r,a,i,l)-m,a=Math.floor(r/31536e6),i=Math.floor(r/e-365*a),l=Math.floor((r-(365*a+i)*e)/36e5),m=Math.floor((r-(365*a+i)*e-36e5*l)/6e4),M=Math.floor((r-(365*a+i)*e-36e5*l-6e4*m)/1e3);t==n?(document.getElementById("year").innerHTML=n,document.getElementById("sitetime").innerHTML="本站已安全运行 "+i+" 天 "+l+" 小时 "+m+" 分钟 "+M+" 秒"):(document.getElementById("year").innerHTML=t+" - "+n,document.getElementById("sitetime").innerHTML="本站已安全运行 "+a+" 年 "+i+" 天 "+l+" 小时 "+m+" 分钟 "+M+" 秒")}setInterval(siteTime,1e3)</script></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/JoyTsing" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fa fa-github"></i> </a><a href="/medias/wechat.jpg" target="_blank" data-tooltip="添加我的微信: [object Object]" data-position="top" data-delay="50"><i class="fa fa-weixin"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script src="/js/search.js"></script><script type="text/javascript">$(function(){searchFunc("/search.xml","searchInput","searchResult")})</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fa fa-angle-up"></i></a></div><script src="/libs/materialize/materialize.min.js"></script><script src="/libs/masonry/masonry.pkgd.min.js"></script><script src="/libs/aos/aos.js"></script><script src="/libs/scrollprogress/scrollProgress.min.js"></script><script src="/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="/js/matery.js"></script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?3a39d92b69933ae56c7eb41ffb9aa2e0";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="/libs/others/busuanzi.pure.mini.js"></script><script type="text/javascript">var st,OriginTitile=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="(oﾟvﾟ)ノ Hi",clearTimeout(st)):(document.title="(*´∇｀*) 欢迎回来！",st=setTimeout(function(){document.title=OriginTitile},3e3))})</script><script type="text/javascript" color="0,0,255" pointcolor="0,0,255" opacity="0.8" zindex="-1" count="150" src="/libs/background/canvas-nest.js"></script><script src="/libs/instantpage/instantpage.js" type="module"></script><script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script><script>const hasAttr = (e,a) => a.some(_=> e.attr(_)!==undefined);
        $('a').each(function() {
          const $this = $(this);
          if(hasAttr($this,["data-fancybox","ignore-external-link"])) return;
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== '' || window.location.host) {
                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":150,"height":200},"mobile":{"show":false},"react":{"opacity":0.7}});</script></body></html>