<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="计算机病毒原理与防范, 博客 JoyTsing blog">
    <meta name="description" content="期末复习与总结">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="white"/>
    <title>计算机病毒原理与防范 | JoyTsing</title>
    <link rel="apple-touch-icon" href="/">
    <link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="/favicon.ico">
    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <style type="text/css">
        
        code[class*="language-"], pre[class*="language-"] {
            white-space: pre !important;
        }

        
    </style>
    <script src="/libs/jquery/jquery.min.js"></script>
<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="JoyTsing" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>

<header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                        <img src="/apple-touch-icon.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">JoyTsing</span>
                </a>
            </div>
            


<!-- <a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/contact" class="waves-effect waves-light">
            
            <i class="fa fa-envelope"></i>
            
            <span>留言</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友链</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul> -->

<!-- 支持二级菜单特性 -->
<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right nav-menu">
    
        <li class="hide-on-med-and-down nav-item">

            
                <a href="/" class="waves-effect waves-light">
                    
                        <i class="fa fa-home"></i>
                    
                    <span>首页</span>
                </a>

            
        </li>
    
        <li class="hide-on-med-and-down nav-item">

            
                <a href="/tags" class="waves-effect waves-light">
                    
                        <i class="fa fa-tags"></i>
                    
                    <span>标签</span>
                </a>

            
        </li>
    
        <li class="hide-on-med-and-down nav-item">

            
                <a href="/categories" class="waves-effect waves-light">
                    
                        <i class="fa fa-bookmark"></i>
                    
                    <span>分类</span>
                </a>

            
        </li>
    
        <li class="hide-on-med-and-down nav-item">

            
                <a href="/archives" class="waves-effect waves-light">
                    
                        <i class="fa fa-archive"></i>
                    
                    <span>归档</span>
                </a>

            
        </li>
    
        <li class="hide-on-med-and-down nav-item">

            
                <a href="/about" class="waves-effect waves-light">
                    
                        <i class="fa fa-user-circle-o"></i>
                    
                    <span>关于</span>
                </a>

            
        </li>
    
        <li class="hide-on-med-and-down nav-item">

            
                <a href="/contact" class="waves-effect waves-light">
                    
                        <i class="fa fa-envelope"></i>
                    
                    <span>留言</span>
                </a>

            
        </li>
    
        <li class="hide-on-med-and-down nav-item">

            
                <a href="/friends" class="waves-effect waves-light">
                    
                        <i class="fa fa-address-book"></i>
                    
                    <span>友链</span>
                </a>

            
        </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
            <img src="/medias/avatars/touxiang2.jpg"
                 class="logo-img circle responsive-img">
        
        <div class="logo-name">JoyTsing</div>
        <div class="logo-desc">
            
                寒冬本来就冷, 还要吵个不停
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
            <li class="m-nav-item">
                
                    <a href="/" class="waves-effect waves-light">
                        
                            <i class="fa fa-fw fa-home"></i>
                        
                        首页
                    </a>
                
            </li>
        
            <li class="m-nav-item">
                
                    <a href="/tags" class="waves-effect waves-light">
                        
                            <i class="fa fa-fw fa-tags"></i>
                        
                        标签
                    </a>
                
            </li>
        
            <li class="m-nav-item">
                
                    <a href="/categories" class="waves-effect waves-light">
                        
                            <i class="fa fa-fw fa-bookmark"></i>
                        
                        分类
                    </a>
                
            </li>
        
            <li class="m-nav-item">
                
                    <a href="/archives" class="waves-effect waves-light">
                        
                            <i class="fa fa-fw fa-archive"></i>
                        
                        归档
                    </a>
                
            </li>
        
            <li class="m-nav-item">
                
                    <a href="/about" class="waves-effect waves-light">
                        
                            <i class="fa fa-fw fa-user-circle-o"></i>
                        
                        关于
                    </a>
                
            </li>
        
            <li class="m-nav-item">
                
                    <a href="/contact" class="waves-effect waves-light">
                        
                            <i class="fa fa-fw fa-envelope"></i>
                        
                        留言
                    </a>
                
            </li>
        
            <li class="m-nav-item">
                
                    <a href="/friends" class="waves-effect waves-light">
                        
                            <i class="fa fa-fw fa-address-book"></i>
                        
                        友链
                    </a>
                
            </li>
        
        
            <li>
                <div class="divider"></div>
            </li>
            <li>
                <a href="https://github.com/JoyTsing" class="waves-effect waves-light" target="_blank">
                    <i class="fa fa-github-square fa-fw"></i>Follow Me
                </a>
            </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #000000;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/JoyTsing" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Follow Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/13.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">计算机病毒原理与防范</h1>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
        <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/UESTC/">
                                    <span class="chip bg-color">UESTC</span>
                                </a>
                            
                                <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92%E5%8E%9F%E7%90%86%E4%B8%8E%E9%98%B2%E8%8C%83/">
                                    <span class="chip bg-color">计算机病毒原理与防范</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                        <div class="post-cate">
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                                <a href="/categories/UESTC/" class="post-category">
                                    UESTC
                                </a>
                            
                        </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                    <div class="post-date info-break-policy">
                        <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                        2021-03-03
                    </div>
                

                
                    <div class="post-date info-break-policy">
                        <i class="fa fa-calendar-check-o fa-fw"></i>更新日期:&nbsp;&nbsp;
                        2023-09-25
                    </div>
                

                
                    <div class="info-break-policy">
                        <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                        5.4k
                    </div>
                

                
                    <div class="info-break-policy">
                        <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                        18 分
                    </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章-概述"></a>第一章-概述</h2><h3 id="计算机病毒的定义"><a href="#计算机病毒的定义" class="headerlink" title="计算机病毒的定义"></a>计算机病毒的定义</h3><p>编制或者在计算机程序中<strong>插入</strong>的破坏计算机功能或者毁坏数据，影响计算机使用，并能自我复制的一组计算机指令或者程序代码。</p>
<h3 id="计算机病毒的本质属性"><a href="#计算机病毒的本质属性" class="headerlink" title="计算机病毒的本质属性"></a>计算机病毒的本质属性</h3><p><strong>人为</strong>的特制<strong>程序</strong>是<strong>任何</strong>计算机病毒的<strong>固有本质属性</strong></p>
<p><strong>程序性</strong>的<strong>客观性</strong>决定了计算机病毒的可防治性和可清除性</p>
<p><strong>人为性</strong>的<strong>主观性</strong>导致计算机病毒各异多变</p>
<h4 id="基本特征-传染性"><a href="#基本特征-传染性" class="headerlink" title="基本特征-传染性"></a>基本特征-传染性</h4><p>传染性是判别一个程序是否为计算机病毒的<code>首要条件</code>,传染性也即指计算机病毒把自身复制到其他程序的能力，把自身的代码强行传染到一切符合其传染条件的程序之上</p>
<h4 id="基本特征-隐蔽性"><a href="#基本特征-隐蔽性" class="headerlink" title="基本特征-隐蔽性"></a>基本特征-隐蔽性</h4><p>传染过程与存在的隐蔽性，用户不知道病毒的存在</p>
<h4 id="基本特征-可触发性"><a href="#基本特征-可触发性" class="headerlink" title="基本特征-可触发性"></a>基本特征-可触发性</h4><p>因某个事件或数值的出现，触发病毒实施感染或攻击破坏即隐藏又保持破坏力</p>
<h4 id="其他特征"><a href="#其他特征" class="headerlink" title="其他特征"></a>其他特征</h4><ul>
<li>欺骗性：欺骗用户触发、激活病毒</li>
<li>非授权性：窃取系统控制权</li>
<li>寄生性：依附于宿主程序</li>
<li>衍生性：病毒变种</li>
<li>持久性：数据恢复困难、病毒清除困难</li>
<li><strong>破坏性</strong>：数据破坏、计算机功能破坏、经济损失</li>
<li><strong>针对性</strong>：特定软件、操作系统、硬件平台（也反映了其程序性的客观事实）</li>
<li><strong>不可预见性</strong>：对未知病毒的预测难度（反病毒软件预防措施和技术手段往往滞后于病毒产生速度）</li>
</ul>
<h3 id="病毒的分类"><a href="#病毒的分类" class="headerlink" title="病毒的分类"></a>病毒的分类</h3><p><img src="/posts/41006/1_1.png" alt></p>
<p><img src="/posts/41006/1_2.png" alt></p>
<h3 id="恶意程序"><a href="#恶意程序" class="headerlink" title="恶意程序"></a>恶意程序</h3><p>未经授权便干扰或破坏计算机系统/网络的程序或代码，早期恶意代码的主要形式是计算机病毒</p>
<h4 id="蠕虫"><a href="#蠕虫" class="headerlink" title="蠕虫"></a>蠕虫</h4><p>独立的可执行程序，不需要寄生在宿主程序中，通过网络分发自己的副本</p>
<p>病毒与蠕虫的区别：</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>病    毒</strong></th>
<th><strong>蠕    虫</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>存在形式</strong></td>
<td><strong>寄生</strong></td>
<td><strong>独立个体</strong></td>
</tr>
<tr>
<td><strong>复制机制</strong></td>
<td><strong>插入到宿主程序</strong>(文件)中</td>
<td><strong>自身的拷贝</strong></td>
</tr>
<tr>
<td><strong>传染机制</strong></td>
<td><strong>宿主程序运行</strong></td>
<td><strong>系统存在漏洞</strong>(Vulnerability)</td>
</tr>
<tr>
<td><strong>搜索机制</strong>(传染目标)</td>
<td>主要是针对<strong>本地文件</strong></td>
<td><strong>主要针对网络上的其它计算机</strong></td>
</tr>
<tr>
<td><strong>触发传染</strong></td>
<td>计算机使用者</td>
<td><strong>程序自身</strong></td>
</tr>
<tr>
<td><strong>影响重点</strong></td>
<td><strong>文件系统</strong></td>
<td><strong>网络性能、系统性能</strong></td>
</tr>
<tr>
<td><strong>计算机使用者角色</strong></td>
<td>病毒传播中的关键环节</td>
<td><strong>无关</strong></td>
</tr>
<tr>
<td><strong>防治措施</strong></td>
<td>从宿主程序中摘除</td>
<td>为系统打补丁(Patch)</td>
</tr>
</tbody></table>
<h3 id="特洛伊木马"><a href="#特洛伊木马" class="headerlink" title="特洛伊木马"></a>特洛伊木马</h3><p>在远程计算机之间建立连接，使得远程计算机能通过网络控制本地计算机的非法程序。</p>
<p>木马系统软件一般由木马配置程序、控制程序和<strong>木马程序(服务端)</strong>三部分组成，其入侵的方式与一般病毒存在区别，而且，自身一般没有传染性。</p>
<h3 id="计算机病毒的危害"><a href="#计算机病毒的危害" class="headerlink" title="计算机病毒的危害"></a>计算机病毒的危害</h3><ul>
<li><p>计算机病毒的蓄意破坏：来自于病毒制造者<strong>目的</strong>，对数据信息的<strong>直接破坏</strong></p>
</li>
<li><p>计算机病毒的偶然性破坏：<strong>自身错误</strong>与不可预见性、<strong>兼容性</strong></p>
</li>
<li><p>计算机病毒的附带性破坏：抢占资源、影响计算机运行</p>
</li>
<li><p>计算机病毒造成的心理及社会的危害：<strong>声誉损失</strong> 、商业风险、心理反应 </p>
</li>
</ul>
<h3 id="计算机病毒的传播途径"><a href="#计算机病毒的传播途径" class="headerlink" title="计算机病毒的传播途径"></a>计算机病毒的传播途径</h3><ul>
<li><p>通过不可移动的计算机<strong>硬件设备</strong>进行传播</p>
</li>
<li><p>通过<strong>移动存储设备</strong>来传播</p>
</li>
<li><p>通过<strong>有线网络系统进行传播</strong></p>
</li>
<li><p>通过<strong>无线通讯系统</strong>传播</p>
</li>
</ul>
<h3 id="计算机病毒的生命周期"><a href="#计算机病毒的生命周期" class="headerlink" title="计算机病毒的生命周期"></a>计算机病毒的生命周期</h3><p>计算机病毒的<strong>产生过程</strong>可分为：</p>
<p>程序设计→传播→潜伏→触发、运行→实施攻击</p>
<p>计算机病毒的<strong>生命周期</strong>：生成开始到完全根治</p>
<ul>
<li>开发期：较短、没有经过严格的测试</li>
<li>传染期：感染流行程序，网络共享，被动到主动</li>
<li>潜伏期：静态潜伏（文件拷贝）和动态潜伏（占据内存）</li>
<li>发作期：触发，实施破坏，取决于编写者意图和编程技术</li>
<li>发现期：被检测隔离，反病毒厂家，病毒通报和描述</li>
<li>消化期：反病毒软件，检测和发现病毒</li>
<li>消亡期：升级杀毒软件，杀毒</li>
</ul>
<p>计算机病毒的产生是必然的，<strong>软硬件脆弱性</strong>是根本原因，<strong>计算机普及</strong> 是必要环境。</p>
<h2 id="第二章-代码初始"><a href="#第二章-代码初始" class="headerlink" title="第二章-代码初始"></a>第二章-代码初始</h2><p>小端机：最低字节放在内存的最低地址，次低字节放内存的次低地址，依次存放。比如，0x12345678放在内存中就是78 56 34 12（最左边为内存低位）</p>
<p>大端机：0x12345678放在内存中就是12 34 56 78</p>
<h3 id="病毒的基本能力和执行特点"><a href="#病毒的基本能力和执行特点" class="headerlink" title="病毒的基本能力和执行特点"></a>病毒的基本能力和执行特点</h3><ul>
<li>执行（最为重要）</li>
<li>潜伏</li>
<li>破坏</li>
<li>传染</li>
</ul>
<p>执行的特点：</p>
<blockquote>
<p>病毒执行并非简单执行自己的指令，它还需要执行被感染对象正常的指令，否则无法潜伏。简单说，在正常指令执行时，需要修改执行流程获得一个执行病毒指令的能力</p>
</blockquote>
<h3 id="JMP指令解析"><a href="#JMP指令解析" class="headerlink" title="JMP指令解析"></a>JMP指令解析</h3><pre><code>地址1        Jmp offset -&gt; Offset=地址3-地址2
地址2        Push eas
    ...
地址3        Mov xxx</code></pre><p>JMP跳转的偏移量是：<strong>目的地址-JMP的下一条指令地址</strong>，同时JMP跳转指令占1个字节，偏移量4个字节，一共5个字节</p>
<h2 id="第三章-文件系统"><a href="#第三章-文件系统" class="headerlink" title="第三章-文件系统"></a>第三章-文件系统</h2><h3 id="硬盘的物理结构"><a href="#硬盘的物理结构" class="headerlink" title="硬盘的物理结构"></a>硬盘的物理结构</h3><p>初级格式化的主要目的：划分成<strong>磁道、扇区和柱面</strong></p>
<p><strong>CHS参数</strong>：磁道/盘片/扇区</p>
<p><strong>INT 13H</strong>：寻址范围为8GB</p>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>文件系统就是组织文件的一种方式，文件管理包括文件生成，删除，目录查询等。下面介绍的FAT12主要用来管理软盘</p>
<p><img src="/posts/41006/1.png" alt></p>
<p>1个FAT有9个扇区，引导扇区1个扇区，根目录区有224条记录（一个记录32字节）</p>
<ul>
<li>数据区中存放用户数据,是文件和子目录数据真正存放的区域</li>
<li>根目录区中存放的是文件目录表,为记录根目录文件项的表，文件项包括文件，目录。通过它可以查找到根目录下的文件和目录信息，比名称，大小，日期等</li>
<li>FAT12为<strong>文件分配表</strong>（FAT（File Allocation Table））：记录已分配的扇区和可用扇区，并通过链表依序记录一个文件占用的扇区,另外一个FAT12为备用的FAT表</li>
<li><strong>引导扇区</strong>（DBR （DOS Boot Record））：记录磁盘和文件系统相关的各种参数，比如扇区大小，一簇的扇区数等</li>
</ul>
<p><strong>引导记录格式</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>偏移</th>
<th>长度</th>
<th>内容</th>
<th>软盘参考值</th>
</tr>
</thead>
<tbody><tr>
<td>BS_jmpBoot</td>
<td>0</td>
<td>3</td>
<td></td>
<td>jmp LABEL_START  nop</td>
</tr>
<tr>
<td>BS_OEMName</td>
<td>3</td>
<td>8</td>
<td>厂商名</td>
<td>‘ForrestY’</td>
</tr>
<tr>
<td>BPB_BytsPerSec</td>
<td>11</td>
<td>2</td>
<td>每扇区字节数</td>
<td>0x200（即十进制512）</td>
</tr>
<tr>
<td>BPB_SecPerClus</td>
<td>13</td>
<td>1</td>
<td>每<a href="http://baike.baidu.com/subview/241650/12503090.htm">簇</a>扇区数</td>
<td>0x01</td>
</tr>
<tr>
<td>BPB_RsvdSecCnt</td>
<td>14</td>
<td>2</td>
<td>Boot记录占用多少扇区</td>
<td>0x01</td>
</tr>
<tr>
<td>BPB_NumFATs</td>
<td>16</td>
<td>1</td>
<td>共有多少FAT表</td>
<td>0x02</td>
</tr>
<tr>
<td>BPB_RootEntCnt</td>
<td>17</td>
<td>2</td>
<td><strong>根目录文件数最大值</strong></td>
<td>0xE0 （224）</td>
</tr>
<tr>
<td>BPB_TotSec16</td>
<td>19</td>
<td>2</td>
<td>扇区总数</td>
<td>0xB40（2880）</td>
</tr>
<tr>
<td>BPB_Media</td>
<td>21</td>
<td>1</td>
<td>介质描述符</td>
<td>0xF0</td>
</tr>
<tr>
<td>BPB_FATSz16</td>
<td>22</td>
<td>2</td>
<td>每FAT扇区数</td>
<td>0x09</td>
</tr>
<tr>
<td>BPB_SecPerTrk</td>
<td>24</td>
<td>2</td>
<td>每磁道扇区数</td>
<td>0x12</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>BPB_NumHeads</th>
<th>26</th>
<th>2</th>
<th>磁头数</th>
<th>0x02</th>
</tr>
</thead>
<tbody><tr>
<td>BPB_HiddSec</td>
<td>28</td>
<td>4</td>
<td>隐藏扇区数</td>
<td>0</td>
</tr>
<tr>
<td>BPB_TotSec32</td>
<td>32</td>
<td>4</td>
<td>如果BPB_TotSec16是0，由这个值记录扇区数</td>
<td>0xB40（2880）</td>
</tr>
<tr>
<td>BS_DrvNum</td>
<td>36</td>
<td>1</td>
<td>中断13的驱动器号</td>
<td>0</td>
</tr>
<tr>
<td>BS_Reserved1</td>
<td>37</td>
<td>1</td>
<td>未使用</td>
<td>0</td>
</tr>
<tr>
<td>BS_BootSig</td>
<td>38</td>
<td>1</td>
<td>扩展引导标记</td>
<td>0x29</td>
</tr>
<tr>
<td>BS_VolD</td>
<td>39</td>
<td>4</td>
<td>卷序列号</td>
<td>0</td>
</tr>
<tr>
<td>BS_VolLab</td>
<td>43</td>
<td>11</td>
<td>卷标</td>
<td>‘OrangeS0.02’</td>
</tr>
<tr>
<td>BS_FileSysType</td>
<td>54</td>
<td>8</td>
<td>文件系统类型</td>
<td>‘FAT12’</td>
</tr>
<tr>
<td>引导代码</td>
<td>62</td>
<td>448</td>
<td>引导代码、数据及其他填充字符等</td>
<td></td>
</tr>
<tr>
<td><strong>结束标志</strong></td>
<td>510</td>
<td>2</td>
<td></td>
<td><strong>0xAA55</strong></td>
</tr>
</tbody></table>
<p>从开始偏移510个字节处有两个字节55 AA代表是引导区，小端机整数表示是0xAA 55</p>
<p>注意到有BS_jmpBoot这个引导记录最开始的JMP指令，反汇编后的机械码为<strong>EB 3C 90</strong>，机器码EB表示JMP，后面1个字节是偏移量，偏移是指从JMP的后条指令开始，到转跳到的指令的差。这里EB 3C表示偏移为60字节（3CH），例如：JMP指令写入内存的地址是0x4011F0，验证一下：0x4011F0 + 2(JMP长2) + 3C= 0x40122E</p>
<h3 id="如何定位一个文件"><a href="#如何定位一个文件" class="headerlink" title="如何定位一个文件"></a>如何定位一个文件</h3><p>文件分配的最小单位是簇，哪怕只有一个字节也会分配一簇，簇由几个扇区组成在引导扇区的引导记录中定义。在FAT12文件系统中，FAT表以3个<strong>半字节</strong>（3*0.5 Byte = 1.5 Byte = 12 bit）来记录一个簇的相关情况，这也是“FAT12“文件系统中命名12的原因。</p>
<p>FAT表的本质是磁盘簇分配情况的数据表示，FAT表中每3个半字节为一个元素，这个元素就代表一个簇，簇号从0开始，这个元素中存放的整数值表示其链接的下一簇的簇号</p>
<h3 id="查找和遍历"><a href="#查找和遍历" class="headerlink" title="查找和遍历"></a>查找和遍历</h3><p>类似于链表的查找，以FFF为结尾，FAT12默认设置引导区占一个扇区，FAT1于其后，同时FAT表开始的3个字节没用于用户文件分配，3字节有2组12bits所以，占用了0,1两个簇号，用户的数据从簇2开始分配。</p>
<p>随后FAT表从头开始按3字节分成一组，但是有一点需要特别注意：</p>
<p><strong>在这3个字节中，用第2字节的低半字节和第1字节形成整数表示一个簇号，用第2字节的高半字节和第3字节形成的整数来表示另一个簇号</strong></p>
<p>由上面学习的内容知道，在FAT表中想要开始遍历就必须知道首簇号，而首簇号位于根目录区域中。</p>
<h3 id="根目录表中的记录格式"><a href="#根目录表中的记录格式" class="headerlink" title="根目录表中的记录格式"></a>根目录表中的记录格式</h3><p>根目录表包含多条记录，每条记录占32字节，其结构如下表所示。目前我们关注<strong>文件名</strong>（查找需要）和<strong>首簇</strong>（遍历需要）</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>偏移</th>
<th>长度</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>DIR_Name</strong></td>
<td><strong>0</strong></td>
<td><strong>0xB　(11)</strong></td>
<td><strong>文件名8字节，扩展名3字节</strong></td>
</tr>
<tr>
<td>DIR_Attr</td>
<td>0xB</td>
<td>1</td>
<td>文件属性</td>
</tr>
<tr>
<td>保留</td>
<td>0xC</td>
<td>10</td>
<td></td>
</tr>
<tr>
<td>DIR_WrtTime</td>
<td>0x16</td>
<td>2</td>
<td>最后修改时间</td>
</tr>
<tr>
<td>DIR_WrtDate</td>
<td>0x18</td>
<td>2</td>
<td>最后修改日期</td>
</tr>
<tr>
<td><strong>DIR_FstClus</strong></td>
<td><strong>0x1A　(26)</strong></td>
<td><strong>2</strong></td>
<td><strong>此条目对应的开始簇号</strong></td>
</tr>
<tr>
<td>DIR_FileSize</td>
<td>0x1C　(28)</td>
<td>4</td>
<td>文件大小</td>
</tr>
</tbody></table>
<ul>
<li><p>文件名字段，在该记录首部偏移0开始，共11字节，其中8个给<strong>文件名</strong>，3个给<strong>扩展名</strong>（不需要记录点号 “.”）</p>
</li>
<li><p><strong>名字</strong>的结束以<strong>空格</strong>表示，即0x20</p>
</li>
</ul>
<h3 id="查找根目录表的算法"><a href="#查找根目录表的算法" class="headerlink" title="查找根目录表的算法"></a>查找根目录表的算法</h3><p>从磁盘0头0道1扇区读出引导区（Boot）512字节，从其中引导记录获取相关信息：<strong>Boot区占用扇区数，FAT表数目，每个FAT表的扇区数，1个扇区的字节数</strong>。</p>
<p>计算根目录区的起始位置为：</p>
<p><strong>[ 1（Boot区扇区数）+2（FAT数目）*9（FAT扇区数）] * 512 = 0x2600</strong></p>
<p>即2600h为根目录区起始位置，从引导记录获取根区记录数，缺省224条，按每条记录32字节读出所有记录。每条记录开始11个字节为文件名，比较文件名匹配则找到记录，从首簇字段（从该记录开始偏移1Ah处）获得首簇号。</p>
<h3 id="系统如何区分卷标项和文件项"><a href="#系统如何区分卷标项和文件项" class="headerlink" title="系统如何区分卷标项和文件项"></a>系统如何区分卷标项和文件项</h3><table>
<thead>
<tr>
<th>名称</th>
<th>偏移</th>
<th>长度</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DIR_Attr</td>
<td>0xB</td>
<td>1</td>
<td>文件属性</td>
</tr>
<tr>
<td><strong>DIR_FstClus</strong></td>
<td>0x1A　(26)</td>
<td>2</td>
<td>此条目对应的开始簇号</td>
</tr>
</tbody></table>
<p>每一条记录，从该记录开始偏移0xB处有个字节指示出文件的类型，对于多级目录来说，则是存放在数据区内，原理和根目录查找目录类似，只不过是多层嵌套，查找到的是另一个目录表。</p>
<p>查找<strong>a:\tem\tem.txt</strong></p>
<p><img src="/posts/41006/2.png" alt></p>
<h3 id="总结文件查找算法"><a href="#总结文件查找算法" class="headerlink" title="总结文件查找算法"></a><strong>总结文件查找算法</strong></h3><ul>
<li><p>STEP1. 根据文件路径的第一项（1），先查看<strong>根目录表</strong> ，是否有匹配的项，如果有，通过对应项的<strong>首簇段（0x1A）</strong> 获取该<strong>子目录表（1）</strong> 的首簇号</p>
</li>
<li><p>STEP2. 通过首簇号和FAT表获得<strong>子目录表（1）</strong> 的全部内容，根据文件路径的第二项（2），遍历子目录表（1），一次偏移32字节用<strong>名字匹配</strong> 的方法查找记录项（2）, 如果找到，则类似STEP1和STEP2继续查找<strong>文件路径中的下一项</strong> ，否则说明找不到，结束</p>
</li>
<li><p>如果在最后一层目录表（路径的倒数第二项，最后一项是文件名）中找到了被查文件的项，从中获取首簇号，即可通过FAT表访问该文件整个相关簇</p>
</li>
</ul>
<h2 id="第四章-硬盘数据结构"><a href="#第四章-硬盘数据结构" class="headerlink" title="第四章-硬盘数据结构"></a>第四章-硬盘数据结构</h2><p>学习完之前有关文件的管理之后，学习有关硬盘的分区信息。</p>
<h3 id="主引导扇区"><a href="#主引导扇区" class="headerlink" title="主引导扇区"></a>主引导扇区</h3><ul>
<li>主引导记录（Master Boot Record, MBR）446字节为<strong>主引导记录</strong></li>
<li>分区表（ Disk Partition Table, DPT）后面存放了一个<strong>分区表</strong></li>
</ul>
<p><strong>相对</strong>扇区数，是相对于引导记录头部的偏移扇区数</p>
<p>主引导扇区中有主引导记录（其中存放了启动时的引导代码）,分区表项, 如何根据分区表项定位到分区入口, 对于放在硬盘头部的MBR和拓展分区与EBR中的计算有所不同.</p>
<p>分区表项的第一个字节表示是否被激活。</p>
<p><img src="/posts/41006/3.png" alt></p>
<h3 id="扩展分区"><a href="#扩展分区" class="headerlink" title="扩展分区"></a>扩展分区</h3><p><strong>虚拟扩展分区</strong>（Extended MBR，即EBR）的目的是为了增加更多的分区,核心想法是形成一个分区链，如图所示的分区中，MBR定义的主分区表本来有4条分区记录，用第一条描述自己分区的信息，用第2条指向下一个分区。下一分区也如此处理，形成链。</p>
<p><img src="/posts/41006/4.png" alt></p>
<p>扩展分区的引导记录没有内容,而主分区开始之前有MBR和保留扇区，主分区的相对扇区相对于MBR，通过MBR和相对扇区就可以定位每一个主分区</p>
<p>注意：</p>
<blockquote>
<p>为了完全兼容MBR的格式，EBR完全复用了引导扇区的格式，即起始446字节给引导记录EBR，但在EBR中，这些内容全为0。同样的，从446偏移开始为分区表，16字节为一项，共4项，后两条无效（但占空间），EBR定义的扇区最后两字节也是结束标识55 AA。主分区表中最后一个有效主分区记录指向的磁盘空间（也叫主扩展分区）将用EBR进行划分，分成N个逻辑盘，形成EBR链。</p>
</blockquote>
<p><img src="/posts/41006/5.png" alt></p>
<p><img src="/posts/41006/6.png" alt></p>
<p>在实际中，则像下图一样：</p>
<p><img src="/posts/41006/7.png" alt></p>
<p>主分区表项的偏移量，就是相对物理盘开始（MBR）的偏移，且这些主分区前面没有EBR，根据偏移得到的直接就是盘区（开始就是该分区的引导扇区和文件系统），除了主分区表项中的最后一项偏移指向的是扩展分区的开始处</p>
<p>扩展分区表项的偏移量，是相对于包含该分区表的扩展区开始处而言（扩展分区开始处为其EBR）</p>
<p>在扩展分区的分区表中，第一项的偏移指向的是盘区，第二项的偏移指向的是下一个扩展分区开始处（也就是下一个扩展分区的EBR）</p>
<h3 id="硬盘的引导过程"><a href="#硬盘的引导过程" class="headerlink" title="硬盘的引导过程"></a>硬盘的引导过程</h3><ul>
<li><p>开机加电自检：开机，CPU跳到内存FFFF:0000处，由该处的一条JMP指令跳到BIOS的自检程序（POST），自检通过后，加载引导程序（与操作系统无关的MBR，按用户在BIOS中的指定顺序，硬盘、软盘、光驱或U盘等</p>
</li>
<li><p>读主引导扇区：将主引导扇区MBR读入到内存的0000:7C00，扫描主分区表，搜索激活分区，分区表项第一个字节为0x80表示激活分区</p>
</li>
<li><p>读激活分区引导扇区 ：如果有多个激活分区或没有，报错结束。否则读取激活分区引导扇区到0000:7c00</p>
</li>
<li><p>操作系统引导代码引导系统并读取操作系统初始化文件</p>
</li>
</ul>
<p>注意的是MBR中硬盘数据结构是与操作系统无关，操作系统相关的引导代码在激活分区的引导扇区，而MBR的引导程序选择激活分区。</p>
<h2 id="第五章-Dos下的病毒寄生"><a href="#第五章-Dos下的病毒寄生" class="headerlink" title="第五章-Dos下的病毒寄生"></a>第五章-Dos下的病毒寄生</h2><h3 id="病毒的关键问题"><a href="#病毒的关键问题" class="headerlink" title="病毒的关键问题"></a>病毒的关键问题</h3><ul>
<li>寄生，没有寄生就没有执行和传播的可能</li>
<li>执行，如果只是文件，没有得以执行的机会，则永远都无法去破坏和感染</li>
<li>反检查，包括隐藏病毒等</li>
</ul>
<h3 id="寄生机制与执行机制"><a href="#寄生机制与执行机制" class="headerlink" title="寄生机制与执行机制"></a>寄生机制与执行机制</h3><ul>
<li><p>文件型病毒</p>
<ul>
<li>头插入</li>
<li>尾插入</li>
<li>逆插入</li>
</ul>
</li>
<li><p>直接面向文件系统的病毒</p>
<ul>
<li>引导型病毒</li>
</ul>
</li>
<li><p>执行机制</p>
<ul>
<li>对于com文件，头、尾和逆插入寄生都相当于入口点修改，病毒可以执行，就不做另行说明</li>
<li>中断替换</li>
</ul>
</li>
</ul>
<h3 id="DOS下的内存"><a href="#DOS下的内存" class="headerlink" title="DOS下的内存"></a>DOS下的内存</h3><p>保护模式带来的最大优点不是单纯的扩大了内存寻址范围，而是对内存寻址从机制上提供了保护，将系统的执行空间按权限进行了划分，防止应用程序非法访问其他应用程序的地址空间(任务间保护)，防止应用程序非法访问操作系统地址空间(系统保护)。</p>
<h3 id="DOS下四种基本可执行文件"><a href="#DOS下四种基本可执行文件" class="headerlink" title="DOS下四种基本可执行文件"></a>DOS下四种基本可执行文件</h3><ul>
<li>批处理文件，以.BAT结尾的文件</li>
<li>设备驱动文件，是以.SYS结尾的文件，如CONFIG.SYS</li>
<li>COM文件，是以.COM结尾的纯代码文件。没有文件头部分，缺省情况下总是从0x100H处开始执行，没有重定位项，所有代码和数据必须控制在64K以内</li>
<li>EXE文件，是以.EXE结尾的文件。文件以英文字母“MZ”开头，有一个文件头，用来指出每个段的定义等信息，EXE文件摆脱了代码大小最多不能超过64K的限制</li>
</ul>
<h3 id="COM文件"><a href="#COM文件" class="headerlink" title="COM文件"></a>COM文件</h3><p>COM文件不存在文件头，由机器码和数据的集合组成，COM文件就是直接读到内存，文件会被加载器加载到段内位置。</p>
<h3 id="头插入"><a href="#头插入" class="headerlink" title="头插入"></a>头插入</h3><p>头插入病毒是三种病毒之中比较直接的方式</p>
<p>选择直接插入的话需要注意的是一般函数调用完成后会有ret指令，将执行权交还给DOS，因此后续的代码没有执行就返回了。需要通过JMP指令跳转，不能够直接将RET指令去除，去除的话就将程序段和数据段混合，同时需要注意跳转指令的地址。</p>
<blockquote>
<p>源码中的地址信息在编译后会直接被预加载地址代替，从而形成可执行文件的机器码。但因为病毒感染占据了原先com文件的头部，所以原来的机器码后移了这个改动加载器是完全不知道的，它只会把文件加载到预先处，从而导致原先部分的机器码在加载后的实际内存位置后移了，后移长度就是病毒程序的机器码长度</p>
</blockquote>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>纠正这个问题一般依靠重定位，但COM文件只是简单地被加载到段内原先位置处，本身是没有重定位需要的相关机制，且我们想通过编程来更正错误的地址也是不太可能的。解决方法其实很简单，将原先挤占的程序挪回去原先的位置，</p>
<p>要拷贝原来的正常程序需要知道它的大小，采取手动的方法，在病毒程序的最后加上两字节的数据存储正常程序的大小，生成感染文件后再在该两字节的位置填入正常程序的大小。</p>
<p>需要注意的是，如果被拷贝文件过大，会存在覆盖的问题：拷贝指令本身所在的内存部分就是被覆盖的部分。当某次拷贝覆盖了拷贝指令所占的那个字节时，拷贝指令本身就被破坏了，当然它就不能再完成拷贝。那么如何解决这个问题？</p>
<p>必须让病毒的执行指令本身不会在原文件的拷贝过程中被自我覆盖，最好的方法就是把这些指令放到一个肯定不会被覆盖的安全区域哪里是安全的区域，这里，我们可以选择感染程序最后面的内存区域,也就是原先程序段之外的位置。</p>
<h3 id="尾部寄生"><a href="#尾部寄生" class="headerlink" title="尾部寄生"></a>尾部寄生</h3><p>在正常代码头部，将原先正常的头部代码修改为jmp覆盖的字节，然后将病毒代码放到正常代码之后，同时注意将被覆盖的正常代码放在病毒代码的后面，确保先执行病毒代码再执行jmp覆盖的字节。但同样具有加载偏差的问题，因此需要使用<code>重定位技术</code>。</p>
<p>只需要获得任意一条指令的加载偏差就可以知道整个程序的实际偏差地址，也就是将运行时的地址值和编译时的地址值相减就行了，因此关键在于获得IP指向指令的地址值。获取IP寄存器的地址有一个技巧：</p>
<blockquote>
<p>Call指令会将下一条指令的IP压栈！然后再跳转执行</p>
<pre class="line-numbers language-asm"><code class="language-asm">call here <-Call指令的下一条指令是pop ax，call执行时，首先会把pop ax指令的IP（即pop ax这条指令的实际地址）压栈，然后根据相对偏移跳到标号here处
here:
pop ax <-标号here处就是pop ax指令，执行这条出栈指令会把栈中数据放入ax中，也就是pop ax指令的IP，我们巧妙地利用栈获得了IP的值
sub ax, here <-Sub语句中的标号here在编译时就生成了地址，但是是预期地址，实际地址-预期地址，ax中放的就是加载偏差了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</blockquote>
<p>计算出pop的实际地址和预期地址here的差。这样只要将编译期要用的的地址，比如字串的首址加上ax就是字串实际地址了。</p>
<h4 id="JMP指令长度和格式"><a href="#JMP指令长度和格式" class="headerlink" title="JMP指令长度和格式"></a>JMP指令长度和格式</h4><p>因为JMP要覆盖头部，所以必须分配对应长度的空间在病毒的数据区，用以保存覆盖的内容，在DOS中<code>JMP 地址</code>指令只有两个字节，如果偏移量过长的话则有多个字节，DOS下一般为小端机顺序。</p>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ul>
<li>构造一个打印的正常程序normal.com</li>
<li>构造一个将粘贴到normal尾部的病毒程序endvirus.com</li>
<li>用DOS的拷贝命令:用<code>copy /b normal.com + virus.com infected.com完成手动感染</code>, 将两个编译好的程序粘起来，手动完成寄生</li>
<li>将normal开始的3字节保存到virus.com的数据部分，用UE将normal开始的3字节手动修改为跳转指令，该JMP的机器码格式是E9 XX XX，其中XX XX是2字节，代表偏移这条手动插入的JMP将跳到virus.com处。偏移量如何计算？就是normal.com的size – 3，其中3是因为偏移量从JMP下一条指令开始算，JMP是3字节，所以减3</li>
<li>virus.com部分指令执行后，将恢复程序开始被覆盖的3字节，还原现场，并JMP到程序开始，将执行权限交给normal.com部分</li>
</ul>
<h4 id="手动完成的工作"><a href="#手动完成的工作" class="headerlink" title="手动完成的工作"></a>手动完成的工作</h4><ol>
<li>寄生感染</li>
</ol>
<p>用copy /b normal.com + virus.com infected.com完成手动感染</p>
<ol start="2">
<li>填写OverridedCode字段，保存将被覆盖的头3字节</li>
</ol>
<p>用UE打开Infected.com</p>
<p> 将文件头3个字节内容填入文件<strong>倒数第5个字节开始处</strong></p>
<ol start="3">
<li>填写InfectedFileSize字段，保存被感染文件本身的大小</li>
</ol>
<p>查看normal.com文件大小为26字节，即0x001A，该值应该保存到最后两字节，根据小端机原理，我们将倒数第2个字节(InfectedFileSize)修改为0x1A</p>
<ol start="4">
<li>修改第一条JMP指令</li>
</ol>
<p>normal.com有26字节，第一条JMP指令自身占3字节，那么跳到virus部分的偏移量是26-3=23，即0x17，那么第一条JMP指令为E9 17 00，修改程序头部3字节为E9 17 00</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>自定位是针对病毒本身出现了加载偏差，而解决原文件加载偏差时，我们是将原文件通过拷贝回预加载地址来解决的。</p>
<h3 id="逆插入感染"><a href="#逆插入感染" class="headerlink" title="逆插入感染"></a>逆插入感染</h3><p>逆插入感染，实际就是一部分病毒代码在原程序的头部，一部分在尾部，将整个原来的程序给包裹起来。因为即在病毒头部也在病毒尾部，因此需要将程序后移，头粘贴尾粘贴都要使用到。</p>
<p><img src="/posts/41006/8.png" alt></p>
<p>与之前手工设计不同的是，需要将感染寄生的代码放在病毒代码中，这段完成感染寄生的代码需要完成：</p>
<ul>
<li>把正常程序向后拷贝头病毒的长度</li>
<li>把头病毒部分拷贝到前面</li>
<li>把尾病毒部分拷贝到后面</li>
</ul>
<p><img src="/posts/41006/9.png" alt></p>
<h4 id="感染代码部分"><a href="#感染代码部分" class="headerlink" title="感染代码部分"></a>感染代码部分</h4><p>(1)获取原文件大小供后面写入使用 </p>
<p>(2)原文件扩容,增加头病毒部分长度的字节,在原文件的尾部写字节完成</p>
<p>(3)原文件向后拷贝头病毒长度部分长度,腾出头部的空间给头病毒,同时要从尾部到头部拷贝,不然会有数据覆盖。</p>
<p>(4)将头病毒部分写入头部</p>
<p>(5)将尾病毒部分写入尾部,直接写即可</p>
<h4 id="头病毒部分"><a href="#头病毒部分" class="headerlink" title="头病毒部分"></a>头病毒部分</h4><p>头病毒部分因为存在加载偏差,需要重定位,并且需要为尾病毒拷贝设置参数.</p>
<h4 id="尾病毒部分"><a href="#尾病毒部分" class="headerlink" title="尾病毒部分"></a>尾病毒部分</h4><p>重定位有关的代码在头病毒部分已经设置完成,因此不需要额外设置.</p>
<h2 id="第六章-函数调用"><a href="#第六章-函数调用" class="headerlink" title="第六章-函数调用"></a>第六章-函数调用</h2><p>栈（Stack）是一种用来存储函数调用时的临时信息的结构，如函数调用所传递的参数、函数的返回地址、函数的局部变量等。在程序运行时由编译器在需要的时候分配，在不需要的时候自动清除。</p>
<h3 id="函数调用对栈的影响"><a href="#函数调用对栈的影响" class="headerlink" title="函数调用对栈的影响"></a>函数调用对栈的影响</h3><ul>
<li><p>首先把指令寄存器EIP（它指向当前CPU将要运行的下一条指令的地址）中的内容压入栈，作为程序的返回地址（一般用RET表示）；</p>
</li>
<li><p>之后放入栈的是基址寄存器EBP（保持之前的值，调用后恢复）；</p>
</li>
<li><p>然后把EBP设为栈顶指针ESP，作为新的基地址；</p>
</li>
<li><p>最后为动态存储分配留出一定空间，即把ESP减去一个适当的数值</p>
</li>
</ul>
<p>调用函数时,CALL指令干了两件事情,一件事情是将返回地址入栈,另外一件事情是JMP跳转至调用被函数.  在使用call指令前,需要将实参入栈。</p>
<p><img src="/posts/41006/10.png" alt></p>
<p>栈的顶部地址存放在ESP寄存器中，而栈的大小变化是以4字节为单位（32位机），因此我们只需要做如下计算就可以访问存储参数2的栈单元，例如 mov eax, [esp + cell*4]。但是之后的函数体如果使用了局部变量进行压栈，那么就无法正确访问参数。因此才需要在call之后先把EBP中的内容压栈，ESP放入到EBP中，此时EBP和ESP同样都是指向原EBP的位置。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>只要在一个函数的开始部分执行:</p>
<pre class="line-numbers language-asm"><code class="language-asm"> push ebp;
 mov ebp, esp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>之后相对ebp 进行正向偏移就可以访问它的主调函数传入的参数了</p>
<h3 id="局部变量的访问"><a href="#局部变量的访问" class="headerlink" title="局部变量的访问"></a>局部变量的访问</h3><p>栈布局如之前图所示，因此局部变量分配在哪，如何访问？因为栈是由高地址向低地址增长，因此如何低地址部分就为局部变量的存储位置，与访问实参相同，都是通过ebp偏移访问。</p>
<p>可以简单记作：在使用了EBP寻址的函数中，EBP+偏移量就是参数的地址，EBP-偏移量就是局部变量的地址</p>
<h3 id="函数返回"><a href="#函数返回" class="headerlink" title="函数返回"></a>函数返回</h3><p>通过调用ret指令，将当前栈顶存放的内容作为返回的地址，而call的时候，就将返回地址存入栈了。</p>
<p>而被调函数的ret语句进行了如下操作：</p>
<p>将返回地址从栈中弹出，并放入EIP寄存器。所以每个被调函数的结尾处都是一句ret，这是函数的返回地址，那么函数返回值如何传递？首先调用ret后，EBP已经还原，对于局部变量来说无法通过EBP-偏移量来访问。</p>
<p>对于被调函数来说，则是将局部变量放入eax或者edx这种通用寄存器中，而对于调用者来说，则是把对应通用寄存器中的值放入到其对应的局部变量中。</p>
<p>对于返回值过多或者过大（如结构体）寄存器无法存储怎么办？解决办法即传地址即可。但是需要注意的是，如果EAX存了返回值，那么调用结束后进行请栈，EAX中存储的地址在逻辑上已经无效了。因此需要分配一段内存来存储这个返回值。这段空间就是在主调函数call背调函数之前完成。</p>
<p><img src="/posts/41006/11.png" alt></p>
<p>然后，当被调函数传递返回值时：</p>
<p>（1）通过[EBP+偏移]获得这个返回值的存放位置</p>
<p>（2）把返回值写入到这个内存</p>
<p>（3）把返回值的地址写入到EAX，mov eax, [ebp+偏移]</p>
<p><img src="/posts/41006/12.png" alt></p>
<h3 id="栈清除"><a href="#栈清除" class="headerlink" title="栈清除"></a>栈清除</h3><p>平衡栈，函数返回需要清除参数传递消耗的栈空间，参数传递使用了栈空间，那么函数完成了工作就不需要这些空间了，必须清除。清除栈上的空间很简单，只需要将ESP寄存器向反方向移动就可以了。清栈的工作可以由被调函数完成，也可以由主调函数清除。</p>
<h4 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h4><p>即分配的临时变量空间不足以容下临时变量，导致覆盖了堆栈的高位元素，EBP，RET这些指令和数据被覆盖，将溢出的数据视为了指令，出现了错误。</p>
<h2 id="第七章-DOS下的引导-中断"><a href="#第七章-DOS下的引导-中断" class="headerlink" title="第七章-DOS下的引导+中断"></a>第七章-DOS下的引导+中断</h2><p>接下来学习面向文件系统的病毒：</p>
<h3 id="引导型病毒"><a href="#引导型病毒" class="headerlink" title="引导型病毒"></a>引导型病毒</h3><p>引导型病毒感染引导区，替换引导区原始的引导代码，从而获得执行。之后还原被修改的引导区，并将执行权限交给原来的引导代码，从而保持正常的工作。</p>
<p>接下来学习的引导型病毒是面向软盘上引导区的，软盘和硬盘所不同的是，硬盘分区（激活分区）的起始位置需要访问所对应的分区表项，找到分区表项，才能知道自己分区从哪里开始等信息，随后才能找到引导扇区的引导代码</p>
<h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><p>病毒感染时替换0头0道1扇区（512个字节），并将原引导扇区内容保存到用户数据区第一个扇区，也即簇2。病毒执行完打印字串的动作后，从簇2对应扇区读出原引导扇区内容，将其恢复到内存7c00h处，并跳到7c00h将执行权限交给原来的引导程序</p>
<p>插入被感染软盘，启动虚拟机设置为软盘引导，将先打印病毒的消息，然后进入原来的引导程序（原引导程序将打印非系统盘）</p>
<h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><p><strong>执行过程：</strong>病毒先把自己加载到7C00h，然后又把原引导程序拷贝到7C00h，这个过程会出现什么问题？就是前面遇见的<strong>自我覆盖</strong>问题，所以需要将病毒中执行拷贝的指令段移出被覆盖的区域。我们可以将它后移一个扇区7e00h处</p>
<p><strong>感染过程：</strong>感染会将原引导扇区的内容一直放到簇2，如何避免后续使用占用簇2，破坏了病毒的逻辑？可以修改FAT1和FAT2表，将簇2的项改成不可使用，如果改为已占用FFF，但却没有对应的目录项，是可疑的，因此，可以改为坏簇FF7，从而防止别人使用它。这些感染，为了简单，没有采用汇编访问硬盘的方式，而是采用C语言来直接修改软盘文件。</p>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul>
<li>复位磁盘系统</li>
</ul>
<pre><code>Xor ah, ah        ;ah=0为磁盘复位
int 13h            ;13h为磁盘中断</code></pre><p>读指定从磁头，道，扇区起始，n个扇区到内存缓冲</p>
<p>AH = 02h是读扇区功能号</p>
<p>AL = 将读入多少个扇区</p>
<p>CL = 起始扇区号</p>
<p>CH = 磁道</p>
<p>DH = 磁头</p>
<p>DL = 磁盘，0代表a盘</p>
<p><strong>ES:BX = 读缓冲的地址，一般只填写BX</strong></p>
<pre><code>Mov ah, 02
Mov al, 5        ;读5个扇区
Mov cl, 1        ;从1扇区开始
Mov ch, 0    ;读0道
Mov dh，0    ;读0头
Mov dl, 0        ;读a盘
Mov bx,7c00h    ;读到7c00h处
int 13h</code></pre><p>Int 13h采用的是CHS的硬盘寻址方式，而我们习惯上采用绝对扇区号为0,1,2,3,…的线性方式。</p>
<h4 id="绝对扇区号如何转换为磁头-道-扇区号"><a href="#绝对扇区号如何转换为磁头-道-扇区号" class="headerlink" title="绝对扇区号如何转换为磁头/道/扇区号"></a>绝对扇区号如何转换为磁头/道/扇区号</h4><p>软盘的扇区磁头道一个道18个扇区。</p>
<ul>
<li>道内扇区号（从1开始计数）：给定绝对扇区号，除以18（软盘一道有18个扇区），则<strong>余数+1是道内扇区号</strong> （道内扇区从1开始），<strong>商为N则N+1为绝对道</strong>（比如，绝对扇区19，商1，余数1，道内扇区2，绝对道2）</li>
<li><strong>磁道</strong>(从0开始计数)：不同头的相同道是连续存放的，假定磁头数目为m（m=2），则<strong>N/m去掉小数为磁道，也即对应的磁道号</strong>。软盘m=2，即N右移一位是磁道号（<strong>N &gt;&gt;1</strong>）</li>
<li><strong>磁头</strong>：对于软盘，有两个头，因为绝对道=N+1。当绝对道为奇，N为偶，对应头0当绝对道为偶，N为奇，对应头1。绝对道6（N=5）对应头1因此，采用运算<strong>N &amp; 1</strong>获得磁头号。N为奇数 and 1 = 1，N为偶数 and 1 = 0。</li>
</ul>
<blockquote>
<p>绝对扇区号/18 得到余数和商N</p>
<p>扇区号：余数+1，磁道：N&gt;&gt;1，磁头：N &amp; 1</p>
</blockquote>
<p><img src="/posts/41006/13.png" alt></p>
<h3 id="执行部分程序设计"><a href="#执行部分程序设计" class="headerlink" title="执行部分程序设计"></a>执行部分程序设计</h3><p><img src="/posts/41006/14.png" alt></p>
<p>执行的时候发现存在引导原先系统盘失败的问题。病毒把引导区全部覆盖了，导致DOS无法识别a盘。在引导扇区，其实还有很多重要的引导记录（包括FAT有多少扇区，磁盘的介质类型等），因为病毒只是简单地覆盖了整个扇区，从而破坏了这些引导记录，导致DOS无法识别盘。</p>
<p>因此只要保留引导记录即可，引导扇区的头3个字节吗？是一条JMP指令和一个NOP，它会跳过引导记录，跳到引导程序处，因此，我们的病毒指令可以只覆盖引导记录后面的部分。</p>
<p>同样的，在加载时它实际加载的地址是引导记录，不是指定的地址，因此加载的位置与实际有偏差，需要使用到重定位。</p>
<ul>
<li><p>解决1：写自定位代码</p>
</li>
<li><p>解决2：让病毒代码前面加入偏移</p>
</li>
</ul>
<p>为了真正执行的病毒代码不发生加载偏差，在病毒指令之前加入了填充字节（字节数为引导记录占用的字节数），需要定位到引导记录后才拷贝，并且从写入时从引导记录后开始复制，复制长度减少了引导记录的长度（即仅仅复制病毒执行部分的长度）。修改后结果，在非引导下，可以正常识别被感染的软盘了。</p>
<h3 id="中断替换"><a href="#中断替换" class="headerlink" title="中断替换"></a>中断替换</h3><h4 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h4><p>中断引发后，就会去调用一段处理程序，叫<strong>中断处理程序</strong>（<strong>例程</strong>），系统找到中断处理程序的<strong>入口地址</strong>，从而执行中断，系统通过<code>中断向量表</code>找到中断处理程序的入口地址，中断向量表存放在内存的最低处，即00:00处，每4个字节为1个项，这个作为索引的项就是<code>中断向量号</code>， 其中存放一个中断处理程序的入口地址，高2字节是段地址，低2字节是段内偏移。</p>
<p>一个中断触发指令<code>int xxh</code>，其中的xx就是中断向量号，4 * xx就是中断xx的入口地址在中断向量表中存放的位置。比如int 10h其入口地址就存放在中断向量表中的4*10h = 40h的位置。</p>
<h4 id="非驻留式中断向量修改"><a href="#非驻留式中断向量修改" class="headerlink" title="非驻留式中断向量修改"></a>非驻留式中断向量修改</h4><p>驻留程序就是一直在内存中不退出，系统的<code>中断处理程序</code>要为所有程序服务，所以它的特点就是不退出一直驻留在内存中。</p>
<p>病毒为了获得执行，会修改<code>中断处理程序的入口地址</code>（即修改中断向量表）指向病毒提供的一段程序，这样，只要调用相应的中断，就会去执行这段程序。但是，这段病毒程序必须也是驻留程序，否则病毒结束后，内存回收，这段程序也不在了，导致中断向量表指向无效。因此，在非驻留式的中断替换中，我们还需要在病毒程序调用后恢复中断向量表。</p>
<p><img src="/posts/41006/15.png" alt></p>
<p>结合之前，段寄存器和中断向量表是在不同的段的。段寄存器需要根据实际访问情况变化，先从低2字节处取出中断程序的<strong>段内偏移</strong> ，约定放在AX寄存器中，再放到数据区的Offset处，再从高2字节处取出中断程序的<strong>段地址</strong>，约定放在CX寄存器中，再放到数据区Seg处。</p>
<p>病毒需要由自己段跳到原中断向量程序所在的段。要跨段跳转，就要采用JMP XX:YY的形式，但是JMP CX:AX的语法是不支持的，即JMP XX:YY的指令不支持两个间接性，XXYY总有一个是立即数，而程序里面Seg和Offset都不是立即数，怎么解决？我们可以先采用两个立即数来确定JMP指令的形式（比如JMP 00:00），然后我们再来定位到JMP指令的机器码，进行按字节的细粒度修改。</p>
<p><img src="/posts/41006/16.png" alt></p>
<h2 id="第八章-链式病毒"><a href="#第八章-链式病毒" class="headerlink" title="第八章-链式病毒"></a>第八章-链式病毒</h2><p>链式病毒只保留一份病毒拷贝，利用文件目录项，将受感染文件的头簇指向病毒。</p>
<p>复习之前获取文件的内容知识</p>
<p><img src="/posts/41006/17.png" alt></p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><strong>感染过程：</strong></p>
<ol>
<li><p>如首次感染，将病毒保存在某个空闲扇区</p>
</li>
<li><p>将被感染文件（COM文件）首簇存目录项保留段</p>
</li>
<li><p>修改首簇号指向病毒的首簇</p>
</li>
</ol>
<p><strong>执行过程：</strong></p>
<ol>
<li><p>执行被感染文件则启动病毒，加载的是病毒的首簇，并执行</p>
</li>
<li><p>病毒获取当前执行程序的名字，获取对应目录项。从其中保留字段获取原文件首簇号，并遍历FAT簇链加载它们。</p>
</li>
<li><p>跳到加载的原文件内存中执行</p>
</li>
</ol>
<h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><p><strong>一、感染部分</strong></p>
<ul>
<li>被感染文件的真实起始扇区号写到<code>目录表项的保留区</code>（目录项的保留区从目录项头第13个字节即偏移0ch开始，共10字节）</li>
<li>修改被感染文件的目录项的<code>起始扇区字段</code>指向病毒文件的首簇</li>
<li>目录项中的<code>文件大小字段</code>也要修改成病毒的真实大小，这样才能保证病毒能被完整加载</li>
<li>将原来病毒文件的目录项全部32字节改为0，这样从外部看就不存在这个病毒文件，也没有对应的目录项了</li>
</ul>
<p><strong>二、执行部分</strong></p>
<ul>
<li><p>病毒运行后，先获取被<code>感染程序的名字</code></p>
</li>
<li><p>然后从根目录寻找<code>被感染程序的目录项</code></p>
</li>
<li><p>找到后从该目录项的保留区获取<code>被感染程序的首簇号</code></p>
</li>
<li><p>找到被感染程序所在簇（即扇区），加载该扇区到内存</p>
<blockquote>
<p>因为被感染文件是COM文件，将其加载到内存100h处，并将执行权交还给被感染文件</p>
<p>注意的细节：当把原文件加载到100h时，会产生<code>自我覆盖</code>的问题，和头感染相似，因此，病毒代码需要把执行拷贝功能的代码段移到一个安全区域（即不会被覆盖的区域）。因为本病毒是针对被感染文件大小 &lt; 1扇区的文件，因此，只需要移动到100h（加载地址） + 200h（1个扇区大小）的位置即可（即300h）</p>
</blockquote>
</li>
</ul>
<p><img src="/posts/41006/18.png" alt></p>
<h3 id="如何获取执行文件名"><a href="#如何获取执行文件名" class="headerlink" title="如何获取执行文件名"></a>如何获取执行文件名</h3><p>原理：</p>
<p>从COM文件的DS:2c处获得<strong>环境块首址的段地址</strong>，环境块就在<strong>段地址：0000</strong> 处。</p>
<p>环境块内容：PATH=……COMSPEC=C:\COMMAND.COM\0….0 0 xxxx。环境块开始是PATH等0字符结尾的串，最后是两个00字符。然后有两个字节，可能是数目，之后就是执行程序的名字。</p>
<h2 id="第九章-Win病毒-虚拟地址"><a href="#第九章-Win病毒-虚拟地址" class="headerlink" title="第九章-Win病毒-虚拟地址"></a>第九章-Win病毒-虚拟地址</h2><h3 id="动态链接库DLL"><a href="#动态链接库DLL" class="headerlink" title="动态链接库DLL"></a>动态链接库DLL</h3><p>动态链接库（Dynamic Link Libraries）为模块化应用程序提供了一种方式，使得<strong>更新和重用</strong>程序更加方便。</p>
<p>1）动态链接库是应用程序的一部分，作为<strong>模块</strong>被进程加载到<strong>自己的空间地址</strong></p>
<p>2）动态链接库在程序编译时并不会被插入到可执行文件中，在程序运行时整个库的代码才会调入内存，这就是所谓的“动态链接”</p>
<h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><blockquote>
<p>Windows系统下程序是如何被加载执行的？</p>
</blockquote>
<p>而执行首先需要加载到内存，这又涉及到<strong>保护模式下内存管理</strong>的问题。下面我们将先学习<strong>内存管理和程序加载的相关机制</strong></p>
<h4 id="Windows内存管理和程序加载"><a href="#Windows内存管理和程序加载" class="headerlink" title="Windows内存管理和程序加载"></a>Windows内存管理和程序加载</h4><ul>
<li><p>DOS的内存管理，是实模式，我们可以随意改动甚至系统的内存（比如修改中断向量表）</p>
</li>
<li><p>Windows是工作在x86的保护模式。每个进程都有自己<strong>独立的线性地址空间</strong>（0-4GB，32位CPU的寻址能力为2^32=4GB），互不干扰，这4GB空间会按某个固定的大小（如4KB）分成N个页</p>
</li>
<li><p>同时，内存又分为<strong>用户空间</strong>和<strong>内核空间</strong>，用户空间的代码（我们编写的exe）无法直接访问内核空间内存的。这些限制让我们无法像DOS那样随便涂改内存了</p>
</li>
<li><p>保护模式最大优点是对内存寻址从机制上提供了保护，将系统的执行空间按权限进行了划分，防止应用程序非法访问其他应用程序的地址空间(<strong>任务间保护</strong>)，防止应用程序非法访问操作系统地址空间(<strong>系统保护</strong>)。</p>
</li>
</ul>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><ul>
<li><p>在Windows系统下，现在是保护模式，我们看见的内存地址，是逻辑地址，并非真正的物理地址。实模式下，看见的内存地址就是真实的物理地址。</p>
</li>
<li><p>同一逻辑地址的值对应不同物理上的内存地址正是保护模式的能力。</p>
</li>
<li><p>虽然逻辑地址相同，但具有不同的映射对应，从而使得大家的物理地址各不相同，但是却隐藏了真正的物理地址，起到保护作用。</p>
</li>
</ul>
<h3 id="虚拟地址转换过程"><a href="#虚拟地址转换过程" class="headerlink" title="虚拟地址转换过程"></a>虚拟地址转换过程</h3><p>32位虚拟地址分成3部分(详情请见操作系统)：</p>
<blockquote>
<p>CR3寄存器给出<strong>页目录地址</strong></p>
<p>CR3寄存器: </p>
<ul>
<li><p>PDE 页表目录：每一项4个字节，保存了页表的地址</p>
</li>
<li><p>PTE 页表，里面包含每一页的物理地址和页属性</p>
</li>
</ul>
<p>在分页系统中，为每个进程配置了一张页表)</p>
<p>前面10位用于在页目录中查找<strong>页表地址</strong></p>
<p>中间10位用于在页表中查找<strong>页表项</strong></p>
<p>后面12位给出相对页表项地址的<strong>偏移</strong></p>
</blockquote>
<h3 id="PE如何解决COM加载的缺点"><a href="#PE如何解决COM加载的缺点" class="headerlink" title="PE如何解决COM加载的缺点"></a>PE如何解决COM加载的缺点</h3><ul>
<li>DLL模块加载的真实内存地址不可能是相同的，相同则产生覆盖。这和COM死板的约定加载到100h不同，既然这个加载地址不是固定的了，那么可执行程序应该有地方存储了<strong>约定的加载地址</strong></li>
<li>COM约定了加载的地方就是程序开始执行的地方（100h必然是第一条指令），但这个也太死板（想像一下我们将子函数写在main函数之前），所以我们可能需要在执行程序中存储<strong>真正代码开始的地方</strong>（即存储第一条指令到头部的偏移即可）</li>
<li>如果确实加载不到约定地址，而代码自身又不具有自定位代码（很不方便），那么我们可以需要一种重定位机制，这又可能需要借助一种新的数据结构，比如<strong>重定位表</strong></li>
<li>这些都导致了执行程序需要一种格式来描述信息，除了指令和数据外，还应该有相应的格式或结构来存储上面这些东西</li>
</ul>
<h2 id="第十章-PE结构和末节寄生"><a href="#第十章-PE结构和末节寄生" class="headerlink" title="第十章-PE结构和末节寄生"></a>第十章-PE结构和末节寄生</h2><p>在Win32位平台可执行文件命名为可移植的可执行文件(Portable Executable File)，该文件的格式就是PE格式</p>
<p><img src="/posts/41006/19.png" alt></p>
<h3 id="映像"><a href="#映像" class="headerlink" title="映像"></a>映像</h3><blockquote>
<p>PE文件的加载要完成<code>虚拟地址（内存）</code>和<code>PE文件（硬盘）</code>之间的映射关系，所以又被称为映像文件。当真正执行某个内存页中的指令或访问某一个页的数据时，这个页面才会真正读入内存。</p>
</blockquote>
<p>在学习PE文件的时候，一定要区分<code>文件位置</code>和<code>虚拟地址</code>的概念，而在内存定位时，除了虚拟地址（Virtual Address，VA）的概念，还有<code>相对虚拟地址（RVA）</code>的重要概念</p>
<h3 id="RVA-相对虚拟地址（Relative-Virtual-Addresses）"><a href="#RVA-相对虚拟地址（Relative-Virtual-Addresses）" class="headerlink" title="RVA-相对虚拟地址（Relative Virtual Addresses）"></a>RVA-相对虚拟地址（Relative Virtual Addresses）</h3><ul>
<li><p>第一，<strong>虚拟</strong>，说明它不是一个真实地址，因此，它应该就是前面我们提到的逻辑地址，既然是逻辑地址，应该就是指的就是内存了（注意和硬盘上文件中的位置相区分）</p>
</li>
<li><p>第二，<strong>相对</strong>，相对说明这个地址很有可能是对某一个逻辑地址的偏移，而这个逻辑地址很有可能就是我们PE文件加载到内存时，所占用的最开始的那个内存单元的逻辑地址（或称之为基地址）</p>
</li>
</ul>
<h3 id="RVA和FOA的联系与区别"><a href="#RVA和FOA的联系与区别" class="headerlink" title="RVA和FOA的联系与区别"></a>RVA和FOA的联系与区别</h3><ul>
<li>RVA是内存的相对位置，相对的是加载到内存的基地地址</li>
<li>FOA是文件中的相对位置，相对的是文件开始位置（即0）</li>
</ul>
<p><img src="/posts/41006/20.png" alt></p>
<p><strong>文件在硬盘存储时的对齐方式和在内存加载时的对齐方式是不同的</strong>，在文件中，每一个<strong>节</strong>往往按512B（200H）的粒度对齐。而在内存中，通常以4096B（1000H）的粒度对齐，由于对齐的方式不同，有些节，它在内存的RVA就和它在文件的FOA就不一致。</p>
<p><img src="/posts/41006/21.png" alt></p>
<h3 id="如何让病毒被加载、执行？"><a href="#如何让病毒被加载、执行？" class="headerlink" title="如何让病毒被加载、执行？"></a>如何让病毒被加载、执行？</h3><p>PE文件格式字段：</p>
<p>e_magic：两个字符MZ代表DOS文件</p>
<p>e_lfanew：偏移量，就是从文件开始到PE文件头（NT头）的偏移量</p>
<p>通过“MZ”和后面的“PE”标志，来初步判断文件是否为PE文件，从而确定是否进行感染寄生</p>
<h3 id="PE头（NT头）"><a href="#PE头（NT头）" class="headerlink" title="PE头（NT头）"></a>PE头（NT头）</h3><p>nPE文件头的结构是IMAGE_NT_HEADERS，又称之为NT头，它是存放了整个PE文件的相关重要信息</p>
<pre><code>IMAGE_NT_HEADERS STRUCT
        Signature  dd ?
         FileHeader IMAGE_FILE_HEADER &lt;&gt;
         OptionalHeader IMAGE_OPTIONAL_HEADER32 &lt;&gt;
IMAGE_NT_HEADERS ENDS</code></pre><p>它包含3部分：</p>
<ul>
<li>PE文件标志（Signature）:字段头两个字节是“PE”，表明该文件是PE格式的文件。</li>
<li>映像文件头（IMAGE_FILE_HEADER）:NumberOfSections字段存储文件中节的个数</li>
<li>可选映像文件头（IMAGE_OPTIONAL_HEADER32）：<ul>
<li>AddressOfEntryPoint表示代码入口RVA，第一条指令的RAV</li>
<li>ImageBase: Cardinal; //载入程序的首选RAV</li>
<li>SectionAlignment: Cardinal; //节在内存中对齐方式</li>
<li>FileAlignment: Cardinal; //节在文件中对齐方式</li>
<li>SizeOfImage: Cardinal;     //内存中整个PE文件的总大小，按内存对齐</li>
<li>DataDirectory: array[0..IMAGE_NUMBEROF_DIRECTORY_ENTRIES - 1] of  TImage_Data_Directory; //数据目录表</li>
</ul>
</li>
</ul>
<p>病毒判断一个文件是否是PE格式往往可以通过：</p>
<ol>
<li><p>先判断文件头2字节是否为“MZ”</p>
</li>
<li><p>判断NT头的Signature是否为“PE”</p>
</li>
</ol>
<h3 id="利用入口RVA实现病毒执行的问题"><a href="#利用入口RVA实现病毒执行的问题" class="headerlink" title="利用入口RVA实现病毒执行的问题"></a>利用入口RVA实现病毒执行的问题</h3><p>知道执行程序的入口代码地址如何确定的，如果找到了，将它指向病毒代码，找到了<strong>AddressOfEntryPoint</strong>，它表示入口RAV，也是第一条指令的RAV，程序从这里开始执行。</p>
<p>我们需要通过RAV来找到该指令在文件中的FOA以便修改开始的机器码，利用RVA找到所属的节,如果该节的起始RVA和该节的起始文件偏移相等，那么就直接用作文件偏移。如果有差别：</p>
<blockquote>
<p>入口点的RVA（AddressOfEntryPoint）- 节的RVA =入口点的FOA - 节的起始文件位置（PointerToRawData）</p>
</blockquote>
<h3 id="PE描述文件大小的字段"><a href="#PE描述文件大小的字段" class="headerlink" title="PE描述文件大小的字段"></a>PE描述文件大小的字段</h3><p>1）节表紧跟在PE文件头后，节表中的每一个结构ImageSectionHeader （28H）都对应一个节，其中，有两个字段描述了对应节的文件大小（SizeOfRawData）和加载到内存的大小（VirtualSize）（两者可能不同，文件大小可以大于内存也可以小于内存。小于内存时，将在内存补0）</p>
<p>2）在PE头的可选映像头ImageOptionalHeader中，SizeOfImage给出了整个程序包括所有头部加载到内存后的大小其大小应该是SectionAlignment的整数倍</p>
<p>简单说，就是PE文件总大小和每个节的大小都有参数：</p>
<ul>
<li>每一个节都有一个对应的节表项SectionHeader结构</li>
<li>VirtualSize表明本节加载到内存后的大小即加载到内存的实际字节数（未对齐）</li>
<li>SizeOfRawData字段表明本节在文件中的大小（对齐后）因此，必须是FileAlignment（在可选映像头中）的整数倍</li>
</ul>
<p>回到可选映像头ImageOptionalHeader中观察：</p>
<ul>
<li><p>SizeOfImage给出了整个文件在内存中对齐后的大小</p>
</li>
<li><p>SectionAlignment是内存对齐的粒度</p>
</li>
<li><p>FileAlignment是文件对齐的粒度</p>
</li>
</ul>
<h3 id="用程序完成末段大小不变的寄生"><a href="#用程序完成末段大小不变的寄生" class="headerlink" title="用程序完成末段大小不变的寄生"></a>用程序完成末段大小不变的寄生</h3><ol>
<li><p>生成需要寄生的病毒代码</p>
</li>
<li><p>获得被感染文件的NT头</p>
<ol>
<li>利用DOS头的e_lfanew字段（文件定位）</li>
<li>定位NT头，读到ntHrds（文件定位读）</li>
</ol>
</li>
<li><p>找到最后一个节判断是否具有空洞</p>
<ol>
<li><p>如何判断节是否有空洞？</p>
<p><strong>virtualSize &lt; SizeofRawData</strong></p>
</li>
<li><p>这些信息在哪里？</p>
<p><strong>最后一个节的节表项中</strong></p>
</li>
<li><p>当前的文件指针在什么地方？</p>
<p><strong>之前读了NT头，现在在NT头的后面也就是节表的起始文件位置</strong></p>
</li>
</ol>
</li>
<li><p>修改最后一个节VirtualSize写入病毒</p>
</li>
<li><p>修改SizeofImage和EntryPoint</p>
</li>
</ol>
<h2 id="第十一章-EPO入口点不在代码节的问题"><a href="#第十一章-EPO入口点不在代码节的问题" class="headerlink" title="第十一章-EPO入口点不在代码节的问题"></a>第十一章-EPO入口点不在代码节的问题</h2><h3 id="入口点模糊技术-Entry-Point-Obscuring"><a href="#入口点模糊技术-Entry-Point-Obscuring" class="headerlink" title="入口点模糊技术(Entry Point Obscuring)"></a>入口点模糊技术(Entry Point Obscuring)</h3><p>每个节的节表项有一个characteristics属性,说明了该节是干什么的,当IMAGE_SCN_CNT_CODE为20时说明是代码节. EPO技术能够让病毒代码隐藏自己入口点，避免被查杀,使得被病毒修改后的入口点看起来依然就像是正常的入口点.</p>
<p>解决入口点不在代码段的问题，我们可以采用下2种解决方法：</p>
<blockquote>
<p>1）不感染最后一节，直接感染代码节，病毒代码附着在代码节的尾部，再修改入口点。这样虽然修改了入口点，但让入口点处于代码节</p>
<p>2）不修改入口点，但将入口点所在的指令替换成一条JMP指令，跳往到寄生的病毒代码</p>
</blockquote>
<h3 id="EPO1-感染在代码节的空洞"><a href="#EPO1-感染在代码节的空洞" class="headerlink" title="EPO1 感染在代码节的空洞"></a>EPO1 感染在代码节的空洞</h3><p>本方法有个缺陷，真正的入口一般都在代码节的前部，而我们感染的是尾部，这样修改后的入口点太靠代码节的后部，这也会使得入口点看起来异常，从而被一些杀毒软件查杀</p>
<p>比如，我们正常软件入口是1690h，代码节.text的起始RVA是1000h，正常入口在节内偏移只有690h，如果感染到本节尾，则修改后的入口点在节内偏移将是212B0-1000=202B0h，远远大于690。基本就是节尾了，这就会引起怀疑。</p>
<p>此外，感染代码节时，代码节往往不是最后节，如果代码节空洞不够，就必须增加代码节的节长，则后续节都要修改RVA，文件偏移等字段，非常麻烦</p>
<h4 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h4><ol>
<li><p>生成需要寄生的病毒代码</p>
</li>
<li><p>获得被感染文件的NT头</p>
</li>
<li><p>找到代码节并判断是否具有空洞</p>
<p>如何找到代码节？遍历所有节表项并判断节表项的属性是否有20属性</p>
</li>
<li><p>修改VirtualSize写入病毒</p>
</li>
<li><p>修改SizeofImage和EntryPoint</p>
</li>
</ol>
<h3 id="EPO2感染最后节并替换入口指令"><a href="#EPO2感染最后节并替换入口指令" class="headerlink" title="EPO2感染最后节并替换入口指令"></a>EPO2感染最后节并替换入口指令</h3><p>感染时，先将原入口5字节保存，替换成JMP跳到寄生代码。病毒执行后，将入口5字节还原，然后跳回到原入口</p>
<h4 id="如何生成寄生的病毒代码"><a href="#如何生成寄生的病毒代码" class="headerlink" title="如何生成寄生的病毒代码"></a>如何生成寄生的病毒代码</h4><p>病毒代码需要进行恢复跳转等细致的操作，所以我们把病毒代码采用C中内嵌汇编的方式编写，生成病毒代码code后，然后利用C语言来完成病毒代码的寄生拷贝</p>
<p>思考：病毒要做的事有哪些</p>
<ol>
<li><p>修改原入口点的数据为JMP指令</p>
</li>
<li><p>保存被覆盖的5个字节</p>
</li>
<li><p>执行逻辑</p>
</li>
<li><p>恢复这5个字节</p>
<ul>
<li><p>源地址就是被覆盖的5个字节，放在数据区，所以我们把可以把<strong>数据区的起始地址</strong>也作为数据放入数据区</p>
</li>
<li><p>目的地址是原程序的<strong>入口点地址</strong>，寄生后，病毒的main函数就结束了，所以这个<strong>入口点地址</strong>也需要写入数据区时</p>
</li>
</ul>
</li>
<li><p>最后一条JMP跳回原入口点</p>
</li>
</ol>
<blockquote>
<p>因此，寄生代码的数据区应该有5+4+4=13个字节</p>
</blockquote>
<p>寄生代码生成的时候，这些重要的地址信息是根据PE文件的预期加载地址ImageBase来生成的，所以说是预期地址。然后寄生代码会放到原文件中，如果原文件加载到预期的ImageBase，寄生代码中的地址信息就是正确的。但是！ImageBase是程序<strong>预期</strong>加载的基地址，win7系统和vs编译器往往都采用了随机地址空间技术，使得程序即每次加载的<strong>实际</strong>地址并不是ImageBase，原文件有重定位表这样的机制帮助重定位，但病毒只能利用前面我们学到的<strong>自定位</strong>技术原理。</p>
<p><img src="/posts/41006/22.png" alt></p>
<p><strong>关键在于：</strong></p>
<ul>
<li>找到入口点所在的节</li>
<li>然后将入口点（内存位置）转变为文件位置</li>
</ul>
<p>实际中会遇到内存区只可读不可改的情况，因此我们把characteristics的值改为我们想要的可写即可，80000000h代表写，为避免类似情况，我们选择在循环搜索入口点所在的节时，一旦找到该节，就将该节的索引（后面写入时需要利用这个索引值找到该节）和属性字段保存，然后，在文件中定位到该节的节头，计算新的属性值并写入到节头的属性字段。</p>
<h2 id="第十二章-DDL-导出表"><a href="#第十二章-DDL-导出表" class="headerlink" title="第十二章-DDL+导出表"></a>第十二章-DDL+导出表</h2><h3 id="如何让病毒调用函数"><a href="#如何让病毒调用函数" class="headerlink" title="如何让病毒调用函数"></a>如何让病毒调用函数</h3><p>我们需要在病毒数据区存放调用函数所需的参数。如何访问这些参数呢？用我们已经熟悉的自定位代码即可，call后再pop到eax，eax就指向了参数的地址。</p>
<p><strong>操作系统通过动态链接库（DLL）来对外提供API</strong> </p>
<p>   1）动态链接库是应用程序的一部分，动态链接库在本质上是作为模块被进程加载到自己的空间地址的。</p>
<p>   2）动态链接库在程序运行时整个库的代码才会调入内存，这就是所谓的“动态链接”</p>
<h4 id="如何获取API的入口地址"><a href="#如何获取API的入口地址" class="headerlink" title="如何获取API的入口地址"></a>如何获取API的入口地址</h4><p>只有获取了API函数入口地址（模块DLL – &gt; 函数），我们才能跳过去调用它，没有操作系统和编译器的帮忙，就只有自力更生：</p>
<p>  （1）找到提供这个API函数的<strong>DLL的加载基址</strong> </p>
<p>  （2）从DLL的导出表中拿到<strong>API函数地址</strong> ，理解DLL的导出表机制，可简单想象成一张表，然后在这个表中根据函数名找到函数入口地址。我们的操作系统通过kernel32中的GetProcAddress来实现的，但是我们病毒，还是只能自力更生</p>
<p>想要快速拿到一个API的入口地址，有一个简陋但快速的办法，它基于如下事实：一个系统中，所有进程加载的同一个DLL的加载基址是相同的。在Windows的设计中，因为某种原因（可能是共享代码段，避免重定位等），每个进程中，系统DLL都被加载在一个地址。</p>
<h4 id="如何利用DLL基址相同让病毒获取API首址？"><a href="#如何利用DLL基址相同让病毒获取API首址？" class="headerlink" title="如何利用DLL基址相同让病毒获取API首址？"></a>如何利用DLL基址相同让病毒获取API首址？</h4><p>只需要在C写的病毒代码中获取MessageBox的首址，然后把这个首址写入到我们病毒的数据区，这样病毒代码寄生到了原文件上时，就可以在自己的数据区获得MessageBox的首址。</p>
<p><img src="/posts/41006/23.png" alt></p>
<h3 id="如何判断是否是控制台程序"><a href="#如何判断是否是控制台程序" class="headerlink" title="如何判断是否是控制台程序"></a>如何判断是否是控制台程序</h3><p>在PE文件的可选映像头中，有一个字段可能能够用于识别PE文件是否为控制台程序，就是subsystem，对于大多数Win32程序，只有Windows GUI和Windows CUI两类值。G - Graphic的头字母，C - Console的头字母，因此，我们只需要判断subsystem字段的值，当其为2时才感染即可。</p>
<h3 id="病毒真正获取API函数地址的方法"><a href="#病毒真正获取API函数地址的方法" class="headerlink" title="病毒真正获取API函数地址的方法"></a>病毒真正获取API函数地址的方法</h3><h5 id="一、获取DLL基址"><a href="#一、获取DLL基址" class="headerlink" title="一、获取DLL基址"></a>一、获取DLL基址</h5><p>只有找到DLL基地址，我们才能找到它的导出表，才能找到所要调用函数的地址。以获取kernel32.dll的基址为例，其他dll模块的方法类似，这里介绍一个简单的获取kernel32.dll基址的方法，主要利用PEB结构（Process Environment Block，进程环境块）查找，每个进程都对应一个PEB。</p>
<p>首先，FS寄存器在偏移0x30处保存一个指针，指向PEB结构，<strong>FS:[0x30]</strong> -&gt; PEB。</p>
<p>然后，在PEB结构的偏移0x0C处保存着另外一个指针，该指针指向一个叫PEB_LDR_DATA的结构</p>
<p>这个PEB_LDR_DATA 偏移0C处是<strong>加载模块链表</strong>的头指针，由8个字节组成，前4个字节指向一个LDR_MODULE结构体（LDR_MDOULE代表一个模块，每一个模块（exe,dll）都对应一个这样的结构体），在该LDR_MODULE中，头4字节又指向下一个加载的LDR_MODULE结构体，由此组成链表。</p>
<p>在win7下，第一个加载的模块是是执行程序本身，第2个是NTDll，第3个就是kernel32，在结构体偏移0x18处就是所对应模块的基址。</p>
<p><strong>那如何在遍历的过程中识别模块呢？</strong> </p>
<p>在LDR_MODULE结构体偏移0x2C的地方，有一个成员BaseDllName，它有8个字节，其中后4字节为地址，指向一个unicode串（每个字符占2个字节），这个unicode串就是不包含路径的纯模块名。</p>
<p>遍历的结束条件是什么？Next指针为0或者ffffffff么？都不是，过调试我们可以发现，在win7下，加载模块链形成了一个循环链表，因此只要发现next块的头4字节是头块地址就停止遍历。</p>
<h5 id="二、获取DLL中的函数地址"><a href="#二、获取DLL中的函数地址" class="headerlink" title="二、获取DLL中的函数地址"></a>二、获取DLL中的函数地址</h5><p>找到基址后，我们必须手动完成由函数名获取其所在DLL中地址的过程，我们需要从DLL的实际基址入手，解析DLL的导出表，获取相关函数的入口地址。</p>
<h3 id="导出表—DLL对外暴露函数地址的机制"><a href="#导出表—DLL对外暴露函数地址的机制" class="headerlink" title="导出表—DLL对外暴露函数地址的机制"></a>导出表—DLL对外暴露函数地址的机制</h3><p>DLL对外暴露自己的函数有两种方式：</p>
<ul>
<li>函数名</li>
<li>序号</li>
</ul>
<p>可以通过函数名查找某函数入口，也可通过序号查找，但是，需要注意的是，函数名和序号并非一 一对应！</p>
<h4 id="序号查找"><a href="#序号查找" class="headerlink" title="序号查找"></a>序号查找</h4><p>序号查找的好处：快！高效！</p>
<p>我们可以用一个简单的hash完成，而不需要遍历，如果我们用一个数组（funcEntryTb）存储函数的入口地址。第0号函数的入口地址就存入数组的第一个元素funcEntryTb[0]，第1号函数的就存入数组的第2个元素funcEntryTb[1]。这样获取入口地址非常简单 ，即funcEntryTb[n]，n是函数的序号，也就是拿到数组首址funcEntryTb加偏移n*4（每个地址4个字节）即可。类似DOS下的中断向量表。</p>
<p>如果序号不是从0开始，而是从n开始，我们依然是将n对应函数的入口地址存入第一个元素，依次类推。获取第M（M肯定大于n，因为n最小）号函数的地址如下： funcEntryTb[m - n]。依然非常快速，计算次数固定，即拿到首址funcEntryTb，做一次减法m-n，再做一次乘法(m - n)*4就获取到元素的地址，取出其值保存值即可。这其实也是c语言switch语句出来case中序号和case分支入口地址的方法，所以一般switch比if else嵌套快</p>
<p>但是序号查找不够直观，同时也不够稳定</p>
<h4 id="用函数名查找"><a href="#用函数名查找" class="headerlink" title="用函数名查找"></a>用函数名查找</h4><p>用函数名查找：直观！具体！</p>
<p>最简单的办法就是一个一个函数名字串比较，找到相同的串。下面给出一个简单实现：函数名表的索引和函数地址表的索引是一一对应的。如果查找func2函数地址，我们先遍历函数名表，每遇到\0就是一个串，自然，在第2串处找到了字串func2，fun2是函数名表第2项，索引为1，然后我们用索引1在函数地址表中获得了address2，函数地址表4字节一个元素<strong>通过两个表相同的索引建立关联</strong>。</p>
<h4 id="两种机制结合"><a href="#两种机制结合" class="headerlink" title="两种机制结合"></a>两种机制结合</h4><p>如果用序号导出对应一个函数地址表，用名字导出也对应一个函数地址表，两个函数地址表显然会造成存储浪费，能否合成在一个函数地址表？</p>
<p>要实现合并需要满足：</p>
<ul>
<li>所有函数都有即有函数名又有序号</li>
<li>函数名表的索引和序号都是按1递增的</li>
<li>函数名表的排序还必须按照序号值排序，也就是说，如果一个函数的序号是x，它的函数名就必须排在函数名表的第x-1项</li>
</ul>
<p>限制太多，而且最重要的是，<strong>并不是每一个函数都向外暴露函数名！有的函数是没有暴露函数名的！</strong>实际上，DLL中有些函数是只有序号暴露，而没有函数名暴露的。而函数地址表是和序号对应的！这样，就导致函数名表索引是无法和函数地址表索引形成一一对应的关系。</p>
<p>若要解决类似的问题，就只能通过增加一个表描述对应关系。增加一个函数地址索引表，用它来记录函数名表索引到函数地址表索引的对应关系。</p>
<p>而按序号查找时，直接根据序号计算其在函数地址表的索引：<code>i=函数序号-最小的序号（n）</code>，然后在函数地址表中找到索引为i的项，取出地址即可。</p>
<p>导出表有表头（IMAGE_EXPORT_DIRECTORY）描述了导出表相关重要信息：</p>
<ol>
<li>Address Table RVA就是函数地址表的RVA</li>
<li>Ordinal Table RVA就是函数地址索引表的RVA，PE格式叫它序号表</li>
<li>Ordinal Base就是最小的序号，Number of names就是函数名表的条数</li>
</ol>
<p>PE格式将函数名表做了些变化，用了一个函数名指针表，Name Pointer Table RVA，它每项4个字节，存放了一个RVA，指向一个函数名的字符串</p>
<p><img src="/posts/41006/24.png" alt></p>
<h4 id="如何获取导出表的表头"><a href="#如何获取导出表的表头" class="headerlink" title="如何获取导出表的表头"></a>如何获取导出表的表头</h4><p>在模块的可选头中，最后有一个数据目录表<code>EXPORT Table</code>：数据目录表中的每一项都是一个重要的元素，包括导出表、导入表、重定位表等…每一个项都给出了相应元素的入口RVA和大小，其中，第一项就是重要的导出表。根据这个就能找到导出表的表头。</p>
<h4 id="导出函数查找算法"><a href="#导出函数查找算法" class="headerlink" title="导出函数查找算法"></a>导出函数查找算法</h4><ol>
<li><p>从DLL加载的<strong>实际基址</strong>获取可选头，从其中<strong>数据目录表</strong>的第一项找到导出表入口RVA</p>
</li>
<li><p>从导出表的表头获取Number of names，即查找的最大循环次数</p>
</li>
<li><p>循环遍历<strong>函数名指针表</strong>，比对每项RVA指向的字串是否为要找的函数名</p>
<p><code>函数名指针表1项4字节 à 对应的字符串地址</code></p>
</li>
<li><p>如果找到，记下此时函数名指针表项的索引，设为 i</p>
</li>
<li><p>根据索引 i，在<strong>序号表</strong>中找到对应项，获取其内容为n</p>
<p><code>序号表1项2字节</code></p>
</li>
<li><p>以n为索引在<strong>函数地址表</strong>中找到函数入口的RVA，加上DLL的实际基址即为函数的实际入口地址</p>
<p><code>地址表1项4字节</code></p>
</li>
</ol>
<p>注：以上算法中，所有访问实际地址的地方，就用<code>DLL的实际加载基址+RVA</code>即可</p>
<h2 id="第十三章-EPO技术指令Patch和导入表机制"><a href="#第十三章-EPO技术指令Patch和导入表机制" class="headerlink" title="第十三章-EPO技术指令Patch和导入表机制"></a>第十三章-EPO技术指令Patch和导入表机制</h2><h3 id="利用Patch指令的方式实现EPO"><a href="#利用Patch指令的方式实现EPO" class="headerlink" title="利用Patch指令的方式实现EPO"></a>利用Patch指令的方式实现EPO</h3><p><strong>核心问题：</strong></p>
<ol>
<li>找到一条指令，并知道其起始边界</li>
<li>最好这条指令必然执行，否则patch了，病毒代码也不会必然执行。</li>
</ol>
<p><strong>解决思路：</strong></p>
<ol>
<li>对一些常见特殊指令识别，比如PUSH EBP；MOV EBP, ESP等，这是很多函数的开始设定基址寄存器的组合。简单，方便。缺点：由于指令长度过短，可能和数据相同，因此不见得一定是指令；同时，不见得该代码一定会被执行</li>
<li>对导入函数的调用指令进行Patch，这些指令的可靠度很高，可以选择某些必然被调用的函数指令去Patch</li>
<li>病毒自带反汇编器（如一些开源反汇编器），静态分析宿主程序，随机找一条指令Patch，隐蔽度极高，复杂，但Patch的指令不一定会必然执行</li>
<li>自带调试功能（相当一个调试器），将宿主程序隐藏启动，单步调试运行，自然得到每条指令的边界</li>
</ol>
<h4 id="为什么Call要用相对偏移"><a href="#为什么Call要用相对偏移" class="headerlink" title="为什么Call要用相对偏移"></a>为什么Call要用相对偏移</h4><p>在前面，我们已经知道了加载可能出现与约定地址不吻合的问题（回想下PE头中的ImageBase字段），如果Call指令采用了绝对地址, 那么这条Call指令就会失效。</p>
<p>因此采用相对偏移Call就不会出问题，虽然加载基址变化，但整个模块是整体搬迁，call和被call之间的偏移却不变！所以无影响。</p>
<p>相对偏移的优点只能运用到同一个模块中（DLL，EXE），如果跨越了模块，调用DLL中的函数时，并不知道该模块会加载到哪里，因此，是不可能事先算出转跳偏移的，那怎么办？</p>
<p>这是在编译器和系统协助下，利用导入表机制完成了这个工作。简单说，就像为每个被调用的DLL函数都设定一个邮箱，系统加载了DLL后，利用导出表机制获得函数的地址（这个我们前面已经学习过了），然后将函数地址放到各自的邮箱中，这样，需要调某函数时，就从邮箱里拿到这个地址。</p>
<h3 id="理解导入表机制"><a href="#理解导入表机制" class="headerlink" title="理解导入表机制"></a>理解导入表机制</h3><p>在可选头的数据目录的第2项就是是导入表的描述，其中有导入表的RVA</p>
<p>RVA指向导入表（IMPORT DICTORY TABLE）起始，在这个地方，每一项是一个IMAGE_IMPORT_DESCRIPTOR结构，代表一个导入的DLL的相关信息。在这个结构中，又有：</p>
<blockquote>
<p> INT表（Import Name Table）和IAT表（Import Address Table）的RVA</p>
</blockquote>
<p><img src="/posts/41006/25.png" alt></p>
<p><img src="/posts/41006/26.png" alt></p>
<p>在一般情况下，INT（OriginalFirstThunk）和IAT（FirstThunk）的内容确实是相同的，因此，是冗余的。正是这个原因，为了节约空间，一些编译器（如Borland）不会生成INT，其RVA值为0。但是，这是在没有使用预先绑定导入地址的情况下，如果有预先绑定，则必须要有INT表，此时RVA不等于0。</p>
<p>由于程序在加载时，需要在IAT表中填入函数的加载地址入口，因此，往往会比较耗时，为了减少加载时间，于是有了预先绑定技术。</p>
<p>预先绑定技术是在编译时就向IAT表中填入导入地址（即函数的入口地址，而不是指向IMAGE_IMPORT_BY_NAME表项的RVA），它是直接根据系统DLL的预期基址（ImageBase）计算出来的。</p>
<p>通过预先绑定，在实际加载时，只要系统DLL的基址没有发生改变，那么IAT表的内容就不需要再次填充，因此，加载时速度更块。</p>
<p>所以，采用预先绑定，在实际加载时，需要验证DLL是否被加载到预期地址。如果，引用的DLL没加载到预期地址，那就必须再次填充IAT表为实际的函数地址。</p>
<p>这时，已经不能使用IAT表来指向IMAGE_IMPORT_BY_NAME表项了（编译时RVA已经被覆盖为函数预期入口地址），但INT表可以，通过INT表再次执行导入机制，从而使得IAT表内容更新。</p>
<p>这也就是为什么预先绑定时必须要有INT表的原因！</p>
<h2 id="第十四章-指令Patch实现与重定位表"><a href="#第十四章-指令Patch实现与重定位表" class="headerlink" title="第十四章-指令Patch实现与重定位表"></a>第十四章-指令Patch实现与重定位表</h2><h3 id="如何找到需要Patch的指令"><a href="#如何找到需要Patch的指令" class="headerlink" title="如何找到需要Patch的指令"></a>如何找到需要Patch的指令</h3><p>整体思路：</p>
<p>  为了找到需要Patch的指令，病毒可以采取以下的动作：</p>
<ol>
<li>首先指定一个会被大概率调用的函数名（也包括函数所在DLL的名字），如Kernel32中的GetCommandLineX，X=A/W</li>
<li>然后通过被寄生文件（exe）的导入表找到该函数的导入表项（即IAT中的对应项地址）的地址XXXX</li>
<li>最后去exe文件的代码中搜索所有可能的Call [XXXX] 或 JMP [XXXX]后，即 FF 15 XXXX 或 FF 25 XXXX </li>
</ol>
<p>详细来说：</p>
<ol>
<li>在文件中找到导入表的位置：先找到导入表的RVA，将RVA转换为导入表的文件位置</li>
<li>找到指定API函数在IAT表中的表项地址。先要找到API所在DLL对应的项，然后才能找到这个DLL所对应的INT和IAT表，比较dll的名字，判断是否是API函数所在DLL的导出表目录项，然后根据预先绑定，如果有INT就用INT表来找函数名，没有就用IAT表找函数名，获得INT表（或IAT表）的RVA，并将其转换为文件位置，遍历INT表（或IAT表）的每一项，查找指定的API函数名。</li>
<li>找到符合的指令进行Patch，先找到代码所在的节，判断节的属性是否有0x20，找到后开始循环遍历每个字节进行替换，并写入patch指令。</li>
</ol>
<h3 id="病毒执行部分的设计"><a href="#病毒执行部分的设计" class="headerlink" title="病毒执行部分的设计"></a>病毒执行部分的设计</h3><ol>
<li>我们准备patch调用GetCommandLineA或GetCommandLineW的函数，因为它们基本在入口处会被调用，这样可以保证病毒一开始就执行</li>
<li>为了防止函数再次调用时病毒再次执行，我们增加了一个标记</li>
<li>另外，感染时到底patch的是W还是A版的GetCommandLine，也有一个标记来告诉寄生的病毒代码，从而寄生病毒执行时才知道去找哪个函数的实际入口地址</li>
<li>寄生病毒执行时，找到函数地址后需要存储一下，因此，并分配了4字节存储GetCommandLineX（W/A）的入口地址。为了不修改老代码，数据区开始的原来13个字节没有删减，用于存放这3个信息。</li>
<li>在数据段增加了“GetCommandLineA”和” GetCommandLineW”串，因为要用getproc动态查找到其首址跳过去</li>
<li>增加了获取kernel32基址和获取GetCommandLineW/A的代码</li>
<li>最后用JMP指令跳到GetCommandLineW/A去</li>
</ol>
<p>关于最后跳转的问题，因为JMP跳转包含的地址是绝对地址（这是函数所对应的IAT表项的地址），如果在exe可重定位的情况下，这个xxxx地址是需要重定位的。然而，病毒尾部的这条Jmp [xxxx]是病毒添加的，因此，在重定位表中没有重定位项的，所以会出错。</p>
<blockquote>
<p> 解决的方法：添加重定位项或让exe不会重定位</p>
</blockquote>
<h3 id="利用IAT表项查找函数入口"><a href="#利用IAT表项查找函数入口" class="headerlink" title="利用IAT表项查找函数入口"></a>利用IAT表项查找函数入口</h3><p>除了修改节头的相关信息数据外，还要填充节直到长度达到要求</p>
<p>感染时填充数据区的预期加载地址，数据区的预期加载地址是：imagebase + 被感染节的起始RVA+virtualSize+5（自定位的call指令长度），数据区在call指令后</p>
<p>被调函数的IAT项的地址,Patch函数调用时，将获得IAT项地址返回，并将其作为参数传递给getCode函数，getCode函数将IAT项地址填入此处.</p>
<p>因为exe可能被重定位，所以IAT的地址可能变化，需利用病毒数据区的信息来定位IAT的实际地址。算法如下：</p>
<ol>
<li>call..pop自定位代码获取了数据区的地址A</li>
<li>数据区的预期加载地址=B= [A+1] </li>
<li>IAT表项的预期地址是[A+5]</li>
<li>IAT表项重定位后的实际地址是 IAT_addr – [A+5] = A – B</li>
<li>通过[IAT_addr]获得函数入口地址</li>
</ol>
<p>如此，则不需用再去调getproc查询函数入口地址</p>
<h3 id="PE文件的重定位机制"><a href="#PE文件的重定位机制" class="headerlink" title="PE文件的重定位机制"></a>PE文件的重定位机制</h3><p>程序因加载到非编译期约定地址时，就必需修改那些包含了绝对地址的指令（因为这些绝对地址已经不是原来的地址了），这称为程序重定位，由加载器（loader）完成</p>
<p>本来，exe是不需要重定位的，它是用户模块第一个进入进程空间的，它的约定加载基址，只要不过分（和系统DLL抢），都可以被满足</p>
<p>但因为为了对抗攻击和安全考虑，从VS2003开始，微软编译器缺省会将exe编译成可重定位模式</p>
<p>理解PE文件重定位的关键在于要解决两个问题：</p>
<ol>
<li>如何进行重定位呢？</li>
<li>加载器如何知晓哪些地方需要被重定位呢？</li>
</ol>
<h4 id="如何进行重定位"><a href="#如何进行重定位" class="headerlink" title="如何进行重定位"></a>如何进行重定位</h4><p>算法：</p>
<ol>
<li>实际和预期加载地址的差x = A – B。</li>
<li>找到需要修改的位置y</li>
<li>读出y开始4字节的值 + x = 新地址值z</li>
<li>将z写入y开始的4字节</li>
</ol>
<h4 id="如何知道哪些地方需要重定位"><a href="#如何知道哪些地方需要重定位" class="headerlink" title="如何知道哪些地方需要重定位"></a>如何知道哪些地方需要重定位</h4><ul>
<li>在可选头的数据目录中，有一项（第6项）就是重定位表，而重定位表中就记录了所有需要进行重定位修改的位置</li>
<li>因为被修改的都是地址值（32位机上4字节），所以在重定位表中，我们不需要记录每个修改位置要改多少字节，只需要记录被修改的位置即可，那么Loader每次就根据这个位置定位4字节进行修改（加上加载偏差）</li>
<li>需要重定位的区域以4096（2^12）字节（即16进制0x1000h）进行划分，在每个区域（Page）里面，每个需要重定位的位置都有相应的重定位项纪录了该位置离这个区域起始位置的偏移</li>
<li>针对每个区域，在重定位表中都有8字节的头部，其中前4个字节的值是这个<strong>重定位内存页的起始RVA</strong>，后4个字节是<strong>重定位块的长度</strong>（包括头和所有表项在内的字节数）</li>
<li>划分为区域后，重定位表中的每一项就只需要12位（1.5个字节）来表示地址，另外有0.5字节为属性（通常我们只能看见属性3，表示所指向的32位地址都需要修正）,即如300F，则00F为偏移。</li>
</ul>
<p>在我们Patch指令的过程中，我们将该指令修改为了不包含绝对地址的指令形式(即：Call 偏移，Jmp 偏移)，但并没有删除针对该指令的重定向项，那么重定位后，就会对这个重定位项指向的位置（即指向了我们Patch后的指令）进行修改，那么我们Patch后的指令就会被篡改！</p>
<blockquote>
<p>解决方法，让exe重定位项失效，或删除这些被Patch指令的重定位项</p>
</blockquote>
<h2 id="第十五章-反病毒技术简介"><a href="#第十五章-反病毒技术简介" class="headerlink" title="第十五章-反病毒技术简介"></a>第十五章-反病毒技术简介</h2><h3 id="反病毒技术的发展历程"><a href="#反病毒技术的发展历程" class="headerlink" title="反病毒技术的发展历程"></a>反病毒技术的发展历程</h3><p> <strong>第一代反病毒技术</strong></p>
<ul>
<li>采用单纯的病毒特征代码分析，清除染毒文件中的病毒</li>
</ul>
<p><strong>第二代反病毒技术</strong></p>
<ul>
<li>采用静态广谱特征扫描技术检测病毒，可以检测变形病毒，但是误报率高</li>
</ul>
<p><strong>第三代反病毒技术</strong></p>
<ul>
<li>将静态扫描技术和动态仿真跟踪技术结合起来，将查找病毒和清除病毒合二为一</li>
</ul>
<p><strong>第四代反病毒技术</strong></p>
<ul>
<li>基于病毒家族体系的命名规则、基于多位校验和扫描机理、启发式智能代码分析模块、动态数据还原模块、内存解毒模块、自身免疫模块等先进的解毒技术，较好的解决了以前防毒技术顾此失彼、此消彼长的状态，能够较好地完成查毒、解毒的任务</li>
</ul>
<h4 id="计算机病毒防治技术的划分"><a href="#计算机病毒防治技术的划分" class="headerlink" title="计算机病毒防治技术的划分"></a>计算机病毒防治技术的划分</h4><ul>
<li>病毒预防，防止病毒进入内存或阻止病毒对磁盘的操作</li>
<li>病毒检测，计算机病毒的判定</li>
<li>病毒消除，计算机病毒感染的逆过程，恢复被感染程序原有的结构信息</li>
<li>病毒免疫，可能并不存在通用的病毒免疫方法</li>
</ul>
<h4 id="病毒防治技术从被动到主动"><a href="#病毒防治技术从被动到主动" class="headerlink" title="病毒防治技术从被动到主动"></a>病毒防治技术从被动到主动</h4><ul>
<li>主动内核(Active K)技术，是在操作系统和网络的内核中嵌入反病毒功能，使反病毒成为系统本身的底层模块，实现各种反毒模块与操作系统和网络无缝连接，而不是一个系统外部的应用软件</li>
<li>主动内核技术能够实时监控整个系统的运行，并在病毒突破计算机系统软、硬件的瞬间发生作用</li>
</ul>
<h4 id="计算机病毒防范的概念"><a href="#计算机病毒防范的概念" class="headerlink" title="计算机病毒防范的概念"></a>计算机病毒防范的概念</h4><ul>
<li>计算机病毒的防范，就是要在<strong>病毒执行之前</strong>进行阻断，需要监视、跟踪系统内类似的操作，提供对系统的保护，最大限度地避免各种计算机病毒的传染破坏，往往需要基于全系统的<strong>内核级行为监控</strong></li>
</ul>
<h4 id="计算机病毒的预防措施"><a href="#计算机病毒的预防措施" class="headerlink" title="计算机病毒的预防措施"></a>计算机病毒的预防措施</h4><p>计算机病毒的预防措施可概括为两点</p>
<ul>
<li>勤备份</li>
<li>严防守</li>
</ul>
<h4 id="计算机检测技术分类"><a href="#计算机检测技术分类" class="headerlink" title="计算机检测技术分类"></a>计算机检测技术分类</h4><p>检测计算机病毒的方法通常有两种：</p>
<ol>
<li><p>手工检测</p>
<p>优点：可以剖析病毒、可以检测一些自动检测工具不能识别的新病毒</p>
<p>缺点：费时费力，复杂</p>
</li>
<li><p>自动检测</p>
<p>优点：可方便地检测大量的病毒</p>
<p>缺点：自动检测工具的发展总是滞后于病毒的发展</p>
</li>
</ol>
<h3 id="常见计算机病毒的诊断方法及原理"><a href="#常见计算机病毒的诊断方法及原理" class="headerlink" title="常见计算机病毒的诊断方法及原理"></a>常见计算机病毒的诊断方法及原理</h3><p><strong>一、比较诊断法</strong></p>
<p>用原始的正常备份与被检测的内容进行比较</p>
<p><strong>优点</strong>：比较法不需要专用的反病毒软件，且可以检测未知病毒</p>
<p><strong>缺点：</strong></p>
<p>- 该方法依赖与未染病毒时的原始系统的备份</p>
<p>- 且无法知道病毒的种类名称</p>
<p>- 易于误报</p>
<p><strong>二、校验和诊断法</strong></p>
<p>根据正常文件的信息计算其校验和（checksum），计算新的校验和与原来保存的校验和是否一致</p>
<p>运用校验和法查病毒一般采用三种方式：</p>
<ol>
<li>对被查的对象文件计算其正常状态的校验和，将校验和值写入被查文件中或检测工具中，而后进行比较</li>
<li>在应用程序中，放入校验和法自我检查功能，实现应用程序的自检测</li>
<li>将校验和检查程序常驻内存，每当应用程序开始运行时，自动比较检查应用程序内部或其他文件中预先保存的校验和</li>
</ol>
<p><strong>优点：</strong>校验和法既能发现已知病毒，也能发现未知病毒</p>
<p><strong>缺点</strong>：不能识别病毒种类与名称，对某些对文件信息影响不大的病毒效果较差，如链式病毒；同比较法一样，病毒感染并不是文件改变的唯一原因，所以此法会产生误报</p>
<p><strong>三、扫描诊断法</strong></p>
<p><strong>原理</strong>：扫描法是用每一种病毒体含有的特定病毒码(Virus Pattern)对被检测的对象进行扫描。如果在被检测对象内部发现了某一种特定病毒码，就表明发现了该病毒码所代表的病毒</p>
<p> - 特征代码扫描法</p>
<p> - 特征字扫描法</p>
<p>特定病毒码：当杀毒软件公司收集到新病毒中，就会从病毒程序中截取一小段独一无二且足以标记该病毒的二进制程序码（就好比犯人的指纹）</p>
<p>扫描法的软件通常由两部分组成：</p>
<p> - 病毒代码库，库中特征码的数量决定了扫描程序的识别能力</p>
<p> - 扫描程序（Scanner）</p>
<p>扫描法是当前最普遍的病毒检测方法，扫描法的核心——病毒特征码的选择</p>
<p>特征码选择的原则：</p>
<p>1.具有代表性：小的病毒一百多字节，长的10KB</p>
<p>2.不应包含数据区，数据区是可变的</p>
<p>3.特征码的长度：过长带来扫码时间和空间的开销过大，过短则不易具有代表性（两个相互矛盾的目标）</p>
<p>4.具有区分性：能区别该病毒和其他病毒，更重要的是要能区分病毒和正常程序，避免误报！</p>
<p><strong>优点</strong>：</p>
<p>使用方便；特征码选择好则误报率低、选择不好则误报率高</p>
<p>不用专门查毒软件；可识别病毒名称和类别；可做扫毒处理</p>
<p><strong>缺点</strong>：</p>
<p>特征码的生成难度很大；扫描需要开销；需要不断更新病毒特征码库</p>
<p>不易识别多态变形病毒、不能检测未知病毒等</p>
<p><strong>四、行为监测诊断法</strong></p>
<p><strong>原理</strong>：利用病毒的特有行为特性监测病毒的方法，称为行为监测法</p>
<p><strong>优点</strong>：即能发现已知病毒，也能发现未知病毒</p>
<p><strong>缺点</strong>：误报，不能识别病毒名称和种类，需要病毒运行以后才能进行分析</p>
<p><strong>五、感染实验诊断法</strong></p>
<p><strong>原理</strong>：利用病毒最基本的特征——感染特征，所有病毒都会进行感染，如果不感染，就不称其为病毒</p>
<p>当系统中出现了异常行为，最新版的检测工具也查不出病毒时，就可以做感染实验，其方法是：</p>
<p>将正常的文件放入异常的系统中去运行，看这些正常文件是否会被感染，如果被感染，则文件内容会发生变化（通过校验和等检测），则断言系统中存在病毒</p>
<p><strong>优点</strong>：可以发现未知的病毒</p>
<p><strong>缺点</strong>：实验开销大，实用性较差</p>
<p><strong>六、软件模拟诊断法</strong></p>
<p>多态病毒每次感染都变化其病毒代码，对付这种病毒，特征码扫描法失效。我们把使用通常特征码扫描法无法检测（或几乎很难检测）的病毒称之为多态病毒。但是，每一个多态病毒在执行时都需要还原，如先执行一段解密代码进行解密，再执行解密后的病毒代码。</p>
<p>通过在一个模拟的虚拟环境下运行计算机病毒，等待计算机病毒自身进行解密完成后，再对解密后的病毒代码实施特征码的识别，识别病毒种类后再进行有相关的清除和查杀工作。</p>
<p><strong>七、分析诊断法</strong></p>
<p>分析法一般只被专业反病毒技术人员使用，使用分析法的目的在于：</p>
<p> - 确认被观察的引导扇区和程序中是否含有病毒 </p>
<p> - 确认病毒的类型和种类，判定其是否是一种新病毒</p>
<p> - 搞清楚病毒体的大致结构，提取特征识别用的字符串或特征字，并增添到病毒代码库供病毒扫描和识别程序使</p>
<p> - 详细分析病毒代码，为制定相应的反病毒措施制定方案</p>
<p>分析法是任何一个性能优良的反病毒系统研发所必须的，它是对病毒进行详尽认真的分析，专业人员需要了解PE文件格式、病毒的核心技术原理、汇编语言、Windows程序设计、软件调试方法等相关知识，还需要进行病毒样本收集、系统漏洞分析等工作。</p>
<p>分析法通常包括静态分析和动态调试两个步骤，Windows上一般的调试工具主要有OD、WinDBG、X64DBG等，对复杂的病毒程序，必须采用动、静结合的分析方法。</p>
<h3 id="启发式代码扫描技术"><a href="#启发式代码扫描技术" class="headerlink" title="启发式代码扫描技术"></a>启发式代码扫描技术</h3><p>启发式代码扫描技术是对传统的特征码扫描技术的改进，来源于人工智能技术</p>
<p><strong>原理</strong>：启发式代码扫描技术基于给定的判断规则和定义的扫描技术，若发现被扫描程序中存在可疑的程序功能指令，则作出存在病毒的预警或判断。</p>
<ol>
<li>可疑程序功能的权值定义</li>
<li>可疑程序的报警标准</li>
<li>可疑功能的标志</li>
</ol>
<h3 id="虚拟机查毒技术"><a href="#虚拟机查毒技术" class="headerlink" title="虚拟机查毒技术"></a>虚拟机查毒技术</h3><p>全虚拟化技术：虚拟的操作系统，与底层的硬件完全隔离，完全由中间的Hypervisor层（VMM）完成指令转换和资源映射，典型的代表有Vmware，WorkStation，Microsoft Virtual Server等</p>
<p>半虚拟化技术：需要在虚拟机的操作系统中加入特定的虚拟化指令（Hypercalls），通过这些加入的指令来调用硬件资源，免除了一部分Hypervisor层转换指令的开销。典型的代表有Xen等。</p>
<p>查毒的虚拟机是一个软件模拟的CPU，它可以象真正CPU一样取指令、译码、执行，可以模拟一段代码在真正CPU上运行得到的结果</p>
<p><strong>原理</strong>：虚拟机查毒实际上是自动跟踪病毒入口的解密代码，当其将加密的病毒体按其解密算法进行解密后，就可以得到解密后的病毒明文，虚拟执行技术使用范围远不止脱壳解密，它还可以应用在跨平台高级语言解释器、恶意代码分析、调试器等</p>
<p>目前有两种方法可以跟踪控制病毒的每一步执行，并能够在病毒循环解密结束后从内存中读出病毒体明文</p>
<ol>
<li>单步和断点跟踪法，和目前一些程序调试器相类似：易于被病毒发觉</li>
<li>虚拟执行法：  控制权永远掌握在虚拟机手中，但完全模拟CPU的运行并非易事，虚拟执行法的意味必须在虚拟机内部处理所有指令的执行，这就需要具有大量的特定指令处理函数来模拟每种指令的执行效果，因此，虚拟机必须要保证模拟结果的正确性，但同时不可能被病毒察觉，且做到了完全虚拟执行</li>
</ol>
<p>虚拟机模拟指令执行的设计方案：</p>
<ol>
<li>自含代码虚拟机(SCCE)：类似真正的CPU</li>
<li>缓冲代码虚拟机(BCE)：进行了特殊指令和非特殊指令的区分</li>
<li>有限代码虚拟机(LCE)：只简单地跟踪一段代码的寄存器内容</li>
</ol>
<h4 id="反虚拟执行技术"><a href="#反虚拟执行技术" class="headerlink" title="反虚拟执行技术"></a>反虚拟执行技术</h4><p>1.<strong>插入特殊指令技术</strong></p>
<p><strong>原理</strong>：虚拟机是模拟CPU的执行，并不是真正的CPU，所以不可以能对整个Intel的指令集进行支持，遇到不认识的指令就会停止工作</p>
<p><strong>应对</strong>：不需要针对每个特殊指令写专门的模拟函数，只需要构建特殊指令的指令长度表，当EIP指向特殊指令时，就跳过特殊指令长度，或者发现这些特殊指令时，交由CPU去真正执行</p>
<p>2.<strong>结构化异常处理技术</strong></p>
<p><strong>原理</strong>：虚拟机仅仅模拟了CPU的工作过程，而对于异常处理等系统机制没有进行处理，虚拟机会在遇到非法指令、进入异常处理函数前停止工作</p>
<p><strong>应对</strong>：为虚拟机赋予发现和记录异常的功能，并在引发异常时将控制转向异常处理函数</p>
<p><strong>3.</strong> <strong>入口点模糊技术（EPO）</strong></p>
<p><strong>原理</strong>：即便是虚拟执行，也不可能查找文件的所有代码，虚拟执行通常会在规定步数内，检查待查文件是否具有解密循环，如果没有，就会判定该文件没有携带加密变形病毒，产生漏报</p>
<p><strong>应对</strong>：合理的增加检查的规定步数，如果规定步数较小，极易产生漏报，但规定步数也不能盲目增加，否则会无谓增加检测时间，如何确定规定步数的大小实在是件难事</p>
<p><strong>4.</strong> <strong>多线程技术</strong></p>
<p><strong>原理</strong>：虚拟对于模拟启动多线程的工作很难与真实效果一致，多线程切换需要交由下层操作系统负责管理，虚拟机只能在被执行线程独占CPU时间</p>
<p><strong>应对</strong>：改进虚拟机，支持这些特定的操作系统机制</p>
<h3 id="病毒实时监控技术"><a href="#病毒实时监控技术" class="headerlink" title="病毒实时监控技术"></a><strong>病毒实时监控技术</strong></h3><p>病毒实时监控本质上是一个文件监视器：</p>
<p><strong>原理</strong>：在文件打开、关闭、清除、写入等操作时检查文件是否是病毒携带者，如果是则根据用户的决定选择不同的处理方案，如清除病毒、禁止访问该文件、删除该文件或简单地忽略，从而有效地避免病毒在本地计算机上的感染传播</p>
<p>可执行文件装入器在装入一个文件执行时首先会要求打开该文件，而这个请求又一定会被实时监控在第一时间截获到，它确保了每次执行的都是干净的不带毒的文件从而不给病毒以任何执行和发作的机会</p>
<h3 id="计算机病毒的清除"><a href="#计算机病毒的清除" class="headerlink" title="计算机病毒的清除"></a>计算机病毒的清除</h3><p>引导型病毒感染时常攻击计算机的如下部位：</p>
<ol>
<li><p>硬盘主引导扇区</p>
</li>
<li><p>硬盘或软盘的BOOT扇区</p>
<p>为保存原主引导扇区、BOOT扇区，病毒可能随意地将它们写入其他扇区，而彻底毁坏这些扇区中的信息</p>
<p>引导型病毒发作时，执行破坏行为造成种种损失</p>
<p>由于引导型病毒一般是常驻内存的，因此，清除病毒之前必须先清除内存中的病毒(或采用修复中断向量表等方法将其灭活)，否则难以清除干净</p>
</li>
</ol>
<h3 id="计算机病毒免疫技术"><a href="#计算机病毒免疫技术" class="headerlink" title="计算机病毒免疫技术"></a>计算机病毒免疫技术</h3><p><strong>重入检测和病毒免疫</strong></p>
<p>  大部分驻留内存的病毒会在加载病毒代码之前，检查系统的内存状态，判断内存中是否有病毒，若存在(自身已被加载)，则不再加载病毒代码</p>
<p>  感染文件之前，查看文件的状态(一般是查看感染标志)，检查该文件是否已被感染，如果被感染了则不再重复感染</p>
<p>   病毒的这种重入检测机制导致了一种反病毒技术的出现，也就是形形色色的免疫程序：利用免疫程序设置内存的状态、设置CPU的状态或者设置文件的一些特征，从而防止某种特定的病毒进入系统</p>
<p>目前常用的免疫方法有两种：</p>
<ol>
<li><p>针对某一种病毒进行的计算机病毒免疫</p>
</li>
<li><p>基于自我完整性检查的计算机病毒免疫</p>
</li>
</ol>
<h2 id="不负责猜题"><a href="#不负责猜题" class="headerlink" title="不负责猜题"></a>不负责猜题</h2><p>计算机病毒的定义?</p>
<blockquote>
<p>编制或者在计算机程序中<strong>插入</strong>的破坏计算机功能或者毁坏数据，影响计算机使用，并能自我复制的一组计算机指令或者程序代码。</p>
</blockquote>
<p>病毒的基本特征？</p>
<ul>
<li>传染性</li>
<li>隐蔽性</li>
<li>可触发性</li>
<li>其他一些基本特性<ul>
<li>破坏性</li>
<li>针对性</li>
<li>不可预见性</li>
<li>寄生性</li>
<li>衍生性</li>
<li>持久性</li>
</ul>
</li>
</ul>
<p>计算机病毒的本质属性?</p>
<blockquote>
<p>人为的<strong>特制程序</strong>是任何计算机病毒的<strong>固有本质属性</strong></p>
<p>程序性的<strong>客观性</strong>决定了计算机病毒的可防治性和可清除性</p>
<p><strong>人为性</strong>的<strong>主观性</strong>导致计算机病毒各异多变</p>
</blockquote>
<p>木马和蠕虫的概念：</p>
<blockquote>
<p>蠕虫:独立的可执行程序, 不需要寄生在宿主程序中，通过网络分发自己的副本，工作方式为：漏洞扫描、远程攻击、迁移传染、现场处理</p>
<p>木马：在远程计算机之间建立连接，使得远程计算机能通过网络控制本地计算机的非法程序。木马系统软件一般由木马配置程序、控制程序和木马程序(服务端)三部分组成。</p>
</blockquote>
<p>小端机和大端机？</p>
<blockquote>
<p>整数逻辑上的最低字节放在内存的最低地址，次低字节放内存的次低地址，依次存放。比如，0x12345678（12为高位）放在内存中就是78 56 34 12(最左边为低字节)。大端机则相反</p>
</blockquote>
<p>JMP指令计算偏移量？</p>
<blockquote>
<p>从JMP指令的开始计算，直接加5。或者说是从JMP的下一条开始的指令算起被减数。</p>
</blockquote>
<p>文件系统（重点）</p>
<blockquote>
<p>一个FAT9个扇区，引导扇区1个，根目录区有224条记录，一个记录32字节，一个表项1.5字节</p>
<ul>
<li>数据区中存放用户数据,是文件和子目录数据真正存放的区域</li>
<li>根目录区中存放的是文件目录表,为记录根目录文件项的表，文件项包括文件，目录。通过它可以查找到根目录下的文件和目录信息，比名称，大小，日期等</li>
<li>FAT12为<strong>文件分配表</strong>（FAT（File Allocation Table））：记录已分配的扇区和可用扇区，并通过链表依序记录一个文件占用的扇区,另外一个FAT12为备用的FAT表</li>
<li><strong>引导扇区</strong>（DBR （DOS Boot Record））：记录磁盘和文件系统相关的各种参数，比如扇区大小，一簇的扇区数等</li>
</ul>
</blockquote>
<p><strong>如何定位一个文件？</strong></p>
<blockquote>
<p>FAT12文件系统中，FAT表以3个<strong>半字节</strong>（3*0.5 Byte = 1.5 Byte = 12 bit）来记录一个簇的相关情况，这也是“FAT12“文件系统中命名12的原因。</p>
<p>FAT表的本质是磁盘簇分配情况的数据表示，FAT表中每3个半字节为一个元素，这个元素就代表一个簇，簇号从0开始，这个元素中存放的整数值表示其链接的下一簇的簇号</p>
</blockquote>
<ul>
<li>查找和遍历</li>
</ul>
<blockquote>
<p>类似于链表的查找，以FFF为结尾，FAT12默认设置引导区占一个扇区，FAT1于其后，同时FAT表开始的3个字节没用于用户文件分配，3字节有2组12bits所以，占用了0,1两个簇号，用户的数据从簇2开始分配。</p>
<p>随后FAT表从头开始按3字节分成一组，但是有一点需要特别注意：</p>
<p>在这3个字节中，用第2字节的低半字节和第1字节形成整数表示一个簇号，用第2字节的高半字节和第3字节形成的整数来表示另一个簇号</p>
<p>由上面学习的内容知道，在FAT表中想要开始遍历就必须知道首簇号，而首簇号位于根目录区域中。</p>
</blockquote>
<blockquote>
<p>计算根目录区的起始位置为：<strong>[ 1（Boot区扇区数）+2（FAT数目）*9（FAT扇区数）] * 512 = 0x2600</strong></p>
<p>每一条记录，从该记录开始偏移0xB处有个字节指示出文件的类型，对于多级目录来说，则是存放在数据区内，原理和根目录查找目录类似，只不过是多层嵌套，查找到的是另一个目录表。</p>
</blockquote>
<p>查找<strong>a:\tem\tem.txt</strong>为例：</p>
<p><img src="/posts/41006/2.png" alt></p>
<p>如何恢复只有一个簇的文件？</p>
<blockquote>
<p>文件内容不会因删除而改动。而对应文件的项只是将第一个字节改成E5，其首簇段的值也不会该动</p>
<p>在目录表中找到E5开始的相关文件名，从该项的首簇字段（0x1A）获得首簇，然后，在FAT表中对应的簇项改成FFF即可</p>
</blockquote>
<p><strong>FAT12和FAT32的区别</strong></p>
<blockquote>
<ul>
<li>FAT32的一个重要不同在于<strong>取消了根目录区</strong>，根目录在用户区，且FAT32引导记录中有一个指向根目录区的首簇字段</li>
<li>fat32支持长文件名而fat12不支持(FAT12文件名固定11字节，其中3字节用于后缀)</li>
<li>fat12一个表项占1.5个字节而fat32一个表项占4个字节</li>
<li>fat32有保留区而fat12没有</li>
<li>FAT32的记录项中的首簇号，由两个字段构成，分别代表高位两字节和低位两字节</li>
</ul>
</blockquote>
<p>硬盘数据结构</p>
<p>MBR和EBR</p>
<blockquote>
<p><strong>扩展分区</strong>核心思想是：形成一个分区链，MBR定义的主分区表本来有4条分区记录，用一条描述自己分区的信息，用剩余的指向下一个分区。</p>
<p>为了完全兼容MBR的格式，EBR完全复用了引导扇区的格式，即起始446字节给引导记录EBR，但在EBR中，这些内容全为0。</p>
<p>主分区的相对扇区相对于MBR，通过MBR和相对扇区就可以定位每一个主分区</p>
</blockquote>
<p><img src="/posts/41006/7.png" alt></p>
<blockquote>
<p>首先找到C盘，找到主引导扇区的分区表，找到分区的相对偏移扇区数，扩展分区1是MBR的主扩展分区，它的EBR放在主扩展分区的开始处</p>
<p>找到扩展分区1的EBR。</p>
<p>随后查找扩展分区1上的基本分区E盘，</p>
<p>同理查找扩展分区2的EBR和分区表</p>
<p>最后利用相对偏移字段和首部偏移查找F盘的起始位置</p>
<p>注意EBR是相对于包含该分区表的扩展区开始处而言（扩展分区开始处为其EBR），在扩展分区的分区表中，第一项的偏移指向的是盘区，第二项的偏移指向的是下一个扩展分区开始处（也就是下一个扩展分区的EBR）</p>
</blockquote>
<p>硬盘的引导过程</p>
<p>分区表项的第一个字节0x80表示激活</p>
<blockquote>
<ul>
<li>开机加电自检：开机，CPU跳到内存FFFF:0000处，由该处的一条JMP指令跳到BIOS的自检程序（POST），自检通过后，加载引导程序（与操作系统无关的MBR，按用户在BIOS中的指定顺序，硬盘、软盘、光驱或U盘等</li>
<li>读主引导扇区：将主引导扇区MBR读入到内存的0000:7C00，扫描主分区表，搜索激活分区，分区表项第一个字节为0x80表示激活分区</li>
<li>读激活分区引导扇区 ：如果有多个激活分区或没有，报错结束。否则读取激活分区引导扇区到0000:7c00</li>
<li>操作系统引导代码引导系统并读取操作系统初始化文件</li>
</ul>
</blockquote>
<p>MBR代码拷贝的问题</p>
<blockquote>
<p>MBR的这段代码会被加载到7C00处，这段代码的主要任务是什么呢？是找到激活分区（如C盘）并将真正C盘的引导扇区加载到7C00处（也就是拷贝），这必然覆盖已经在内存7C00处的MBR自己，当自己正在拷贝的另外的指令覆盖自己时，必然破坏了自己的指令执行逻辑。</p>
<p> 所以，要错开<strong>MBR引导程序</strong>和<strong>激活分区引导程序</strong>占用的内存空间范围，让MBR的引导程序在600h执行，而它拷贝的激活分区引导程序将在7C00h执行</p>
</blockquote>
<p>头插入病毒遇到的问题</p>
<blockquote>
<p>需要去掉病毒代码最后的RET指令，否则原本的COM文件得不到执行机会</p>
<p>病毒代码执行结束后需用一条JMP指令跳过病毒数据区</p>
<p>加载后的实际内存位置后移, 后移长度就是virus.com的机器码长度</p>
<p>将源程序复制到原先的位置时候需要避免自我覆盖</p>
</blockquote>
<p>尾插入中的思路</p>
<blockquote>
<p>1） 构造一个打印的正常代码normal.com</p>
<p>2）构造一个寄生在normal.com尾部的病毒代码virus.com</p>
<p>3）用DOS的拷贝命令将两个编译好的程序粘起来</p>
<p>4）将normal.com开始的3字节作为数据保存到virus.com的代码某部分，然后将normal.com开始的3字节修改（先用UE手动修改）为JMP XXXX（跳到virus.com指令处）。</p>
<p>5）virus.com打印“I am virus”后，将normal.com开始的3字节进行还原，并JMP到normal.com开始，将执行权限交给normal.com</p>
</blockquote>
<p>为什么计算机病毒往往需要重定位技术？病毒重定位技术的关键技术原理是什么？以下重定位代码中，语句（1）-（4）在变量Message重定位过程中发挥的作用分别是什么？</p>
<pre><code>（1） call base
 base:
（2） pop bp
（3） sub bp, base
​     mov ax, bp
（4） add ax, Message</code></pre><blockquote>
<p>病毒的寄生会导致指令所在位置发生变化，从而导致预期加载地址和实际地址不一致的情况；知道一条指令<strong>运行时的地址值</strong>和<strong>编译时的地址值</strong>，相减即可；</p>
<p>Call指令的下一条指令是pop ax，call执行时，首先会把pop ax指令的IP（即pop ax这条指令的实际地址）<strong>压栈</strong>，然后根据<strong>相对偏移</strong>跳到标号here处；</p>
<p>标号base处就是pop bp指令，执行这条<strong>出栈</strong>指令会把栈中数据放入bp中，也就是pop bp指令的IP，利用栈获得了IP的值</p>
<p>Sub语句中的标号base在编译时就生成了地址，但是是<strong>预期地址</strong>,现在，实际地址-预期地址，ax中放的就是加载偏差了</p>
<p>将编译期要用的的地址，比如字串的首址加上ax就是字串实际地址了</p>
</blockquote>
<p>逆插入病毒</p>
<blockquote>
<p>与前面不同，我们需要添加一段完成感染寄生的代码，但这段代码自身不寄生在原文件上，它只需要完成以下功能：</p>
<p>1.把正常程序向后拷贝HdrVirus长度</p>
<p>2.把HdrVirus部分拷贝到前面</p>
<p>3.把EndVirus部分拷贝到后面</p>
</blockquote>
<p><img src="/posts/41006/9.png" alt></p>
<blockquote>
<p>头病毒部分因为存在加载偏差,需要重定位,并且需要为尾病毒拷贝设置参数.</p>
<p>重定位有关的代码在头病毒部分已经设置完成,因此不需要额外设置.</p>
</blockquote>
<p>感染部分思路</p>
<blockquote>
<p>1 ）获取原文件大小，后续写入需要</p>
<p>-———————————————</p>
<p>2 ）将原文件扩容，增加hdrvirusSize（头病毒部分长度）个字节，通过在原文件的尾部写字节完成</p>
<p>-———————————————</p>
<p>3 ）原文件向后拷贝hdrvirusSize长度，腾出空间给头病毒部分。注意：原文件应从尾至头完成拷贝，如果采取从头至尾的拷贝，则当原文件大小&gt;移动长度时，就会产生覆盖</p>
<p>-———————————————</p>
<p>4）将HdrVirus部分写入头部</p>
<p>-———————————————</p>
<p>5）将EndVirus部分写入尾部</p>
<p>不用事先扩容，写直接完成扩容</p>
</blockquote>
<p>引导型病毒</p>
<blockquote>
<p><strong>执行过程：</strong>病毒先把自己加载到7C00h，然后又把原引导程序拷贝到7C00h，这个过程会出现什么问题？就是前面遇见的<strong>自我覆盖</strong>问题，所以需要将病毒中执行拷贝的指令段移出被覆盖的区域。我们可以将它后移一个扇区7e00h处</p>
<p><strong>感染过程：</strong>感染会将原引导扇区的内容一直放到簇2，如何避免后续使用占用簇2，破坏了病毒的逻辑？可以修改FAT1和FAT2表，将簇2的项改成不可使用，如果改为已占用FFF，但却没有对应的目录项，是可疑的，因此，可以改为坏簇FF7，从而防止别人使用它。这些感染，为了简单，没有采用汇编访问硬盘的方式，而是采用C语言来直接修改软盘文件。</p>
</blockquote>
<p>中断替换</p>
<blockquote>
<p>病毒篡改中断向量表内容指向Hook，Hook函数执行完自己的逻辑后在正常跳回到中断处理程序处，并将原地址协会中断向量表中，当病毒和中断向量表在<strong>不同的段</strong>时，约定AX放段内偏移，CX放段地址。若需要内存驻留则直接调用DOS提供的驻留退出中断int 27h</p>
</blockquote>
<p>链式病毒思路</p>
<blockquote>
<p>病毒在感染时，完全不改变宿主程序本体，而是改动或利用与宿主程序相关的信息，将病毒程序与宿主程序连成一体。</p>
<p><strong>一、感染部分</strong></p>
<ul>
<li>被感染文件的真实起始扇区号写到<code>目录表项的保留区</code>（目录项的保留区从目录项头第13个字节即偏移0ch开始，共10字节）</li>
<li>修改被感染文件的目录项的<code>起始扇区字段</code>指向病毒文件的首簇</li>
<li>目录项中的<code>文件大小字段</code>也要修改成病毒的真实大小，这样才能保证病毒能被完整加载</li>
<li>将原来病毒文件的目录项全部32字节改为0，这样从外部看就不存在这个病毒文件，也没有对应的目录项了</li>
</ul>
<p><strong>二、执行部分</strong></p>
<ul>
<li>病毒运行后，先获取被<code>感染程序的名字</code></li>
<li>然后从根目录寻找<code>被感染程序的目录项</code></li>
<li>找到后从该目录项的保留区获取<code>被感染程序的首簇号</code></li>
<li>找到被感染程序所在簇（即扇区），加载该扇区到内存</li>
</ul>
</blockquote>
<p>PE结构，如何从一个PE文件中找到程序入口的文件地址的方法</p>
<p><img src="/posts/41006/19.png" alt></p>
<blockquote>
<p>寻找可选头中的 AddressOfEntryPoint，利用RVA找到该值所属的节，如果该节的起始RVA和该节的起始文件偏移相等则直接作为偏移，否则利用偏移量计算出新的值</p>
<p>（入口点的RVA（AddressOfEntryPoint）- 节的RVA = 入口点的FOA - 节的起始文件位置（PointerToRawData） )</p>
<p>随后寻找可选头中另外一个字段<strong>ImageBase</strong>，即程序约定加载地址，该地址加上入口点偏移</p>
<p>程序入口地址VA：ImageBase+AddressOfEntryPoint</p>
</blockquote>
<p>RVA和FOA的联系与区别</p>
<blockquote>
<ul>
<li>RVA是内存的相对位置，相对的是加载到内存的基地地址</li>
<li>FOA是文件中的相对位置，相对的是文件开始位置（即0）</li>
</ul>
</blockquote>
<p>用程序完成末段大小不变的寄生</p>
<blockquote>
<ol>
<li><p>生成需要寄生的病毒代码</p>
</li>
<li><p>获得被感染文件的NT头</p>
<ol>
<li>利用DOS头的e_lfanew字段（文件定位）</li>
<li>定位NT头，读到ntHrds（文件定位读）</li>
</ol>
</li>
<li><p>找到最后一个节判断是否具有空洞</p>
<ol>
<li><p>如何判断节是否有空洞？</p>
<p><strong>virtualSize &lt; SizeofRawData</strong></p>
</li>
<li><p>这些信息在哪里？</p>
<p><strong>最后一个节的节表项中</strong></p>
</li>
<li><p>当前的文件指针在什么地方？</p>
<p><strong>之前读了NT头，现在在NT头的后面也就是节表的起始文件位置</strong></p>
</li>
</ol>
</li>
<li><p>修改最后一个节VirtualSize写入病毒</p>
</li>
<li><p>修改SizeofImage和EntryPoint</p>
</li>
</ol>
</blockquote>
<p>入口点模糊技术(Entry Point Obscuring)</p>
<blockquote>
<p>每个节的节表项有一个characteristics属性,说明了该节是干什么的,当IMAGE_SCN_CNT_CODE为20时说明是代码节. EPO技术能够让病毒代码隐藏自己入口点，避免被查杀,使得被病毒修改后的入口点看起来依然就像是正常的入口点.</p>
<p>解决入口点不在代码段的问题，我们可以采用下2种解决方法：</p>
<p>1）不感染最后一节，直接感染代码节，病毒代码附着在代码节的尾部，再修改入口点。这样虽然修改了入口点，但让入口点处于代码节</p>
<p>2）不修改入口点，但将入口点所在的指令替换成一条JMP指令，跳往到寄生的病毒代码</p>
</blockquote>
<p>感染在代码节的空洞</p>
<blockquote>
<ol>
<li><p>生成需要寄生的病毒代码</p>
</li>
<li><p>获得被感染文件的NT头</p>
</li>
<li><p>找到代码节并判断是否具有空洞</p>
<p>如何找到代码节？遍历所有节表项并判断节表项的属性是否有20属性</p>
</li>
<li><p>修改VirtualSize写入病毒</p>
</li>
<li><p>修改SizeofImage和EntryPoint</p>
</li>
</ol>
</blockquote>
<p>感染最后节并替换入口指令</p>
<blockquote>
<ol>
<li>修改原入口点的数据为JMP指令</li>
<li>保存被覆盖的5个字节</li>
<li>执行逻辑</li>
<li>恢复这5个字节<ul>
<li>源地址就是被覆盖的5个字节，放在数据区，所以我们把可以把<strong>数据区的起始地址</strong>也作为数据放入数据区</li>
<li>目的地址是原程序的<strong>入口点地址</strong>，寄生后，病毒的main函数就结束了，所以这个<strong>入口点地址</strong>也需要写入数据区时</li>
</ul>
</li>
<li>最后一条JMP跳回原入口点</li>
</ol>
</blockquote>
<p>ImageBase是程序<strong>预期</strong>加载的基地址，win7系统和vs编译器往往都采用了随机地址空间技术，使得程序即每次加载的<strong>实际</strong>地址并不是ImageBase，原文件有重定位表这样的机制帮助重定位，但病毒只能利用前面我们学到的<strong>自定位</strong>技术原理。</p>
<p>病毒真正获取API函数地址的方法</p>
<blockquote>
<p>一、获取DLL基址</p>
<p>只有找到DLL基地址，我们才能找到它的导出表，才能找到所要调用函数的地址,利用PEB结构（Process Environment Block，进程环境块）查找，每个进程都对应一个PEB。然后，PEB结构保存着另外一个指针，该指针指向一个叫PEB_LDR_DATA的结构</p>
<p>这个PEB_LDR_DATA 偏移0C处是<strong>加载模块链表</strong>的头指针，由8个字节组成，前4个字节指向一个LDR_MODULE结构体（LDR_MDOULE代表一个模块，每一个模块（exe,dll）都对应一个这样的结构体），在该LDR_MODULE中，头4字节又指向下一个加载的LDR_MODULE结构体，由此组成链表。</p>
<p>在win7下，第一个加载的模块是是执行程序本身，第2个是NTDll，第3个就是kernel32，在结构体偏移0x18处就是所对应模块的基址。</p>
<p><strong>那如何在遍历的过程中识别模块呢？</strong></p>
<p>在LDR_MODULE结构体偏移0x2C的地方，有一个成员BaseDllName，它有8个字节，其中后4字节为地址，指向一个unicode串（每个字符占2个字节），这个unicode串就是不包含路径的纯模块名。</p>
<p>遍历的结束条件是什么？Next指针为0或者ffffffff么？都不是，过调试我们可以发现，在win7下，加载模块链形成了一个循环链表，因此只要发现next块的头4字节是头块地址就停止遍历。</p>
<p> 二、获取DLL中的函数地址</p>
<p>找到基址后，我们必须手动完成由函数名获取其所在DLL中地址的过程，我们需要从DLL的实际基址入手，解析DLL的导出表，获取相关函数的入口地址。</p>
</blockquote>
<p>导出表—DLL对外暴露函数地址的机制</p>
<blockquote>
<p>序号查找</p>
<p>序号查找的好处：快！高效！</p>
<p>我们可以用一个简单的hash完成，而不需要遍历，如果我们用一个数组（funcEntryTb）存储函数的入口地址。第0号函数的入口地址就存入数组的第一个元素funcEntryTb[0]，第1号函数的就存入数组的第2个元素funcEntryTb[1]。这样获取入口地址非常简单 ，即funcEntryTb[n]，n是函数的序号，也就是拿到数组首址funcEntryTb加偏移n*4（每个地址4个字节）即可。类似DOS下的中断向量表。</p>
<p>如果序号不是从0开始，而是从n开始，我们依然是将n对应函数的入口地址存入第一个元素，依次类推。获取第M（M肯定大于n，因为n最小）号函数的地址如下： funcEntryTb[m - n]。依然非常快速，计算次数固定，即拿到首址funcEntryTb，做一次减法m-n，再做一次乘法(m - n)*4就获取到元素的地址，取出其值保存值即可。这其实也是c语言switch语句出来case中序号和case分支入口地址的方法，所以一般switch比if else嵌套快</p>
<p>但是序号查找不够直观，同时也不够稳定</p>
<p>用函数名查找</p>
<p>用函数名查找：直观！具体！</p>
<p>最简单的办法就是一个一个函数名字串比较，找到相同的串。下面给出一个简单实现：函数名表的索引和函数地址表的索引是一一对应的。如果查找func2函数地址，我们先遍历函数名表，每遇到\0就是一个串，自然，在第2串处找到了字串func2，fun2是函数名表第2项，索引为1，然后我们用索引1在函数地址表中获得了address2，函数地址表4字节一个元素<strong>通过两个表相同的索引建立关联</strong>。</p>
</blockquote>
<p>导出函数查找算法</p>
<blockquote>
<ol>
<li><p>从DLL加载的<strong>实际基址</strong>获取可选头，从其中<strong>数据目录表</strong>的第一项找到导出表入口RVA</p>
</li>
<li><p>从导出表的表头获取Number of names，即查找的最大循环次数</p>
</li>
<li><p>循环遍历<strong>函数名指针表</strong>，比对每项RVA指向的字串是否为要找的函数名</p>
<p><code>函数名指针表1项4字节 à 对应的字符串地址</code></p>
</li>
<li><p>如果找到，记下此时函数名指针表项的索引，设为 i</p>
</li>
<li><p>根据索引 i，在<strong>序号表</strong>中找到对应项，获取其内容为n</p>
<p><code>序号表1项2字节</code></p>
</li>
<li><p>以n为索引在<strong>函数地址表</strong>中找到函数入口的RVA，加上DLL的实际基址即为函数的实际入口地址</p>
<p><code>地址表1项4字节</code></p>
</li>
</ol>
<p>注：以上算法中，所有访问实际地址的地方，就用<code>DLL的实际加载基址+RVA</code>即可</p>
</blockquote>
<p>导入表机制</p>
<p>RVA指向导入表（IMPORT DICTORY TABLE）起始，在这个地方，每一项是一个IMAGE_IMPORT_DESCRIPTOR结构，代表一个导入的DLL的相关信息。在这个结构中，又有：</p>
<blockquote>
<p>INT表（Import Name Table）和IAT表（Import Address Table）的RVA</p>
</blockquote>
<p><img src="/posts/41006/25.png" alt></p>
<p><img src="/posts/41006/26.png" alt></p>
<p>如何找到需要Patch的指令</p>
<blockquote>
<ol>
<li>在文件中找到导入表的位置：先找到导入表的RVA，将RVA转换为导入表的文件位置</li>
<li>找到指定API函数在IAT表中的表项地址。先要找到API所在DLL对应的项，然后才能找到这个DLL所对应的INT和IAT表，比较dll的名字，判断是否是API函数所在DLL的导出表目录项，然后根据预先绑定，如果有INT就用INT表来找函数名，没有就用IAT表找函数名，获得INT表（或IAT表）的RVA，并将其转换为文件位置，遍历INT表（或IAT表）的每一项，查找指定的API函数名。</li>
<li>找到符合的指令进行Patch，先找到代码所在的节，判断节的属性是否有0x20，找到后开始循环遍历每个字节进行替换，并写入patch指令。</li>
</ol>
</blockquote>

            </div>
            <hr/>

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/UESTC/">
                                    <span class="chip bg-color">UESTC</span>
                                </a>
                            
                                <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92%E5%8E%9F%E7%90%86%E4%B8%8E%E9%98%B2%E8%8C%83/">
                                    <span class="chip bg-color">计算机病毒原理与防范</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share"
                     style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">
    
        <div class="social-share" data-sites="wechat,qq,weibo,twitter,facebook,linkedin"
             data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
        <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    /* 修复评论第一行位置错位 */
    .v .vlist .vcard {
        padding-top: 2.5em !important;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling"
         style="font-size: 20px; font-weight: 700; position: relative; left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fa fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid"></div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: '98JpzSGcrl9jFqHO13vqxHvX-gzGzoHsz',
        appKey: 'mDmr2h9PB20xvPMNqgyRnNIC',
        notify: 'true' === 'true',
        verify: 'true' === 'true',
        visitor: 'true' === 'true',
        avatar: 'mm',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: 'just go go'
    });
</script>
    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
            <div class="article col s12 m6" data-aos="fade-up">
                <div class="article-badge left-badge text-color">
                    <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
                <div class="card">
                    <a href="/posts/56075/">
                        <div class="card-image">
                            
                                
                                <img src="/medias/featureimages/9.jpg" class="responsive-img" alt="Scheme入门教程">
                            
                            <span class="card-title">Scheme入门教程</span>
                        </div>
                    </a>
                    <div class="card-content article-content">
                        <div class="summary block-with-text">
                            
                                Scheme快速入门
                            
                        </div>
                        <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2021-03-05
                        </span>
                            <span class="publish-author">
                                
                                    <i class="fa fa-bookmark fa-fw icon-category"></i>
                                    
                                        <a href="/categories/%E6%9D%82%E8%AE%B0/" class="post-category">
                                    杂记
                                </a>
                                    
                                
                            </span>
                        </div>
                    </div>
                    
                        <div class="card-action article-tags">
                            
                                <a href="/tags/Scheme/">
                                    <span class="chip bg-color">Scheme</span>
                                </a>
                            
                        </div>
                    
                </div>
            </div>
        
        
            <div class="article col s12 m6" data-aos="fade-up">
                <div class="article-badge right-badge text-color">
                    下一篇&nbsp;<i class="fa fa-chevron-right"></i>
                </div>
                <div class="card">
                    <a href="/posts/52979/">
                        <div class="card-image">
                            
                                <img src="medias/imgs/52979/1.png" class="responsive-img" alt="[漫语]葬送的芙莉莲">
                            
                            <span class="card-title">[漫语]葬送的芙莉莲</span>
                        </div>
                    </a>
                    <div class="card-content article-content">
                        <div class="summary block-with-text">
                            
                                难得一见的优秀漫画
                            
                        </div>
                        <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2021-01-07
                            </span>
                            <span class="publish-author">
                                
                                    <i class="fa fa-bookmark fa-fw icon-category"></i>
                                    
                                        <a href="/categories/%E6%9D%82%E8%AE%B0/" class="post-category">
                                    杂记
                                </a>
                                    
                                
                            </span>
                        </div>
                    </div>
                    
                        <div class="card-action article-tags">
                            
                                <a href="/tags/%E6%9D%82%E8%AE%B0/">
                                    <span class="chip bg-color">杂记</span>
                                </a>
                            
                        </div>
                    
                </div>
            </div>
        
    </div>
</article>
</div>




<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

    <script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

    <script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

    <script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

    <style type="text/css">
        code[class*="language-"], pre[class*="language-"] {
            white-space: pre !important;
        }
    </style>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

    <div id="floating-toc-btn" class="hide-on-med-and-down">
        <a class="btn-floating btn-large bg-color">
            <i class="fa fa-list"></i>
        </a>
    </div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h2, h3, h4, h5'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4, h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换 TOC 目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="/about" rel="external nofollow noreferrer">JoyTsing</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            <span id="sitetime">载入运行时间...</span>
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="fa fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                                                                       class="white-color"></span>&nbsp;次
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fa fa-user"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                                                                         class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
                <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
                    document.write(unescape("%3Cspan id='cnzz_stat_icon_1278523400'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s4.cnzz.com/z_stat.php%3Fid%3D1278523400%26online%3D1%26show%3Dline' type='text/javascript'%3E%3C/script%3E"));
                </script>
                <br>
            
            
                
                    &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;<span
                            class="white-color">297k</span>&nbsp;字
                
                
                <script>
                    function siteTime() {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2019";
                        var startMonth = "7";
                        var startDate = "24";
                        var startHour = "0";
                        var startMinute = "0";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);
                        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                            minutes);
                        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                            diffMinutes * minutes) / seconds);
                        if (startYear == todayYear) {
                            document.getElementById("year").innerHTML = todayYear;
                            document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                                " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                                " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                        }
                    }

                    setInterval(siteTime, 1000);
                </script>
            

        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/JoyTsing" class="tooltipped" target="_blank"
       data-tooltip="访问我的GitHub"
       data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>


















</div>
    </div>
</footer>

<div class="progress-bar"></div>



<!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
    $(function () {
        searchFunc("/search.xml", 'searchInput', 'searchResult');
    });
</script>
<!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


<script src="/libs/materialize/materialize.min.js"></script>
<script src="/libs/masonry/masonry.pkgd.min.js"></script>
<script src="/libs/aos/aos.js"></script>
<script src="/libs/scrollprogress/scrollProgress.min.js"></script>
<script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
<script src="/js/matery.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->


<!-- Baidu Analytics -->


<!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>




    <script async src="/libs/others/busuanzi.pure.mini.js"></script>


<script type="text/javascript">
    var OriginTitile = document.title,
        st;
    document.addEventListener("visibilitychange", function () {
        document.hidden ? (document.title = "(oﾟvﾟ)ノ Hi", clearTimeout(st)) : (document.title =
            "(*´∇｀*) 欢迎回来！", st = setTimeout(function () {
            document.title = OriginTitile
        }, 3e3))
    })
</script>

<!-- 在线聊天工具  -->



<!-- 背景 canvas-nest -->

    <script type="text/javascript" color="0,0,255"
            pointColor="0,0,255" opacity='0.8'
            zIndex="-1" count="150"
            src="/libs/background/canvas-nest.js"></script>



    <script src="/libs/instantpage/instantpage.js" type="module"></script>



        <script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script>
        <script>
        const hasAttr = (e,a) => a.some(_=> e.attr(_)!==undefined);
        $('a').each(function() {
          const $this = $(this);
          if(hasAttr($this,["data-fancybox","ignore-external-link"])) return;
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== '' || window.location.host) {
                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });
        </script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":150,"height":200},"mobile":{"show":false},"react":{"opacity":0.7}});</script></body>
</html>