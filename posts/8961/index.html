<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="Cpp Core Guidelines, 博客 JoyTsing blog"><meta name="description" content="前言这篇文章实际上是C++ Core Guidelines解析的转载加上一些自己的理解(相当于自己集合一些觉得精华的内容放在自己blog上),废话少说。开始挖坑！
C++ Core Guidelines 由 16 个主要部分组成：

简介
"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="theme-color" content="white"><title>Cpp Core Guidelines | JoyTsing</title><link rel="apple-touch-icon" href="/"><link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="/favicon.ico"><link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css"><link rel="stylesheet" type="text/css" href="/libs/aos/aos.css"><link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css"><link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" type="text/css" href="/css/matery.css"><link rel="stylesheet" type="text/css" href="/css/my.css"><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style><script src="/libs/jquery/jquery.min.js"></script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="JoyTsing" type="application/atom+xml"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><img src="/apple-touch-icon.png" class="logo-img" alt="LOGO"> <span class="logo-span">JoyTsing</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fa fa-home"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-tags"></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-bookmark"></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-archive"></i> <span>归档</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa fa-user-circle-o"></i> <span>关于</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa fa-envelope"></i> <span>留言</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa fa-address-book"></i> <span>友链</span></a></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fa fa-search" title="搜索"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="/medias/avatars/touxiang2.jpg" class="logo-img circle responsive-img"><div class="logo-name">JoyTsing</div><div class="logo-desc">寒冬本来就冷, 还要吵个不停</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="m-nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-fw fa-bookmark"></i> 分类</a></li><li class="m-nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li class="m-nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa fa-fw fa-user-circle-o"></i> 关于</a></li><li class="m-nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa fa-fw fa-envelope"></i> 留言</a></li><li class="m-nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa fa-fw fa-address-book"></i> 友链</a></li><li><div class="divider"></div></li><li><a href="https://github.com/JoyTsing" class="waves-effect waves-light" target="_blank"><i class="fa fa-github-square fa-fw"></i>Follow Me</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#000;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href="https://github.com/JoyTsing" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Follow Me" data-position="left" data-delay="50"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a></nav></header><div class="bg-cover pd-header post-cover" style="background-image:url(/medias/featureimages/6.jpg)"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">Cpp Core Guidelines</h1></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{width:345px;padding-left:20px}.toc-widget .toc-title{margin:35px 0 15px 0;padding-left:17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content{height:calc(100vh - 250px);overflow:auto}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px;position:absolute;right:23.5vw;display:block}#toc-content .is-active-link{color:#42b983}#floating-toc-btn{position:fixed;right:15px;bottom:76px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/C/"><span class="chip bg-color">C++</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/Cpp/" class="post-category">Cpp</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp; 2023-12-05</div><div class="post-date info-break-policy"><i class="fa fa-calendar-check-o fa-fw"></i>更新日期:&nbsp;&nbsp; 2023-12-12</div><div class="info-break-policy"><i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp; 5.4k</div><div class="info-break-policy"><i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp; 20 分</div><div id="busuanzi_container_page_pv" class="info-break-policy"><i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp; <span id="busuanzi_value_page_pv"></span></div></div></div><hr class="clearfix"><div class="card-content article-card-content"><div id="articleContent"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章实际上是<a href="https://zhuanlan.zhihu.com/p/662592729">C++ Core Guidelines</a>解析的转载加上一些自己的理解(相当于自己集合一些觉得精华的内容放在自己blog上),废话少说。开始挖坑！</p><p>C++ Core Guidelines 由 16 个主要部分组成：</p><ul><li>简介</li><li>理念</li><li>接口</li><li>函数</li><li>类和类的层次结构</li><li>枚举</li><li>资源管理</li><li>表达式和语句</li><li>性能</li><li>并发性</li><li>错误处理</li><li>常量和不变性</li><li>模板和泛型编程</li><li>C 风格编程</li><li>源文件</li></ul><h2 id="理念"><a href="#理念" class="headerlink" title="理念"></a>理念</h2><p>理念性规则概览：理念性规则强调一般性，因此，无法进行检查。不过，理念性规则为下面的具体规则提供了理论依据。一共有 13 条理念性规则。可以简单理解为一般情况下的编码规范。</p><h3 id="P-1-在代码中直接表达思想"><a href="#P-1-在代码中直接表达思想" class="headerlink" title="P.1 在代码中直接表达思想"></a>P.1 在代码中直接表达思想</h3><p>编译器是不会去读注释（或设计文档）的，许多程序员也（固执地）不去读它们。 而代码中所表达的东西是带有 明确的语义 的，并且（原则上）是可以由编译器和其他工具进行检验的。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Date</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    Month <span class="token function">month</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 好</span>
    <span class="token keyword">int</span> <span class="token function">month</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 不好</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一个 <code>month</code> 比第二个，有更多的信息，以 <code>const</code> 修饰，代表不会修改当前的日期，返回类型 <code>Month</code> 也非常明确。</p><blockquote><p>成员函数修饰 <code>const</code> 是为什么，能做什么。只是默认，不修改当前类的数据成员就要加 <code>const</code>，明确语义，增加可读性。 <strong>但不够正确，也远不止如此</strong>。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>

<span class="token keyword">class</span> <span class="token class-name">Date</span> <span class="token punctuation">{</span>
    <span class="token keyword">using</span> Month <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    Month m<span class="token punctuation">;</span>

    <span class="token keyword">int</span> <span class="token function">month</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> m<span class="token punctuation">;</span> <span class="token punctuation">}</span>          
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date<span class="token operator">&amp;</span> date<span class="token punctuation">)</span><span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> date<span class="token punctuation">.</span><span class="token function">month</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    Date d<span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">func</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码会得到一个编译错误，这应该是很常见的调用方式。为什么呢？显然，就是因为 <code>month</code> 成员函数没有以 <code>const</code> 修饰。<strong><code>C++</code> 不允许 const 的对象调用没有以 const 修饰的成员函数</strong>，事实上这个语义非常的合理：我都是 const 对象了，你为啥要修改？但是明明 <code>month</code> 函数根本没有修改对象的数据，所以这其实是开发者的问题，不应该写出这种代码。当前的语境很简单，我们只需要改成：</p><p>但是明明 <code>month</code> 函数根本没有修改对象的数据，所以这其实是开发者的问题，不应该写出这种代码。</p><p>当前的语境很简单，我们只需要改成：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Month <span class="token function">month</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> m<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// const 对象和非 const 对象都能调用</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果你阅读过 <code>STL</code> 源码，或者看过基本的<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/container/array">文档</a>，会知道，<strong>大部分成员函数都要提供 <code>const</code> 和非 <code>const</code> 两种版本，我们以 <code>std::array</code> 的 <code>operator[]</code> 为例</strong>。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> reference <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span> size_type pos <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">constexpr</span> const_reference <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span> size_type pos <span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两个成员函数都不会修改自己存储的对象，但是为什么要写 <code>const</code> 版本呢？<strong>注意返回类型</strong>。</p><ul><li>如果没有以 const 修饰的 std::array 对象，那么它调用 <code>operator[]</code> 自然是可以修改的，行为就像普通数组那样，我们就返回 <code>reference</code>。</li><li>如果是以 const 修饰的 std::array 对象，那么它调用 <code>operator[]</code> 根据我们的语义，自然不该让它外部能够修改，所以我们返回 <code>const_reference</code>。</li></ul><p><strong>一个成员函数是否以 const 修饰，不在于这个成员函数到底是否会修改自己的成员，而在于 “可变性”。</strong></p><p>相对于 标准库（STL）的算法，使用 for 或 while 等方式的手工循环通常也有上面一样的可读性问题。比如下面这样：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                          <span class="token comment" spellcheck="true">//不好</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>
        index <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">auto</span> it <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//更好</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个专业的 C++ 开发者应该了解 <strong>STL 算法</strong>。使用它们的话，你就可以避免显式使用循环，你的代码也会变得更容易理解，更容易维护，因此，也更不容易出错。现代 C++ 中有一句谚语：</p><ul><li><em>如果你显式使用循环的话，说明你不了解 STL 算法。</em></li></ul><blockquote><p>其实就是说成员函数注意返回类型的名字，和 const 修饰，增加可读性。 多使用 STL 算法，而不是自己搓，既能增加可读性也能减少错误。</p></blockquote><h3 id="P-2-用-ISO-标准写代码"><a href="#P-2-用-ISO-标准写代码" class="headerlink" title="P.2 用 ISO 标准写代码"></a>P.2 用 ISO 标准写代码</h3><p>要想得到一个可移植的 C++ 程序，最好的选择就是按照标准写代码。</p><p>使用当前的 C++ 标准，不要使用编译器扩展，同时注意，<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/ub">未定义行为和实现定义行为</a>。</p><p><strong>当你必须使用没有写在 ISO 标准里的扩展时，可以用一个稳定的接口将它们封装起来</strong>。</p><blockquote><p>比如将使用的编译器扩展用宏封装起来，以后如果要修改，或者说要适应别的平台，都很方便。举一个古代<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/jGfGz941G">例子</a>：</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">if</span> __cplusplus >= 201103L</span>
<span class="token macro property">#<span class="token directive keyword">define</span> INLINE inline</span>
<span class="token macro property">#<span class="token directive keyword">else</span></span>
<span class="token macro property">#<span class="token directive keyword">define</span> INLINE __attribute__((__always_inline__))</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="P-3-表达意图"><a href="#P-3-表达意图" class="headerlink" title="P.3 表达意图"></a>P.3 表达意图</h3><p>以下的隐式和显式循环中，你能看出什么意图？</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> v<span class="token operator">:</span> vec<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>                              <span class="token comment" spellcheck="true">// (1)</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> v<span class="token operator">:</span> vec<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>                                    <span class="token comment" spellcheck="true">// (2)</span>
std<span class="token operator">::</span><span class="token function">for_each</span><span class="token punctuation">(</span>std<span class="token operator">::</span>execution<span class="token operator">::</span>par<span class="token punctuation">,</span> vec<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// (3) 很抽象，这种形式其实根本做不到，当伪代码就好</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>循环（1）不修改容器 vec 的元素。（2）有可能修改。算法 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/algorithm/for_each">std::for_each</a>（3）以并行方式（<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/algorithm/execution_policy_tag_t">std::execution::par</a>）执行。这意味着我们不关心处理的顺序。<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/hxfdnT6W8">举个例子</a>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>vec<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span><span class="token function">for_each</span><span class="token punctuation">(</span>std<span class="token operator">::</span>execution<span class="token operator">::</span>par<span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//打印的顺序是随机的</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span><span class="token function">for_each</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//12345</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>表达意图也是良好代码文档的一个重要准测。</p><ul><li><em>文档应该说明代码会做什么，而不是代码会怎么做</em>。</li></ul><blockquote><p>其实这里是在指，文档应该讲功能，而非实现细节。 不过事实上技术文档一般都不会完全这样，多少会提一些实现细节的，具体情况具体分析。</p></blockquote><h3 id="P-4-理想情况下，程序应该是静态类型安全的"><a href="#P-4-理想情况下，程序应该是静态类型安全的" class="headerlink" title="P.4 理想情况下，程序应该是静态类型安全的"></a>P.4 理想情况下，程序应该是静态类型安全的</h3><p>C++ 是一种静态类型的语言。静态类型意味着编译器知道数据的类型，此外，还说明，编译器可以检测到类型错误。 由于现有的问题领域，我们并非一直能够达到这一目标，但对于联合体、转型(cast)、数组退化、范围错误或窄化转换，确实是有办法的。</p><ul><li>在 C++17 中，可以使用 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/utility/variant">std::variant</a> 安全地替代<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/union">联合体</a>。</li><li>基于模板的泛型代码减少了转型的需要，因此，也减少了类型错误。<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/YrfcvsTGY">如</a>。</li><li>当用一个 C 数组调用一个函数时，就会发生<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/implicit_conversion">数组退化</a>。函数需要用指向数组第一个元素的指针，另加数组的长度。这意味着，你从一个类型丰富的数据结构 C 数组开始，却以类型极差的数组首项指针结束。<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/KPPcP5j89">解决方法</a>在 C++20 里：<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/container/span">std::span</a>。std::span 可以自动推算出 C 数组的大小，也可以防止范围错误的发生。如果你还没有使用 C++20，请使用 Guidelines 支持库（GSL）提供的实现。</li><li><a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/list_initialization">窄化转换</a>是对算术值的有精度损失的隐式转换。</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">i1</span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> i2 <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果你使用 {} 初始化语法，编译器就能<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/j6GTbGvvn">检测到窄化转换</a>。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> i1<span class="token punctuation">{</span><span class="token number">3.14</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> i2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">3.14</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="P-5-编译期检查优先于运行期检查"><a href="#P-5-编译期检查优先于运行期检查" class="headerlink" title="P.5 编译期检查优先于运行期检查"></a>P.5 编译期检查优先于运行期检查</h3><ul><li><em>如果可以在编译期检查，那就应该在编译期检查</em>。</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// Int 被用作整数的别名</span>
<span class="token keyword">int</span> bits <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 请勿如此: 可以避免的代码</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>Int i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token punctuation">;</span> i <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token operator">++</span>bits<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>bits <span class="token operator">&lt;</span> <span class="token number">32</span><span class="token punctuation">)</span>
    cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"Int too small\n"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个例子并没有达成其所要达成的目的（因为溢出是未定义行为），应当被替换为简单的 static_assert：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// Int 被用作整数类型的别名</span>
<span class="token keyword">static_assert</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Int<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// do: 编译时检查</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>或者更好的方式是直接利用类型系统，将 int 替换 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/types/integer">int32_t</a>。</p><blockquote><p>如果当前环境有 int32_t 这个别名，那么代表，你的环境支持 32位整数类型。</p></blockquote><p>或用来检测<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/meta%23.E7.B1.BB.E5.9E.8B.E7.89.B9.E6.80.A7">类型特征</a>（type traits），比如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">static_assert</span><span class="token punctuation">(</span>std<span class="token operator">::</span>is_integral_v<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="P-6-不能在编译期检查的事项应该在运行期检查"><a href="#P-6-不能在编译期检查的事项应该在运行期检查" class="headerlink" title="P.6 不能在编译期检查的事项应该在运行期检查"></a>P.6 不能在编译期检查的事项应该在运行期检查</h3><p>因为有 <code>dynamic_cast</code> ，可以安全的将类的指针和引用沿着继承层次结构进行向上，向下以及测向的转换。如果转型失败，</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span> 新类型 <span class="token operator">></span><span class="token punctuation">(</span> 表达式 <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果转型失败且 新类型 是指针类型，那么它会返回该类型的空指针。</p><p>如果转型失败且 新类型 是引用类型，那么它会抛出与类型 <code>std::bad_cast</code> 的处理块匹配的异常。</p><p>第五章中 “dynamic_cast” 一节中会有更多的细节。</p><h3 id="P-7-尽早识别运行期错误"><a href="#P-7-尽早识别运行期错误" class="headerlink" title="P.7 尽早识别运行期错误"></a>P.7 尽早识别运行期错误</h3><p>可以采取很多对策来摆脱运行期错误。管理好指针和 C 数组，检查他们的范围。对于转换，同样需要检测：</p><ul><li><em>如有可能，应尽量避免转换，对于窄化转换，尤其如此。检查输入也属于这个范畴</em>。</li></ul><h3 id="P-8-不要泄露任何资源"><a href="#P-8-不要泄露任何资源" class="headerlink" title="P.8 不要泄露任何资源"></a>P.8 不要泄露任何资源</h3><p>资源可以是内存、文件句柄、套接字，等等。处理资源的惯用法是 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/raii">RAII</a> 。RAII 是资源获取即初始化（Resource Acquisition Is Initialization）。 是一种 C++ 编程技术，它将必须在使用前请求的资源（分配的堆内存、执行线程、打开的套接字、打开的文件、锁定的互斥体、磁盘空间、数据库连接等——任何存在受限供给中的事物）的生命周期与一个对象的生存期相绑定。 即：构造函数中获取资源，析构函数中释放资源。</p><p>C++ 大量使用 RAII：锁负责处理互斥量，智能指针负责处理原始内存，STL 的容器负责处理底层元素，等等。</p><blockquote><p>这里居然用中文的 “锁” 这个字来指代那些通用锁管理类（<code>std::lock_guard</code>），原书这里用这个字描述是有问题的，请不要模仿。</p></blockquote><h3 id="P-9-不要浪费时间和空间"><a href="#P-9-不要浪费时间和空间" class="headerlink" title="P.9 不要浪费时间和空间"></a>P.9 不要浪费时间和空间</h3><p>节省时间和空间都是一种美德。我们用的是 C++。你发现下面循环中的问题了吗？</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">lower</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string s<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> std<span class="token operator">::</span><span class="token function">strlen</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
        s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">tolower</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>虽然是个错误示例，但这代码写的太过愚蠢了，函数形参不用引用直接拷贝是其一，s 明明是个 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/string/basic_string">std::string</a> 对象，不去调用 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/string/basic_string/size">size()</a> 成员函数，跑去用 C 标准库的玩意？</p></blockquote><p>使用 STL 中的算法 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/algorithm/transform">std::transform</a> ，就可以把前面的函数变成一行。</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span><span class="token function">transform</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">tolower</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>与函数 lower 相比，算法 std::transform 自动确定了字符串的大小。因此，你不需要使用 std::strlen 指定字符串的长度。</p><p>下面是另一个经常出现在生产代码中的典型例子。为一个用户定义的数据类型声明拷贝语义。（拷贝构造函数和拷贝赋值运算符）。最终，编译器永远用不了廉价的移动语义。（即使实际上移动是适用的），而只能一直依赖代价高昂的拷贝语义。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> S<span class="token punctuation">{</span>
    std<span class="token operator">::</span>string s_<span class="token punctuation">;</span>
    <span class="token function">S</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string s<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">s_</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token function">S</span><span class="token punctuation">(</span><span class="token keyword">const</span> S<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">s_</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>s_<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    S<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> S<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span> s_ <span class="token operator">=</span> rhs<span class="token punctuation">.</span>s_<span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp"><code class="language-cpp">S s1<span class="token punctuation">;</span>
S s2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//进行拷贝，而不能从 s1.s_ 移动。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>这里没有任何问题，但是我们详细的描述一下，因为我觉得很多人不清楚移动语义能带来什么。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//不修改 S 类</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    S s1<span class="token punctuation">{</span> <span class="token string">"aaaaaaaaaaaaaaaa"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span>s_<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    S s2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span>s_<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/5Kr51KeMo">打印</a>的地址不一样，这代表实际上是复制了 <code>std::string</code> 管理的数据的。</p><p>但是，如果我们修改 S 类，比如直接把复制构造和复制赋值运算符给删了，会怎么样？</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>

<span class="token keyword">struct</span> S<span class="token punctuation">{</span>
    std<span class="token operator">::</span>string s_<span class="token punctuation">;</span>
    <span class="token function">S</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string s<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">s_</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    S s1<span class="token punctuation">{</span><span class="token string">"aaaaaaaaaaaaaaaa"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span>s_<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    S s2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span>s_<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/4rGxq1h5Y">打印</a>的地址完全一致。</p><p>这代表了 std::string 对象管理的数据并没有真的进行复制。</p><p>我们讲一下为什么：没有了复制构造函数和复制赋值运算符后，移动构造不会再被抑制了，编译器可以<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/move_constructor">隐式定义移动构造函数</a>。</p><p>这个隐式定义的移动构造函数，你大约可以理解为，我们的 <code>S s2 = std::move(s1)</code> 这里调用了 S 的移动构造函数，那么，它的数据成员，同时，也会被 移动，如果是类类型，且有移动构造函数的话，会被调用，相当于，<code>std::string</code> 被调用了移动构造，然后进行了转移。我们知道 std::string 的移动构造，是转移所有权（其实你就可以理解为把原对象的指向数据的指针给了我们当前的对象，然后原对象赋空）。</p><p>我们举个例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>

<span class="token keyword">struct</span> X<span class="token punctuation">{</span>
    <span class="token function">X</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
    <span class="token function">X</span><span class="token punctuation">(</span>X<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"X(X&amp;&amp;)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token function">X</span><span class="token punctuation">(</span><span class="token keyword">const</span> X<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"X(const X&amp;)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">X</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> Y<span class="token punctuation">{</span>
    X x<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Y y1<span class="token punctuation">;</span>
    Y y2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>y1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码会打印一个 <code>X(X&amp;&amp;)</code>，这证明了我们前面说的：</p><p>编译器隐式定义的移动构造函数，被调用，相当于会把自身的数据成员也进行移动，如果它是类类型，且有移动构造，那么也会匹配上，进行调用。</p><h3 id="P-10-不可变数据优先于可变数据"><a href="#P-10-不可变数据优先于可变数据" class="headerlink" title="P.10 不可变数据优先于可变数据"></a>P.10 不可变数据优先于可变数据</h3><p>使用不可变数据的理由有很多。首先，当你使用常量时，你的代码更容易验证。<strong>常量也有更高的优化潜力</strong>。但最重要的是，常量在并发程序中具有很大的优势。不可变数据在设计上是没有数据竞争的，因为数据竞争的必要条件就是对数据进行修改。</p><blockquote><p>其实只需要考虑一个事情：<strong>如果它可以是常量，那就把它设置为常量</strong>。</p></blockquote><h3 id="P-11-封装杂乱的构建，不要让它在代码中散布开"><a href="#P-11-封装杂乱的构建，不要让它在代码中散布开" class="headerlink" title="P.11 封装杂乱的构建，不要让它在代码中散布开"></a>P.11 封装杂乱的构建，不要让它在代码中散布开</h3><p>混乱的代码往往是低级代码，易于隐藏错误，容易出问题。如果可能的话，用 STL 中的高级构建（如容器或算法）来取代你的杂乱代码。如果这不可能，就把那些杂乱代码封装到一个用户定义的类型或函数中去。</p><h3 id="P-12-适当使用辅助工具"><a href="#P-12-适当使用辅助工具" class="headerlink" title="P.12 适当使用辅助工具"></a>P.12 适当使用辅助工具</h3><p>计算机比人类更擅长做枯燥和重复性的工作。也就是说，应该使用静态分析工具、并发工具和测试工具来自动完成这些验证步骤。<strong>用一个以上的 C++ 编译器来编译代码，往往是验证代码的最简方式</strong>。一个编译器可能检测不到某种未定义行为，而另一个编译器可能会在同样情况下发出警告或产生错误。</p><h3 id="P-13-适当使用支持库"><a href="#P-13-适当使用支持库" class="headerlink" title="P.13 适当使用支持库"></a>P.13 适当使用支持库</h3><p>这也很好解释。你应该去找设计良好、文档齐全、支持良好的库。你会得到经过良好测试、<strong>几乎</strong>没有错误的库，其中的算法经过领域专家的高度优化。突出的例子包括：<strong>C++ 标准库</strong>、Guidelines 支持库和 Boost 库。</p><blockquote><p>我觉得一定有人看到这段会嗤之以鼻，但是总体其实没错的。</p></blockquote><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口是服务的提供者和使用者之间的契约。根据 C++ Core Guidelines，接口”可能是代码辅助中最重要的一个方面”。“接口”这一部分大约有 20 条规则。</p><blockquote><p><em>让接口易于正确使用，难以错误使用</em>。</p></blockquote><h3 id="I-2-避免非-const-的全局变量"><a href="#I-2-避免非-const-的全局变量" class="headerlink" title="I.2 避免非 const 的全局变量"></a>I.2 避免非 const 的全局变量</h3><p>当然，你应该避免非 const 的全局变量。但是为什么呢？为什么全局变量（尤其是当它不是常量时）会很糟糕？<strong>全局变量会在函数中注入隐藏的依赖，而该依赖并不是接口的一部分</strong>。下面的代码片段说明了我的观点：</p><blockquote><p>加粗的话注意理解。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> glob<span class="token punctuation">{</span> <span class="token number">2011</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">multiply</span><span class="token punctuation">(</span><span class="token keyword">int</span> fac<span class="token punctuation">)</span><span class="token punctuation">{</span>
    glob <span class="token operator">*</span><span class="token operator">=</span> glob<span class="token punctuation">;</span>
    <span class="token keyword">return</span> glob <span class="token operator">*</span> fac<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数 multiply 的执行有一个副作用——会改变全局变量 glob 的值。因此，<strong>你无法对函数进行孤立测试或推理</strong>。当更多的线程并发地使用 multiply 时，你就必须对变量 glob 加以保护。非 const 的全局变量还有更多其他弊端。<strong>如果函数 multiply 没有副作用，那你可以为了性能而将之前的结果存储到缓存中以进行复用。</strong></p><blockquote><p>注意到我们加粗的内容了吗？这非常重要，自行理解。 我们就讲一下最后一句，这其实是在描述<strong>编译器优化</strong> ，我们举个例子：什么情况才可能会是我们说的：<strong>没有副作用，那你可以为了性能而将之前的结果存储到缓存中以进行复用</strong>。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实无非就是：编译器看到你用同样的入参调用了两次 就可以干掉第二次调用。之前的结果被缓存了。（前提是这得是<a href="https://en.m.wikipedia.org/wiki/Pure_function">纯函数</a>）。</p><p>但是我们前面依赖了全局变量，就不行，它有外部的副作用，返回的结果可能会根据全局变量的不同而不同，没办法缓存。不能保证：<strong>多次调用传入的数据相同就能得到完全一致的结果</strong>。</p><h3 id="3-1-非-const-全局变量的弊端"><a href="#3-1-非-const-全局变量的弊端" class="headerlink" title="3.1 非 const 全局变量的弊端"></a>3.1 非 const 全局变量的弊端</h3><p>非 const 的全局变量有许多弊端。首当其冲的弊端是，<strong>非 const 的全局变量破坏了封装。这种对封装的破坏让你无法对函数/类（实体）进行独立思考</strong>。下面列举非 const 全局变量的主要弊端。</p><ul><li><strong>可测试性</strong>：无法孤立地测试你的实体。如果单元不存在，那么单元测试也将不存在。你只能进行系统测试。实体的执行效果要依赖整个系统状态。</li><li><strong>重构</strong>：因为你无法孤立地对代码进行推理，重构它会相当有挑战。</li><li><strong>优化</strong>：你无法轻易地重新安排函数调用或者在不同的线程上进行函数调用，因为可能有隐藏的依赖。缓存之前函数调用的结果也极为危险。</li><li><strong>并发</strong>：产生数据竞争的必要条件是有共享而可变的状态。而非 const 全局变量正是共享而可变的。</li></ul><h3 id="I-3-避免单例"><a href="#I-3-避免单例" class="headerlink" title="I.3 避免单例"></a>I.3 避免单例</h3><p>有时，全局变量伪装得很好。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// singleton.cpp</span>

<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>

<span class="token keyword">class</span> <span class="token class-name">MySingleton</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">MySingleton</span><span class="token punctuation">(</span><span class="token keyword">const</span> MySingleton<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
    MySingleton<span class="token operator">&amp;</span> <span class="token keyword">operator</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> MySingleton<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>

    <span class="token keyword">static</span> MySingleton<span class="token operator">*</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>instance<span class="token punctuation">)</span><span class="token punctuation">{</span>
            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">MySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">static</span> MySingleton<span class="token operator">*</span> instance<span class="token punctuation">;</span>
    <span class="token function">MySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
    <span class="token operator">~</span><span class="token function">MySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

MySingleton<span class="token operator">*</span> MySingleton<span class="token operator">::</span>instance <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><em>单例就是全局变量，因此你应当尽可能*</em>避免单例***。</li></ul><p>单例简单、直接地保证该类最多只有一个实例存在。作为全局变量，单例注入了一个依赖，而该依赖忽略了函数的接口。这是因为作为静态变量，单例通常会被直接调用，正如上面例子主函数中的两行所展示的那样：Singleton::getInstance()。而对单例的直接调用有一些严重的后果。你无法对有单例的函数进行<strong>单元测试</strong>，因为单元不存在。此外，你也不能创建单例的伪对象并在运行期替换，因为单例并不是函数接口的一部分。</p><blockquote><p>我们先聊一下最后一句话：其实就是说，我没办法创造一个和单例一样类型的对象，然后进行函数传参。因为单例不是函数接口的一部分，它通常会被直接调用。 另外，我们要明白，“单例” 它是<strong>带状态</strong>的，单例的状态是经常变化和难以确定的，因为大家都使用和修改这个单例。如果某个函数使用了这个单例，就没办法对它进行单独的单元测试，因为单例的状态无法确定，单例的状态依赖于所有修改它的代码。这也就是前面说的：<strong>你无法对有单例的函数进行单元测试</strong>。</p></blockquote><ul><li><em>简而言之，单例破坏了代码的可测试性</em>。</li></ul><p>实现单例看似小事一桩，但其实不然。你将面对几个挑战：</p><ul><li>谁来负责单例的销毁？</li><li>是否应该允许从单例派生？</li><li>如何以线程安全的方式初始化单例？</li><li>当单例互相依赖并属于不同的翻译单元时，应该以何种顺序初始化这些单例？这里要吓唬吓唬你了。这一难题被称为<strong><a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/xd3G9sh7P">静态初始化顺序问题</a></strong>。</li></ul><h3 id="3-2-运用依赖注入化解"><a href="#3-2-运用依赖注入化解" class="headerlink" title="3.2 运用依赖注入化解"></a>3.2 运用依赖注入化解</h3><p><strong>当某个对象使用单例的时候，注入的依赖就被注入对象中</strong>。而借助依赖注入技术，这个依赖可以变成接口的一部分，并且服务时从外界注入的。这样，客户代码和注入的服务之间就没有依赖了。依赖注入的典型方式是构造函数、设置函数（setter）成员或模板参数。</p></div><hr><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/tags/C/"><span class="chip bg-color">C++</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="wechat,qq,weibo,twitter,facebook,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="/libs/share/js/social-share.min.js"></script></div></div></div></div></div><style>.valine-card{margin:1.5rem auto}.valine-card .card-content{padding:20px 20px 5px 20px}#vcomments textarea{box-sizing:border-box;background:url(/medias/comment_bg.png) 100% 100% no-repeat}#vcomments p{margin:2px 2px 10px;font-size:1.05rem;line-height:1.78rem}#vcomments blockquote p{text-indent:.2rem}#vcomments a{padding:0 2px;color:#4cbf30;font-weight:500;text-decoration:none}#vcomments img{max-width:100%;height:auto;cursor:pointer}#vcomments ol li{list-style-type:decimal}#vcomments ol,ul{display:block;padding-left:2em;word-spacing:.05rem}#vcomments ul li,ol li{display:list-item;line-height:1.8rem;font-size:1rem}#vcomments ul li{list-style-type:disc}#vcomments ul ul li{list-style-type:circle}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}#vcomments table,td,th{border:0}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments h1{font-size:1.85rem;font-weight:700;line-height:2.2rem}#vcomments h2{font-size:1.65rem;font-weight:700;line-height:1.9rem}#vcomments h3{font-size:1.45rem;font-weight:700;line-height:1.7rem}#vcomments h4{font-size:1.25rem;font-weight:700;line-height:1.5rem}#vcomments h5{font-size:1.1rem;font-weight:700;line-height:1.4rem}#vcomments h6{font-size:1rem;line-height:1.3rem}#vcomments p{font-size:1rem;line-height:1.5rem}#vcomments hr{margin:12px 0;border:0;border-top:1px solid #ccc}#vcomments blockquote{margin:15px 0;border-left:5px solid #42b983;padding:1rem .8rem .3rem .8rem;color:#666;background-color:rgba(66,185,131,.1)}#vcomments pre{font-family:monospace,monospace;padding:1.2em;margin:.5em 0;background:#272822;overflow:auto;border-radius:.3em;tab-size:4}#vcomments code{font-family:monospace,monospace;padding:1px 3px;font-size:.92rem;color:#e96900;background-color:#f8f8f8;border-radius:2px}#vcomments pre code{font-family:monospace,monospace;padding:0;color:#e8eaf6;background-color:#272822}#vcomments pre[class*=language-]{padding:1.2em;margin:.5em 0}#vcomments code[class*=language-],pre[class*=language-]{color:#e8eaf6}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}#vcomments b,strong{font-weight:700}#vcomments dfn{font-style:italic}#vcomments small{font-size:85%}#vcomments cite{font-style:normal}#vcomments mark{background-color:#fcf8e3;padding:.2em}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}.v .vlist .vcard{padding-top:2.5em!important}</style><div class="card valine-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;left:20px;top:15px;padding-bottom:5px"><i class="fa fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="vcomments" class="card-content" style="display:grid"></div></div><script src="/libs/valine/av-min.js"></script><script src="/libs/valine/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"98JpzSGcrl9jFqHO13vqxHvX-gzGzoHsz",appKey:"mDmr2h9PB20xvPMNqgyRnNIC",notify:!0,verify:!0,visitor:!0,avatar:"mm",pageSize:"10",lang:"zh-cn",placeholder:"just go go"})</script><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fa fa-chevron-left"></i>&nbsp;上一篇</div><div class="card"><a href="/posts/15264/"><div class="card-image"><img src="/medias/featureimages/12.jpg" class="responsive-img" alt="Effective STL-STL使用经验"> <span class="card-title">Effective STL-STL使用经验</span></div></a><div class="card-content article-content"><div class="summary block-with-text">前言开新坑咯！</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2023-12-12 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/Cpp/" class="post-category">Cpp</a></span></div></div><div class="card-action article-tags"><a href="/tags/Cpp/"><span class="chip bg-color">Cpp</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fa fa-chevron-right"></i></div><div class="card"><a href="/posts/21341/"><div class="card-image"><img src="/medias/featureimages/18.jpg" class="responsive-img" alt="git如何更新新的个人令牌Tokens"> <span class="card-title">git如何更新新的个人令牌Tokens</span></div></a><div class="card-content article-content"><div class="summary block-with-text">前言2021年8月13日开始，GitHub在使用Git操作远程仓库时不再支持使用用户名密码形式进行身份验证，需使用个人访问令牌。使用Git操作GitHub仓库时使用用户名密码进行身份验证会报错： 解决方法使用token登录的方式，就是把你</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2023-10-09 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E6%9D%82%E8%AE%B0/" class="post-category">杂记</a></span></div></div><div class="card-action article-tags"><a href="/tags/%E6%9D%82%E8%AE%B0/"><span class="chip bg-color">杂记</span></a></div></div></div></div></article></div><script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script><script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script><script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script><script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget"><div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fa fa-list"></i></a></div><script src="/libs/tocbot/tocbot.min.js"></script><script>$(function(){tocbot.init({tocSelector:"#toc-content",contentSelector:"#articleContent",headingsOffset:-(.4*$(window).height()-45),headingSelector:"h2, h3, h4, h5"});let t=0;var e="toc-heading-";$("#toc-content a").each(function(){$(this).attr("href","#"+e+ ++t)}),t=0,$("#articleContent").children("h2, h3, h4, h5").each(function(){$(this).attr("id",e+ ++t)});var n=parseInt(.4*$(window).height()-64);let o=$(".toc-widget");$(window).scroll(function(){var t=$(window).scrollTop();n<t?o.addClass("toc-fixed"):o.removeClass("toc-fixed")});var i="expanded";let a=$("#toc-aside"),c=$("#main-content");$("#floating-toc-btn .btn-floating").click(function(){a.hasClass(i)?(a.removeClass(i).hide(),c.removeClass("l9")):(a.addClass(i).show(),c.addClass("l9")),function(){let e=$("#artDetail");if(0!==e.length){let t=e.width();450<=t?t+=21:350<=t&&t<450?t+=18:300<=t&&t<350?t+=16:t+=14,$("#prenext-posts").width(t)}}()})})</script></main><footer class="page-footer bg-color"><div class="container row center-align"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2019</span> <a href="/about" rel="external nofollow noreferrer">JoyTsing</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br><span id="sitetime">载入运行时间...</span> <span id="busuanzi_container_site_pv">|&nbsp;<i class="fa fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span>&nbsp;次 </span><span id="busuanzi_container_site_uv">|&nbsp;<i class="fa fa-user"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv" class="white-color"></span>&nbsp;人</span><br><script type="text/javascript">var cnzz_protocol="https:"==document.location.protocol?"https://":"http://";document.write(unescape("%3Cspan id='cnzz_stat_icon_1278523400'%3E%3C/span%3E%3Cscript src='"+cnzz_protocol+"s4.cnzz.com/z_stat.php%3Fid%3D1278523400%26online%3D1%26show%3Dline' type='text/javascript'%3E%3C/script%3E"))</script><br>&nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;<span class="white-color">302.4k</span>&nbsp;字<script>function siteTime(){var e=864e5,t="2019",n=(m=new Date).getFullYear(),o=m.getMonth()+1,r=m.getDate(),a=m.getHours(),i=m.getMinutes(),l=m.getSeconds(),m=Date.UTC(t,"7","24","0","0","0"),r=Date.UTC(n,o,r,a,i,l)-m,a=Math.floor(r/31536e6),i=Math.floor(r/e-365*a),l=Math.floor((r-(365*a+i)*e)/36e5),m=Math.floor((r-(365*a+i)*e-36e5*l)/6e4),M=Math.floor((r-(365*a+i)*e-36e5*l-6e4*m)/1e3);t==n?(document.getElementById("year").innerHTML=n,document.getElementById("sitetime").innerHTML="本站已安全运行 "+i+" 天 "+l+" 小时 "+m+" 分钟 "+M+" 秒"):(document.getElementById("year").innerHTML=t+" - "+n,document.getElementById("sitetime").innerHTML="本站已安全运行 "+a+" 年 "+i+" 天 "+l+" 小时 "+m+" 分钟 "+M+" 秒")}setInterval(siteTime,1e3)</script></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/JoyTsing" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fa fa-github"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script src="/js/search.js"></script><script type="text/javascript">$(function(){searchFunc("/search.xml","searchInput","searchResult")})</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fa fa-angle-up"></i></a></div><script src="/libs/materialize/materialize.min.js"></script><script src="/libs/masonry/masonry.pkgd.min.js"></script><script src="/libs/aos/aos.js"></script><script src="/libs/scrollprogress/scrollProgress.min.js"></script><script src="/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="/js/matery.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js",(e=document.getElementsByTagName("script")[0]).parentNode.insertBefore(t,e)}()</script><script async src="/libs/others/busuanzi.pure.mini.js"></script><script type="text/javascript">var st,OriginTitile=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="(oﾟvﾟ)ノ Hi",clearTimeout(st)):(document.title="(*´∇｀*) 欢迎回来！",st=setTimeout(function(){document.title=OriginTitile},3e3))})</script><script type="text/javascript" color="0,0,255" pointcolor="0,0,255" opacity="0.8" zindex="-1" count="150" src="/libs/background/canvas-nest.js"></script><script src="/libs/instantpage/instantpage.js" type="module"></script><script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script><script>const hasAttr = (e,a) => a.some(_=> e.attr(_)!==undefined);
        $('a').each(function() {
          const $this = $(this);
          if(hasAttr($this,["data-fancybox","ignore-external-link"])) return;
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== '' || window.location.host) {
                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/shizuku.model.json"},display:{position:"left",width:150,height:200},mobile:{show:!1},react:{opacity:.7}})</script></body></html>