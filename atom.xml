<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JoyTsing</title>
  
  <subtitle>深海</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://joytsing.github.io/"/>
  <updated>2024-03-23T13:11:02.714Z</updated>
  <id>https://joytsing.github.io/</id>
  
  <author>
    <name>JoyTsing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux下的 I/O 模式:select/poll/epoll</title>
    <link href="https://joytsing.github.io/posts/50203/"/>
    <id>https://joytsing.github.io/posts/50203/</id>
    <published>2024-03-23T09:34:36.000Z</published>
    <updated>2024-03-23T13:11:02.714Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>”Everything is File“，在Linux <strong>·</strong> 古事迹中是这么记载的。在了解多路复用select、poll、epoll实现之前，先复习一下基础的概念。</p><h2 id="一、什么是多路复用："><a href="#一、什么是多路复用：" class="headerlink" title="一、什么是多路复用："></a>一、什么是多路复用：</h2><p>知乎上有这么一个问题，<a href="https://www.zhihu.com/question/59975081/answer/1932776593">IO多路复用到底是不是异步的？</a>。首先先明确一下这个概念：</p><ul><li>多路: 指的是多个socket网络连接;</li><li>复用: 指的是复用一个线程、使用一个线程来检查多个文件描述符（Socket）的就绪状态</li><li>多路复用主要有三种技术：select，poll，epoll。</li></ul><h2 id="二、五种IO模型："><a href="#二、五种IO模型：" class="headerlink" title="二、五种IO模型："></a>二、五种IO模型：</h2><pre class="line-numbers language-text"><code class="language-text">[1]blockingIO - 阻塞IO[2]nonblockingIO - 非阻塞IO[3]signaldrivenIO - 信号驱动IO[4]asynchronousIO - 异步IO[5]IOmultiplexing - IO多路复用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="阻塞式I-O模型："><a href="#阻塞式I-O模型：" class="headerlink" title="阻塞式I/O模型："></a><strong>阻塞式I/O模型：</strong></h3><p><img src="/posts/50203/2020-02-09-15812482347815-blocking-io-model.png" alt></p><p>进程/线程在从调用recv开始到它返回的整段时间内是被阻塞的，recv成功返回后，应用进程/线程开始处理数据报。主要特点是进程阻塞挂起不消耗CPU资源，能及时响应每个操作；实现难度低，适用并发量小的网络应用开发，不适用并发量大的应用，因为一个请求IO会阻塞进程，所以每请求分配一个处理进程（线程）去响应，系统开销大。</p><h3 id="非阻塞式I-O模型："><a href="#非阻塞式I-O模型：" class="headerlink" title="非阻塞式I/O模型："></a><strong>非阻塞式I/O模型：</strong></h3><p><img src="/posts/50203/2020-02-09-15812482347824-non-blocking-io-model.png" alt></p><p>进程发起IO系统调用后，如果内核缓冲区没有数据，需要到IO设备中读取，进程返回一个错误而不会被阻塞；进程发起IO系统调用后，如果内核缓冲区有数据，内核就会把数据返回进程。</p><ul><li>进程轮询（重复）调用，消耗CPU的资源；</li><li>实现难度低、开发应用相对阻塞IO模式较难；</li><li>适用并发量较小、且不需要及时响应的网络应用开发；</li></ul><h3 id="信号驱动IO："><a href="#信号驱动IO：" class="headerlink" title="信号驱动IO："></a>信号驱动IO<strong>：</strong></h3><p><img src="/posts/50203/image-20240323190653949.png" alt></p><p>当进程发起一个IO操作，会向内核注册一个信号处理函数，然后进程返回不阻塞；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用IO读取数据。</p><p>特点：回调机制，实现、开发应用难度大；</p><h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p><img src="/posts/50203/image-20240323190757505.png" alt></p><p>当进程发起一个IO操作，进程返回（不阻塞），但也不能返回结果；内核把整个IO处理完后，会通知进程结果。如果IO操作成功则进程直接获取到数据。</p><p>特点：</p><ul><li>不阻塞，数据一步到位；Proactor模式；</li><li>需要操作系统的底层支持，LINUX 2.5 版本内核首现，2.6 版本产品的内核标准特性；</li><li>实现、开发应用难度大；</li><li>非常适合高性能高并发应用；</li></ul><h3 id="IO复用模型"><a href="#IO复用模型" class="headerlink" title="IO复用模型"></a><strong>IO复用模型</strong></h3><p><img src="/posts/50203/image-20240323191129383.png" alt></p><p>IO多路复用会将多个Socket注册到一个选择器(Selector)。相当于可以使用一个线程来管理多个Socket连接。在最初的阻塞型IO，每来一个新的连接都需要分配一个线程来处理。</p><p>IO多路复用有三种模式：select、poll、epoll。当用户调用select/poll/epoll，会阻塞当前进程，内核会不断的轮询注册到选择器(Selector)上的Socket，当任何一个Socket的数据准备好了，就会结束阻塞。这个时候用户进程再调用read操作，将数据从内核空间拷贝到用户空间。<strong>IO多路复用</strong>，第一阶段会阻塞在Selector上，第二阶段拷贝数据也会阻塞。</p><p>回顾一下：大多数文件系统的默认IO操作都是缓存IO。在Linux的缓存IO机制中，操作系统会将IO的数据缓存在文件系统的页缓存（page cache）。也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓存区拷贝到应用程序的地址空间中。这种做法的缺点就是，<strong>需要在应用程序地址空间和内核进行多次拷贝，这些拷贝动作所带来的CPU以及内存开销是非常大的</strong>。</p><p>至于为什么不能直接让磁盘控制器把数据送到应用程序的地址空间中呢？<strong>最简单的一个原因就是应用程序不能直接操作底层硬件。</strong>总的来说，IO分两阶段：</p><p>1)数据准备阶段</p><p>2)内核空间复制回用户进程缓冲区阶段。如下图：</p><p><img src="/posts/50203/u=1195948225,2395373012&fm=253&app=138&f=PNG.png" alt></p><h2 id="三、I-O-多路复用之select、poll、epoll详解"><a href="#三、I-O-多路复用之select、poll、epoll详解" class="headerlink" title="三、I/O 多路复用之select、poll、epoll详解"></a>三、I/O 多路复用之select、poll、epoll详解</h2><h3 id="一些看法"><a href="#一些看法" class="headerlink" title="一些看法"></a>一些看法</h3><p>都什么年代了还在用上个世纪的C-style API，boost/asio，启动！iouring，启动！</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>目前支持I/O多路复用的系统调用有<code>select，pselect，poll，epoll。</code>与多进程和多线程技术相比，<code>I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程</code>，也不必维护这些进程/线程，从而大大减小了系统的开销。</p><p>I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p><h3 id="select"><a href="#select" class="headerlink" title="select"></a><strong>select</strong></h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">select</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>readfds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>writefds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>exceptfds<span class="token punctuation">,</span> <span class="token keyword">struct</span> timeval <span class="token operator">*</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从上述的select函数声明可以看出，fd_set本质是一个数组，为了方便我们操作该数组，操作系统提供了以下函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 将文件描述符fd从set集合中删除 </span><span class="token keyword">void</span> <span class="token function">FD_CLR</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 判断文件描述符fd是否在set集合中 </span><span class="token keyword">int</span>  <span class="token function">FD_ISSET</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将文件描述符fd添加到set集合中 </span><span class="token keyword">void</span> <span class="token function">FD_SET</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将set集合中, 所有文件描述符对应的标志位设置为0</span><span class="token keyword">void</span> <span class="token function">FD_ZERO</span><span class="token punctuation">(</span>fd_set <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>select</strong> 函数监视的文件描述符分3类，分别是<code>writefds</code>、<code>readfds</code>、和<code>exceptfds</code>，当用户process调用<strong>select</strong>的时候，select会将需要监控的<code>readfds</code>集合拷贝到内核空间（假设监控的仅仅是socket可读），然后遍历自己监控的<code>skb(SocketBuffer)</code>，挨个调用<code>skb</code>的<code>poll</code>逻辑以便检查该socket是否有可读事件，遍历完所有的<code>skb</code>后，如果没有任何一个socket可读，那么select会调用<code>schedule_timeout</code>进入<code>schedule</code>循环，使得process进入睡眠。</p><p>如果在timeout时间内某个socket上有数据可读了，或者等待timeout了，则调用select的process会被唤醒，接下来select就是遍历监控的集合，挨个收集可读事件并返回给用户了，相应的伪码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// nfds:监控的文件描述符集里最大文件描述符加1</span><span class="token comment" spellcheck="true">// readfds：监控有读数据到达文件描述符集合，传入传出参数</span><span class="token comment" spellcheck="true">// writefds：监控写数据到达文件描述符集合，传入传出参数</span><span class="token comment" spellcheck="true">// exceptfds：监控异常发生达文件描述符集合, 传入传出参数</span><span class="token comment" spellcheck="true">// timeout：定时阻塞监控时间，3种情况</span><span class="token comment" spellcheck="true">//  1.NULL，永远等下去</span><span class="token comment" spellcheck="true">//  2.设置timeval，等待固定时间</span><span class="token comment" spellcheck="true">//  3.设置timeval里时间均为0，检查描述字后立即返回，轮询</span><span class="token comment" spellcheck="true">/* * select服务端伪码* 首先一个线程不断接受客户端连接，并把socket文件描述符放到一个list里。*/</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  connfd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">fcntl</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span> F_SETFL<span class="token punctuation">,</span> O_NONBLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span>  fdlist<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** select函数还是返回刚刚提交的list，应用程序依然list所有的fd，只不过操作系统会将准备就绪的文件描述符做上标识，* 用户层将不会再有无意义的系统调用开销。*/</span><span class="token keyword">struct</span> timeval timeout<span class="token punctuation">;</span><span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 用于记录最大的fd，在轮询中时刻更新即可</span><span class="token comment" spellcheck="true">// 初始化比特位</span><span class="token function">FD_ZERO</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>read_fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 阻塞获取 每次需要把fd从用户态拷贝到内核态</span>    nfds <span class="token operator">=</span> <span class="token function">select</span><span class="token punctuation">(</span>max <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>read_fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>write_fd<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 每次需要遍历所有fd，判断有无读写事件发生</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> max <span class="token operator">&amp;&amp;</span> nfds<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 只读已就绪的文件描述符，不用过多遍历</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> listenfd<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 这里处理accept事件</span>            <span class="token function">FD_SET</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>read_fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将客户端socket加入到集合中</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">FD_ISSET</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>read_fd<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 这里处理read事件</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>看见C-style风格的代码我是真的会谢</p></blockquote><p><strong>select存在三个问题：</strong></p><p>[1] 每次调用select，都需要把被监控的fds集合从用户态空间拷贝到内核态空间，高并发场景下这样的拷贝会使得消耗的资源是很大的。<br>[2] 能监听端口的数量有限，单个进程所能打开的最大连接数由FD_SETSIZE宏定义，监听上限就等于fds_bits位数组中所有元素的二进制位总数，其大小是32个整数的大小<br>[3] 被监控的fds集合中，只要有一个有数据可读，整个socket集合就会被遍历一次调用sk的poll函数收集可读事件</p><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a><strong>poll</strong></h3><p>poll的实现和select非常相似，只是描述fd集合的方式不同。poll只是使用pollfd结构而不是select的fd_set结构，去掉了 select 只能监听 1024 个文件描述符的限制。但poll和select同样存在一个性能缺点就是包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** poll服务端实现伪码：*/</span><span class="token keyword">struct</span> pollfd fds<span class="token punctuation">[</span>POLL_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> nfds<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>fds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>fd<span class="token operator">=</span>server_sockfd<span class="token punctuation">;</span>fds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>events<span class="token operator">=</span>POLLIN<span class="token operator">|</span>POLLPRI<span class="token punctuation">;</span>nfds<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">{</span>    res<span class="token operator">=</span><span class="token function">poll</span><span class="token punctuation">(</span>fds<span class="token punctuation">,</span>nfds<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>revents<span class="token operator">&amp;</span><span class="token punctuation">(</span>POLLIN<span class="token operator">|</span>POLLPRI<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//执行accept并加入fds中，nfds++</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">--</span>res<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//循环之后的fds</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>revents<span class="token operator">&amp;</span><span class="token punctuation">(</span>POLLIN<span class="token operator">|</span>POLLERR <span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//读操作或处理异常等</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">--</span>res<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a><strong>epoll</strong></h3><p>相比于select，epoll最大的好处在于它不会随着监听fd数目的增长而降低效率。如前面我们所说，在内核中的select实现中，它是采用轮询来处理的，轮询的fd数目越多，自然耗时越多。所以 epoll 主要就是针对这三点进行了改进：</p><ol><li>内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可。</li><li>内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒。</li><li>内核仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合。</li></ol><p>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大。这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p><p>epoll的接口非常简单，一共就三个函数：</p><ul><li>epoll_create：创建一个epoll句柄</li><li>epoll_ctl：向 epoll 对象中添加/修改/删除要管理的连接</li><li>epoll_wait：等待其管理的连接上的 IO 事件的文件描述符，否者失败，返回-1。</li></ul><p>epoll_create的源码实现：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">SYSCALL_DEFINE1</span><span class="token punctuation">(</span>epoll_create1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> eventpoll <span class="token operator">*</span>ep <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//创建一个 eventpoll 对象</span>    error <span class="token operator">=</span> <span class="token function">ep_alloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//struct eventpoll 的定义</span><span class="token comment" spellcheck="true">// file：fs/eventpoll.c</span><span class="token keyword">struct</span> eventpoll <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//sys_epoll_wait用到的等待队列</span>    wait_queue_head_t wq<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//接收就绪的描述符都会放到这里</span>    <span class="token keyword">struct</span> list_head rdllist<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//每个epoll对象中都有一颗红黑树</span>    <span class="token keyword">struct</span> rb_root rbr<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ep_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> eventpoll <span class="token operator">*</span><span class="token operator">*</span>pep<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> eventpoll <span class="token operator">*</span>ep<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//申请 epollevent 内存</span>    ep <span class="token operator">=</span> <span class="token function">kzalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>ep<span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//初始化等待队列头</span>    <span class="token function">init_waitqueue_head</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-</span><span class="token operator">></span>wq<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//初始化就绪列表</span>    <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-</span><span class="token operator">></span>rdllist<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//初始化红黑树指针</span>    ep<span class="token operator">-</span><span class="token operator">></span>rbr <span class="token operator">=</span> RB_ROOT<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中eventpoll 这个结构体中的几个成员的含义如下：</p><ul><li><strong>wq：</strong> 等待队列链表。软中断数据就绪的时候会通过 wq 来找到阻塞在 epoll 对象上的用户进程。</li><li><strong>rbr：</strong> 红黑树。为了支持对海量连接的高效查找、插入和删除，eventpoll 内部使用的就是红黑树。通过红黑树来管理用户主进程accept添加进来的所有 socket 连接。</li><li><strong>rdllist：</strong> 就绪的描述符链表。当有连接就绪的时候，内核会把就绪的连接放到 rdllist 链表里。这样应用进程只需要判断链表就能找出就绪进程，而不用去遍历红黑树的所有节点了。</li></ul><p><strong>epoll_ctl 函数</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">epoll_ctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> epoll_event <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>功能：</strong>epoll 的事件注册函数，它不同于 select() 是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。</li><li><strong>参数epfd:</strong> epoll 专用的文件描述符，epoll_create()的返回值</li><li><strong>参数op:</strong> 表示动作，用三个宏来表示：</li></ul><ol><li>EPOLL_CTL_ADD：注册新的 fd 到 epfd 中；</li><li>EPOLL_CTL_MOD：修改已经注册的fd的监听事件；</li><li>EPOLL_CTL_DEL：从 epfd 中删除一个 fd；</li></ol><ul><li><strong>参数fd:</strong> 需要监听的文件描述符</li><li><strong>参数event:</strong> 告诉内核要监听什么事件，struct epoll_event 结构如:</li><li><strong>events</strong>可以是以下几个宏的集合：</li><li>EPOLLIN ：表示对应的文件描述符可以读（包括对端 SOCKET 正常关闭）；</li><li>EPOLLOUT：表示对应的文件描述符可以写；</li><li>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</li><li>EPOLLERR：表示对应的文件描述符发生错误；</li><li>EPOLLHUP：表示对应的文件描述符被挂断；</li><li>EPOLLET ：将 EPOLL 设为边缘触发(Edge Trigger)模式，这是相对于水平触发(Level Trigger)来说的。</li><li>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个 socket 的话，需要再次把这个 socket 加入到 EPOLL 队列里</li><li><strong>返回值：</strong>0表示成功，-1表示失败。</li></ul><p><strong>epoll_wait函数</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> epoll_event <span class="token operator">*</span> events<span class="token punctuation">,</span> <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>功能：</strong>等待事件的产生，收集在 epoll 监控的事件中已经发送的事件，类似于 select() 调用。</li><li><strong>参数epfd:</strong> epoll 专用的文件描述符，epoll_create()的返回值</li><li><strong>参数events:</strong> 分配好的 epoll_event 结构体数组，epoll 将会把发生的事件赋值到events 数组中（events 不可以是空指针，内核只负责把数据复制到这个 events 数组中，不会去帮助我们在用户态中分配内存）。</li><li><strong>参数maxevents:</strong> maxevents 告之内核这个 events 有多少个 。</li><li><strong>参数timeout:</strong> 超时时间，单位为毫秒，为 -1 时，函数为阻塞。</li><li><strong>返回值：</strong></li></ul><ol><li>如果成功，表示返回需要处理的事件数目</li><li>如果返回0，表示已超时</li><li>如果返回-1，表示失败</li></ol><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;netinet/in.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;errno.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cassert></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/epoll.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">const</span> <span class="token keyword">int</span> MAX_EVENT_NUMBER <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//最大事件数</span><span class="token comment" spellcheck="true">// 设置句柄非阻塞</span><span class="token keyword">int</span> <span class="token function">setnonblocking</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> old_option <span class="token operator">=</span> <span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> F_GETFL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> new_option <span class="token operator">=</span> old_option <span class="token operator">|</span> O_NONBLOCK<span class="token punctuation">;</span>    <span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> F_SETFL<span class="token punctuation">,</span> new_option<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> old_option<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 创建套接字</span>    <span class="token keyword">int</span> nRet<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> m_listenfd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>PF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>m_listenfd<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fail to socket!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// </span>    <span class="token keyword">struct</span> sockaddr_in address<span class="token punctuation">;</span>    <span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    address<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>    address<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">htonl</span><span class="token punctuation">(</span>INADDR_ANY<span class="token punctuation">)</span><span class="token punctuation">;</span>    address<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span><span class="token number">6666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 设置ip可重用</span>    <span class="token function">setsockopt</span><span class="token punctuation">(</span>m_listenfd<span class="token punctuation">,</span> SOL_SOCKET<span class="token punctuation">,</span> SO_REUSEADDR<span class="token punctuation">,</span> <span class="token operator">&amp;</span>flag<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 绑定端口号</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span>m_listenfd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> sockaddr <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fail to bind!,errno :%d"</span><span class="token punctuation">,</span>errno<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 监听连接fd</span>    ret <span class="token operator">=</span> <span class="token function">listen</span><span class="token punctuation">(</span>m_listenfd<span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fail to listen!,errno :%d"</span><span class="token punctuation">,</span>errno<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 初始化红黑树和事件链表结构rdlist结构</span>    epoll_event events<span class="token punctuation">[</span>MAX_EVENT_NUMBER<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建epoll实例</span>    <span class="token keyword">int</span> m_epollfd <span class="token operator">=</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>m_epollfd<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fail to epoll create!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> m_epollfd<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 创建节点结构体将监听连接句柄</span>    epoll_event event<span class="token punctuation">;</span>    event<span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd <span class="token operator">=</span> m_listenfd<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//设置该句柄为边缘触发（数据没处理完后续不会再触发事件，水平触发是不管数据有没有触发都返回事件），</span>    event<span class="token punctuation">.</span>events <span class="token operator">=</span> EPOLLIN <span class="token operator">|</span> EPOLLET <span class="token operator">|</span> EPOLLRDHUP<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 添加监听连接句柄作为初始节点进入红黑树结构中，该节点后续处理连接的句柄</span>    <span class="token function">epoll_ctl</span><span class="token punctuation">(</span>m_epollfd<span class="token punctuation">,</span> EPOLL_CTL_ADD<span class="token punctuation">,</span> m_listenfd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//进入服务器循环</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span>m_epollfd<span class="token punctuation">,</span> events<span class="token punctuation">,</span> MAX_EVENT_NUMBER<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>number <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> errno <span class="token operator">!=</span> EINTR<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span> <span class="token string">"epoll failure"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> number<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> sockfd <span class="token operator">=</span> events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 属于处理新到的客户连接</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>sockfd <span class="token operator">==</span> m_listenfd<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">struct</span> sockaddr_in client_address<span class="token punctuation">;</span>                socklen_t client_addrlength <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>client_address<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> connfd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>m_listenfd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> sockaddr <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>client_address<span class="token punctuation">,</span> <span class="token operator">&amp;</span>client_addrlength<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>connfd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"errno is:%d accept error"</span><span class="token punctuation">,</span> errno<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                epoll_event event<span class="token punctuation">;</span>                event<span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd <span class="token operator">=</span> connfd<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//设置该句柄为边缘触发（数据没处理完后续不会再触发事件，水平触发是不管数据有没有触发都返回事件），</span>                event<span class="token punctuation">.</span>events <span class="token operator">=</span> EPOLLIN <span class="token operator">|</span> EPOLLRDHUP<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 添加监听连接句柄作为初始节点进入红黑树结构中，该节点后续处理连接的句柄</span>                <span class="token function">epoll_ctl</span><span class="token punctuation">(</span>m_epollfd<span class="token punctuation">,</span> EPOLL_CTL_ADD<span class="token punctuation">,</span> connfd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">setnonblocking</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events <span class="token operator">&amp;</span> <span class="token punctuation">(</span>EPOLLRDHUP <span class="token operator">|</span> EPOLLHUP <span class="token operator">|</span> EPOLLERR<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//服务器端关闭连接，</span>                <span class="token function">epoll_ctl</span><span class="token punctuation">(</span>m_epollfd<span class="token punctuation">,</span> EPOLL_CTL_DEL<span class="token punctuation">,</span> sockfd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">close</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//处理客户连接上接收到的数据</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events <span class="token operator">&amp;</span> EPOLLIN<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                <span class="token function">read</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span>buf<span class="token punctuation">,</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"from client :%s"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 将事件设置为写事件返回数据给客户端</span>                events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd <span class="token operator">=</span> sockfd<span class="token punctuation">;</span>                events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events <span class="token operator">=</span> EPOLLOUT <span class="token operator">|</span> EPOLLET <span class="token operator">|</span> EPOLLONESHOT <span class="token operator">|</span> EPOLLRDHUP<span class="token punctuation">;</span>                <span class="token function">epoll_ctl</span><span class="token punctuation">(</span>m_epollfd<span class="token punctuation">,</span> EPOLL_CTL_MOD<span class="token punctuation">,</span> sockfd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events <span class="token operator">&amp;</span> EPOLLOUT<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                std<span class="token operator">::</span>string response <span class="token operator">=</span> <span class="token string">"server response \n"</span><span class="token punctuation">;</span>                <span class="token function">write</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span>response<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>response<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 将事件设置为读事件，继续监听客户端</span>                events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd <span class="token operator">=</span> sockfd<span class="token punctuation">;</span>                events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events <span class="token operator">=</span> EPOLLIN <span class="token operator">|</span> EPOLLRDHUP<span class="token punctuation">;</span>                <span class="token function">epoll_ctl</span><span class="token punctuation">(</span>m_epollfd<span class="token punctuation">,</span> EPOLL_CTL_MOD<span class="token punctuation">,</span> sockfd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//else if 可以加管道，unix套接字等等数据</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="epoll的边缘触发与水平触发"><a href="#epoll的边缘触发与水平触发" class="headerlink" title="epoll的边缘触发与水平触发"></a>epoll的边缘触发与水平触发</h3><p><strong>水平触发(LT)</strong></p><p>关注点是数据是否有无，只要读缓冲区不为空，写缓冲区不满，那么epoll_wait就会一直返回就绪，水平触发是epoll的默认工作方式。</p><p><strong>边缘触发(ET)</strong></p><p>关注点是变化，只要缓冲区的数据有变化，epoll_wait就会返回就绪。这里的数据变化并不单纯指缓冲区从有数据变为没有数据，或者从没有数据变为有数据，还包括了数据变多或者变少。即当buffer长度有变化时，就会触发。</p><p>假设epoll被设置为了边缘触发，当客户端写入了100个字符，由于缓冲区从0变为了100，于是服务端epoll_wait触发一次就绪，服务端读取了2个字节后不再读取。这个时候再去调用epoll_wait会发现不会就绪，只有当客户端再次写入数据后，才会触发就绪。这就导致如果使用ET模式，那就必须保证要「一次性把数据读取&amp;写入完」，否则会导致数据长期无法读取/写入。</p><h3 id="epoll更高效的原因"><a href="#epoll更高效的原因" class="headerlink" title="epoll更高效的原因"></a>epoll更高效的原因</h3><p>epoll比select和poll高效的原因主要有下面几点： </p><ol><li>将文件描述符添加和检测分离，减少了用户态和内核态之间的文件描述符拷贝 </li><li>减少了对就绪文件描述符的遍历，内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒。</li><li>内核仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合。</li></ol><p>深入阅读的话可以看：<a href="https://zhuanlan.zhihu.com/p/361750240">深入揭秘 epoll 是如何实现 IO 多路复用的</a>，<a href="https://mp.weixin.qq.com/s/X6c_H5_4OInR8nFQVn7IMA">最多能创建多少个TCP连接</a></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>select，poll，epoll都是IO多路复用机制，即可以监视多个描述符，一旦某个描述符就绪（读或写就绪），能够通知程序进行相应读写操作。 但select，poll，epoll本质上都是<strong>同步I/O</strong>（注意啊，select/poll 模型是一种<strong>阻塞模型</strong>，epoll 是<strong>非阻塞模型</strong>，同步≠阻塞），因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p><ul><li>select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。</li><li>select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。</li></ul><table><thead><tr><th></th><th>select</th><th>poll</th><th>epoll</th></tr></thead><tbody><tr><td>性能</td><td>随着连接数的增加，性能急剧下降，处理成千上万的并发连接数时，性能很差</td><td>随着连接数的增加，性能急剧下降，处理成千上万的并发连接数时，性能很差</td><td>随着连接数的增加，性能基本没有变化</td></tr><tr><td>连接数</td><td>一般1024</td><td>无限制</td><td>无限制</td></tr><tr><td>内存拷贝</td><td>每次调用select拷贝</td><td>每次调用poll拷贝</td><td>fd首次调用epoll_ctl拷贝，每次调用epoll_wait不拷贝</td></tr><tr><td>数据结构</td><td>bitmap</td><td>数组</td><td>红黑树</td></tr><tr><td>内在处理机制</td><td>线性轮询</td><td>线性轮询</td><td>FD挂在红黑树，通过事件回调callback</td></tr><tr><td>时间复杂度</td><td>O(n)</td><td>O(n)</td><td>O(1)</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;”Everything is File“，在Linux &lt;strong&gt;·&lt;/strong&gt; 古事迹中是这么记载的。在了解多路复用selec
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Redis学习笔记</title>
    <link href="https://joytsing.github.io/posts/30038/"/>
    <id>https://joytsing.github.io/posts/30038/</id>
    <published>2024-03-23T09:27:30.000Z</published>
    <updated>2024-03-23T14:50:29.103Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先，学习一个项目最好的方法就是看文档，<a href="https://redis.io/docs/">redis文档</a>里面就介绍了怎么直接通过加apt源的方式便捷安装(类似之前的llvm镜像源)，本文章主要介绍redis的基础知识，但同时就像简介上说的，重点在于怎么用好怎么设计而不是死扣细节知识，不过凡事都要讲究一个先后顺序，不积跬步无以至千里。</p><h2 id="1-简单动态字符串"><a href="#1-简单动态字符串" class="headerlink" title="1. 简单动态字符串"></a>1. 简单动态字符串</h2><ul><li>在大多数情况下，Redis 使用 SDS（Simple Dynamic String，简单动态字符串）作为字符串表示</li></ul><h3 id="1-1-SDS-的结构体定义"><a href="#1-1-SDS-的结构体定义" class="headerlink" title="1.1 SDS 的结构体定义"></a>1.1 SDS 的结构体定义</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> sdshdr <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 记录 buf 数组中已使用字节的数量</span>    <span class="token comment" spellcheck="true">// 等于 SDS 所保存字符串的长度</span>    <span class="token keyword">int</span> len<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 记录 buf 数组中未使用字节的数量</span>    <span class="token keyword">int</span> free<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 字节数组，用于保存字符串，会自动在数组末尾添加一个字节，用于保存'\0'，不计入 len 值中</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-SDS-相对于-C-字符串的优点"><a href="#1-2-SDS-相对于-C-字符串的优点" class="headerlink" title="1.2 SDS 相对于 C 字符串的优点"></a>1.2 SDS 相对于 C 字符串的优点</h3><ol><li>常数复杂度获取字符串长度</li></ol><p>Redis 将获取字符串长度所需的复杂度从 O(N) 降低到了 O(1)，这确保了获取字符串长度的工作不会成为 Redis 的性能瓶颈</p><ul><li>杜绝缓冲区溢出</li><li>减少修改字符串时带来的内存重分配次数</li></ul><p>通过未使用空间（free），SDS 实现了 <strong>空间预分配</strong> 和 <strong>惰性空间释放</strong> 两种优化策略</p><ol start="2"><li>二进制安全</li></ol><p>为了确保 Redis 可以适用于各种不同的适用场景，SDS 的 API 都是二进制安全的，因此使得 Redis 不仅可以保存文本数据，还可以保存任意格式的二进制数据，因为 SDS 使用 len 属性的值而不是空字符来判断字符串是否结束</p><ol start="3"><li>兼容部分C字符串函数</li></ol><p>通过遵循C字符串以空字符结尾的惯例，SDS 可以在有需要时重用 <code>&lt;string.h&gt;</code> 函数库，从而避免了不必要的代码重复</p><h2 id="2-链表"><a href="#2-链表" class="headerlink" title="2. 链表"></a>2. 链表</h2><p>链表被广泛用于实现 Redis 的各种功能，比如列表键、发布与订阅、慢查询、监视器等</p><p>Redis 的链表是由一个 <code>list</code> 结构和 n 个 <code>listNode</code> 结构组成，list 里面可以存储该链表的头指针、尾指针、以及长度计数器和用于实现多态链表所需的类型特定函数，Redis 的链表是 <strong>双端</strong>、<strong>无环</strong> 的</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 每个链表节点使用一个 adlist.h/listNode</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> listNode <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 前置节点</span>    <span class="token keyword">struct</span> listNode <span class="token operator">*</span> prev<span class="token punctuation">;</span>    <span class="token keyword">struct</span> listNode <span class="token operator">*</span> next<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 节点的值</span>    <span class="token keyword">void</span> <span class="token operator">*</span> value<span class="token punctuation">;</span><span class="token punctuation">}</span>listNode<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 虽然仅仅使用多个listNode结构就可以构成链表，</span><span class="token comment" spellcheck="true">// 但使用adlist.h/list来持有链表的话，操作起来会更方便</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> list <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 表头节点</span>    listNode <span class="token operator">*</span> head<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 表尾节点</span>    listNode <span class="token operator">*</span> tail<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 链表所包含的节点数量</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 节点值复制函数</span>    <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>dup<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 节点值释放函数</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>free<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 节点值对比函数</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>match<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>list<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-字典"><a href="#3-字典" class="headerlink" title="3. 字典"></a>3. 字典</h2><ul><li>Redis 的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对</li></ul><h3 id="3-1-哈希表"><a href="#3-1-哈希表" class="headerlink" title="3.1 哈希表"></a>3.1 哈希表</h3><ul><li>Redis 字典所使用的哈希表由 <code>dict.h/dictht</code> 结构定义：</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> dicht <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 哈希表数组</span>    dictEntry <span class="token operator">*</span><span class="token operator">*</span>table<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 哈希表大小</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 哈希表大小掩码，用于计算索引值</span>    <span class="token comment" spellcheck="true">// 总是等于 size - 1</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sizemask<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 该哈希表已有节点的数量</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> used<span class="token punctuation">;</span><span class="token punctuation">}</span>dictht<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-哈希表节点"><a href="#3-2-哈希表节点" class="headerlink" title="3.2 哈希表节点"></a>3.2 哈希表节点</h3><ul><li>哈希表节点使用 <code>dictEntry</code> 结构表示，每个 <code>dictEntry</code> 结构都保存着一个键值对：</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> dictEntry <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 键</span>    <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 值</span>    <span class="token keyword">union</span> <span class="token punctuation">{</span>        <span class="token keyword">void</span> <span class="token operator">*</span>val<span class="token punctuation">;</span>        uint64_tu64<span class="token punctuation">;</span>        int64_ts64<span class="token punctuation">;</span>    <span class="token punctuation">}</span> v<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 指向下个哈希表节点，形成链表</span>    <span class="token keyword">struct</span> dictEntry <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span>dictEntry<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-字典"><a href="#3-3-字典" class="headerlink" title="3.3 字典"></a>3.3 字典</h3><ul><li>Redis 中的字典由 <code>dict.h/dict</code> 结构表示：</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> dict <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 类型特定函数</span>    dictType <span class="token operator">*</span>type<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 私有数据</span>    <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 哈希表</span>    dictht ht<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// rehash 索引</span>    <span class="token comment" spellcheck="true">// 当 rehash 不在进行时，值为 -1</span>    <span class="token keyword">int</span> trehashidx<span class="token punctuation">;</span><span class="token punctuation">}</span> dict<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-普通状态下的字典"><a href="#3-4-普通状态下的字典" class="headerlink" title="3.4 普通状态下的字典"></a>3.4 普通状态下的字典</h3><p><img src="/posts/30038/image-20240323221208002.png" alt></p><h3 id="3-5-哈希算法"><a href="#3-5-哈希算法" class="headerlink" title="3.5 哈希算法"></a>3.5 哈希算法</h3><ul><li>当要将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新的键值对的哈希表节点放到哈希表数组的指定索引上面。</li></ul><p>Redis 计算哈希值和索引值的方法如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 使用字典设置的哈希函数，计算键key的哈希值</span>hash <span class="token operator">=</span> dict <span class="token operator">-></span> type <span class="token operator">-></span> <span class="token function">hashFunction</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用哈希表的sizemask属性和哈希值，计算出索引值</span><span class="token comment" spellcheck="true">// 根据情况不同，ht[x]可以是ht[0]或者ht[1]</span>index <span class="token operator">=</span> hash <span class="token operator">&amp;</span> dict <span class="token operator">-></span> ht<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>sizemask<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>Redis 使用 <code>MurmurHash2</code> 算法来计算键的哈希值</p></blockquote><h3 id="3-6-解决键冲突"><a href="#3-6-解决键冲突" class="headerlink" title="3.6 解决键冲突"></a>3.6 解决键冲突</h3><p>Redis 的哈希表使用链地址法（separate chaining）来解决键冲突，每个哈希表节点都有一个 next 指针，多个哈希表节点可以用 next 指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突的问题</p><p>因为 <code>dictEntry</code> 节点组成的链表没有指向链表表尾的指针，所以为了速度考虑，程序总是将新节点添加到链表的表头位置（复杂度为O(1)）,排在其他已有节点的前面。</p><h3 id="3-7-rehash"><a href="#3-7-rehash" class="headerlink" title="3.7 rehash"></a>3.7 rehash</h3><p>随着操作的不断执行，哈希表保存的键值对会逐渐地增多或者减少，为了让哈希表的负载因子（load factor）维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。</p><p>Redis 对字典的哈希表执行 rehash 的步骤如下：</p><ol><li>为字典的 ht[1] 哈希表分配空间</li><li>如果是扩展操作，那么 ht[1] 的大小为第一个大于等于 <code>ht[0].used*2 的 2 ^ n</code>（2 的 n 次方）</li><li>如果执行的是收缩操作，那么 ht[1] 的大小为第一个大于等于 <code>ht[0].used 的 2 ^ n</code></li><li>将保存在 ht[0] 中的所有键值对 rehash 到 ht[1] 上面：rehash 指的是重新计算键的哈希值和索引值，然后将键值对放置到 ht[1] 哈希表的指定位置上</li><li>当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后（ht[0] 变为空表），释放 ht[0]，将 ht[1] 设置为 ht[0] ，并在 ht[1] 新创建一个空白哈希表，为下一次 rehash 做准备</li></ol><h3 id="3-8-执行扩展或收缩操作的条件"><a href="#3-8-执行扩展或收缩操作的条件" class="headerlink" title="3.8 执行扩展或收缩操作的条件"></a>3.8 执行扩展或收缩操作的条件</h3><p>当以下条件中的任意一个被满足时，程序会自动对哈希表执行扩展操作：</p><ol><li>服务目前没有在执行 <code>BGSAVE</code> 命令或者 <code>BGREWRITEAOF</code> 命令，并且哈希表的负载因子大于等于 1 。</li><li>服务器目前正在执行 <code>BGSAVE</code> 命令或者 <code>BGREWRITEAOF</code> 命令，并且哈希表的负载因子大于等于 5 。</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 负载因子 = 哈希表已保存的节点数量 / 哈希表大小</span>load_factor <span class="token operator">=</span> ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>used <span class="token operator">/</span> ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>size<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>另一方面，当哈希表的负载因子小于 0.1 时，程序自动开始对哈希表执行收缩操作</p><p>但是，为了避免 rehash 对服务器性能造成影响，服务器不是一次性将 ht[0] 里面的所有键值对全部 rehash 到 ht[1] ，而是分多次、渐进式地将 ht[0] 里面的键值对慢慢地 rehash 到 ht[1]。</p><p>其方法是通过在字典中维护一个索引计数器变量 <code>rehashidx</code>，当 <code>rehashidx</code> 为 0 时，表示 rehash 工作正式开始，在 rehash 工作期间，每次对字典执行增删改查操作，都会顺带将 ht[0] 哈希表在 <code>rehashidx</code> 索引上的所有键值对 rehash 到 ht[1]，rehash 完成之后，<code>rehashidx</code> 自增一，最终在某个时间点 ht[0] 上所有键值对都会被 rehash 至 ht[1] ，这时程序将 <code>rehashidx</code> 属性值设为 1，表示 rehash 操作已完成。</p><p>渐进式 rehash 的好处在于它采取分而治之的方式，将 rehash 键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式 rehash 而带来的庞大计算量。</p><h2 id="4-跳跃表"><a href="#4-跳跃表" class="headerlink" title="4. 跳跃表"></a>4. 跳跃表</h2><p>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。跳跃表支持平均 O(logN) 、最坏 O(N) 度的节点查找，还可以通过顺序性操作来批量处理节点。Redis 只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构。</p><h3 id="4-1-跳跃表的实现"><a href="#4-1-跳跃表的实现" class="headerlink" title="4.1 跳跃表的实现"></a>4.1 跳跃表的实现</h3><p>Redis 的跳跃表由 <code>redis.h/zskiplistNode</code> 和 <code>redis.h/zskiplist</code> 两个结构定义，其中 <code>zskiplistNode</code> 结构用于表示跳跃表节点，而 <code>zskiplist</code> 结构则用于保存跳跃表节点的相关信息，比如节点的数量，以及指向表头节点和表尾节点的指针等。</p><p><img src="/posts/30038/image-20240323221355732.png" alt></p><h3 id="4-2-跳跃表节点"><a href="#4-2-跳跃表节点" class="headerlink" title="4.2 跳跃表节点"></a>4.2 跳跃表节点</h3><p>跳跃表节点的实现由 <code>redis.h/zskiplistNode</code> 结构定义</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> zskiplistNode <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 层</span>    <span class="token keyword">struct</span> zskiplistLevel <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 前进指针</span>        <span class="token keyword">struct</span> zskiplistNode <span class="token operator">*</span>forward<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 跨度</span>        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> span<span class="token punctuation">;</span>    <span class="token punctuation">}</span> level<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 后退指针</span>    <span class="token keyword">struct</span> zskiplistNode <span class="token operator">*</span>backward<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 分值</span>    <span class="token keyword">double</span> score<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 成员变量</span>    robj <span class="token operator">*</span>obj<span class="token punctuation">;</span><span class="token punctuation">}</span> zskiplistNode<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-整数集合"><a href="#5-整数集合" class="headerlink" title="5. 整数集合"></a>5. 整数集合</h2><ul><li>整数集合（intset）是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis 就会使用整数集合作为集合键的底层实现。</li></ul><p>每个 <code>intset.h/intset</code> 结构表示一个整数集合</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> intset <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 编码方式</span>    uint32_t encoding<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 集合中包含的元素数量</span>    uint32_t length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 保存元素的数组</span>    int8_t contents<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span> intset<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>contents</code> 数组是整数集合的底层实现：整数集合的每个元素都是 <code>contents</code> 数组的一个数组项（item），各个项在数组中按值的大小从小到大有序的排列，并且数组中不包含任何重复项。</p><h3 id="5-1-升级"><a href="#5-1-升级" class="headerlink" title="5.1 升级"></a>5.1 升级</h3><ul><li>每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现在所有元素的类型都要长时，整数集合需要先进行升级（upgrade），然后才能将新元素添加到整数集合里面</li></ul><h3 id="5-2-升级的好处"><a href="#5-2-升级的好处" class="headerlink" title="5.2 升级的好处"></a>5.2 升级的好处</h3><ul><li>整数集合的升级策略有两个好处，一个是提升整数集合的灵活性，另一个是尽可能的节约内存。</li></ul><blockquote><p>整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。</p></blockquote><h2 id="6-压缩列表"><a href="#6-压缩列表" class="headerlink" title="6. 压缩列表"></a>6. 压缩列表</h2><ul><li>压缩列表（ziplist）是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么 Redis 就会使用压缩列表来做列表键的底层实现。</li><li>压缩列表是 Redis 为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的 <strong>顺序型（sequential）数据结构</strong>。一个压缩列表可以包含任意 <strong>多个节点（entry）</strong>，每个节点可以保存一个字节数组或者一个整数值。</li><li>添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操作，但这种操作出现的几率并不高。</li></ul><h2 id="7-对象"><a href="#7-对象" class="headerlink" title="7. 对象"></a>7. 对象</h2><blockquote><p>前面已经介绍了 Redis 用到的所有主要数据结构，比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合等等。<br>Redis 并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象，每种对象都用到了至少一种我们前面所介绍的数据结构。<br>通过这五种不同类型的对象，Redis 可以在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令。使用对象的另一个好处是，我们可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率。<br>除此之外，Redis 的对象系统还实现了基于引用计数技术的内存回收机制以及对象共享机制，Redis 对象还带有访问时间记录信息，可以用于计算数据库键的空转时长等等。</p></blockquote><h3 id="7-1-对象的类型与编码"><a href="#7-1-对象的类型与编码" class="headerlink" title="7.1 对象的类型与编码"></a>7.1 对象的类型与编码</h3><p>Redis 使用对象来表示数据库中的键和值，每次当我们在 Redis 的数据库中新创建一个键值对时，我们 <strong>至少会创建两个对象</strong>，一个对象用作键值对的键（键对象），另一个对象用作键值对的值（值对象）。</p><p>Redis 中每个对象都由一个 <code>redisObject</code> 结构表示</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> redisObject <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 类型</span>    <span class="token keyword">unsigned</span> type<span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 编码</span>    <span class="token keyword">unsigned</span> encoding<span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 指向底层实现数据结构的指针</span>    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 引用计数</span>    <span class="token keyword">int</span> refcount<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 对象最后一次被命令程序访问的时间</span>    <span class="token keyword">unsigned</span> lru<span class="token punctuation">:</span><span class="token number">22</span><span class="token punctuation">;</span><span class="token punctuation">}</span> robj<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7-1-1-类型"><a href="#7-1-1-类型" class="headerlink" title="7.1.1 类型"></a>7.1.1 类型</h4><p>对象的 <code>type</code> 属性记录了对象的类型，其值可以是字符串对象、列表对象、哈希对象、集合对象、有序集合对象。</p><p>对于 Redis 数据库保存的键值对来说，键总是一个字符串对象，而值则可以是其他类型对象中的一种，因此：</p><ul><li>当我们称呼一个数据库键为 “字符串键” 时，我们指的是 “这个数据库键所对应的值为字符串对象”；</li><li>当我们称呼一个键为 “列表键” 时，我们指的是 “这个数据库键所对应的值为列表对象” 。</li></ul><p><code>TYPE</code> 命令的实现方式也与此类似，当我们对一个数据库键执行 <code>TYPE</code> 命令时，命令返回的结果为数据库键对应的值对象的类型，而不是键对象的类型。</p><h4 id="7-1-2-编码和底层实现"><a href="#7-1-2-编码和底层实现" class="headerlink" title="7.1.2 编码和底层实现"></a>7.1.2 编码和底层实现</h4><p>对象的 <code>ptr</code> 指针指向对象的底层实现数据结构，而这些数据结构由对象的 <code>encoding</code> 属性决定。</p><p><code>encoding</code> 属性记录了对象所使用的编码，也即是说这个对象使用了什么数据结构作为对象的底层实现。</p><p>使用 <code>OBJECT ENCODING</code> 命令可以查看一个数据库键的值对象的编码</p><h3 id="7-2-字符串对象"><a href="#7-2-字符串对象" class="headerlink" title="7.2 字符串对象"></a>7.2 字符串对象</h3><p>字符串对象的编码可以是 <code>int</code> 、<code>raw</code> 、或者 <code>embstr</code> 。</p><ul><li>如果一个字符串对象保存的是整数值，并且这个整数值可以用 <code>long</code> 类型来表示，那么字符串对象会将整数值保存在字符串对象结构的 <code>ptr</code> 属性里面（将 void* 转换成 long），并将字符串对象的编码设置为 <code>int</code> 。</li><li>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于 32 字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为 <code>raw</code> 。</li><li>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于 32 字节，那么字符串对象将使用 <code>embstr</code> 编码的方式来保存这个字符串值 。</li></ul><blockquote><p><code>raw</code> 与 <code>embstr</code> 的区别是：<code>raw</code> 编码会调用两次内存分配函数来分别创建 <code>redisObject</code> 结构和 <code>sdshdr</code> 结构，而 <code>embstr</code> 编码则通过一次内存分配函数来分配一块连续的空间，空间中依次包含 <code>redisObject</code> 和 <code>sdshdr</code> 两个结构 。<br>最后，long double 类型表示的浮点数在 Redis 中也是作为字符串值来保存的，保存时会先将浮点数转换成字符串值，然后再保存所得字符串值 。</p></blockquote><h4 id="7-2-1-编码的转换"><a href="#7-2-1-编码的转换" class="headerlink" title="7.2.1 编码的转换"></a>7.2.1 编码的转换</h4><p>对于 <code>int</code> 编码的字符串对象来说，如果我们向对象执行了一些命令，使这个对象保存的不再是整数值，而是一个字符串值，那么字符串对象的编码将从 <code>int</code> 变为 <code>raw</code> 。</p><p>另外 Redis 没有为 <code>embstr</code> 编码的字符串对象编写任何相应的修改程序（<code>int</code> 和 <code>raw</code> 有），所以 <code>embstr</code> 编码的字符串对象实际上是只读的，当对 <code>embstr</code> 编码的字符串对象执行任何修改命令时，程序会先将对象的编码从 <code>embstr</code> 转换成 <code>raw</code>，然后再执行修改命令。因为这个原因，<code>embstr</code> 编码的对象在执行修改命令之后，总会变成一个 <code>raw</code> 编码的字符串对象。</p><h3 id="7-3-列表对象"><a href="#7-3-列表对象" class="headerlink" title="7.3 列表对象"></a>7.3 列表对象</h3><p>列表对象的编码可以是 <code>ziplist</code> 或者 <code>linkedlist</code> 。</p><ul><li><code>ziplist</code> 编码的列表对象使用压缩列表作为底层实现，每个压缩列表节点（entry）保存了一个列表元素。</li><li><code>linkedlist</code> 编码的列表对象使用双端链表作为底层实现，每个双端链表节点（node）都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素</li></ul><h4 id="7-3-1-编码转换"><a href="#7-3-1-编码转换" class="headerlink" title="7.3.1 编码转换"></a>7.3.1 编码转换</h4><p>当列表对象可以同时满足以下两个条件时，列表对象使用 <strong>ziplist</strong> 编码：</p><ul><li>列表对象保存的所有字符串元素的长度都小于 64 字节；</li><li>列表对象保存的元素数量小于 512 个；</li></ul><p>不能满足这两个条件的列表对象需要使用 <strong>linkedlist</strong> 编码。注意这两个条件的上限值是可以修改的。</p><h3 id="7-4-哈希对象"><a href="#7-4-哈希对象" class="headerlink" title="7.4 哈希对象"></a>7.4 哈希对象</h3><p>哈希对象的编码可以是 <code>ziplist</code> 或者 <code>hashtable</code> 。</p><p>使用 <code>ziplist</code> 编码的哈希对象有以下特点：</p><ol><li>保存了同一键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后。</li><li>先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。</li></ol><p>使用 <code>hashtable</code> 编码的哈希对象有以下特点：</p><ol><li>字典的每个键都是一个字符串对象，对象中保存了键值对的键；</li><li>字典的每个值都是一个字符串对象，对象中保存了键值对的值；</li></ol><h4 id="7-4-1-编码转换"><a href="#7-4-1-编码转换" class="headerlink" title="7.4.1 编码转换"></a>7.4.1 编码转换</h4><p>当哈希对象可以同时满足以下两个条件时，哈希对象使用 <strong>ziplist</strong> 编码：</p><ol><li>哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节；</li><li>哈希对象保存的键值对数量小于 512 个；</li></ol><p>这两个条件的上限值也是可以修改的，不满足条件的哈希对象需要使用 <strong>hashtable</strong> 编码。</p><h3 id="7-5-集合对象"><a href="#7-5-集合对象" class="headerlink" title="7.5 集合对象"></a>7.5 集合对象</h3><p>集合对象的编码可以是 <code>intset</code> 或者 <code>hashtable</code> 。</p><ul><li><code>intset</code> 编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面。</li><li><code>hashtable</code> 编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为 null 。</li></ul><h4 id="7-5-1-编码转换"><a href="#7-5-1-编码转换" class="headerlink" title="7.5.1 编码转换"></a>7.5.1 编码转换</h4><p>当集合对象可以同时满足以下两个条件时，对象使用 <code>intset</code> 编码：</p><ol><li>集合对象保存的所有元素都是整数值；</li><li>集合对象保存的元素数量不超过 512 个；</li></ol><p>第二个条件的上限值是可以修改的，不满足这两个条件的集合对象需要使用 <code>hashtable</code> 编码。</p><h3 id="7-6-有序集合对象"><a href="#7-6-有序集合对象" class="headerlink" title="7.6 有序集合对象"></a>7.6 有序集合对象</h3><p>有序集合的编码可以是 <code>ziplist</code> 或者 <code>skiplist</code> 。</p><p>ziplist 编码的压缩对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member），而第二个元素则保存元素的分值（score），压缩列表内的集合元素按分值从小到大进行排序。</p><p><code>skiplist</code> 编码的有序集合对象使用 <code>zset</code> 结构作为底层实现，一个 <code>zset</code> 结构同时包含一个字典和一个跳跃表。</p><h4 id="7-6-1-编码转换"><a href="#7-6-1-编码转换" class="headerlink" title="7.6.1 编码转换"></a>7.6.1 编码转换</h4><p>当有序集合对象可以同时满足以下两个条件时，对象使用 <code>ziplist</code> 编码：</p><ol><li>有序集合保存的元素数量小于 128 个；</li><li>有序集合保存的所有元素成员长度都小于 64 字节；</li></ol><p>以上两个上限值都是可以修改的，不能满足这两个条件的有序集合对象将使用 <code>skiplist</code> 编码 。</p><h3 id="7-7-内存回收-amp-对象共享"><a href="#7-7-内存回收-amp-对象共享" class="headerlink" title="7.7 内存回收 &amp; 对象共享"></a>7.7 内存回收 &amp; 对象共享</h3><p>因为 C 语言并不具备自动内存回收功能，所以 Redis 在自己的对象系统中构建了一个引用计数（reference counting）技术实现的内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。每个对象的引用计数信息由 <code>redisObject</code> 结构的 <code>refcount</code> 属性记录。</p><p>除了用于实现引用计数内存回收机制之外，对象的引用计数属性还带有对象共享的作用。尽管共享更复杂的对象可以节约更多的内存，但受 CPU 时间的限制，Redis 只对包含整数值的字符串对象进行共享。</p><h3 id="7-8-对象的空转时长"><a href="#7-8-对象的空转时长" class="headerlink" title="7.8 对象的空转时长"></a>7.8 对象的空转时长</h3><p>除了之前介绍了 <code>type</code> 、<code>encoding</code> 、<code>ptr</code> 和 <code>refcount</code> 四个属性之外，<code>redisObject</code> 结构包含的最后一个属性为 <code>lru</code> 属性，该属性记录了对象最后一次被命令程序访问的时间。</p><p>使用命令 <code>OBJECT IDLETIME 给定键</code> 可以打印出给定键的空转时长，这一空转时长就是通过将当前时间减去键的值对象的 lru 时间计算得出的。</p><blockquote><p>除了可以被 <code>OBJECT IDLETIME 给定键</code> 命令打印出来之外，键的空转时长还有另外一项作用：如果服务器打开了 <code>maxmemory</code> 选项，并且服务器用于回收内存的算法为 <code>volatile-lru</code> 或者 <code>allkeys-lru</code> ，那么当服务器占用的内存数超过了 <code>maxmemory</code> 选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。</p></blockquote><h2 id="8-数据库"><a href="#8-数据库" class="headerlink" title="8. 数据库"></a>8. 数据库</h2><h3 id="8-1-服务器中的数据库"><a href="#8-1-服务器中的数据库" class="headerlink" title="8.1 服务器中的数据库"></a>8.1 服务器中的数据库</h3><p>Redis 服务器将所有数据库都保存在服务器状态 <code>redis.h/redisServer</code> 结构的 db 数组中，db 数组的每个项都是一个 <code>redis.h/redisDb</code> 结构，每个 <code>redisDb</code> 结构代表一个数据库。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> redisServer <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    <span class="token comment" spellcheck="true">// 一个数组，保存着服务器中的所有数据库</span>    redisDb <span class="token operator">*</span>db<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ...</span>    <span class="token comment" spellcheck="true">// 初始化服务器时，程序会根据服务器状态的 dbnum 属性</span>    <span class="token comment" spellcheck="true">// 来决定应该创建多少个数据库，默认是 16</span>    <span class="token keyword">int</span> dbnum<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以通过命令 <code>SELECT n</code> 来切换到 n 号数据库。</p><h3 id="8-2-数据库键空间"><a href="#8-2-数据库键空间" class="headerlink" title="8.2 数据库键空间"></a>8.2 数据库键空间</h3><p><code>redisDb</code> 结构的 <code>dict</code> 字典保存了数据库中所有键值对，我们将这个字典称为键空间（key space）。</p><p>键空间和用户所见的数据库是直接对应的</p><ul><li>键空间的键也就是数据库的键，每个键都是一个字符串对象。</li><li>键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种 Redis 对象。</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> redisDb <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    <span class="token comment" spellcheck="true">// 数据库键空间，保存着数据库中的所有键值对</span>    dict <span class="token operator">*</span>dict<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 过期字典，保存着键的过期时间</span>    dict <span class="token operator">*</span>expires<span class="token punctuation">;</span><span class="token punctuation">}</span> redisDb<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-3-键的生存时间或过期时间"><a href="#8-3-键的生存时间或过期时间" class="headerlink" title="8.3 键的生存时间或过期时间"></a>8.3 键的生存时间或过期时间</h3><p>redisDb 结构的 <code>expires</code> 字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典：</p><ul><li>过期字典的键是一个指针，这个指针指向键空间中某个键对象（也即是某个数据库键）。</li><li>过期字典的值是一个 long long 类型的整数，这个整数保存了键所指向的数据库键的过期时间–一个毫秒精度的 UNIX 时间戳。</li></ul><p><img src="/posts/30038/image-20240323224406093.png" alt></p><h3 id="8-4-过期键的删除策略"><a href="#8-4-过期键的删除策略" class="headerlink" title="8.4 过期键的删除策略"></a>8.4 过期键的删除策略</h3><p>有三种不同的删除策略：</p><ol><li>定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。</li><li>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话就删除该键；如果没有，就返回该键。</li><li>定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</li></ol><p>为了更好更合理的在 CPU 时间以及避免浪费内存空间之间取得平衡，Redis 服务器使用 <strong>惰性删除</strong> 和 <strong>定期删除</strong> 两种策略。</p><h3 id="8-5-AOF、RDB-和复制功能对过期键的处理"><a href="#8-5-AOF、RDB-和复制功能对过期键的处理" class="headerlink" title="8.5 AOF、RDB 和复制功能对过期键的处理"></a>8.5 AOF、RDB 和复制功能对过期键的处理</h3><h4 id="8-5-1-载入-RDB-文件"><a href="#8-5-1-载入-RDB-文件" class="headerlink" title="8.5.1 载入 RDB 文件"></a>8.5.1 载入 RDB 文件</h4><p>在启动服务器时，如果服务器开启了 RDB 功能，那么服务器将对 RDB 文件进行载入：</p><ul><li>如果服务器以主服务器模式运行，那么在载入 RDB 文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键对载入 RDB 文件的主服务器不会造成影响。</li><li>如果服务器以从服务器模式运行，那么在载入 RDB 文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。不过，因为主从服务器在进行数据同步的时候，从服务器的数据库就会被清空，所以一般来讲，过期键对载入 RDB 文件的从服务器也不会造成影响。</li></ul><h4 id="8-5-1-AOF-文件写入"><a href="#8-5-1-AOF-文件写入" class="headerlink" title="8.5.1 AOF 文件写入"></a>8.5.1 AOF 文件写入</h4><p>当服务器以 AOF 持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么 AOF 文件不会因为这个过期键而产生任何影响。</p><p>当过期键被惰性删除或者定期删除之后，程序回向 AOF 文件追加（append）一条 DEL 命令，来显式地记录该键已经被删除。</p><h4 id="8-5-2-AOF-重写"><a href="#8-5-2-AOF-重写" class="headerlink" title="8.5.2 AOF 重写"></a>8.5.2 AOF 重写</h4><p>和生成 RDB 文件时类似，在执行 AOF 重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的 AOF 文件中。</p><h4 id="8-5-3-复制"><a href="#8-5-3-复制" class="headerlink" title="8.5.3 复制"></a>8.5.3 复制</h4><p>当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制：</p><ul><li>主服务器在删除一个过期键之后，会显式的向所有从服务器发送一个 <code>DEL</code> 命令，告知从服务器删除这个过期键。</li><li>从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键。</li><li>从服务器只有在接到主服务器发来的 <code>DEL</code> 命令之后，才会删除过期键。</li></ul><p>通过由主服务器来控制从服务器统一地删除过期键，可以保证主从服务器数据的一致性，也正是因为这个原因，当一个过期键仍然存在于主服务器的数据库时，这个过期键在从服务器里的复制品也会继续存在。</p><h4 id="8-5-4-数据库通知"><a href="#8-5-4-数据库通知" class="headerlink" title="8.5.4 数据库通知"></a>8.5.4 数据库通知</h4><p>数据库通知功能可以让客户端通过订阅给定的频道或者模式，来获知数据库中键的变化，以及数据库中命令的执行情况。</p><ul><li>“某个键执行了什么命令” 的通知称为键空间通知（key-space notification）</li><li>“某个命令被什么键执行了” 的通知称为键事件通知（key-event notification）</li></ul><p>当 Redis 命令对数据库进行修改之后，服务器会根据配置向客户端发送数据库通知。</p><h2 id="9-RDB-持久化"><a href="#9-RDB-持久化" class="headerlink" title="9. RDB 持久化"></a>9. RDB 持久化</h2><h3 id="9-1-RDB-文件的创建与载入"><a href="#9-1-RDB-文件的创建与载入" class="headerlink" title="9.1 RDB 文件的创建与载入"></a>9.1 RDB 文件的创建与载入</h3><p>有两个 Redis 命令可以用于生成 RDB 文件，一个是 <code>SAVE</code> ，另一个是 <code>BGSAVE</code>。</p><ul><li><code>SAVE</code> 命令会阻塞 <code>Redis</code> 服务器进程，直到 RDB 文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求。</li><li>与 <code>SAVE</code> 命令直接阻塞服务器进程的做法不同，<code>BGSAVE</code> 命令会派生出一个子进程，然后由子进程负责创建 RDB 文件，服务器进程（父进程）继续处理命令请求。</li></ul><p>RDB 文件的载入工作是在服务器启动时自动执行的，所以 Redis 并没有专门用于载入 RDB 文件的命令，只要 Redis 服务器在启动时检测到 RDB 文件存在，它就会自动载入 RDB 文件。</p><p>另外，因为 AOF 文件的更新频率通常比 RDB 文件的更新频率高，所以：</p><ul><li>如果服务器开启了 AOF 持久化功能，那么服务器会优先使用 AOF 文件来还原数据库状态。</li><li>只有在 AOF 持久化功能处于关闭状态时，服务器才会使用 RDB 文件来还原数据库状态。</li></ul><p>服务器在载入 RDB 文件期间，会一直处于阻塞状态，直到载入工作完成为止。</p><h3 id="9-2-自动间隔性保存"><a href="#9-2-自动间隔性保存" class="headerlink" title="9.2 自动间隔性保存"></a>9.2 自动间隔性保存</h3><p>因为 <code>BGSAVE</code> 命令可以在不阻塞服务器进程的情况下执行，所以 Redis 允许用户通过设置服务器配置的 <code>save</code> 选项，让服务器每个一段时间自动执行一次 <code>BGSAVE</code> 命令。</p><p>用户可以通过 <code>save</code> 选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行 <code>BGSAVE</code> 命令。</p><p>Redis 的服务器周期性操作函数 <code>serverCron</code> 默认每个 100 毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查 <code>save</code> 选项所设置的保存条件是否已经满足，如果满足的话，就执行 <code>BGSAVE</code> 命令。</p><h2 id="10-AOF-持久化"><a href="#10-AOF-持久化" class="headerlink" title="10. AOF 持久化"></a>10. AOF 持久化</h2><p>与 RDB 持久化通过保存数据库中的键值对来记录数据库状态不同，AOF（Append Only File）持久化时通过保存 Redis 服务器所执行的写命令来记录数据库状态的。</p><h3 id="10-1-AOF-持久化的实现"><a href="#10-1-AOF-持久化的实现" class="headerlink" title="10.1 AOF 持久化的实现"></a>10.1 AOF 持久化的实现</h3><p>AOF 持久化功能的实现可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤。</p><h4 id="10-1-1-命令追加"><a href="#10-1-1-命令追加" class="headerlink" title="10.1.1 命令追加"></a>10.1.1 命令追加</h4><p>当 AOF 持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的 <code>aof_buf</code> 缓冲区的末尾。</p><h4 id="10-1-2-文件的写入与同步"><a href="#10-1-2-文件的写入与同步" class="headerlink" title="10.1.2 文件的写入与同步"></a>10.1.2 文件的写入与同步</h4><blockquote><p>为了提高文件的写入效率，在现代操作系统中，当用户调用 <code>write</code> 函数，将一些数据写入到文件的时候，操作系统通常会将写入数据暂时保存在一个内存缓冲区里面，等到缓冲区的空间被填满、或者超过了指定的时限之后，才真正的将缓冲区中的数据写入到磁盘里面。<br>这种做法虽然提高了效率，但也为写入数据带来了安全问题，因为如果计算机发生停机，那么保存在内存缓冲区里面的写入数据将会丢失。</p></blockquote><p>因此，Redis 服务器配置 <code>appendfsync</code> 选项的值直接决定 AOF 持久化功能的效率和安全性。</p><p>下面是配置可选值：</p><p><img src="/posts/30038/image-20240323224837065.png" alt></p><h3 id="10-2-AOF-文件的载入与数据还原"><a href="#10-2-AOF-文件的载入与数据还原" class="headerlink" title="10.2 AOF 文件的载入与数据还原"></a>10.2 AOF 文件的载入与数据还原</h3><p>因为 AOF 文件里面包含了重建数据库状态所需的所有写命令，所以服务器只要读入并重新执行一遍 AOF 文件里面保存的写命令，就可以还原服务器关闭之前的数据库状态。</p><p>步骤如下：</p><ol><li>创建一个不带网络连接的伪客户端（fake client）</li><li>从 AOF 文件中分析并读取一条写命令</li><li>使用伪客户端执行被读出的写命令</li><li>重复执行步骤 2 与 步骤 3 ，直到 AOF 中的所有写命令都被处理完毕为止。</li></ol><h3 id="10-3-AOF-重写"><a href="#10-3-AOF-重写" class="headerlink" title="10.3 AOF 重写"></a>10.3 AOF 重写</h3><p>因为 AOF 持久化是通过保存被执行的写命令来记录数据库状态的，所以随着服务器运行时间的流逝，AOF 文件中的内容越来越多，文件体积也会越来越大，如果不加以控制，体积过大的 AOF 文件很可能对 Redis 服务器、甚至整个宿主计算机造成影响，并且 AOF 文件体积越大，使用 AOF 文件来进行数据还原所需的时间就越多。</p><p>为了解决 AOF 文件体积膨胀的问题，Redis 提供了 AOF 文件重写（rewrite）功能。通过该功能，Redis 服务器可以创建一个新的 AOF 文件来替代现有的 AOF 文件，新旧两个 AOF 文件所保存的数据库状态相同，但新 AOF 文件不会包含任何浪费空间的冗余命令，所以新 AOF 文件的体积通常会比旧 AOF 文件的体积要小得多。</p><p>AOF 文件重写并不需要对现有的 AOF 文件进行任何读取、分析或者写入操作，这个功能是通过读取服务器当前的数据库状态来实现的。</p><p>首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令，这就是 AOF 重写功能的实现原理。</p><p>Redis 将 AOF 重写程序放到子进程里执行，这样子进程在进行 AOF 重写期间，服务器进程（父进程）可以继续处理命令请求，并且可以避免在使用锁的情况下，保证数据的安全性。</p><p>但是，使用子进程也有一个问题需要解决，因为子进程在进行 AOF 重写期间，服务器还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写后的 AOF 文件所保存的数据库状态不一致。</p><p>为了解决这种数据不一致的问题，Redis 服务器设置了一个 AOF 重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当 Redis 服务器执行完一个写命令之后，它会同时将这个命令发送给 AOF 缓冲区和 AOF 重写缓冲区。</p><p>当子进程完成 AOF 重写工作之后，它会向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作：</p><ol><li>将 AOF 重写缓冲区中的所有内容写入到新 AOF 文件中，这时新 AOF 文件所保存的数据库状态将和服务器当前的数据库状态一致。</li><li>对新的 AOF 文件进行改名，原子地（atomic）覆盖现有的 AOF 文件，完成新旧两个 AOF 文件的替换。</li></ol><p>这个信号处理函数执行完毕之后，父进程就可以继续像往常一样接受命令请求了。</p><p>在整个 AOF 后台重写过程中，只有信号处理函数执行时会对服务器进程（父进程）造成阻塞，在其它时候，AOF 后台重写都不会阻塞父进程，这将 AOF 重写对服务器性能造成的影响降到了最低。</p><blockquote><p>总结 AOF 重写就是，在执行 <code>BGREWRITEAOF</code> 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新的 AOF 文件的末尾，使得新旧两个 AOF 文件所保存的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</p></blockquote><h2 id="11-事件"><a href="#11-事件" class="headerlink" title="11. 事件"></a>11. 事件</h2><p>Redis 服务器是一个事件驱动器，服务器需要处理以下两类事件：</p><ul><li>文件事件（file event）：Redis 服务器通过套接字与客户端（或者其它 Redis 服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或者其它服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。</li><li>时间事件（time event）：Redis 服务器中的一些操作（比如 <code>serverCron</code> 函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。</li></ul><h3 id="11-1-文件事件"><a href="#11-1-文件事件" class="headerlink" title="11.1 文件事件"></a>11.1 文件事件</h3><p>Redis 基于 <code>Reactor</code> 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）：</p><ul><li>文件事件处理器使用 I / O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li><li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul><p>虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其它同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p><p>文件事件分为 <code>AE_READABLE</code> 事件（读事件）和 <code>AE_WRITEABLE</code> 事件（写事件）两类。</p><h3 id="11-2-时间事件"><a href="#11-2-时间事件" class="headerlink" title="11.2 时间事件"></a>11.2 时间事件</h3><p>Redis 的时间事件分为以下两类：</p><ul><li>定时事件：让一段程序在指定的时间之后执行一次。比如说，让程序 X 在当前时间的 30 毫秒之后执行一次。</li><li>周期性事件：让一段程序每隔指定时间就执行一次。比如说，让程序 X 每隔 30 毫秒就执行一次。</li></ul><p>服务器在一般情况下只执行 <code>serverCron</code> 函数一个时间事件，并且这个事件是周期性事件。</p><p>时间事件的实际处理时间通常会比设定的到达时间晚一些。</p><blockquote><p>文件事件和时间事件之间是合作关系，服务器会轮流处理这两种事件，并且处理事件的过程中也不会进行抢占。</p></blockquote><h2 id="12-复制"><a href="#12-复制" class="headerlink" title="12. 复制"></a>12. 复制</h2><p>在 Redis 中，用户可以通过执行 <code>SLAVEOF</code> 命令或者设置 <code>slaveof</code> 选项，让一个服务器去复制（replicate）另一个服务器，我们称呼被复制的服务器为主服务器（master），而对主服务器进行复制的服务器被称为从服务器（slave）。</p><h3 id="12-1-复制功能的实现"><a href="#12-1-复制功能的实现" class="headerlink" title="12.1 复制功能的实现"></a>12.1 复制功能的实现</h3><p>Redis 的复制功能分为同步（sync）和命令传播（command propagate）两个操作：</p><ul><li>同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态。</li><li>命令传播操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态。</li></ul><p>在 Redis 的旧版复制功能中存在着缺陷，也就是当从服务器断线后重复制的效率非常低。在旧版复制功能中，从服务器断线之后重连，需要请求主服务器重新执行 <code>BGSAVE</code> 命令生成包含全部数据库状态的 RDB 文件，然后再传输给从服务器，从服务器接受载入 RDB 文件，其效率非常低下。</p><p>为了解决旧版复制功能在处理断线重复制情况时的低效问题，Redis 从 2.8 版本开始，使用 <code>PSYNC</code> 命令代替 <code>SYNC</code> 命令来执行复制时的同步操作。</p><p><code>PSYNC</code> 命令具有两种模式：</p><ul><li>完整重同步（full resynchronization）：用于处理初次复制情况，执行步骤与 <code>SYNC</code> 命令的执行步骤基本一样，它们都是通过让主服务器创建并发送 RDB 文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步。</li><li>部分重同步（partial resynchronization）：用于处理断线后的重复制情况，当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态。</li></ul><h3 id="12-2-心跳检测"><a href="#12-2-心跳检测" class="headerlink" title="12.2 心跳检测"></a>12.2 心跳检测</h3><p>在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令 <code>REPLCONF ACK &lt;replication_offset&gt;</code> ，其中 <code>replication_offset</code> 是从服务器当前的复制偏移量。</p><p>发送 <code>REPLCONF ACK</code> 命令对于从服务器有三个作用：</p><ul><li>检测主从服务器的网络连接状态。</li><li>辅助实现 <code>min-slaves</code> 选项。</li><li>检测命令是否丢失。</li></ul><h2 id="13-Sentinel"><a href="#13-Sentinel" class="headerlink" title="13. Sentinel"></a>13. Sentinel</h2><p>Sentinel（哨岗、哨兵）是 Redis 的高可用性解决方案：由一个或多个 Sentinel 实例（instance）组成的 Sentinel 系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p><p>Sentinel 本质上只是一个运行在特殊模式下的 Redis 服务器。</p><p>Sentinel 的启动命令</p><pre class="line-numbers language-text"><code class="language-text">redis-sentinel /path/to/your/sentinel.conf# 或者是redis-server /path/to/your/sentinel.conf --sentinel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="13-1-主观下线"><a href="#13-1-主观下线" class="headerlink" title="13.1 主观下线"></a>13.1 主观下线</h3><p>在默认情况下，Sentinel 会以每秒一次的频率向所有与它创建了命令连接的实例（包括主服务器、从服务器、其它 Sentinel 在内）发送 <code>PING</code> 命令，并通过实例返回的 <code>PING</code> 命令回复来判断实例是否在线。</p><p>如果在默认配置的间隔时间内，有一服务器并没有进行有效回复，那此 Sentinel 就会将此服务器标记为主观下线。</p><h3 id="13-2-客观下线"><a href="#13-2-客观下线" class="headerlink" title="13.2 客观下线"></a>13.2 客观下线</h3><p>当 Sentinel 将一个服务器判断为主观下线之后，为了确定此服务器是否是真的下线了，它会去询问其它 Sentinel 此服务器是否已下线，当得到足够数量的确定回复之后，Sentinel 就会将此服务器标记为客观下线状态，如果此服务器是主服务器，就执行故障转移操作。</p><h3 id="13-3-选举领头-Sentinel"><a href="#13-3-选举领头-Sentinel" class="headerlink" title="13.3 选举领头 Sentinel"></a>13.3 选举领头 Sentinel</h3><p>当一个主服务器被判定为客观下线之后，监视这个下线主服务器的各个 Sentinel 会进行协商，选举出一个领头 Sentinel，并由领头 Sentinel 对下线主服务器执行故障转移操作。</p><h3 id="13-4-故障转移"><a href="#13-4-故障转移" class="headerlink" title="13.4 故障转移"></a>13.4 故障转移</h3><p>在选举产生领头 Sentinel 之后，领头 Sentinel 将对已下线的主服务器执行故障转移操作，包含以下三个步骤：</p><ol><li>在已下线主服务器的所有从服务器中，选择一个从服务器将其转换为新的主服务器。</li><li>让已下线主服务器的所有从服务器改为复制新的从服务器。</li><li>将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线时，他就会成为新的主服务器的从服务器。</li></ol><h2 id="14-集群"><a href="#14-集群" class="headerlink" title="14. 集群"></a>14. 集群</h2><p>Redis 集群是 Redis 提供的分布式数据库方案，集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能。</p><p>一个 Redis 集群通常由多个节点组成，在刚开始的时候，每个节点都是相互独立的，它们都处于一个只包含自己的集群当中，要组建一个真正可工作的集群，我们必须将各个独立的节点连接起来，构成一个包含多个节点的集群。</p><pre class="line-numbers language-text"><code class="language-text"># 连接各个节点的工作可以使用这个命令来完成CLUSTER MEET <ip> <port><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="14-1-槽指派"><a href="#14-1-槽指派" class="headerlink" title="14.1 槽指派"></a>14.1 槽指派</h3><p>Redis 集群通过分片的方式来保存数据库中的键值对：集群的整个数据库被分为 16384 个槽（slot），数据库中的每个键都属于这 16384 个槽的其中一个，集群中的每个节点可以处理 0 个或最多 16384 个槽。每个节点都会记录哪些槽指派给了自己，而哪些槽又被指派给了其它节点。</p><p>当数据库中的 16384 个槽都有节点在处理时，集群处于上线状态（ok）；相反地，如果数据库中有任何一个槽没有得到处理，那么集群处于下线状态（fail）。</p><p>节点在接到一个命令请求时，会先检查这个命令请求要处理的键所在的槽是否由自己负责，如果不是的话，节点将向客户端返回一个 MOVED 错误，MOVED 错误携带的信息可以指引客户端转向至正在负责相关槽的节点。</p><p>对 Redis 集群的重新分片工作是由 <code>redis-trib</code> 负责执行的，重新分片的关键是将属于某个槽的所有键值对从一个节点转移至另一个节点。</p><p>如果节点 A 正在迁移槽 i 至节点 B ，那么当节点 A 没能在自己的数据库中找到命令指定的数据库键时，节点 A 会向客户端返回一个 ASK 错误，指引客户端到节点 B 继续查找指定的数据库键。</p><p>MOVED 错误表示槽的负责权已经从一个节点转移到了另一个节点，而 ASK 错误只是两个节点在迁移槽的过程中使用的一种临时措施。</p><p>集群中的从节点用于复制主节点，并在主节点下线时，代替主节点继续处理命令请求。</p><p>集群中的节点通过发送和接收消息来进行通信，常见的消息包括 <code>MEET</code>、<code>PING</code>、<code>PONG</code>、<code>PUBLISH</code>、<code>FAIL</code> 五种。</p><h2 id="15-发布与订阅"><a href="#15-发布与订阅" class="headerlink" title="15. 发布与订阅"></a>15. 发布与订阅</h2><p>Redis 的发布与订阅功能由 <code>PUBLISH</code>、<code>SUBSCRIBE</code>、<code>PSUBSCRIBE</code> 等命令组成</p><ul><li><code>SUBSCRIBE</code> 是频道订阅，客户端可以订阅一个或多个频道，成为这些频道的订阅者（<code>subscriber</code>），每当有其它客户端向被订阅的频道发送消息时，频道的所有订阅者都会收到这条消息</li><li><code>PSUBSCRIBE</code> 是基于模式的订阅，除了订阅频道之外，客户端还可以通过执行 <code>PSUBSCRIBE</code> 命令订阅一个或多个模式，从而成为这些模式的订阅者，每当有其它客户端向某个频道发送消息时，消息不仅会被发送给这个频道的所有订阅者，它还会发送给所有与这个频道相匹配的模式的订阅者。</li></ul><p>客户端可以通过 <code>PUBSUB</code> 命令来查看频道或者模式的相关信息，比如某个频道目前有多少订阅者，又或者某个模式目前有多少订阅者等等。</p><p>当一个 Redis 客户端执行 <code>PUBLISH &lt;channel&gt; &lt;message&gt;</code> 命令将消息 message 发送给频道 channel 的时候，服务器需要执行以下两个动作：</p><ol><li>将消息 message 发送给 channel 频道的所有订阅者。</li><li>如果有一个或多个模式的 <code>pattern</code> 与频道 channel 相匹配，那么将消息 message 发送给 <code>pattern</code> 模式的订阅者。</li></ol><h2 id="16-事务"><a href="#16-事务" class="headerlink" title="16. 事务"></a>16. 事务</h2><p>Redis 通过 <code>MULTI</code>、<code>EXEC</code>、<code>WATCH</code> 等命令来实现事务功能。事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其它客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其它客户端的命令请求。事务以 <code>MULTI</code> 开始，以 <code>EXEC</code> 命令结束。</p><h3 id="16-1-事务的实现"><a href="#16-1-事务的实现" class="headerlink" title="16.1 事务的实现"></a>16.1 事务的实现</h3><ol><li><code>MULTI</code> 命令的执行代表事务的开始，<code>MULTI</code> 通过将客户端状态的 <code>flags</code> 属性中的 <code>REDIS_MULTI</code> 标识打开来将执行该命令的客户端切换至事务状态。</li><li>每个客户端都有自己的事务状态，它保存在客户端状态的 <code>mstate</code> 属性里面，<code>mstate</code> 里面包含一个事务队列，以及一个已入队命令的计数器，事务队列是一个 <code>multiCmd</code> 类型的数组，每个 <code>multiCmd</code> 结构都保存着一个已入队命令的相关信息，事务队列以先进先出（FIFO）的方式保存入队命令。</li><li>当一个处于事务状态的客户端向服务器发送 <code>EXEC</code> 命令时，这个 <code>EXEC</code> 命令会立即被执行。服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得的结果全部返回给客户端。</li></ol><h3 id="16-2-WATCH-命令的实现"><a href="#16-2-WATCH-命令的实现" class="headerlink" title="16.2 WATCH 命令的实现"></a>16.2 WATCH 命令的实现</h3><blockquote><p><code>WATCH</code> 命令是一个乐观锁，它可以在 <code>EXEC</code> 命令执行之前，监视任意数量的数据库键，并在 <code>EXEC</code> 命令执行时，检查被监视的键是否至少有一个已经被修改过了，如果是的话，服务器将拒绝执行事务，并向客户端返回代表事务执行失败的回复。</p></blockquote><p>每个Redis 数据库都保存着一个 <code>watched_keys</code> 字典，这个字典的键是某个被 <code>WATCH</code> 命令监视的数据库键，而字典的值则是一个链表，链表中记录了所有监视相应数据库键的客户端。通过 <code>watched_keys</code> 字典，服务器可以清楚地知道哪些数据库键正在被监视，以及哪些客户端正在监视这些数据库键。</p><p>通过执行 <code>WATCH</code> 命令，客户端可以在 <code>watched_keys</code> 字典中与被监视的键进行关联。</p><p>当前客户端为 c10086 ，在执行 <code>WATCH &quot;name&quot; &quot;age&quot;</code> 命令之后，如下图所示：</p><p><img src="/posts/30038/image-20240323224948348.png" alt></p><p>所有对数据库进行修改的命令，在执行之后都会调用 <code>touchWatchKey</code> 函数对 <code>watched_key</code> 字典进行检查，查看是否有客户端正在监视刚刚被命令修改过的数据库键，如果有的话，那么 <code>touchWatchKey</code> 函数会将监视被修改键的客户端的 <code>REDIS_DIRTY_CAS</code> 标识打开，表示该客户端的事务安全性已经被破坏。</p><p>当服务器接收到一个客户端发来的 <code>EXEC</code> 命令时，服务器会根据这个客户端是否打开了 <code>REDIS_DIRTY_CAS</code> 标识来决定是否执行事务，如果标识被打开，说明客户端所监视的键当中，至少有一个键已经被修改过了，服务器会拒绝执行客户端所提交的事务；如果标识没有被打开，说明事务仍然是安全的，服务器会执行客户端提交的事务。</p><h3 id="16-3-事务的-ACID-性质"><a href="#16-3-事务的-ACID-性质" class="headerlink" title="16.3 事务的 ACID 性质"></a>16.3 事务的 ACID 性质</h3><p>Redis 的事务总是具有 ACID 中的原子性、一致性和隔离性，当服务器运行在 AOF 持久化模式下，并且 <code>appendfsync</code> 选项的值为 <code>always</code> 时，事务也具有耐久性。</p><h2 id="17-排序"><a href="#17-排序" class="headerlink" title="17. 排序"></a>17. 排序</h2><p>Redis 的 <code>SORT</code> 命令可以对列表键、集合键或者有序集合键的值进行排序。</p><p><code>SORT</code> 命令通过将被排序键包含的元素载入到数组里面，然后对数组进行排序来完成对键进行排序的工作，排序操作由快速排序算法实现。</p><h2 id="18-二进制位数组"><a href="#18-二进制位数组" class="headerlink" title="18. 二进制位数组"></a>18. 二进制位数组</h2><p>Redis 提供了 <code>SETBIT</code>、<code>GETBIT</code>、<code>BITCOUNT</code>、<code>BITOP</code> 四个命令用于处理二进制位数组，又称 “位数组”</p><ul><li><code>SETBIT</code> 命令用于为位数组指定偏移量上的二进制位设置值，可以是 0 或者 1</li><li><code>GETBIT</code> 用于获取指定偏移量上的二进制位的值</li><li><code>BITCOUNT</code> 用于统计位数组里面，值为 1 的二进制位的数量</li><li><code>BITOP</code> 可以对多个位数组进行按位与（and）、按位或（or）、按位异或（xor）、取反（not）运算</li></ul><p>Redis 使用 SDS 来保存位数组</p><h2 id="19-慢查询日志"><a href="#19-慢查询日志" class="headerlink" title="19. 慢查询日志"></a>19. 慢查询日志</h2><ul><li>Redis 的慢查询日志功能用于记录执行时间超过给定时长的命令请求，用户可以通过这个功能产生的日志来监视和优化查询速度。</li></ul><h2 id="20-监视器"><a href="#20-监视器" class="headerlink" title="20. 监视器"></a>20. 监视器</h2><ul><li>客户端可以通过执行 <code>MONITOR</code> 命令，将客户端转换成监视器，接收并打印服务器处理的每个命令请求的相关信息</li><li>当一个客户端从普通客户端变为监视器时，该客户端的 <code>REDIS_MONITOR</code> 标识会被打开</li><li>服务器将所有监视器都记录在 <code>monitors</code> 链表中</li><li>每次处理命令时，服务器都会遍历 <code>monitors</code> 链表，将相关信息发送给监视器。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;首先，学习一个项目最好的方法就是看文档，&lt;a href=&quot;https://redis.io/docs/&quot;&gt;redis文档&lt;/a&gt;里面就介绍了
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://JoyTsing.github.io/categories/Redis/"/>
    
    
      <category term="C" scheme="https://JoyTsing.github.io/tags/C/"/>
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
      <category term="数据库" scheme="https://JoyTsing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="https://JoyTsing.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Go并发基础</title>
    <link href="https://joytsing.github.io/posts/1938/"/>
    <id>https://joytsing.github.io/posts/1938/</id>
    <published>2024-03-21T16:38:19.000Z</published>
    <updated>2024-03-22T06:44:55.188Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>基本上大部分编程语言在并发上的编程范式都差不多，配合Cpp食用更佳。这里推荐一本书，&lt;&lt;深入理解Go并发编程&gt;&gt;。</p><h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><h3 id="动态栈"><a href="#动态栈" class="headerlink" title="动态栈"></a>动态栈</h3><p>操作系统的线程一般都有固定的栈内存（通常为2MB）,而 Go 语言中的 goroutine 非常轻量级，一个 goroutine 的初始栈空间很小（一般为2KB），所以在 Go 语言中一次创建数万个 goroutine 也是可能的。并且 goroutine 的栈不是固定的，可以根据需要动态地增大或缩小， Go 的 runtime 会自动为 goroutine 分配合适的栈空间。</p><h3 id="goroutine调度"><a href="#goroutine调度" class="headerlink" title="goroutine调度"></a>goroutine调度</h3><p>操作系统内核在调度时会挂起当前正在执行的线程并将寄存器中的内容保存到内存中，然后选出接下来要执行的线程并从内存中恢复该线程的寄存器信息，然后恢复执行该线程的现场并开始执行线程。从一个线程切换到另一个线程需要完整的上下文切换。因为可能需要多次内存访问，索引这个切换上下文的操作开销较大，会增加运行的cpu周期。</p><p>区别于操作系统内核调度操作系统线程，goroutine 的调度是Go语言运行时（runtime）层面的实现，是完全由 Go 语言本身实现的一套调度系统——go scheduler。它的作用是按照一定的规则将所有的 goroutine 调度到操作系统线程上执行。</p><p>在经历数个版本的迭代之后，目前 Go 语言的调度器采用的是 <code>GPM</code> 调度模型。</p><p><img src="/posts/1938/gpm.png" alt></p><p>其中：</p><ul><li>G：表示 goroutine，每执行一次<code>go f()</code>就创建一个 G，包含要执行的函数和上下文信息。</li><li>全局队列（Global Queue）：存放等待运行的 G。</li><li>P：表示 goroutine 执行所需的资源，最多有 GOMAXPROCS 个。</li><li>P 的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建 G 时，G 优先加入到 P 的本地队列，如果本地队列满了会批量移动部分 G 到全局队列。</li><li>M：线程想运行任务就得获取 P，从 P 的本地队列获取 G，当 P 的本地队列为空时，M 也会尝试从全局队列或其他 P 的本地队列获取 G。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。</li><li>Goroutine 调度器和操作系统调度器是通过 M 结合起来的，每个 M 都代表了1个内核线程，操作系统调度器负责把内核线程分配到 CPU 的核上执行。</li></ul><p>单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的， goroutine 则是由Go运行时（runtime）自己的调度器调度的，完全是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身 goroutine 的超轻量级，以上种种特性保证了 goroutine 调度方面的性能。</p><ul><li><p>Work stealing</p><p>所有P放满了才会放到全局队列，如果某个M没东西了，会从其他P偷一个G过来，· 其他P没得偷从全局中拿一个</p></li><li><p>handoff</p></li></ul><p>如果某P的本地队列中的某G使得M阻塞，P会移动到另一个唤醒/创建的M，原来的M在G运行完之后睡眠或者销毁</p><h3 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h3><p>可以用<code>sync.WaitGroup</code>来让主线程在其他用户线程之后退出</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"sync"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 声明全局等待组变量</span><span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup<span class="token keyword">func</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span>    wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 告知当前goroutine完成</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 登记1个goroutine</span>    <span class="token keyword">go</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"你好"</span><span class="token punctuation">)</span>    wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 阻塞等待登记的goroutine完成</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>Go语言采用的并发模型是<code>CSP（Communicating Sequential Processes）</code>，提倡<strong>通过通信共享内存</strong>而不是<strong>通过共享内存而实现通信</strong>。</p><p>只读通道：<code>v &lt;-chan int</code></p><p>只写通道：<code>v chan&lt;- int</code></p><p><strong>注意：</strong>一个通道值是可以被垃圾回收掉的。通道通常由发送方执行关闭操作，并且只有在接收方明确等待通道关闭的信号时才需要执行关闭操作。它和关闭文件不一样，通常在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</p><p>关闭后的通道有以下特点：</p><ol><li>对一个关闭的通道再发送值就会导致 panic。</li><li>对一个关闭的通道进行接收会一直获取值直到通道为空。</li><li>对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</li><li>关闭一个已经关闭的通道会导致 panic。</li></ol><p>无缓冲通道：<code>c := make(chan int)</code></p><p>有缓冲通道：<code>cc := make(chan int, 3)</code></p><p>对无缓冲通道发送消息而不接收会造成死锁，我们要创建一个goroutine来接收通道中的内容：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">recv</span><span class="token punctuation">(</span>c <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ret <span class="token operator">:=</span> <span class="token operator">&lt;-</span>c    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"接收成功"</span><span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">recv</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 创建一个 goroutine 从通道接收值</span>    ch <span class="token operator">&lt;-</span> <span class="token number">10</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"发送成功"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以用多返回值模式来判断通道是否关闭：</p><pre class="line-numbers language-go"><code class="language-go">value<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span> ch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中：</p><ul><li>value：从通道中取出的值，如果通道被关闭则返回对应类型的零值。</li><li>ok：通道ch关闭时返回 false，否则返回 true。</li></ul><h3 id="Worker-Pool"><a href="#Worker-Pool" class="headerlink" title="Worker Pool"></a>Worker Pool</h3><p>E.g：三个线程干五个活</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">worker</span><span class="token punctuation">(</span>id <span class="token builtin">int</span><span class="token punctuation">,</span> jobs <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> results <span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> job <span class="token operator">:=</span> <span class="token keyword">range</span> jobs <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"worker id: "</span><span class="token punctuation">,</span> id<span class="token punctuation">,</span> <span class="token string">"doing job: "</span><span class="token punctuation">,</span> job<span class="token punctuation">)</span>        results <span class="token operator">&lt;-</span> job <span class="token operator">*</span> <span class="token number">2</span>        time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"worker id: "</span><span class="token punctuation">,</span> id<span class="token punctuation">,</span> <span class="token string">"finished job: "</span><span class="token punctuation">,</span> job<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    jobs <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>    results <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">{</span>        <span class="token keyword">go</span> <span class="token function">worker</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> jobs<span class="token punctuation">,</span> results<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        jobs <span class="token operator">&lt;-</span> i    <span class="token punctuation">}</span>    <span class="token function">close</span><span class="token punctuation">(</span>jobs<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;-</span>results<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>Select 语句具有以下特点。</p><ul><li>可处理一个或多个 channel 的发送/接收操作。</li><li>如果多个 case 同时满足，select 会<strong>随机</strong>选择一个执行。</li><li>对于没有 case 的 select 会一直阻塞，可用于阻塞 main 函数，防止退出</li></ul><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        <span class="token keyword">select</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//如果多个case都满足，随机选一个执行</span>        <span class="token keyword">case</span> x <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch<span class="token punctuation">:</span> <span class="token comment" spellcheck="true">//可以从channel中取值</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Receiving"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span>        <span class="token keyword">case</span> ch <span class="token operator">&lt;-</span> i<span class="token punctuation">:</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Sending "</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//可以从channel中存放值</span>        <span class="token keyword">default</span><span class="token punctuation">:</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"do nothing"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="并发安全和互斥锁"><a href="#并发安全和互斥锁" class="headerlink" title="并发安全和互斥锁"></a>并发安全和互斥锁</h2><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>互斥锁是一种常用的控制共享资源访问的方法，它能够保证同一时间只有一个 goroutine 可以访问共享资源。Go 语言中使用<code>sync</code>包中提供的<code>Mutex</code>类型来实现互斥锁。</p><p><code>sync.Mutex</code>提供了两个方法供我们使用。</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>func (m *Mutex) Lock()</td><td>获取互斥锁</td></tr><tr><td>func (m *Mutex) Unlock()</td><td>释放互斥锁</td></tr></tbody></table><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"sync"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// sync.Mutex</span><span class="token keyword">var</span> <span class="token punctuation">(</span>    x <span class="token builtin">int64</span>    wg sync<span class="token punctuation">.</span>WaitGroup <span class="token comment" spellcheck="true">// 等待组</span>    m sync<span class="token punctuation">.</span>Mutex <span class="token comment" spellcheck="true">// 互斥锁</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// add 对全局变量x执行5000次加1操作</span><span class="token keyword">func</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        m<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 修改x前加锁</span>        x <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span>        m<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 改完解锁</span>    <span class="token punctuation">}</span>    wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="读写互斥锁"><a href="#读写互斥锁" class="headerlink" title="读写互斥锁"></a>读写互斥锁</h3><p>互斥锁是完全互斥的，但是实际上有很多场景是读多写少的，当我们并发的去读取一个资源而不涉及资源修改的时候是没有必要加互斥锁的，这种场景下使用读写锁是更好的一种选择。读写锁在 Go 语言中使用<code>sync</code>包中的<code>RWMutex</code>类型。</p><p><code>sync.RWMutex</code>提供了以下5个方法。</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>func (rw *RWMutex) Lock()</td><td>获取写锁</td></tr><tr><td>func (rw *RWMutex) Unlock()</td><td>释放写锁</td></tr><tr><td>func (rw *RWMutex) RLock()</td><td>获取读锁</td></tr><tr><td>func (rw *RWMutex) RUnlock()</td><td>释放读锁</td></tr><tr><td>func (rw *RWMutex) RLocker() Locker</td><td>返回一个实现Locker接口的读写锁</td></tr></tbody></table><p>读写锁分为两种：读锁和写锁。当一个 goroutine 获取到读锁之后，其他的 goroutine 如果是获取读锁会继续获得锁，如果是获取写锁就会等待；而当一个 goroutine 获取写锁之后，其他的 goroutine 无论是获取读锁还是写锁都会等待。</p><p>在读多写少（相差一个数量级）的情况下，使用读写互斥锁比起使用互斥锁可以提高执行效率</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// 使用互斥锁，10并发写，1000并发读</span><span class="token function">do</span><span class="token punctuation">(</span>writeWithLock<span class="token punctuation">,</span> readWithLock<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// x:10 cost:1.466500951s</span><span class="token comment" spellcheck="true">// 使用读写互斥锁，10并发写，1000并发读</span><span class="token function">do</span><span class="token punctuation">(</span>writeWithRWLock<span class="token punctuation">,</span> readWithRWLock<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// x:10 cost:117.207592ms</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="sync-WaitGroup-1"><a href="#sync-WaitGroup-1" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h3><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>func (wg * WaitGroup) Add(delta int)</td><td>计数器+delta</td></tr><tr><td>(wg *WaitGroup) Done()</td><td>计数器-1</td></tr><tr><td>(wg *WaitGroup) Wait()</td><td>阻塞直到计数器变为0</td></tr></tbody></table><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup<span class="token keyword">func</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello Goroutine!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 启动另外一个goroutine去执行hello函数</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main goroutine done!"</span><span class="token punctuation">)</span>    wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h3><p>在某些场景下我们需要确保某些操作即使在高并发的场景下也只会被执行一次，例如只加载一次配置文件等。</p><p>Go语言中的<code>sync</code>包中提供了一个针对只执行一次场景的解决方案——<code>sync.Once</code>，<code>sync.Once</code>只有一个<code>Do</code>方法</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> singleton<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"sync"</span><span class="token punctuation">)</span><span class="token keyword">type</span> singleton <span class="token keyword">struct</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">var</span> instance <span class="token operator">*</span>singleton<span class="token keyword">var</span> once sync<span class="token punctuation">.</span>Once<span class="token keyword">func</span> <span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>singleton <span class="token punctuation">{</span>    once<span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        instance <span class="token operator">=</span> <span class="token operator">&amp;</span>singleton<span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> instance<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h3><p>Go 语言中内置的 map 不是并发安全的，当并发地写map时会报错<code>fatal error: concurrent map writes</code>，因此我们可以使用<code>sync.Map</code></p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>func (m *Map) Store(key, value interface{})</td><td>存储key-value数据</td></tr><tr><td>func (m *Map) Load(key interface{}) (value interface{}, ok bool)</td><td>查询key对应的value</td></tr><tr><td>func (m *Map) LoadOrStore(key, value interface{}) (actual interface{}, loaded bool)</td><td>查询或存储key对应的value</td></tr><tr><td>func (m *Map) LoadAndDelete(key interface{}) (value interface{}, loaded bool)</td><td>查询并删除key</td></tr><tr><td>func (m *Map) Delete(key interface{})</td><td>删除key</td></tr><tr><td>func (m *Map) Range(f func(key, value interface{}) bool)</td><td>对map中的每个key-value依次调用f</td></tr></tbody></table><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"sync"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    wg <span class="token operator">:=</span> sync<span class="token punctuation">.</span>WaitGroup<span class="token punctuation">{</span><span class="token punctuation">}</span>    m <span class="token operator">:=</span> sync<span class="token punctuation">.</span>Map<span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>            m<span class="token punctuation">.</span><span class="token function">Store</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">)</span>            t<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> m<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token string">":"</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span>            wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;基本上大部分编程语言在并发上的编程范式都差不多，配合Cpp食用更佳。这里推荐一本书，&amp;lt;&amp;lt;深入理解Go并发编程&amp;gt;&amp;gt;。&lt;
      
    
    </summary>
    
    
      <category term="Go" scheme="https://JoyTsing.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="https://JoyTsing.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Cpp20-STL-Cookbook速查</title>
    <link href="https://joytsing.github.io/posts/13644/"/>
    <id>https://joytsing.github.io/posts/13644/</id>
    <published>2024-03-21T15:41:57.000Z</published>
    <updated>2024-03-23T09:03:24.775Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>阅读时请配合cpp reference使用，同时请确保编译器支持C++20。在bilibili上有对应的<a href="https://www.bilibili.com/video/BV1r8411N75b">讲解</a>，这位up主更是为cpp高手，以下大部分内容均是这位up主的笔记，为了方便速查选择我常用的部分搬运了过来。</p><h2 id="第一章-C-20的新特性"><a href="#第一章-C-20的新特性" class="headerlink" title="第一章 C++20的新特性"></a>第一章 C++20的新特性</h2><h3 id="1-2格式化文本"><a href="#1-2格式化文本" class="headerlink" title="1.2格式化文本"></a>1.2格式化文本</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;algorithm></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;string_view></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;format></span></span><span class="token keyword">template</span> <span class="token operator">&lt;</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string_view fmt_str<span class="token punctuation">,</span> Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">auto</span> fmt_args<span class="token punctuation">{</span> std<span class="token operator">::</span><span class="token function">make_format_args</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>   std<span class="token operator">::</span>string outstr<span class="token punctuation">{</span> std<span class="token operator">::</span><span class="token function">vformat</span><span class="token punctuation">(</span>fmt_str<span class="token punctuation">,</span> fmt_args<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token function">fputs</span><span class="token punctuation">(</span>outstr<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">struct</span> Frac <span class="token punctuation">{</span>   <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">struct</span> std<span class="token operator">::</span>formatter<span class="token operator">&lt;</span>Frac<span class="token operator">></span> <span class="token punctuation">{</span>   <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> ParseContext<span class="token operator">></span>   <span class="token keyword">constexpr</span> <span class="token keyword">auto</span> <span class="token function">parse</span><span class="token punctuation">(</span>ParseContext<span class="token operator">&amp;</span> ctx<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> ctx<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> FormatContext<span class="token operator">></span>   <span class="token keyword">auto</span> <span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">const</span> Frac<span class="token operator">&amp;</span> f<span class="token punctuation">,</span> FormatContext<span class="token operator">&amp;</span> ctx<span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">format_to</span><span class="token punctuation">(</span>ctx<span class="token punctuation">.</span><span class="token function">out</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"{0:d}/{1:d}"</span><span class="token punctuation">,</span> f<span class="token punctuation">.</span>a<span class="token punctuation">,</span> f<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   Frac f<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//特化规则参见:    https://zh.cppreference.com/w/cpp/named_req/Formatter</span>out<span class="token operator">:</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>实现模板函数 <strong><code>print</code></strong></li></ol><p>使用与<code>std::format()</code>函数相同的参数。第一个参数是格式字符串的 <code>std::string_view</code> 对象，后面作为参数 的可变参数包。</p><p><a href="https://zh.cppreference.com/w/cpp/utility/format/make_format_args"><code>std::make_format_args()</code></a> 函数的作用: <em>接受参数包并返回一个对象，该对象包含适合格式化的已擦除 类型的值。</em></p><p><code>fmt_str</code>就是传递的格式化字符串，<code>fmt_args</code>是一个保有格式化参数的对象，使用<a href="https://zh.cppreference.com/w/cpp/utility/format/vformat"><code>std::vformat(fmt_str, fmt_args)</code></a>即可返回格式化完毕的字符串。我们使用 <code>fputs()</code> 将值输出到控制台上 (这比 <code>cout</code> 高效得多)。</p><ol><li><a href="https://zh.cppreference.com/w/cpp/utility/format/formatter"><strong><code>std::formatter</code></strong></a> 特化</li></ol><p>对于自定义，或者说标准没有对其有特化的类型，需要我们自行特化<code>std::formatter</code>才可以正确的格式化。</p><p><strong><code>parse()</code></strong> 函数解析格式字符串，从冒号之后 (若没有冒号，则在开大括号之后) 直到但不包括结 束大括号 (就是指定对象类型的部分)。其接受一个 <code>ParseContext</code>对象，<strong>并返回一个迭代器</strong>。这里，可以只返回 <code>begin()</code> 迭代器。因为我们的类型不需要新语法，所以无需准备任何东西。</p><p><strong><code>format()</code></strong> 函数接受一个 <code>Frac</code> 对象和一个 <code>FormatContext</code> 对象，<strong>返回结束迭代器</strong>。<strong><code>format_to()</code></strong> 函数可使这变得很容易，<strong>其可以接受一个迭代器、一个格式字符串和一个参数包</strong>。本例中，参数包是 Frac 类的两个属性，分子和分母。 需要做的就是提供一个简单的格式字符串<code>“{0}/{1}”</code>以及分子和分母的值 (0 和 1 表示参数的 位置)。</p><h3 id="1-3使用编译时constexpr-std-vector和std-string"><a href="#1-3使用编译时constexpr-std-vector和std-string" class="headerlink" title="1.3使用编译时constexpr std::vector和std::string"></a>1.3使用编译时constexpr <code>std::vector</code>和<code>std::string</code></h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span><span class="token keyword">constexpr</span> <span class="token keyword">auto</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>v<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> v<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">constexpr</span> <span class="token keyword">auto</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">{</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//未delete解除分配</span>    <span class="token keyword">return</span> <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">constexpr</span> <span class="token keyword">auto</span> n <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//√</span>    <span class="token comment" spellcheck="true">//constexpr auto n2 = f()//error</span>    <span class="token comment" spellcheck="true">//constexpr auto n3 = f2()//error</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>C++20</code> 允许在新的上下文中使用 <a href="https://zh.cppreference.com/w/cpp/language/constexpr"><strong><code>constexpr</code></strong></a>，这些语句可以在编译时计算，其中包括在 <code>constexpr</code> 上下文中使用 <a href="https://zh.cppreference.com/w/cpp/string/basic_string"><code>string</code></a> 和 <a href="https://zh.cppreference.com/w/cpp/container/vector"><code>vector</code></a> 对象的能力。所以 <strong>，这些对象本身可能不声 明为 constexpr</strong>，<strong>但可以在编译时上下文中使用，同时也可以使用STL中的算法。</strong><code>C++20</code> 开始，标准 <code>string</code> 和 <code>vector</code> 类具有<code>constexpr</code>限定的构造函数和析构函数，这是可在编译时使用的 前提。所以，分配给 <code>string</code> 或 <code>vector</code> 对象的内存，也必须在编译时释放。注意该对象在运行时实际上是不可用的，就算能通过编译也无法使用。</p><h3 id="1-4安全比较不同类型的整数cmp-less"><a href="#1-4安全比较不同类型的整数cmp-less" class="headerlink" title="1.4安全比较不同类型的整数cmp_less"></a>1.4安全比较不同类型的整数<code>cmp_less</code></h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span><span class="token keyword">class</span> <span class="token class-name">U</span><span class="token operator">></span><span class="token keyword">constexpr</span> <span class="token keyword">bool</span> <span class="token function">cmp_less</span><span class="token punctuation">(</span>T t<span class="token punctuation">,</span> U u<span class="token punctuation">)</span><span class="token keyword">noexcept</span> <span class="token punctuation">{</span>    <span class="token keyword">using</span> UT <span class="token operator">=</span> std<span class="token operator">::</span>make_unsigned_t<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//有符号类型到无符号类型的安全转换。</span>    <span class="token keyword">using</span> UU <span class="token operator">=</span> std<span class="token operator">::</span>make_unsigned_t<span class="token operator">&lt;</span>U<span class="token operator">></span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>is_signed_v <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">==</span> std<span class="token operator">::</span>is_signed_v<span class="token operator">&lt;</span>U<span class="token operator">></span><span class="token punctuation">)</span>        <span class="token keyword">return</span> t <span class="token operator">&lt;</span> u<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>is_signed_v<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span>        <span class="token keyword">return</span> t <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token function">UT</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token operator">&lt;</span> u<span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> u <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token boolean">false</span> <span class="token operator">:</span> t <span class="token operator">&lt;</span> <span class="token function">UU</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>boolalpha <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">5u</span> <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>boolalpha <span class="token operator">&lt;&lt;</span> <span class="token operator">::</span><span class="token function">cmp_less</span><span class="token punctuation">(</span><span class="token number">5u</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>boolalpha <span class="token operator">&lt;&lt;</span> <span class="token operator">::</span><span class="token function">cmp_less</span><span class="token punctuation">(</span><span class="token number">5u</span><span class="token punctuation">,</span> <span class="token number">2u</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>C++20</code> 在 <a href="https://zh.cppreference.com/w/cpp/header/utility"><strong><code>utility</code></strong></a> 引入了一组<a href="https://zh.cppreference.com/w/cpp/utility/intcmp"><strong>比较函数</strong></a>，他们分别是：</p><ul><li><code>std::cmp_equal</code></li><li><code>std::cmp_not_equal</code></li><li><code>std::cmp_less</code></li><li><code>std::cmp_greater</code></li><li><code>std::cmp_less_equal</code></li><li><code>std::cmp_greater_equal</code></li></ul><h3 id="1-5三路比较运算符"><a href="#1-5三路比较运算符" class="headerlink" title="1.5三路比较运算符"></a>1.5三路比较运算符</h3><p>三路比较运算符表达式的形式为<code>表达式1 &lt;=&gt; 表达式2</code>该表达式将返回一个对象</p><ul><li>若<code>表达式1 &lt; 表达式2</code>，则<code>(表达式1 &lt;=&gt; 表达式2) &lt; 0</code></li><li>若<code>表达式1 &gt; 表达式2</code>，则<code>(表达式1 &lt;=&gt; 表达式2) &gt; 0</code></li><li>若<code>表达式1 == 表达式2</code>，则<code>(表达式1 &lt;=&gt; 表达式2) == 0</code></li></ul><p>每当<code>&lt;</code> <code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code> <code>&lt;=&gt;</code>被比较且重载决议选择该重载时，<code>operator&lt;=&gt;</code>都会被调用</p><h3 id="1-7概念-concept-和约束-constraint-创建更安全的模板"><a href="#1-7概念-concept-和约束-constraint-创建更安全的模板" class="headerlink" title="1.7概念(concept)和约束(constraint)-创建更安全的模板"></a>1.7概念(<code>concept</code>)和约束(<code>constraint</code>)-创建更安全的模板</h3><p>重点内容，这个功能可以说让模板焕发新生。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">template</span><span class="token operator">&lt;</span>std<span class="token operator">::</span>integral T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>requires std<span class="token operator">::</span>integral<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">||</span> std<span class="token operator">::</span>is_pointer_v<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token keyword">struct</span> X <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>requires std<span class="token operator">::</span>is_integral_v<span class="token operator">&lt;</span>T<span class="token operator">></span>T n<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>concept love <span class="token operator">=</span> std<span class="token operator">::</span>is_integral_v<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>is_same_v<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token operator">||</span> std<span class="token operator">::</span>is_same_v<span class="token operator">&lt;</span>uint32_t<span class="token punctuation">,</span> T<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span>love <span class="token keyword">auto</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 1 是 int，约束满足</span>    <span class="token function">f</span><span class="token punctuation">(</span><span class="token string">'*'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// '*' 是整数类型(Integer Type)之一，约束满足</span>    <span class="token comment" spellcheck="true">//f(1.2);</span>    X<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> x<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// int 满足两个约束的析取之一：std::integral&lt;T>，约束满足</span>    <span class="token comment" spellcheck="true">//X&lt;double>x2;</span>    X<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">*</span><span class="token operator">></span> x3<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// double* 满足两个约束的析取之一：std::is_pointer_t&lt;T>，约束满足</span>    n<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//n&lt;double>;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> n<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    <span class="token function">f2</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 满足合取 std::is_integral_v&lt;T> 和 std::is_same_v&lt;int, T></span>    <span class="token function">f2</span><span class="token punctuation">(</span><span class="token number">1u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 满足合取 std::is_integral_v&lt;T>，std::is_same_v&lt;uint32_t, T></span>    <span class="token comment" spellcheck="true">//f2(1l);</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Requires表达式 https://zh.cppreference.com/w/cpp/language/requires</span><span class="token comment" spellcheck="true">//约束与概念 https://zh.cppreference.com/w/cpp/language/constraints</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>作为 <code>C++20</code> 引入的四大新特性之一：<code>Concept</code> ，提出了一种比 <em>SFINAE</em> 更好的约束方法，它易于理解和编写，也能在出现问题时给出更可读的编译期报错。概念的定义形式如下：</p><blockquote><p><strong>template &lt; <em>模板形参列表</em> &gt; <em>*concept *概念名</em> <em>属性</em>(可选) **=</strong> <em>约束表达式</em> <strong>;</strong></p></blockquote><p>在上述例子中，概念 <code>love</code> 的定义就是这样：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>concept love <span class="token operator">=</span> std<span class="token operator">::</span>is_integral_v<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>is_same_v<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token operator">||</span> std<span class="token operator">::</span>is_same_v<span class="token operator">&lt;</span>uint32_t<span class="token punctuation">,</span> T<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>requires</code> 关键字可用于进行多个约束的分开表达，约束之间的关系均为合取，分为以下多种情况：</p><ul><li>简单约束</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 1. 简单约束</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>concept Addable <span class="token operator">=</span> <span class="token function">requires</span><span class="token punctuation">(</span>T a<span class="token punctuation">,</span> T b<span class="token punctuation">)</span><span class="token punctuation">{</span>    a <span class="token operator">+</span> b<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//编译器会检查该表达式是否 "合法"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>类型约束</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">struct</span> tmp<span class="token punctuation">{</span>    <span class="token keyword">using</span> value <span class="token operator">=</span> T<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token operator">::</span>enable_if_t<span class="token operator">&lt;</span>std<span class="token operator">::</span>is_same_v<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> V<span class="token operator">>></span><span class="token keyword">struct</span> test <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">using</span> Ref <span class="token operator">=</span> T<span class="token operator">&amp;</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>concept Cpt <span class="token operator">=</span> requires<span class="token punctuation">{</span>    <span class="token keyword">typename</span> T<span class="token operator">::</span>value<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 检查 T 是否存在成员 T::value</span>    <span class="token keyword">typename</span> X<span class="token operator">&lt;</span>T<span class="token operator">></span>         <span class="token comment" spellcheck="true">// 检查是否存在模板类 S 的特化 S&lt;T></span>    <span class="token keyword">typename</span> Ref<span class="token operator">&lt;</span>T<span class="token operator">></span>       <span class="token comment" spellcheck="true">// 检查是否存在合法别名模板 Ref&lt;T></span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>复合约束 复合约束用于约束表达式的返回类型。其定义为：</li></ul><blockquote><p>{ <em>表达式</em> } <strong>noexcept</strong>(可选) -&gt; <em>类型约束</em> <strong>;</strong></p></blockquote><p>例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>concept C <span class="token operator">=</span> <span class="token function">requires</span><span class="token punctuation">(</span>T x<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token punctuation">{</span>x <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">}</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">typename</span> T<span class="token operator">::</span>inner<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 表达式 x * 2 的类型可转换为 T::inner</span>  <span class="token punctuation">{</span>x <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">}</span> <span class="token operator">-</span><span class="token operator">></span> std<span class="token operator">::</span>same_as<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 表达式 x + 3 需要满足约束 std::same_as&lt;int></span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-8模块"><a href="#1-8模块" class="headerlink" title="1.8模块"></a>1.8模块</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token number">1.8</span>模块<span class="token punctuation">.</span>cppimport test<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*int n[]{#include"t.txt"    };    for (auto i : n) {        std::cout &lt;&lt; i &lt;&lt; ' ';    }*/</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> mylib<span class="token operator">::</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//mylib::print("*");</span>    <span class="token function">t</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//模块: https://zh.cppreference.com/w/cpp/language/modules</span><span class="token comment" spellcheck="true">//编译设置:add_executable (Test1 "src/1.8模块.cpp" "src/test.ixx" "src/test2.ixx")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/Mq-b/Cpp20-STL-Cookbook-src/blob/master/src/test.ixx"><code>test.ixx</code></a></p><pre class="line-numbers language-cpp"><code class="language-cpp">module<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">define</span> PI 3.14</span><span class="token keyword">export</span> module test<span class="token punctuation">;</span><span class="token keyword">export</span> import<span class="token operator">&lt;</span>iostream<span class="token operator">></span><span class="token punctuation">;</span><span class="token keyword">export</span> import test2<span class="token punctuation">;</span><span class="token keyword">namespace</span> mylib <span class="token punctuation">{</span>    <span class="token keyword">export</span> <span class="token keyword">auto</span> <span class="token function">add</span><span class="token punctuation">(</span>std<span class="token operator">::</span>integral <span class="token keyword">auto</span> a<span class="token punctuation">,</span> std<span class="token operator">::</span>integral <span class="token keyword">auto</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">auto</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">auto</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> t <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/Mq-b/Cpp20-STL-Cookbook-src/blob/master/src/test2.ixx"><code>test2.ixx</code></a></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">export</span> module test2<span class="token punctuation">;</span>import<span class="token operator">&lt;</span>iostream<span class="token operator">></span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">void</span> <span class="token function">t</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"乐\n"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/Mq-b/Cpp20-STL-Cookbook-src/blob/master/src/t.txt"><code>t.txt</code></a></p><pre><code>1,2,3,4,5</code></pre><h3 id="1-9视图"><a href="#1-9视图" class="headerlink" title="1.9视图"></a>1.9视图</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;ranges></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span><span class="token keyword">namespace</span> stdv <span class="token operator">=</span> std<span class="token operator">::</span>views<span class="token punctuation">;</span><span class="token keyword">namespace</span> stdr <span class="token operator">=</span> std<span class="token operator">::</span>ranges<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>stdr<span class="token operator">::</span>range <span class="token keyword">auto</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> i <span class="token operator">:</span> v<span class="token punctuation">)</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span><span class="token punctuation">;</span>    <span class="token function">endl</span><span class="token punctuation">(</span>std<span class="token operator">::</span>cout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>vector nums<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> ret <span class="token operator">=</span> nums <span class="token operator">|</span> stdv<span class="token operator">::</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">|</span> stdv<span class="token operator">::</span>reverse<span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> ret2 <span class="token operator">=</span> nums <span class="token operator">|</span> stdv<span class="token operator">::</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> i <span class="token operator">></span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>ret2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> ret3 <span class="token operator">=</span> nums <span class="token operator">|</span> stdv<span class="token operator">::</span><span class="token function">transform</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> i <span class="token operator">*</span> i<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>ret3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//视图是不会改变原来的数据的</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span>strs<span class="token punctuation">{</span> <span class="token string">"🐴"</span><span class="token punctuation">,</span><span class="token string">"🐭"</span><span class="token punctuation">,</span><span class="token string">"🥵"</span><span class="token punctuation">,</span><span class="token string">"🤣"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> ret4 <span class="token operator">=</span> strs <span class="token operator">|</span> stdv<span class="token operator">::</span>reverse<span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>ret4<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> ret5 <span class="token operator">=</span> nums <span class="token operator">|</span> stdv<span class="token operator">::</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> i <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">|</span> stdv<span class="token operator">::</span><span class="token function">transform</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>ret5<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> nums_ <span class="token operator">=</span> stdv<span class="token operator">::</span><span class="token function">iota</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>nums_<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> rnums <span class="token operator">=</span> stdv<span class="token operator">::</span><span class="token function">iota</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> stdv<span class="token operator">::</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>rnums<span class="token punctuation">)</span><span class="token punctuation">;</span>    stdr<span class="token operator">::</span><span class="token function">copy</span><span class="token punctuation">(</span>strs <span class="token operator">|</span> stdv<span class="token operator">::</span>reverse <span class="token operator">|</span> stdv<span class="token operator">::</span><span class="token function">drop</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>ostream_iterator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token punctuation">(</span>std<span class="token operator">::</span>cout<span class="token punctuation">,</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//范围库: https://zh.cppreference.com/w/cpp/ranges</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第二章-STL的泛型特性"><a href="#第二章-STL的泛型特性" class="headerlink" title="第二章 STL的泛型特性"></a>第二章 STL的泛型特性</h2><h3 id="2-2span类"><a href="#2-2span类" class="headerlink" title="2.2span类"></a>2.2span类</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;format></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;span></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;array></span></span><span class="token keyword">template</span> <span class="token operator">&lt;</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string_view fmt_str<span class="token punctuation">,</span> Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> fmt_args<span class="token punctuation">{</span> std<span class="token operator">::</span><span class="token function">make_format_args</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>string outstr<span class="token punctuation">{</span> std<span class="token operator">::</span><span class="token function">vformat</span><span class="token punctuation">(</span>fmt_str<span class="token punctuation">,</span> fmt_args<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">fputs</span><span class="token punctuation">(</span>outstr<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">pspan</span><span class="token punctuation">(</span>std<span class="token operator">::</span>span<span class="token operator">&lt;</span>T<span class="token operator">></span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"number of elemnts: {}\n"</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//  返回序列中的元素个数</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"size of span: {}\n"</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">size_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 返回以字节表示的序列大小</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> s<span class="token punctuation">)</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{} "</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">endl</span><span class="token punctuation">(</span>std<span class="token operator">::</span>cout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    pspan<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">endl</span><span class="token punctuation">(</span>std<span class="token operator">::</span>cout<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> b<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    pspan<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">endl</span><span class="token punctuation">(</span>std<span class="token operator">::</span>cout<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token operator">></span> c<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    pspan<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>out<span class="token operator">:</span>    number of elemnts<span class="token operator">:</span> <span class="token number">6</span>    size of span<span class="token operator">:</span> <span class="token number">24</span>    <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://zh.cppreference.com/w/cpp/container/span"><strong><code>std::span</code></strong></a> 在C++20中被引入</p><p>它给具有连续对象的序列提供了轻量级的视图，以更加安全的方式对其进行迭代和索引，比如<code>std::array</code>、 <code>std::vector</code>、原生数组和原生指针。</p><p>常用于去包裹原生数组，并提供了更加安全的一系列函数：如<code>front()</code>，<code>begin()</code>, <code>size()</code>, <code>empty()</code>等</p><p>经典的实现中只有两个成员：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">private</span><span class="token operator">:</span>    pointer _ptr<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指向元素的指针</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-3结构化绑定"><a href="#2-3结构化绑定" class="headerlink" title="2.3结构化绑定"></a>2.3结构化绑定</h3><p>注意，由于结构化绑定使用自动类型推导，所以类型声明必须使用 <code>auto</code>,且使用的变量名在该作用域内唯一，同时保证标识符列表内的标识符（即[a, b, c] 中的变量a,b,c）个数<strong>等于</strong>所指代对象的子元素个数。</p><p><a href="https://zh.cppreference.com/w/cpp/language/lambda">Lambda表达式(C++11 起) </a>在C++17起才允许捕获结构化绑定的变量</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> S <span class="token punctuation">{</span> <span class="token keyword">int</span> p<span class="token punctuation">{</span><span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">,</span> q<span class="token punctuation">{</span><span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> <span class="token punctuation">[</span>b<span class="token punctuation">,</span> d<span class="token punctuation">]</span> <span class="token operator">=</span> S<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">auto</span> l <span class="token operator">=</span> <span class="token punctuation">[</span>b<span class="token punctuation">,</span> d<span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> b <span class="token operator">*</span> d<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// C++17 起合法</span><span class="token function">assert</span><span class="token punctuation">(</span><span class="token function">l</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4if-amp-switch中的初始化"><a href="#2-4if-amp-switch中的初始化" class="headerlink" title="2.4if&amp;switch中的初始化"></a>2.4if&amp;switch中的初始化</h3><pre class="line-numbers language-c++"><code class="language-c++">void ifFunc(int n) {    if (auto flag = [n]() {return n; }(); flag % 2 == 0) {// C++17起，允许if语句内声明表达式，它可以是这里的lambda表达式        print("This is a even Number: {}\n", n);    }}void switchFunc() {    switch (char c = getchar(); c)// C++17起，允许switch语句内声明表达式，它可以是一条语句    {    case 'a':        print("a\n");        break;    default:        print("input not a b c\n");        break;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过<code>if &amp; switcht 初始化语句</code>限制了变量的作用域，避免了与其他变量名发生冲突，并且会自动调用对应的析构函数，确保内存被安全释放。</p><h3 id="2-5模板参数推导（CTAD）"><a href="#2-5模板参数推导（CTAD）" class="headerlink" title="2.5模板参数推导（CTAD）"></a>2.5模板参数推导（CTAD）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">"print.h"</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token operator">::</span>string_literals<span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">struct</span> X <span class="token punctuation">{</span>    T v<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token operator">></span>    <span class="token function">X</span><span class="token punctuation">(</span>Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span> <span class="token operator">:</span> v<span class="token punctuation">{</span> <span class="token punctuation">(</span>args <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Ts<span class="token operator">></span><span class="token function">X</span><span class="token punctuation">(</span>Ts<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>ts<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> X<span class="token operator">&lt;</span>std<span class="token operator">::</span>common_type_t<span class="token operator">&lt;</span>Ts<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">>></span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//确定所有类型Ts...都能隐式转换到的类型</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    X <span class="token function">x</span><span class="token punctuation">(</span><span class="token string">"Hello "</span><span class="token punctuation">,</span> <span class="token string">"World🤣"</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">.</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre><code>Hello World🤣</code></pre><p>在C++17,当我们给定类模板实参时，编译器会对其进行自动类型推导，如上面代码代码中的实例化对象<code>x</code>, 而之前为了实现`x对象的实例化，我们可能需要这样写：</p><pre><code>X&lt;const char*, std::string&gt; x(&quot;Hello&quot;, &quot;World&quot;s);</code></pre><p>虽然有了<code>类模板实参推导</code>,但该类模板只接收一种类型，所以需要使用<a href="https://zh.cppreference.com/w/cpp/types/common_type"><code>std::common_type_t</code></a>来对类模板实参进行一个都可隐式转换的类型的提取</p><p>因此，当我们初始化STL容器时，可以省略类型的书写：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>pair p<span class="token punctuation">{</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3.14</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 省略容器元素的类型</span>std<span class="token operator">:</span>vector vec<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span><span class="token function">sort</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>greater<span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//省略比较器的类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-6编译期if"><a href="#2-6编译期if" class="headerlink" title="2.6编译期if"></a>2.6编译期<code>if</code></h3><pre><code>#include&quot;print.h&quot;template&lt;class T&gt;auto f(const T&amp; v) {    if constexpr (std::is_pointer_v&lt;T&gt;)        print(&quot;is pointer\n&quot;);    else        print(&quot;not pointer\n&quot;);}template&lt;class T,class...Args&gt;void show(T t, Args&amp;&amp;...args) {    print(&quot;{}\t&quot;,t);    if constexpr (sizeof...(args)) {        show(args...);    }}int main() {    int* p{};    f(p);    f(1);    show(5,314, &quot;🤣&quot;, &#39;*&#39;);    print(&quot;\n&quot;);}</code></pre><p>运行结果：</p><pre><code>is pointernot pointer5       314     🤣   *</code></pre><blockquote><p><a href="https://zh.cppreference.com/w/cpp/types/is_pointer"><code>std::is_pointer</code></a>用于编译器判断参数类型T是否为对象/函数指针</p></blockquote><p>以 <a href="https://zh.cppreference.com/w/cpp/language/if"><code>if constexpr</code></a> 开始的语句被称为 <em>constexpr if 语句</em>, 在 <em>constexpr if</em> 语句中, 若表达式的值可转换到bool类型的常量表达式，如果值为<code>true</code>，舍弃<code>false</code>分支（如果存在），反之亦然</p><p>被舍弃的分支中的<code>return 语句</code><strong>不参与</strong>函数的返回值类型推导，且可以使用<strong>未定义</strong>的变量（大概是因为他不会被执行到，所以无关紧要）</p><pre><code>sizeof...`在编译期求出参数包的大小，值为0时，被决为`false</code></pre><h2 id="第三章-STL容器"><a href="#第三章-STL容器" class="headerlink" title="第三章 STL容器"></a>第三章 STL容器</h2><h3 id="3-3使用擦除函数从容器中擦除项"><a href="#3-3使用擦除函数从容器中擦除项" class="headerlink" title="3.3使用擦除函数从容器中擦除项"></a>3.3使用擦除函数从容器中擦除项</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">"print.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;list></span></span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Tc<span class="token punctuation">,</span><span class="token keyword">typename</span> Tv<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">remove_value</span><span class="token punctuation">(</span>Tc<span class="token operator">&amp;</span> c<span class="token punctuation">,</span> <span class="token keyword">const</span> Tv<span class="token operator">&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//C++20之前的做法</span>    <span class="token keyword">auto</span> remove_it <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">remove</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//remove_it是首个需要被删除元素的位置</span>    c<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>remove_it<span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//删除remove_it到end()这个范围的元素</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>vector v<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">::</span><span class="token function">remove_value</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">erase</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">erase_if</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> i <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>list list<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">erase</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">erase_if</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> i <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> std<span class="token operator">::</span>string<span class="token operator">></span> map<span class="token punctuation">{</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"🤣"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"🥵"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"🐴"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token string">"🐭"</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">erase_if</span><span class="token punctuation">(</span>map<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> <span class="token punctuation">[</span>k<span class="token punctuation">,</span> v<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">return</span> v <span class="token operator">==</span> <span class="token string">"🥵"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行结果</strong></p><pre><code>    size: 5  [ 1 2 3 4 5 ]    size: 4  [ 2 3 4 5 ]    size: 3  [ 2 3 4 ]    size: 2  [ 2 4 ]    size: 4  [ 1 3 7 9 ]    size: 4 [ 1:🤣 2:🥵 3:🐴 4:🐭 ]    size: 3 [ 1:🤣 3:🐴 4:🐭 ]</code></pre><p><strong>解析</strong></p><p><a href="https://zh.cppreference.com/w/cpp/io/c/remove"><strong><code>std::remove</code></strong></a></p><ul><li>功能: 该函数用于将迭代器中与值匹配的元素移动到末尾,并返回操作完毕后首个与参数值匹配的元素位置</li><li>参数 <code>_First</code> 需要进行操作的容器的起始位置</li><li>参数 <code>_Last</code> 需要进行操作的容器的截止位置</li><li>参数 <code>_Val</code> 需要操作的值</li><li>Ps: <code>std::remove</code> 提供了可自定义操作规则的 <a href="https://zh.cppreference.com/w/cpp/algorithm/remove"><strong><code>std::remove_if</code></strong></a></li></ul><p><a href="https://zh.cppreference.com/w/cpp/container/vector/erase2"><strong><code>std::erase</code></strong></a></p><ul><li>功能: 删除给定容器中与 <code>_Value</code> 匹配的元素</li><li>参数 <code>_Cont</code> 需要被擦除元素的容器</li><li>参数 <code>_Value</code> 需要被擦除的值</li><li>Ps: 该函数从 <code>C++20</code> 起,功能同 remove_value()</li></ul><p><a href="https://zh.cppreference.com/w/cpp/container/vector/erase2"><strong><code>std::erase_if</code></strong></a></p><ul><li>功能: <code>std::erase</code> 的自定义删除规则版本</li><li>参数 <code>_Cont</code> 需要被擦除元素的容器</li><li>参数 <code>_Pred</code> 当该参数为 <code>true</code> 时,擦除对应元素。该参数必须是一个可转换为 <code>bool</code> 类型的表达式(此处使用一个<code>lambda 表达式</code> 来判断是否擦除)</li><li>Ps: 该函数是 <code>std::erase</code> 的改进版本,相较于旧版本只能单一匹配值来进行删除,<code>std::erase_if</code>可以实现类似示例中的自定义删除规则</li></ul><p><strong>注意</strong>: <code>std::erase</code> 与 <code>std::erase_if</code> 会使序列容器迭代器失效</p><h3 id="3-4常数时间内从未排序的向量中删除项"><a href="#3-4常数时间内从未排序的向量中删除项" class="headerlink" title="3.4常数时间内从未排序的向量中删除项"></a>3.4常数时间内从未排序的向量中删除项</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">"print.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;ranges></span></span><span class="token keyword">namespace</span> stdr <span class="token operator">=</span> std<span class="token operator">::</span>ranges<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//使用下标的版本</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">quick_delete</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> v<span class="token punctuation">,</span> size_t idx<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        v<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        v<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//使用迭代器的版本</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">quick_delete</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> v<span class="token punctuation">,</span> <span class="token keyword">typename</span> T<span class="token operator">::</span>iterator it<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>it <span class="token operator">&lt;</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">*</span>it <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        v<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//若 vector 中项目的顺序不重要，就可以优化这个过程，使其花费 O(1)(常数) 时间</span><span class="token comment" spellcheck="true">//做法很简单，将传入的要删除的迭代器或索引赋值为末尾元素的值，然后将末尾元素删除，就完成了，但是没有顺序</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>vector v<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> it <span class="token operator">=</span> stdr<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">quick_delete</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> it<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//顺序不对，正常现象</span>    <span class="token function">quick_delete</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-5安全的访问std-vector元素"><a href="#3-5安全的访问std-vector元素" class="headerlink" title="3.5安全的访问std::vector元素"></a>3.5安全的访问<code>std::vector</code>元素</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">"print.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span><span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>vector v<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    v<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2001</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//写入非法内存，访问也是越界</span>    <span class="token keyword">auto</span><span class="token operator">&amp;</span> i <span class="token operator">=</span> v<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//引用了错误的内存</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//可能发生错误，不保证</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>vector v<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span><span class="token operator">&amp;</span> i <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// at会进行越界检查，保证了程序的安全</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>exception<span class="token operator">&amp;</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}\n"</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>vector v<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span><span class="token operator">&amp;</span> i <span class="token operator">=</span> v<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>exception<span class="token operator">&amp;</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}\n"</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//test1();//error</span>    <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//test3();//error</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-7高效的将元素插入到std-map中"><a href="#3-7高效的将元素插入到std-map中" class="headerlink" title="3.7高效的将元素插入到std::map中"></a>3.7高效的将元素插入到<code>std::map</code>中</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">"print.h"</span></span><span class="token keyword">struct</span> X <span class="token punctuation">{</span>    std<span class="token operator">::</span>string s<span class="token punctuation">;</span>    <span class="token function">X</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"default construct\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token function">X</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token operator">:</span>s<span class="token punctuation">{</span> s <span class="token punctuation">}</span> <span class="token punctuation">{</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"construct\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token function">X</span><span class="token punctuation">(</span><span class="token keyword">const</span> X<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"copy construct\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">printm</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> X<span class="token operator">></span><span class="token operator">&amp;</span> map<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> <span class="token punctuation">[</span>k<span class="token punctuation">,</span> v<span class="token punctuation">]</span> <span class="token operator">:</span> map<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"[ {}:{} ]"</span><span class="token punctuation">,</span> k<span class="token punctuation">,</span> v<span class="token punctuation">.</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> X<span class="token operator">></span>map<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    map<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"🐴"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//两个构造的开销，有参和默认</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//直接转发，只有一个有参构造的开销,这里使用try_emplace和emplace效果完全一样</span>    map<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"🥵"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"🤣"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printm</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"乐"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//添加一个具有重复键的元素</span>    map<span class="token punctuation">.</span><span class="token function">try_emplace</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"乐"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printm</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//重复键元素的问题参见 https://gcc.gnu.org/bugzilla/show_bug.cgi?id=92300</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-8高效的修改std-map项的键值"><a href="#3-8高效的修改std-map项的键值" class="headerlink" title="3.8高效的修改std::map项的键值"></a>3.8高效的修改<code>std::map</code>项的键值</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">"print.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;string></span></span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> M<span class="token punctuation">,</span><span class="token keyword">typename</span> K<span class="token operator">></span><span class="token keyword">bool</span> <span class="token function">node_swap</span><span class="token punctuation">(</span>M<span class="token operator">&amp;</span> m<span class="token punctuation">,</span> K k1<span class="token punctuation">,</span> K k2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//extract 是更换 map 的键而不重分配的唯一方式</span>    <span class="token keyword">auto</span> node1<span class="token punctuation">{</span> m<span class="token punctuation">.</span><span class="token function">extract</span><span class="token punctuation">(</span>k1<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> node2<span class="token punctuation">{</span> m<span class="token punctuation">.</span><span class="token function">extract</span><span class="token punctuation">(</span>k2<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node1<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> node2<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">swap</span><span class="token punctuation">(</span>node1<span class="token punctuation">.</span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> node2<span class="token punctuation">.</span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    m<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>node1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    m<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>node2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>map<span class="token operator">&lt;</span>uint32_t<span class="token punctuation">,</span> std<span class="token operator">::</span>string<span class="token operator">></span>maps<span class="token punctuation">{</span>        <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"🐴"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"🥵"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"🤣"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token string">"🐭"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token string">"😘"</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>maps<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">::</span><span class="token function">node_swap</span><span class="token punctuation">(</span>maps<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>maps<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> node <span class="token operator">=</span> maps<span class="token punctuation">.</span><span class="token function">extract</span><span class="token punctuation">(</span>maps<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    node<span class="token punctuation">.</span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> t <span class="token operator">=</span>maps<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>maps<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>t<span class="token punctuation">.</span>inserted<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"插入失败 {}\n"</span><span class="token punctuation">,</span>t<span class="token punctuation">.</span>position<span class="token operator">-</span><span class="token operator">></span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-10使用set进行输入和筛选"><a href="#3-10使用set进行输入和筛选" class="headerlink" title="3.10使用set进行输入和筛选"></a>3.10使用<code>set</code>进行输入和筛选</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">"print.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;set></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;string></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;ranges></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>set<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> sets<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//set 容器用于存储键适用于索引关键字</span>    std<span class="token operator">::</span><span class="token function">copy</span><span class="token punctuation">(</span>std<span class="token operator">::</span>istream_iterator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token punctuation">{</span>std<span class="token operator">::</span>cin<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        std<span class="token operator">::</span><span class="token function">inserter</span><span class="token punctuation">(</span>sets<span class="token punctuation">,</span> sets<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>sets<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://zh.cppreference.com/w/cpp/algorithm/copy"><strong><code>std::copy</code></strong></a> 用于将数据拷贝到对应容器中</p><ul><li>参数1 <code>_First</code> 需要拷贝的起始迭代器(这里使用<code>istream</code>的迭代器来读取输入流字符串)</li><li>参数2 <code>_Last</code> 拷贝的截止迭代器 (这里使用 <code>{}</code> 占位 即拷贝所有输入流中的字符)</li><li>参数2 <code>_Dest</code> 如何拷贝(这里使用<code>std::inserter</code>进行插入)</li></ul><p><a href="https://zh.cppreference.com/w/cpp/algorithm/copy"><strong><code>std::inserter</code></strong></a> 将每一组输入的字符串作为 <code>key</code> 插入到容器中</p><ul><li>参数1 <code>_Cont</code> 需要插入数据的容器(这里是sets)</li><li>参数2 <code>_Where</code> 需要插入的位置(这里始终插入到<code>sets</code>的尾部)</li></ul><p><strong>运行结果</strong></p><pre><code>    输入:  1 12 3 3 3 3 3 ^Z    输出:  size: 3 [ 1 12 3 ]</code></pre><p><code>set</code> 容器的 <code>key</code> 是不可重复的,如果需要运行重复 <code>key</code> 的 <code>set</code> 可以使用 `std::multiset</p><p><code>set</code> 容器内部通过一颗 <code>R&amp;B树(红黑树)</code>来存储数据,其对字符串的排序方式是按照 <a href="https://baike.baidu.com/item/字典序#:~:text=在数学中，字典或,顺序排列的方法。"><strong>字典序</strong></a>故输出时 <code>12</code> 出现在 <code>3</code> 之前</p><h2 id="第四章-兼容迭代器"><a href="#第四章-兼容迭代器" class="headerlink" title="第四章 兼容迭代器"></a><a href="https://github.com/Mq-b/Cpp20-STL-Cookbook-src?tab=readme-ov-file#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%85%BC%E5%AE%B9%E8%BF%AD%E4%BB%A3%E5%99%A8">第四章 兼容迭代器</a></h2><p>略过，详细可以点击标题了解。</p><h2 id="第五章-lambda表达式"><a href="#第五章-lambda表达式" class="headerlink" title="第五章 lambda表达式"></a>第五章 lambda表达式</h2><h3 id="5-3用于作用域可重用代码"><a href="#5-3用于作用域可重用代码" class="headerlink" title="5.3用于作用域可重用代码"></a>5.3用于作用域可重用代码</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">"print.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> one <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token string">"one"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> two <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token string">"two"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{} {}\n"</span><span class="token punctuation">,</span> <span class="token function">one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">two</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> p <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//泛型lambda，C++20之前只能使用这种方式</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}\n"</span><span class="token punctuation">,</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">p</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token string">"乐"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> p2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}\n"</span><span class="token punctuation">,</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">p2</span><span class="token punctuation">(</span>one<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">p2</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>one<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}\n"</span><span class="token punctuation">,</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">(</span>two<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> num<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> p3 <span class="token operator">=</span> <span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">mutable</span> <span class="token punctuation">{</span>num<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token function">p3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}\n"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> p4 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">mutable</span> <span class="token punctuation">{</span>num<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>p4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">constexpr</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token number">10</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> p5 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token keyword">int</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-4算法库中作为谓词"><a href="#5-4算法库中作为谓词" class="headerlink" title="5.4算法库中作为谓词"></a>5.4算法库中作为谓词</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">"print.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span><span class="token keyword">bool</span> <span class="token function">is_div4</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> i <span class="token operator">%</span> <span class="token number">4</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">struct</span> is_div4_ <span class="token punctuation">{</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> i <span class="token operator">%</span> <span class="token number">4</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">auto</span> <span class="token function">is_div_by</span><span class="token punctuation">(</span><span class="token keyword">int</span> divisor<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> i <span class="token operator">%</span> divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>vector v<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">44</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> count1 <span class="token operator">=</span>std<span class="token operator">::</span><span class="token function">count_if</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> is_div4<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> count2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">count_if</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> is_div4_<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{} {}\n"</span><span class="token punctuation">,</span> count1<span class="token punctuation">,</span> count2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> count3 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">count_if</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> i <span class="token operator">%</span> <span class="token number">4</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}\n"</span><span class="token punctuation">,</span> count3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">auto</span> count <span class="token operator">=</span> std<span class="token operator">::</span>ranges<span class="token operator">::</span><span class="token function">count_if</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> <span class="token function">is_div_by</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{} "</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//不带捕获的lambda表达式可以有转换函数，隐式转换到对应的函数指针</span>    <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> a<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}\n"</span><span class="token punctuation">,</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-5与std-function一起作为多态包装器"><a href="#5-5与std-function一起作为多态包装器" class="headerlink" title="5.5与std::function一起作为多态包装器"></a>5.5与<code>std::function</code>一起作为多态包装器</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">"print.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;functional></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;list></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;deque></span></span><span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"hello\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">struct</span> Hello_ <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">greeting</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"hello\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>d<span class="token punctuation">;</span>    std<span class="token operator">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>l<span class="token punctuation">;</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>v<span class="token punctuation">;</span>    <span class="token keyword">auto</span> print_c <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> i <span class="token operator">:</span> c<span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{} "</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> push_c <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> container<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>container<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>            container<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">>></span>consumers<span class="token punctuation">{</span> <span class="token function">push_c</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">push_c</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">push_c</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//consumers[0](10);</span>    <span class="token comment" spellcheck="true">//print_c(d);</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> i <span class="token operator">:</span> consumers<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">i</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">print_c</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print_c</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print_c</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>function f<span class="token punctuation">{</span> hello <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Hello_ h<span class="token punctuation">;</span>    std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token operator">></span>ff<span class="token punctuation">{</span> std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Hello_<span class="token operator">::</span>greeting<span class="token punctuation">,</span><span class="token operator">&amp;</span>h<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">ff</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Hello_<span class="token operator">::</span>greeting<span class="token punctuation">,</span> <span class="token operator">&amp;</span>h<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-7将谓词与逻辑连接词连接起来"><a href="#5-7将谓词与逻辑连接词连接起来" class="headerlink" title="5.7将谓词与逻辑连接词连接起来"></a>5.7将谓词与逻辑连接词连接起来</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">"print.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span><span class="token keyword">static</span> <span class="token keyword">bool</span> <span class="token function">begins_with_a</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">bool</span> <span class="token function">ends_with_b</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">rfind</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> A<span class="token punctuation">,</span> <span class="token keyword">typename</span> B<span class="token punctuation">,</span> <span class="token keyword">typename</span> F<span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">combine</span><span class="token punctuation">(</span>F binary_func<span class="token punctuation">,</span> A a<span class="token punctuation">,</span> B b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">binary_func</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">b</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> a_xxx_b<span class="token punctuation">{</span> <span class="token function">combine</span><span class="token punctuation">(</span>std<span class="token operator">::</span>logical_and<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>begins_with_a<span class="token punctuation">,</span> ends_with_b<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">copy_if</span><span class="token punctuation">(</span>std<span class="token operator">::</span>istream_iterator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token punctuation">{</span>std<span class="token operator">::</span>cin<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        std<span class="token operator">::</span>ostream_iterator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token punctuation">{</span>std<span class="token operator">::</span>cout<span class="token punctuation">,</span> <span class="token string">", "</span><span class="token punctuation">}</span><span class="token punctuation">,</span> a_xxx_b<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-8用相同的输入调用多个lambda"><a href="#5-8用相同的输入调用多个lambda" class="headerlink" title="5.8用相同的输入调用多个lambda"></a>5.8用相同的输入调用多个lambda</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">"print.h"</span></span><span class="token keyword">auto</span> <span class="token function">braces</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}{}{} "</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> v<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> a <span class="token operator">=</span> <span class="token function">braces</span><span class="token punctuation">(</span><span class="token string">'('</span><span class="token punctuation">,</span> <span class="token string">')'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> b <span class="token operator">=</span> <span class="token function">braces</span><span class="token punctuation">(</span><span class="token string">'['</span><span class="token punctuation">,</span> <span class="token string">']'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> c <span class="token operator">=</span> <span class="token function">braces</span><span class="token punctuation">(</span><span class="token string">'{'</span><span class="token punctuation">,</span> <span class="token string">'}'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> d <span class="token operator">=</span> <span class="token function">braces</span><span class="token punctuation">(</span><span class="token string">'|'</span><span class="token punctuation">,</span> <span class="token string">'|'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> <span class="token punctuation">{</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">x</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-9对跳转表使用映射lambda"><a href="#5-9对跳转表使用映射lambda" class="headerlink" title="5.9对跳转表使用映射lambda"></a>5.9对跳转表使用映射lambda</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">"print.h"</span></span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token function">prompt</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>string r<span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{} > "</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">getline</span><span class="token punctuation">(</span>std<span class="token operator">::</span>cin<span class="token punctuation">,</span> r<span class="token punctuation">,</span> <span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">'\0'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果走这个分支，就是直接下一个循环</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"响应时间过长\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">toupper</span><span class="token punctuation">(</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">using</span> jumpfunc <span class="token operator">=</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>map<span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token punctuation">,</span> jumpfunc<span class="token operator">></span> jumpmap<span class="token punctuation">{</span>        <span class="token punctuation">{</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"func A\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"func B\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"func C\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span> <span class="token string">'D'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"func D\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span> <span class="token string">'X'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Bye!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> select<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>select <span class="token operator">!=</span> <span class="token string">'X'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>select <span class="token operator">=</span> <span class="token function">prompt</span><span class="token punctuation">(</span><span class="token string">"select A/B/C/D/X"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">auto</span> it <span class="token operator">=</span> jumpmap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>select<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> jumpmap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> it<span class="token operator">-</span><span class="token operator">></span><span class="token function">second</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"没有对应的选项！\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第六章-STL算法"><a href="#第六章-STL算法" class="headerlink" title="第六章 STL算法"></a>第六章 STL算法</h2><h3 id="6-2基于迭代器的复制"><a href="#6-2基于迭代器的复制" class="headerlink" title="6.2基于迭代器的复制"></a>6.2基于迭代器的复制</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">"print.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span><span class="token keyword">namespace</span> stdr <span class="token operator">=</span> std<span class="token operator">::</span>ranges<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span>v1<span class="token punctuation">{</span> <span class="token string">"alpha"</span><span class="token punctuation">,</span><span class="token string">"beta"</span><span class="token punctuation">,</span><span class="token string">"gamma"</span><span class="token punctuation">,</span><span class="token string">"delta"</span><span class="token punctuation">,</span><span class="token string">"epsilon"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">printc</span><span class="token punctuation">(</span>v1<span class="token punctuation">,</span><span class="token string">"v1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token function">v2</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">copy</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printc</span><span class="token punctuation">(</span>v2<span class="token punctuation">,</span> <span class="token string">"v2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">copy</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">back_inserter</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printc</span><span class="token punctuation">(</span>v2<span class="token punctuation">,</span> <span class="token string">"v2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span>v3<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">copy_n</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">back_inserter</span><span class="token punctuation">(</span>v3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printc</span><span class="token punctuation">(</span>v3<span class="token punctuation">,</span> <span class="token string">"v3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span>v4<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*std::copy_if(v1.begin(), v1.end(), std::back_inserter(v4), [](auto&amp; s) {        return s.size() > 4;    });*/</span>    stdr<span class="token operator">::</span><span class="token function">copy_if</span><span class="token punctuation">(</span>v1<span class="token punctuation">,</span>std<span class="token operator">::</span><span class="token function">back_inserter</span><span class="token punctuation">(</span>v4<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">4</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printc</span><span class="token punctuation">(</span>v4<span class="token punctuation">,</span> <span class="token string">"v4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    stdr<span class="token operator">::</span><span class="token function">copy</span><span class="token punctuation">(</span>v1<span class="token punctuation">,</span> std<span class="token operator">::</span>ostream_iterator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token punctuation">{</span>std<span class="token operator">::</span>cout<span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    stdr<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>v1<span class="token punctuation">,</span> v2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printc</span><span class="token punctuation">(</span>v1<span class="token punctuation">,</span> <span class="token string">"after move: v1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printc</span><span class="token punctuation">(</span>v2<span class="token punctuation">,</span> <span class="token string">"after move: v2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-3将容器元素连接到以供字符串当中"><a href="#6-3将容器元素连接到以供字符串当中" class="headerlink" title="6.3将容器元素连接到以供字符串当中"></a>6.3将容器元素连接到以供字符串当中</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">"print.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;sstream></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;list></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;numbers></span></span><span class="token keyword">namespace</span> bw <span class="token punctuation">{</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>    std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span> <span class="token function">join</span><span class="token punctuation">(</span>T it<span class="token punctuation">,</span> T end_it<span class="token punctuation">,</span> std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span> o<span class="token punctuation">,</span> std<span class="token operator">::</span>string_view sep <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> end_it<span class="token punctuation">)</span>o <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> end_it<span class="token punctuation">)</span>o <span class="token operator">&lt;&lt;</span> sep <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> o<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> I<span class="token operator">></span>    std<span class="token operator">::</span>string <span class="token function">join</span><span class="token punctuation">(</span>I it<span class="token punctuation">,</span> I end_it<span class="token punctuation">,</span> std<span class="token operator">::</span>string_view sep <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>ostringstream ostr<span class="token punctuation">;</span>        <span class="token function">join</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> end_it<span class="token punctuation">,</span> ostr<span class="token punctuation">,</span> sep<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ostr<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    std<span class="token operator">::</span>string <span class="token function">join</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> c<span class="token punctuation">,</span> std<span class="token operator">::</span>string_view sep <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">join</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">end</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> sep<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span>greek<span class="token punctuation">{</span> <span class="token string">"alpha"</span><span class="token punctuation">,</span><span class="token string">"beta"</span><span class="token punctuation">,</span><span class="token string">"gamma"</span><span class="token punctuation">,</span>        <span class="token string">"delta"</span><span class="token punctuation">,</span><span class="token string">"epsilon"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> c <span class="token operator">:</span> greek<span class="token punctuation">)</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> <span class="token string">","</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> greek_view <span class="token operator">=</span> greek <span class="token operator">|</span> std<span class="token operator">::</span>views<span class="token operator">::</span>join<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> c <span class="token operator">:</span> greek_view<span class="token punctuation">)</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    bw<span class="token operator">::</span><span class="token function">join</span><span class="token punctuation">(</span>greek<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> greek<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>cout<span class="token punctuation">,</span> <span class="token string">", "</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> s <span class="token operator">=</span> bw<span class="token operator">::</span><span class="token function">join</span><span class="token punctuation">(</span>greek<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> greek<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">", "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}\n"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> s2 <span class="token operator">=</span> bw<span class="token operator">::</span><span class="token function">join</span><span class="token punctuation">(</span>greek<span class="token punctuation">,</span> <span class="token string">", "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}\n"</span><span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>list<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span>list<span class="token punctuation">{</span> std<span class="token operator">::</span>numbers<span class="token operator">::</span>pi<span class="token punctuation">,</span>std<span class="token operator">::</span>numbers<span class="token operator">::</span>e<span class="token punctuation">,</span>std<span class="token operator">::</span>numbers<span class="token operator">::</span>sqrt2 <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}\n"</span><span class="token punctuation">,</span> bw<span class="token operator">::</span><span class="token function">join</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token string">": "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-4std-sort排序容器元素"><a href="#6-4std-sort排序容器元素" class="headerlink" title="6.4std::sort排序容器元素="></a><a href="https://github.com/Mq-b/Cpp20-STL-Cookbook-src/blob/master/src/6.4sort排序容器元素.cpp">6.4<code>std::sort</code>排序容器元素</a>=</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">"print.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;random></span></span><span class="token keyword">void</span> <span class="token function">check_sorted</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>std<span class="token operator">::</span><span class="token function">is_sorted</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"un"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"sorted: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">printc_</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">check_sorted</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> e <span class="token operator">:</span> c<span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{} "</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">randomize</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> std<span class="token operator">::</span>random_device rd<span class="token punctuation">;</span>    <span class="token keyword">static</span> std<span class="token operator">::</span>default_random_engine <span class="token function">rng</span><span class="token punctuation">(</span><span class="token function">rd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">shuffle</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> rng<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">struct</span> things <span class="token punctuation">{</span>    std<span class="token operator">::</span>string s_<span class="token punctuation">;</span>    <span class="token keyword">int</span> i_<span class="token punctuation">;</span>    std<span class="token operator">::</span>string <span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"({}, {})"</span><span class="token punctuation">,</span> s_<span class="token punctuation">,</span> i_<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">print_things</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> v <span class="token operator">:</span> c<span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{} "</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>v<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">printc_</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">{</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> i<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">randomize</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printc_</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    std<span class="token operator">::</span><span class="token function">sort</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printc_</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"partial_sort:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">randomize</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> middle<span class="token punctuation">{</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">partial_sort</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> middle<span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printc_</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">partition</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> i <span class="token operator">></span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printc_</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>things<span class="token operator">></span>vthings<span class="token punctuation">{</span> <span class="token punctuation">{</span><span class="token string">"🐴"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"😘"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"🤣"</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"🥵"</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"🤡"</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">sort</span><span class="token punctuation">(</span>vthings<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vthings<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> things<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> things<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> lhs<span class="token punctuation">.</span>i_ <span class="token operator">></span> rhs<span class="token punctuation">.</span>i_<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print_things</span><span class="token punctuation">(</span>vthings<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-5std-transform修改容器内容"><a href="#6-5std-transform修改容器内容" class="headerlink" title="6.5std::transform修改容器内容"></a>6.5<code>std::transform</code>修改容器内容</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">"print.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span>std<span class="token operator">::</span>string <span class="token function">str_lower</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>string outstr<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">&amp;</span> c <span class="token operator">:</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        outstr <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">tolower</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> outstr<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>v1<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>v2<span class="token punctuation">;</span>    <span class="token function">printc</span><span class="token punctuation">(</span>v1<span class="token punctuation">,</span> <span class="token string">"v1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">transform</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">back_inserter</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printc</span><span class="token punctuation">(</span>v2<span class="token punctuation">,</span> <span class="token string">"v2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span>vstr1<span class="token punctuation">{</span> <span class="token string">"Aaa"</span><span class="token punctuation">,</span><span class="token string">"Bbb"</span><span class="token punctuation">,</span><span class="token string">"Ccc"</span><span class="token punctuation">,</span><span class="token string">"DDD"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span>vstr2<span class="token punctuation">;</span>    <span class="token function">printc</span><span class="token punctuation">(</span>vstr1<span class="token punctuation">,</span> <span class="token string">"vstr1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"str_lower:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">transform</span><span class="token punctuation">(</span>vstr1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vstr1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">back_inserter</span><span class="token punctuation">(</span>vstr2<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">str_lower</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printc</span><span class="token punctuation">(</span>vstr2<span class="token punctuation">,</span> <span class="token string">"vstr2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"ranges sequares:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> view1 <span class="token operator">=</span> std<span class="token operator">::</span>views<span class="token operator">::</span><span class="token function">transform</span><span class="token punctuation">(</span>v1<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printc</span><span class="token punctuation">(</span>view1<span class="token punctuation">,</span> <span class="token string">"view1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    v2<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>ranges<span class="token operator">::</span><span class="token function">transform</span><span class="token punctuation">(</span>v1<span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">back_inserter</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printc</span><span class="token punctuation">(</span>v2<span class="token punctuation">,</span> <span class="token string">"v2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中一个常用操作就是配合<code>tolower</code>()函数是把字符串都转化为小写字母；<code>touppre</code>()函数是把字符串都转化为大写字母：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">transform</span><span class="token punctuation">(</span>first<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>first<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>second<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">::</span>tolower）<span class="token punctuation">;</span><span class="token function">transform</span><span class="token punctuation">(</span>first<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>first<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>second<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">::</span><span class="token function">touppre</span><span class="token punctuation">(</span><span class="token punctuation">)</span>）<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="6-6查找特定项"><a href="#6-6查找特定项" class="headerlink" title="6.6查找特定项"></a>6.6查找特定项</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">"print.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;algorithm></span></span><span class="token keyword">struct</span> City <span class="token punctuation">{</span>    std<span class="token operator">::</span>string name<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> pop<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> City<span class="token operator">&amp;</span> o<span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name <span class="token operator">==</span> o<span class="token punctuation">.</span>name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    std<span class="token operator">::</span>string <span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"[{}, {}]"</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> pop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>v<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> it1 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>it1 <span class="token operator">!=</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"found: {}\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>it1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"not found:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>City<span class="token operator">></span>c<span class="token punctuation">{</span>        <span class="token punctuation">{</span><span class="token string">"London"</span><span class="token punctuation">,</span><span class="token number">8425622</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span><span class="token string">"Berlin"</span><span class="token punctuation">,</span><span class="token number">3566791</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span><span class="token string">"Tokyo"</span><span class="token punctuation">,</span><span class="token number">37435191</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span><span class="token string">"Cairo"</span><span class="token punctuation">,</span><span class="token number">20485965</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> it2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> City<span class="token punctuation">{</span> <span class="token string">"Berlin"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>it2 <span class="token operator">!=</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"found: {}\n"</span><span class="token punctuation">,</span> it2<span class="token operator">-</span><span class="token operator">></span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"not found:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> it3 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find_if</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> City<span class="token operator">&amp;</span> item<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> item<span class="token punctuation">.</span>pop <span class="token operator">></span> <span class="token number">20000000</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>it3 <span class="token operator">!=</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"found: {}\n"</span><span class="token punctuation">,</span> it3<span class="token operator">-</span><span class="token operator">></span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"not found:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> vwl <span class="token operator">=</span> std<span class="token operator">::</span>views<span class="token operator">::</span><span class="token function">filter</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> City<span class="token operator">&amp;</span> item<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> item<span class="token punctuation">.</span>pop <span class="token operator">></span> <span class="token number">20000000</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> City<span class="token operator">&amp;</span> e <span class="token operator">:</span> vwl<span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}\n"</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个内容大概四个部分</p><ol><li>使用<a href="https://zh.cppreference.com/w/cpp/algorithm/find"><strong><code>std::find</code></strong></a>查找标量元素</li><li>使用<code>std::find</code>查找自定义类型元素(需要重载<code>operator==</code>)</li><li>使用 <strong><code>std::find_if</code></strong> 查找自定义类型符合谓词要求的元素</li><li>使用 <a href="https://zh.cppreference.com/w/cpp/ranges/filter_view"><strong><code>std::views::filter</code></strong></a> 返回符合谓词要求的视图，可以像普通容器一样遍历</li></ol><p><code>std::find</code>或<code>std::find_if</code>的返回值是<strong>迭代器</strong>，如果没有查找到，则返回<code>end()</code>。</p><h3 id="6-10合并已排序容器"><a href="#6-10合并已排序容器" class="headerlink" title="6.10合并已排序容器"></a>6.10合并已排序容器</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">"print.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;algorithm></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span>vs1<span class="token punctuation">{</span> <span class="token string">"dog"</span><span class="token punctuation">,</span><span class="token string">"cat"</span><span class="token punctuation">,</span><span class="token string">"veloiraptor"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span>vs2<span class="token punctuation">{</span> <span class="token string">"kirk"</span><span class="token punctuation">,</span><span class="token string">"sulu"</span><span class="token punctuation">,</span><span class="token string">"spock"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span>dest<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">printc</span><span class="token punctuation">(</span>vs1<span class="token punctuation">,</span> <span class="token string">"vs1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printc</span><span class="token punctuation">(</span>vs2<span class="token punctuation">,</span> <span class="token string">"vs2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>ranges<span class="token operator">::</span><span class="token function">sort</span><span class="token punctuation">(</span>vs1<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>ranges<span class="token operator">::</span><span class="token function">sort</span><span class="token punctuation">(</span>vs2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printc</span><span class="token punctuation">(</span>vs1<span class="token punctuation">,</span> <span class="token string">"vs1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printc</span><span class="token punctuation">(</span>vs2<span class="token punctuation">,</span> <span class="token string">"vs2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">merge</span><span class="token punctuation">(</span>vs1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vs1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vs2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vs2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">back_inserter</span><span class="token punctuation">(</span>dest<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printc</span><span class="token punctuation">(</span>dest<span class="token punctuation">,</span> <span class="token string">"dest"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果:</p><pre><code>vs1: [dog] [cat] [veloiraptor]vs2: [kirk] [sulu] [spock]vs1: [cat] [dog] [veloiraptor]vs2: [kirk] [spock] [sulu]dest: [cat] [dog] [kirk] [spock] [sulu] [veloiraptor]</code></pre><p><a href="https://zh.cppreference.com/w/cpp/algorithm/merge"><strong><code>std::merge</code></strong></a>算法接受两个已排序的序列，并创建第三个已合并并排序的序列。前面四个参数表示两个输入范围，第五个参数表示结果序列发送的输出迭代器</p><h2 id="第七章-字符串、流和格式化"><a href="#第七章-字符串、流和格式化" class="headerlink" title="第七章 字符串、流和格式化"></a>第七章 字符串、流和格式化</h2><p>STL 字符串类是一个功能强大的全功能工具，用于存储、操作和显示基于字符的数据。在高级脚本语言中，可以找到的许多字符串相关的便利、快速和敏捷的功能。</p><p><strong><code>std::string</code></strong> 类基于 <a href="https://zh.cppreference.com/w/cpp/string/basic_string"><strong><code>std::basic_string</code></strong></a>，这是一个连续的容器类，可以用字符类型实例化。其类签名是这样</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Elem</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_Traits</span> <span class="token operator">=</span> char_traits<span class="token operator">&lt;</span>_Elem<span class="token operator">></span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_Alloc</span> <span class="token operator">=</span> allocator<span class="token operator">&lt;</span>_Elem<span class="token operator">>></span><span class="token keyword">class</span> <span class="token class-name">basic_string</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>Trait</code> 和 <code>Allocator</code> 模板参数通常保留默认值。<code>basic_string</code> 的底层存储是一个连续的 CharT 序列，可以通过 <code>data()</code> 成员函数访问:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;string></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> std<span class="token operator">::</span>basic_string<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span>s<span class="token punctuation">{</span> <span class="token string">"hello"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> sdata <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> sdata<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果:</p><pre><code>h e l l o</code></pre><p><code>data()</code> 成员函数返回一个指向底层字符数组的 <code>CharT*</code>。从 C++11 起，data() 返回的数组以空结 束，使得 <code>data()</code> <strong>等价于</strong> <code>c_str()</code>。</p><p><code>basic_string</code> 类包含许多在其他连续存储类中可以找到的方法，包括 <code>insert()</code>、<code>erase()</code>、<code>push_back()</code>、 <code>pop_back()</code> 等，这些方法可以操作底层的 CharT 数组。</p><p><code>std::string</code> 是 <code>std::basic_string&lt;char&gt;</code> 类型的别名:</p><pre><code>using string  = basic_string&lt;char, char_traits&lt;char&gt;, allocator&lt;char&gt;&gt;;</code></pre><h3 id="7-3轻量字符串对象string-view"><a href="#7-3轻量字符串对象string-view" class="headerlink" title="7.3轻量字符串对象string_view"></a>7.3轻量字符串对象<code>string_view</code></h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">"print.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;string></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token operator">::</span>literals<span class="token punctuation">;</span>std<span class="token operator">::</span>string_view <span class="token function">sv</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> text<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span> <span class="token string">"hello"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>string_view greeting<span class="token punctuation">{</span> text <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> greeting<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string_view str<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">{</span> <span class="token string">"hello"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>string str2<span class="token punctuation">{</span> str <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}\n"</span><span class="token punctuation">,</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span>    str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}\n"</span><span class="token punctuation">,</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>string_view sview<span class="token punctuation">{</span> str <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}\n"</span><span class="token punctuation">,</span> sview<span class="token punctuation">)</span><span class="token punctuation">;</span>    str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'b'</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}\n"</span><span class="token punctuation">,</span> sview<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> t <span class="token operator">=</span> <span class="token function">sv</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}\n"</span><span class="token punctuation">,</span> <span class="token string">"hello"</span>sv<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">constexpr</span> std<span class="token operator">::</span>string_view str3<span class="token punctuation">{</span> <span class="token string">"哈哈"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//constexpr std::string str4{ "哈哈" };//error</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}\n"</span><span class="token punctuation">,</span> str3<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>string str4<span class="token punctuation">{</span> <span class="token string">"1"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> std<span class="token operator">::</span>string str5<span class="token punctuation">{</span> <span class="token string">"1"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">f</span><span class="token punctuation">(</span>str4<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">f</span><span class="token punctuation">(</span>str5<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">f</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//开销大，需要构造临时的std::string对象</span>    <span class="token function">f2</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">f2</span><span class="token punctuation">(</span>str4<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">f2</span><span class="token punctuation">(</span>str5<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://zh.cppreference.com/w/cpp/string/basic_string_view"><strong><code>std::string_view</code></strong></a>是C++17添加的一个字符串视图类，它的构成和原理也十分简单：它的构造函数只是把自己的数据成员<code>const pointer</code>以及<code>size</code>初始化而已，这是通常的实现，也就是自己不存储任何数据，副本，只是<strong>视图</strong>，依靠指针进行一切访问操作，不提供修改操作</p><h3 id="7-4连接字符串"><a href="#7-4连接字符串" class="headerlink" title="7.4连接字符串"></a>7.4连接字符串</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">"print.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;sstream></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;ostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;chrono></span></span><span class="token keyword">using</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>high_resolution_clock<span class="token punctuation">;</span><span class="token keyword">using</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>duration<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>std<span class="token operator">::</span>string<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> t1 <span class="token operator">=</span> high_resolution_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>string s<span class="token punctuation">{</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> t2 <span class="token operator">=</span> high_resolution_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    duration<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token punctuation">,</span> std<span class="token operator">::</span>milli<span class="token operator">></span>ms <span class="token operator">=</span> t2 <span class="token operator">-</span> t1<span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"duration: {} ms\n"</span><span class="token punctuation">,</span> ms<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>std<span class="token operator">::</span>string <span class="token function">concat_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"concat_string\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>string a<span class="token punctuation">{</span> <span class="token string">"a"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>string b<span class="token punctuation">{</span> <span class="token string">"b"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> n<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">++</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>string x<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        x <span class="token operator">+</span><span class="token operator">=</span> a <span class="token operator">+</span> <span class="token string">", "</span> <span class="token operator">+</span> b <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">>=</span> <span class="token number">10000000</span><span class="token punctuation">)</span><span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token string">"error\n"</span><span class="token punctuation">;</span><span class="token punctuation">}</span>std<span class="token operator">::</span>string <span class="token function">append_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"append_string\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>string a<span class="token punctuation">{</span> <span class="token string">"a"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>string b<span class="token punctuation">{</span> <span class="token string">"b"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> n<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">++</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>string x<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        x<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        x<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">", "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        x<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        x<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">>=</span> <span class="token number">10000000</span><span class="token punctuation">)</span><span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token string">"error\n"</span><span class="token punctuation">;</span><span class="token punctuation">}</span>std<span class="token operator">::</span>string <span class="token function">concat_ostringstream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"ostringstream\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>string a<span class="token punctuation">{</span> <span class="token string">"a"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>string b<span class="token punctuation">{</span> <span class="token string">"b"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> n<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">++</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>stringstream x<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        x <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">>=</span> <span class="token number">10000000</span><span class="token punctuation">)</span><span class="token keyword">return</span> x<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token string">"error\n"</span><span class="token punctuation">;</span><span class="token punctuation">}</span>std<span class="token operator">::</span>string <span class="token function">concat_format</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"append_format\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>string a<span class="token punctuation">{</span> <span class="token string">"a"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>string b<span class="token punctuation">{</span> <span class="token string">"b"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> n<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">++</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>string x<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        x <span class="token operator">+</span><span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"{}, {}\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">>=</span> <span class="token number">10000000</span><span class="token punctuation">)</span><span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token string">"error\n"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">timer</span><span class="token punctuation">(</span>append_string<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">timer</span><span class="token punctuation">(</span>concat_string<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">timer</span><span class="token punctuation">(</span>concat_ostringstream<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">timer</span><span class="token punctuation">(</span>concat_format<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果:</p><pre><code>append_stringa, bduration: 5285.7537 msconcat_stringa, bduration: 19286.9228 msostringstreama, bduration: 21790.0884 msappend_formata, bduration: 29601.7629 ms</code></pre><h3 id="7-5转换字符串"><a href="#7-5转换字符串" class="headerlink" title="7.5转换字符串"></a>7.5转换字符串</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">"print.h"</span></span><span class="token keyword">char</span> <span class="token function">char_upper</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">&amp;</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">toupper</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">char</span> <span class="token function">char_lower</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">&amp;</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">tolower</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">char</span> <span class="token function">rot13</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> rot13a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">char</span> x<span class="token punctuation">,</span> <span class="token keyword">char</span> a<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token keyword">char</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> a <span class="token operator">+</span> <span class="token punctuation">(</span>x <span class="token operator">-</span> a <span class="token operator">+</span> <span class="token number">13</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">26</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">>=</span> <span class="token string">'A'</span> <span class="token operator">&amp;&amp;</span> x <span class="token operator">&lt;=</span> <span class="token string">'Z'</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token function">rot13a</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">>=</span> <span class="token string">'a'</span> <span class="token operator">&amp;&amp;</span> x <span class="token operator">&lt;=</span> <span class="token string">'z'</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token function">rot13a</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span>std<span class="token operator">::</span>string <span class="token function">title_case</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> begin<span class="token punctuation">{</span> s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> end<span class="token punctuation">{</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token operator">*</span>begin<span class="token operator">++</span> <span class="token operator">=</span> <span class="token function">char_upper</span><span class="token punctuation">(</span><span class="token operator">*</span>begin<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">bool</span> space_flag<span class="token punctuation">{</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it<span class="token punctuation">{</span> begin <span class="token punctuation">}</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> end<span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>it <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">)</span>space_flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>space_flag<span class="token punctuation">)</span><span class="token operator">*</span>it <span class="token operator">=</span> <span class="token function">char_upper</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span>            space_flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> s<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>string s<span class="token punctuation">{</span> <span class="token string">"hello jimi\n"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">transform</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> char_upper<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> c <span class="token operator">:</span> s<span class="token punctuation">)</span>c <span class="token operator">=</span> <span class="token function">rot13</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> c <span class="token operator">:</span> s<span class="token punctuation">)</span>c <span class="token operator">=</span> <span class="token function">rot13</span><span class="token punctuation">(</span><span class="token function">char_lower</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">title_case</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果:</p><pre><code>hello jimiHELLO JIMIURYYB WVZVhello jimiHello Jimi</code></pre><h3 id="7-7删除字符串的空白"><a href="#7-7删除字符串的空白" class="headerlink" title="7.7删除字符串的空白"></a>7.7删除字符串的空白</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">"print.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;ranges></span></span>std<span class="token operator">::</span>string <span class="token function">trimstr</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">constexpr</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> whitespace<span class="token punctuation">{</span> <span class="token string">" \t\r\n\v\f"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> s<span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">auto</span> first<span class="token punctuation">{</span> s<span class="token punctuation">.</span><span class="token function">find_first_not_of</span><span class="token punctuation">(</span>whitespace<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">==</span> std<span class="token operator">::</span>string<span class="token operator">::</span>npos<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">auto</span> last<span class="token punctuation">{</span> s<span class="token punctuation">.</span><span class="token function">find_last_not_of</span><span class="token punctuation">(</span>whitespace<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> <span class="token punctuation">(</span>last <span class="token operator">-</span> first <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>string s<span class="token punctuation">{</span> <span class="token string">" \t ten-thumbed input \t  \n \t"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"[{}]\n"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"[{}]\n"</span><span class="token punctuation">,</span> <span class="token function">trimstr</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果:</p><pre><code>[        ten-thumbed input        ][ten-thumbed input]</code></pre><h3 id="7-9统计文件中的单词数"><a href="#7-9统计文件中的单词数" class="headerlink" title="7.9统计文件中的单词数"></a>7.9统计文件中的单词数</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">"print.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;fstream></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;filesystem></span></span>size_t <span class="token function">wordcount</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> is<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">using</span> it_t <span class="token operator">=</span> std<span class="token operator">::</span>istream_iterator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token punctuation">;</span>    <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">distance</span><span class="token punctuation">(</span>it_t<span class="token punctuation">{</span> is <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> fn<span class="token punctuation">{</span> <span class="token string">"E:/自制视频教程/《C++20 STL Cookbook》2023/src/src/the-raven.txt"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>ifstream infile<span class="token punctuation">{</span> fn<span class="token punctuation">,</span>std<span class="token operator">::</span>ios_base<span class="token operator">::</span>in <span class="token punctuation">}</span><span class="token punctuation">;</span>    size_t wc<span class="token punctuation">{</span> <span class="token function">wordcount</span><span class="token punctuation">(</span>infile<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"There are {} words in the file.\n"</span><span class="token punctuation">,</span> wc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"size: {}\n"</span><span class="token punctuation">,</span> std<span class="token operator">::</span>filesystem<span class="token operator">::</span><span class="token function">file_size</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第八章-实用工具类"><a href="#第八章-实用工具类" class="headerlink" title="第八章 实用工具类"></a><a href="https://github.com/Mq-b/Cpp20-STL-Cookbook-src?tab=readme-ov-file#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB">第八章 实用工具类</a></h2><p>C++标准库包括为特定任务设计的各种<strong>工具类</strong>。有些是常见的，读者们可能在这本书的其他示 例中见过很多这样的类。 本章在以下主题中介绍了一些通用的工具，包括时间测量、泛型类型、智能指针等:</p><p>• <a href="https://zh.cppreference.com/w/cpp/utility/optional"><strong><code>std::optional</code></strong></a> 管理可选值</p><p>• <a href="https://zh.cppreference.com/w/cpp/utility/any"><strong><code>std::any</code></strong></a> 保证类型安全</p><p>• <a href="https://zh.cppreference.com/w/cpp/utility/variant"><strong><code>std::variant</code></strong></a> 存储不同的类型</p><p>• <a href="https://zh.cppreference.com/w/cpp/header/chrono"><strong><code>std::chrono</code></strong></a> 的时间事件</p><p>• 对可变元组使用折叠表达式</p><p>• <a href="https://zh.cppreference.com/w/cpp/memory/unique_ptr"><strong><code>std::unique_ptr</code></strong></a> 管理已分配的内存</p><p>• <a href="https://zh.cppreference.com/w/cpp/memory/shared_ptr"><strong><code>std::shared_ptr</code></strong></a> 的共享对象</p><p>• 对共享对象使用弱指针</p><p>• 共享管理对象的成员</p><p>• 比较随机数引擎</p><p>• 比较随机数分布发生器</p><p>感兴趣的可以点击标题去看具体内容</p><h2 id="第九章-并发和并行"><a href="#第九章-并发和并行" class="headerlink" title="第九章 并发和并行"></a><a href="https://github.com/Mq-b/Cpp20-STL-Cookbook-src?tab=readme-ov-file#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C">第九章 并发和并行</a></h2><p>并发性和并行性指的是在不同的执行线程中运行代码的能力。<strong>并发性</strong> 是在后台运行线程的能力，<strong>并行性</strong> 是在处理器的不同内核中同时运行线程的能力。 运行时库以及主机操作系统，将为给定硬件环境中的线程，在并发和并行执行模型之间进行选择。 在现代多任务操作系统中，<code>main()</code> 函数已经代表了一个执行线程。当一个新线程启动时，可由 现有的线程派生。 C++ 标准库中，<code>std::thread</code> 类提供了线程执行的基本单元。其他类构建在线程之上，以提供锁、 互斥和其他并发模式。根据系统架构的不同，执行线程可以在一个处理器上并发运行，也可以在不 同的内核上并行运行。</p><p>• 休眠一定的时间</p><p>• <a href="https://zh.cppreference.com/w/cpp/thread/thread"><strong><code>std::thread</code></strong></a>——实现并发</p><p>• <a href="https://zh.cppreference.com/w/cpp/thread/async"><strong><code>std::async</code></strong></a>——实现并发(重点看一下)</p><p>• STL 算法与执行策略</p><p>• 互斥锁和锁——安全地共享数据(重点看一下)</p><p>• <a href="https://zh.cppreference.com/w/cpp/atomic/atomic"><strong><code>std::atomic</code></strong></a>——共享标志和值</p><p>• <a href="https://zh.cppreference.com/w/cpp/thread/call_once"><strong><code>std::call_once</code></strong></a>——初始化线程</p><p>• <a href="https://zh.cppreference.com/w/cpp/thread/condition_variable"><strong><code>std::condition_variable</code></strong></a>——解决生产者-消费者问题</p><p>• 实现多个生产者和消费者</p><h2 id="第十章-文件系统"><a href="#第十章-文件系统" class="headerlink" title="第十章 文件系统"></a><a href="https://github.com/Mq-b/Cpp20-STL-Cookbook-src?tab=readme-ov-file#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">第十章 文件系统</a></h2><p>不多介绍</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;阅读时请配合cpp reference使用，同时请确保编译器支持C++20。在bilibili上有对应的&lt;a href=&quot;https://w
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://JoyTsing.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="读书笔记" scheme="https://JoyTsing.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>spdlog库源码阅读</title>
    <link href="https://joytsing.github.io/posts/38320/"/>
    <id>https://joytsing.github.io/posts/38320/</id>
    <published>2024-03-21T15:36:29.000Z</published>
    <updated>2024-03-22T14:35:34.762Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>阅读源码是学习进阶必须越过的一步，同时也要学习其他人阅读源码的方式和经验，本文内容不全是个人做的<del>比如图就是从网上偷来的</del>，站在巨人肩膀上才能更好地让自己看到更多。</p><p>源码地址在这：<a href="https://github.com/gabime/spdlog">spdlog</a>，同时贴上一个不错的<a href="https://www.cnblogs.com/fortunely/p/17388565.html">笔记帖子</a>。</p><h2 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h2><p>spdlog的是一个支持多平台的日志库，使用十分方便。且既支持header-only version，也支持compiled version。header-only的全部代码都在项目的include文件夹下，直接将里面的内容copy到自己的项目里就能用。spdlog主要由logger（也包括async_logger）、sink、formatter、registry这四个部分组成，它们之间的基本逻辑结构如下图所示:</p><p><img src="/posts/38320/v2-eafecc8f5d2bcbe542691f7fc6d4263e_r.jpg" alt="spdlog基本逻辑结构"></p><ul><li><strong>spdlog log API</strong> —— 是建立在logger之上的，只是对logger使用的封装，目的只是为了能够像官网给的示例代码spdlog::info(“Welcome to spdlog!”);那样，让用户能够以最简单的方式使用spdlog打印出log。这是一种从用户使用维度出发的程序设计思想。</li><li><strong>logger</strong> —— 是spdlog开始处理日志的入口。sync-logger主要负责日志信息的整理，将格式化（通过第三方库fmt）后的日志内容、日志等级、日志时间等信息“整理”到一个名为log_msg结构体的对象中，然后再交给下游的sink进行处理。而对于async-logger，则是在将整理后的log_msg对象交给线程池，让线程池去处理后续的工作。</li><li><strong>sink</strong> —— 接收log_msg对象，并通过formatter将对象中所含有的信息转换成字符串，最后将字符串输出到指定的地方，例如控制台、文件等，甚至通过tcp/udp将字符串发送到指定的地方。sink译为“下沉”，扩展一下可以理解为“落笔”，做的是把日志真正记录下来的事情。</li><li><strong>formatter</strong> —— 负责将log_msg对象中的信息转换成字符串，例如将等级、时间、实际内容等。时间的格式和精度、等级输出显示的颜色等都是由formatter决定的。支持用户自动以格式。</li><li><strong>registry</strong> —— 负责管理所有的logger，包括创建、销毁、获取等。通过registry用户还可以对所有的logger进行一些全局设置，例如设置日志等级。</li></ul><h2 id="sync-logger"><a href="#sync-logger" class="headerlink" title="sync-logger"></a>sync-logger</h2><p>这部分的代码都在logger.h和logger-inl.h中，对应logger类。logger要做的事情就是将要记录的内容通过函数调用层层传递到，最后到sink。以logger中成员函数info两种调用情况为例，展示logger的调用过程。</p><p><img src="/posts/38320/image-20240322162258564.png" alt></p><p>具体函数签名：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 调用例如spdlog::info("Welcome to spdlog!");</span><span class="token comment" spellcheck="true">// 或者spdlog::info(num);</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">info</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">log</span><span class="token punctuation">(</span>level<span class="token operator">::</span>info<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 确定log等级为info</span><span class="token comment" spellcheck="true">// 调用例如spdlog::info("Support for floats {:03.2f}", 1.23456);</span><span class="token comment" spellcheck="true">// 或者spdlog::info("Positional args are {1} {0}..", "too", "supported");</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">info</span><span class="token punctuation">(</span>format_string_t<span class="token operator">&lt;</span>Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span> fmt<span class="token punctuation">,</span> Args <span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">log</span><span class="token punctuation">(</span>level<span class="token operator">::</span>info<span class="token punctuation">,</span> fmt<span class="token punctuation">,</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Args<span class="token operator">></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 确定log等级为info</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">log</span><span class="token punctuation">(</span>level<span class="token operator">::</span>level_enum lvl<span class="token punctuation">,</span> <span class="token keyword">const</span> T <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">log</span><span class="token punctuation">(</span>source_loc<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> lvl<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 接着再确定日志调用的位置（文件、函数名、行号）</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">log</span><span class="token punctuation">(</span>level<span class="token operator">::</span>level_enum lvl<span class="token punctuation">,</span> format_string_t<span class="token operator">&lt;</span>Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span> fmt<span class="token punctuation">,</span> Args <span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">log</span><span class="token punctuation">(</span>source_loc<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> lvl<span class="token punctuation">,</span> fmt<span class="token punctuation">,</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Args<span class="token operator">></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 接着再确定日志调用的位置（文件、函数名、行号）</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">log</span><span class="token punctuation">(</span>source_loc loc<span class="token punctuation">,</span> level<span class="token operator">::</span>level_enum lvl<span class="token punctuation">,</span> <span class="token keyword">const</span> T <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">log</span><span class="token punctuation">(</span>loc<span class="token punctuation">,</span> lvl<span class="token punctuation">,</span> <span class="token string">"{}"</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 因为spdlog::info(num);可以等价为spdlog::info("{}", num);，所以这里加了一个“{}”</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">log</span><span class="token punctuation">(</span>source_loc loc<span class="token punctuation">,</span> level<span class="token operator">::</span>level_enum lvl<span class="token punctuation">,</span> format_string_t<span class="token operator">&lt;</span>Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span> fmt<span class="token punctuation">,</span> Args <span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">log_</span><span class="token punctuation">(</span>loc<span class="token punctuation">,</span> lvl<span class="token punctuation">,</span> details<span class="token operator">::</span><span class="token function">to_string_view</span><span class="token punctuation">(</span>fmt<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Args<span class="token operator">></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 成员函数info两种调用过程都会汇集到此处</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>logger的调用过程是层层传递的，传递过程中不断添加各种信息，最后两种方式的调用都汇集到log_函数中，log_函数实现如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp">    <span class="token comment" spellcheck="true">// common implementation for after templated public api has been resolved</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">log_</span><span class="token punctuation">(</span>source_loc loc<span class="token punctuation">,</span> level<span class="token operator">::</span>level_enum lvl<span class="token punctuation">,</span> string_view_t fmt<span class="token punctuation">,</span> Args <span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">bool</span> log_enabled <span class="token operator">=</span> <span class="token function">should_log</span><span class="token punctuation">(</span>lvl<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">bool</span> traceback_enabled <span class="token operator">=</span> tracer_<span class="token punctuation">.</span><span class="token function">enabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>log_enabled <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>traceback_enabled<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    SPDLOG_TRY <span class="token punctuation">{</span>        memory_buf_t buf<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">ifdef</span> SPDLOG_USE_STD_FORMAT</span>        fmt_lib<span class="token operator">::</span><span class="token function">vformat_to</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">back_inserter</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span> fmt<span class="token punctuation">,</span> fmt_lib<span class="token operator">::</span><span class="token function">make_format_args</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">else</span></span>        fmt<span class="token operator">::</span><span class="token function">vformat_to</span><span class="token punctuation">(</span>fmt<span class="token operator">::</span><span class="token function">appender</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span> fmt<span class="token punctuation">,</span> fmt<span class="token operator">::</span><span class="token function">make_format_args</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>        details<span class="token operator">::</span>log_msg <span class="token function">log_msg</span><span class="token punctuation">(</span>loc<span class="token punctuation">,</span> name_<span class="token punctuation">,</span> lvl<span class="token punctuation">,</span> <span class="token function">string_view_t</span><span class="token punctuation">(</span>buf<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> buf<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">log_it_</span><span class="token punctuation">(</span>log_msg<span class="token punctuation">,</span> log_enabled<span class="token punctuation">,</span> traceback_enabled<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">SPDLOG_LOGGER_CATCH</span><span class="token punctuation">(</span>loc<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先判断是否需要记录日志should_log(lvl)，以及是否需要traceback，如果都不需要则直接返回，判断逻辑是当前log等级是否大于logger的log等级。而traceback是spdlog的另一个功能，对我们理解spdlog的调用过程相关程度不高，可不必细究。至于fmt库将输出格式化，C++20中STL库有了自带的fmt和location，在学习之后可以自己试着写一个log库。</p><p>至此logger完成了它的主要工作，最后很剩下的工作就是把log_msg对象交给下游的sink进行处理了，就是上面最后一句代码“<code>log_it_(log_msg, log_enabled, traceback_enabled);”</code>要做的事。这部分代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// protected methods</span>SPDLOG_INLINE <span class="token keyword">void</span> logger<span class="token operator">::</span><span class="token function">log_it_</span><span class="token punctuation">(</span><span class="token keyword">const</span> spdlog<span class="token operator">::</span>details<span class="token operator">::</span>log_msg <span class="token operator">&amp;</span>log_msg<span class="token punctuation">,</span>                                   <span class="token keyword">bool</span> log_enabled<span class="token punctuation">,</span>                                   <span class="token keyword">bool</span> traceback_enabled<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>log_enabled<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">sink_it_</span><span class="token punctuation">(</span>log_msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>traceback_enabled<span class="token punctuation">)</span> <span class="token punctuation">{</span>        tracer_<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>log_msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>SPDLOG_INLINE <span class="token keyword">void</span> logger<span class="token operator">::</span><span class="token function">sink_it_</span><span class="token punctuation">(</span><span class="token keyword">const</span> details<span class="token operator">::</span>log_msg <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>sink <span class="token operator">:</span> sinks_<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sink<span class="token operator">-</span><span class="token operator">></span><span class="token function">should_log</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>level<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            SPDLOG_TRY <span class="token punctuation">{</span> sink<span class="token operator">-</span><span class="token operator">></span><span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>            <span class="token function">SPDLOG_LOGGER_CATCH</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>source<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">should_flush_</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">flush_</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>SPDLOG_INLINE <span class="token keyword">void</span> logger<span class="token operator">::</span><span class="token function">flush_</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>sink <span class="token operator">:</span> sinks_<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SPDLOG_TRY <span class="token punctuation">{</span> sink<span class="token operator">-</span><span class="token operator">></span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token function">SPDLOG_LOGGER_CATCH</span><span class="token punctuation">(</span><span class="token function">source_loc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>log_it函数又进一步调用了sink_it函数。在sink_it函数中，首先遍历了sinks_中的所有sink，在把msg交由每个sink去处理。</p><blockquote><p>sinks并不是一个类，而是一系列类，以基类-派生类形式组织，一个sink派生类代表了一种输出log消息方式，输出目标可以是普通文件stdout、stderr，或者syslog等等。sink系列类主要负责从logger接收用户log消息，按指定模式（pattern）进行格式化（format），得到一条完整的、格式化后的log消息，然后将其写到目标文件。sink系列类的实现，全部位于include/spdlog/sinks目录。</p></blockquote><p>sinks_是logger的成员变量，其声明为“std::vector&lt;sink_ptr&gt; sinks_;”。可以看出一个logger是可以对应多个sink的，同时sink实际上还是指针形式保存在logger中的，意味着也可以存在多个logger都指向同一个sink的情况。这样日志的输入端（logger）和输出端（sink）就解耦了。这样方便我们扩展，比如现在想让日志同时输出到文件和控制台，只需要在创建logger的时候把两个sink都添加进去就可以了。</p><p><code>sink_it_</code>函数中还调用了<code>flush\_</code>函数，这个函数的作用是让所有sink都进行一次flush操作。前面的<code>sink-&gt;log(msg)</code>这是写入了缓冲区，而sink-&gt;flush()是将缓冲区的内容进一步写入到文件或者控制台等最终目的地。而且在<code>sink_it</code>函数调用<code>flush_</code>函数之前，还调用了<code>should_flush_</code>函数，函数中判断了msg的等级和<code>flush_level_</code>的关系，如果msg的等级大于<code>flush_level_</code>则返回true，否则返回false。这么做的目的是减少不必要的flush操作。例如我们像保存info及其以上等级的日志，但是绝大多数时候我们并会实时地查看info级别的日志，但是error级别的日志我们却希望能够及时展示出来。那么我们可以将<code>flush_level_</code>设置为error，这样只有error级别的日志才会进行flush操作。</p><h3 id="同步工厂方法"><a href="#同步工厂方法" class="headerlink" title="同步工厂方法"></a>同步工厂方法</h3><p>通常，一个工厂方法创建一种对象，如果想创建不同类型的对象，就传入参数，工厂方法内部进行判断后创建不同类型对象。synchronous_factory的精妙之处在于，函数参数用来创建对象，模板参数用来指定要创建的类型（有关的部分）。</p><p>logger_name对于registry全局注册表来说，是唯一标识logger对象的。</p><p>这里有一个潜在的约定，所有工厂方法必须实现一个static create方法，通过模板参数Sink创建不同类型Sink派生类对象，然后绑定到新建的logger对象，从而实现不同的功能。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// Default logger factory-  creates synchronous loggers</span><span class="token keyword">class</span> <span class="token class-name">logger</span><span class="token punctuation">;</span><span class="token keyword">struct</span> synchronous_factory<span class="token punctuation">{</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Sink<span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> SinkArgs<span class="token operator">></span>    <span class="token keyword">static</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>spdlog<span class="token operator">::</span>logger<span class="token operator">></span> <span class="token function">create</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string logger_name<span class="token punctuation">,</span>  SinkArgs <span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">auto</span> sink <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>Sink<span class="token operator">></span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>SinkArgs<span class="token operator">></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 模板参数Sink决定了要具体Sink类型</span>        <span class="token keyword">auto</span> new_logger <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>spdlog<span class="token operator">::</span>logger<span class="token operator">></span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>logger_name<span class="token punctuation">)</span><span class="token punctuation">,</span>  std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>sink<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用logger name及sink来创建logger对象</span>        details<span class="token operator">::</span>registry<span class="token operator">::</span><span class="token function">instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">initialize_logger</span><span class="token punctuation">(</span>new_logger<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始化logger, 并添加到全局注册表</span>        <span class="token keyword">return</span> new_logger<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="async-logger"><a href="#async-logger" class="headerlink" title="async-logger"></a>async-logger</h2><p>async-logger的代码在asyn_logger.h和async_looger-inl.h中，对应async_logger类。async_logger继承自logger，前面关于接受日志内容整理log_msg对象中的工作照常做，将对sink的调用（包括sink-&gt;log(msg)和sink-&gt;flush()）都交由线程池去执行了，由此便实现了异步。代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> spdlog<span class="token operator">::</span>async_logger<span class="token operator">::</span><span class="token function">sink_it_</span><span class="token punctuation">(</span><span class="token keyword">const</span> details<span class="token operator">::</span>log_msg <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> pool_ptr <span class="token operator">=</span> thread_pool_<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        pool_ptr<span class="token operator">-</span><span class="token operator">></span><span class="token function">post_log</span><span class="token punctuation">(</span><span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> msg<span class="token punctuation">,</span> overflow_policy_<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token function">throw_spdlog_ex</span><span class="token punctuation">(</span><span class="token string">"async log: thread pool doesn't exist anymore"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// thread_pool_ 的声明</span>std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span>details<span class="token operator">::</span>thread_pool<span class="token operator">></span> thread_pool_<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>线程池通过<code>pool_ptr-&gt;post_log(shared_from_this(), msg, overflow_policy_);</code>这句代码持有了当前<code>asyn_logger</code>的<code>shared_ptr</code>。那这样asyn_logger就不能再以shared_ptr的形式持有线程池了，因为会存在交叉引用带来的内存泄露问题。所以这里使用weak_ptr来持有线程池。毫无疑问，async_logger实现的重点是线程池。</p><p>线程池里面要有一个多生产多消费的线程安全队列，用来存放日志内容。可以有多个async_logger（即生产者）向里面生产日志，又同时又多个线程（即消费者）从里面消费日志。这个队列的容量应该是有限的，当队列满了之后向里面生产日志可以有不同的策略，spdlog提供了三种策略：阻塞、丢弃新日志和丢弃旧日志。为方便实现这个需求，用循环队列来实现。</p><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>循环队列的代码在circular_q.h中，实现起来不难。这里只提两点可能在没开始动手实现之前可能想不起来的点：</p><ul><li>circular_q应设计成类模板，使其能够支持各种数据类型；</li><li>circular_q中实际存数据的std::vector&lt;T&gt; vec_的大小应该比circular_q能存的数据大小多一个，这样才能队列是满的还是空的，两个状态不会混淆。</li></ul><h3 id="多生产多消费的线程安全队列"><a href="#多生产多消费的线程安全队列" class="headerlink" title="多生产多消费的线程安全队列"></a>多生产多消费的线程安全队列</h3><p>这部分代码在mpmc_blocking_q.h中，我们先来看一下其中的成员变量：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">mpmc_blocking_queue</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>mutex queue_mutex_<span class="token punctuation">;</span>    std<span class="token operator">::</span>condition_variable push_cv_<span class="token punctuation">;</span>    std<span class="token operator">::</span>condition_variable pop_cv_<span class="token punctuation">;</span>    spdlog<span class="token operator">::</span>details<span class="token operator">::</span>circular_q<span class="token operator">&lt;</span>T<span class="token operator">></span> q_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>push_cv_和pop_cv_是用来实现生产者消费者模型的关键，其存在的目的是当q_为空或满时，消费者线程或生产者线程是阻塞式等待，而不是空转。我们看看向mpmc_blocking_queue中生产和消费数据的代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>T <span class="token operator">&amp;&amp;</span>item<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span>queue_mutex_<span class="token punctuation">)</span><span class="token punctuation">;</span>        pop_cv_<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>q_<span class="token punctuation">.</span><span class="token function">full</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        q_<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    push_cv_<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">dequeue</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span>popped_item<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span>queue_mutex_<span class="token punctuation">)</span><span class="token punctuation">;</span>        push_cv_<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>q_<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        popped_item <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>q_<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        q_<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    pop_cv_<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="spdlog线程池"><a href="#spdlog线程池" class="headerlink" title="spdlog线程池"></a>spdlog线程池</h3><p>站在数据（环形队列）的角度，线程池不断接收生产者（前端线程）输入的数据，同时不断从队列取出数据，交给消费者处理（后端线程）。</p><p><img src="/posts/38320/741401-20221027012235353-635622687.png" alt></p><p>这里面包含几个重要线程池操作：</p><ul><li>前端线程往线程池插入数据；</li><li>从线程池取出数据交给后端线程处理；</li><li>线程池数据满时，插入数据异常处理；</li><li>线程池空时，取出数据异常处理；</li></ul><p>线程池的代码在<code>thread_pool.h</code>和<code>thread_pool-inl.h</code>中，这里的线程池跟那些通用的线程池实现相比，核心没变，每个线程都是负责从队列里面取东西然后执行，不同是线程池因为是专门做日志输出工作的，所以去从队列里去的东西是日志相关的东西，通用的线程池一般取的是函数指针。由于线程池的唯一需要确保线程安全的数据是环形队列，而环形队列本身提供线程安全支持，因此线程池无需额外支持线程安全。</p><p>简单看看每个线程（worker）做的事情：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> thread_pool<span class="token operator">::</span><span class="token function">worker_loop_</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">process_next_msg_</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">bool</span> thread_pool<span class="token operator">::</span><span class="token function">process_next_msg_</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    async_msg incoming_async_msg<span class="token punctuation">;</span>    q_<span class="token punctuation">.</span><span class="token function">dequeue</span><span class="token punctuation">(</span>incoming_async_msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>incoming_async_msg<span class="token punctuation">.</span>msg_type<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> async_msg_type<span class="token operator">::</span>log<span class="token operator">:</span> <span class="token punctuation">{</span>            incoming_async_msg<span class="token punctuation">.</span>worker_ptr<span class="token operator">-</span><span class="token operator">></span><span class="token function">backend_sink_it_</span><span class="token punctuation">(</span>incoming_async_msg<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">case</span> async_msg_type<span class="token operator">::</span>flush<span class="token operator">:</span> <span class="token punctuation">{</span>            incoming_async_msg<span class="token punctuation">.</span>worker_ptr<span class="token operator">-</span><span class="token operator">></span><span class="token function">backend_flush_</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">case</span> async_msg_type<span class="token operator">::</span>terminate<span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">default</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token function">assert</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的<code>backend_sink_it_</code>和<code>backend_flush_</code>里面的实现跟前面同步logger中的l<code>ogger::sink_it_</code>和<code>logger::flush</code>_是一样的。所以看到这就知道<code>asyn_logger</code>就是把其中调用sink这部分工作交给线程池来做了，仅此而已。</p><h3 id="异步工厂方法"><a href="#异步工厂方法" class="headerlink" title="异步工厂方法"></a>异步工厂方法</h3><p>针对所使用的环形队列，当队列满时，如果插入数据，有两种策略：阻塞、非阻塞，分别对应工厂类型async_factory、async_factory_nonblock：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> async_factory <span class="token operator">=</span> async_factory_impl<span class="token operator">&lt;</span>async_overflow_policy<span class="token operator">::</span>block<span class="token operator">></span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 阻塞策略</span><span class="token keyword">using</span> async_factory_nonblock <span class="token operator">=</span>  async_factory_impl<span class="token operator">&lt;</span>async_overflow_policy<span class="token operator">::</span>overrun_oldest<span class="token operator">></span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 非阻塞策略</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以看到上面2种工厂类型，都是通过<code>async_factory_impl</code>来实现的。那么，<code>async_factory_impl</code>是如何实现的呢？<code>async_factory_impl</code>也遵循工厂方法的潜规则：提供<code>static create</code>方法，根据模板参数Sink创建不同类型sink对象并绑定到新建的logger对象。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// async logger factory - creates async loggers backed with thread pool.</span><span class="token comment" spellcheck="true">// if a global thread pool doesn't already exist, create it with default queue</span><span class="token comment" spellcheck="true">// size of 8192 items and single thread.</span><span class="token keyword">template</span><span class="token operator">&lt;</span>async_overflow_policy OverflowPolicy <span class="token operator">=</span> async_overflow_policy<span class="token operator">::</span>block<span class="token operator">></span><span class="token keyword">struct</span> async_factory_impl<span class="token punctuation">{</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Sink<span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> SinkArgs<span class="token operator">></span>    <span class="token keyword">static</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>async_logger<span class="token operator">></span> <span class="token function">create</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string logger_name<span class="token punctuation">,</span> SinkArgs  <span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">auto</span> <span class="token operator">&amp;</span>registry_inst <span class="token operator">=</span> details<span class="token operator">::</span>registry<span class="token operator">::</span><span class="token function">instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果全局线程池不存在，就创建一个</span>        <span class="token comment" spellcheck="true">// create global thread pool if not already exists..</span>        <span class="token keyword">auto</span> <span class="token operator">&amp;</span>mutex <span class="token operator">=</span> registry_inst<span class="token punctuation">.</span><span class="token function">tp_mutex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>recursive_mutex<span class="token operator">></span> <span class="token function">tp_lock</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">auto</span> tp <span class="token operator">=</span> registry_inst<span class="token punctuation">.</span><span class="token function">get_tp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tp <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            tp <span class="token operator">=</span>  std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>details<span class="token operator">::</span>thread_pool<span class="token operator">></span><span class="token punctuation">(</span>details<span class="token operator">::</span>default_async_q_size<span class="token punctuation">,</span> <span class="token number">1U</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            registry_inst<span class="token punctuation">.</span><span class="token function">set_tp</span><span class="token punctuation">(</span>tp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">auto</span> sink <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>Sink<span class="token operator">></span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>SinkArgs<span class="token operator">></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 创建新async_logger对象同时, 绑定线程池</span>        <span class="token keyword">auto</span> new_logger <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>async_logger<span class="token operator">></span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>logger_name<span class="token punctuation">)</span><span class="token punctuation">,</span>  std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>sink<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>tp<span class="token punctuation">)</span><span class="token punctuation">,</span> OverflowPolicy<span class="token punctuation">)</span><span class="token punctuation">;</span>        registry_inst<span class="token punctuation">.</span><span class="token function">initialize_logger</span><span class="token punctuation">(</span>new_logger<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> new_logger<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>跟同步工厂方法最大的区别是：异步工厂方法，是依附于一个（registry单例管理的）全局线程池的。创建出来的logger对象真实类型是派生类<code>async_logger</code>。而<code>async_logger</code>通过一个弱指针指向线程池。上面的只是工厂的类型，并非工厂方法。用户想要利用工厂方法创建对象，需要用到下面的<code>create_async</code>, <code>create_async_nb</code>方法：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 采用阻塞策略的异步工厂方法</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Sink<span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> SinkArgs<span class="token operator">></span><span class="token keyword">inline</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>spdlog<span class="token operator">::</span>logger<span class="token operator">></span> <span class="token function">create_async</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string logger_name<span class="token punctuation">,</span>  SinkArgs <span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> sink_args<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> async_factory<span class="token operator">::</span>create<span class="token operator">&lt;</span>Sink<span class="token operator">></span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>logger_name<span class="token punctuation">)</span><span class="token punctuation">,</span>  std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>SinkArgs<span class="token operator">></span><span class="token punctuation">(</span>sink_args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 采用非阻塞策略的异步工厂方法</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Sink<span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> SinkArgs<span class="token operator">></span><span class="token keyword">inline</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>spdlog<span class="token operator">::</span>logger<span class="token operator">></span> <span class="token function">create_async_nb</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string logger_name<span class="token punctuation">,</span>  SinkArgs <span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> sink_args<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> async_factory_nonblock<span class="token operator">::</span>create<span class="token operator">&lt;</span>Sink<span class="token operator">></span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>logger_name<span class="token punctuation">)</span><span class="token punctuation">,</span>  std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>SinkArgs<span class="token operator">></span><span class="token punctuation">(</span>sink_args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在客户端，比如你想创建一个<code>basic_logger_mt</code>，即一个基本都用于多线程环境的<code>async_logger</code>，可以这样封装工厂方法，然后供APP调用：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// include/spdlog/sinks/basic_file_sink.h</span><span class="token comment" spellcheck="true">// 封装工厂方法，供APP调用</span><span class="token comment" spellcheck="true">// factory functions</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Factory <span class="token operator">=</span> spdlog<span class="token operator">::</span>synchronous_factory<span class="token operator">></span><span class="token keyword">inline</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>logger<span class="token operator">></span> <span class="token function">basic_logger_mt</span><span class="token punctuation">(</span>    <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>logger_name<span class="token punctuation">,</span> <span class="token keyword">const</span> filename_t <span class="token operator">&amp;</span>filename<span class="token punctuation">,</span> <span class="token keyword">bool</span> truncate <span class="token operator">=</span>  <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">const</span> file_event_handlers <span class="token operator">&amp;</span>event_handlers <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> Factory<span class="token operator">::</span><span class="token keyword">template</span> create<span class="token operator">&lt;</span>sinks<span class="token operator">::</span>basic_file_sink_mt<span class="token operator">></span><span class="token punctuation">(</span>logger_name<span class="token punctuation">,</span>  filename<span class="token punctuation">,</span> truncate<span class="token punctuation">,</span> event_handlers<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// APP端创建async_logger对象</span><span class="token comment" spellcheck="true">// spdlog::init_thread_pool(32768, 1); // queue with max 32k items 1 backing  thread.</span><span class="token keyword">auto</span> async_file <span class="token operator">=</span>  spdlog<span class="token operator">::</span>basic_logger_mt<span class="token operator">&lt;</span>spdlog<span class="token operator">::</span>async_factory<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"async_file_logger"</span><span class="token punctuation">,</span>  <span class="token string">"logs/async_log.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="sink"><a href="#sink" class="headerlink" title="sink"></a>sink</h2><h3 id="sink-1"><a href="#sink-1" class="headerlink" title="sink"></a>sink</h3><p>sink相关的代码都在sinks文件夹中，有不同种类的sink实现，以满足用户对不同输出目的地的需求，比如有控制台、文件、网络、数据库等。</p><pre class="line-numbers language-text"><code class="language-text">sink    | ---> base_sink ---> basic_file_sink   | ---> stdout_sink_base<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>sink是所有不同类型sink的基类，它提供了统一的接口，实际上并它的实现并没有多少代码量。我们看看它的定义：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> level_t <span class="token operator">=</span> std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">sink</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">sink</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">const</span> details<span class="token operator">::</span>log_msg <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">set_pattern</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>pattern<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">set_formatter</span><span class="token punctuation">(</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>spdlog<span class="token operator">::</span>formatter<span class="token operator">></span> sink_formatter<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">set_level</span><span class="token punctuation">(</span>level<span class="token operator">::</span>level_enum log_level<span class="token punctuation">)</span><span class="token punctuation">;</span>    level<span class="token operator">::</span>level_enum <span class="token function">level</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token keyword">bool</span> <span class="token function">should_log</span><span class="token punctuation">(</span>level<span class="token operator">::</span>level_enum msg_level<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">// sink log level - default is all</span>    level_t level_<span class="token punctuation">{</span>level<span class="token operator">::</span>trace<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>sink类只有一个成员变量，level_类型是原子变量。同时之后跟level_相关的成员函数在这里实现了，其他的都是纯虚函数，需要子类去实现。这是因为sink及其子类都要是线程安全的，因为此处level_已经是原子变量了，可以做到线程安全了，所以跟level_相关的成员函数就直接在此处得到实现。</p><p>其他成员函数log()和flush()的功能是将从logger传过来的msg转成字符串然后写到缓冲区和从缓冲区写到目的地（控制台、文件等）。<code>set_pattern()</code>和<code>set_formatter()</code>是用来设置日志格式的，例如显示时间的样式等，这两个函数一定程度上是等价的。具体是怎么格式化的，我们留到将formatter部分的时候再讲，本文不再展开。</p><p>既然sink及其子类都要求线程安全，那么就应该在sink这个基类这里把线程安全相关的代码都写好，这样子类继承时候再写的代码只管逻辑就行，不用再考虑线程安全问题了。这么想是对的，确实应该在父类中把线程安全相关的代码都写好，spdlog也是这么做的。但是是在base_sink类里实现的，而不是sink类。为什么是在base_sink类里，而不是在sink类里？以及为什么stdout_sink_base直接继承自sink而不是base_sink？</p><h3 id="base-sink"><a href="#base-sink" class="headerlink" title="base_sink"></a>base_sink</h3><p>base_sink继承自sink，而且是个类模板，代码也很少，就是对该加锁地方加上了锁，以此来实现线程安全。以下是base_sink部分代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Mutex<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">base_sink</span> <span class="token operator">:</span> <span class="token keyword">public</span> sink <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">const</span> details<span class="token operator">::</span>log_msg <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span> final <span class="token punctuation">{</span>        std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>Mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span>mutex_<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sink_it_</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span> final <span class="token punctuation">{</span>        std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>Mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span>mutex_<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">flush_</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">protected</span><span class="token operator">:</span>    Mutex mutex_<span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">sink_it_</span><span class="token punctuation">(</span><span class="token keyword">const</span> details<span class="token operator">::</span>log_msg <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">flush_</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>log和flush函数在sink是纯虚函数，需要在子类中实现。而base_sink的实现仅仅只是加锁之后再进一步调用<code>sink_it_</code>和f<code>lush_</code>，只是做了线程安全方面的处理，没有具体业务逻辑。这里需要强调一下的是，锁mutex_的类型是Mutex是通过模板参数传进来的，也就是说base_sink是支持多种锁类型的。用模板来支持多种锁类型，这还不是这个模板用法的最值得说道的点。最值得说道的点是，这样的实现能够同时让base_sink十分优雅的支持无锁版本。</p><p>需要说明，对于只在单线程中使用spdlog，我们肯定不希望每次写日志还要加锁，毕竟这带来的白白的性能损耗，所以也必须给所有类型的sink至少提供有锁和无锁两种版本。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> basic_file_sink_mt <span class="token operator">=</span> basic_file_sink<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span><span class="token punctuation">;</span><span class="token keyword">using</span> basic_file_sink_st <span class="token operator">=</span> basic_file_sink<span class="token operator">&lt;</span>details<span class="token operator">::</span>null_mutex<span class="token operator">></span><span class="token punctuation">;</span><span class="token keyword">struct</span> null_mutex <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上是basic_file_sink中的两行代码，basic_file_sink继承自Mutex。<code>basic_file_sink_mt</code>后面的mt就是multi-thread的意思，表示多线程版本，所以模板参数用的是std::mutex。<code>basic_file_sink_st</code>后面的st就是single-thread的意思，表示单线程版本，模板参数用的是<code>details::null_mutex</code>，这个null_mutex是spdlog自己实现的空锁，我的评价是妙啊。</p><h3 id="basic-file-sink"><a href="#basic-file-sink" class="headerlink" title="basic_file_sink"></a>basic_file_sink</h3><p>接着上面，我们继续来看basic_file_sink的代码。就是把base_sink的两个纯虚函数sink_it_和flush_实现了，本身逻辑也是十分简单。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Mutex<span class="token operator">></span><span class="token keyword">void</span> basic_file_sink<span class="token operator">&lt;</span>Mutex<span class="token operator">></span><span class="token operator">::</span><span class="token function">sink_it_</span><span class="token punctuation">(</span><span class="token keyword">const</span> details<span class="token operator">::</span>log_msg <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    memory_buf_t formatted<span class="token punctuation">;</span>    formatter_<span class="token operator">-</span><span class="token operator">></span><span class="token function">format</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> formatted<span class="token punctuation">)</span><span class="token punctuation">;</span>    file_helper_<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>formatted<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Mutex<span class="token operator">></span><span class="token keyword">void</span> basic_file_sink<span class="token operator">&lt;</span>Mutex<span class="token operator">></span><span class="token operator">::</span><span class="token function">flush_</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    file_helper_<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>sink_it_中的<code>formatter_-&gt;format(msg, formatted)</code>就是将msg中的内容格式化成字符串，然后写入到formatted中。<code>file_helper_.write</code>和<code>file_helper_.flush</code>中的核心代码（ubuntu环境下）无非也就是<code>std::fwrite</code>和<code>std::fflush</code>两个库函数。</p><h3 id="stdout-sinks"><a href="#stdout-sinks" class="headerlink" title="stdout_sinks"></a>stdout_sinks</h3><p>前面我们提到，stdout_sink_base直接继承自sink而不是base_sink。stdout_sink_base也是要考虑线程安全的，我们来看看它与base_sink有何不同。作为对比我们把base_sink的部分代码也贴过出来：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Mutex<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">base_sink</span> <span class="token operator">:</span> <span class="token keyword">public</span> sink <span class="token punctuation">{</span><span class="token keyword">protected</span><span class="token operator">:</span>    Mutex mutex_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> ConsoleMutex<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">stdout_sink_base</span> <span class="token operator">:</span> <span class="token keyword">public</span> sink <span class="token punctuation">{</span><span class="token keyword">protected</span><span class="token operator">:</span>    ConsoleMutex<span class="token operator">::</span>mutex_t <span class="token operator">&amp;</span>mutex_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最大的区别就在于成员变量<code>mutex_</code>的类型不同，<code>stdout_sink_base</code>的锁类型是带引用的。因为<code>stdout_sink_base</code>就是输出到控制台，一个程序只能有一个控制台啊，因此<code>stdout_sink_base</code>中的<code>mutex_</code>应该是全局唯一的，是个单例，那么很理所当然的这里用引用类型。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> console_mutex <span class="token punctuation">{</span>    <span class="token keyword">using</span> mutex_t <span class="token operator">=</span> std<span class="token operator">::</span>mutex<span class="token punctuation">;</span>    <span class="token keyword">static</span> mutex_t <span class="token operator">&amp;</span><span class="token function">mutex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">static</span> mutex_t s_mutex<span class="token punctuation">;</span>        <span class="token keyword">return</span> s_mutex<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> console_nullmutex <span class="token punctuation">{</span>    <span class="token keyword">using</span> mutex_t <span class="token operator">=</span> null_mutex<span class="token punctuation">;</span>    <span class="token keyword">static</span> mutex_t <span class="token operator">&amp;</span><span class="token function">mutex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">static</span> mutex_t s_mutex<span class="token punctuation">;</span>        <span class="token keyword">return</span> s_mutex<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="formatter"><a href="#formatter" class="headerlink" title="formatter"></a>formatter</h2><p>不在这里介绍，感兴趣可以好好学学C++20新增的format。</p><h2 id="registry"><a href="#registry" class="headerlink" title="registry"></a><strong>registry</strong></h2><p>spdlog主要由logger（也包括async_logger）、sink、formatter、registry这四个部分组成。实际上这三个已经足够将一条日志输出（记录）下来了，还剩下没介绍的registry则是负责管理前面那三个部件的。当然用户也可以不通过registry来自行管理。所以registry不是必须的，它本身的实现并不涉及spdlog的核心功能，只是为了更好的管理资源。例如通过registry，用户对所有logger设置日志等级、可以创建带有默认设置的logger之类的……</p><h3 id="默认logger和默认sink"><a href="#默认logger和默认sink" class="headerlink" title="默认logger和默认sink"></a>默认logger和默认sink</h3><p>registry的代码主要在registry.h、registry-inl.h。还记得这一句最简单的使用spdlog的代码吗？</p><pre class="line-numbers language-cpp"><code class="language-cpp">spdlog<span class="token operator">::</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Welcome to spdlog!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这里我们既没有创建logger，也没有设置sink，直接就可用了。实际上是registry帮我们创建了默认的logger和默认的sink，方便我们直接使用。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">info</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 即spdlog::info</span>    <span class="token function">default_logger_raw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">info</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>spdlog<span class="token operator">::</span>logger <span class="token operator">*</span><span class="token function">default_logger_raw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> registry<span class="token operator">::</span><span class="token function">instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get_default_raw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>registry <span class="token operator">&amp;</span>registry<span class="token operator">::</span><span class="token function">instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> registry s_instance<span class="token punctuation">;</span>    <span class="token keyword">return</span> s_instance<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 直接用logger的裸指针的原因，spdlog是这么解释的：</span><span class="token comment" spellcheck="true">// To be used directly by the spdlog default api (e.g. spdlog::info)</span><span class="token comment" spellcheck="true">// This make the default API faster</span>logger <span class="token operator">*</span>registry<span class="token operator">::</span><span class="token function">get_default_raw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> default_logger_<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>registry<span class="token operator">::</span><span class="token function">registry</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> color_sink <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>sinks<span class="token operator">::</span>ansicolor_stdout_sink_mt<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>default_logger_name <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>    default_logger_ <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>spdlog<span class="token operator">::</span>logger<span class="token operator">></span><span class="token punctuation">(</span>default_logger_name<span class="token punctuation">,</span>                                                       std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>color_sink<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到<code>spdlog::info</code>中<code>default_logger_raw()</code>得到了默认logger的指针，然后顺理成章就调用info输出日志。默认logger的指针则来自registry对象中的<code>default_logger_</code>成员变量。registry是单例，所以获取registry对象使用的是静态方法<code>registry::instance()</code>。最后我们看到<code>registry::registry()</code>中创建了默认logger，选择的sink是<code>ansicolor_stdout_sink_mt</code>，也就是彩色输出到控制台，最后的“_mt”表示是线程安全的sink。也就是说，当用户什么都没设置时调用spdlog::info时，结果是像控制台输出彩色日志，这也是用户刚上手spdlog最可能希望得到的结果。</p><h3 id="logger工厂"><a href="#logger工厂" class="headerlink" title="logger工厂"></a>logger工厂</h3><p>registry主要作用就是管理logger（例如将所有logger日志等级、格式等统一为相同的），那么logger创建的时候就要将其共享指针存在registry中，这样registry才能管理到。在考虑到简单易用的原则，用户可以不事先了解logger和registry概念，也不必时刻记得要把logger的共享指针存到registry中。因此spdlog提供了一系列获取logger的函数，这些函数除了构造logger对象之外，还将这个logger的共享指针存到registry中。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// stdout_logger_mt返回使用stdout_sink的logger，且多线程版本（线程安全的）</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Factory <span class="token operator">=</span> spdlog<span class="token operator">::</span>synchronous_factory<span class="token operator">></span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>logger<span class="token operator">></span> <span class="token function">stdout_logger_mt</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// basic_logger_st返回使用basic_file_sink的logger，且单线程版本（非线程安全的）</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Factory <span class="token operator">=</span> spdlog<span class="token operator">::</span>synchronous_factory<span class="token operator">></span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>logger<span class="token operator">></span> <span class="token function">basic_logger_st</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// rotating_logger_mt返回使用rotating_file_sink的logger，且多线程版本（线程安全的）</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Factory <span class="token operator">=</span> spdlog<span class="token operator">::</span>synchronous_factory<span class="token operator">></span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>logger<span class="token operator">></span> <span class="token function">rotating_logger_mt</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>spdlog几乎为所有类型的sink都提供了如上类似的logger创建函数。从函数名可以看出这类函数把sink的概念给隐藏了，普通用户只需要知道创建出来的logger能够把日志写到指定地方就行了，根本不需要知道sink这类东西的存在。我们以stdout_logger创建函数为例，看一下具体实现。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> stdout_sink_mt <span class="token operator">=</span> stdout_sink<span class="token operator">&lt;</span>details<span class="token operator">::</span>console_mutex<span class="token operator">></span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 有锁对应多线程版本</span><span class="token keyword">using</span> stdout_sink_st <span class="token operator">=</span> stdout_sink<span class="token operator">&lt;</span>details<span class="token operator">::</span>console_nullmutex<span class="token operator">></span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 无锁对应单线程版本</span><span class="token comment" spellcheck="true">// 模板参数Factory都默认为spdlog::synchronous_factory</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Factory<span class="token operator">></span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>logger<span class="token operator">></span> <span class="token function">stdout_logger_mt</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>logger_name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Factory<span class="token operator">::</span>create<span class="token operator">&lt;</span>sinks<span class="token operator">::</span>stdout_sink_mt<span class="token operator">></span><span class="token punctuation">(</span>logger_name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Factory<span class="token operator">></span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>logger<span class="token operator">></span> <span class="token function">stdout_logger_st</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>logger_name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Factory<span class="token operator">::</span>create<span class="token operator">&lt;</span>sinks<span class="token operator">::</span>stdout_sink_st<span class="token operator">></span><span class="token punctuation">(</span>logger_name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">struct</span> synchronous_factory <span class="token punctuation">{</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Sink<span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> SinkArgs<span class="token operator">></span>    <span class="token keyword">static</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>spdlog<span class="token operator">::</span>logger<span class="token operator">></span> <span class="token function">create</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string logger_name<span class="token punctuation">,</span> SinkArgs <span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">auto</span> sink <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>Sink<span class="token operator">></span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>SinkArgs<span class="token operator">></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">auto</span> new_logger <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>spdlog<span class="token operator">::</span>logger<span class="token operator">></span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>logger_name<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>sink<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        details<span class="token operator">::</span>registry<span class="token operator">::</span><span class="token function">instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">initialize_logger</span><span class="token punctuation">(</span>new_logger<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> new_logger<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不论是<code>stdout_logger_mt</code>还是<code>stdout_logger_st</code>里面都直接调用了<code>Factory::create</code>。模板参数Factory都默认为<code>spdlog::synchronous_factory</code>，除此之外还可以是<code>async_factory</code>。</p><p>先看<code>synchronous_factory::create</code>的实现，这个函数里做的事情就是先把logger构造出来后，再传进registry的initialize_logger方法中，<code>initialize_logger(new_logger)</code>有做了一些初始化，例如将该logger的formatter（存在logger中的）设置为默认formatter（存在registry中的），因为用户大体上会希望新创建的logger能够在日志格式上在已有或者全局的基础上保持统一。同时<code>initialize_logger(new_logger)</code>也将该logger的shared_ptr存到registry中，这样用户就可以通过registry管理该logger。<code>async_factory::create</code>做的事情基本相同，需要额外做些事情主要就是<code>async_logger</code>中所使用的线程池的创建。这里使用工厂方法的重点不在在于重建对象或者更好的组织代码，而是在创建logger之后将其注册进registry，registry需要注册logger，所以才提供Factory来在创建logger后完成注册。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;阅读源码是学习进阶必须越过的一步，同时也要学习其他人阅读源码的方式和经验，本文内容不全是个人做的&lt;del&gt;比如图就是从网上偷来的&lt;/del&gt;
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="源码阅读" scheme="https://JoyTsing.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>CMake实战</title>
    <link href="https://joytsing.github.io/posts/64584/"/>
    <id>https://joytsing.github.io/posts/64584/</id>
    <published>2024-03-21T13:52:37.000Z</published>
    <updated>2024-03-21T14:34:54.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文是知乎上HAN Bing写的CMake实战指南，加上一部分个人的理解和实践。</p><h2 id="使用find-package引入外部依赖包"><a href="#使用find-package引入外部依赖包" class="headerlink" title="使用find_package引入外部依赖包"></a>使用find_package引入外部依赖包</h2><h3 id="通过Cmake内置模块引入依赖包"><a href="#通过Cmake内置模块引入依赖包" class="headerlink" title="通过Cmake内置模块引入依赖包"></a>通过Cmake内置模块引入依赖包</h3><p>为了方便我们在项目中引入外部依赖包，cmake官方为我们预定义了许多寻找依赖包的Module，他们存储在path_to_your_cmake/share/cmake-&lt;version&gt;/Modules目录下。每个以Find.cmake命名的文件都可以帮我们找到一个包。我们也可以在官方文档中查看到哪些库官方已经为我们定义好了，我们可以直接使用find_package函数进行引用<a href="https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html">官方文档：Find Modules</a>。</p><p>以curl库为例，假设我们项目需要引入这个库，从网站中请求网页到本地，我们看到官方已经定义好了FindCURL.cmake。所以我们在CMakeLists.txt中可以直接用find_pakcage进行引用。</p><pre class="line-numbers language-cmake"><code class="language-cmake">find_package(CURL)add_executable(curltest curltest.cc)if(CURL_FOUND)    target_include_directories(clib PRIVATE ${CURL_INCLUDE_DIR})    target_link_libraries(curltest ${CURL_LIBRARY})else(CURL_FOUND)    message(FATAL_ERROR ”CURL library not found”)endif(CURL_FOUND)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于系统预定义的 <code>Find&lt;LibaryName&gt;.cmake</code> 模块，使用方法一般如上例所示。</p><p>每一个模块都会定义以下几个变量</p><ul><li><code>&lt;LibaryName&gt;_FOUND</code></li><li><code>&lt;LibaryName&gt;_INCLUDE_DIR or &lt;LibaryName&gt;_INCLUDES</code></li><li><code>&lt;LibaryName&gt;_LIBRARY or &lt;LibaryName&gt;_LIBRARIES</code></li></ul><p>你可以通过<code>&lt;LibaryName&gt;_FOUND</code> 来判断模块是否被找到，如果没有找到，按照工程的需要关闭 某些特性、给出提醒或者中止编译，上面的例子就是报出致命错误并终止构建。 如果<code>&lt;LibaryName&gt;_FOUND</code> 为真，则将<code>&lt;LibaryName&gt;_INCLUDE_DIR</code> 加入 INCLUDE_DIRECTORIES，</p><h3 id="通过find-package引入非官方的库（该方式只对支持cmake编译安装的库有效）"><a href="#通过find-package引入非官方的库（该方式只对支持cmake编译安装的库有效）" class="headerlink" title="通过find_package引入非官方的库（该方式只对支持cmake编译安装的库有效）"></a>通过find_package引入非官方的库（该方式只对支持cmake编译安装的库有效）</h3><p>假设此时我们需要引入glog库来进行日志的记录，我们在Module目录下并没有找到 FindGlog.cmake。所以我们需要自行安装glog库，再进行引用。</p><p>安装</p><pre class="line-numbers language-sh"><code class="language-sh"># clone该项目git clone https://github.com/google/glog.git # 切换到需要的版本 cd gloggit checkout v0.40  # 根据官网的指南进行安装cmake -H. -Bbuild -G "Unix Makefiles"cmake --build buildcmake --build build --target install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时我们便可以通过与引入curl库一样的方式引入glog库了</p><pre class="line-numbers language-cmake"><code class="language-cmake">find_package(glog)add_executable(glogtest glogtest.cc)if(GLOG_FOUND)    # 由于glog在连接时将头文件直接链接到了库里面，所以这里不用显示调用target_include_directories    target_link_libraries(glogtest glog::glog)else(GLOG_FOUND)    message(FATAL_ERROR ”glog library not found”)endif(GLOG_FOUND)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Module模式与Config模式"><a href="#Module模式与Config模式" class="headerlink" title="Module模式与Config模式"></a>Module模式与Config模式</h3><p>通过上文我们了解了通过Cmake引入依赖库的基本用法。知其然也要知其所以然，find_package对我们来说是一个黑盒子，那么它是具体通过什么方式来查找到我们依赖的库文件的路径的呢。到这里我们就不得不聊到find_package的两种模式，一种是Module模式，也就是我们引入curl库的方式。另一种叫做Config模式，也就是引入glog库的模式。下面我们来详细介绍着两种方式的运行机制。</p><p>在Module模式中，cmake需要找到一个叫做<code>Find&lt;LibraryName&gt;.cmake</code>的文件。这个文件负责找到库所在的路径，为我们的项目引入头文件路径和库文件路径。cmake搜索这个文件的路径有两个，一个是上文提到的cmake安装目录下的<code>share/cmake-&lt;version&gt;/Modules</code>目录，另一个使我们指定的<code>CMAKE_MODULE_PATH</code>的所在目录。</p><p>如果Module模式搜索失败，没有找到对应的<code>Find&lt;LibraryName&gt;.cmake</code>文件，则转入Config模式进行搜索。它主要通过<code>&lt;LibraryName&gt;Config.cmake</code> or <code>&lt;lower-case-package-name&gt;-config.cmake</code>这两个文件来引入我们需要的库。以我们刚刚安装的glog库为例，在我们安装之后，它在<code>/usr/local/lib/cmake/glog/</code>目录下生成了<code>glog-config.cmake</code>文件，而<code>/usr/local/lib/cmake/&lt;LibraryName&gt;/</code>正是find_package函数的搜索路径之一。（find_package的搜索路径是一系列的集合，而且在linux，windows，mac上都会有所区别，需要的可以参考官方文档<a href="https://cmake.org/cmake/help/latest/command/find_package.html">find_package</a>）</p><p>由以上的例子可以看到，对于原生支持Cmake编译和安装的库通常会安装Config模式的配置文件到对应目录，这个配置文件直接配置了头文件库文件的路径以及各种cmake变量供find_package使用。而对于非由cmake编译的项目，我们通常会编写一个<code>Find&lt;LibraryName&gt;.cmake</code>，通过脚本来获取头文件、库文件等信息。通常，原生支持cmake的项目库安装时会拷贝一份XXXConfig.cmake到系统目录中，因此在没有显式指定搜索路径时也可以顺利找到。</p><h3 id="编写自己的Find-lt-LibraryName-gt-cmake模块"><a href="#编写自己的Find-lt-LibraryName-gt-cmake模块" class="headerlink" title="编写自己的Find&lt;LibraryName&gt;.cmake模块"></a>编写自己的<code>Find&lt;LibraryName&gt;.cmake</code>模块</h3><p>假设我们编写了一个新的函数库，我们希望别的项目可以通过find_package对它进行引用我们应该怎么办呢。</p><p>我们在当前目录下新建一个<code>ModuleMode</code>的文件夹，在里面我们编写一个计算两个整数之和的一个简单的函数库。库函数以手工编写Makefile的方式进行安装，库文件安装在/usr/lib目录下，头文件放在/usr/include目录下。其中的Makefile文件如下：</p><pre class="line-numbers language-Makefile"><code class="language-Makefile"># 1、准备工作，编译方式、目标文件名、依赖库路径的定义。CC = g++CFLAGS  := -Wall -O3 -std=c++11 OBJS = libadd.o #.o文件与.cpp文件同名LIB = libadd.so # 目标文件名INCLUDE = ./ # 头文件目录HEADER = libadd.h # 头文件all : $(LIB)# 2. 生成.o文件 $(OBJS) : libadd.cc    $(CC) $(CFLAGS) -I ./ -fpic -c $< -o $@# 3. 生成动态库文件$(LIB) : $(OBJS)    rm -f $@    g++ $(OBJS) -shared -o $@     rm -f $(OBJS)# 4. 删除中间过程生成的文件 clean:    rm -f $(OBJS) $(TARGET) $(LIB)# 5.安装文件install:    cp $(LIB) /usr/lib    cp $(HEADER) /usr/include<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译安装</p><pre class="line-numbers language-sh"><code class="language-sh">makesudo make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>接下来我们回到我们的Cmake项目中来，在<code>cmake</code>文件夹下新建一个FindAdd.cmake的文件。我们的目标是找到库的头文件所在目录和共享库文件的所在位置。</p><pre class="line-numbers language-cmake"><code class="language-cmake"># 在指定目录下寻找头文件和动态库文件的位置，可以指定多个目标路径find_path(ADD_INCLUDE_DIR libadd.h /usr/include/ /usr/local/include ${CMAKE_SOURCE_DIR}/ModuleMode)find_library(ADD_LIBRARY NAMES add PATHS /usr/lib/add /usr/local/lib/add ${CMAKE_SOURCE_DIR}/ModuleMode)if (ADD_INCLUDE_DIR AND ADD_LIBRARY)    set(ADD_FOUND TRUE)endif (ADD_INCLUDE_DIR AND ADD_LIBRARY)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这时我们便可以像引用curl一样引入我们自定义的库了。</p><p>在CMakeLists.txt中添加</p><pre class="line-numbers language-cmake"><code class="language-cmake"># 将项目目录下的cmake文件夹加入到CMAKE_MODULE_PATH中，让find_pakcage能够找到我们自定义的函数库set(CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/cmake;${CMAKE_MODULE_PATH}")add_executable(addtest addtest.cc)find_package(ADD)if(ADD_FOUND)    target_include_directories(addtest PRIVATE ${ADD_INCLUDE_DIR})    target_link_libraries(addtest ${ADD_LIBRARY})else(ADD_FOUND)    message(FATAL_ERROR "ADD library not found")endif(ADD_FOUND)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="引入外部项目"><a href="#引入外部项目" class="headerlink" title="引入外部项目"></a>引入外部项目</h2><p>本节主要介绍如何引入外部项目源码作为自己项目的Library，与FindPackage引入头文件编译好的库不同的是，本节介绍的方法直接将第三方库源码引入到项目中，编译自己的项目时也会连同第三方库的源码一同编译。特别是当我们使用git等工具引入代码时，我们可以很方便地控制第三方代码的版本，防止本地安装的库文件版本与项目存在冲突。</p><h3 id="通过Submodle的方式引入"><a href="#通过Submodle的方式引入" class="headerlink" title="通过Submodle的方式引入"></a>通过Submodle的方式引入</h3><p>克隆spdlog作为项目的子项目</p><pre class="line-numbers language-sh"><code class="language-sh">git submodule add https://github.com/gabime/spdlog.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>本项目已经添加了submodule，所以在项目根目录执行以下命令初始化</p><pre class="line-numbers language-sh"><code class="language-sh">git submodule initgit submodule update<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>切换到我们需要的版本</p><pre class="line-numbers language-sh"><code class="language-sh">git checkout v1.4.2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们已经clone好了，现在只需要将spdlog作为subdirectory加入CMakeLists.txt当中就行了</p><pre class="line-numbers language-cmake"><code class="language-cmake">project(ImportExternalProject)cmake_minimum_required(VERSION 3.5)add_definitions(-std=c++11)  # 指定采用c++11进行编译（spdlog需要c++11）add_subdirectory(spdlog)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用FetchContent-CMake-3-11"><a href="#使用FetchContent-CMake-3-11" class="headerlink" title="使用FetchContent (CMake 3.11+)"></a>使用FetchContent (CMake 3.11+)</h3><p>使用FetchContent的步骤总结起来就是:</p><ul><li>使用FetchContent_Declare(MyName) 获取项目。可以是一个URL也可以是一个Git仓库。</li><li>使用FetchContent_GetProperties(MyName) 获取我们需要的变量MyName_*。</li><li>使用add_subdirectory(${MyName_SOURCE_DIR} ${MyName_BINARY_DIR})引入项目。</li></ul><p>在cmake3.14版本，官方又为我们提供了更方便的FetchContent_MakeAvailable方法，将步骤2，3集成在了一起。为了兼容3.11版本，我们可以把它封装成一个宏，这样我们就可以统一使用FetchContent_MakeAvailable方法了。</p><pre class="line-numbers language-cmake"><code class="language-cmake"># Campatible with cmake 3.11 and above.macro(FetchContent_MakeAvailable NAME)FetchContent_GetProperties(${NAME})if(NOT ${NAME}_POPULATED)    FetchContent_Populate(${NAME})    add_subdirectory(${${NAME}_SOURCE_DIR} ${${NAME}_BINARY_DIR})endif()endmacro()macro(FetchContent_MakeAvailable NAME)    FetchContent_GetProperties(${NAME})    if(NOT ${NAME}_POPULATED)        FetchContent_Populate(${NAME})        add_subdirectory(${${NAME}_SOURCE_DIR} ${${NAME}_BINARY_DIR})    endif()endmacro()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而后的第三方库cmake目录可以这么写：</p><pre class="line-numbers language-cmake"><code class="language-cmake"># 添加第三方依赖包include(FetchContent)# FetchContent_MakeAvailable was not added until CMake 3.14if(${CMAKE_VERSION} VERSION_LESS 3.14)    include(add_FetchContent_MakeAvailable.cmake)endif()set(SPDLOG_GIT_TAG  v1.4.1)  # 指定版本set(SPDLOG_GIT_URL  https://github.com/gabime/spdlog.git)  # 指定git仓库地址FetchContent_Declare(  spdlog  GIT_REPOSITORY    ${SPDLOG_GIT_URL}  GIT_TAG           ${SPDLOG_GIT_TAG})FetchContent_MakeAvailable(spdlog)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在CMakeLists.txt中，包含对应的第三方cmake，便可将spdlog作为library来使用了</p><pre class="line-numbers language-cmake"><code class="language-cmake">project(ImportExternalProject)cmake_minimum_required(VERSION 3.14)add_definitions(-std=c++11)  # 指定采用c++11进行编译（spdlog需要c++11）add_executable(test_spdlog testspdlog.cc)set(CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/cmake;${CMAKE_MODULE_PATH}")include(spdlog2)target_link_libraries(test_spdlog PRIVATE spdlog)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>本节主要介绍如何将项目生成的库文件、头文件、可执行文件或相关文件等安装到指定位置（系统目录，或发行包目录）。在cmake中，这主要是通过<code>install</code>方法在CMakeLists.txt中配置，<code>make install</code>命令安装相关文件来实现的。</p><h3 id="编写一个简单的库"><a href="#编写一个简单的库" class="headerlink" title="编写一个简单的库"></a>编写一个简单的库</h3><p>编写一个计算整数和浮点数之和的库函数mymath</p><p>mymath.h</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">ifndef</span> MYMATH_H</span><span class="token macro property">#<span class="token directive keyword">define</span> MYMATH_H</span><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">double</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>mymath.cpp</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"mymath.h"</span></span><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">double</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">double</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可执行程序mymathApp.cpp</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"mymath.h"</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">double</span> a <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1.1</span><span class="token punctuation">,</span> <span class="token number">1.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"1.1加1.1等于"</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"1加1等于"</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="编写CMakeLists"><a href="#编写CMakeLists" class="headerlink" title="编写CMakeLists"></a>编写CMakeLists</h3><p>在CMakeLists中添加配置</p><pre class="line-numbers language-cmake"><code class="language-cmake">cmake_minimum_required(VERSION 3.0)project(Installation VERSION 1.0)# 如果想生成静态库，使用下面的语句# add_library(mymath mymath.cc)# target_include_directories(mymath PUBLIC ${CMAKE_SOURCE_DIR}/include)# 如果想生成动态库，使用下面的语句add_library(mymath SHARED mymath.cc)target_include_directories(mymath PRIVATE  ${CMAKE_SOURCE_DIR}/include)set_target_properties(mymath PROPERTIES PUBLIC_HEADER ${CMAKE_SOURCE_DIR}/include/mymath.h)# 生成可执行文件add_executable(mymathapp mymathApp.cc)target_link_libraries(mymathapp mymath)target_include_directories(mymathapp PRIVATE ${CMAKE_SOURCE_DIR}/include)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来我们为生成的target配置安装目录。<code>install</code>方法的基础用法如下</p><pre class="line-numbers language-cmake"><code class="language-cmake">install(TARGETS MyLib        EXPORT MyLibTargets         LIBRARY DESTINATION lib  # 动态库安装路径        ARCHIVE DESTINATION lib  # 静态库安装路径        RUNTIME DESTINATION bin  # 可执行文件安装路径        PUBLIC_HEADER DESTINATION include  # 头文件安装路径        )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>LIBRARY, ARCHIVE, RUNTIME, PUBLIC_HEADER是可选的，可以根据需要进行选择。 DESTINATION后面的路径可以自行制定，根目录默认为<code>CMAKE_INSTALL_PREFIX</code>,可以试用<code>set</code>方法进行指定，如果使用默认值的话，Unix系统的默认值为 <code>/usr/local</code>, Windows的默认值为 <code>c:/Program Files/${PROJECT_NAME}</code>。比如字linux系统下若LIBRARY的安装路径指定为<code>lib</code>,即为<code>/usr/local/lib</code>。所以要安装<code>mymath mymathapp</code>我们可以这样写</p><pre class="line-numbers language-cmake"><code class="language-cmake"># 将库文件，可执行文件，头文件安装到指定目录install(TARGETS mymath mymathapp        EXPORT MyMathTargets        LIBRARY DESTINATION lib        ARCHIVE DESTINATION lib        RUNTIME DESTINATION bin        PUBLIC_HEADER DESTINATION include        )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>他人如果使用我们编写的函数库，安装完成后，希望可以通过<code>find_package</code>方法进行引用，这时我们需要怎么做呢。</p><p>首先我们需要生成一个<code>MyMathConfigVersion.cmake</code>的文件来声明版本信息</p><pre class="line-numbers language-cmake"><code class="language-cmake"># 写入库的版本信息include(CMakePackageConfigHelpers)write_basic_package_version_file(        MyMathConfigVersion.cmake        VERSION ${PACKAGE_VERSION}        COMPATIBILITY AnyNewerVersion  # 表示该函数库向下兼容        )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中<code>PACKAGE_VERSION</code>便是我们在<code>CMakeLists.txt</code>开头<code>project(Installation VERSION 1.0)</code>中声明的版本号</p><p>第二步我们将前面<code>EXPORT MyMathTargets</code>的信息写入到<code>MyLibTargets.cmake</code>文件中, 该文件存放目录为<code>${CMAKE_INSTALL_PREFIX}/lib/cmake/MyMath</code></p><pre class="line-numbers language-cmake"><code class="language-cmake">install(EXPORT MyMathTargets        FILE MyLibTargets.cmake        NAMESPACE MyMath::        DESTINATION lib/cmake/MyLib        )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后我们在源代码目录新建一个<code>MyMathConfig.cmake.in</code>文件,用于获取配置过程中的变量，并寻找项目依赖包。如果不一来外部项目的话，可以直接include <code>MyMathTargets.cmake</code>文件</p><pre class="line-numbers language-cmake"><code class="language-cmake">include(CMakeFindDependencyMacro)# 如果想要获取Config阶段的变量，可以使用这个# set(my-config-var @my-config-var@)# 如果你的项目需要依赖其他的库，可以使用下面语句，用法与find_package相同# find_dependency(MYDEP REQUIRED)# Any extra setup# Add the targets fileinclude("${CMAKE_CURRENT_LIST_DIR}/MyMathTargets.cmake")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后在CMakeLists.txt文件中，配置生成<code>MyMathTargets.cmake</code>文件，并一同安装到<code>${CMAKE_INSTALL_PREFIX}/lib/cmake/MyMath</code>目录中。</p><pre class="line-numbers language-cmake"><code class="language-cmake">configure_file(MyMathConfig.cmake.in MyMathConfig.cmake @ONLY)install(FILES "${CMAKE_CURRENT_BINARY_DIR}/MyMathConfig.cmake"                "${CMAKE_CURRENT_BINARY_DIR}/MyMathConfigVersion.cmake"        DESTINATION lib/cmake/MyMath        )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后我们在其他项目中，就可以使用</p><pre class="line-numbers language-cmake"><code class="language-cmake">find_package(MyMath 1.0)target_linked_library(otherapp MyMath::mymath)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>来引用我们的函数库了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;本文是知乎上HAN Bing写的CMake实战指南，加上一部分个人的理解和实践。&lt;/p&gt;
&lt;h2 id=&quot;使用find-package引入外
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="CMake" scheme="https://JoyTsing.github.io/tags/CMake/"/>
    
      <category term="Tool" scheme="https://JoyTsing.github.io/tags/Tool/"/>
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>MySQL技术内幕-InnoDB存储引擎</title>
    <link href="https://joytsing.github.io/posts/9398/"/>
    <id>https://joytsing.github.io/posts/9398/</id>
    <published>2024-03-20T15:46:10.000Z</published>
    <updated>2024-03-20T16:22:52.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这是一份读书笔记，之前一直写在本地没有上传到博客上，同步一下也方便自己。</p><h2 id="第1章-MYSQL体系结构和存储引擎"><a href="#第1章-MYSQL体系结构和存储引擎" class="headerlink" title="第1章 MYSQL体系结构和存储引擎"></a>第1章 MYSQL体系结构和存储引擎</h2><p><strong>数据库</strong>和<strong>实例</strong>：</p><blockquote><p><code>数据库</code>：物理操作系统文件或者其他形式文件类型的集合。在Mysql中，<strong>数据库文件可以是frm、ibd、MYD等形式的文件。</strong><br><code>实例</code>：<strong>Mysql数据库由后台线程以及一个共享内存区组成</strong>，而共享内存区可以被运行的后台线程共享。（数据库实例才是真正用于操作数据库文件的角色）<br>从概念上来说，数据库是文件的集合；数据库实例则是程序，是位于用户与操作系统之间的一层数据管理软件，所有对数据库的操作都要通过这层抽象层进行</p></blockquote><p>MySQL数据库实例在系统上的表现就是一个进程，<strong>用户对数据库数据的任何操作</strong>，包括数据库定义、数据查询、数据维护、数据库运行控制等<strong>都是在数据库实例下进行的</strong>，<strong>应用程序只有通过数据库实例才能和数据库打交道。</strong></p><p>MySQL具体的体系结构可以分为下面几种：</p><ol><li><strong>连接池</strong>：管理、缓冲用户的连接，线程处理等需要缓存的需求。</li><li><strong>管理服务和工具组件</strong>：系统管理和控制工具，例如备份恢复、Mysql复制、集群等 。</li><li><strong>sql接口</strong>：接受用户的SQL命令，并且返回用户需要查询的结果。</li><li><strong>查询解析器</strong>：SQL命令传递到解析器的时候会被解析器验证和解析。(权限、语法结构)</li><li><strong>查询优化器</strong>：SQL语句在查询之前会使用查询优化器对查询进行优化。</li><li><strong>缓存</strong>：如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。</li><li><strong>插入式存储引擎</strong>：存储引擎说白了就是如何管理操作数据（存储数据、如何更新、查询数据等）的一种方法。因为在关系数据库中数据的存储是以表的形式存储的，所以存储引擎也可以称为表类型。（即存储和操作此表的类型）</li><li><strong>物理文件</strong></li></ol><p>MySQL区别于其他数据的<strong>最重要的特点就是其插件式的表存储引擎</strong>，这个表存储引擎是基于表，而不是数据库，即进行存储操作等都是通过record等来进行操作。在你实际使用的过程中，存储引擎是透明的。</p><h3 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a>InnoDB引擎</h3><p>InnoDB是第一个完整支持ACID事务的Mysql存储引擎（DBD是第一个支持事务的InnoDB存储引擎，但是注意前面还带了个ACID！别搞混了）</p><ol><li><strong>InnoDB存储引擎支持事务</strong>，其特点是<strong>行锁设计、支持外键</strong>、支持非锁定锁（即默认读取操作不会产生锁）。并且Mysql5.5.8版本起，默认的存储引擎就是InnoDB了。</li><li>InnoDB通过<strong>使用多版本并发控制MVCC来获得高并发性，并且实现了SQL标准的4种隔离级别</strong>，默认是Repeatable级别（重复读）。</li><li><strong>使用一种被称为next-key的连接锁策略来避免幻读的产生</strong>。</li><li>InnoDB还<strong>提供了插入缓冲、二次写、自定义哈希索引、预读等4大特性</strong>。</li><li>InnoDB引擎采用了聚集的方式，因此每张表的存储都是按照主键的顺序进行存放。</li><li>如果没有显式的在表中定义主键，那么InnoDB会为每一行生成一个6字节大小的RowId，并以此为主键。（换句话说，无论咋样，一张表必有主键）</li></ol><p>拓展：</p><blockquote><p><code>那么Mysql的事务是怎么实现的？</code><br>Mysql的事务的实现即为ACID的实现：<br><strong>第一：事务的原子性是通过undo log来实现，也就是所谓的回滚操作。</strong> undo log记录了数据被修改之前的信息以及新增、删除的信息。undo log就是通过生成操作相反的sql语句来实现，举几个栗子🌰：<br>   1.若undo log中有新增记录，则生成删除该记录的sql。<br>   2.若undo log中有删除记录，则生成生成该记录的sql。<br>   3.若undo log中有修改记录，则生成修改至原先语句的sql。<br>因此，所谓的回滚操作就是根据undo log做一个逆向操作。<br><strong>第二：事务的持久性</strong>（这里就说几个重要的点，因为说白了，持久性跟存储有关）：<br>   1.<strong>redolog在提交commit前会写一次数据</strong>，顺序存储。<br>   2.InnoDB的二次写以及自带的buffer pool。<br><strong>第三：事务的隔离性则通过4种隔离级别来实现。</strong><br><strong>第四：事务的一致性：其实现依赖于以上3个特性的实现、即回滚、恢复、隔离机制。</strong></p></blockquote><h4 id="（1）存储策略和存储大小"><a href="#（1）存储策略和存储大小" class="headerlink" title="（1）存储策略和存储大小"></a>（1）存储策略和存储大小</h4><p>InnoDB存储数据的策略有两种：</p><ol><li>共享表空间存储方式。</li></ol><blockquote><p><strong>InnoDB的所有数据保存在一个单独的表空间里面</strong>，而这个表空间可以由很多歌文件组成，一个表可以跨多个文件存在，所以其大小限制不再是文件大小的限制，而是其自身的限制，<strong>官方指出InnoDB表空间的最大限制是64TB。</strong></p></blockquote><ol start="2"><li>独享表空间存储方式。</li></ol><blockquote><p>每个表的数据以一个单独的文件来存放，此时的单表限制，就变成文件系统的大小限制了。</p></blockquote><h4 id="（2）MVCC和隔离级别"><a href="#（2）MVCC和隔离级别" class="headerlink" title="（2）MVCC和隔离级别"></a>（2）MVCC和隔离级别</h4><p>上文提到了InnoDB通过使用多版本并发控制MVCC来获得高并发性，并且实现了SQL标准的4种隔离级别，那接下来就对这两点来进行阐述。</p><p>首先MVCC，全名多版本并发控制（Multi-Version Concurrency Control），是Mysql的InnoDB存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。</p><p><strong>基本思想：</strong> <strong>利用多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系。</strong>（在MVCC中事务的修改操作，delete、insert、update这3个操作会为数据行新增一个版本快照）。</p><p>接下来先把4个事务隔离级别的基本概念说清楚（等级从小到大依次排序）：</p><blockquote><ol><li>Read uncommitted（读未提交）：避免了更新丢失，却可能出现脏读。（<strong>表现：读写并行</strong>）</li><li>Read committed（读提交）：避免了脏读，但是可能出现不可重复度。（<strong>表现：MVCC、读写分离</strong>）</li><li>Repeatable read（重复读）：避免了不可重复读和脏读，但是有可能出现幻读。（默认的隔离级别，<strong>表现：读写锁、MVCC</strong>）</li><li>Serializable（序列化，也叫串行化）：事务只能一个接着一个的执行，不能并发执行，可以解决幻读问题。</li></ol><p>概念解释：<br><code>脏读</code></p><ol><li>A进行了一条数据操作，但是没有提交事务，如果此时B进行这条数据的查询，是可以查到A的数据操作结果的。  </li><li>后来A还没有提交事务，反而不提交了或者进行了事务回滚，那么B查询到的数据就是脏数据。<br><code>不可重复读（侧重于修改）</code><br>事务A多次读取到同一个数据，而B在A多次读取的过程中，对数据进行了修改，导致事务A多次多去同一个数据的时候，结果不一致。<br><code>幻读（侧重于增加或者删除）</code><br>再一次事务里面，多次查询之后，结果集的个数不一致的情况叫做幻读。而多或者少的那一行数据叫做幻行。</li></ol></blockquote><h4 id="（3）Next-Key-Locks"><a href="#（3）Next-Key-Locks" class="headerlink" title="（3）Next-Key Locks"></a>（3）Next-Key Locks</h4><p>MVCC不能解决幻读的问题，而Next-Key Locks就是为了解决这个问题而存在的。<strong>在可重复读级别下，使用MVCC+Next-Key Locks可以解决幻读问题。</strong></p><p><strong>一：Record Locks</strong>：<br><strong>锁定一个记录上的索引，而不是记录本身</strong>，如果表没有设置索引，由于InnoDB会自动加一个隐藏的主键，因此Record Locks依然可以使用。<br>记录锁其实很好理解，对表中的记录加锁，叫做记录锁，简称行锁。比如</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token punctuation">`</span>test<span class="token punctuation">`</span> <span class="token keyword">WHERE</span> <span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它会在 id=1 的记录上加上记录锁，以阻止其他事务插入，更新，删除 id=1 这一行。</p><p>需要注意的是：</p><ul><li><strong>id 列必须为唯一索引列或主键列</strong>，否则上述语句加的锁就会变成临键锁(有关临键锁下面会讲)。</li><li><strong>同时查询语句必须为精准匹配（=）</strong>，不能为 &gt;、&lt;、like等，否则也会退化成临键锁。</li></ul><p>其他实现比如，在通过 <strong>主键索引</strong> 与 <strong>唯一索引</strong> 对数据行进行 UPDATE 操作时，也会对该行数据加记录锁：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- id 列为主键列或唯一索引列 </span><span class="token keyword">UPDATE</span> <span class="token keyword">SET</span> age <span class="token operator">=</span> <span class="token number">50</span> <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>记录锁是锁住记录，锁住索引记录，而不是真正的数据记录</strong>.如果要锁的列没有索引，则会进行全表记录加锁，同时<code>记录锁也是排它(X)锁</code>,所以会阻塞其他事务对其<strong>插入、更新、删除</strong>。</p><p><strong>二：Gap Locks：</strong><br>锁定索引之间的间隙，但是不包含索引本身。间隙锁是Innodb在RR(可重复读) 隔离级别下为了解决<code>幻读问题</code>时引入的锁机制。<strong>间隙锁是innodb中行锁的一种</strong>。使用间隙锁锁住的是一个<strong>区间</strong>，而<strong>不仅仅是这个区间中的每一条数据</strong>。</p><p>举例来说，假如emp表中只有101条记录，其empid的值分别是1,2,…,100,101，下面的SQL：</p><pre class="line-numbers language-sql"><code class="language-sql">  <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> emp <span class="token keyword">WHERE</span> empid <span class="token operator">></span> <span class="token number">100</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当我们用条件检索数据，并请求共享或排他锁时，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。这个时候如果你插入empid等于102的数据的，如果那边事物还没有提交，那你就会处于等待状态，无法插入数据。</p><p><strong>三：临键锁</strong>：</p><p><strong>Next-key锁是记录锁和间隙锁的组合，它指的是加在某条记录以及这条记录前面间隙上的锁</strong>。即不仅锁定一个记录上的索引，也锁定索引之间的缝隙。他锁定一个前开后闭的区间，例如一个索引包含以下值：10，11，13，20，那么就会锁定这么几个区间：</p><blockquote><p>(-∞，10]，(10,11]，(11,13]，(13,20]，(20,+∞)</p></blockquote><p>也可以理解为一种特殊的<strong>间隙锁</strong>。通过<strong>临建锁</strong>可以解决<code>幻读</code>的问题。 每个数据行上的<strong>非唯一索引列</strong>上都会存在一把<strong>临键锁</strong>，当某个事务持有该数据行的<strong>临键锁</strong>时，会锁住一段<strong>左开右闭区间</strong>的数据。</p><p>需要强调的一点是，InnoDB 中<strong>行级锁</strong>是基于索引实现的，<strong>临键锁</strong>只与<strong>非唯一索引列</strong>有关，在<code>唯一索引列（包括主键列）上不存在临键锁</code>。</p><p><strong>四：总结：</strong></p><p>这里对 <strong>记录锁</strong>、<strong>间隙锁</strong>、<strong>临键锁</strong> 做一个总结</p><ul><li><strong>InnoDB</strong> 中的<strong>行锁</strong>的实现依赖于<strong>索引</strong>，一旦某个加锁操作没有使用到索引，那么该锁就会退化为<code>表锁</code>。</li><li><strong>记录锁</strong>存在于包括<strong>主键索引</strong>在内的<strong>唯一索引</strong>中，锁定单条索引记录。</li><li><strong>间隙锁</strong>存在于<strong>非唯一索引</strong>中，锁定<strong>开区间</strong>范围内的一段间隔，它是基于<strong>临键锁</strong>实现的。</li><li><strong>临键锁</strong>存在于<strong>非唯一索引</strong>中，该类型的每条记录的索引上都存在这种锁，它是一种特殊的<strong>间隙锁</strong>，锁定一段<strong>左开右闭</strong>的索引区间</li></ul><h4 id="（4）InnoDB的4大特性"><a href="#（4）InnoDB的4大特性" class="headerlink" title="（4）InnoDB的4大特性"></a>（4）InnoDB的4大特性</h4><ol><li><strong>插入缓冲</strong>（insert buffer）：对于非聚簇类索引的插入和更新操作，如果该索引页在缓存中，那么直接插入，先插入到缓冲区中，再以一定的频率和索引页合并。</li><li><strong>二次写</strong>（double write）：写数据前，将数据线写入一块独立的物理文件位置（ibdata）然后再写入数据页中。</li><li><strong>自定义哈希索引</strong>（ahi）：自定义哈希索引即将字典类型的索引通过哈希函数映射于一张表，让查询的时候更加迅速。</li><li><strong>预读</strong>（read ahead）：InnoDB在IO的优化上做出了预读机制，就是发起一个IO请求，异步地在缓冲池中预先回迁若干页面，预计把可能用到的数据页返回。</li></ol><h3 id="MyISAM引擎（了解）"><a href="#MyISAM引擎（了解）" class="headerlink" title="MyISAM引擎（了解）"></a>MyISAM引擎（了解）</h3><p>和InnoDB引擎相比，MyISAM不支持事务、表锁设计，但是<strong>支持全文索引</strong>。MyISAM存储引擎的<strong>另一个与众不同的地方是他的缓冲池只缓存索引文件而不缓存数据文件。</strong> 另外，还记得上文提到，InnoDB的最大存储限度有一个64TB，Mysql5以上的时候，<strong>如果用的是MyISAM引擎，那么支持256TB的单表数据。</strong> 并且使用MyISAM存储引擎表，MySQL只缓存索引文件，数据文件缓存则是交给操作系统。</p><h5 id="MyISAM和InnoDB的区别"><a href="#MyISAM和InnoDB的区别" class="headerlink" title="MyISAM和InnoDB的区别"></a>MyISAM和InnoDB的区别</h5><table><thead><tr><th>比较内容</th><th>MyISAM</th><th>InnoDB</th><th></th></tr></thead><tbody><tr><td>构成上的区别</td><td>每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。</td><td>基于磁盘的资源是InnoDB表空间数据文件和它的日志文件，InnoDB 表的大小只受限于操作系统文件的大小，一般为 2GB</td><td></td></tr><tr><td>是否支持事务</td><td>不支持</td><td>支持</td><td></td></tr><tr><td>支持的锁</td><td>行锁</td><td>表锁</td><td></td></tr><tr><td>是否有MVCC</td><td>不支持</td><td>支持</td><td></td></tr><tr><td>是否支持外键</td><td>不支持</td><td>支持</td><td></td></tr><tr><td>是否支持全文索引</td><td>支持</td><td>不支持</td><td></td></tr><tr><td>操作的速度</td><td>建议如果执行大量的select语句，使用MyISAM</td><td>如果数据执行大量的insert和update操作，出于性能考虑，使用InnoDB表</td><td></td></tr><tr><td>表的具体行数</td><td>MyISAM会保存好表中的行数，因此对于count操作很快</td><td>InnoDB则没有，需要扫描一遍全表计算</td><td></td></tr></tbody></table><p>一个极具迷惑性的提问：当表的数据量大于1000万时候MySQL的性能会急剧下降吗？</p><blockquote><p>MySQL是数据库，不是文件，随着数据行数增加性能必然会下降，但这些下降不是线性的，如果在对应业务情况下使用合适的存储引擎与配置，那么这些数据量是能承受住的。如在官方手册上所说的InnoDB 1TB数据。</p></blockquote><h2 id="第2章-InnoDB存储引擎"><a href="#第2章-InnoDB存储引擎" class="headerlink" title="第2章 InnoDB存储引擎"></a>第2章 InnoDB存储引擎</h2><h3 id="InnoDB体系架构"><a href="#InnoDB体系架构" class="headerlink" title="InnoDB体系架构"></a>InnoDB体系架构</h3><p>InnoDB内有多个内存块，这些内存块组成一个大的内存池，负责维护数据的写、访问以及日记的记录，这些内存块由多个后台线程负责处理，来适应不同的任务。</p><p>这些后台线程的任务主要用来：</p><p>（1）Master Thread</p><ul><li>负责将缓冲池的数据异步刷新到磁盘</li><li>保证数据一致性：包括脏页的刷新、合并插入缓冲池、undo页的回收<br>在后续的更新里，Innodb 1.2.x把刷新脏页从主线程里面分离到了PageCleanerTherad线程中</li></ul><p>Master Thread内部由多个循环loop组成，并且在多个循环状态之间切换。</p><ul><li>主循环（loop）</li><li>后台循环（background loop）</li><li>刷新循环（flush loop）</li><li>暂停循环（suspend loop）</li></ul><p>大部分操作在主循环中，分为每秒的操作和每十秒的操作，每秒的操作包括：</p><blockquote><p>1.日志缓冲刷新到磁盘，即使这个事务还没有提交。（总是）<br>2.合并插入缓冲。（可能）<br>3.最多刷新100个InnoDB的缓冲池中的脏页到磁盘。（可能）<br>4.如果当前没有用户活动，则切换到background loop后台循环。（可能）<br>——-background loop执行的操作：<br>——-1.删除无用的Undo页。（总是）<br>——-2.合并20个插入缓冲。（总是）<br>——-3.跳回到主循环。（总是）<br>——-4.不断刷新100个页直到符合条件。（可能）</p></blockquote><p>每十秒的操作包括：</p><blockquote><p>1.刷新100个脏页到磁盘。（可能）<br>2.合并最多5个插入缓冲（总是）<br>3.将日志缓冲刷新到磁盘。（总是）<br>4.删除无用的Undo页。（总是）<br>5.刷新100个或者10个脏页到磁盘。（总是）</p></blockquote><p>（2） IO Thread<br>InnoDB中使用了大量的<strong>AIO来处理写IO请求</strong>，以便提高数据库的性能，<strong>而IO Thread的工作就是负责这些IO请求的回调处理。</strong> 其中比较重要的几个线程为write IO Thread（默认4个）、read IO Thread（默认4个）、insert buffer IO Thread、log IO Thread</p><p>（3)）Purge Thread<br>事务被提交后，其所用的undolog可能不再需要，那么则需要一个线程去回收已经使用并分配的undo页。而做这份工作的线程就叫做Purge Thread。</p><p>（4）Page Cleaner Thread<br>Page Cleaner Thread的作用<strong>是将之前版本中脏页的刷新操作都放入到单独的线程中去完成。</strong> 其目的：减轻原Mster Thread的工作及对于用户查询线程的阻塞，进一步提高InnoDB的性能。</p><h3 id="Innodb内存"><a href="#Innodb内存" class="headerlink" title="Innodb内存"></a>Innodb内存</h3><h4 id="（1）缓冲池"><a href="#（1）缓冲池" class="headerlink" title="（1）缓冲池"></a>（1）缓冲池</h4><p><img src="/posts/9398/image-20231109162323130.png" alt></p><p><strong>InnoDB存储引擎是基于磁盘存储的，并且将其中的记录按照页的方式进行管理。</strong> 而基于磁盘的数据库系统，因为存储设备速率的差距，通常需要使用缓冲池技术来提高数据库的整体性能，从上图可以看到，缓冲池并不是简单的一个k-v map。</p><p>缓冲池作为内存中最大的一块，也包含了很多数据页类型：索引页、数据页、undo页、插入缓冲、自定义哈希索引、锁信息、数据字典信息等。同时InnoDB存储引擎还<strong>允许有多个缓冲池实例，</strong> 相当于自适应哈希索引中的多个哈希桶。</p><h4 id="（2）InnoDB的LRU算法"><a href="#（2）InnoDB的LRU算法" class="headerlink" title="（2）InnoDB的LRU算法"></a>（2）InnoDB的LRU算法</h4><p>InnoDB存储引擎则使用了<strong>一种经过优化的LRU算法</strong>来堆缓冲池进行管理，即在LRU的基础上增加了一个<code>midpoint</code>的位置，新读取到的页并不会直接放入到LRU列表的首部，而是放到LRU列表的<code>midpoint</code>位置。默认情况下，这个位置在LRU列表长度的5/8处。即新读取的页给放在LRU列表尾端3/8的位置，midpoint之后的为old列表，之前的为new列表，new列表为频繁访问的数据。</p><p>问题1：<strong>为什么不采用普通的LRU算法，直接将读取的页放入到LRU列表的首部呢？</strong></p><blockquote><p> 如果直接吧读取到的页放入到LRU列表的首部，那么某些SQL操作可能会使缓冲池中的页被刷新出，从而影响缓冲池的效率。</p></blockquote><p>问题2：<strong>所谓的会将缓冲池中的页刷新出的SQL某些操作是什么？为什么会影响呢？</strong></p><blockquote><p>1.如索引或者数据的扫描操作。<br>2.比如全表扫描，需要访问到表中的全部页，<strong>问题是缓冲池的大小是有限的，那么我这次全表扫描，如果全部放入到LRU列表的首部，那么非常可能会将比较重要的热点数据页从LRU列表中移出</strong>，当下一次需要读取热点数据的时候，又得去访问磁盘。<br>3.此外，InnoDB还引入一个时间参数<strong>innodb_old_blocks_time</strong>来保证：页读取到mid位置后需要等待多久会被加入到LRU列表的热端（new部分），以尽可能的让LRU列表中热点数据不被移出。</p></blockquote><p>InnoDB引擎在1.0.x版本就开始支持页的压缩功能了。原本页的大小是16K，现在可以压缩为1、2、4、8KB，而这些非16KB的页，通过unzip_LRU列表来管理。</p><p>unzip_LRU列表对不同压缩页大小的页进行分别管理，例如需要从缓冲池中申请页为4KB的大小，过程如下：</p><ol><li>检查4KB的unzip_LRU列表,检查是否有可用的空闲页。</li><li>如果有，直接使用。</li><li>如果没有，检查8KB的unzip_LRU列表。</li><li>如果能够得到空闲页，将页分成2个4KB页，存放到4KB的unzip_LRU列表。</li><li>如果不能得到空闲页，从LRU列表中申请一个16KB的页，将页分为1个8KB的页、2个4KB的页，分别存放到对应的unzip_LRU列表中。</li></ol><p><strong>在LRU列表中的页如果被修改了，那么这种页叫做脏页。</strong> 即缓冲池中的页he磁盘上的页的数据产生了不一致，而<strong>这个时候数据库会通过Checkpoint机制将脏页刷新到磁盘，而Flush列表中的页即为脏页列表。</strong></p><p><strong>注意：</strong></p><ul><li><strong>脏页既存在于LRU列表，也存在与Flush列表中。</strong></li><li><strong>LRU列表用来管理缓冲池中页的可用性，Flush列表用来管理将页刷新到磁盘，两者是独立的互相不影响的。</strong></li></ul><h4 id="（3）重做日志缓冲"><a href="#（3）重做日志缓冲" class="headerlink" title="（3）重做日志缓冲"></a>（3）重做日志缓冲</h4><p>InnoDB存储引擎的内存区域除了有缓冲池外，还有重做日志缓冲（redo log buffer）。<strong>InnoDB存储引擎首先将重做日志信息放到该缓冲区中，然后按照一定的频率将其刷新到重做日志文件中，默认重做日志缓冲的大小为8MB，参数由innodb_log_buffer_size控制</strong></p><p>缓冲刷新至文件的3种时机：</p><ul><li>Master Thread每秒将重做日志缓冲刷新到重做日志文件。</li><li>每个事务提交的时候会将重做日志缓冲刷新到重做日志文件。</li><li>当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件。</li></ul><h4 id="（4）额外内存池"><a href="#（4）额外内存池" class="headerlink" title="（4）额外内存池"></a>（4）额外内存池</h4><p>在InnoDB存储引擎中，<strong>堆内存的管理是通过一种称为内存堆的方式进行的</strong>。在对一些数据结构本身的内存进行分配的时候，<strong>需要从额外的内存池中进行申请，当该区域的内存不够的时候，才会从缓冲池进行申请。</strong></p><h3 id="Checkpoint"><a href="#Checkpoint" class="headerlink" title="Checkpoint"></a>Checkpoint</h3><p>为了避免数据库发生数据丢失，当前事务数据库系统普遍采用了一种策略叫做：<strong>Write Ahead Log策略。</strong> <strong>即事务提交的时候，先写重做日志，再修改页</strong>。而发生宕机而导致数据丢失的时候，就可以通过重做日志来完成数据的恢复。</p><p>Checkpoint技术的目的就是解决以下几个问题：</p><ol><li>缩短数据库的恢复时间。</li><li>缓冲池不够用，将脏页刷新到磁盘。</li><li>重做日志不可用时，刷新脏页。</li></ol><blockquote><p>重做日志出现不可用的原因？<br>回答：<br>因为当前事务数据库系统对重做日志的设计都是循环使用的，并不是让日志无限增大，重做日志可以被重用的部分是指这些日志已经不再需要了，那么这部分就可以被覆盖。但是万一覆盖之后，之前的部分又需要使用了，那么必须强制产生Checkpoint，将缓冲池中的页至少刷新到当前重做日志的位置。</p></blockquote><p>此外，当数据库发生宕机需要恢复的时候，不需要重做所有的日志，<strong>因为Checkpoint之前的页已经能保证刷新到磁盘中了，所以数据库只需要对之后的重做日志进行恢复即可</strong>，这样大大缩短了恢复的时间。并且，当缓冲池不够用的时候，根据LRU算法会把最近最少使用的页给移除，如果该页为脏页，那么需要强制执行Checkpoint，将脏页刷回磁盘。</p><p>InnoDB存储引擎内部有两种Checkpoint：</p><ul><li><p>Sharp Checkpoint：<strong>发生在数据库关闭时，将所有的脏页刷新到磁盘，默认工作方式。</strong> 通过参数<code>innodb_fast_shutdown=1</code>实现</p></li><li><p>Fuzzy Checkpoint：<strong>只刷新一部分脏页。</strong> 使用Fuzzy Checkpoint的情况：</p></li><li><p>Master Thread Checkpoint</p></li></ul><blockquote><p>以每秒或者每十秒的速度从缓冲池的脏页列表中刷新一定比例的页回到磁盘。</p></blockquote><ul><li>FLUSH_LRU_LIST Checkpoint</li></ul><blockquote><p><strong>因为InnoDB引擎需要保证LRU列表中需要有差不多100个空闲页可供使用，所以如果没有足够的空闲页，那么InnoDB引擎会将LRU列表尾端的页移除，那如果有脏页，则进行Checkpoint。</strong> 通过参数innodb_lru_scan_depth指定，默认1024</p></blockquote><ul><li>Async/Sync Flush Checkpoint</li></ul><blockquote><p>指的是重做日志文件不可用的情况，这时候需要强制将一些页刷新到磁盘，为了保证重做日志的循环使用。</p></blockquote><ul><li>Dirty Page too much Checkpoint</li></ul><blockquote><p>当脏页的数量太多，导致InnoDB存储引擎强制进行Checkpoint，目的是为了保证缓冲池中有足够的可用的页。通过参数innodb_max_dirty_pages_pct控制</p></blockquote><p>默认大小75%，即缓冲池中脏页数量占据75%时候，强制进行Checkpoint，刷新一部分的脏页到磁盘。</p><h3 id="InnoDB关键特性"><a href="#InnoDB关键特性" class="headerlink" title="InnoDB关键特性"></a>InnoDB关键特性</h3><h4 id="插入缓冲"><a href="#插入缓冲" class="headerlink" title="插入缓冲"></a>插入缓冲</h4><h5 id="Insert-Buffer"><a href="#Insert-Buffer" class="headerlink" title="Insert Buffer"></a>Insert Buffer</h5><p>在InnoDB存储引擎中，主键是行唯一的标识符大家都知道，<strong>通常应用程序中行记录的插入顺序是按照主键递增的顺序进行插入的。</strong> 也因此，插入聚簇索引一般是顺序的，不需要磁盘的随机读取。 </p><p>问题来了：一张表一般除了一个主键，还有多个非聚簇索引，我这里假设一张表中的聚簇索引为a，非聚簇索引为b，如：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> t<span class="token punctuation">(</span><span class="token number">a</span> <span class="token keyword">int</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span> <span class="token number">b</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span><span class="token number">a</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span><span class="token number">b</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>那么这张表在进行插入操作的时候，页的存放还是按照主键a进行顺序存放的，但是对于非聚簇索引b的叶子节点的插入不再是顺序的了，这时候需要离散的访问非聚簇索引页，即随机读取。（B+树的特性决定了非聚簇索引插入的离散型）。</strong></p><p>那么，InnoDB存储引擎开创了Insert Buffer的目的是啥呢？</p><blockquote><p>对于非聚簇索引的插入或者更新操作，不是每一次都直接插入到索引页中，<strong>而是先判断插入的非聚簇索引页是否在缓冲池中。</strong><br>如果在——&gt;直接插入。<br><strong>如果不在——&gt;先放入到Insert Buffer对象中，然后再以一定的频率将Insert Buffer和辅助索引页子节点进行合并操作。</strong><br>那么这时候能够将多个插入合并到一个操作中，就大大提高了对于非聚簇索引插入的性能。</p></blockquote><p>那么以我的理解：</p><ol><li>把Insert Buffer<strong>看做是一个大容器</strong>，把每次非聚簇索引的插入当做一次任务。</li><li><strong>因为非聚簇索引的插入具有离散型，那么如果把多个非聚簇索引的插入绑定在一块</strong>，形成一个大的插入事件，提高插入性能。</li></ol><p>使用Insert Buffer需要满足的条件，有俩：</p><ol><li>索引是辅助索引（非聚簇）。</li><li>索引不是唯一的（unique）。</li></ol><h5 id="Change-Buffer"><a href="#Change-Buffer" class="headerlink" title="Change Buffer"></a>Change Buffer</h5><p>前面的Insert Buffer可以说是针对非聚簇索引的插入操作，那么自从InnoDB1.0.x版本后，引入了Insert Buffer的升级版：Change Buffer，可以对DML操作（insert，update，delete）都进行缓冲，这里分别对应了Insert Buffer、Purge Buffer、Delete Buffer，使用参数<code>innodb_change_buffering</code>来开启各种Buffer选项。（默认是all，即全开启）</p><p>值得注意的是，因为Change Buffer是升级版，所以它适用的对象依然是非唯一的辅助索引，比如对一条记录进行update操作可以分为2个过程：</p><ol><li>将记录标记为已删除。（对应Delete Buffer）</li><li>真正将记录删除。（对应Purge Buffer）</li></ol><h5 id="Insert-Buffer的内部实现原理"><a href="#Insert-Buffer的内部实现原理" class="headerlink" title="Insert Buffer的内部实现原理"></a>Insert Buffer的内部实现原理</h5><p><strong>Insert Buffer的数据结构是一颗B+树。</strong> 目前版本全局只有一颗Insert Buffer B+树，<strong>负责对所有的表的辅助索引进行Insert Buffer。这颗B+树存放在共享表空间中，默认是ibdata1中，其非叶子节点存放的是查询的search key（键值）</strong></p><p>search key的结构：<br><img src="/posts/9398/image-20231109210839840.png" alt></p><ol><li>space（4字节）：待插入记录所在表的表空间id（唯一），可以通过该id得知哪张表。</li><li>marker（1字节）：兼容老版本的Insert Buffer。</li><li>offset（4字节）：页所在的偏移量</li></ol><p><strong>插入原理：</strong><br>当一个辅助索引需要插入到页中的时候，<strong>如果这个也不在缓冲池中，那么InnoDB存储引擎首先会根据上述的数据结构构造一个search key</strong>，接下来查询Insert Buffer这颗B+树，然后江浙条记录插入到其叶子节点中。</p><p><strong>插入后的结构：</strong><br>如图：Insert Buffer叶子节点中的记录，相比之前，多了一个metadata<br><img src="/posts/9398/4.png" alt><br>其中metadata的存储内容包括（4字节）：<br><img src="/posts/9398/5.png" alt><br><strong>其中IBUF_REC_OFFSET_COUNT用来排序每个记录进入Insert Buffer的顺序。</strong> 并且这里大家可以看出，Insert Buffer的B+树存储叶子节点，需要额外的13字节的开销（9字节的search key和4字节的metadata），后续的列表就是记录的实际字段了。</p><h4 id="Merge-Insert-Buffer"><a href="#Merge-Insert-Buffer" class="headerlink" title="Merge Insert Buffer"></a>Merge Insert Buffer</h4><p>插入缓冲的时候，如果插入记录的辅助索引页不在缓冲池中，记录将插入到Insert Buffer B+树中。<strong>那么什么时候把Insert Buffer的记录合并到真正的辅助索引中呢？</strong> </p><p>直接总的来说，Merge Insert Buffer的时机有这么3种：</p><ol><li>辅助索引页被读取到缓冲池。</li></ol><blockquote><p>比如执行select操作，这时候需要先检查Insert Buffer Bitmap页，确认该辅助索引页是否有记录存放在Insert Buffer B+树中，如果有，则把树中的记录插入到辅助索引页中。<br><strong>注意，注意：大家可以理解为，Insert Buffer B+树只是一个中间件，缓存记录的地方，而辅助索引页是辅助索引记录的最终归宿。</strong></p></blockquote><ol start="2"><li>Insert Buffer Bitmap页追踪到该辅助索引页已经没有可用空间的时候。</li></ol><blockquote><p>若插入辅助索引记录时检测到插入记录后辅助索引页的可用空间小于1/32，那么这个时候会强制进行Merge Insert Buffer。</p></blockquote><ol start="3"><li>Master Thread。</li></ol><blockquote><p>每秒或者每十秒会进行一次Merge Insert Buffer操作。</p></blockquote><p>上文多次提到了Insert Buffer Bitmap，这里来稍微解释下是个啥东西：<br><strong>为了保证每次Merge Insert Buffer页必须成功，需要一个特殊的页来标记每个辅助索引页的可用空间，而这个也的类型为Insert Buffer Bitmap。</strong></p><p>其结构：<br><img src="/posts/9398/20201209145959330.png" alt></p><h4 id="二次写"><a href="#二次写" class="headerlink" title="二次写"></a>二次写</h4><p><strong>Insert Buffer带给InnoDB存储引擎的是性能上的提升，而二次写（doublewrite）带给他的是数据页的可靠性。</strong></p><p>再讲二次写之前，先给解释两个专有名词：<strong>写失效</strong></p><blockquote><p>当发生数据库宕机的时候，可能InnoDB存储引擎正在写入某个页到表中，而这个页中只写了一部分，比如一共16KB的页，只写了前4KB，之后发生了宕机，那么这种情况称之为写失效。</p></blockquote><p>虽然发生写失效的时候，可以通过重做日志来进行恢复，<strong>但是重做日志中记录的是对页的物理操作，如果这个页本身发生了损坏，那么重做是没有意义的。</strong> 因此，我们需要在重做日志前，用户需要一个页的副本，当写入失效发生的时候，<strong>先通过页的副本来还原，再进行重做，这就是二次写。</strong></p><p>doublewrite的结构如下，由两个部分组成：</p><ul><li>一部分是内存中的doublewrite buffer，大小为2MB。</li><li>一部分是物理磁盘上共享表空间中连续的128个页，大小为2MB。</li></ul><p><img src="/posts/9398/6.png" alt></p><p><strong>工作原理：</strong></p><ol><li>在对缓冲池的脏页进行刷新时，并不直接写磁盘，而是通过memcpy函数将脏页<strong>先复制到内存当中的doublewrite buffer。</strong></li><li>之后通过doublewrite buffer分两次操作，每次1MB，<strong>顺序的写入共享表空间的物理磁盘上。</strong></li><li><strong>调用fsync函数，同步磁盘</strong>，避免缓冲写带来的问题。</li><li>完成doublewrite页的写入后，<strong>再将doublewrite buffer中的页写入各个表空间文件中。</strong></li></ol><p>问题：如果操作系统在将页写入磁盘的过程中发生了崩溃，怎么办？</p><blockquote><p>回答：<br>恢复过程中，InnoDB存储引擎可以<strong>从共享表空间中的doublewrite中找到该页的一个副本，将其复制到表空间文件中，再应用重做日志进行恢复。</strong></p></blockquote><h4 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h4><p>首先大家应该知道一点，哈希是一种非常快的查找方法，一般时间复杂度为O（1），B+树的查找次数，取决于B+树的高度。<strong>InnoDB会监控表上各个索引页的查询，如果说观察到建立哈希索引可以带来速度提升，那么会建立一个哈希索引，也就是自适应哈希索引（Adaptive Hash Index ，AHI）。</strong></p><p><strong>AHI是通过缓冲池的B+树页构造而来</strong>，因此建立的速度很快，<strong>InnoDB会自动根据访问的频率和模式来自动的为某一些热点页建立哈希索引，并且默认AHI功能默认开启。</strong></p><h4 id="异步IO和刷新邻接页"><a href="#异步IO和刷新邻接页" class="headerlink" title="异步IO和刷新邻接页"></a>异步IO和刷新邻接页</h4><p>首先说下<strong>异步IO</strong>：<br>很简单，就是用户发起一个IO请求后立即在发送一个IO请求，当所有IO请求发送完毕后，等待所有IO操作的完成，<strong>核心是无需等待第一个IO请求的返回结果。</strong></p><p>AIO的另一个优势就是可以进行IO Merge操作，也就是将多个IO操作合并为1个IO，这样可以提高IOPS（可以视为是每秒的读写次数）的性能。这里举一个书中的例子：</p><blockquote><p>例如用户需要访问页的（space，page_no）为：(8,6)，(8,7)，(8,8)<br>那么每个页的大小为16KB，那么同步IO需要进行3次IO操作，而AIO会判断到这3个页是连续的，因此AIO底层会发送一个IO请求，从（8，6）开始，一次性读取48KB的页。</p></blockquote><p>再来说下<strong>刷新邻接页</strong>：<br>InnoDB存储引擎提供了刷新邻接页（Flush Neighbor Page）的特性，其工作原理为：</p><ol><li>当刷新一个脏页的时候，InnoDB存储引擎<strong>会检测到该页所在区的所有页</strong>。</li><li><strong>如果是脏页，那么一个区的所有页一起进行刷新</strong>。</li></ol><p>通过AIO可以将多个IO写入操作合并为一个IO操作，那么该工作机制在传统的机械硬盘下肯定是有显著的优势，但是也产生了俩问题：</p><ul><li>如果将不怎么脏的页进行了写入，但是之后页又很快变成了脏页咋办？</li><li>固态硬盘有着较高的IOPS，是否还需要这个特性？</li></ul><h2 id="第3章-文件"><a href="#第3章-文件" class="headerlink" title="第3章 文件"></a>第3章 文件</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;这是一份读书笔记，之前一直写在本地没有上传到博客上，同步一下也方便自己。&lt;/p&gt;
&lt;h2 id=&quot;第1章-MYSQL体系结构和存储引擎&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://JoyTsing.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
      <category term="读书笔记" scheme="https://JoyTsing.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="MySql" scheme="https://JoyTsing.github.io/tags/MySql/"/>
    
      <category term="数据库" scheme="https://JoyTsing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>如何用lambda表达式快速刷题</title>
    <link href="https://joytsing.github.io/posts/34936/"/>
    <id>https://joytsing.github.io/posts/34936/</id>
    <published>2024-03-20T08:50:48.000Z</published>
    <updated>2024-03-20T09:14:37.148Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>好吧，我承认文章题目有点标题党了，总的来说就是用lambda表达式让你能够在一个函数之内解决战斗(本人很不喜欢刷题的时候拆开写函数)，只要用到递归的地方都能够使用。</p><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>什么是函数式编程就不展开说了，这里主要用到Lambda演算理论中的<code>Y Combinator</code>，通过它我们可以实现匿名的递归调用函数。关于它的解释，一般是所谓的“懂的都懂”，感兴趣的可以去了解一下，这里只讲怎么用。具体来说，就是在c++中，如果你想在lambda表达式中递归调用自己是不行的(当然后面能够做到，不然也就没这篇文章了)，编译器会提示你此时还未定义，那么怎么做呢，就是通过<code>Y Combinator</code>，这也不卖关子了，其实就是把函数自身当成参数传进去即可，这样就可以调用了是不是？</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="/posts/34936/image-20240320170607932.png" alt></p><p>具体怎么写递归不在这篇文章的范围，如果我们想用lambda表达式的话我们应该怎么写？实际上看下面的代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">auto</span> func<span class="token operator">=</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> func<span class="token punctuation">,</span>Node<span class="token operator">*</span> node<span class="token punctuation">,</span><span class="token keyword">int</span> depth<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>depth<span class="token punctuation">)</span><span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            res<span class="token punctuation">[</span>depth<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> child<span class="token operator">:</span>node<span class="token operator">-</span><span class="token operator">></span>children<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">func</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span>child<span class="token punctuation">,</span>depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token function">func</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span>root<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>lambda表达的第一个参数不一定要和定义的lambda变量重名，可以叫别的名字(通常起名为self)，这样写的目的是方便直观的调用，比如下面这样：</p><p><img src="/posts/34936/image-20240320171019481.png" alt></p><p>代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>TreeNode <span class="token operator">*</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> dfs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> self<span class="token punctuation">,</span> TreeNode <span class="token operator">*</span>root<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">int</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">self</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token function">self</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">max</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>dfs<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>细心的可能发现了为什么第一种写法的参数需要用<code>&amp;&amp;</code>而第二个不需要，感兴趣的话可以在下面评论区留言。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>其实一切的起因还是归咎于本人懒，加上代码能力一般实在不想背非递归调用的板子，还是觉得在能保证正确的情况下行数越少逻辑越清晰越好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;好吧，我承认文章题目有点标题党了，总的来说就是用lambda表达式让你能够在一个函数之内解决战斗(本人很不喜欢刷题的时候拆开写函数)，只要用
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="Leetcode" scheme="https://JoyTsing.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Cpp对象模型</title>
    <link href="https://joytsing.github.io/posts/28140/"/>
    <id>https://joytsing.github.io/posts/28140/</id>
    <published>2024-03-15T07:51:17.000Z</published>
    <updated>2024-03-20T16:24:32.801Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>C++对象模型，启动！</p><h2 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h2><ul><li>简单对象模型(A Simple Object Model)</li></ul><p>对象保存成员的指针，成员实际存放在其他区域.</p><p>这种模型保证了成员中每个元素需要的内存空间都是一样的, 不论元素是何种类型, 访问时只需要确定成员的index和对象首地址即可. 坏处是访问成员时需要多进行一次内存访问, 并且占用了更多的内存空间.</p><ul><li>表格驱动对象模型(A Table-driven Object Model)</li></ul><p>将对象中的数据成员和函数成员分别组织, 放在不同的内存区域, 对象中保存了指向这两个内存区域的指针.</p><p>这种模型保证了不同类型的对象具有相同的内存布局,</p><h2 id="C-对象模型"><a href="#C-对象模型" class="headerlink" title="C++对象模型"></a>C++对象模型</h2><p>每个有虚函数的类产生一个virtual table, 保存所有虚函数的指针, 对象在所在内存开始位置保存指向 vtable 的指针 vptr. 在调用类的虚函数时, 会沿着虚函数表搜索, 第一个满足条件的就是要调用的函数. 在调用类的构造函数, 复制构造函数等时这些函数会自动处理类的vptr. 比如下面的代码中, 假设类Base 是Derived的父类, 二者都定义了函数f(), 那么自然就有vptr. 在第二行中, 调用了Base的复制构造函数, 对象d会被截断, 并且b的vptr会在复制构造函数中设置, 因此第三行中b调用的是Base中的f(). 另外一个值得注意的是, 运行时多态只能通过指针和引用来实现.</p><pre class="line-numbers language-cpp"><code class="language-cpp">Derived d<span class="token punctuation">;</span>Base b <span class="token operator">=</span> b<span class="token punctuation">;</span>b<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>单继承且无继承时, 每个对象只有一个vptr, 而当存在虚继承时, 虚继承的直接子类还会产生一个附加的 vptr, 指向自身的virtual table. 当存在多继承时, 会为每个父类产生一个vptr. 下面针对这些情况 详细举例说明.</p><ul><li>单继承, 无虚继承时的对象模型</li></ul><p>这是最简单的情况, 在对象的开始处保存一个vptr指针, 指向一个虚函数指针数组, 非静态数据成员按继承, 声明的顺序排列.</p><ul><li>单继承, 有虚继承时的对象模型</li></ul><p>采用虚继承的类会在产生多个vptr, 对象开始处是父类的vptr, 父类成员之后, 子类成员之前保存子类的vptr. 如下:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">BB</span><span class="token punctuation">{</span>    int64_t m_bb<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B1</span> <span class="token operator">:</span> <span class="token keyword">public</span> <span class="token keyword">virtual</span> BB<span class="token punctuation">{</span>    int64_t m_b1<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">DD</span> <span class="token operator">:</span> <span class="token keyword">public</span> B1<span class="token punctuation">{</span>    int64_t m_dd<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">D1</span> <span class="token operator">:</span> <span class="token keyword">public</span> DD<span class="token punctuation">{</span>    int64_t m_d1<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// D1对象的结构, gcc 8.2.0, GNU gdb 8.1.1</span><span class="token comment" spellcheck="true">// 注意, 这是在gdb中查看的结果, 并不代表真正的对象内存布局. 比如多继承, 有虚继承的情况.</span><span class="token punctuation">{</span>    <span class="token operator">&lt;</span>DD<span class="token operator">></span> <span class="token operator">=</span>    <span class="token punctuation">{</span>        <span class="token operator">&lt;</span>B1<span class="token operator">></span> <span class="token operator">=</span>        <span class="token punctuation">{</span>            <span class="token operator">&lt;</span>BB<span class="token operator">></span> <span class="token operator">=</span>            <span class="token punctuation">{</span>                _vptr<span class="token punctuation">.</span>BB <span class="token operator">=</span> <span class="token operator">&lt;</span>vtable <span class="token keyword">for</span> D1<span class="token operator">+</span><span class="token number">112</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 父类的vptr</span>                m_bb            <span class="token punctuation">}</span><span class="token punctuation">,</span>            _vptr<span class="token punctuation">.</span>B1 <span class="token operator">=</span> <span class="token operator">&lt;</span>vtable <span class="token keyword">for</span> D1<span class="token operator">+</span><span class="token number">24</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 虚继承子类B1的vptr</span>            m_b1        <span class="token punctuation">}</span><span class="token punctuation">,</span>        m_dd    <span class="token punctuation">}</span><span class="token punctuation">,</span>    m_d1 <span class="token comment" spellcheck="true">// 没有采用虚继承, 因此与基类BB共用vptr.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>继承, 无虚继承时的对象模型</li></ul><p>保留多个父类的vptr.</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">BB</span><span class="token punctuation">{</span>    int64_t m_bb<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B1</span> <span class="token operator">:</span> <span class="token keyword">public</span> BB<span class="token punctuation">{</span>    int64_t m_b1<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B2</span> <span class="token operator">:</span> <span class="token keyword">public</span> BB<span class="token punctuation">{</span>    int64_t m_b2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">DD</span> <span class="token operator">:</span> <span class="token keyword">public</span> B1<span class="token punctuation">,</span> B2<span class="token punctuation">{</span>    int64_t m_dd<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// DD对象的结构, gcc 8.2.0, GNU gdb 8.1.1</span><span class="token punctuation">{</span>    <span class="token operator">&lt;</span>B1<span class="token operator">></span> <span class="token operator">=</span>    <span class="token punctuation">{</span>        <span class="token operator">&lt;</span>BB<span class="token operator">></span> <span class="token operator">=</span>        <span class="token punctuation">{</span>            _vptr<span class="token punctuation">.</span>BB <span class="token operator">=</span> <span class="token operator">&lt;</span>vtable <span class="token keyword">for</span> DD<span class="token operator">+</span><span class="token number">16</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// B1的vptr</span>            m_bb        <span class="token punctuation">}</span><span class="token punctuation">,</span>        m_b1    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token operator">&lt;</span>B2<span class="token operator">></span> <span class="token operator">=</span>    <span class="token punctuation">{</span>        <span class="token operator">&lt;</span>BB<span class="token operator">></span> <span class="token operator">=</span>        <span class="token punctuation">{</span>            _vptr<span class="token punctuation">.</span>BB <span class="token operator">=</span> <span class="token operator">&lt;</span>vtable <span class="token keyword">for</span> DD<span class="token operator">+</span><span class="token number">80</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// B2的vptr</span>            m_bb        <span class="token punctuation">}</span><span class="token punctuation">,</span>        m_b2    <span class="token punctuation">}</span><span class="token punctuation">,</span>    m_dd <span class="token comment" spellcheck="true">// 与基类B1共用vptr.</span><span class="token punctuation">}</span>BB <span class="token operator">*</span>bp <span class="token operator">=</span> <span class="token keyword">new</span> DD<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 错误, 有歧义</span>BB <span class="token operator">*</span>bp1 <span class="token operator">=</span> <span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span>B1<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> DD<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正确, bp1指向DD中的B1部分.</span>BB <span class="token operator">*</span>bp2 <span class="token operator">=</span> <span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span>B2<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> DD<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正确, bp2指向DD中的B2部分.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很自然地, 当用BB类型的指针/引用保存DD对象时, 就会出现歧义, 编译器无法确定采用B1中的BB还是B2中BB. 可以使用 dynamic_cast 进行干预, 以达到预期目的.</p><ul><li>多继承, 有虚继承时的对象模型<br>有了上面的结论, 就不难推测这种情况下的对象模型了.</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">BB</span><span class="token punctuation">{</span>    int64_t m_bb<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B1</span> <span class="token operator">:</span> <span class="token keyword">virtual</span> <span class="token keyword">public</span> BB<span class="token punctuation">{</span>    int64_t m_b1<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B2</span> <span class="token operator">:</span> <span class="token keyword">virtual</span> <span class="token keyword">public</span> BB<span class="token punctuation">{</span>    int64_t m_b2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">DD</span> <span class="token operator">:</span> <span class="token keyword">public</span> B1<span class="token punctuation">,</span> B2<span class="token punctuation">{</span>    int64_t m_dd<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// DD对象的结构, gcc 8.2.0, GNU gdb 8.1.1</span><span class="token punctuation">{</span>    <span class="token operator">&lt;</span>B1<span class="token operator">></span> <span class="token operator">=</span>    <span class="token punctuation">{</span>        <span class="token operator">&lt;</span>BB<span class="token operator">></span> <span class="token operator">=</span>        <span class="token punctuation">{</span>            _vptr<span class="token punctuation">.</span>BB <span class="token operator">=</span> <span class="token operator">&lt;</span>vtable <span class="token keyword">for</span> DD<span class="token operator">+</span><span class="token number">160</span><span class="token operator">></span><span class="token punctuation">,</span>            m_bb <span class="token operator">=</span> <span class="token number">1</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        _vptr<span class="token punctuation">.</span>B1 <span class="token operator">=</span> <span class="token operator">&lt;</span>vtable <span class="token keyword">for</span> DD<span class="token operator">+</span><span class="token number">24</span><span class="token operator">></span><span class="token punctuation">,</span>        m_b1    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token operator">&lt;</span>B2<span class="token operator">></span> <span class="token operator">=</span>    <span class="token punctuation">{</span>        _vptr<span class="token punctuation">.</span>B2 <span class="token operator">=</span> <span class="token operator">&lt;</span>vtable <span class="token keyword">for</span> DD<span class="token operator">+</span><span class="token number">88</span><span class="token operator">></span><span class="token punctuation">,</span>        m_b2    <span class="token punctuation">}</span><span class="token punctuation">,</span>    m_dd<span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 实际内存布局可能是:</span><span class="token punctuation">{</span>    <span class="token operator">&lt;</span>B1<span class="token operator">></span> <span class="token operator">=</span>    <span class="token punctuation">{</span>        vptr<span class="token punctuation">.</span>B1<span class="token punctuation">,</span>        m_b1    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token operator">&lt;</span>B2<span class="token operator">></span> <span class="token operator">=</span>    <span class="token punctuation">{</span>        vptr<span class="token punctuation">.</span>B2<span class="token punctuation">,</span>        m_b2    <span class="token punctuation">}</span>    m_dd<span class="token punctuation">,</span>    <span class="token operator">&lt;</span>BB<span class="token operator">></span> <span class="token operator">=</span>    <span class="token punctuation">{</span>        vptr<span class="token punctuation">.</span>BB<span class="token punctuation">,</span>        m_bb    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="关键字class和struct的区别"><a href="#关键字class和struct的区别" class="headerlink" title="关键字class和struct的区别"></a>关键字class和struct的区别</h2><p>二者在绝大多数情况下是完全相同的, 可以互换, 只有几点不同.</p><p>class可以用于模板声明, struct不可以. C++引入class关键字, 保留struct的一个原因是为了体现OO, 并且兼容C, 而C中不需要模板, 也就不需要保证struct可以用于模板.</p><p>另外, 当用于声明类类型时二者略有差别:</p><ul><li>用class声明的类的成员的默认访问级别是private, 用struct声明的类的成员的默认访问级别是public.</li><li>有继承时, 用class声明的类的默认继承方式是private, 用struct声明的类的默认继承方式是public. 这里的class, struct是指用于子类, 父类的声明方式不影响默认方式. 如下代码:</li></ul><pre class="line-numbers language-text"><code class="language-text">class BB {};class D1 : BB {}; // private继承struct D2 : BB {}; // public继承 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="运行时多态必须通过public继承实现"><a href="#运行时多态必须通过public继承实现" class="headerlink" title="运行时多态必须通过public继承实现"></a>运行时多态必须通过public继承实现</h2><p>这个设计是符合逻辑的. 可以设想, 如果使用其他继承方式, 那么从逻辑上说, 在类外不应该能访问父类成 员. 但是要实现运行时多态, 正常做法是将子类指针/引用赋值给一个父类类型的指针/引用(设为bp), 一旦复制成功, 我们就可以通过bp访问父类的public成员, 这显然与前面的逻辑要求矛盾. 所以, 在C++中, 前面说得”赋值”是违法的. 而没有这个”赋值”操作, 也就无法实现运行时多态, 因此必须通过public继承实现运行时多态.</p><h2 id="Default-Constructor的构造操作"><a href="#Default-Constructor的构造操作" class="headerlink" title="Default Constructor的构造操作"></a>Default Constructor的构造操作</h2><p><strong>默认构造函数(default constructor)的定义</strong>:</p><blockquote><p>一个可以以空参数列表调用的构造函数称为默认构造函数, 这有两种情形, 一种是构造函数参数列表为空, 另一种是每个参数都在声明中给出了默认值.</p></blockquote><p>默认构造函数可以是自己定义的, 也可以由编译器自动生成. 当用户没有定义任何构造函数时, 编译器就会为用户生成一个参数列表为空的默认构造函数.</p><p><strong>trivial default constructor(无用默认构造函数)</strong></p><blockquote><p>满足下面所有的条件时, 一个默认构造函数是trivial的: - 不是由用户提供的, 即是由编译器生成的或者声明为default. - 类没有虚成员函数 - 类没有虚基类 - 类没有默认初始化的非静态成员 - 直接基类有trivial default constructor - 非静态类成员有trivial default constructor<br>显然, trivial default constructor不进行任何操作. 所有与C语言兼容的数据类型(POD类型)都具有trivial default constructor.</p></blockquote><h3 id="带有default-constructor的member-class-object"><a href="#带有default-constructor的member-class-object" class="headerlink" title="带有default constructor的member class object"></a>带有default constructor的member class object</h3><p>编译器会为没有定义构造函数的类合成默认构造函数, 但是这个合成操作只有在构造函数真正需要被调用时才会发生.</p><p>那么在C++不同编译模块中, 编译器怎么避免生成多个默认构造函数呢? 解决方法是把合成的默认构造函数, 复制构造函数, 析构函数, 赋值运算符都作为inline, 而inline函数是静态链接(static linkage)的, 不会被编译模块(即文件)以外的看到. 如果函数太复杂, 作为inline不合适, 就会合成一个显式non-inline静态(explicit non-inline static)实例.</p><p>我们知道, 类对象是必须要初始化的, 当一个类的成员有其他类对象时, 就必须在构造函数中对类成员进行初始化. 如果是编译器合成的默认构造函数, 就在合成的默认构造函数中按类成员声明顺序调用它们的默认构造函数(当然, 如果没有就会引起错误). 注意一点, 对于显式定义的构造函数函数, 如果没有对部分类成员对象的初始化, 编译器会自动插入一些代码, 使得用户代码被执行之前, 先调用必要的默认构造函数, 调用顺序与它们的声明相同. 但是如果有的对象显式调用了构造函数, 有的没有, 顺序是如何确定的呢? 仍然按照它们的声明顺序调用.</p><h3 id="“带有default-constructor”的Base-Class"><a href="#“带有default-constructor”的Base-Class" class="headerlink" title="“带有default constructor”的Base Class"></a>“带有default constructor”的Base Class</h3><p>如果一个子类的基类带有默认构造函数, 那么在合成子类的构造函数时, 会在其中插入对基类的默认构造函 数会的调用代码, 这个代码在成员的默认构造函数调用代码之前. 即先初始化基类, 再按声明顺序初始化子 类成员.</p><h3 id="“带有一个Virtual-Function”的Class"><a href="#“带有一个Virtual-Function”的Class" class="headerlink" title="“带有一个Virtual Function”的Class"></a>“带有一个Virtual Function”的Class</h3><p>对于带有虚函数的类, 不论是直接声明的还是直接/间接继承而来的, 都有虚函数表, 对应对象有虚函数表指 针(vptr)作为数据成员. 那么vptr是如何确定的呢? 显然, 虚函数表是在编译阶段就可以确定的, 因此由 编译器合成. 但是vptr的确定就要分情况讨论了:</p><ul><li>对于静态初始化的对象, vptr由编译器初始化.</li><li>对于动态初始化的对象, <strong>vptr由构造函数初始化</strong>. 因此编译器会在所有的构造函数中插入一些代码来完成这个任务.</li></ul><h3 id="“带有一个Virtual-Base-Class”的Class"><a href="#“带有一个Virtual-Base-Class”的Class" class="headerlink" title="“带有一个Virtual Base Class”的Class"></a>“带有一个Virtual Base Class”的Class</h3><p>当存在虚基类时, 通过虚基类指针/引用访问其非虚函数, 数据成员时, 应该是不属于多态的, 但是仍然在 运行时才能决定. 指针所指对象的实际类型很多时候是未知的, 在不同类型中, 由于采用了虚继承, 同一变 量偏移可能不一样(这是由实现决定的), 简而言之就是编译器不知道成员在指针所指对象的什么位置. 因此, 存在虚基类时, 就需要提供某种方法, 使我们能够通过虚基类指针访问虚基类的非虚函数和数据成员. 一种 方法是在子类中插入一个指向虚基类的指针, 将原始的通过虚基类指针访问那些成员的代码替换为先访问这个 指针, 再访问成员的代码. 如下所示:</p><pre class="line-numbers language-cpp"><code class="language-cpp">virtualBasePointer<span class="token operator">-</span><span class="token operator">></span>virtualBaseData<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 原始代码</span>virtualBasePointer<span class="token operator">-</span><span class="token operator">></span>virtualBaseVptr<span class="token operator">-</span><span class="token operator">></span>virtualBaseData<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 编译器替换后的代码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>而这个<strong>虚基类指针的初始化</strong>就是由构造函数完成的.</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li>类的默认构造函数只有真正需要时才会被合成, 而不是没有定义构造函数时就会合成.</li><li>对于一个类的所有类成员对象, 如果没有显式初始化, 编译器会对其进行默认初始化. 但是对于内置类型, 例如int, 指针类型等, 不会进行初始化, 这是程序员的工作.</li></ol><h2 id="Copy-Constructor的构造操作"><a href="#Copy-Constructor的构造操作" class="headerlink" title="Copy Constructor的构造操作"></a>Copy Constructor的构造操作</h2><p>3种情况下会调用复制构造函数:</p><ol><li>用一个对象作为参数初始化另一个对象时.</li><li>对象作为函数参数时, 会用参数对象在函数作用域构造一个新的对象.</li><li>对象作为返回值时, 会用函数内部的对象在返回值所在作用域构造一个新的对象.</li></ol><p>注意, 2, 3不一定会发生, 因为可能会存在右值参数, 返回值优化等, 具体情况不做详述.</p><p>如果不显式定义复制构造函数, 编译器有两种复制对象的方法: bitwise copy和default memberwise copy, 区别如下:</p><ul><li>bitwise copy并不调用复制构造函数, 可能的实现方式如利用memcpy等, 因此效率更高, 复制出的对象和原对象完全相同.</li><li>default memberwise copy就如同对每个成员分别赋值一样, 对于内置类型, 直接初始化, 对于类类型, 递归调用其默认复制构造函数来初始化. 默认构造函数是由编译器合成的, 或者被声明为default. 其产生的新对象的用户定义的数据成员与原对象是一样的, 但是隐式的成员(如vptr), 内存布局(子类初始化父类)等不一定相同.</li></ul><blockquote><p><strong>注意:</strong><br>bitwise copy和浅复制(shallow copy)是不同的, 浅复制更侧重于当在类内部保存指针成员, 用指针指向实际数据的时候, 复制时仅仅复制指针的值. 这种情况包含在bitwise copy中.</p></blockquote><p>那么在没有定义复制构造函数的时候, 编译器在什么情况下采用bitwise copy, 在什么情况下合成默认复制构造函数(即采用default memberwise copy)? 下面四种情况, 会采用后者, 其他情况采用前者.</p><ol><li>当类含有类对象成员, 且这个成员含有复制构造函数时(不论是编译器合成的还是显式定义的).</li><li>当类继承自一个基类, 并且基类含有复制构造函数时(不论是编译器合成的还是显式定义的).</li><li>当类含有虚函数时.</li><li>当类有虚基类时.</li></ol><p>上面的情况很容易理解. 对于1和2, 由于复制对象时, 要复制数据成员和基类, 既然它们提供了复制构造函数, 就可以认为需要在它们的复制构造函数中进行某些bitwise copy无法实现的操作, 因此不能采用bitwise copy. 对于3, 由于含有虚函数, 所以需要初始化对象的vtpr, 而vptr的值显然不一定等于参数对象的值, 例如用子类对象初始化父类对象时. 所以bitwise不能满足需求. 对于4, 由于含有虚基类, 父子基类的内存布局可能存在区别, 更不能采用bitwise copy.</p><p>当合成/用户定义的复制构造函数的语意和bitwise copy相同时, 是否应该用bitwise copy替换复制构造函数?</p><h2 id="程序转化语意学-Program-Transformation-Semantics"><a href="#程序转化语意学-Program-Transformation-Semantics" class="headerlink" title="程序转化语意学(Program Transformation Semantics)"></a>程序转化语意学(Program Transformation Semantics)</h2><p>尽管在程序中可以使用不同的形式来初始化一个类对象, 但在编译阶段都会被转化成相同的形式. 例如:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">X</span><span class="token punctuation">;</span>X <span class="token function">x0</span><span class="token punctuation">(</span>paras<span class="token punctuation">)</span><span class="token punctuation">;</span>X x1 <span class="token operator">=</span> <span class="token function">X</span><span class="token punctuation">(</span>paras<span class="token punctuation">)</span><span class="token punctuation">;</span>X <span class="token function">x2</span><span class="token punctuation">(</span>x0<span class="token punctuation">)</span><span class="token punctuation">;</span>X x3 <span class="token operator">=</span> x0<span class="token punctuation">;</span>X x4 <span class="token operator">=</span> <span class="token function">X</span><span class="token punctuation">(</span>x0<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>会被转化为:</p><pre class="line-numbers language-cpp"><code class="language-cpp">X x0<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 声明但不初始化</span>X x1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 声明但不初始化</span>X x2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 声明但不初始化</span>X x3<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 声明但不初始化</span>X x4<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 声明但不初始化</span><span class="token comment" spellcheck="true">// 调用构造函数初始化对象</span>x0<span class="token punctuation">.</span>X<span class="token operator">::</span><span class="token function">X</span><span class="token punctuation">(</span>paras<span class="token punctuation">)</span>x1<span class="token punctuation">.</span>X<span class="token operator">::</span><span class="token function">X</span><span class="token punctuation">(</span>paras<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 调用复制构造函数初始化对象</span>x2<span class="token punctuation">.</span>X<span class="token operator">::</span><span class="token function">X</span><span class="token punctuation">(</span>x0<span class="token punctuation">)</span>x3<span class="token punctuation">.</span>X<span class="token operator">::</span><span class="token function">X</span><span class="token punctuation">(</span>x0<span class="token punctuation">)</span>x4<span class="token punctuation">.</span>X<span class="token operator">::</span><span class="token function">X</span><span class="token punctuation">(</span>x0<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数复制优化和返回值优化(都是指省略不必要的复制构造函数的调用, 后面统称为复制优化或copy elision)</p><p>从C++17开始, 标准规定了必须进行copy elision的情况:</p><ul><li>类似下面的情形:</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp">T t <span class="token operator">=</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token function">T</span><span class="token punctuation">(</span><span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 只会调用一次默认构造函数, 要求类型相同(不考虑cv).</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>在返回类对象时, 如果直接在return语句中创建对象, 并且该对象与函数返回值类型一致(不考虑cv)时, 一般称这个优化为RVO(return value optimization)(注意, RVO在C++17之前都不是强制的, 从C++17开始才规定为mandatory的.), 如下例子:</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp">T <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">return</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>T t <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 只会调用一次默认构造函数.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样也规定了可以实施copy elision, 但不强制的情况, 比如NRVO(named return value optimization), 是指函数返回一个具名对象, 该对象是函数体内部定义的自动存储期变量, 并且是non-volatile的, 与函数返回值具有相同类型(不考虑cv). 具体可以参考<a href="https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/language/copy_elision">copy elision</a></p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ol><li>只有当存在复制构造函数(不论是显式定义的还是编译器生成的)时, 编译器才有可能实施复制优化.</li><li>谨慎对待copy elision, 因为类设计者可能需要在复制/移动构造函数中进行某些特殊操作, 省略了之后可能带来难以调试的错误.</li></ol><h2 id="成员初始化列表-Member-Initialization-List"><a href="#成员初始化列表-Member-Initialization-List" class="headerlink" title="成员初始化列表(Member Initialization List)"></a>成员初始化列表(Member Initialization List)</h2><p>应该用成员初始化列表来初始化变量的情况:</p><ol><li>初始化一个引用时.</li><li>初始化一个常量成员时.</li><li>调用基类的构造函数, 并且这个构造函数有一组参数时.</li><li>调用类成员的构造函数, 并且这个构造函数有一组参数时.</li></ol><p>类成员的初始化顺序与初始化列表的顺序无关, 而是与成员在类声明中的顺序一致. 所以, 尽量使初始化列表的顺序与声明顺序一致, 最好不要用一个成员来初始化另一个成员. 在编译阶段, 会将初始化列表转化为成员的初始化代码, 并置于构造函数体内的代码之前.</p><p>注意一点, 用成员函数的返回值来作为初始化列表的参数语法上是没有问题的, 但是需要保证这个成员函数不依赖于成员的数据对象, 因为很可能这个在调用此函数时还没有初始化其依赖的数据成员, 这就会引起难以发现的错误. 另外, 最好不要将其用于初始化基类成员, 详情见后面的讨论.</p><h2 id="不含数据成员的类对象"><a href="#不含数据成员的类对象" class="headerlink" title="不含数据成员的类对象"></a>不含数据成员的类对象</h2><p>对于不存在继承和虚函数的类, 没有数据成员时, 其大小至少是1 byte, 以保证变量有唯一的地址. 当加上虚函数后, 由于有虚函数指针, 对象大小等于一个指针的大小, 32位系统中是4 bytes, 64位系统中是8 bytes. 看下面的代码:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Empty <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> VirtualEmpty<span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Empty a<span class="token punctuation">;</span>Empty b<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Empty<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出为1</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>VirtualEmpty<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出为8</span>cout<span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>a<span class="token operator">&lt;&lt;</span><span class="token string">' '</span><span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>b<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 在输出中可以看到b的地址比a的地址大一.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是, 当其作为基类时, 在某些情况下则不必遵循上面的要求, 可以在子类中将其优化掉, 节省所占空间. 例如下面的情况:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Base <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> Derived <span class="token operator">:</span> Base<span class="token punctuation">{</span>    int64_t i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Base<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出为1</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Derived<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl <span class="token comment" spellcheck="true">// 输出为8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显然这里没有必要保留额外空间来表示基类对象. 上面说过, 为空对象保留空间的原因是保证其有唯一地址, 避免出现不同对象的地址相同的情形. 但是在这里, 子类地址就可以作为父类地址, 不会出现不同对象地址相同的情形. 但是即使是继承, 也有不能进行优化的情况:</p><ul><li>子类的第一个非静态数据成员的类型和空基类相同.</li><li>子类的第一个非静态数据成员的基类类型和空基类相同.</li></ul><p>不难看出, 这两种情况下, 会有两个空基类对象(父类对象和子类数据成员对象)连续出现, 如果优化掉, 将不能区别二者. 示例如下:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Base <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> Derived1 <span class="token operator">:</span> Base <span class="token comment" spellcheck="true">// 情况一</span><span class="token punctuation">{</span>    Base b<span class="token punctuation">;</span>    int64_t i<span class="token punctuation">;</span><span class="token punctuation">}</span>d1<span class="token punctuation">;</span><span class="token keyword">struct</span> Derived2<span class="token punctuation">{</span>    Base b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> Derived3 <span class="token operator">:</span> Base<span class="token punctuation">{</span>    Derived2 d2<span class="token punctuation">;</span>    int64_t i<span class="token punctuation">;</span><span class="token punctuation">}</span>d3<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Derived1<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出为16, 基类对象和成员b各占1 byte, 由于内存对齐补齐8 bytes</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Derived2<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出为1</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Derived3<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出为16, 基类对象和成员d2各占1 byte, 由于内存对齐补齐8 bytes</span>cout<span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>d1<span class="token operator">&lt;&lt;</span><span class="token string">' '</span><span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>d1<span class="token punctuation">.</span>b<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 前者(基类对象地址)比后者小1</span>cout<span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>d3<span class="token operator">&lt;&lt;</span><span class="token string">' '</span><span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>d3<span class="token punctuation">.</span>d2<span class="token punctuation">.</span>b<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 前者(基类对象地址)比后者小1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于空类作为虚基类的情况, 同样可以进行优化. 例如下面的代码:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Base <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> Derived1 <span class="token operator">:</span> <span class="token keyword">virtual</span> Base <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> Derived2 <span class="token operator">:</span> <span class="token keyword">virtual</span> Base <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> Derived3 <span class="token operator">:</span> Derived1<span class="token punctuation">,</span> Derived1 <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> Derived4 <span class="token operator">:</span> Derived1<span class="token punctuation">,</span> Derived1<span class="token punctuation">{</span>    Base b<span class="token punctuation">;</span><span class="token punctuation">}</span>d4<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Derived3<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出为16</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Derived4<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出为24</span>cout<span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>d4<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出为0x55c6986ffe70</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span>Base<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d4<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出为0x55c6986ffe70</span>cout<span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>d4<span class="token operator">-</span><span class="token operator">></span>b<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出为0x55c6986ffe80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了实现虚继承, 类Derived1和Derived2包含一个指针. 而虚基类Base被优化掉了, 因此Derived3大小为16 bytes. 而Derived4中由于包含类型是Base的非静态成员, 需要占据8 bytes, 即Derived4大小为24 bytes. 注意这里基类被优化了, 子类数据成员没有被优化. 测试显示, 即使这个成员不是第一个或最后一个, 编译器仍然不会优化.</p><p>虽然标准没有规定非静态数据成员在内存中的排列顺序, 但是一般实现都是按照声明顺序排列. 而由于内存对齐的要求, 仅仅改变成员的声明顺序可能产生不同大小的对象, 例如下面的声明:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Test1 <span class="token comment" spellcheck="true">// 大小为16 bytes</span><span class="token punctuation">{</span>    int64_t i1<span class="token punctuation">;</span>    <span class="token keyword">char</span> c1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// c1 和 c2 被放置在一个字(16 bytes)中</span>    <span class="token keyword">char</span> c2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> Test2 <span class="token comment" spellcheck="true">// 大小为24 bytes</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> c1<span class="token punctuation">;</span>    int64_t i1<span class="token punctuation">;</span>    <span class="token keyword">char</span> c2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> Test3 <span class="token comment" spellcheck="true">// 大小为16 bytes</span><span class="token punctuation">{</span>    int64_t i1<span class="token punctuation">;</span>    int32_t i2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// i2,c1,c2 被放置在一个字(16 bytes)中</span>    <span class="token keyword">char</span> c1<span class="token punctuation">;</span>    <span class="token keyword">char</span> c2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于计算机是以字(32位机为4 bytes, 64位机为8 bytes)为单位来读写, 因此内存对齐可以加快存取操作. 否则当一个变量跨字时, 读取这个变量就需要两次内存读. 但是这可能会增加需要的内存空间, 这就需要程序员仔细安排变量顺序, 以保证获得最佳的空间利用率.</p><p>而对于普通类的静态数据成员, 则具有独立于对象的静态生存期, 保存在全局数据段中. 模板类的静态数据成员如果没有被显式特化或实例化, 则在使用时会被隐式特化, 只有当特化/实例化后才是有效定义的. 有下面几种情况, 而这几种都可以归到C++14引入的 <em>variable template</em>(变量模板), 参考<a href="https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/language/variable_template">cppreference</a>.</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Test1<span class="token punctuation">{</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span> <span class="token keyword">static</span> T val<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 非模板类的模板静态成员.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span> T Test1<span class="token operator">::</span>val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">struct</span> Test2<span class="token punctuation">{</span>    <span class="token keyword">static</span> T val<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 模板类的非模板静态成员.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span> T Test2<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token operator">></span><span class="token keyword">struct</span> Test3<span class="token punctuation">{</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T2<span class="token operator">></span> <span class="token keyword">static</span> std<span class="token operator">::</span>pair<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token operator">></span> val<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 模板类的模板静态成员.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token operator">></span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T2<span class="token operator">></span>std<span class="token operator">::</span>pair<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token operator">></span> Test2<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token operator">::</span>val <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token function">T1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">T2</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> var <span class="token operator">=</span> Test3<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>val<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 即pair&lt;int, float>(1, 2)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数据成员的存取"><a href="#数据成员的存取" class="headerlink" title="数据成员的存取"></a>数据成员的存取</h2><h3 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h3><p>对静态成员, 通过对象或对象指针访问和通过类名访问没有区别, 编译器一般会将二者统一为相同形式. 类成员指针不能指向静态成员, 因为对静态成员取地址得到的是一个该成员的指针. 如:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>A<span class="token operator">::</span>x<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 其类型是 int*</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为类静态成员都是保存在全局数据段中, 如果不同类具有相同名字的静态成员, 就需要保证不会发生名称冲突. 编译器的解决方法是对每个静态数据成员编码(这种操作称为name-mangling), 以得到一个独一无二的名称.</p><h3 id="非静态数据成员"><a href="#非静态数据成员" class="headerlink" title="非静态数据成员"></a>非静态数据成员</h3><p>不存在虚基类时, 通过对象名或对象指针访问非静态数据成员没有区别. 存在虚基类时, 通过对象指针访问非静态数据成员需要在运行时才能确定, 因为无法确定指针所指对象的实际类型, 也就不能判断对象的内存布局, 也就不知道对象中该数据成员的偏移. 普通继承和虚继承的这个区别的原因在于, 普通继承的类对象的内存布局在编译时就可以决定, 而存在虚继承时则需要在运行时决定, 详情见下文虚继承对内存布局的影响的讨论.</p><h2 id="继承对对象布局的影响"><a href="#继承对对象布局的影响" class="headerlink" title="继承对对象布局的影响"></a>继承对对象布局的影响</h2><h3 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h3><p>最简单的一种情况, 单继承不会修改父类的内存布局, 例如父类由于内存对齐产生的额外空间在子类中不会被消除, 而是保持原样. 所以下面的代码中, 子类大小是24 bytes, 而不是16 bytes.</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Base <span class="token comment" spellcheck="true">// 16 bytes</span><span class="token punctuation">{</span>    int64_t i1<span class="token punctuation">;</span>    <span class="token keyword">char</span> c1<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> Derived <span class="token operator">:</span> Base <span class="token comment" spellcheck="true">// 24 bytes</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> c2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其原因是如果消除了这些额外空间, 将子类对象赋值给父类对象时就可能会在父类对象的额外空间位置赋值, 这改变了程序的语义, 显然是不合适的.</p><h3 id="加上多态"><a href="#加上多态" class="headerlink" title="加上多态"></a>加上多态</h3><p>为了支持动态绑定, 编译器需要在对象中添加虚表指针(vptr), 指向虚表. 虚表中包含类的类型信息和虚函数指针, 值得注意的是, vptr并不是指向虚表的起始地址, 很多时候该地址之前会保存着对象的类型信息, 程序通过此类型信息实现RTTI. 而vptr初值的设置和其所占空间的回收, 则分别由构造函数和析构函数负责, 编译器自动在其中插入相应代码. 这是多态带来的空间负担和时间负担.</p><p>那么vptr放在什么位置呢? 这是由编译器决定的, gcc将其放在对象头部, 这导致对象不能兼容C语言中的struct, 但是在多重继承中, 通过类成员指针访问虚函数会更容易实现. 如果放在对象末尾则可以保证兼容性, 但是就需要在执行期间获得各个vptr在对象中的偏移, 在多重继承中尤其会增加额外负担.</p><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>标准并没有规定不同基类在布局中的顺序, 但是大多数实现按照继承声明顺序安排. 多重继承给程序带来了这些负担:</p><ul><li>将子类地址赋值给基类指针变量时, 如果是声明中的第一个基类, 二者地址相等, 可以直接赋值. 否则, 需要加上一个偏移量, 已获得对应对象的地址.</li><li>上面的直接加偏移并不能保证正确性, 设想子类指针值为0, 直接加上偏移后指向的是一个内容未知的地址. 正确做法应该是将0值赋给基类指针变量. 因此, 需要先判断基类指针是否为0, 再做处理. 而对于引用, 虽然其底层是指针, 但是不需要检查是否为0, 因为引用必须要绑定到一个有效地址, 不可能为0.</li></ul><h3 id="虚拟继承"><a href="#虚拟继承" class="headerlink" title="虚拟继承"></a>虚拟继承</h3><p>主要问题是如何实现只有一个虚拟基类. 主流方案是将虚拟基类作为共享部分, 其他类通过指针等方式指向虚拟基类, 访问时需要通过指针或其他方式获得虚拟基类的地址. gcc的做法是将虚基类放在对象末尾, 在虚表中添加一项, 记录基类对象在对象中的偏移, 从而获得其地址. 我们可以通过gdb调试来看看具体情况.</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> B<span class="token punctuation">{</span>    int64_t i1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">"B::f() called\n"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> D1 <span class="token operator">:</span> <span class="token keyword">virtual</span> B<span class="token punctuation">{</span>    int64_t i2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> D2 <span class="token operator">:</span> <span class="token keyword">virtual</span> B<span class="token punctuation">{</span>    int64_t i3 <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> D3 <span class="token operator">:</span> D1<span class="token punctuation">,</span> D2<span class="token punctuation">{</span>    int64_t i4 <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token punctuation">}</span>d3<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>d3<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">8</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"d3["</span><span class="token operator">&lt;&lt;</span>i<span class="token operator">&lt;&lt;</span><span class="token string">"] = 0x"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>hex<span class="token operator">&lt;&lt;</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>int64_t<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>d3 <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先用g++编译, 载入gdb中</p><pre class="line-numbers language-shell"><code class="language-shell"># g++ main.cc -g# gdb a.out<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>之后, 设置断点, 运行程序, 再通过下面的命令查看对象d3的虚表.</p><pre class="line-numbers language-assembly"><code class="language-assembly">(gdb) p d3$2 = {<D1> = {<B> = {_vptr.B = 0x555555557c58 <vtable for D3+72>, i1 = 1}, _vptr.D1 = 0x555555557c28 <vtable for D3+24>, i2 = 2}, <D2> = { _vptr.D2 = 0x555555557c40 <vtable for D3+48>, i3 = 3}, i4 = 4}(gdb) p /a *((void**)0x555555557c28-3)@10$4 = {0x28,      0x0,      0x555555557d20 <_ZTI2D3>,      0x18,      0xfffffffffffffff0,      0x555555557d20 <_ZTI2D3>,      0x0,      0xffffffffffffffd8,      0x555555557d20 <_ZTI2D3>,      0x555555555446 <B::f()>}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现, _vptr.D1等于<em>(int64_t *)&amp;d3, _vptr.D2等于</em>((int64_t <em>)&amp;d3 + 2), _vptr.B等于</em>((int64_t *)&amp;d3 + 5). 显然分别是各个对象的vptr的值. gdb的第二个命令是打印部分虚表内容, -3指定起始位置, 10指定长度. 可见_vptr.D1指向输出的第四个, _vptr.D2指向输出的第七个, 二者指向位置的地址减3即为对应对象和基类对象的偏移. 同样可以看到前一个是当前对象的类型信息. 如果在C++中直接访问虚表, 可以用下面的代码, 这和上面用gdb打印虚表等效:</p><pre class="line-numbers language-cpp"><code class="language-cpp">int64_t <span class="token operator">*</span>vptr <span class="token operator">=</span> <span class="token punctuation">(</span>int64_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>int64_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>d3<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// D1的虚表地址.</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">7</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"_vptr.D1["</span><span class="token operator">&lt;&lt;</span>i<span class="token operator">&lt;&lt;</span><span class="token string">"] = 0x"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>hex<span class="token operator">&lt;&lt;</span><span class="token operator">*</span><span class="token punctuation">(</span>vptr<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="成员函数的调用"><a href="#成员函数的调用" class="headerlink" title="成员函数的调用"></a>成员函数的调用</h2><h3 id="普通非静态成员函数"><a href="#普通非静态成员函数" class="headerlink" title="普通非静态成员函数"></a>普通非静态成员函数</h3><blockquote><p>C++的设计准则之一就是: nonstatic member function至少必须和一般的nonmember funciton有相同的效率.</p></blockquote><p>为了保证类成员函数的效率, 编译器将对普通非静态成员函数的调用转换为对普通函数的调用. 步骤如下:</p><ol><li>修改函数签名, 添加一个额外的参数(作为第一个参数), 称为this指针. 由此将函数和对象关联起来.</li><li>将函数中对非静态成员的访问改为经过this指针访问.</li><li>将成员函数重写为一个外部函数, 生成一个独一无二的名字(name mangling).</li></ol><h3 id="虚成员函数"><a href="#虚成员函数" class="headerlink" title="虚成员函数"></a>虚成员函数</h3><p>编译器将对虚成员函数的调用转化为通过vptr调用函数. 在虚继承体系下, 任何含有某一虚函数的类, 该函数在虚表中的偏移都是固定的, 因此编译器可以根据函数名在编译期确定函数指针在虚表中的下标. 所以, 虚函数带来的额外负担就是增加一个内存访问.</p><pre class="line-numbers language-cpp"><code class="language-cpp">p<span class="token operator">-</span><span class="token operator">></span><span class="token function">func</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 设其在虚表中的下标为index.</span><span class="token comment" spellcheck="true">// 上面的语句将被转化为</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">></span>vptr<span class="token punctuation">)</span><span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> param<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 这里p等于this指针, 所以将其作为第一个参数.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><p>对静态成员函数的访问将被转化为对普通函数的访问, 由于静态成员不能访问非静态数据成员, 因此不需要添加this指针. 静态函数有下面几个特点:</p><ul><li>不能直接访问类对象的非静态成员.</li><li>不能被声明为const, volatile, virtual.</li><li>可以通过类对象和类名来调用.</li></ul><p>注意一点, 当通过类对象来调用静态成员函数, 并且这个对象是由一个表达式得到时, 虽然不需要执行表达式就能直接调用函数, 但是表达式仍然会被执行(evaluate), 因为此表达式可能会有副作用, 不能被忽略. 例如:</p><pre class="line-numbers language-cpp"><code class="language-cpp">Object <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">static_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// func()仍然会被先执行, func()中可能会有某些不可省略的操作.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="虚成员函数的实现"><a href="#虚成员函数的实现" class="headerlink" title="虚成员函数的实现"></a>虚成员函数的实现</h2><h3 id="单继承-1"><a href="#单继承-1" class="headerlink" title="单继承"></a>单继承</h3><p>前文提到的虚成员函数实现是单继承下的模型, 下面具体说明其实现(注意下面提到的函数都指的是虚函数). 首先, 我们知道每个类都只有一个虚表(多继承和虚继承的类对象有多个vtpr, 指向不同的虚表, 但是实际上这些虚表是一个, vptr只是指向虚表的不同偏移位置), 也就是说相同类型的对象的vptr值是相同的. 当单继承发生时, 子类不仅继承了父类的数据成员, 还继承了函数成员, 前者体现在类对象布局上, 而后者体现在虚表上. 虚表继承的步骤可能包含下面几步:</p><ol><li>将父类虚表中的虚函数指针拷贝到子类虚表的相同下标位置.</li><li>如果子类重写了父类的虚函数, 就将被重写的虚函数的指针修改为对应函数的地址.</li><li>如果子类加入新的虚函数, 就增加虚表容量, 在后面添加新的函数指针.</li></ol><p>从上面可以看到, 单继承下的虚函数效率高, 实现简单, 但是多继承和虚拟继承则要复杂很多.</p><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>多继承的复杂性在于下面几个问题:</p><ul><li>通过第2,3,…个父类的指针访问子类的虚函数.</li><li>通过子类指针访问第2,3,…个父类的虚函数.</li><li>重写的虚函数的返回类型可能和父类的被重写函数的返回类型不一样, 这是标准允许的.</li></ul><p>在讨论上面的问题之前, 先复习一下C++中虚函数相关的知识.</p><p>首先, 明确虚函数重写的概念. 父类声明了一个虚函数, 如果其(直接或间接)子类定义了函数, 与父类虚函数具有相同的:</p><ul><li>名字</li><li>参数类型列表(不包含返回值)</li><li>const/volatile类型, 参考 <a href="https://zhuanlan.zhihu.com/p/61610818/edit#1">[1]</a></li><li>引用类型(三种: 无引用符号, &amp;, &amp;&amp;), 参考 <a href="https://zhuanlan.zhihu.com/p/61610818/edit#1">[1]</a></li></ul><p>则子类函数为虚函数(无论是否声明为virtual), 并且重写了父类的虚函数.</p><p>第二点, 多继承时, 我们通过子类指针可以访问所有父类的函数, 这一点很明确. 但是不能通过一个父类的指针访问其他父类的函数. 看下面的例子:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> B1<span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> B2<span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> D<span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>B1 <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token keyword">new</span> D<span class="token punctuation">;</span>p1<span class="token operator">-</span><span class="token operator">></span><span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// illegal</span>B2 <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token keyword">new</span> D<span class="token punctuation">;</span>p2<span class="token operator">-</span><span class="token operator">></span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// illegal</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也就是说, 通过一个类对象指针调用函数时, 这个函数必须要在这个类或其父类中声明过.</p><p>下面举例说明上面问题的复杂性.(调用虚函数时一定是通过指针或引用, 由于引用本质上是指针, 下面只讨论指针.)</p><p>对于第一个问题, 通过父类指针直接调用子类定义的函数时有两种情况:</p><ul><li>通过第一个基类指针访问时, 直接将指针值作为this指针值传给函数.</li><li>通过第2,3,…个基类指针访问时, 需要调整指针值, 加上/减去一个偏移, 再作为this指针传给函数.</li></ul><p>显然第二种情况下需要<strong>在运行时调整this指针的值</strong>, 因为编译时无法确定指针所指对象的实际类型.</p><p>除此之外, 再考虑一种特殊情况(间接调用子类虚函数):</p><ul><li>对一个父类指针调用delete.</li></ul><p>如果析构函数被声明为virtual, 那么程序将根据指针所指对象的实际类型决定调用哪个析构函数. 这就需要<strong>在运行时需要调整指针的值</strong>, 以保证能够访问正确的vptr, 从而获得对应的析构函数.</p><p>上面两个例子说明第一个问题的复杂性在于需要在运行时根据指针所指对象的实际类型来调整指针的值, 使之指向子类对象. 其他两个问题复杂性的根源也来自于此, 不(会)做详述.</p><p>问题明确了, 解决办法呢? 老实说没怎么看懂, 就不瞎说了, 等以后看明白了再补.</p><h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>其复杂性同样在于指针值的运行时修改, 书中建议不要在虚基类中声明非静态的函数.</p><h2 id="成员函数指针"><a href="#成员函数指针" class="headerlink" title="成员函数指针"></a>成员函数指针</h2><p>成员函数指针只能指向类的非静态成员函数, 使用方法如下:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> C<span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token punctuation">(</span>C<span class="token operator">::</span><span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>C<span class="token operator">::</span>f<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// pointer to member function</span>C c<span class="token punctuation">,</span> <span class="token operator">*</span>cp <span class="token operator">=</span> <span class="token operator">&amp;</span>c<span class="token punctuation">;</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过对象调用函数f</span><span class="token punctuation">(</span>cp<span class="token operator">-</span><span class="token operator">></span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过对象指针调用函数f</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>父类成员函数指针可以直接赋值给子类成员函数指针, 如下面的例子:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> B<span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> D <span class="token operator">:</span> B<span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token punctuation">(</span>B<span class="token operator">::</span><span class="token operator">*</span> bf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>B<span class="token operator">::</span>f<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token punctuation">(</span>D<span class="token operator">::</span><span class="token operator">*</span> df<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> bf<span class="token punctuation">;</span>B bp <span class="token operator">=</span> <span class="token keyword">new</span> D<span class="token punctuation">;</span><span class="token punctuation">(</span>bp<span class="token punctuation">.</span><span class="token operator">*</span>bf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用D::f()</span><span class="token punctuation">(</span>bp<span class="token punctuation">.</span><span class="token operator">*</span>df<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用D::f()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而子类的成员函数指针可以通过static_cast或C风格的类型转换将其转换为父类的成员函数指针.</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token punctuation">(</span>D<span class="token operator">::</span><span class="token operator">*</span> df<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>D<span class="token operator">::</span>f<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token punctuation">(</span>B<span class="token operator">::</span><span class="token operator">*</span> bf1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">void</span> <span class="token punctuation">(</span>B<span class="token operator">::</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span>df<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token punctuation">(</span>B<span class="token operator">::</span><span class="token operator">*</span> bf2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span>B<span class="token operator">::</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>df<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>从上面的例子中可以看到, 成员函数指针仍然支持虚函数机制. 下面看看编译器是如何支持各种虚拟机制的.</p><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>成员函数指针可以指向一个普通函数, 此时她可以是函数地址. 如果指向一个虚函数, 她可以是该函数在虚表中的偏移. 这两种值可以保存在相同类型的变量中, 但是如何区分她们呢? 早期C++限制最多有128个虚函数(应该是限制虚表长度为128吧), 所以偏移值最大为127. 而程序空间起始地址必定大于127, 因此可以通过将指针值和127做”&amp;”(按位与)运算来判断是偏移还是函数地址.</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>pmf<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token number">127</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token operator">*</span>pmf<span class="token punctuation">)</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token operator">-</span><span class="token operator">></span>vptr<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>pmf<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="多继承和虚继承"><a href="#多继承和虚继承" class="headerlink" title="多继承和虚继承"></a>多继承和虚继承</h3><p>支持这些机制的方法就更加复杂了. Stroustrup提出的一种方式是将成员函数指针定义为一个结构体, 包含this指针偏移, 虚基类指针偏移等等. 不过因为对不需要如此复杂机制的函数调用带来额外负担而受到批评. 有的实现对成员函数指针有多种实现方式, 以减少不必要的负担. 比如微软, 对单继承, 多继承, 虚继承就采用不同的方式来实现. 这个地方感觉还是不够具体, 坑先留着, 以后再填.</p><h3 id="inline函数"><a href="#inline函数" class="headerlink" title="inline函数"></a>inline函数</h3><p>在下面的情况下, 一个函数是inline函数:</p><ul><li>声明中包含inline关键字的函数</li><li>当一个函数(成员函数或非成员友元函数)的定义在类内部时</li><li>被声明为constexpr的函数(since C++11)</li></ul><p>inline函数只是一种建议, 建议编译器将对inline函数的调用转换, 但是编译器并不一定会接受该建议, 而且非inline函数也有可能被转换, 这依赖于具体实现. 使用inline函数时要注意下面几点:</p><ul><li><p>inline函数可能会增加生成的文件的大小.</p></li><li><p>inline函数尽可能简单. 减少不必要的局部变量, 否则可能会在结果中产生大量的局部变量.(现在的编译器应该可以优化这个了吧)</p></li><li><p>赋值运算符.</p></li><li><p>显式定义复制赋值运算符,</p></li><li><p>拒绝赋值行为.</p></li></ul><p>对于第三点, C++11之前需要将<em>operator =</em>声明为private, 并且不提供其定义. 而C++11之后, 可以用下面的语句实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp">ClassName<span class="token operator">&amp;</span> ClassName<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> ClassName<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>另外C++11提供的一个语法是可以将其显式声明为default, 虽然用户显式声明之, 但是定义是由编译器隐式生成的.</p><pre class="line-numbers language-cpp"><code class="language-cpp">ClassName<span class="token operator">&amp;</span> ClassName<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> ClassName<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当不需要拒绝赋值时, 就需要考虑是不是显式提供一个<em>operator =</em>. 一个原则是:</p><blockquote><p><strong>只有在默认复制赋值运算符的行为不安全或不正确时, 才需要显式定义复制赋值运算符</strong>.</p></blockquote><p>那么问题来了, 默认复制赋值运算符的行为是什么?</p><h3 id="Trivial-copy-assignment-operator"><a href="#Trivial-copy-assignment-operator" class="headerlink" title="Trivial copy assignment operator"></a>Trivial copy assignment operator</h3><p>当复制赋值运算符满足下面的条件是, 她就是tirivial的:</p><ul><li>不是用户提供的(隐式定义的或声明为default).</li><li>类没有虚函数.</li><li>类没有虚基类.</li><li>直接基类的复制赋值运算符都是trivial的.</li><li>非静态成员的复制赋值运算符是tirvial的.</li></ul><p>满足这个条件的对象的赋值行为是bitwise的, 就如同调用std::memmove一样. 所有与C语言兼容的数据类型都满足此条件. 不满足上面的的条件时, 就采用member-wise复制赋值行为. 以上的bitwise和member-wise就是默认复制赋值运算符的行为.</p><p>另一个问题是存在虚基类时复制赋值运算符可能会多次对基类子对象调用<em>operator =</em>, gcc-8就是如此. 一般含有虚基类的子类的复制赋值运算符定义如下:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> A <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*...*/</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> B <span class="token operator">:</span> <span class="token keyword">virtual</span> A <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*...*/</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> C <span class="token operator">:</span> <span class="token keyword">virtual</span> A <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*...*/</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> D <span class="token operator">:</span> B<span class="token punctuation">,</span> C <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*...*/</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>A<span class="token operator">&amp;</span> A<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*    ... // member copy assignment    */</span><span class="token punctuation">}</span>B<span class="token operator">&amp;</span> B<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>A<span class="token operator">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 直接调用 A::operator =</span>    <span class="token comment" spellcheck="true">/*    ... // member copy assignment    */</span><span class="token punctuation">}</span>C<span class="token operator">&amp;</span> C<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> C<span class="token operator">&amp;</span> c<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>A<span class="token operator">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 直接调用 A::operator =</span>    <span class="token comment" spellcheck="true">/*    ... // member copy assignment    */</span><span class="token punctuation">}</span>D<span class="token operator">&amp;</span> D<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> D<span class="token operator">&amp;</span> d<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>A<span class="token operator">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 直接调用 A::operator =</span>    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>B<span class="token operator">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 间接调用 A::operator =</span>    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>C<span class="token operator">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 间接调用 A::operator =</span>    <span class="token comment" spellcheck="true">/*    ... // member copy assignment    */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++并没有提供类似复制构造函数的语法来保证虚基类只会被复制一次. 所以, 书中建议将虚基类的复制赋值运算符声明为delete, 甚至不要再虚基类中声明数据成员.</p><h2 id="对象析构"><a href="#对象析构" class="headerlink" title="对象析构"></a>对象析构</h2><p>书中提到一个值得注意的问题, 并不是定义了构造函数就需要定义析构函数, 这种”对称”是无意义的. 只有当需要一个析构函数时, 我们才应该显式定义之. 那么什么时候需要呢? 首先要搞清楚析构函数的作用, 她是对象的生命周期的终结, 而函数体内执行的主要是是对对象持有的资源的释放, 例如在构造函数中动态申请的空间. 析构函数的操作与构造函数类似, 但是顺序相反.</p><h3 id="Trivial-destructor"><a href="#Trivial-destructor" class="headerlink" title="Trivial destructor"></a>Trivial destructor</h3><p>类T的析构函数如果满足下面的条件, 就是trivial的:</p><ul><li>析构函数不是用户定义的.(隐式声明或声明为default)</li><li>析构函数非虚.(这就要求父类的虚函数也非虚)</li><li>直接父类的析构函数是trivial的.</li><li>非静态数据成员(数组的数据成员)的析构函数是trivial的.</li></ul><p>trivial析构函数不进行任何操作, 析构时只需要释放对象的空间即可. 所有与C语言兼容的数据类型都是<em>trivial destructible</em>的.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;C++对象模型，启动！&lt;/p&gt;
&lt;h2 id=&quot;对象模型&quot;&gt;&lt;a href=&quot;#对象模型&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://JoyTsing.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
      <category term="读书笔记" scheme="https://JoyTsing.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>喜报加悲报(迫真)</title>
    <link href="https://joytsing.github.io/posts/17028/"/>
    <id>https://joytsing.github.io/posts/17028/</id>
    <published>2024-03-13T12:24:15.000Z</published>
    <updated>2024-03-23T15:37:46.391Z</updated>
    
    <content type="html"><![CDATA[<h2 id="喜报"><a href="#喜报" class="headerlink" title="喜报"></a>喜报</h2><p>为了庆祝我的blog阅读量全面超过我的qq空间访问数量(快一万)，加上真的没想到有这么多人看这个blog，为了更好的访问体验，本人决定自掏腰包，买了腾讯云的域名和对应服务(主要是dns加快访问，众所众知github的dns服务器经常被污染),因此以后的新域名就是<code>https://joytsing.cn/</code>啦，同时还白嫖了腾讯云的SSL证书(爽到)。</p><p><img src="/posts/17028/1.png" alt="迫真购买记录"></p><h2 id="悲报"><a href="#悲报" class="headerlink" title="悲报"></a>悲报</h2><p>换了新域名后访问记录归零啦！😅这下qq空间又赢了，难蚌。。。</p><p><img src="/posts/17028/2.png" alt="迫真归零"></p><p>不过体感上真的快了不少，以前有时候不挂梯子都上不了blog，果然花钱就是好啊(赞赏🤣)，总体上肯定是好的，访问量归零就归零了把，反正有之前的文章记录了之前的访问量，以后会努力产出的(<del>毕竟花了💰</del>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;喜报&quot;&gt;&lt;a href=&quot;#喜报&quot; class=&quot;headerlink&quot; title=&quot;喜报&quot;&gt;&lt;/a&gt;喜报&lt;/h2&gt;&lt;p&gt;为了庆祝我的blog阅读量全面超过我的qq空间访问数量(快一万)，加上真的没想到有这么多人看这个blog，为了更好的访问体验，本人决定自掏腰
      
    
    </summary>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="站点相关" scheme="https://JoyTsing.github.io/tags/%E7%AB%99%E7%82%B9%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>纪念这个特殊时刻(迫真)</title>
    <link href="https://joytsing.github.io/posts/29245/"/>
    <id>https://joytsing.github.io/posts/29245/</id>
    <published>2024-03-12T11:53:46.000Z</published>
    <updated>2024-03-23T15:38:49.598Z</updated>
    
    <content type="html"><![CDATA[<h2 id="迫真喜报"><a href="#迫真喜报" class="headerlink" title="迫真喜报"></a>迫真喜报</h2><p>下图为本人qq空间访问量</p><p><img src="/posts/29245/1.png" alt="qq空间访问量"></p><p>下图为本人blog访问量</p><p><img src="/posts/29245/2.png" alt="blog访问量"></p><p><strong>喜报！本人blog花了4年半的时间超过了我10多年的qq空间浏览量！</strong>😄</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;迫真喜报&quot;&gt;&lt;a href=&quot;#迫真喜报&quot; class=&quot;headerlink&quot; title=&quot;迫真喜报&quot;&gt;&lt;/a&gt;迫真喜报&lt;/h2&gt;&lt;p&gt;下图为本人qq空间访问量&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/29245/1.png&quot; alt=&quot;qq空间访问量
      
    
    </summary>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="站点相关" scheme="https://JoyTsing.github.io/tags/%E7%AB%99%E7%82%B9%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>Go语言之context</title>
    <link href="https://joytsing.github.io/posts/31191/"/>
    <id>https://joytsing.github.io/posts/31191/</id>
    <published>2024-03-12T09:00:46.000Z</published>
    <updated>2024-03-12T09:29:45.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、基本认识"><a href="#一、基本认识" class="headerlink" title="一、基本认识"></a><strong>一、基本认识</strong></h2><p>在介绍具体之前，先列几点关于 Context 接口以及 context 包的基本认识，文章后续也会不断的提及：</p><ol><li>Context 只有两个简单的功能：跨 API 或在进程间 <strong>1)携带键值对、2)传递取消信号</strong>(主动取消、时限/超时自动取消) </li><li><strong>Context 是接口</strong>，可以通过两种方式获得上下文：</li></ol><ul><li>通过 <code>BackGround()</code> 或者 <code>TODO()</code> 创建空上下文</li><li>通过 <code>With</code> 开头函数创建新的上下文，新老上下文是派生关系(derived)</li></ul><p>同样的还有两点，函数间传递的 Context 实际是某结构的地址，不用担心消耗问题，并且相同的 Context 可以多个 goroutine 中使用，是并发安全的。另外，实践中还应该遵循一些规范，这些在 Go 的官方文档中有提及：</p><ul><li>Context 显式传递给每个<strong>需要它</strong>的函数且作为第一个参数，通常命名为 <code>ctx</code>：</li></ul><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">DoSomething</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> arg Arg<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ... use ctx ...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>不传递 <code>nil</code> 作为上下文，如果不确定传递什么，可以通过 <code>context.TODO()</code> 创建一个空上下文</li><li>携带的键值对仅用于传输过程和 API 请求相关的数据（比如 security credentials, tracing information, deadlines, and cancellation signals across API and process boundaries），函数相关的参数应该通过函数参数传递</li></ul><h2 id="二、空的上下文的创建"><a href="#二、空的上下文的创建" class="headerlink" title="二、空的上下文的创建"></a><strong>二、空的上下文的创建</strong></h2><p><strong>空的</strong>上下文的创建有两种方式：</p><ul><li>调用 <code>context.TODO()</code></li><li>调用 <code>context.BackGround()</code></li></ul><p>这两个函数的实现都返回一个 <code>context.emptyCtx</code> 对象的地址：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">var</span> <span class="token punctuation">(</span>    background <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>emptyCtx<span class="token punctuation">)</span>    todo       <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>emptyCtx<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>尽管本质上是一样的，但是区分两个函数是<strong>为了在编写代码时，更清晰地表明开发人员在创建这个上下文的意图</strong>：</p><ul><li><code>TODO()</code>: 不确定要使用哪个上下文时，可以将其用作占位符</li><li><code>BackGround()</code>: 打算启动已知上下文的地方，通常我们都使用这个</li></ul><p>空的上下文没有什么用途。因为 <code>emptyCtx</code> 的 <code>Done()</code>、<code>Err()</code>、<code>Value()</code> 等方法，都返回的 <code>nil</code>。</p><h2 id="三、携带键值对"><a href="#三、携带键值对" class="headerlink" title="三、携带键值对"></a><strong>三、携带键值对</strong></h2><p>通过 <code>WithValue()</code> 函数可以让 Context 实现携带键值对的功能。</p><p><code>WithValue()</code> 函数定义中，传入的 <code>Context</code> 命名为 <code>parent</code>：再次强调，<strong>返回的 Context 与其是派生关系</strong>。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">WithValue</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val any<span class="token punctuation">)</span> Context<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>举一个简单的例子：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    a <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span>              <span class="token comment" spellcheck="true">// 创建上下文</span>    b <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">WithValue</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token string">"k1"</span><span class="token punctuation">,</span> <span class="token string">"v1"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 塞入一个kv</span>    c <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">WithValue</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token string">"k2"</span><span class="token punctuation">,</span> <span class="token string">"v2"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 塞入另外一个kv</span>    d <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">WithValue</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token string">"k1"</span><span class="token punctuation">,</span> <span class="token string">"vo1"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 覆盖一个kv</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"k1 of b: %s\n"</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span><span class="token function">Value</span><span class="token punctuation">(</span><span class="token string">"k1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"k1 of d: %s\n"</span><span class="token punctuation">,</span> d<span class="token punctuation">.</span><span class="token function">Value</span><span class="token punctuation">(</span><span class="token string">"k1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"k2 of d: %s\n"</span><span class="token punctuation">,</span> d<span class="token punctuation">.</span><span class="token function">Value</span><span class="token punctuation">(</span><span class="token string">"k2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码打印的内容：</p><pre class="line-numbers language-text"><code class="language-text">k1 of b: v1k1 of d: vo1k2 of d: v2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>直观的感觉是上下文中的<strong>键值对</strong>可以被<strong>覆盖</strong>，但看一下 <code>WithValue()</code> 的实现，这种表现并不是真正的覆盖了某些值。另外，这里的值可以是任何类型，拿出来使用的时候，需要转换成具体的类型。</p><p><strong>如果不断地通过</strong> <strong><code>WithValue()</code></strong> <strong>同一个的 key 更新上下文，写入和读取就像使用一个栈，后边被设置进去的会被先读取到。</strong> <code>Value()</code> 是一个递归解嵌套的过程，终止条件就是 Context 为 <code>emptyCtx</code> 或找到对应 key。</p><h2 id="四、传递取消信号"><a href="#四、传递取消信号" class="headerlink" title="四、传递取消信号"></a><strong>四、传递取消信号</strong></h2><p>Context 接口要求实现 4 个方法，除了 <code>Value()</code> 是和上边介绍的传递键值对有关之外，其他的三个都和<em>传递取消信号</em>有关。</p><p><strong>上下文是可以结束的</strong>。 可以向使用 <code>context.Context</code> 的任何函数发出信号，表明上下文已结束。而这些函数在收到上下文完成的信号后，以自己的方式处理了有关上下文相关的工作。这种处理方式是高效的：虽然可能因为超时或主动取消，没有得到预期结果，但可以及时停止后续操作、释放出资源来处理别的请求，而不必等待每个函数都有返回。</p><h3 id="Done-——-确定上下文是否完成"><a href="#Done-——-确定上下文是否完成" class="headerlink" title="Done() —— 确定上下文是否完成"></a><strong>Done() —— 确定上下文是否完成</strong></h3><p>无论上下文是因为什么原因结束的，都可以通过调用其 <code>Done()</code> 方法确认：该方法返回一个通道(<code>chan struct{}</code>)，该通道会在上下文完成时被关闭，任何监听该通道的函数都会感应到对应上下文完成的事件。</p><p><strong>【channel 基础知识】通道有一种常见的用法：不会往通道里写入任何东西，在需要发送信号的时候关闭通道，此时接收操作符（receive operator）会立马收到一个管道类型的零值</strong>，在 <a href="https://link.zhihu.com/?target=https%3A//go.dev/ref/spec%23Receive_operator">Go 规范</a>中有详细描述：</p><blockquote><p>A receive operation on a <a href="https://link.zhihu.com/?target=https%3A//go.dev/ref/spec%23Close">closed</a> channel can always proceed immediately, yielding the element type’s <a href="https://link.zhihu.com/?target=https%3A//go.dev/ref/spec%23The_zero_value">zero value</a> after any previously sent values have been received.</p></blockquote><p>通道的等待往往结合 <code>select</code> 一块使用。 select 可以通过多个 case 同时读取多个 channel，如果每个 case 的 channel 都被阻塞则 select 会被阻塞。也会有另外的做法，在 default 做<strong>逻辑</strong>或者 sleep，将 select 放在循环中，不断的重复检查。</p><p>再说回 <code>Done()</code> 方法，它返回一个通道，在 Context 未关闭和关闭的表现：</p><ul><li>没有关闭的时候，<code>case &lt;- ctx.Done()</code> 会阻塞住</li><li>关闭之后，每次 <code>&lt;- ctx.Done()</code> 都会返回一个零值</li></ul><h3 id="Cancel-——-取消上下文"><a href="#Cancel-——-取消上下文" class="headerlink" title="Cancel() —— 取消上下文"></a><strong>Cancel() —— 取消上下文</strong></h3><p>取消上下文是结束上下文最直接、最可控的方式。通过 <code>context.WithCancel</code> 会在 Context 上关联上一个 <code>CancelFunc</code> 类型的<em>取消函数</em>，该类型就是一个 <code>func()</code>，不接受参数也没有返回。</p><p><code>WithCancel()</code> 返回的是第一个参数的 Context 是 <code>cancelCtx</code> 类型的对象。cancelCtx 结构有一个方法是 <code>cancel()</code>，而 WithCancel 返回的第二个就是该方法的封装：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">WithCancel</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">)</span> <span class="token punctuation">(</span>ctx Context<span class="token punctuation">,</span> cancel CancelFunc<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> parent <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"cannot create context from nil parent"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    c <span class="token operator">:=</span> <span class="token function">newCancelCtx</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span>    <span class="token function">propagateCancel</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span>c<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> c<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> Canceled<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="取消上下文的示例"><a href="#取消上下文的示例" class="headerlink" title="取消上下文的示例"></a><strong>取消上下文的示例</strong></h3><p>下边的代码来自 <a href="https://link.zhihu.com/?target=https%3A//pkg.go.dev/context%23WithCancel">Go 官方 context 包文档中 WithCancel 的示例</a>，展示了在函数中使用了 <code>Done()</code> 和 <code>Cancel()</code> 两个方法。</p><pre class="line-numbers language-go"><code class="language-go">gen <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>    dst <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>    n <span class="token operator">:=</span> <span class="token number">1</span>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">{</span>            <span class="token keyword">select</span> <span class="token punctuation">{</span>            <span class="token keyword">case</span> <span class="token operator">&lt;-</span>ctx<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token comment" spellcheck="true">// returning not to leak the goroutine</span>            <span class="token keyword">case</span> dst <span class="token operator">&lt;-</span> n<span class="token punctuation">:</span>                n<span class="token operator">++</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> dst<span class="token punctuation">}</span>ctx<span class="token punctuation">,</span> cancel <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">WithCancel</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">defer</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// cancel when we are finished consuming integers</span><span class="token keyword">for</span> n <span class="token operator">:=</span> <span class="token keyword">range</span> <span class="token function">gen</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>    <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">5</span> <span class="token punctuation">{</span>        <span class="token keyword">break</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中代码具体的执行，做一下简单的说明：</p><ul><li><p><code>gen</code> 是一个函数变量，返回一个 <code>chan int</code></p></li><li><p>使用 <code>BackGround()</code> 创建空白上下文，使用 <code>WithCancel()</code> 关联上一个取消函数 cancel</p></li><li><p>将 cancel 函数加入到 defer 栈</p></li><li><p>调用 <code>gen(ctx)</code>，传入 Context，在 <code>gen()</code> 函数中：</p><ul><li>创建一个 <code>chan int</code>。注意，这个 channel 的size 是0，也就是只有下游准备好接收的时候，才能塞入，这个之前文章有介绍过</li><li>启动一个 goroutine，不断的循环在两个 channel 上读写：等待上下文结束通道关闭；等待目的通道可以写，写入递增数字</li><li>返回目的通道 <code>dst</code></li></ul></li><li><p><code>for</code> 循环利用 <code>range</code> 不断的从 dst 通道中读出数字并打印</p><ul><li>在读出并打印出 5 之后，退出</li></ul></li><li><p>defer 栈中的 cancel 函数被拿出来执行，ctx 被取消，上下文结束</p></li><li><p>gen() 函数中启动的 goroutine 中的函数接收到 <code>ctx.Done()</code> 中得到的 0，函数结束退出</p></li></ul><p>这个示例，使用<em>取消上下文</em>的目的是为了<strong>防止 goroutine 的泄漏</strong>：如果没有上下文的结束信号，外部的for循环退出之后，goroutine 运行的函数会会一直阻塞在 select，对应的资源也不会被释放。</p><h2 id="五、带时限-超时的取消"><a href="#五、带时限-超时的取消" class="headerlink" title="五、带时限/超时的取消"></a><strong>五、带时限/超时的取消</strong></h2><p>上边介绍的 <code>WithCancel()</code> 派生出来的上下文，只能主动去取消上下文。context 包中还提供了两个可以带时间<em>自动取消上下文</em>的函数：</p><ul><li>通过 <code>context.WithDeadline()</code> 设置上下文需要完成的截止时间，在到达截止时间之后回自动结束</li><li>通过 <code>context.WithTimeout()</code> 设置上下文的超时时间，在到达超时之后自动结束</li></ul><p>其实，两个函数作用大同小异，<code>WithTimeout()</code> 也是在当前时间上加了一个超时时间，然后调用 <code>WithDeadline()</code> 函数实现的：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">WithTimeout</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">,</span> timeout time<span class="token punctuation">.</span>Duration<span class="token punctuation">)</span> <span class="token punctuation">(</span>Context<span class="token punctuation">,</span> CancelFunc<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">WithDeadline</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="超时取消示例"><a href="#超时取消示例" class="headerlink" title="超时取消示例"></a><strong>超时取消示例</strong></h3><p>这里仍然使用 context 官方文档上的一个示例，做了一点修改：</p><pre class="line-numbers language-go"><code class="language-go">ctx<span class="token punctuation">,</span> cancel <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">WithTimeout</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// Even though ctx will be expired, it is good practice to call its</span>    <span class="token comment" spellcheck="true">// cancellation function in any case. Failure to do so may keep the</span>    <span class="token comment" spellcheck="true">// context and its parent alive longer than necessary.</span>    <span class="token keyword">defer</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">select</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token operator">&lt;-</span>time<span class="token punctuation">.</span><span class="token function">After</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">:</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"overslept"</span><span class="token punctuation">)</span>    <span class="token keyword">case</span> <span class="token operator">&lt;-</span>ctx<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>ctx<span class="token punctuation">.</span><span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对上边的代码做一下简单解释：</p><ul><li>创建空上下文，通过 <code>WithTimeout()</code> 创建一个带 10ms 超时的上下文</li><li>将得到的 cancel 函数压入 defer 栈中</li><li><code>select</code> 等待两个事件：一个是1秒之后的超时，另一个是等待上下文结束</li><li>由于上下文超时时间远小于定时时钟，所以会走到 <code>fmt.Println(ctx.Err())</code></li><li>select 结束，函数结束前执行 defer 栈中的 cancel 函数</li></ul><p>如注释：<strong>尽管上下文会在超时结束取消，但是作为一种良好实践，在任何场景中，都应该调用一下 cancel 函数</strong>。</p><p>从另外角度理解，<code>CancelFunc()</code> 可以被多次调用，不会像多次 close channel 一样会 panic。</p><h3 id="Err-——-获取上下文错误"><a href="#Err-——-获取上下文错误" class="headerlink" title="Err() —— 获取上下文错误"></a><strong>Err() —— 获取上下文错误</strong></h3><p>上边的示例代码会走到外边的 <code>&lt;-ctx.Done()</code> 分支，会打印 <code>ctx.Err()</code> 得到的错误(DeadlineExceeded)：</p><blockquote><p>context deadline exceeded</p></blockquote><p>Context 接口要求的实现一个方法是 <code>Err()</code>：</p><ul><li>在 <code>Done()</code> 返回的 channel 没有被关闭的时候，调用 Err() 一定会返回 nil</li><li>在 <code>Done()</code> 关闭之后，<code>Err()</code> 会返回 Canceled 或 DeadlineExceeded 两种错误</li><li>BackGround() 创建的 emptyCtx 在任何时候都会返回 nil</li></ul><p><code>Canceled</code> 和 <code>DeadlineExceeded</code> 是两个<strong>包级别的变量</strong>，是 error 接口。在 cancelCtx.cancel 方法参数中，可以指定使用何种错误取消上下文。实现上，<code>WithDeadline()</code> 等创建的上下文，在 <code>time.AfterFunc</code> 中调用取消的时候会填入 DeadlineExceeded，否则主动取消会填入Canceled。</p><h2 id="六、Context-树与-Cancel-传播"><a href="#六、Context-树与-Cancel-传播" class="headerlink" title="六、Context 树与 Cancel 传播"></a><strong>六、Context 树与 Cancel 传播</strong></h2><p>我们多次在前文中看到了：Context 的创建过程，是先通过 <code>BackGround()</code> 获得空上下文，然后在此基础上，调用 With 开头的4个函数，不断的派生上下文。</p><p>context 包文档中的这段话也是如此的描述，其中提到的是 <strong>optionally</strong>，这意味着<strong>并不是每个函数都需要派生上下文，而是在确实需要的情况下可以派生，不然可以直接使用当前的上下文</strong>：</p><blockquote><p>The chain of function calls between them must propagate the Context, optionally replacing it with a derived Context created using WithCancel, WithDeadline, WithTimeout, or WithValue. When a Context is canceled, all Contexts derived from it are also canceled.</p></blockquote><p>因为一个 Context 可以派生出多个 child Context，因此所有的 Context 会形成一棵树，而这棵树的根就是 <code>BackGround()</code> 的空上下文。</p><h3 id="ctx-WithValue-ctx-key-val-的过程"><a href="#ctx-WithValue-ctx-key-val-的过程" class="headerlink" title="ctx = WithValue(ctx, key, val) 的过程"></a><strong><code>ctx = WithValue(ctx, key, val)</code></strong> <strong>的过程</strong></h3><p>虽然前边提到过，通过 With 开头的函数，可以派生出新的上下文，但是实际使用中，<strong>并不需要每个中间派生的上下文都需要存到一个变量中</strong>。</p><p>下边的代码也很常见：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">for</span> key<span class="token punctuation">,</span> val <span class="token operator">:=</span> <span class="token keyword">range</span> paramMap <span class="token punctuation">{</span>    ctx <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">WithValue</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这个场景中，中间派生出的 Context 并没有用途，但是随着一次次的 <code>ctx = WithValue(ctx, key, val)</code> 会将中间派生的 Context 保存在新的 Context 中，因此最后一个 ctx 还存在的情况下，中间的 Context 的引用计数没有归零，所以也不会被清理掉。</p><h3 id="为什么需要传播-cancel"><a href="#为什么需要传播-cancel" class="headerlink" title="为什么需要传播 cancel"></a><strong>为什么需要传播 cancel</strong></h3><p>这里的传播和之前提到的传递信号是两个概念：</p><ul><li>传递信号是指创建 goroutine 调用函数，使用同一个上下文，调用方和被调函数都能够主动结束、或感知到结束</li><li>传播是指由派生关系的上下文，当父上下文结束之后，会将派生的上下文也 cancel 掉</li></ul><blockquote><p>Calling the CancelFunc cancels the child and its children, removes the parent’s reference to the child, and stops any associated timers. Failing to call the CancelFunc leaks the child and its children until the parent is canceled or the timer fires. The go vet tool checks that CancelFuncs are used on all control-flow paths.</p></blockquote><p><strong>上下文通过直接调用 Cancel 或者通过定时/截止时间间接调用 Cancel 来结束上下文，都会传递给该上下文的所派生出的所有上下文，使得这些上下文结束。</strong></p><p><strong>这个功能非常容易理解</strong>：以一个 HTTP 请求处理函数为例，假设会多次查询 MySQL，如果我们整个请求处理的超时设置为1秒（会创建一个上下文 parent，WithTimeout 1s），每次 MySQL 请求的超时设置为 800ms(会派生出上下文 childN，WithTimeout 800ms)，当第N个 MySQL 请求还没有达到超时，但是总的超时时间已经达到1秒时，parent 会被自动 cancel 掉，这时候当前的 MySQL 查询（以及后续未执行的查询，但是还没有派生上下文），都没有意义，因此的这个派生的上下文childN 会在 parent canel 的过程中也被 cancel 掉。</p><h3 id="Cancel-传播示例"><a href="#Cancel-传播示例" class="headerlink" title="Cancel 传播示例"></a><strong>Cancel 传播示例</strong></h3><p>以上边解释为什么要是传递给派生上下文的场景为例，写一个简单的例子：</p><pre class="line-numbers language-go"><code class="language-go">ctx<span class="token punctuation">,</span> cancel <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">WithTimeout</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token keyword">defer</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>slowFunc <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    childCtx<span class="token punctuation">,</span> cancel <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">WithTimeout</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> <span class="token number">800</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span>    <span class="token keyword">defer</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"query No. %d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>    <span class="token keyword">select</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token operator">&lt;-</span>childCtx<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"child context err: %v\n"</span><span class="token punctuation">,</span> childCtx<span class="token punctuation">.</span><span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>    <span class="token keyword">select</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token operator">&lt;-</span>ctx<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"parent context err: %v\n"</span><span class="token punctuation">,</span> ctx<span class="token punctuation">.</span><span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token keyword">default</span><span class="token punctuation">:</span>        <span class="token function">slowFunc</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> i<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行上边代码，会在 1秒钟之后结束，其屏幕输出结果是：</p><pre class="line-numbers language-text"><code class="language-text">query No. 0child context err: context deadline exceededquery No. 1child context err: context deadline exceededparent context err: context deadline exceeded<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>将for移入default会是什么情况？</strong>上边的代码中，每执行完一次查询，都去检查上下文是否完成，如果为未完成走 default 分支。如果将 for 循环移入 default 或者移入 slowFunc 中，结果会有什么异同呢？</p><ul><li>也会在1秒钟之后结束</li><li>会调用5次 <code>slowFunc</code>，传入 i 从0到5，会打印 5 次 query 提示</li><li>不会打印到 parent context err：因为 select 只有一次，导致第一次进入default 之后就执行完毕了，而没有机会再进入到 <code>&lt;-ctx.Done()</code> 的分支</li></ul><h2 id="七、进程间-Context-间传递"><a href="#七、进程间-Context-间传递" class="headerlink" title="七、进程间 Context 间传递"></a><strong>七、进程间 Context 间传递</strong></h2><p>context 包文档中第一句就介绍，Context 可以携带信息在跨越 API 边界或在进程间传递。前面的例子大多是说在 API 调用的时候传递 ctx 的例子，接下来介绍一下进程间传递信息的示例和实现。</p><p>在进程间传递上下文，需要 RPC 协议的支持。比如较流行的 gRPC 就支持上下文的传递，包括：</p><ul><li>默认的 context 中部分信息，比如超时时间</li><li>用户自己需要传递的元数据信息 metadata</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、基本认识&quot;&gt;&lt;a href=&quot;#一、基本认识&quot; class=&quot;headerlink&quot; title=&quot;一、基本认识&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、基本认识&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;在介绍具体之前，先列几点关于 Context 接口以及 context 包
      
    
    </summary>
    
    
      <category term="Go" scheme="https://JoyTsing.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="https://JoyTsing.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Google Cpp Style Guide</title>
    <link href="https://joytsing.github.io/posts/45891/"/>
    <id>https://joytsing.github.io/posts/45891/</id>
    <published>2024-03-11T11:54:01.000Z</published>
    <updated>2024-03-20T16:20:45.456Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Google C++ Style Guide是一份不错的C++编码指南，直接看下图快速掌握规范的重点内容。不过规范毕竟是人定的，记得活学活用。</p><ol><li>保持一致也非常重要，如果你在一个文件中新加的代码和原有代码风格相去甚远的话，这就破坏了文件本身的整体美观也影响阅读，所以要尽量避免。</li><li>一些条目往往有例外，比如下面这些，所以本图不能代替文档，有时间还是把PDF认真阅读一遍吧。</li></ol><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p><img src="/posts/45891/1.png" alt></p><p>对于高质量的工程，一般会做到：</p><ul><li><p>代码简洁精炼，美观，可读性好，高效率，高复用，可移植性好，高内聚，低耦合，没有冗余，不符合这些原则，必须特别说明。</p></li><li><p>规范性，代码有规可循。特殊排版、特殊语法、特殊指令，必须特别说明。</p></li></ul><h2 id="2-文件排版"><a href="#2-文件排版" class="headerlink" title="2.文件排版"></a><strong>2.文件排版</strong></h2><h3 id="2-1-包含头文件"><a href="#2-1-包含头文件" class="headerlink" title="2.1.包含头文件"></a><strong>2.1.包含头文件</strong></h3><ul><li>a)系统头文件与用户头文件包含区分开，不交叉。</li><li>b)系统头文件，稳定的目录结构，应采用包含子路径方式。#include”sub/test.h”</li><li>c)系统头文件应用：#include</li><li>d)自定义同文件应用：#include “xxx.h”</li><li>e)只引用需要的头文件。</li><li>f)将所有#include的文件名视为大小写敏感。能使用声明的情况下，使用声明。</li></ul><h3 id="2-2-h和cpp文件"><a href="#2-2-h和cpp文件" class="headerlink" title="2.2. h和cpp文件"></a><strong>2.2. h和cpp文件</strong></h3><ul><li>a)头文件命名为<em>.h，内联文件命名为</em>.inl；C++文件命名为*.cpp</li><li>b)文件名用不要用无意义的名称：例如XImage.cpp，命名方式在系统中应该统一。</li><li>c)头文件除了特殊情况，应使用#ifdef控制块。</li><li>d)头文件#endif应采用行尾注释。</li><li>e)头文件，首先是包含全局函数，其次是宏定义代码块，然后是全局变量，全局常量，类型定义，类定义，内联部分。</li><li>f)cpp文件，包含指令，宏定义，全局变量，函数定义。</li></ul><h3 id="2-3-文件结构"><a href="#2-3-文件结构" class="headerlink" title="2.3.文件结构"></a><strong>2.3.文件结构</strong></h3><ul><li>a)文件应包含文件头注释和内容。</li><li>b)函数体类体之间原则上用1个空行，特殊情况下可用一个或者不需要空行。</li></ul><h3 id="2-4-空行"><a href="#2-4-空行" class="headerlink" title="2.4.空行"></a><strong>2.4.空行</strong></h3><p>文件头、控制块，#include部分、宏定义部分、class部分、全局常量部分、全局变量部分、函数和函数之间，用一个空行。</p><hr><h2 id="3-注释方面"><a href="#3-注释方面" class="headerlink" title="3.注释方面"></a><strong>3.注释方面</strong></h2><h3 id="3-1-文件头注释"><a href="#3-1-文件头注释" class="headerlink" title="3.1.文件头注释"></a><strong>3.1.文件头注释</strong></h3><p>作者，文件名称，文件说明，生成日期(可选)，提供模板</p><h3 id="3-2-函数注释"><a href="#3-2-函数注释" class="headerlink" title="3.2.函数注释"></a><strong>3.2.函数注释</strong></h3><ul><li>a)关键函数必须写上注释，说明函数的用途，提供注释模板。</li><li>b)特别函数参数，需要说明参数的目的，由谁负责释放等等。</li><li>c)除了特别情况，注释写在代码之前，不要放到代码行之后。</li><li>d)对每个#else或#endif给出行末注释。</li><li>e)关键代码注释，包括但不限于：赋值，函数调用，表达式，分支等等。</li><li>f)尚未实现完整的代码，或者需要进一步优化的代码，应加上 // TODO …或者同等含义的注释。</li><li>g)调试的代码，加上注释 // DEBUG或者同等含义的注释</li><li>h)需要引起关注的代码，加上注释 // NOTE …或者同等含义的注释</li><li>i)对于较大的代码块结尾，如for,while,do等，可加上 // end for|while|do或者同等含义的注释。</li></ul><hr><h2 id="4-命名方面"><a href="#4-命名方面" class="headerlink" title="4.命名方面"></a><strong>4.命名方面</strong></h2><h3 id="4-1-原则"><a href="#4-1-原则" class="headerlink" title="4.1.原则"></a><strong>4.1.原则</strong></h3><ul><li>a)同一性：在编写一个子模块或派生类的时候，要遵循其基类或整体模块的命名风格，保持命名风格在整个模块中的同一性。</li><li>b)标识符组成：标识符采用英文单词或其组合，应当直观且可以拼读，可望文知意，用词应当准确，避免用拼音命名。</li><li>c)最小化长度 &amp;&amp; 最大化信息量原则：在保持一个标识符意思明确的同时，应当尽量缩短其长度。</li><li>d)避免过于相似：不要出现仅靠大小写区分的相似的标识符，例如”i”与”I”，”function”与”Function”等等。</li><li>e)避免在不同级别的作用域中重名：程序中不要出现名字完全相同的局部变量和全局变量，尽管两者的作用域不同而不会发生语法错误，但容易使人误解。</li><li>f)正确命名具有互斥意义的标识符：用正确的反义词组命名具有互斥意义的标识符，如：”minValue” 和 “maxValue”，”getName()” 和”setName()” ….</li><li>g)避免名字中出现数字编号：尽量避免名字中出现数字编号，如Value1,Value2等，除非逻辑上的确需要编号。</li></ul><h3 id="4-2-函数"><a href="#4-2-函数" class="headerlink" title="4.2.函数"></a><strong>4.2.函数</strong></h3><ul><li>a)类的函数名称应采用首字母小写类似handleXXX命名，例如：handleColor；不推荐采用例如 HandleColor；除了标准c风格代码，标准模板库，不推荐用下划线，例如，handle_color。容易与系统函数标准函数重名，导致不能目视而知其作用范围。</li><li>b)函数参数比较多时，应考虑用结构代替，参数不能超过6个。</li><li>c)如果不能避免函数参数比较多，应在排版上可考虑相似含义的参数占用一行，参数名竖向对齐。甚至每个参数一行。</li></ul><h3 id="4-3-变量"><a href="#4-3-变量" class="headerlink" title="4.3.变量"></a><strong>4.3.变量</strong></h3><p>a)变量命令方式应采用驼峰命令方式。例如handleColor；不同类型变量打头方式见表 1，当类型叠加时，应以最能够表现变量类型的打头方式，例如int类型的指针，应采用p打头；指针类型的数组，应采用a打头，数组的指针因采用p打头。</p><p>表 1 变量类型打头表</p><table><thead><tr><th align="left">类型</th><th align="left">打头</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">int</td><td align="left">n</td><td align="left">如nValue</td></tr><tr><td align="left">bool</td><td align="left">b</td><td align="left"></td></tr><tr><td align="left">long</td><td align="left">l</td><td align="left">如lValue</td></tr><tr><td align="left">float</td><td align="left">f</td><td align="left"></td></tr><tr><td align="left">double</td><td align="left">d</td><td align="left"></td></tr><tr><td align="left">std::string/QString</td><td align="left">str</td><td align="left"></td></tr><tr><td align="left">std::list/QList</td><td align="left">lst</td><td align="left">如lstValues</td></tr><tr><td align="left">std::vector/QVector</td><td align="left">vec</td><td align="left"></td></tr><tr><td align="left">std::map/QMap</td><td align="left">map</td><td align="left"></td></tr><tr><td align="left">枚举</td><td align="left">e</td><td align="left"></td></tr><tr><td align="left">指针</td><td align="left">p</td><td align="left"></td></tr><tr><td align="left">引用</td><td align="left">r</td><td align="left"></td></tr><tr><td align="left">数组</td><td align="left">a</td><td align="left"></td></tr></tbody></table><p>b)不同作用范围的变量应在类型前面添加前缀加下划线，不同作用范围的前缀见表 2。</p><p>表 2变量作用范围前缀表</p><table><thead><tr><th align="left">类型</th><th align="left">前缀</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">成员变量</td><td align="left">m_</td><td align="left">如m_nValue</td></tr><tr><td align="left">全局变量</td><td align="left">g_</td><td align="left">如g_lValue</td></tr><tr><td align="left">静态变量</td><td align="left">s_</td><td align="left">如s_pValuePtr，静态全局和静态成员也应s为前缀</td></tr></tbody></table><h3 id="4-4-类型名"><a href="#4-4-类型名" class="headerlink" title="4.4.类型名"></a><strong>4.4.类型名</strong></h3><ul><li>a)类名和结构体首字母大写，例如MyClass，MyStruct。</li><li>b)类和对象名应是名词。</li><li>c)枚举定义以E_打头，且应全大写，使用下划线分割不同的引文单词，如E_TYPE_STUDENT_INFO，各枚值名字应为枚举类型名打头，例如E_TYPE_STUDENT_INFO_NUMBER。</li><li>d)宏定义以DEF_打头，且应全大写，使用下划线分割不同的引文单词，如DEF_TYPE_ID。</li></ul><hr><h3 id="4-5-风格兼容性"><a href="#4-5-风格兼容性" class="headerlink" title="4.5.风格兼容性"></a><strong>4.5.风格兼容性</strong></h3><p>a)对于移植的或者开源的代码，可以沿用原有风格，不用C++的命名规范。</p><hr><h3 id="5-1-Tab和空格"><a href="#5-1-Tab和空格" class="headerlink" title="5.1.Tab和空格"></a>5.1.Tab和空格</h3><ul><li>a)每一行开始处的缩进只能用4个空格，不能用Tab，输入内容之后统一用空格。</li><li>b)在代码行的结尾部分不能出现多余的空格。</li><li>c)不要在”::”,”-&gt;”,”.”前后加空格。</li><li>d)不要在”，”,”；”之前加空格。</li></ul><h3 id="5-2-类型定义"><a href="#5-2-类型定义" class="headerlink" title="5.2.类型定义"></a><strong>5.2.类型定义</strong></h3><ul><li>a)类，结构，枚举，联合：大括号另起一行</li><li>b)函数体的{需要新起一行，在{之前的缩进应与上一级对齐。</li><li>c)除了特别情况，函数体内不能出现两个空行。</li><li>d)除了特别情况，函数体内不能宏定义指令，除非该宏定义仅能在该函数内使用。</li><li>e)在一个函数体内，逻揖上密切相关的语句之间不加空行，其它地方应加空行分隔。</li></ul><h3 id="5-3-代码块"><a href="#5-3-代码块" class="headerlink" title="5.3.代码块"></a><strong>5.3.代码块</strong></h3><ul><li>a)”if”、”for”、”while”、”do”、”try”、”catch” 等语句自占一行，执行语句不得紧跟其后。不论执行语句有多少都要加 “{ }” 。这样可以防止书写和修改代码时出现失误。</li><li>b)”if”、”for”、”while”、”do”、”try”、”catch” 的括号和表达式，括号可紧挨关键字，这样强调的是表达式。</li></ul><h3 id="5-4-代码行"><a href="#5-4-代码行" class="headerlink" title="5.4.代码行"></a><strong>5.4.代码行</strong></h3><ul><li>a)一行代码只做一件事情，如只定义一个变量，或只写一条语句。这样的代码容易阅读，并且方便于写注释。</li><li>b)多行变量定义，为了追求代码排版美观，可将变量竖向对齐。</li><li>c)代码行最大长度宜控制在一定个字符以内，能在当前屏幕内全部可见为宜。建议80个。</li></ul><h3 id="5-5-宏"><a href="#5-5-宏" class="headerlink" title="5.5.宏"></a><strong>5.5.宏</strong></h3><ul><li>a)不要用分号结束宏定义。</li><li>b)能使用函数来解决的问题，不要使用宏，方便调式。</li></ul><h3 id="5-6-goto"><a href="#5-6-goto" class="headerlink" title="5.6.goto"></a><strong>5.6.goto</strong></h3><ul><li>a)不要用goto。</li></ul><hr><h2 id="6-类型"><a href="#6-类型" class="headerlink" title="6.类型"></a><strong>6.类型</strong></h2><ul><li>a)定义指针和引用时*和&amp;紧跟变量名。</li><li>b)尽量避免使用浮点数，除非必须。</li><li>c)用typedef简化程序中的复杂语法。</li><li>d)避免定义无名称的类型。例如： enum TState { EIdle, EActive };</li><li>e)少用union，如果一定要用，则采用简单数据类型成员。</li><li>f)用enum取代(一组相关的)常量。</li><li>g)不要使用魔鬼数字。</li><li>h)尽量用引用取代指针。</li><li>i)定义变量完成后立即初始化，勿等到使用时才进行，在需要使用到变量的时候才定义变量。</li><li>j)如果有更优雅的解决方案，不要使用强制类型转换。例如dynamic_cast，尽量使用多态。</li></ul><hr><h2 id="7-表达式"><a href="#7-表达式" class="headerlink" title="7.表达式"></a><strong>7.表达式</strong></h2><ul><li>a)避免在表达式中用赋值语句。</li><li>b)避免对浮点类型做等于或不等于判断。</li><li>c)不能将枚举类型进行运算后再赋给枚举变量。</li><li>d)在循环过程中不要修改循环计数器。</li><li>e)检测空指针，用 if( p )</li><li>f)检测非空指针，用 if( ! p )</li></ul><hr><h2 id="8-函数"><a href="#8-函数" class="headerlink" title="8.函数"></a><strong>8.函数</strong></h2><h3 id="8-1-引用"><a href="#8-1-引用" class="headerlink" title="8.1.引用"></a><strong>8.1.引用</strong></h3><ul><li>a)引用类型作为返回值：函数必须返回一个存在的对象。</li><li>b)引用类型作为参数：调用者必须传递一个存在的对象。</li></ul><h3 id="8-2-返回值"><a href="#8-2-返回值" class="headerlink" title="8.2.返回值"></a><strong>8.2.返回值</strong></h3><ul><li>a)除开void函数，构造函数，析构函数，其它函数必须要有返回值。在函数的实现中，每个分支必须显示返回return。</li><li>b)当函数返回引用或指针时，用文字描述其有效期。</li></ul><h3 id="8-3-内联函数"><a href="#8-3-内联函数" class="headerlink" title="8.3.内联函数"></a><strong>8.3.内联函数</strong></h3><ul><li>a)内联函数应将函数体放到类体外。</li><li>b)只有简单的函数才有必要设计为内联函数，复杂业务逻辑的函数不要这么做。</li><li>c)虚函数不要设计为内联函数。</li></ul><h3 id="8-4-函数参数"><a href="#8-4-函数参数" class="headerlink" title="8.4.函数参数"></a><strong>8.4.函数参数</strong></h3><ul><li>a)只读取该参数的内容，不对其内容做修改，用常量引用。</li><li>b)修改参数内容，或需要通过参数返回，用非常量引用。</li><li>c)简单数据类型用传值方式。</li><li>d)复杂数据类型用引用或指针方式。</li><li>e)输入参数排在前面，输出参数排在后面，默认参数除外。</li><li>f)除通用库函数，尽量不使用默认参数。</li></ul><hr><h2 id="9-类"><a href="#9-类" class="headerlink" title="9.类"></a><strong>9.类</strong></h2><h3 id="9-1-整体结构"><a href="#9-1-整体结构" class="headerlink" title="9.1.整体结构"></a><strong>9.1.整体结构</strong></h3><ul><li>a)按照 public, protected, private 的顺序分块。哪一块没有，就直接忽略。</li><li>b)每一块中，按照下面顺序排列</li></ul><p>1)typedef，enum，struct，class 定义的嵌套类型</p><p>2)常量</p><p>3)构造函数</p><p>4)析构函数</p><p>5)成员函数,含静态成员函数</p><p>6)数据成员,含静态数据成员</p><ul><li>c).cpp 文件中，函数的实现尽可能和声明次序一致。</li></ul><h3 id="9-2-构造函数"><a href="#9-2-构造函数" class="headerlink" title="9.2.构造函数"></a><strong>9.2.构造函数</strong></h3><ul><li>a)构造函数的初始化列表，应和类里成员变量的顺序一致。</li><li>b)初始化列表中的每个项，应独占一行。</li><li>c)避免出现用一个成员初始化另一个成员。</li><li>d)构造函数应初始化所有成员，尤其是指针。</li><li>e)不要在构造函数和析构函数中抛出异常。</li></ul><h3 id="9-3-纯虚函数"><a href="#9-3-纯虚函数" class="headerlink" title="9.3.纯虚函数"></a><strong>9.3.纯虚函数</strong></h3><p>接口类的虚函数应设计为纯虚函数。</p><h3 id="9-4-构造和析构函数"><a href="#9-4-构造和析构函数" class="headerlink" title="9.4.构造和析构函数"></a><strong>9.4.构造和析构函数</strong></h3><ul><li>a)如果类可以继承，则应将类析构函数设计为虚函数。</li><li>b)如果类不允许继承，则应将类析构函数设计为非虚函数。</li><li>c)如果类不能被复制，则应将拷贝构造函数和赋值运算符设计为私有的。</li><li>d)如果为类设计了构造函数，则应有析构函数。</li></ul><h3 id="9-5-成员变量"><a href="#9-5-成员变量" class="headerlink" title="9.5.成员变量"></a><strong>9.5.成员变量</strong></h3><ul><li>a)尽量避免使用mutable(mutex除外)和volatile。</li><li>b)尽量避免使用公有成员变量。</li></ul><h3 id="9-6-成员函数"><a href="#9-6-成员函数" class="headerlink" title="9.6.成员函数"></a><strong>9.6.成员函数</strong></h3><ul><li>a)努力使类的接口少而完备。</li><li>b)尽量使用常成员函数代替非常量成员函数，const函数</li><li>c)除非特别理由，绝不要重新定义非虚函数。</li><li>d)如果是子类型重写父类的虚函数，应该在函数声明后面添加override，让编译器来检查是否重新定义非虚函数。C++11</li><li>e)不想被子类重写的虚函数，函数声明后面添加final。C++11</li></ul><h3 id="9-7-继承"><a href="#9-7-继承" class="headerlink" title="9.7.继承"></a><strong>9.7.继承</strong></h3><ul><li>a)继承必须满足IS-A的关系，HAS-A应采用包含。</li><li>b)虚函数不要采用默认参数。</li><li>c)除非特别需要，应避免设计大而全的虚函数，虚函数功能要单一。</li><li>d)除非特别需要，避免将基类强制转换成派生类。</li></ul><h2 id="10-错误处理"><a href="#10-错误处理" class="headerlink" title="10.错误处理"></a><strong>10.错误处理</strong></h2><ul><li>a)释放内存完成后将指针赋空，避免出现野指针。</li><li>b)使用指针前进行判断合法性，应考虑到为空的情况的处理，除非明显的组合模式。</li><li>c)使用数组时，应先判断索引的有效性，处理无效的索引的情况。</li><li>d)卫句风格：先处理所有可能发生错误的情况，再处理正常情况。</li></ul><hr><h2 id="11-性能"><a href="#11-性能" class="headerlink" title="11.性能"></a><strong>11.性能</strong></h2><ul><li><p>a)头文件中使用前向声明代替头文件包含。Class M;</p></li><li><p>b)尽量在for循环之前，先写计算估值表达式。</p></li><li><p>c)尽量避免在循环体内部定义对象。</p></li><li><p>d)避免对象拷贝，尤其是代价很高的对象拷贝。</p></li><li><p>e)避免生成临时对象，尤其是大的临时对象。</p></li><li><p>f)注意大尺寸对象数组。</p></li><li><p>g)尽量使用标准库中封装的算法。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Google C++ Style Guide是一份不错的C++编码指南，直接看下图快速掌握规范的重点内容。不过规范毕竟是人定的，记得活学活用
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Cpp 中如何优雅进行 enum 到 string 的转换</title>
    <link href="https://joytsing.github.io/posts/30790/"/>
    <id>https://joytsing.github.io/posts/30790/</id>
    <published>2024-03-11T11:27:58.000Z</published>
    <updated>2024-03-20T16:13:18.592Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这里不介绍非侵入式的写法，具体想要了解的话可以观看<a href="https://zhuanlan.zhihu.com/p/680412313">这篇文章</a>,这里仅介绍通过宏写法来进行转换的情况。</p><h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><p>这里拿minilog的log-level定义来介绍，首先肯定是需要按照等级先进行定义：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">define</span> MINILOG_FOREACH_LOG_LEVEL(f) \  f(trace) f(debug) f(info) f(critical) f(warn) f(error) f(fatal)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>后续如果要修改只用修改这一处就行了，优点是一劳永逸，不存在维护额外开销的问题，当然缺点也有，比如在写server的时候遇到过需要将传入的指令进行与操作整合的情况，这种类型的情况下就无法使用宏的方法，或者说需要额外处理。</p><p>在定义好各个level后就需要进行enum的声明了：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">log_level</span> <span class="token operator">:</span> std<span class="token operator">::</span>uint8_t <span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">define</span> _FUNCTION(name) name,</span>  <span class="token function">MINILOG_FOREACH_LOG_LEVEL</span><span class="token punctuation">(</span>_FUNCTION<span class="token punctuation">)</span><span class="token macro property">#<span class="token directive keyword">undef</span> _FUNCTION</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体来说就是将log_level在enum中用宏函数进行了展开，避免无用代码的编写。接下来是文章的核心，怎么进行enum和string的相互转化。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">inline</span> std<span class="token operator">::</span>string <span class="token function">log_level_name</span><span class="token punctuation">(</span>log_level level<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">switch</span> <span class="token punctuation">(</span>level<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">define</span> _FUNCTION(name) \  case log_level::name: \    return #name;</span>    <span class="token function">MINILOG_FOREACH_LOG_LEVEL</span><span class="token punctuation">(</span>_FUNCTION<span class="token punctuation">)</span><span class="token macro property">#<span class="token directive keyword">undef</span> _FUNCTION</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token string">"unknown"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">inline</span> log_level <span class="token function">log_level_from_name</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string_view lev<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">define</span> _FUNCTION(name) \  if (lev == #name) return log_level::name;</span>  <span class="token function">MINILOG_FOREACH_LOG_LEVEL</span><span class="token punctuation">(</span>_FUNCTION<span class="token punctuation">)</span><span class="token macro property">#<span class="token directive keyword">undef</span> _FUNCTION</span>  <span class="token keyword">return</span> log_level<span class="token operator">::</span>info<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>非常方便，相当于自动维护对应的代码，事实上，clang 在定义TokenKind的时候，就是这么做的，具体的案例请参考。由于 clang 要适配多种语言前端，最后总计的TokenKind有几百个之多。如果不这样做，可想而知，进行Token的增加和修改会十分困难。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;这里不介绍非侵入式的写法，具体想要了解的话可以观看&lt;a href=&quot;https://zhuanlan.zhihu.com/p/6804123
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>More Effective-CPP:读书笔记</title>
    <link href="https://joytsing.github.io/posts/59007/"/>
    <id>https://joytsing.github.io/posts/59007/</id>
    <published>2024-03-11T06:30:01.000Z</published>
    <updated>2024-03-20T16:21:03.033Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>虽然早在4年前的大二时期就看过并且实践在工程作业里面，但一直没有一个完整的记录，想着别的几本都有了干脆补全一下吧，个人总结，难免会出现一些不太准确的地方，欢迎各位指正。</p><h2 id="条款1：仔细区别-pointers-和-references"><a href="#条款1：仔细区别-pointers-和-references" class="headerlink" title="条款1：仔细区别 pointers 和 references"></a>条款1：仔细区别 pointers 和 references</h2><ul><li>reference 不能为 null。</li><li>一般而言，当你需要考虑“不指向任何对象”的可能性时，或是考虑“在不同事件指向不同对象”的能力时，你就应该采用 pointer。</li><li>当你知道你需要指向某个东西，而且绝不会改变指向其他东西，或是当你实现一个操作符而其语法需求无法由 pointers 达成，你就应该选择 reference。任何其他时候，请采用 pointers。</li></ul><h2 id="条款2：最好使用-C-转型操作符"><a href="#条款2：最好使用-C-转型操作符" class="headerlink" title="条款2：最好使用 C++ 转型操作符"></a>条款2：最好使用 C++ 转型操作符</h2><h3 id="1-static-cast"><a href="#1-static-cast" class="headerlink" title="1 static_cast"></a>1 static_cast</h3><p>使用 <code>static_cast&lt;type&gt;(expression)</code>代替 (type)expression</p><h3 id="2-const-cast"><a href="#2-const-cast" class="headerlink" title="2 const_cast"></a>2 const_cast</h3><p>将某个对象的常量性去除掉</p><h3 id="3-dynamic-cast"><a href="#3-dynamic-cast" class="headerlink" title="3 dynamic_cast"></a>3 dynamic_cast</h3><ul><li>利用<code>dynamic_cast</code>，将“指向 base class objects 的 pointers 或 references”转型为“指向derived（或 sibling base）class objects 的 pointers 或 references”， 并得知转型是否成功。</li><li>如果转型失败，会以一个 null 指针（当转型对象是指针）或一个 exception （当转型对象是 reference）表现出来。</li></ul><h3 id="4-reinterpret-cast"><a href="#4-reinterpret-cast" class="headerlink" title="4 reinterpret_cast"></a>4 reinterpret_cast</h3><p>最常用用途是转换“函数指针”类型，对应C里面的强制转换</p><h2 id="条款3：绝对不要以多态（polymorphically）方式处理数组"><a href="#条款3：绝对不要以多态（polymorphically）方式处理数组" class="headerlink" title="条款3：绝对不要以多态（polymorphically）方式处理数组"></a>条款3：绝对不要以多态（polymorphically）方式处理数组</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">base</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">base</span><span class="token punctuation">(</span><span class="token keyword">int</span> p1<span class="token punctuation">,</span> <span class="token keyword">int</span> p2<span class="token punctuation">)</span>        <span class="token operator">:</span><span class="token function">p1</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">p2</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> p1<span class="token punctuation">,</span> p2<span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> p1 <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> p2 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">derived</span> <span class="token operator">:</span> <span class="token keyword">public</span> base<span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">derived</span><span class="token punctuation">(</span><span class="token keyword">int</span> p1<span class="token punctuation">,</span> <span class="token keyword">int</span> p2<span class="token punctuation">,</span> <span class="token keyword">int</span> p3<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">base</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">p3</span><span class="token punctuation">(</span>p3<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> p3<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override<span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> p1 <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> p2 <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> p3 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>base array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">"th item's size is: "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    base    <span class="token function">b1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span>  <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    derived <span class="token function">d1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>   <span class="token number">2</span><span class="token punctuation">,</span>  <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    base    <span class="token function">b2</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">,</span>  <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    derived <span class="token function">d2</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span>   <span class="token number">5</span><span class="token punctuation">,</span>  <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    base array<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>d1<span class="token punctuation">,</span> b1<span class="token punctuation">,</span> d2<span class="token punctuation">,</span> b2<span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sizeof(base): "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>b1<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\tsizeof(derived): "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>d1<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// sizeof(base): 8 sizeof(derived): 12</span>    <span class="token function">print</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 0th item's size is: 8    1, 2</span>    <span class="token comment" spellcheck="true">// 1th item's size is: 8    10, 20</span>    <span class="token comment" spellcheck="true">// 2th item's size is: 8    4, 5</span>    <span class="token comment" spellcheck="true">// 3th item's size is: 8    40, 50</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你交给printBaseArray函数一个包含derived对象组成的数组，你的编译器就会被误导。这种情况下它仍假设数组中的每一个元素的大小是base的大小，但其实每一个元素的大小是不一样的。</p><h2 id="条款4：非必要不提供-default-constructor"><a href="#条款4：非必要不提供-default-constructor" class="headerlink" title="条款4：非必要不提供 default constructor"></a>条款4：非必要不提供 default constructor</h2><ul><li>在一个完美的世界中，凡可以“合理地从无到有生成对象”的 classes，都应该内含 default constructors，“必须有某些外来信息才能生成对象” 的 classes，则不必拥有 default constructors。</li><li>在进退维谷的情况下，最后一个考虑点和 virtual base classes 有关。 Virtual base classes 如果缺乏 default constructors，与之合作将会是一种刑法。</li><li>添加无意义的 constructors，也会影响 classes 的效率。</li></ul><h2 id="条款5：对定制的-“类型转换函数”-保持警觉"><a href="#条款5：对定制的-“类型转换函数”-保持警觉" class="headerlink" title="条款5：对定制的 “类型转换函数” 保持警觉"></a>条款5：对定制的 “类型转换函数” 保持警觉</h2><p>下述代码根本的原因在于，在你从未打算也未预期的情况下，此函数可能会被调用，而其结果可能是不正确.不直观的程序行为很难发现调试。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Rational</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Rational</span><span class="token punctuation">(</span><span class="token keyword">int</span> numerator <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">int</span> denominator <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">operator</span> <span class="token keyword">double</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token keyword">friend</span> std<span class="token operator">::</span>ostream <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>std<span class="token operator">::</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> Rational <span class="token operator">&amp;</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> numerator<span class="token punctuation">;</span>    <span class="token keyword">int</span> denominator<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Rational<span class="token operator">::</span><span class="token function">Rational</span><span class="token punctuation">(</span><span class="token keyword">int</span> numerator<span class="token punctuation">,</span> <span class="token keyword">int</span> denominator<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>numerator <span class="token operator">=</span> numerator<span class="token punctuation">;</span>     <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>denominator <span class="token operator">=</span> denominator<span class="token punctuation">;</span><span class="token punctuation">}</span>Rational<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">double</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>numerator<span class="token punctuation">)</span><span class="token operator">/</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>denominator<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>std<span class="token operator">::</span>ostream <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>std<span class="token operator">::</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> Rational <span class="token operator">&amp;</span>r<span class="token punctuation">)</span> <span class="token punctuation">{</span>    os <span class="token operator">&lt;&lt;</span> r<span class="token punctuation">.</span>numerator <span class="token operator">&lt;&lt;</span> <span class="token string">"/"</span> <span class="token operator">&lt;&lt;</span> r<span class="token punctuation">.</span>denominator <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> os<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   Rational <span class="token function">r</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> r<span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// 1/2</span>   <span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">0.5</span> <span class="token operator">*</span> r<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 0.25</span>   std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> d <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假设你忘了为 Rational 写一个 operator&lt;&lt;，你或许以为上述的 std::cout &lt;&lt; r; 不会成功，因为没有适当的 operator&lt;&lt; 可以调用。但是你错了，你的编译器面对上述动作，发现不存在任何 operator&lt;&lt; 可以接受一个 Rational，但它会想尽各种办法（包括找出一系列可接受的隐式类型转换）让函数调用动作成功。即进行了隐式类型转换，导致（非预期）的函数被调用。</p><p>解决这个问题，可以采用:</p><ul><li>以功能对等的另一个函数取代类型转换操作符</li><li>使用关键字 explicit</li></ul><h2 id="条款6：区别-increment-decrement-操作符的前置-prefix-和后置-postfix-形式"><a href="#条款6：区别-increment-decrement-操作符的前置-prefix-和后置-postfix-形式" class="headerlink" title="条款6：区别 increment/decrement 操作符的前置(prefix)和后置(postfix)形式"></a>条款6：区别 increment/decrement 操作符的前置(prefix)和后置(postfix)形式</h2><pre class="line-numbers language-c++"><code class="language-c++">class UPInt{public:    UPInt(int i)                    //提供一个构造函数        :val(i){};    UPInt& operator++();            //前置++    const UPInt operator++(int);    //后置++    UPInt& operator--();            //前置--    const UPInt operator--(int);    //后置--    UPInt& operator+=(const int i); //+=操作符    //...    int val;};//前置++，返回referenceUPInt &UPInt::operator++() {    *this += 1;    return *this;}//后置++，返回一个const对象const UPInt UPInt::operator++(int) {    UPInt oldValue = *this;    ++(*this);    return oldValue;}//前置--，返回referenceUPInt &UPInt::operator--() {    *this += -1;    return *this;}//后置--，返回一个const对象const UPInt UPInt::operator--(int) {    UPInt oldValue = *this;    --(*this);    return oldValue;}//+=操作符，看需求，这里返回一个 referenceUPInt &UPInt::operator+=(const int i) {    this->val = this->val + i;    return *this;}//这里帮助打印UPint里的val值void print(const UPInt &up) { std::cout << up.val <<std::endl; }int main(){    UPInt i(0);    print(i);       // 0    print(++i);     // 1    print(i++);     // 1    print(i);       // 2    print(--i);     // 1    print(i--);     // 1    print(i);       // 0}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为什么后置++或–返回的是一个const值呢？如果不是一个const值的话，那么下面的动作就是合法的。</p><pre class="line-numbers language-cpp"><code class="language-cpp">    UPInt <span class="token function">i</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    i<span class="token operator">++</span><span class="token operator">++</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>处理用户定制类型时，应尽可能使用前置式 increment，因为它天生体质较佳。</p><h2 id="条款7：千万不要重载-amp-amp-，-和-操作符"><a href="#条款7：千万不要重载-amp-amp-，-和-操作符" class="headerlink" title="条款7：千万不要重载 &amp;&amp;，|| 和 , 操作符"></a>条款7：千万不要重载 &amp;&amp;，|| 和 , 操作符</h2><p>C++ 对于“真假值表达式”采用所谓的“骤死式”评估方式。意思是一旦该表达式的真假值确定，即使表达式中还有部分尚未检验，整个评估工作仍结束。</p><p>如果你决定重载 operator&amp;&amp; 或 operator||，你必须知道，你正在从根本层面改变整个游戏规则，因为从此“函数调用”语义会取代“骤死式”语义。</p><p>如果你将 &amp;&amp; 或 || 重载，就没有办法提供程序员预期（甚至依赖）的某种行为模式。</p><p><strong>如果你没有什么好的理由将某个操作符重载，就不要去做。</strong></p><h2 id="条款8：了解各种不同意义的-new-和-delete"><a href="#条款8：了解各种不同意义的-new-和-delete" class="headerlink" title="条款8：了解各种不同意义的 new 和 delete"></a>条款8：了解各种不同意义的 new 和 delete</h2><h3 id="new-operator"><a href="#new-operator" class="headerlink" title="new operator"></a>new operator</h3><p>举个例子，当你写出这样的代码，就是使用了所谓的 new operator</p><p>string *ps = new string(“Hello World!”);<br>分配足够的内存，用来放置某类型的对象<br>调用一个constructor，为上一步中分配的内存中的那个对象设定初始值。<br>new operator 总是做这两件事，无论如何你不能改变其行为。</p><h3 id="operator-new"><a href="#operator-new" class="headerlink" title="operator new"></a>operator new</h3><p>举个例子，函数 operator new 通常声明如下</p><blockquote><p>void *operator new(size_t size);</p></blockquote><p>上述返回值类型是 void*。此函数返回一个指针，直线一块原始的、未设初始值的内存。函数中的 size_t 参数表示需要分配多少内存。你可以将 operator new 重载，加上额外的参数，但第一参数的类型必须总是 size_t。</p><p>举个例子</p><blockquote><p>void *rawMemory = operator new(sizeof(string))</p></blockquote><p>这里的 operator new 将返回指针，指向一块足够容纳一个 string 对象的内存。和 malloc 一样 operator new 的唯一任务就是分配内存。</p><h3 id="placement-new"><a href="#placement-new" class="headerlink" title="placement new"></a>placement new</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">new</span><span class="token punctuation">(</span>内存地址<span class="token punctuation">)</span> 类<span class="token punctuation">(</span><span class="token punctuation">[</span>实参<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">base</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">base</span><span class="token punctuation">(</span><span class="token keyword">int</span> p1<span class="token punctuation">)</span>        <span class="token operator">:</span><span class="token function">p1</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> p1<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>base<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 4</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 1</span>    <span class="token keyword">char</span> <span class="token operator">*</span>memory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>base<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// address: 0xdb3278</span>    base <span class="token operator">*</span>b1 <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>memory<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">base</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// address:0xdb3278    val:e8 03 00 00     03e8    = 1000</span>    base <span class="token operator">*</span>b2 <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>memory<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">base</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// address:0xdb327c    val:02 00 00 00     02      = 2</span>    base <span class="token operator">*</span>b3 <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>memory<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">base</span><span class="token punctuation">(</span><span class="token number">9999999</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// address:0xdb3280    val:7f 96 98 00     98967f  = 9999999</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简而言之，如果你有一些分配好的内存，且需要在上面构建对象。那么可以使用 placement new。</p><table><thead><tr><th></th><th>分配内存</th><th>构造</th></tr></thead><tbody><tr><td>new operator</td><td>√</td><td>√</td></tr><tr><td>operator new</td><td>√</td><td>×</td></tr><tr><td>placement new</td><td>×</td><td>√</td></tr></tbody></table><p>至于delete也是同理，不在这过多描述(很少使用)。</p><h2 id="条款9：利用-deconstructors-避免泄露资源"><a href="#条款9：利用-deconstructors-避免泄露资源" class="headerlink" title="条款9：利用 deconstructors 避免泄露资源"></a>条款9：利用 deconstructors 避免泄露资源</h2><ul><li>使用析构函数</li><li>使用智能指针</li></ul><p>当然，到了现在一般更喜欢依赖RAII来对资源进行自动管理，也更加优雅。</p><h2 id="条款10：在-constructors-内阻止资源泄露"><a href="#条款10：在-constructors-内阻止资源泄露" class="headerlink" title="条款10：在 constructors 内阻止资源泄露"></a>条款10：在 constructors 内阻止资源泄露</h2><ul><li>C++ 只会析构已构造完成的对象</li><li>对于在构造期抛出 exceptions 的对象，C++不会自动清理，所以你必须设计你的 constructors 使它们能够在那种情况下也能自我清理。</li><li>一个更好的解答是，接受条款9的忠告，将point data members所指对象视为资源，交给局部对象管理（即使用智能指针）。</li></ul><h2 id="条款11：禁止异常（exceptions）流出-destructors-之外"><a href="#条款11：禁止异常（exceptions）流出-destructors-之外" class="headerlink" title="条款11：禁止异常（exceptions）流出 destructors 之外"></a>条款11：禁止异常（exceptions）流出 destructors 之外</h2><p>两种情况下 destructor <strong>会被调用</strong>：</p><ul><li>当对象在正常状态下被销毁，也就是当它离开了它的生存空间(scope)或是被明确地删除。</li><li>当对象被 exception 处理机制——也就是 exception 传播过程中的 stk-unwinding(栈展开)机制——销毁。</li></ul><p><strong>危害</strong>：</p><ul><li>如果控制权基于 exception 的因素离开 destructor，而此时正有另一个 exception 处于作用状态，C++ 会调用 terminate 函数。此函数会将你的程序结束掉——它会立刻动手，甚至不等局部对象被销毁。</li></ul><p>全力阻止 exceptions 传出 destructors 的好处：</p><ul><li>避免 terminate 函数在 exception 传播过程的栈展开(stack-unwinding)机制中被调用。</li><li>协助确保 destructors 完成其应该完成的所有事情。</li></ul><p>换句话说，一定要保证析构函数是nonexpection的。</p><h2 id="条款12：了解“抛出一个-exception”-与-“传递一个参数”-或-“调用一个虚函数”-之间的差异"><a href="#条款12：了解“抛出一个-exception”-与-“传递一个参数”-或-“调用一个虚函数”-之间的差异" class="headerlink" title="条款12：了解“抛出一个 exception” 与 “传递一个参数” 或 “调用一个虚函数” 之间的差异"></a>条款12：了解“抛出一个 exception” 与 “传递一个参数” 或 “调用一个虚函数” 之间的差异</h2><p>函数参数和 exceptions 的传递方式有3种:</p><ul><li>by value</li><li>by reference</li><li>by pointer</li></ul><p>区别1：当你调用一个函数，控制器最终会回到调用端（除非函数失败以至于无法返回），但是当你抛出一个 exception ，控制权不会再回到抛出端。而且一个对象被抛出作为 exception 时，总是会发生复制(copy)。</p><p>区别2：“抛出exception”比“传递参数”慢。因为“exception objects 必定会造成复制行为”这一事实，所以解释了“抛出exception”常常比“传递参数”慢。复制动作永远是以静态类型为本。</p><p>区别3：函数调用过程中将一个临时对象传递给一个 non-const reference 参数是不允许的，但是对 exceptions 则属合法。一个被抛出的对象（必为临时对象）可以简单地用 by reference 的方式捕捉，不需要以 by reference-to-const 的方式捕捉。</p><p>区别4：“抛出exception” 比 “传递函数参数”多构造一个“被抛出物”的副本（并于稍后析构），千万不要抛出一个指向局部对象的指针，因为该局部对象会在 exception 传离其 scope 时被销毁，因此 catch 子句会获得一个指向“已被销毁的对象”的指针。这正时“义务性复制(copy)规则”的设计要避免的情况。</p><p>区别5：“自变量传递”与“exception 传播”两动作有着互异的做法。</p><p>区别6：catch 子句总是依出现顺序做匹配尝试。</p><p><strong>总结</strong>：“传递对象到函数去，或是以对象调用虚函数”和“将对象抛出成为一个exception”之间，有3个主要差异</p><ul><li>exception objects 总是会被复制，如果以 by value 方式捕捉，它们甚至被复制两次。至于传递给函数参数的对象则不一定得复制。</li><li>被抛出成为 exceptions 的对象，其被允许的类型转换动作，比“被传递到函数去”的对象少。</li><li>catch 子句以其“出现于源代码的顺序”被编译器检验对比，其中第一个匹配成功者变执行；而当我们以某对象调用一个虚函数，被选中执行的是那个“与对象类型最佳吻合”的函数，不论它是不是源代码所列的第一个。</li></ul><h2 id="条款13：以-by-reference-方式捕捉-exceptions"><a href="#条款13：以-by-reference-方式捕捉-exceptions" class="headerlink" title="条款13：以 by reference 方式捕捉 exceptions"></a>条款13：以 by reference 方式捕捉 exceptions</h2><ul><li>避开 exception objects 的切割（slicing）的问题</li><li>保留捕捉标准 exceptions 的能力</li><li>约束了exception objects 需被复制的次数</li></ul><h2 id="条款14：明智运用-exception-specifications"><a href="#条款14：明智运用-exception-specifications" class="headerlink" title="条款14：明智运用 exception specifications"></a>条款14：明智运用 exception specifications</h2><p>告诉编译器函数不引发任何异常。 但是，在 std:c++14 模式下，如果函数确实引发异常，这可能会导致未定义的行为。 因此，建议使用 noexcept 运算符：</p><h2 id="条款15：了解异常处理（exception-handling）的成本"><a href="#条款15：了解异常处理（exception-handling）的成本" class="headerlink" title="条款15：了解异常处理（exception handling）的成本"></a>条款15：了解异常处理（exception handling）的成本</h2><p>只要你用上那么一个，也就是说一旦你决定捕捉 exceptions，你就得付出那样的成本。不同的编译器以不同的方法实现 try 语句块，代码大约整体膨胀 5%~10%，执行速度亦下降这个数。</p><p><strong>为了将此成本最小化，你应该避免非必要的 try 语句块</strong>。</p><h2 id="条款16：谨记-80-20-法则"><a href="#条款16：谨记-80-20-法则" class="headerlink" title="条款16：谨记 80-20 法则"></a>条款16：谨记 80-20 法则</h2><p>软件的证一性能几乎总是由其构成要素（代码）的一小部分决定。</p><h2 id="条款17：考虑使用-lazy-evaluation（缓式评估）"><a href="#条款17：考虑使用-lazy-evaluation（缓式评估）" class="headerlink" title="条款17：考虑使用 lazy evaluation（缓式评估）"></a>条款17：考虑使用 lazy evaluation（缓式评估）</h2><ul><li>Reference Counting（引用计数）：在你真正需要之前，不必着急为某物做一个副本——可避免非必要的对象复制</li><li>区分读和写：可区别 operator[]的读和写的动作</li><li>Lazy Fatching（缓式取出）：可避免非必要的数据库读取动作</li><li>Lazy Expression Evaluation（表达式缓评估）：可避免非必要的数值计算动作</li></ul><p><strong>总结</strong><br>如果你的计算是必要的，lazy evaluation 并不会为你的程序节省人和工作或任何时间。只有当“你的软件被要求执行某些计算，而那些计算其实可以避免”的情况下，lazy evaluation 才有用处。</p><h2 id="条款18：分期摊还预期的计算成本"><a href="#条款18：分期摊还预期的计算成本" class="headerlink" title="条款18：分期摊还预期的计算成本"></a>条款18：分期摊还预期的计算成本</h2><p>简单来说，就是使用缓存。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">findCubicleNumber</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>employeeName<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">typedef</span> map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> CubicleMap<span class="token punctuation">;</span>    <span class="token keyword">static</span> CubicleMap cubes<span class="token punctuation">;</span>    CubicleMap<span class="token operator">::</span>iterator it <span class="token operator">=</span> cubes<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>employeeName<span class="token punctuation">)</span>  <span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>it <span class="token operator">==</span> cubes<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> cubicle <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   <span class="token comment" spellcheck="true">// 这里逻辑处理</span>        cubes<span class="token punctuation">[</span>employeeName<span class="token punctuation">]</span> <span class="token operator">=</span> cubicle<span class="token punctuation">;</span>        <span class="token keyword">return</span> cubicle<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后一个语句返回 (*it).second 而非传统的 it-&gt;second，为什么？答案关系到STL实行的规矩。简单地说，iterator本身是对象，不是指针，所以并不能保证 -&gt; 可施行于 it 身上。但STL明确要求 . 和 * 对 iterators 必须有效，所以 (*it).second 虽然语法上笨拙，却保证能够有效运行。</p><h2 id="条款19：了解临时对象的来源"><a href="#条款19：了解临时对象的来源" class="headerlink" title="条款19：了解临时对象的来源"></a>条款19：了解临时对象的来源</h2><p>临时对象可能很耗成本，所以你应该尽可能消除它们。这本书写成的时候比较早，到现在有了std::move和移动构造，移动赋值，就转换成了左值和右值的问题。</p><h2 id="条款20：协助完成“返回值优化-RVO"><a href="#条款20：协助完成“返回值优化-RVO" class="headerlink" title="条款20：协助完成“返回值优化(RVO)"></a>条款20：协助完成“返回值优化(RVO)</h2><p>函数返回对象，背后隐藏着 constructor 和 destructor。如果是为了行为正确而不得不这么做，是可以返回一个对象的；否则就不要那么做。</p><p>有人企图采用某些方法消除 by-value的返回方式</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const</span> Rational<span class="token operator">*</span> <span class="token keyword">operator</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>Rational a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>Rational c <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>a <span class="token operator">*</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样会使得整个调用流程显得不自然，同时调用者也需要手动删除此函数返回的指针，不然会导致资源泄露。</p><p>有些人试图返回 references, 于是就有了</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//h</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//cpp</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">{</span>    Rational <span class="token function">result</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span><span class="token function">numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> rhs<span class="token punctuation">.</span><span class="token function">numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lhs<span class="token punctuation">.</span>denominator <span class="token operator">*</span> rhs<span class="token punctuation">.</span><span class="token function">denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//use</span>Rational a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>Rational c <span class="token operator">=</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这看起来似乎没有问题，但是当局部变量 result 离开了 const Rational&amp; operator* 之后，就被自动销毁了。所以 const Rational&amp; operator* 实际返回的 reference 指向的是一个不在存活的对象。</p><h2 id="条款21：利用重载技术（overload）避免隐式类型转换"><a href="#条款21：利用重载技术（overload）避免隐式类型转换" class="headerlink" title="条款21：利用重载技术（overload）避免隐式类型转换"></a>条款21：利用重载技术（overload）避免隐式类型转换</h2><p>假设我们有这么一个结构</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">UPInt</span><span class="token punctuation">{</span>    <span class="token function">UPInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">UPInt</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>UPInt <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> UPInt<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> UPInt<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当我们调用</p><pre class="line-numbers language-cpp"><code class="language-cpp">UPInt upi1<span class="token punctuation">,</span> upi2<span class="token punctuation">,</span> upi3<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>upi3 <span class="token operator">=</span> upi1 <span class="token operator">+</span> upi2<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 成功，调用了 UPInt operator+(const UPInt&amp; lhs, const UPInt&amp; rhs);</span>upi3 <span class="token operator">=</span> upi1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 成功，生成了临时对象</span>upi3 <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> upi1<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 成功，生成了临时对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 upi1 + 1 与 1 + upi1 都会进行隐式类型转换，这里会有一点成本。为了避免隐式类型转换带来的开销，我们可以重载 UPInt operator+ 这个函数</p><pre class="line-numbers language-cpp"><code class="language-cpp">UPInt <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> UPInt<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>UPInt <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> UPInt<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>来消除类型转换。但是我们不能狂热过度写出下面的函数</p><blockquote><p>UPInt operator+(const int lhs, const int rhs);</p></blockquote><p>这会导致可怕的灾难。</p><h2 id="条款22：考虑以操作符符合形式（op-）取代其独身形式（op）"><a href="#条款22：考虑以操作符符合形式（op-）取代其独身形式（op）" class="headerlink" title="条款22：考虑以操作符符合形式（op=）取代其独身形式（op）"></a>条款22：考虑以操作符符合形式（op=）取代其独身形式（op）</h2><p>到目前为止 C++ 并不考虑在 operator+，operator= 和 operator+= 之间设立任何互动关系。如果你希望这三个操作符都存在并且有着你所期望的互动关系，你必须自己实现。</p><p><strong>三个于效率有关的情况需要注意</strong></p><ol><li>一般而言，符合操作符比起对应的独身版本效率高，因为独身版通常必须返回一个新对象，而我们必须因此负担一个临时对象的构造成本和析构成本。至于复合版本则是直接将结果写入其左端自变量，所以不需要产生一个临时对象来放置返回值。</li><li>如果同提供某个操作符的复合形式和独身形式，便允许你的客户在效率与便利性之间做取舍。</li></ol><p>下面的两个例子中，第二个虽然更容易理解，但是却比第一个多构造了一个临时对象。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//Good</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">const</span> T <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">T</span><span class="token punctuation">(</span>lhs<span class="token punctuation">)</span> <span class="token operator">+</span> rhs<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Not Good</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">const</span> T <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">{</span>     T <span class="token function">result</span><span class="token punctuation">(</span>lhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result <span class="token operator">+</span><span class="token operator">=</span> rhs<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>身为一位程序库设计者，你应该为两者都提供。</p><h2 id="条款23：考虑使用其他程序库"><a href="#条款23：考虑使用其他程序库" class="headerlink" title="条款23：考虑使用其他程序库"></a>条款23：考虑使用其他程序库</h2><p>由于不同的程序库将效率、扩充性、移植性、类型安全性等的不同设计具体化，有时候你可以找找看是否存在另一个功能相近的程序库而其在效率上有较高的设计权重。</p><h2 id="条款24：了解虚函数、多重继承、虚基类和运行类型的成本"><a href="#条款24：了解虚函数、多重继承、虚基类和运行类型的成本" class="headerlink" title="条款24：了解虚函数、多重继承、虚基类和运行类型的成本"></a>条款24：了解虚函数、多重继承、虚基类和运行类型的成本</h2><ol><li>虚函数<br>当一个虚函数被调用，执行的代码必须对应于“调用者（对象）的动态类型”。大部分编译器使用所谓的 virtual tables 和 virtual table pointers —— 此二者通常被简写为 vtabls 和 vptrs。</li></ol><p><strong>虚函数成本：</strong></p><ul><li>你必须为每个拥有虚函数的 class 耗费一个 vtable 空间，其大小视虚函数的个数（包括继承而来的）而定。</li><li>你必须在每一个拥有虚函数的对象内付出“一个额外指针”的代价。调用一个虚函数的成本，基本上和”通过一个函数指针来调用函数“相同。虚函数本身并不构成性能上的瓶颈。</li><li>你事实上废弃了 inlining。虚函数不应该 inlined。因为 inline 意味“在编译期，将调用端的调用动作被调用函数的函数本身取代”，而 virtual 则意味着“等待，知道运行时期才知道哪个函数被调用”。</li></ul><ol start="2"><li><p>多重继承<br>多重继承问我导致 virtual base classes（虚拟基类）的需求。<br>在 non-virtual base class 的情况下，如果 derived class 在其 base class 有多条继承路径，则此 base class 的 data members 会在每一个 derived class object 体内复制滋生，每一个副本对应 “derived class 和 base class 之间的一条继承路线”。</p></li><li><p>虚拟继承<br>让base class 成为 virtual，可以消除这样的复制现象，<a href="https://blog.csdn.net/qq_45615577/article/details/115345490">学习资料</a>。</p></li><li><p>RTTI<br><a href="https://zhuanlan.zhihu.com/p/509453699">RTTI</a> 让我们得以在运行时获得 objects 和 classes 的相关信息，他们被存发在类型为 type_info 的对象内。一个 class 只需要一份 RTTI 信息就好，但是必须有某种办法让其下属的每个对象都能取用它。只有当某种类型拥有至少一个虚函数，才保证我们能够检验该类型对象的动态类型。</p></li></ol><table><thead><tr><th>性质</th><th>对象大小增加</th><th>Class数据量增加</th><th>Inlining 几率低</th></tr></thead><tbody><tr><td>虚函数 Virtual Functions</td><td>是</td><td>是</td><td>是</td></tr><tr><td>多重继承Multiple Inheritance</td><td>是</td><td>是</td><td>否</td></tr><tr><td>虚拟基类 Virtual Base Classes</td><td>往往如此</td><td>有时候</td><td>否</td></tr><tr><td>运行时期类型辨识</td><td>RTTI</td><td>否</td><td>是</td></tr></tbody></table><h2 id="条款25：将-constructor-和-non-member-functions-虚化"><a href="#条款25：将-constructor-和-non-member-functions-虚化" class="headerlink" title="条款25：将 constructor 和 non-member functions 虚化"></a>条款25：将 constructor 和 non-member functions 虚化</h2><p>constructor 虚化其实不是真正的虚化构造函数，书中所讲不是很好理解，可以参考下面的例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Shape</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>                 <span class="token comment" spellcheck="true">// A virtual destructor</span>  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// A pure virtual function</span>  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">move</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// ...</span>  <span class="token keyword">virtual</span> Shape<span class="token operator">*</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// Uses the copy constructor</span>  <span class="token keyword">virtual</span> Shape<span class="token operator">*</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// Uses the default constructor</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Circle</span> <span class="token operator">:</span> <span class="token keyword">public</span> Shape <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  Circle<span class="token operator">*</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">const</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// Covariant Return Types; see below</span>  Circle<span class="token operator">*</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// Covariant Return Types; see below</span>  <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Circle<span class="token operator">*</span> Circle<span class="token operator">::</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">Circle</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>Circle<span class="token operator">*</span> Circle<span class="token operator">::</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">Circle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过调用 clone() 或 create()虚函数来间接地调用构造函数与拷贝构造。即虚假的构造函数与真正的构造函数。</p><p>而至于non-member functions 的虚化十分容易：写一个虚函数做实际工作，再写一个什么都不做的非虚函数，只负责调用虚函数。</p><h2 id="条款26：限制某个class所能产生的对象数量"><a href="#条款26：限制某个class所能产生的对象数量" class="headerlink" title="条款26：限制某个class所能产生的对象数量"></a>条款26：限制某个class所能产生的对象数量</h2><h3 id="1-允许零个或一个对象"><a href="#1-允许零个或一个对象" class="headerlink" title="1.允许零个或一个对象"></a>1.允许零个或一个对象</h3><h4 id="1-1-零个对象"><a href="#1-1-零个对象" class="headerlink" title="1.1.零个对象"></a>1.1.零个对象</h4><p>每当即将产生一个对象，就会有一个 <code>constructor</code> 被调用。阻止某个 <code>class</code> 产出对象的最简单方法就是将其 <code>constructors</code> 声明为 <code>private</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">CantBeInstantiated</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token function">CatBeInstantiated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">CantBeInstantiated</span><span class="token punctuation">(</span><span class="token keyword">const</span> CantBeInstantiated<span class="token operator">&amp;</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-封装对象在函数内"><a href="#1-2-封装对象在函数内" class="headerlink" title="1.2.封装对象在函数内"></a>1.2.封装对象在函数内</h4><p>我们可以将对象封装在某个函数内，如此一来只有唯一一个对象被产生.<br>接下使用打印机的例子来说明。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">PrintJob</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Printer</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">submitJob</span><span class="token punctuation">(</span><span class="token keyword">const</span> PrintJob<span class="token operator">&amp;</span> job<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">performSelfTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">friend</span> Printer<span class="token operator">&amp;</span> <span class="token function">thePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token keyword">const</span> Printer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Printer<span class="token operator">&amp;</span> <span class="token function">thePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> Printer p<span class="token punctuation">;</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//唯一一个打印机对象</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里有三个点值得注意</p><ul><li><code>Printer class</code> 的 <code>constructors</code> 属性 <code>private</code>，可以压制对象的诞生。</li><li>全局函数 <code>thePrinter</code> 被声明在此 <code>class</code> 的一个 <code>friend</code>，致使 <code>thePrinter</code> 不受 <code>private constructors</code> 的约束。</li><li><code>thePrinter</code> 内含一个 <code>static Printer</code> 对象，意思只有一个 <code>Printer</code> 对象被产生出来。</li></ul><p>在使用的时候，只需要调用 <code>thePrinter().</code> 就可以</p><h4 id="1-2-消除firend"><a href="#1-2-消除firend" class="headerlink" title="1.2.消除firend"></a>1.2.消除<code>firend</code></h4><p>以上方的例子为例，我们可以让 <code>thePrinter</code> 成为 <code>Printer</code> 的一个 <code>static member function</code>，消除 <code>friend</code> 的必要性。我们就能获得接下来的代码</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Printer</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">static</span> Printer<span class="token operator">&amp;</span> <span class="token function">thePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token keyword">const</span> Printer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Printer<span class="token operator">&amp;</span> Printer<span class="token operator">::</span><span class="token function">thePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> Printer p<span class="token punctuation">;</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在用户调用 <code>Printer</code>时，会显得冗长</p><pre class="line-numbers language-cpp"><code class="language-cpp">Printer<span class="token operator">::</span><span class="token function">thePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="1-3-使用namespace"><a href="#1-3-使用namespace" class="headerlink" title="1.3.使用namespace"></a>1.3.使用<code>namespace</code></h4><p>另一个做法是把 <code>Printer</code> 和 <code>thePrinter</code> 从全局空间移走，放进一个 <code>namespace</code> 内。我们就可以得到以下代码</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">namespace</span> PrintingStuff<span class="token punctuation">{</span>    <span class="token keyword">class</span> <span class="token class-name">Printer</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">//这个class 位于 PrintingStuff namespace 内</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token keyword">void</span> <span class="token function">submitJob</span><span class="token punctuation">(</span><span class="token keyword">const</span> PrintJob<span class="token operator">&amp;</span> job<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token function">performSelfTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">friend</span> Printer<span class="token operator">&amp;</span> <span class="token function">thePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token keyword">const</span> Printer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    Printer<span class="token operator">&amp;</span> <span class="token function">thePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   这个函数也位于 PrintingStuff <span class="token keyword">namespace</span> 内    <span class="token punctuation">{</span>        <span class="token keyword">static</span> Printer p<span class="token punctuation">;</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//唯一一个打印机对象</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了这个 <code>namespace</code>，用户就能使用完全限定名来取用 <code>thePrinter</code>:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> PrintingStuff<span class="token operator">::</span>theprinter<span class="token punctuation">;</span><span class="token function">thePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在此代码实现中，又两个精细的地方值得探讨。</p><ul><li>形成唯一一个 <code>Printer</code> 对象的，是函数中的 <code>static</code> 对象，而非 <code>class</code> 中的 <code>static</code> 对象。<br>C++ 的一个设计哲学基础是你不应该为你并不使用的东西付出任何代价。<br><code>function static</code>的初始时机：在该函数第一次被调用时。<br><code>class static</code> 则不一定在什么时候初始化。</li><li>函数的 <code>static</code> 对象与 <code>inlining</code> 的互动。</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp">Printer<span class="token operator">&amp;</span> <span class="token function">thePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">static</span> Printer p<span class="token punctuation">;</span> <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果上方的函数被声明为 <code>inline</code>，那么你的程序可能会拥有多份该 <code>static</code> 对象的副本。因为 <code>inline</code> 意味着编译器应该将每一个调用动作以函数本身取代。<br>千万不要产生内含 <code>local static</code> 对象的 <code>inline non-member functions</code>。</p><h4 id="1-4-使用抛出异常提示产生了过多的对象"><a href="#1-4-使用抛出异常提示产生了过多的对象" class="headerlink" title="1.4.使用抛出异常提示产生了过多的对象"></a>1.4.使用抛出异常提示产生了过多的对象</h4><p>我们继续改进我们的 <code>Printer</code>,给定一个函数来抛出一个类型为 <code>TooManyObjects</code> 的 <code>exception</code></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Printer</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">class</span> <span class="token class-name">TooManyObjects</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">static</span> size_t numberObjects<span class="token punctuation">;</span>    <span class="token function">Printer</span><span class="token punctuation">(</span>cosnt Printer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//我们限制只有一个打印机，所以绝不允许复制行为，所以放在private区</span><span class="token punctuation">}</span>size_t Printer<span class="token operator">::</span>numberObjects <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>Printer<span class="token operator">::</span><span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>numObjects <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token function">TooManyObjects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 这里处理一般的构造</span>    <span class="token operator">++</span>numObjects<span class="token punctuation">;</span><span class="token punctuation">}</span>Printer<span class="token operator">::</span><span class="token operator">~</span><span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 这里处理析构</span>    <span class="token operator">--</span>numObjects<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个非常简单直观。</p><h3 id="2-不同的对象构造状态"><a href="#2-不同的对象构造状态" class="headerlink" title="2.不同的对象构造状态"></a>2.不同的对象构造状态</h3><h4 id="2-1-继承问题"><a href="#2-1-继承问题" class="headerlink" title="2.1.继承问题"></a>2.1.继承问题</h4><p>假设我们有一台彩色打印机</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">ColorPrinter</span><span class="token operator">:</span> <span class="token keyword">public</span> Printer<span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当我们调用下面的代码时</p><pre class="line-numbers language-cpp"><code class="language-cpp">Printer p<span class="token punctuation">;</span>ColorPrinter cp<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们其实构造了两个Printer对象，这个时候就会有 <code>TooManyObjects exception</code> 被抛出。</p><h4 id="2-2-对象包含问题"><a href="#2-2-对象包含问题" class="headerlink" title="2.2.对象包含问题"></a>2.2.对象包含问题</h4><p>当我们有对象包含<code>Printer</code>时，就会出现这样的代码</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Machine</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//这是一个机器，处理打印、传真等功能</span><span class="token keyword">private</span><span class="token operator">:</span>    Printer p<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 针对打印功能</span>    FaxMachine f<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 针对传真功能</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 这里调用</span>Machine m1<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 没有问题</span>Machine m2<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 抛出 TooManyObjects exception</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，当我们构造 <code>m2</code> 的时候，就出现问题了，因为此时 <code>Printer</code> 对象位于较大对象当中</p><h4 id="2-3-阻止继承"><a href="#2-3-阻止继承" class="headerlink" title="2.3.阻止继承"></a>2.3.阻止继承</h4><p>为了阻止上述的继承导致的问题，我们可以通过把 <code>constructors</code> 变为 <code>private</code> 来实现禁止派生。</p><h3 id="3-允许对象生生灭灭"><a href="#3-允许对象生生灭灭" class="headerlink" title="3.允许对象生生灭灭"></a>3.允许对象生生灭灭</h3><p>到这里我们已经能得到一个较好的版本了，可以限制对象生成的数量。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Printer</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">class</span> <span class="token class-name">TooManyObjects</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> Printer <span class="token operator">*</span><span class="token function">MakePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">submitJob</span><span class="token punctuation">(</span>cibst PrintJob <span class="token operator">&amp;</span>job<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这里是一些外部调用的接口</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">static</span> size_t<span class="token operator">::</span>numObjects<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 用于记录已经生成的Printer对象</span>    <span class="token keyword">const</span> size_t Printer<span class="token operator">::</span>maxObject <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 用于限制最大的对象数量</span>    <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                              <span class="token comment" spellcheck="true">// 我们不允许继承，所以放置再private区</span>    <span class="token function">Printer</span><span class="token punctuation">(</span>cosnt Printer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 我们不允许直接调用拷贝构造，所以放在private区</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>Printer<span class="token operator">::</span><span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>numObjects <span class="token operator">>=</span> maxObjects<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token function">TooManyObjects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 这里处理一般的构造</span>    <span class="token operator">++</span>numObjects<span class="token punctuation">;</span><span class="token punctuation">}</span>Printer<span class="token operator">::</span><span class="token function">Printer</span><span class="token punctuation">(</span>cosnt Printer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 这里处理和默认构造函数一致</span><span class="token punctuation">}</span>Printer<span class="token operator">::</span><span class="token operator">~</span><span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 这里处理析构</span>    <span class="token operator">--</span>numObjects<span class="token punctuation">;</span><span class="token punctuation">}</span>Printer <span class="token operator">*</span>Printer<span class="token operator">::</span><span class="token function">makePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">new</span> Printer<span class="token punctuation">;</span> <span class="token punctuation">}</span>Printer <span class="token operator">*</span>Printer<span class="token operator">::</span><span class="token function">MakePrinter</span><span class="token punctuation">(</span><span class="token keyword">const</span> Printer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">Printer</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-一个用来计算对象个数的-Base-Class"><a href="#4-一个用来计算对象个数的-Base-Class" class="headerlink" title="4.一个用来计算对象个数的 Base Class"></a>4.一个用来计算对象个数的 <code>Base Class</code></h3><p>接下来我们使用 <code>template</code> 来实现</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">BeingCounted</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Counted</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">class</span> <span class="token class-name">TooManyObjects</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">objectCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> numObjects<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token function">Counted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Counted</span><span class="token punctuation">(</span><span class="token keyword">const</span> Counted <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">Counted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">--</span>numObjects<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> numObjects<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> size_t maxObjects<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 用以避免 ctor 码重复出现</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">BeingCounted</span><span class="token operator">></span>Counted<span class="token operator">&lt;</span>BeingCounted<span class="token operator">></span><span class="token operator">::</span><span class="token function">Counted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">BeingCounted</span><span class="token operator">></span>Counted<span class="token operator">&lt;</span>BeingCounted<span class="token operator">></span><span class="token operator">::</span><span class="token function">Counted</span><span class="token punctuation">(</span><span class="token keyword">const</span> Counted<span class="token operator">&lt;</span>BeingCounted<span class="token operator">></span><span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">BeingCounted</span><span class="token operator">></span><span class="token keyword">void</span> Counted<span class="token operator">&lt;</span>BeingCounted<span class="token operator">></span><span class="token operator">::</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>numObjects <span class="token operator">>=</span> maxObjects<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token function">TooManyObjects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">++</span>numObjects<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 下面我们要使用上面的模板，实现一个只能构造 10 个对象的打印机</span><span class="token keyword">const</span> size_t Counted<span class="token operator">&lt;</span>Printer<span class="token operator">></span><span class="token operator">::</span>maxObjects <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Printer</span> <span class="token operator">:</span> <span class="token keyword">private</span> Counted<span class="token operator">&lt;</span>Printer<span class="token operator">></span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">// pseudo-constructors</span>    <span class="token keyword">static</span> Printer <span class="token operator">*</span><span class="token function">makePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> Printer <span class="token operator">*</span><span class="token function">makePrinter</span><span class="token punctuation">(</span><span class="token keyword">const</span> Printer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>    <span class="token operator">~</span><span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">submitJob</span><span class="token punctuation">(</span><span class="token keyword">const</span> PrintJob<span class="token operator">&amp;</span> job<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">performSelfTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">using</span> Counted<span class="token operator">&lt;</span>Printer<span class="token operator">></span><span class="token operator">::</span>objectCount<span class="token punctuation">;</span>    <span class="token keyword">using</span> Counted<span class="token operator">&lt;</span>Printer<span class="token operator">></span><span class="token operator">::</span>TooManyObjects<span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Printer</span><span class="token punctuation">(</span><span class="token keyword">const</span> Printer <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="条款27：要求（或禁止）对象产生于-heap-中"><a href="#条款27：要求（或禁止）对象产生于-heap-中" class="headerlink" title="条款27：要求（或禁止）对象产生于 heap 中"></a>条款27：要求（或禁止）对象产生于 heap 中</h2><h3 id="要求对象产生于-heap-之中（Heap-Based-Objects）"><a href="#要求对象产生于-heap-之中（Heap-Based-Objects）" class="headerlink" title="要求对象产生于 heap 之中（Heap-Based Objects）"></a>要求对象产生于 <code>heap 之中</code>（<code>Heap-Based Objects</code>）</h3><p>只要限制 <code>destructor</code> 或 <code>constructors</code> 的运用，便可阻止 <code>non-heap object</code> 的诞生。但是他同时也妨碍了继承（<code>inheritance</code>）和包含（<code>containment</code>）</p><h3 id="禁止对象产生于-heap-中"><a href="#禁止对象产生于-heap-中" class="headerlink" title="禁止对象产生于 heap 中"></a>禁止对象产生于 <code>heap</code> 中</h3><p>首先我们需要知道有三种情况下，对象可能被产生于 <code>heap</code> 中</p><ol><li>对象被直接实例化</li><li>对象被实例化为 <code>derived class objects</code> 内的 “base class 成分”</li><li>对象被内嵌于其他对象之中</li></ol><p>简单来说，可以直接设置 <code>operator new</code> 和 <code>operator delete</code> 为 <code>private</code> 即可</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">UPNumber</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你也像禁止“由 <code>UPNumber</code> 对象所组成的数组” 位于 <code>heap</code> 内，可以将 <code>operator new[]</code> 和 <code>operator delete[]</code> 亦声明为 <code>private</code>。当然现在更推荐直接delete掉。</p><h2 id="条款28：Smart-Pointers（智能指针）"><a href="#条款28：Smart-Pointers（智能指针）" class="headerlink" title="条款28：Smart Pointers（智能指针）"></a>条款28：Smart Pointers（智能指针）</h2><p>这里的智能指针比较早，包括了auto_ptr，可以单独了解，本书内容有点过时了。</p><h2 id="条款29：Reference-counting（引用计数）"><a href="#条款29：Reference-counting（引用计数）" class="headerlink" title="条款29：Reference counting（引用计数）"></a>条款29：Reference counting（引用计数）</h2><p>总体意思需要结合上一个条款中谈到的 <code>smart ptr</code> 来实现引用计数。有几个方面需要考虑</p><ul><li>需要有一个结构体即存储引用次数，也要存储数据</li><li>上述需要生成在堆中，通过指针访问地址</li><li>正确且自动处理引用增加及减少情况<ul><li>构造函数（包括拷贝构造等）</li><li>析构函数</li><li>赋值</li></ul></li><li>修改对象数据时需要调整引用及分享权限（也就是 <code>copy on write</code>）</li><li>避免内存泄漏</li></ul><h2 id="条款30：Proxy-classes（替身类、代理类）"><a href="#条款30：Proxy-classes（替身类、代理类）" class="headerlink" title="条款30：Proxy classes（替身类、代理类）"></a>条款30：Proxy classes（替身类、代理类）</h2><p>简单来说，如果我们有一个 <code>string a = &quot;123&quot;;</code> 此时我们想用 <code>a[0]</code> 取得 <code>&#39;1&#39;</code>。然而我们这里取得<code>&#39;1&#39;</code>之后，我们会有以下一种行为</p><ol><li>只读，此时我们不需要修改 <code>reference count</code></li><li>写入，此时我们需要修改 <code>reference count</code></li></ol><p>所以我们这里返回的时候可以不返回一个 <code>char</code> 而是返回一个结构体，且只要这个结构体能够转换为<code>char</code>就行了。这个和之前所讲的 条款17：缓式评估 有相同的实现思路，可以折回去参考一下。</p><h2 id="条款31：让函数根据一个以上的对象类型来决定如何虚化"><a href="#条款31：让函数根据一个以上的对象类型来决定如何虚化" class="headerlink" title="条款31：让函数根据一个以上的对象类型来决定如何虚化"></a>条款31：让函数根据一个以上的对象类型来决定如何虚化</h2><p>这里指出了一个情况，例如我们有三种物体，且都继承<code>GameObject</code></p><ul><li><code>SpaceShip</code> 飞船</li><li><code>SpaceStation</code> 空间站</li><li><code>Asteroid</code> 陨石</li></ul><p>不同的物体会相撞，且会产生不同的结果。例如飞船和空间站相撞，飞船能进入到空间站内；飞船和陨石相撞，两者都会摧毁。<br>这个时候，我们需要一个方法，传入任意俩个<code>GameObject</code>都可以处理。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">processCollision</span><span class="token punctuation">(</span>GameObject<span class="token operator">&amp;</span> object1<span class="token punctuation">,</span> GameObject<span class="token operator">&amp;</span> object2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>书中讨论了一套方法，是一个不错的方法，但是感觉还不是很完美。目前就整理一下代码，记录下来。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;map></span></span><span class="token keyword">class</span> <span class="token class-name">GameObject</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">GameObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//基类里面有虚函数，派生类继承后，使用typeid().name才能取得对应的class name</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">SpaceShip</span> <span class="token operator">:</span> <span class="token keyword">public</span> GameObject <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">SpaceStation</span> <span class="token operator">:</span> <span class="token keyword">public</span> GameObject <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Asteroid</span> <span class="token operator">:</span> <span class="token keyword">public</span> GameObject <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//匿名namespace</span><span class="token keyword">namespace</span> <span class="token punctuation">{</span>    <span class="token keyword">using</span> std<span class="token operator">::</span>string<span class="token punctuation">;</span>    <span class="token keyword">using</span> std<span class="token operator">::</span>map<span class="token punctuation">;</span>    <span class="token keyword">using</span> std<span class="token operator">::</span>make_pair<span class="token punctuation">;</span>    <span class="token keyword">using</span> std<span class="token operator">::</span>pair<span class="token punctuation">;</span>    <span class="token keyword">using</span> std<span class="token operator">::</span>cout<span class="token punctuation">;</span>    <span class="token keyword">using</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">shipAsteroid</span><span class="token punctuation">(</span>GameObject<span class="token operator">&amp;</span> spaceShip<span class="token punctuation">,</span> GameObject<span class="token operator">&amp;</span> asteroid<span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"spaceShip collide with asteroid"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">shipStation</span><span class="token punctuation">(</span>GameObject<span class="token operator">&amp;</span> spaceShip<span class="token punctuation">,</span> GameObject<span class="token operator">&amp;</span> spaceStation<span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"spaceShip collide with spaceStation"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">asteroidStation</span><span class="token punctuation">(</span>GameObject<span class="token operator">&amp;</span> asteroid<span class="token punctuation">,</span> GameObject<span class="token operator">&amp;</span> spaceStation<span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"asteroid collide with spaceStation"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">asteroidShip</span><span class="token punctuation">(</span>GameObject<span class="token operator">&amp;</span> asteroid<span class="token punctuation">,</span> GameObject<span class="token operator">&amp;</span> spaceShip<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">shipAsteroid</span><span class="token punctuation">(</span>spaceShip<span class="token punctuation">,</span> asteroid<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">stationShip</span><span class="token punctuation">(</span>GameObject<span class="token operator">&amp;</span> spaceStation<span class="token punctuation">,</span> GameObject<span class="token operator">&amp;</span> spaceShip<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">shipStation</span><span class="token punctuation">(</span>spaceShip<span class="token punctuation">,</span> spaceStation<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">stationAsteroid</span><span class="token punctuation">(</span>GameObject<span class="token operator">&amp;</span> spaceStation<span class="token punctuation">,</span> GameObject<span class="token operator">&amp;</span> asteroid<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">asteroidStation</span><span class="token punctuation">(</span>asteroid<span class="token punctuation">,</span> spaceStation<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//碰撞map</span><span class="token keyword">class</span> <span class="token class-name">CollisionMap</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">//这里使用单例</span>    <span class="token keyword">static</span> CollisionMap<span class="token operator">*</span> <span class="token function">theCollisionMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">static</span> CollisionMap CM<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">&amp;</span>CM<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>HitFunctionPtr<span class="token punctuation">)</span><span class="token punctuation">(</span>GameObject<span class="token operator">&amp;</span><span class="token punctuation">,</span> GameObject<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//这里添加新的碰撞处理函数，成对处理</span>    <span class="token keyword">void</span> <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> type1<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> type2<span class="token punctuation">,</span> HitFunctionPtr collisionFunction<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>collisionMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">make_pair</span><span class="token punctuation">(</span>type1<span class="token punctuation">,</span> type2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> collisionMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//成对添加</span>        collisionMap<span class="token punctuation">[</span>std<span class="token operator">::</span><span class="token function">make_pair</span><span class="token punctuation">(</span>type1<span class="token punctuation">,</span> type2<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> collisionFunction<span class="token punctuation">;</span>        collisionMap<span class="token punctuation">[</span>std<span class="token operator">::</span><span class="token function">make_pair</span><span class="token punctuation">(</span>type2<span class="token punctuation">,</span> type1<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> collisionFunction<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//这里移除碰撞函数</span>    <span class="token keyword">void</span> <span class="token function">removeEntry</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> type1<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> type2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>collisionMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">make_pair</span><span class="token punctuation">(</span>type1<span class="token punctuation">,</span> type2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> collisionMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//成对移除</span>        collisionMap<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">make_pair</span><span class="token punctuation">(</span>type1<span class="token punctuation">,</span> type2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        collisionMap<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">make_pair</span><span class="token punctuation">(</span>type2<span class="token punctuation">,</span> type1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//查找有没有对应的碰撞函数</span>    HitFunctionPtr <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> class1<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> class2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        HitMap<span class="token operator">::</span>iterator it <span class="token operator">=</span> collisionMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span>class1<span class="token punctuation">,</span> class2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>it <span class="token operator">==</span> collisionMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> map<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> string<span class="token operator">></span><span class="token punctuation">,</span> HitFunctionPtr<span class="token operator">></span> HitMap<span class="token punctuation">;</span>    HitMap collisionMap<span class="token punctuation">;</span>    <span class="token function">CollisionMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">initializeCollisionMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">CollisionMap</span><span class="token punctuation">(</span><span class="token keyword">const</span> CollisionMap<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这里可以内部初始化，也可以改为一个函数，来注册一下函数</span>    <span class="token keyword">void</span> <span class="token function">initializeCollisionMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        collisionMap<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token string">"class SpaceShip"</span><span class="token punctuation">,</span> <span class="token string">"class Asteroid"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>shipAsteroid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token string">"class SpaceShip"</span><span class="token punctuation">,</span> <span class="token string">"class SpaceStation"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>shipStation<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// ...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//匿名namespace</span><span class="token keyword">namespace</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//这里处理碰撞，会查找碰撞map，如果有函数就执行，没有的话就抛出异常</span>    <span class="token keyword">void</span> <span class="token function">processCollision</span><span class="token punctuation">(</span>GameObject<span class="token operator">&amp;</span> object1<span class="token punctuation">,</span> GameObject<span class="token operator">&amp;</span> object2<span class="token punctuation">)</span> <span class="token punctuation">{</span>          CollisionMap<span class="token operator">*</span> CM <span class="token operator">=</span> CollisionMap<span class="token operator">::</span><span class="token function">theCollisionMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        CollisionMap<span class="token operator">::</span>HitFunctionPtr phf <span class="token operator">=</span> CM<span class="token operator">-</span><span class="token operator">></span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">typeid</span><span class="token punctuation">(</span>object1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>object2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>phf<span class="token punctuation">)</span> <span class="token function">phf</span><span class="token punctuation">(</span>object1<span class="token punctuation">,</span> object2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"UnkowCollision! "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>object1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" - "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>object2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    SpaceShip spaceShip<span class="token punctuation">;</span>    Asteroid asteroid<span class="token punctuation">;</span>    SpaceStation spaceStation<span class="token punctuation">;</span>    <span class="token function">processCollision</span><span class="token punctuation">(</span>spaceShip<span class="token punctuation">,</span> asteroid<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//spaceShip collide with asteroid</span>    <span class="token function">processCollision</span><span class="token punctuation">(</span>asteroid<span class="token punctuation">,</span> spaceShip<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//UnkowCollision! class Asteroid - class SpaceShip</span>    <span class="token function">processCollision</span><span class="token punctuation">(</span>spaceShip<span class="token punctuation">,</span> spaceStation<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//spaceShip collide with spaceStation</span>    <span class="token function">processCollision</span><span class="token punctuation">(</span>asteroid<span class="token punctuation">,</span> spaceStation<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//UnkowCollision! class Asteroid - class SpaceStation</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="条款32：在未来时态下发展程序"><a href="#条款32：在未来时态下发展程序" class="headerlink" title="条款32：在未来时态下发展程序"></a>条款32：在未来时态下发展程序</h2><p>对于未来式思维，作者希望我们多考虑一些东西：</p><ul><li>提供玩真的<code>class</code> —— 即使某些部分目前用不到。当心的需求进来，你不太需要回头去修改那些 <code>classes</code>。</li><li>设计你的接口，使有利于共同的操作行为，阻止共同的错误。让这些 <code>classes</code> 轻易地被正确运用，难以被错误运用。</li><li>尽量使你都代码一般化（泛化），除非有不良的巨大后果。</li></ul><p>但是注意在之前的effective c++中提到的，过早优化是性能恶化之源。</p><h2 id="条款33：将非尾端类-non-leaf-classes-设计为-抽象类-abstract-classes"><a href="#条款33：将非尾端类-non-leaf-classes-设计为-抽象类-abstract-classes" class="headerlink" title="条款33：将非尾端类(non-leaf classes) 设计为 抽象类(abstract classes)"></a>条款33：将非尾端类(non-leaf classes) 设计为 抽象类(abstract classes)</h2><p>继承体系中的 <code>non-leaf</code>(非尾端)类应该使抽象类。如果 使用外界供应的程序库，你或许可以对其法则做点变通；单如果代码完全在你掌控之下，坚持这个法则，可以为你带来许多好处，并提升整个软件的可靠度、健壮度、精巧度、扩充度。</p><p>当然了，现在的设计思路一般都是组合优于继承，继承能干的组合就能够解决。</p><h2 id="条款34：如何在同一程序中结合-C-和-C"><a href="#条款34：如何在同一程序中结合-C-和-C" class="headerlink" title="条款34：如何在同一程序中结合 C++ 和 C"></a>条款34：如何在同一程序中结合 C++ 和 C</h2><ul><li><code>Name Mangling</code>(名命重整)</li><li><code>Statics</code> 的初始化</li><li>动态内存分配</li><li>数据结构的兼容性</li></ul><p>并指明了以下守则</p><ul><li>确定你的 C++ 和 C 编译器产出兼容的目标文件(<code>object files</code>)。</li><li>将双方都使用的函数声明为 <code>extern &quot;C&quot;</code>。</li><li>如果可能，尽可能在 C++ 中撰写 <code>main</code>。</li><li>总是以 <code>delete</code> 删除 <code>new</code> 返回的内存：总是以 <code>free</code> 释放 <code>malloc</code> 放回的内存。</li><li>将两个语言间的“数据结构传递”限制于 C 所能了解的形式；C++ <code>structs</code> 如果内含非虚函数，但是不受此限。</li></ul><h2 id="条款35：让自己习惯于标准-C-语言"><a href="#条款35：让自己习惯于标准-C-语言" class="headerlink" title="条款35：让自己习惯于标准 C++ 语言"></a>条款35：让自己习惯于标准 C++ 语言</h2><p>拥抱新的c++标准。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;虽然早在4年前的大二时期就看过并且实践在工程作业里面，但一直没有一个完整的记录，想着别的几本都有了干脆补全一下吧，个人总结，难免会出现一些不
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://JoyTsing.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="读书笔记" scheme="https://JoyTsing.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Cpp工程实践必备技能</title>
    <link href="https://joytsing.github.io/posts/23555/"/>
    <id>https://joytsing.github.io/posts/23555/</id>
    <published>2024-03-06T08:24:58.000Z</published>
    <updated>2024-03-15T08:01:21.472Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本科时候质疑CMAKE，后面理解CMAKE,加入CMAKE。言归正传，之前不喜欢用clion的原因，一是因为clion每次使用的时候启动慢，加上卡，其次是那会真不会CMAKE，而clion是强制用，然后后面就选择用vs去了，到现在大部分时间都在linux下写代码，慢慢开始熟悉CMAKE，突然有点感慨，遇到这么多人大部分人还停留在学校用vs教个基础语法的阶段，modern cpp不了解，cmake更是不知道。</p><p>接下来会对现代工程进行一个初步介绍，对单元测试框架以及benchmark框架的引入和使用进行个预览。</p><h2 id="CMAKE"><a href="#CMAKE" class="headerlink" title="CMAKE"></a>CMAKE</h2><p>首先是CMAKE，CMAKE写不好你都不要想着启动程序（迫真），目前来说，我觉得CMAKE不需要完全像一门编程语言一样能够熟悉到默写，只要能够看懂仿写我觉得就足够了。目前来说比较优秀的资料有这两个，两者都是类似讲座的形式，对现代CMAKE进行个粗略的介绍：<a href="https://www.bilibili.com/video/BV1nu411u7rb/?spm_id_from=333.999.0.0">一个半小时入门现代CMake</a>，<a href="https://www.bilibili.com/video/BV16P4y1g7MH/?spm_id_from=333.999.0.0&vd_source=698e8d6597cbbceb9e4ea1aa22057b46">现代CMake高级教程</a>, <a href="https://www.bilibili.com/video/BV1V84y117YU/?spm_id_from=333.999.0.0&vd_source=698e8d6597cbbceb9e4ea1aa22057b46">现代CMake模块化项目管理指南</a>大概就能了解个差不多了。</p><h2 id="单元测试框架"><a href="#单元测试框架" class="headerlink" title="单元测试框架"></a>单元测试框架</h2><p>本来想用google test的，后面想想选择更加现代化的 catch2 或 doetest，两者都是head-only类型的，只需要引入就能够使用，不过更推荐用doctest，因为他编译速度比catch2快很多，如果想要使用方便的话直接使用 <code>include(FetchContent)</code>的方式使用即可。</p><pre class="line-numbers language-cmake"><code class="language-cmake"> include(FetchContent) FetchContent_Declare(         doctest         GIT_REPOSITORY https://github.com/doctest/doctest.git         GIT_TAG master         GIT_SHALLOW TRUE ) FetchContent_MakeAvailable(doctest) ​ target_link_libraries(target doctest_with_main)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体使用不在这讲，看<a href="https://github.com/doctest/doctest/tree/master/doc/markdown">官方文档</a>即可，非常方便。</p><h2 id="benchmark框架"><a href="#benchmark框架" class="headerlink" title="benchmark框架"></a>benchmark框架</h2><p>建议使用 nanobench ，同样也是因为引入简单轻量，使用简单且 head only 。使用可以去看<a href="https://nanobench.ankerl.com/tutorial.html#usage">官方文档</a>。</p><pre class="line-numbers language-cmake"><code class="language-cmake">include(FetchContent) ​ FetchContent_Declare(     nanobench     GIT_REPOSITORY https://github.com/martinus/nanobench.git     GIT_TAG master     GIT_SHALLOW TRUE) ​ FetchContent_MakeAvailable(nanobench)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体输出的话如下：</p><ul><li>ns/op：每个bench内容需要经历的时间（ns为单位）。</li><li>op/s：每秒可以执行多少次操作。</li><li>err%：运行多次测试的波动情况（误差）。</li><li>ins/op：每次操作需要多少条指令。</li><li>cyc/op：每次操作需要多少次时钟周期。</li><li>bra/op：每次操作有多少次分支预判。</li><li>miss%：分支预判的miss率。</li><li>total：本次消耗的总时间。</li><li>benchmark：对应的名字。</li></ul><p>注意测试的时候，有时需要记得防止被编译器优化。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;nanobench.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;doctest/doctest.h></span></span><span class="token function">TEST_CASE</span><span class="token punctuation">(</span><span class="token string">"tutorial_fast_v2"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    uint64_t x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    ankerl<span class="token operator">::</span>nanobench<span class="token operator">::</span><span class="token function">Bench</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token string">"++x"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ankerl<span class="token operator">::</span>nanobench<span class="token operator">::</span><span class="token function">doNotOptimizeAway</span><span class="token punctuation">(</span>x <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="内存泄露检测"><a href="#内存泄露检测" class="headerlink" title="内存泄露检测"></a>内存泄露检测</h2><p>推荐使用backward-cpp，同样是head-only类型的，同样的也可以用上面的方式引入。</p><pre class="line-numbers language-cmake"><code class="language-cmake">include(FetchContent)# Also requires one of: libbfd (gnu binutils), libdwarf, libdw (elfutils)FetchContent_Declare(backward    GIT_REPOSITORY https://github.com/bombela/backward-cpp    GIT_TAG master  # or a version tag, such as v1.6    GIT_SHALLOW TRUE    SYSTEM          # optional, the Backward include directory will be treated as system directory)FetchContent_MakeAvailable(backward)# Add Backward to your target (either Backward::Interface, Backward::Object, or Backward::Backward)target_link_libraries(mytarget PUBLIC Backward::Interface)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于perf，sanitizers等就不在这介绍了。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>├── build<br>├── include<br>├── src<br>│  ├── CMakeLists.txt<br>│  └── main.cpp<br>└── test<br>   └── CMakeLists.txt</p><p>对于一个CMAKE构建的cpp工程应该具有类似上面的项目格式，在总目录下有 CMakeLists.txt,同时，在对应的src和test，有时还会有third-party目录下同样具有CMakeLists.txt。</p><pre class="line-numbers language-cmake"><code class="language-cmake">cmake_minimum_required(VERSION 3.20)if(NOT CMAKE_BUILD_TYPE)  set(CMAKE_BUILD_TYPE "Debug")endif()project(main LANGUAGES CXX)include(FetchContent)#用于引入上面介绍的三方库include_directories(${PROJECT_SOURCE_DIR}/include)set(CMAKE_EXPORT_COMPILE_COMMANDS ON)set(CMAKE_CXX_STANDARD 20)add_subdirectory(src/)add_subdirectory(test/)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总的项目cmakelists应该如上，当然对于第三方库的使用除了上面介绍的方法还有将文件download下来编译的，只不过现在介绍的方法更方便。</p><p>对应的src目录的cmakelists应该如下：</p><pre class="line-numbers language-cmake"><code class="language-cmake"># track the stack info# Also requires one of: libbfd (gnu binutils), libdwarf, libdw (elfutils)FetchContent_Declare(  backward  GIT_REPOSITORY https://github.com/bombela/backward-cpp  GIT_TAG master # or a version tag, such as v1.6  GIT_SHALLOW TRUE  SYSTEM # optional, the Backward include directory will be treated as system directory)FetchContent_MakeAvailable(backward)# srcfile(GLOB_RECURSE all_src CONFIGURE_DEPENDS *.cpp)add_executable(main ${all_src})target_include_directories(main PUBLIC ${PROJECT_SOURCE_DIR}/include/)target_link_libraries(main PRIVATE Backward::Backward)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>test的则是如下：</p><pre class="line-numbers language-cmake"><code class="language-cmake"># doctestFetchContent_Declare(  doctest  GIT_REPOSITORY https://github.com/doctest/doctest.git  GIT_TAG master  GIT_SHALLOW TRUE)FetchContent_MakeAvailable(doctest)# benchmarkFetchContent_Declare(  nanobench  GIT_REPOSITORY https://github.com/martinus/nanobench.git  GIT_TAG master  GIT_SHALLOW TRUE)FetchContent_MakeAvailable(nanobench)file(GLOB_RECURSE all_tests *.cpp)file(GLOB_RECURSE all_src CONFIGURE_DEPENDS ${PROJECT_SOURCE_DIR}/src/*.cpp)list(REMOVE_ITEM all_src ${PROJECT_SOURCE_DIR}/src/main.cpp)foreach(v ${all_tests})  string(REGEX MATCH "test/.*" relative_path ${v})  string(REGEX REPLACE "test/" "" target_name ${relative_path})  string(REGEX REPLACE ".cpp" "" target_name ${target_name})  add_executable(${target_name} ${v} ${all_src})  target_include_directories(${target_name} PUBLIC ${PROJECT_SOURCE_DIR}/include/)  target_link_libraries(${target_name} PRIVATE doctest_with_main nanobench Backward::Backward)endforeach()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;本科时候质疑CMAKE，后面理解CMAKE,加入CMAKE。言归正传，之前不喜欢用clion的原因，一是因为clion每次使用的时候启动慢，
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>通过折叠表达式简化返回值检测</title>
    <link href="https://joytsing.github.io/posts/33498/"/>
    <id>https://joytsing.github.io/posts/33498/</id>
    <published>2024-03-04T07:14:44.000Z</published>
    <updated>2024-03-20T16:12:25.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="返回值检查"><a href="#返回值检查" class="headerlink" title="返回值检查"></a>返回值检查</h2><p>比如在启动服务器或者客户端的时候编写init函数， 此时需要依次去config目录加载对应的配置，log的配置等等，在这个时候如果一行行写的话就会有如下代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp">error_t result<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>result <span class="token operator">=</span> <span class="token function">check1</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> error_t<span class="token operator">::</span>ok<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span>result <span class="token operator">=</span> <span class="token function">check2</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> error_t<span class="token operator">::</span>ok<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span>result <span class="token operator">=</span> <span class="token function">check3</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> error_t<span class="token operator">::</span>ok<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span>result <span class="token operator">=</span> <span class="token function">check4</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> error_t<span class="token operator">::</span>ok<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> error_t<span class="token operator">::</span>ok<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽说也可以但是终归是比较丑陋，如果应用折叠表达式的话可以写成如下形式：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">return</span> <span class="token function">checked_exec</span><span class="token punctuation">(</span>  error_t<span class="token operator">::</span>ok<span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">check1</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">check2</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">check3</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">check4</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对应的check_exec可以写成：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> R<span class="token punctuation">,</span>          <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Fn<span class="token operator">></span>R <span class="token function">checked_exec</span><span class="token punctuation">(</span><span class="token keyword">const</span> R<span class="token operator">&amp;</span> expected<span class="token punctuation">,</span>               Fn<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> fn<span class="token punctuation">)</span><span class="token punctuation">{</span>  R result <span class="token operator">=</span> expected<span class="token punctuation">;</span>  <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>result <span class="token operator">=</span> forward<span class="token operator">&lt;</span>Fn<span class="token operator">></span><span class="token punctuation">(</span>             fn<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> expected<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>         <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，前提是不传入参数，传入参数不同的话就需要额外编写。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;返回值检查&quot;&gt;&lt;a href=&quot;#返回值检查&quot; class=&quot;headerlink&quot; title=&quot;返回值检查&quot;&gt;&lt;/a&gt;返回值检查&lt;/h2&gt;&lt;p&gt;比如在启动服务器或者客户端的时候编写init函数， 此时需要依次去config目录加载对应的配置，log的配置等等，
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>vscode CMake Tools 传递命令行参数</title>
    <link href="https://joytsing.github.io/posts/61384/"/>
    <id>https://joytsing.github.io/posts/61384/</id>
    <published>2024-01-20T15:03:02.000Z</published>
    <updated>2024-03-20T16:24:07.149Z</updated>
    
    <content type="html"><![CDATA[<p>vscode调试C++程序时，有时需要给程序传递命令行参数。这么说，如果是用F5去运行的话那么则是另外一套配置配置方法，但现在最近已经习惯了CMake一套工具链，同时懒得跳到命令行里面去打make或者运行脚本。这种时候，通常做法是配置<code>launch.json</code>文件中要调试程序的<code>args</code>字段。但是设置<code>tasks.json</code>和<code>launch.json</code>的方式不如使用CMake Tools插件调试运行程序方便。CMake Tools插件调试运行程序可以在多个cmake的target中切换，省去了写那些配置的繁琐步骤。</p><p><img src="/posts/61384/image-20240120230905008.png" alt></p><h2 id="1-设置方法-设置-cmake-debugConfig-的-args字段"><a href="#1-设置方法-设置-cmake-debugConfig-的-args字段" class="headerlink" title="1. 设置方法: 设置 cmake.debugConfig 的 args字段"></a>1. 设置方法: 设置 cmake.debugConfig 的 args字段</h2><p>注意要是去设置<code>Workspace</code>的<code>settings.json</code>,因为每个项目需要的设置的命令行参数不一样。</p><p>如果设置<code>User</code>的<code>settings.json</code>会对其他项目产生影响。</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"cmake.debugConfig"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"args"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"arg1"</span><span class="token punctuation">,</span> <span class="token string">"arg2"</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里只配置了<code>cmake.debugConfig</code>中的<code>args</code>字段，其他字段省去了，因为我们当前只需要设置命令行参数。</p><p>虽然名字叫<code>debugConfig</code>，这里传递的命令行参数在<code>Release</code>和<code>Debug</code>模式下都是有效的。</p><h2 id="2-例子"><a href="#2-例子" class="headerlink" title="2. 例子"></a>2. 例子</h2><p>假设<code>main.cpp</code>需要用到命令行参数</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> argc <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后直接创建一个.vscode文件夹，创建一个settings.json文件，把上面1中提到的内容加进去就好了。</p><p><img src="/posts/61384/image-20240120230941833.png" alt></p><p>这样用CMake一套就能直接带参数调试或者运行了，同理，想要配置clangd的话也是直接去settings设置就好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;vscode调试C++程序时，有时需要给程序传递命令行参数。这么说，如果是用F5去运行的话那么则是另外一套配置配置方法，但现在最近已经习惯了CMake一套工具链，同时懒得跳到命令行里面去打make或者运行脚本。这种时候，通常做法是配置&lt;code&gt;launch.json&lt;/c
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Tool" scheme="https://JoyTsing.github.io/tags/Tool/"/>
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>贵安，元旦快乐</title>
    <link href="https://joytsing.github.io/posts/53667/"/>
    <id>https://joytsing.github.io/posts/53667/</id>
    <published>2024-01-01T16:54:05.000Z</published>
    <updated>2024-01-01T16:58:55.541Z</updated>
    
    <content type="html"><![CDATA[<h2 id="元旦快乐"><a href="#元旦快乐" class="headerlink" title="元旦快乐"></a>元旦快乐</h2><p>2024年伊始，很久没有更新新的博文了，先给大家祝贺一下。在这里顺便说一下本站接下来的计划吧：</p><p>因为这个blog是我大二时候一时兴起搭的，大部分插件什么的也是那会弄的，现在发现已经有很多不能用了，可能之后会有一次大的迭代或者重构吧。毕竟前端这东西还是迭代太快了，这才4年hexo的结构就已经变了个样了，插件统计什么的我估计之前都是靠着缓存在工作，clean之后直接罢工了（笑。</p><p>希望新的一年多多努力，好好奋斗，多读点书（不管是什么样的），做一些有意义的工作，别的想说的都融在那两首歌里面了，愿意听就去听吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;元旦快乐&quot;&gt;&lt;a href=&quot;#元旦快乐&quot; class=&quot;headerlink&quot; title=&quot;元旦快乐&quot;&gt;&lt;/a&gt;元旦快乐&lt;/h2&gt;&lt;p&gt;2024年伊始，很久没有更新新的博文了，先给大家祝贺一下。在这里顺便说一下本站接下来的计划吧：&lt;/p&gt;
&lt;p&gt;因为这个blo
      
    
    </summary>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Linux下多Clang工具链的踩坑</title>
    <link href="https://joytsing.github.io/posts/19689/"/>
    <id>https://joytsing.github.io/posts/19689/</id>
    <published>2023-12-21T11:21:21.000Z</published>
    <updated>2024-03-20T16:20:38.855Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>故事是从C++ 17标准说起，在写线程池异步执行的时候发现居然没法使用move移动，然后怀疑到了clang头上，因为发现当我使用C++17标准下的<code>std::invoke_result</code>时直接报错是没有这个函数实现，说明clang版本有点旧了(加上我需要C++20的实现)，然后就开始研究起来clang的更新。</p><p><img src="/posts/19689/2.png" alt></p><h2 id="第一个坑"><a href="#第一个坑" class="headerlink" title="第一个坑"></a>第一个坑</h2><p>首先，因为需要做cmu15445 2023spring的project，在我的环境下安装了全套clang-14的tool-chain，那么问题来了，首先，你直接apt install只能安装到14的版本，其次，如果能安装了，但我需要使用最新的C++标准，但我又想保留老的tool chain怎么办？（可以试一试，如果直接安装的话会把老的版本卸载了）</p><p>首先是安装：我先找到了llvm官网的安装脚本，但又存在一个问题，通过这个安装脚本下载的话速度太慢（是的挂梯子也不行），后来翻找发现果然国内有对应的<a href="https://mirrors.tuna.tsinghua.edu.cn/help/llvm-apt/">镜像源</a>。那么怎么做，长话短说，直接通过脚本安装的话会卸载，这里是手动启用了一部分，即首先信任来自 <a href="https://apt.llvm.org/">llvm</a> 的 PGP 公钥。然后先手动安装clang-17以及clang++-17（或许还有别的，但这两个是肯定有的），在手动安装的情况下因为指定了版本号，所以是不会冲突的（clang-14与clang-17），最重要的部分安装好后通过先前的脚本将完整的tool-chain下载下来（即clang-tidy-17等等）。</p><p>到目前为止没结束，因为还需管理多版本clang，需要通过<code>update-alternatives</code>选择对应版本号，具体怎么用直接搜索该命令就好，最后应该把这3个软件版本设成最新的：clang、clang++、clangd。那么目前多版本算是好了。</p><h2 id="第二个坑"><a href="#第二个坑" class="headerlink" title="第二个坑"></a>第二个坑</h2><p>那么怎么使用多版本呢？如果你不是命令行档（即干啥都坚持在命令行cmake），想要自己多个选择的话，那么此时你打开vscode对应的项目会出现下面的问题<img src="/posts/19689/1.png" alt></p><p>原因很显然，因为我们将对应的默认clang版本更改了，但是理论上说，在vscode上选择对应工具链会切换成对应的版本号，那么为什么？我花了大量时间在.vscode和插件的配置上，但实际上这些都是没用的。上图是我已经正常配置过了的版本，如果你之前使用的话，那么你会发现clang 14和clang17这两个地方的编译器的链接是完全相同的。</p><p>出现这个情况的原因在上文中已经说了，因为我们使用的<code>update-alternatives</code>，做的实际上是帮助我们创建对应的软链接，即：对于<code>clang</code> ，如果我在<code>update-alternatives</code>中把clang版本中的14设为高优先级那么clang链接的就是14，设置的是17就是17。我们需要做的是更改tool chain对应找的工具，也就是不再要之前的软链接（曾经是对的，但不会自动更改）。</p><p><img src="/posts/19689/3.png" alt></p><p>当时思路是正确了，那么怎么更改？在扫描tool chain的时候我注意到他会去一个目录下加载，于是去那个目录：</p><p><img src="/posts/19689/4.png" alt></p><p>把对应的clang14和clang17的tool-chain加上版本号即可，这时候vscode的cmake tool chain也设置好了。以后如果是多环境也是这样即可。</p><h2 id="别的坑"><a href="#别的坑" class="headerlink" title="别的坑"></a>别的坑</h2><p>其实实际上踩的坑不止这些，包括但不限于把公钥全删了导致apt报错等等，但最后终于把vscode下c++的clangd更新，不再给我那些C++17语法报错，总的来说还是指的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;故事是从C++ 17标准说起，在写线程池异步执行的时候发现居然没法使用move移动，然后怀疑到了clang头上，因为发现当我使用C++17标
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="Tool" scheme="https://JoyTsing.github.io/tags/Tool/"/>
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
  </entry>
  
</feed>
