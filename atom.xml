<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JoyTsing</title>
  
  <subtitle>深海</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://joytsing.github.io/"/>
  <updated>2024-04-26T07:07:20.192Z</updated>
  <id>https://joytsing.github.io/</id>
  
  <author>
    <name>JoyTsing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2024,F1上海站</title>
    <link href="https://joytsing.github.io/posts/8251/"/>
    <id>https://joytsing.github.io/posts/8251/</id>
    <published>2024-04-26T05:05:15.000Z</published>
    <updated>2024-04-26T07:07:20.192Z</updated>
    
    <content type="html"><![CDATA[<h2 id="20年的道路"><a href="#20年的道路" class="headerlink" title="20年的道路"></a>20年的道路</h2><p>曾经我们有个“奥运三问”：中国什么时候能参加奥运，什么时候能拿到金牌，什么时候我们能举办奥运会。同样的，我们也有个“F1三问”：中国什么时候可以举办F1分站、什么时候可以出一个F1车手、什么时候我们的车手可以拿到F1年度冠军。2024赛季虽然这是周冠宇的第三年，却是中国大奖赛的回归，周冠宇第一次回到主场作战，我们才真切的有“中国出了个F1车手”的实感啊。既然有了第一个车手，那就会有第二个、第三个，。总有一天，我们会拿到第一个分站冠军，乃至拿下年度冠军，总有一天。</p><p><img src="/posts/8251/zhou.jpg" alt="周冠宇"></p><p>很遗憾我没能去现场去看小周这场比赛，但是也许二十年后，新的年轻中国车手可以在领奖台上说，二十年前在上海，中国的第一位F1车手曾激励了我。</p><p><img src="/posts/8251/image-20240426145048589.png" alt="经典窝法乙烷"></p><h2 id="明年还能再见吗"><a href="#明年还能再见吗" class="headerlink" title="明年还能再见吗"></a>明年还能再见吗</h2><p>2024年算是车手合同到期的大年，刘易斯汉密尔顿爵士加盟法拉利绝对是车手市场的震撼级操作，而围场中岁数最大的车手头哥阿隆索跟马丁续约，也让年轻车手们争夺席位的压力变得更大了。席位一共就那么多个，让小周去五大车队或者小红牛是绝对没戏的。2025年，小周如果想继续在F1赛场上奋战，那么希望只在这三小车队索伯、哈斯和威廉姆斯身上，而这希望目前看来并不算大。</p><p>周冠宇留在F1，除了成绩，还需要的是进步和身后赞助商支持。虽然我不想这么说，但周冠宇目前实际上还是属于付费车手一级，并没有征服其他车队。赛季初采访周冠宇的时候他的目标是争取一份长期合同留在围场，这个目标说实话有点难。很多时候周冠宇被诟病的就是不够狠，起步昏厥和极速不够快，当然这里有车的问题(struggle)。</p><p><img src="/posts/8251/image-20240426145841657.png" alt="奥迪只想拿名次"></p><p>从卡丁车到F4，再到需要大量投入的F3和F2，最后走上F1<strong>成为了中国第一位F1正赛车手</strong>。也许你可以说有很多的不完美，阿尔法罗密欧不是强队、带资进组、周冠宇F2表现并没有达到顶尖水平….各种种种，都可以，或许<strong>成绩也许看起来平平，但是却创造了诸多的中国车手的历史</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;20年的道路&quot;&gt;&lt;a href=&quot;#20年的道路&quot; class=&quot;headerlink&quot; title=&quot;20年的道路&quot;&gt;&lt;/a&gt;20年的道路&lt;/h2&gt;&lt;p&gt;曾经我们有个“奥运三问”：中国什么时候能参加奥运，什么时候能拿到金牌，什么时候我们能举办奥运会。同样的，我们
      
    
    </summary>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>在Linux下Cpp添加三方库</title>
    <link href="https://joytsing.github.io/posts/24753/"/>
    <id>https://joytsing.github.io/posts/24753/</id>
    <published>2024-04-25T14:27:36.000Z</published>
    <updated>2024-04-25T14:41:07.231Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>最近在学习Boost网络库，一开始使用的版本是apt源带的1.74.0，大概是20年左右的版本，后面想了一下太老了，同时想配合gcc13体验一下协程，就去下了最新的Boost 1.85.0, 然后在安装的时候没有选择默认安装位置（之前不知道吃大亏），而是自定义了一个地方，虽然版本分离的问题解决了但是无法像之前丝滑的<code>#include</code>使用，同时又不想像维护第三方一样每次都写CMakeList，于是怎么让gcc(or g++)识别就成了一个问题。</p><h2 id="省流"><a href="#省流" class="headerlink" title="省流"></a>省流</h2><p><img src="/posts/24753/image-20240425223633571.png" alt></p><p>我这里选择的方法是使用在<code>.zshrc</code>中export环境变量的方法来使用，下面分别来看这三变量的作用</p><ul><li><code>BOOST_ROOT</code>:实际上可有可无，主要是在CMakeList中使用<code>find_package</code>查找boost时使用的，最终目的是无感使用即不需要显示编写CMakeList。</li><li><code>CPLUS_INCLUDE_PATH</code>: g++查找头文件包含处</li><li><code>LD_LIBRARY_PATH</code>: 动态库连接地址</li></ul><p>基本上下两个是无感使用某个常用库的必备配置，常用的话可以直接加在<code>.zshrc</code>中避免繁杂的编写。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;最近在学习Boost网络库，一开始使用的版本是apt源带的1.74.0，大概是20年左右的版本，后面想了一下太老了，同时想配合gcc13体验
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>数据库内核学习记录</title>
    <link href="https://joytsing.github.io/posts/41900/"/>
    <id>https://joytsing.github.io/posts/41900/</id>
    <published>2024-04-25T08:57:15.000Z</published>
    <updated>2024-04-25T09:10:18.295Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章-数据库的存储结构"><a href="#第一章-数据库的存储结构" class="headerlink" title="第一章 数据库的存储结构"></a>第一章 数据库的存储结构</h2><h3 id="1-1文件组织结构"><a href="#1-1文件组织结构" class="headerlink" title="1.1文件组织结构"></a>1.1文件组织结构</h3><h4 id="1-1-1文件分页"><a href="#1-1-1文件分页" class="headerlink" title="1.1.1文件分页"></a>1.1.1文件分页</h4><p>DBMS中可以看到数据库是以文件的形式存储在磁盘中的，对目前大部分数据库来说都是将数据存储于磁盘上，对于这类存储介质来说，因为其是非易失性存储，这意味着对于系统而言他的寻址方式是块寻址的，必须先将包含这个值的一个块的数据加载到内存中（目前也有基于NVEM存储开发的数据库）。<br><img src="/posts/41900/image-20230913211052243.png" alt></p><p>主流操作系统提供的通常为无结构的流文件，DBMS会将每个文件再划分为固定大小的数据块，称为页（page）。页是DBMS在磁盘和内存间交换数据的基本单元。如果需要对数据库进行读写操作，DBMS需要先将数据从磁盘读取到内存中的缓冲池内，缓冲池管理器负责在磁盘和内存之间以页为单位进行数据交换。DBMS的执行引擎在语句处理过程中需要使用某个数据页时，会向缓冲池提出请求，缓冲池管理器负责将该页读入内存，并向执行引擎提供该页在内存中的指针。当执行引擎操作那部分内存时，缓冲池管理器必须确保该页面始终驻留在那片内存区域中。</p><blockquote><p>从操作系统的角度来看，一个文件就是一个字节流序列，操作系统并不关心和了解文件的内容以及文件之间的关联性。数据库文件的内容只有创建它的DBMS才知道如何解读，因为它是由DBMS以其特定的方式来组织的。数据库文件的组织和管理由DBMS的存储管理器负责，它将文件划分为页面的集合，并且负责跟踪记录这些页面的使用情况，包括哪些页面存储了什么数据，哪些页面是空闲的等等。页面中可以存储不同类型的数据，比如记录、索引等，但是DBMS通常不会将不同类型的数据混合存储在同一个页面中。</p></blockquote><h4 id="1-1-2页"><a href="#1-1-2页" class="headerlink" title="1.1.2页"></a>1.1.2页</h4><p>每个页面都有唯一的标识符，对于DBMS来说，页因为是对于操作系统存在的抽象层，因此页实际是作为一个间接层提供给DBMS，将对应的页面标识符ID映射成文件路径以及偏移量。</p><blockquote><p>系统上层模块请求一个页面时，先给出页面ID，存储管理器将该页面ID转换为文件路径和偏移量，并由此定位到对应页面。</p></blockquote><p>需要注意区分以下两个关于页的概念:</p><ul><li><strong>硬件页：</strong> 即磁盘块，大小通常为4 KB，是磁盘I/O的基本单位。</li><li><strong>数据库页：</strong> 大小通常为磁盘块大小的整数倍，是DBMS在磁盘和缓冲池之间交换数据的基本单位。</li></ul><blockquote><p>二者的区别在于，对硬件页的写操作是原子的，但是对数据库页的写操作则不一定。换言之，如果硬件页的大小为4KB，那么当系统尝试向磁盘写入一个硬件页时，这4KB数据要么全部写入，要么全部不写入，这一点是由存储设备来保证的。</p><p>但是，如果数据库页大于硬件页，那么DBMS对一个数据库页的写操作将被操作系统分解为对多个硬件页的写操作，此时DBMS必须采取额外措施来确保数据被安全地写入磁盘，因为系统可能会在将一个数据库页写入到磁盘的过程中发生崩溃，从而导致该数据库页的内容出现不一致性错误。</p></blockquote><h5 id="1-1-2-1-OS中的页"><a href="#1-1-2-1-OS中的页" class="headerlink" title="1.1.2.1 OS中的页"></a>1.1.2.1 OS中的页</h5><blockquote><p>由于系统中的物理内存是随分配不断在变化的，有时候这个程序使用，有时候那个程序在使用。如果不使用逻辑地址直接使用物理地址，那当前进程操作的地址被占用，则不能使用内存。通过将连续的逻辑地址映射成不连续的物理地址，程序将只用关系的连续的逻辑地址，而物理地址再通过一些方法找到并映射过去。</p></blockquote><p>将程序的逻辑地址空间分为若干等大的页，称为 <strong>页/页面/虚页</strong> 。同样将物理内存分成若干项大小同虚页大小的页，称为 <strong>块/页帧/实页</strong>。虚页是连续的，实页是不连续的，<strong>页表</strong>就维护了虚页到实页的映射关系，页表中每一项称为<strong>页表项(PTE)</strong>，表示一个虚页到实页是映射关系。每个进程都有自己的页表，称为<strong>进程页表</strong>。</p><p>程序中使用的虚地址大致如下：</p><pre class="line-numbers language-text"><code class="language-text">|页号|页内偏移|<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>页表中的内容大致如下(当然还可以有一些标志信息，如是否有读写权限、是否可用等)：</p><pre class="line-numbers language-text"><code class="language-text">页号1: |标记|物理页号|页号2: |标记|物理页号|页号3: |标记|物理页号|页号4: |标记|物理页号|标注页号仅表示页表项之间的位置关系(连续)，不占用实际内存<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每个进程为了找到自己的进程页表还需要 <strong>页表基地址寄存器(PTBR)</strong> 的帮忙，其指向进程页表的实页号/页表起始地址(<strong>PPN</strong>)。进程切换时会切换PTBR的值。</p><p><strong>注意</strong> ，页号表示页表项之间的位置关系(连续)，实际不占物理内存，通过<strong>PTBR+页号x页表项大小算出目标地址</strong></p><p>由虚地址到实际物理地址的变化叫做内存映射，过程如下：</p><pre class="line-numbers language-text"><code class="language-text">┌────┐    ┌────────┬─────────┐ │PTBR│    │虚拟页号│ 页内偏移│             主存 └─┬──┘    └──┬─────┴────┬────┘        ┌─────────────┐   │          │          │             │             │   │          │          │             │             │   │          │          │             │             │   │          │          │             ├─────────────┤   └──────────+──────────┼────────────►│             │                         │   物理页号  │page table   │                         x─◄───────────┤             │                         │             ├─────────────┤                         │             │             │                         │             │             │                         │             │             │                         │  物理地址   │             │                         └───────────► │             │                                       │             │                                       │             │                                       └─────────────┘<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果对应地址缺页，则会触发缺页中断。进入内核态(异常/中断型)，从磁盘换入或加载内存并填写到内存中，并填写帧号，然后重新进行寻址过程。</p><p>如<code>0x000011a3</code>的地址映射过程</p><ul><li>逻辑地址32位=20位页号+12位页内偏移</li><li>页表项32位=20位块号(与20位页号对应)+12位标记位</li><li>物理地址=20位块号+12为页内偏移</li></ul><p>页表如下:</p><pre class="line-numbers language-text"><code class="language-text">起址：PTBR +页号        |标记| 帧号         |              |----|--------------| +0x00001  -> |    | 0x000f3      |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>第一次访问内存，通过PTBR+0x00001找到对应的页表项的地址，读取物理页号/页帧/实页号。再通过帧号0x000f3<strong>拼接</strong>页内偏移0x1a3得到物理地址(不需要加法，一部分高位，一部分低位，直接拼接更快)，第二次访问内存读取数据。<strong>至少需要两次内存访问</strong></p><h5 id="1-1-2-2-分页机制的优化"><a href="#1-1-2-2-分页机制的优化" class="headerlink" title="1.1.2.2 分页机制的优化"></a>1.1.2.2 分页机制的优化</h5><p>要真正获取一个内存中的内容实际需要加载两次内存，第一次是查页表找到物理页号，第一次是根据物理页号加页内偏移到对应内存,因此可以进行时间上的优化。而每个进程都需要维护一个页表，页表本身也是占内存空间的，因此还可以进行空间优化。</p><h5 id="1-1-2-3-空间优化与多级页表"><a href="#1-1-2-3-空间优化与多级页表" class="headerlink" title="1.1.2.3 空间优化与多级页表"></a>1.1.2.3 空间优化与多级页表</h5><p>引入多级页表有两个原因</p><ul><li><strong>如果页表大小超过了一个页面的大小/容量，则可能将数据存放到两个不同的页面</strong>，将无法通过PTBR+页号的方式找到</li><li>如通常一个页4KB，32位系统中一PTE有32位4B，故PTE数不应超过1k</li><li>进程页表本身也是在内存中的，需要占用内存空间<br>如果不考虑页面容量问题，<strong>假设一个页能容纳所有页表项</strong>。一个32位的系统和程序，如果页内偏移12位，要访问全部4G内存则需要2^20个物理块/物理页面/物理页号，对应就有2^20个页号/虚页号，即2^20个页表项：</li></ul><pre class="line-numbers language-text"><code class="language-text">|12位标记位|20位表示物理页号|<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这么一个页表项32bit=4B，则维护一个进程的页表需要占用2^20x4B=4MB的内存空间。4MB看起来很小，但是操作系统是要运行很多程序的。</p><p>如果使用多级页表，应当<strong>页表大小==页面容量</strong> ，如将32位分为10位，10位，12位的分级方式。为何10位？10位能索引2^10个PTE，而每个PTE占4B，一个页表刚好就4KB，与页容量相同。如果小于页容量会产生内碎片，浪费;如果大于页容量则无法通过页表起址+offset寻址。</p><blockquote><p>64位系统中则常用9位索引页表，64bit=8B，8Bx2^9=4KB，也刚好是一个页的大小。  </p></blockquote><pre class="line-numbers language-text"><code class="language-text">虚地址：| VPN[1] | VPN[0] | 页内偏移 |PTE:| PPN[1] | PPN[0] | 页内偏移 |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>PTBR指向一级页表起始地址，加上VPN[1]可以索引到对应页表项，一级页表中的PPN[1]PPN[0]就是二级页表的起始地址，再通过VPN[0]索引二级也被即可得到物理页号，加上页内偏移得到物理地址。</p><pre class="line-numbers language-text"><code class="language-text">┌────┐   ┌──────┬─────┬───────┐│PTBR│   │ VPN1 │VPN0 │offset │└─┬──┘   └──┬───┴──┬──┴───┬───┘               ┌─────────────┐  │         │      │      │                   │             │  │         │      │      │                   ├─────────────┤  └─────────x──────┼──────┼──────────────────►│xxxxxxxxxxxxx│                   │      │                   │x L0       xx│                   │      │     PPN1,PPN0     │x          xx│                   x──────┼─────◄─────────────┤xxxxxxxxxxxxx│                   │      │                   ├─────────────┤                   │      │                   │             │                   │      │                   │             │                   │      │                   │             │                   │      │                   ├─────────────┤                   └──────┼──────────────────►│xxxxxxxxxxxxx│                          │                   │x L1      xxx│                          │     PPN1,PPN0     │x         xxx│                          x─────◄─────────────┤xxxxxxxxxxxxx│                          │                   ├─────────────┤                          │                   │             │                          │                   │             │                          │                   │             │                          │                   │             │                          │                   │             │                          └──────────────────►│             │                                              │             │                                              │             │                                              │             │                                              │             │                                              │             │                                              └─────────────┘<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果发现第一级只有3项指向第二级，而第二级页表有2^10项，所以一共3个页表需要(2^10+3x2^10)x4B = 16KB的内存空间。当然上限还是2^10x2^10个表项x4B占4M空间。<strong>问题就是内存的访问次数增加了</strong>，前面使用多级页表的方式虽然减少了空间占用，但是内存的访问次数增加了。</p><h5 id="1-1-2-4TLB"><a href="#1-1-2-4TLB" class="headerlink" title="1.1.2.4TLB"></a>1.1.2.4TLB</h5><p>将最常访问的几个(一般8-128个左右)页表项储存到访问速度更快的硬件中，如关联存储器(相当于哈希表)，这个小表的名称为<strong>TLB (Translation Lookaside Buffer)</strong> 或 <strong>快表</strong> 。寻址会同时寻找TLB和页表，如果TLB命中则查页表寻址的操作作废。</p><h5 id="1-1-2-5使用大页"><a href="#1-1-2-5使用大页" class="headerlink" title="1.1.2.5使用大页"></a>1.1.2.5使用大页</h5><p>依旧上述多级页表的例子，但是使用某种机制让大页表地址连续，那么就可以使用起址+offset的方式寻址，而不需要多级页表多次访问内存。</p><pre class="line-numbers language-text"><code class="language-text">虚地址：| VPN[1] | VPN[0] | 页内偏移 |PTE:| PPN[1] | PPN[0] | 页内偏移 |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只是访问一级页表(L0)时其返回PPN[1]作为大页的索引(高10位)，然后使用虚拟地址的<code>&lt;VPN[0],页内偏移&gt;</code>所谓大页的页内偏移。如此一来访问次数就降低了。</p><pre class="line-numbers language-text"><code class="language-text">┌────┐ ┌──────┬─────┬───────┐│PTBR│ │ VPN1 │VPN0 │offset │└─┬──┘ └──┬───┴──┬──┴──┬────┘  │       │      │     │  │       │      └──┬──┘         ┌─────────────┐  │       │         │            │             │  │       │         │            ├─────────────┤  └───────x─────────┼───────────►│xxxxxxxxxxxxx│                    │            │x L0       xx│                    │  PPN1,     │x          xx│                    x───────◄────┤xxxxxxxxxxxxx│                    │            ├─────────────┤                    │            │             │                    │            │             │                    │            │             │                    │            ├─────────────┤                    └───────────►│             │                                 │  huge page  │                                 │             │                                 │             │                                 │             │                                 │             │                                 │             │                                 │             │                                 ├─────────────┤                                 └─────────────┘<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-1-3堆文件"><a href="#1-1-3堆文件" class="headerlink" title="1.1.3堆文件"></a>1.1.3堆文件</h4><p>关系型数据库存储的是关系，关系则是记录的集合，这些记录在数据库中有许多组织形式：</p><ul><li><strong>堆文件组织（ heap file organization）</strong> ：堆文件是页的无序集合，记录在页中以随机的顺序存储。即，一条记录可以放在文件中的任何地方，只要那里有足够的空间存放这条记录，记录间不用考虑先后顺序的。 通常每个关系使用一个单独的堆文件。</li><li>顺序文件组织（sequential file organization）：记录根据其”查找键”的值顺序存储。</li><li><strong>散列文件组织（ hash file organization）</strong> ：在每条记录的某个或某些属性上计算一个散列函数，根据散列的结果来确定将记录放到文件的哪个页面中。</li></ul><p>对于堆存储方式而言，由于这种存储形式对程序员而言是可见的，也就是说可以控制记录的存储。同时这种存储方式不关心记录间存储的顺序，只需要维护堆文件中哪些页面是存储了数据（数据页），哪些是空闲的即可。常见的有两种存储方式：</p><ul><li>链表：以链表的形式将文件中的空闲页和数据页分别勾连起来，并在文件的首页维护两个指针，分别指向空闲页链表和数据页链表的第一个页面。这种方式下，如果想要找到一个特定的数据页，需要从链首开始逐个扫描链表中的页面，直到找到为止，I/O开销较大。</li></ul><p><img src="/posts/41900/image-20230914133809745-1714036106757-59.png" alt></p><ul><li>页目录：维护一种特殊的页面（目录页），在该页中记录每个数据页的位置以及该数据页中剩余的空闲空间大小。页目录将页面的状态信息集中存放在一起，可以提高查找特定页面的速度。<br><img src="/posts/41900/image-20230914133840439.png" alt></li></ul><h4 id="1-1-4块的存储结构"><a href="#1-1-4块的存储结构" class="headerlink" title="1.1.4块的存储结构"></a>1.1.4块的存储结构</h4><p>块在存储中的组织与记录类似，可以简单地看成是由 header + data 数据组成，例如一个块要管理内部所有的记录，需要在块的 header 中保存每个记录的偏移、块最后修改的时间戳、块在存储结构中的位置信息等，因此 header 中的元数据主要是为了方便自身的管理和维护。</p><p>下面我们来看一个块里面是如何存放数据的，这里需要强调的是，块里面存储的地址偏移是相对于虚拟地址的偏移，并非实际物理磁盘的偏移。还需要注意，新插入的记录，是从块的末端往中间增长的，而未使用的空间是从 header 之后往块的末端增长的。<br><img src="/posts/41900/image-20231002155739470.png" alt><br>从图中可以看出记录 1 在最后，记录 4 在最前面，因为记录有可能不等长，无法事先根据记录的长度和块的总长来计算好能插入多少数据。</p><p>示例：假如一个块的大小是 100。</p><ul><li>如果记录都等长，都为 10，那么我们可以算出一个块最多能插入 10 条记录，并且可以从块的起始到末端的方向插入，最后刚好到 100 不会报错。</li><li>如果记录不等长，事先也不知道这个块最多能容纳多少条记录的，如一条长度 10，一条长度 50 的记录，从起始往末端方向编排，如果下一条记录的长度为 50 ，因为不知道块中还有多少空间，也不会提前报错，那必然会插入失败。<br>  但是如果记录是从块的末端往前增长，那在插入 10 和 50 这两条记录后，由于长度为 50 的那条记录的偏移是 40（100 - 10 - 50 = 40），那就能知道当前的空间只剩 40 了，没办法容纳新的记录，然后提前报错然后重新分配块。</li></ul><h3 id="1-2页的组织结构"><a href="#1-2页的组织结构" class="headerlink" title="1.2页的组织结构"></a>1.2页的组织结构</h3><p>页面的内部结构可以粗分为两个部分:</p><ul><li><strong>页头</strong> ：页头登记了关于页面内容的元数据，如页面大小、校验和、DBMS版本、事务可见性、压缩信息等。有些系统（如Oracle）要求页面是自包含的，即关于该页的所有描述信息都可以在该页面中找到。</li><li><strong>数据区</strong> ：存放数据的区域。这里我们只讨论如何在数据区中存放记录。目前DBMS中最常用的方法是采用槽式页面。这种方法将数据区划分为一个个插槽（slot），每个插槽中放置一条记录。<h4 id="1-2-1槽式页面"><a href="#1-2-1槽式页面" class="headerlink" title="1.2.1槽式页面"></a>1.2.1槽式页面</h4>顾名思义，就像一个个slot一样，将记录数据存储到磁盘上，对于这种存储方式而言，需要管理当前页面存储的信息，如最基本的存储记录条数与可用位置，因此需要在页头的位置维护下面信息：<blockquote><ol><li>本页中已使用的槽的数量；</li><li>最后一个已使用的槽的起始位置；</li><li>一个槽数组，登记本页中每个记录的起始位置。</li></ol></blockquote></li></ul><p>并且对于存储的数据库来说，记录数量应该是变长的，也就是说一个页面所存储的记录数量是不确定的，因此槽数组的最大长度是不能决定的，也就是说页头所占的区域大小是不确定的。因此比较合理的做法是，向页中插入记录时，槽数组从前向后增长，而被插入的记录数据则是从页尾向前增长。当槽数组和记录数据相遇时，则认为该页面是满页。<br><img src="/posts/41900/image-20230914134830996.png" alt></p><h4 id="1-2-2插入记录"><a href="#1-2-2插入记录" class="headerlink" title="1.2.2插入记录"></a>1.2.2插入记录</h4><p>向关系中插入一条记录时，对于堆文件，只需要找到一个有足够空闲空间能放得下这条记录的页面，或当所有已分配页面中都没有足够空闲空间时，就申请一个新的空闲页，然后将记录放置在那里。</p><h4 id="1-2-3删除记录"><a href="#1-2-3删除记录" class="headerlink" title="1.2.3删除记录"></a>1.2.3删除记录</h4><p>从页中删除记录时，需要考虑如何回收该记录的空间。一种方法是在页内滑动记录，使得记录间没有空隙，从而保证页面中未使用的区域一定位于槽数组和已使用区域之间。</p><p>如果不滑动记录，则需要在页头维护一个空闲区列表，以保证当向页中插入一条新记录时能知道该页中的空闲区在哪里，有多大。而页头通常不必存储全部空闲区列表，只存列表的链头就够了，然后可以使用空闲区自身的空间存储下一个空闲区的信息。</p><h4 id="1-2-4修改记录"><a href="#1-2-4修改记录" class="headerlink" title="1.2.4修改记录"></a>1.2.4修改记录</h4><p>如果修改的是定长记录，对页面存储没有影响，因为修改后记录占用的空间与修改前完全相同。但是如果修改的是变长记录，就会碰到与插入和删除类似的问题。</p><p>如果修改后的记录比其旧版本长，则需要在当前页面中获得更多的空间，这个过程可能涉及记录的滑动。如果当前页面中的空闲区域不够，还需要将记录移动到其他页面。反之，如果记录由于修改而变短可以像删除记录时那样回收其释放的空间。</p><h3 id="1-3记录的组织形式"><a href="#1-3记录的组织形式" class="headerlink" title="1.3记录的组织形式"></a>1.3记录的组织形式</h3><p>记录本质上就是一个字节序列，如何将这些字节解释为属性类型和值是DBMS的工作。与页面结构类似，记录内部结构也可以分为两部分：</p><ul><li><strong>记录头</strong> ：存放关于记录的元数据，例如DBMS并发控制协议的可见性信息（即哪个事务创建/修改了此记录的信息）、NULL值的位映射等。注意，关于数据库模式的元数据没有必要存储在记录头里。</li><li><strong>记录数据</strong> ：包含记录中各个属性的实际数值。如前所述，大多数DBMS不允许记录的长度超过页面的大小，且一个页面中一般只存放同一个关系的记录。<h4 id="1-3-1定长记录"><a href="#1-3-1定长记录" class="headerlink" title="1.3.1定长记录"></a>1.3.1定长记录</h4>定长记录全部由定长字段组成，是最简单的记录组织形式。定长记录的插入和删除是比较容易实现的，因为被删除的记录留出的可用空间恰好是插入新的记录所需要的空间。</li></ul><blockquote><p>定长记录在组织时需要注意的一个问题是内存对齐问题。很多处理器需要在数据的开始地址为4或8的倍数时才能实现更高效的内存读写，所以DBMS在组织记录数据时通常会根据情况使所有字段的起始地址是4或8的倍数。采用这种做法时，一个字段前可能会存在一些没有被上一个字段使用的空间，这些空间其实是被浪费掉了。但尽管如此，这样做还是有必要的。因为记录虽然是存放在磁盘而不是内存中，但是对记录的操作仍需在内存中进行，所以在组织记录时需要考虑如何让它在内存能够被高效访问。</p></blockquote><h4 id="1-3-2变长记录"><a href="#1-3-2变长记录" class="headerlink" title="1.3.2变长记录"></a>1.3.2变长记录</h4><p>变长记录允许记录中存在一个或多个变长字段。由于变长字段在记录中的偏移位置是不确定的，因此记录中必须包含足够多的信息，让我们能够方便地提取记录的任何字段。变长记录的实现可以采用以下两种方法。</p><blockquote><p>一种简单有效的实现方法，是将所有定长字段放在变长字段之前，然后在记录头写入以下信息：（1）记录长度；（2）除第一个变长字段之外的所有变长字段的偏移位置。之所以不需要存第一个变长字段的偏移位置，是因为我们知道第一个变长字段就紧跟在定长字段之后。一个变长记录的例子如图所示，该记录共包含四个字段，其中有两个变长字段：name和address。</p></blockquote><p><img src="/posts/41900/image-20230914140004897.png" alt></p><p>变长记录的另一种表示方法是保持记录定长，将变长部分放在另一个溢出页中，而在记录本身存储指向每一个变长字段开始位置的指针。</p><p><img src="/posts/41900/image-20230914140423450.png" alt><br>这种做法可以保持记录定长，能够更有效地对记录进行搜索，记录也很容易在页内或页间移动。但是另一方面，将变长部分存储在另一个页中，增加了为检索一条记录的全部数据而需要进行的磁盘I/O次数（损失性能)。</p><p>溢出页不仅可以存储变长字段，还可以用于存储大值数据类型的字段，比如TEXT和BLOB字段，这些数据往往需要使用多个页面来存储。</p><p>有时候变长记录是由具有可变格式的记录导致的，也就是是字段没有固定格式的记录，在数据库的维度来说是指没有具体表结构的数据，是非结构化的数据，例如 XML 文件。</p><p>示例：假设要记录一个人的信息，包括姓名、投资的餐馆等，可能字段固定但是内容不固定。这个时候可以使用标记（如姓名）以及类型（如 string）加上长度来记录，例如下图中的 N 表示 name，S 表示 string 类型，14 表示 name 的长度。这样做的好处是即便不知道存储的格式，但是可以把一些特征标识保存起来，最后根据标识解析出数据。</p><p><img src="/posts/41900/image-20240425170620590.png" alt></p><h4 id="1-3-3大值记录"><a href="#1-3-3大值记录" class="headerlink" title="1.3.3大值记录"></a>1.3.3大值记录</h4><p>所谓大值，是指在一个块中无法存储的记录，大值涉及多个块之间的交互。</p><p>示例：如下图记录 2 存储时，分成了两部分进行存储，分别是记录 2-a 和记录 2-b，其中在存储记录 2-a 的时候，需要额外的存储空间来保存一些数据：一是标识，表明这是一个记录的片段；二是片段的序号，如这是第 1 个片段，或者第 N 个片段；最后还要保存指向下一个片段的指针，用于跨块之间的访问。</p><p><img src="/posts/41900/image-20240425170630765.png" alt></p><h3 id="1-4缓冲池管理"><a href="#1-4缓冲池管理" class="headerlink" title="1.4缓冲池管理"></a>1.4缓冲池管理</h3><p>对于数据库来说，其最大的开销一般是磁盘和内存之间IO交互，也就是将页面传输到内存所耗的那部分，减少磁盘访问次数的一种方法是在内存中保留尽可能多的页面，理想情况下，要访问的页面正好都已经在内存中了，这样就不再需要访问磁盘了。</p><h4 id="1-3-1缓冲池结构"><a href="#1-3-1缓冲池结构" class="headerlink" title="1.3.1缓冲池结构"></a>1.3.1缓冲池结构</h4><p>缓冲池是DBMS内部分配的一块内存区域，用来缓存从磁盘获取的页面。这片内存空间被组织为一个数组，其中每个数组项被称为一个帧（frame），一个帧正好能放置一个页面。类似于操作系统，当请求一个页面的时候首先先到缓冲池里面搜索，如果没有搜索到再从磁盘中获取并存入到缓冲池中的一个帧中。<br><img src="/posts/41900/image-20230914143130161.png" alt><br>同样的，存在一个管理器来维护使用缓冲池所需要的元数据。存在页表，为一个内存哈希表（OS虚拟内存管理页表结构)<code>对于64位系统，当我们得到一64位虚拟地址ip时，将前几位作为虚拟页码（前几位可能与页大小有关），计算虚拟页码的哈希值，计算出哈希值后到哈希表对应条目进行查找，哈希表使用链表来解决碰撞问题，每个链表节点有3个内容，虚拟页码，映射的帧码，下一个节点指针。在查找到帧码后将其与页偏移组合，得到真实物理地址</code>用于登记当前已经在内存中的页面的信息。</p><p>页表将页面ID映射到缓冲池中一个帧的位置。因为缓冲池中页面的顺序不一定反映磁盘上的顺序，所以需要通过这个额外的数据结构来定位页面在缓冲池中的位置。除了最重要的内存地址之外，还需要为每个页面维护一个标志位和引用计数器（用于释放回收）。</p><blockquote><p><strong>脏标志</strong>：脏标志由线程在修改页面时设置。如果一个页面被设置了脏标志，就意味着缓冲池管理器必须将该页写回磁盘，以保证磁盘上的页面副本包含最新的数据。(修改位)</p><p><strong>引用计数</strong>：引用计数表示当前访问该页（读取或修改该页）的线程数。线程在访问该页之前必须增加引用计数。如果页的引用计数大于零，说明该页面正在被使用，此时不允许缓冲池管理器从内存中淘汰该页。</p></blockquote><p>关于缓冲池中的内存空间如何进行分配，一般采取两种策略：</p><blockquote><p><strong>全局策略</strong>：有利于当前整体工作负载的策略。全局策略综合考虑所有活动事务，以找到分配内存的最佳方案。</p><p><strong>本地策略</strong>：以保证单个查询或事务运行得更快为目标的策略。本地策略将一个帧分配给特定事务时，不考虑其他并发事务的行为，即使这样可能对整体工作负载不利。</p></blockquote><h4 id="1-3-2缓冲池替换算法"><a href="#1-3-2缓冲池替换算法" class="headerlink" title="1.3.2缓冲池替换算法"></a>1.3.2缓冲池替换算法</h4><p>DBMS对数据库文件的读写操作需要通过调用操作系统接口来实现，通常，为了优化I/O性能，操作系统自身也维护了一个缓冲区来缓存从磁盘读入的数据块。这个缓冲区和DBMS的缓冲池在功能上显然是重复的，会导致同一个数据库页面的数据在内存中的冗余存储，而且操作系统缓冲区的管理策略还使得DBMS难以控制内存与磁盘之间的页面交互。因此，<strong>大多数DBMS都使用直接I/O绕过操作系统的缓存</strong>。</p><p>因为需要DBMS来控制缓冲池，因此当需要释放一个帧为新页面腾出空间时，必须决定从缓冲池中淘汰掉哪个页面，替换算法的目标是提高正确性、准确性、速度和元数据开销。需要注意的是，引用计数大于零的页面是不能淘汰的。目前最常用的替换算法有最近最少使用（LRU）算法和时钟（CLOCK）算法。</p><blockquote><p><strong>LRU算法</strong>：LRU算法为每个页面维护其最后一次被访问的时间戳，这些时间戳可以存储在一个单独的数据结构（如队列）中，以便对其进行排序来提高效率。需要淘汰页面时，DBMS总是选择淘汰时间戳最早的页面。</p><p><strong>CLOCK算法</strong>：CLOCK算法是一种近似LRU算法，它不需要每个页面都有单独的时间戳，而是为每个页面维护一个引用位。当某个页面被访问时，就将它的引用位的值置为1。想象页面被组织在循环缓冲区中，需要选择淘汰页面时，有一个”时钟指针”在循环缓冲区中扫描，检查页面的引用位是否为1。如果是，则将引用位重新置0并移动指针到下一个页面；否则，淘汰当前页面。</p></blockquote><p>有三种解决方案可以解决LRU和CLOCK算法的缺点:</p><ul><li>第一种解决方案是LRU-K，LRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。它会以时间戳的形式登记最后K次引用的历史，并计算连续引用之间的时间间隔，将此历史记录用于预测页面下一次被访问的时间。<ul><li>相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到K次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。详细实现如下：</li></ul></li></ul><blockquote><ol><li>数据第一次被访问，加入到访问历史列表；</li><li>如果数据在访问历史列表里后没有达到K次访问，则按照一定规则（FIFO，LRU）淘汰；</li><li>当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；</li><li>缓存数据队列中被再次访问后，重新排序；</li><li>需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即：淘汰“倒数第K次访问离现在最久”的数据。</li></ol></blockquote><ul><li><p>第二种解决方案是对每个查询进行局部化，DBMS在每个查询的局部范围内选择要淘汰的页面，这样可以最小化每个查询对缓冲池的污染。</p></li><li><p>最后一种解决方案是优先级提示，它允许事务在查询执行期间根据每个页面的上下文，告诉缓冲池管理器该页面是否重要。在淘汰页面时，对于脏页可以有两种处理方法：</p><ul><li>（1）总是优先淘汰缓冲池中的非脏页面；</li><li>（2）先将脏页写回磁盘以确保其更改被持久化，然后再将其淘汰。后者会降低替换页面的速度；而前者虽然速度快，但是有可能将未来不会被再次访问的脏页留在缓冲池。</li></ul></li></ul><p>避免在淘汰页面时执行页面写出操作的一种方法是后台写。采用这种方法的DBMS会定期遍历页表并将脏页写入磁盘。当脏页被安全写入磁盘后，将该页面的脏标志重新置零。</p><h4 id="1-3-3缓冲池的优化"><a href="#1-3-3缓冲池的优化" class="headerlink" title="1.3.3缓冲池的优化"></a>1.3.3缓冲池的优化</h4><ul><li>（1）多缓冲池<br>DBMS可以维护多个用于不同目的的缓冲池，比如每个数据库使用一个缓冲池，每种页面类型使用一个缓冲池。然后针对其中存储的数据的特点，每个缓冲池可以采用量身定制的管理策略。</li></ul><p>将所需页面映射到缓冲池有两种方法：对象ID和散列。对象ID这种方法需要扩展元数据，使其包含关于每个缓冲池正在管理哪些数据库对象的信息，然后通过对象ID，就可以实现从对象到特定缓冲池的映射。另一种方法是散列，DBMS散列页面ID以选择访问哪个缓冲池。</p><ul><li><p>（2）预取<br>DBMS还可以根据查询计划通过预取页面来进行优化。然后，在处理第一组页面时，系统可以将第二组页面预取到缓冲池中。这种方法通常在顺序访问多个页面时使用。</p></li><li><p>（3）扫描共享<br>查询游标可以重用从磁盘读入的数据或操作符的计算结果，最大程度地减少多次扫描相同数据的开销。这种方法允许将多个查询附加到扫描表的单个游标上。当一个查询开始扫描时，如果已经有另一个查询在扫描，DBMS会将第一个查询附加到第二个查询的游标上。DBMS登记第二个查询加入时的位置，以便在到达数据结构末尾时结束扫描。换而言之，当多个查询需要执行相同的顺序扫描操作时，它们应该尽量共享已经加载到缓冲池中的数据页面，而不是每个查询都重新加载相同的数据。这可以通过缓存共享数据页面的内存块来实现，以便多个查询都可以访问相同的数据，从而减少磁盘 I/O 操作，提高性能。</p></li><li><p>（4）缓冲池旁路<br>为了避免开销，顺序扫描操作符不会将获取的页存储在缓冲池中，而是使用正在运行的查询的本地内存。如果操作符需要读取磁盘上连续的大量页序列，那么这种方法可以很好地工作。缓冲池旁路也可以用于临时数据，如排序、连接。</p></li></ul><h4 id="1-3-4其他内存池"><a href="#1-3-4其他内存池" class="headerlink" title="1.3.4其他内存池"></a>1.3.4其他内存池</h4><p>除了元组和索引，DBMS还需要内存来存放其他东西。这些内存池中的内容可能并不总是来自磁盘或者需要写入磁盘，具体取决于实现。</p><ul><li>排序+连接缓冲区</li><li>查询缓存</li><li>维护缓冲区</li><li>日志缓冲区</li><li>字典缓存</li></ul><h3 id="1-4数据库系统架构"><a href="#1-4数据库系统架构" class="headerlink" title="1.4数据库系统架构"></a>1.4数据库系统架构</h3><p>事务管理器里面可以分为两个部分。</p><ol><li>日志与恢复，所有的 SQL 在对磁盘进行操作的时候都会写一些日志，比如物理日志，逻辑日志，并且会提供一定的恢复功能，该部分负责事务的持久性。</li><li>并发控制，即怎么来控制对数据的事务，并发控制包括锁和 MVCC。并发控制负责保证事务的原子性和孤立性。</li></ol><p>在存储层存在 Buffer Pool（缓冲池），所以不会直接从底层的磁盘中将数据提取出来。很多时候是通过 Buffer Pool 查询 Catalog，然后从 Catalog 中拿到所有的元数据信息，之后再发请求给存储管理器，由存储管理器最后发送到存储，然后从存储中将数据拿取出来。</p><h3 id="1-5LRU-K补充"><a href="#1-5LRU-K补充" class="headerlink" title="1.5LRU-K补充"></a>1.5LRU-K补充</h3><p>可以先去LeetCode把<a href="https://leetcode.cn/problems/lru-cache/">LRU</a>这个数据结构给做了,网上也有不少对应的学习资料。</p><h2 id="第二章-索引结构"><a href="#第二章-索引结构" class="headerlink" title="第二章 索引结构"></a>第二章 索引结构</h2><h3 id="2-1索引结构概述"><a href="#2-1索引结构概述" class="headerlink" title="2.1索引结构概述"></a>2.1索引结构概述</h3><p>对于很多查询来说，只涉及表中的部分记录，例如寻找id为4的人，如果为了找这个人将整个表读取进将会损失很多效率，理想情况下DBMS能够直接定位到该记录。为了支持这种访问方式，需要额外设计一些与表相关联的附加结构，我们称之为索引。DBMS中最常用的索引结构为B+树与散列表。</p><p>索引是这样的数据结构：它以一个或多个属性的值为输入，并能快速地定位具有该值的记录的位置。建立索引的属性（组）称为查找键（search key）。与表一样，索引结构同样存储在数据库文件中。例如，我们可以用一个数据文件来存储一个表，用一个索引文件来存储一个索引。一个数据文件可能拥有一个或多个索引文件。除此之外，由于索引是指定表的附加结构，需要与表的内容保持一致，因此当表更新时，DBMS也需要同步更新表的索引。</p><p>在数据库中存在不同类型的索引结构，这些索引结构各自有自己的优势，评价索引结构一般参考以下指标：</p><ul><li>查找类型：该索引结构能有效支持的查找类型，比如等值查找、范围查找等。</li><li>查找时间：使用该索引结构找到一个特定索引项（集）所需的时间。</li><li>插入时间：插入一个新的索引项所需的时间，包括找到插入这个新索引项的正确位置，以及更新索引结构所需的时间。</li><li>删除时间：删除一个索引项所需的时间，包括找到待删除项所需的时间， 以及更新索引结构所需的时间。</li><li>空间开销：索引结构所占用的存储空间。</li></ul><h3 id="2-2B-树"><a href="#2-2B-树" class="headerlink" title="2.2B+树"></a>2.2B+树</h3><h4 id="2-2-1B-树的结构"><a href="#2-2-1B-树的结构" class="headerlink" title="2.2.1B+树的结构"></a>2.2.1B+树的结构</h4><p>B+树是一种平衡排序树，树中根结点到叶结点的每条路径的长度相同，并且保持键的有序排列。在B+树中进行搜索、顺序访问、插入和删除的时间复杂度均为O(log(n))，它是在数据插入和删除的情况下仍能保持其执行效率的几种使用最广泛的索引结构之一，几乎所有现代DBMS都使用B+树。</p><p>B+树可以定义为具有以下性质的m路搜索树：</p><blockquote><ul><li>除非整棵树只有一个结点，<strong>否则根结点至少有两个子结点；</strong></li><li>除根结点外的<strong>所有内结点至少是半满的</strong>，即有⌈m/2⌉到m个子结点；</li><li>所有叶结点的深度相等；</li><li>叶结点中键的数量必须<strong>大于等于 ⌈(m-1)/2⌉ 且小于等于 m-1</strong> ；</li><li>每个有k个键的内结点都有k+1个非空子结点；</li><li>叶结点中包含所有查找键值。</li></ul></blockquote><p><img src="/posts/41900/image-20230914192825349.png" alt></p><p>树中的每个结点都包含了一个键值对，并且是按键值排序的，一般来说键（key）来自索引的查找键，值则根据结点类型有不同含义。</p><p>如果结点是内结点，那么值则是指向子结点的指针。如果结点是叶结点，则结点汇总的值则可能是记录ID，比如对于DB种的非聚集索引，B+树中存放的就是记录位置的指针；叶结点中的值也可能是记录数据，比如对于聚集索引， B+树中存放的就是记录的实际数据。在树的最底层，叶结点间通过兄弟指针链接起来，形成一个按所有键值大小排序的链表，以便更高效地支持范围查找等顺序处理。</p><p>在上图中的B+树，m取值为4。具体实现上，把B+树索引存储到磁盘文件中的时候，通常是一个页面来存储一个结点，在页面空间能够允许的前提下应该把m取得尽可能的大，让树的高度降低来提高查询的效率。</p><h4 id="2-2-2B-树的查找"><a href="#2-2-2B-树的查找" class="headerlink" title="2.2.2B+树的查找"></a>2.2.2B+树的查找</h4><h5 id="2-2-2-1等值查找"><a href="#2-2-2-1等值查找" class="headerlink" title="2.2.2.1等值查找"></a>2.2.2.1等值查找</h5><p>对于一棵B+树，如果想找出键值为K的记录，则需要执行从根结点到叶结点的递归查找，查找过程为：</p><ol><li>若当前结点为内结点，且结点中的键为<strong>K1，K2，…，Kn</strong>，则根据以下规则来决定下一步对此结点的哪一个子结点进行查找：</li><li>如果<strong>K&lt;K1</strong>，则下一个结点为第1个子结点；</li><li>如果<strong>Ki≤K&lt;Ki+1</strong>，则下一个结点为第i+1个子结点；</li><li>如果<strong>K≥Kn</strong>，则下一个结点为第n+1个子结点。</li></ol><p>递归执行此查找过程，直到查找到叶结点，若当前结点为叶结点，在该结点的键值中查找，若第i个键值为K，则根据第i个值即可找到所需记录；否则查找失败。</p><h5 id="2-2-2-2范围查找"><a href="#2-2-2-2范围查找" class="headerlink" title="2.2.2.2范围查找"></a>2.2.2.2范围查找</h5><p>如果想在B+树中找出在范围[a, b]之间的所有键值，先通过等值查找来查找键a，不论键a在B+树中是否存在，都会到达可能出现a的叶结点，然后在该叶结点中查找等于或大于a的那些键。只要在当前叶结点中不存在比b大的键，就根据兄弟指针找到下一个叶结点，继续查找[a, b]之间的所有键值。</p><p>上面的查找算法在查找范围只有上界或者只有下界时也有效：</p><ol><li>当查找范围为[a,+∞)时，先找到键a可能出现的叶结点，然后从该结点中第一个等于或大于a的键开始，一直到最后一个叶结点的最后一个键。</li><li>当查找范围为(‐∞, b]时，则从B+树的第一个叶结点开始向后查找，直到遇到第一个超过b的键时停止查找。</li></ol><h4 id="2-2-3B-树的插入"><a href="#2-2-3B-树的插入" class="headerlink" title="2.2.3B+树的插入"></a>2.2.3B+树的插入</h4><p>向B+树中插入一个新索引项，必须遍历该树并使用内部结点来确定将键插入到哪个叶结点。在插入过程中，当结点太满时需要对其进行拆分，过程如下：</p><ol><li>找到正确的叶结点L；</li><li>将新索引项按顺序插入到L中：</li><li>如果L有足够的空间，则执行插入操作，算法结束；</li><li>否则，将L平均拆分为L和L2两个结点，并复制L2的第一个键，将其插入到L的父结点中。</li><li>如果父结点中有足够的空间，则执行插入操作，算法结束；否则拆分父结点，将该结点的中间键上移插入到其父结点，然后将剩余的索引项平均拆分为两个结点。递归执行此步骤直到算法结束。</li></ol><p><img src="/posts/41900/image-20230914195822660.png" alt></p><p>上图是向一棵4路B+树分别插入键值10和2的过程。可以看到，插入键值10后，原B+树中最右的叶结点发生了分裂，新增叶结点的第一个键值10被复制并插入到父结点中。插入键值2后，最左的叶结点发生了分裂，新增叶结点的第一个键值3被复制并插入到父结点中，而且还进一步导致了父结点的分裂，其中间键值7被上移并插入到新增的根结点中。</p><h4 id="2-2-4B-树的删除"><a href="#2-2-4B-树的删除" class="headerlink" title="2.2.4B+树的删除"></a>2.2.4B+树的删除</h4><p>在删除过程中，如果因删除索引项导致结点小于半满状态，则必须合并结点。过程如下：</p><ol><li>找到待删除的索引项所在的叶结点L；</li><li>从L中删除该索引项，删除后：</li><li>如果L不低于半满状态，则算法结束；</li><li>否则，通过向兄弟结点借索引项来满足约束条件，如果能成功借到，则算法结束；</li><li>如果兄弟结点也没有多余的索引项可借，则合并L和兄弟结点，删除父结点中指向被合并子结点的索引项。递归执行以上删除操作，直至算法结束。</li></ol><p><img src="/posts/41900/image-20230914205010129.png" alt></p><p>从一棵5路B+树中先后删除键值6和1的过程。可以看到，删除键值6时，原B+树中第二个叶结点中的项数已经无法满足最低要求，因此向左边的兄弟结点借了1项来达到约束条件。删除键值1时，最左的叶结点中项数无法满足最低要求，而且兄弟结点也没有多余的项可借，因此只能对最左的两个结点进行合并。</p><h4 id="2-2-5非唯一查找键"><a href="#2-2-5非唯一查找键" class="headerlink" title="2.2.5非唯一查找键"></a>2.2.5非唯一查找键</h4><p>基于某个查找键来构建索引时，假如表中存在两条或者多条记录在查找键属性上拥有相同的值，那么该查找键称为非唯一查找键。</p><p>非唯一查找键的一个问题在于影响记录删除的效率。假设某个查找键值出现了很多次，当表中拥有该查找键值的某条记录被删除时，为了维护索引与表数据的一致性，删除操作需要在B+树中查看很多个索引项，才能从中找出和被删除记录相对应的那个索引项并删除它，这个过程可能需要遍历多个叶结点。</p><p>解决以上问题的方法有两种：</p><p>一种简单的解决方法是创建包含原始查找键和其他额外属性的复合查找键，确保该复合查找键对于所有记录是唯一的，这种方法通常被大多数数据库系统使用。这个额外属性也叫唯一化属性，它可以是记录ID，或者是在拥有相同查找键值的所有记录中取值唯一的任何其他属性。删除一条记录时，先计算该记录的复合查找键值，然后再用这个复合键值到索引中查找。因为复合查找键值是唯一的，所以不会影响记录删除的效率。在这种方法中，一个查找键值在记录中出现多少次，它在索引中就会被重复存储多少次。</p><p>另一种方法是，每个查找键值在B+树中只存储一次，并且为该查找键值维护一个记录指针的桶（或者列表）来解决非唯一问题。这种方法虽然没有存储冗余信息，但是索引维护和修改起来更加复杂。</p><h3 id="2-3散列表"><a href="#2-3散列表" class="headerlink" title="2.3散列表"></a>2.3散列表</h3><p>散列表也叫哈希表，是一种常见的数据结构，它通过把键值映射到桶数组中的某个位置来加快查找记录的速度。散列表中包含两个关键元素：</p><ul><li><strong>散列函数</strong> ：散列函数h以查找键（散列键）为参数并计算出一个介于0到B-1之间的整数。</li><li><strong>桶数组</strong> ：桶数组是一个编号从0到B-1、长度为B的数组，其中包含B个链表头，每个链表头对应一个桶，用于存储记录。</li></ul><p>构造散列表时，如果一条记录的查找键为K，则将该记录链接到桶号为h(K)的桶中存储。</p><p>散列表在DBMS中被广泛运用，例如基于散列表来组织数据文件、基于散列表来构造索引文件、或者基于散列表进行连接运算等。当散列表的规模大到内存难以容纳时，或者出于数据持久化的目的，就需要将散列表存储在磁盘中。本教程主要讨论散列表在磁盘上的实现。</p><p>磁盘中的散列表与内存中的散列表存在一些区别。首先，桶数组是由页面组成，而不是由指向链表的指针组成；其次，散列到某个桶中的记录是存储在磁盘上的页面而非内存中。因此，磁盘上的散列表在设计时需要考虑访问磁盘的I/O代价以及表规模的扩展问题。</p><h4 id="2-3-1静态散列表"><a href="#2-3-1静态散列表" class="headerlink" title="2.3.1静态散列表"></a>2.3.1静态散列表</h4><p>对于一个散列表，如果其桶数组的规模B（即桶的数量）一旦确定下来就不再允许改变，则称其为静态散列表。</p><h5 id="2-3-1-1散列函数"><a href="#2-3-1-1散列函数" class="headerlink" title="2.3.1.1散列函数"></a>2.3.1.1散列函数</h5><p>由于在设计时无法事先准确知道文件中将存储哪些搜索键值，因此我们希望选择一个具有下列特性的散列函数：</p><ul><li>函数的输出是确定的。相同的搜索键值应该总是生成相同的散列值。</li><li>输出值的分布是随机且均匀的。散列函数应该表现为随机的，即散列值不应与搜索键的任何外部可见的排序相关，且不管搜索键值实际怎样分布，每个桶应分配到的记录数应该几乎相同。</li><li>易于计算。散列函数的执行时间不能太长，因为它需要执行很多次。</li></ul><p>理想的散列函数是能将搜索键值均匀地分布到所有桶中，使每个桶含有相同数目的记录，但是这样的函数往往需要非常长的时间来进行计算。因此，散列函数需要在冲突率和快速执行之间进行权衡。目前最先进的散列函数是Facebook XXHash3。</p><h5 id="2-3-1-2散列表的插入"><a href="#2-3-1-2散列表的插入" class="headerlink" title="2.3.1.2散列表的插入"></a>2.3.1.2散列表的插入</h5><p>当一个查找键为K的新记录需要被插入时，先计算h(K)，找到桶号为h(K)的桶。如果桶内还有空间，我们就把该记录存放到此桶对应的页面中。如果该桶的页面中已经没有空间了，就增加一个新的溢出页，链接到该桶之后，并把新记录存入该页面。这种处理桶溢出问题的方式称为溢出链。<br><img src="/posts/41900/image-20230914210727908.png" alt></p><h5 id="2-3-1-3散列表的删除"><a href="#2-3-1-3散列表的删除" class="headerlink" title="2.3.1.3散列表的删除"></a>2.3.1.3散列表的删除</h5><p>删除查找键值为K的记录与插入操作的方式类似。先找到桶号为h(K)的桶，由于不同的查找键值可能被映射到同一个桶中，因此还需要在桶内搜索，查找键值为K的记录，继而将找到的记录删除。删除记录后，如果允许记录在页面中移动，还可以选择合并同一桶链上的页面来减少链的长度。但是合并页面也有一定的风险，如果交替地往一个桶中插入和删除记录，可能导致页面被反复地创建和删除。</p><h5 id="2-3-1-4散列表的效率"><a href="#2-3-1-4散列表的效率" class="headerlink" title="2.3.1.4散列表的效率"></a>2.3.1.4散列表的效率</h5><p>如果希望达到最好的查找效率，理想情况是散列表中有足够的桶，每个桶只由单个页面组成。如果是这样，那么查询一条记录就只需一次磁盘I/O，且记录的插入和删除也只需两次磁盘I/O。</p><p>为了减少桶溢出的可能性，桶的数量B可选为 (<em>n</em>/<em>f</em>)*(1+<em>d</em>)，其中n是要存储的记录总数，f是一个桶中能存放的记录数，d表示避让因子，一般取值为0.2。这种做法会导致一定的浪费，平均每个桶有20%的空间是空的，好处则是减少了溢出的可能性。</p><p>但是，如果记录不断增长，而桶的数量固定不变，那么最终还是会出现很多桶都包含多个页面的情况。这种情况下，我们就需要在由多个页面构成的桶链中查找记录，每访问一个新的页面就增加一次磁盘I/O，这显然会严重影响散列表的查找效率。</p><h4 id="2-3-2动态散列表"><a href="#2-3-2动态散列表" class="headerlink" title="2.3.2动态散列表"></a>2.3.2动态散列表</h4><p>静态散列表由于其桶的数量不能改变，因此当无法预知记录总数时，难以解决由于记录数不断增长而带来的性能问题。本节我们将讨论两种动态散列表，它们能够以不同的方式动态调整散列表的大小，既不需要重新构建整个表，又能保证每个桶大多只有一个页面，从而最大化读写效率。</p><h5 id="2-3-2-1可扩展散列表"><a href="#2-3-2-1可扩展散列表" class="headerlink" title="2.3.2.1可扩展散列表"></a>2.3.2.1可扩展散列表</h5><p>与静态散列表相比，可扩展散列表在结构上做了以下改变：</p><ul><li>增加了一个间接层，用一个指向页面的指针数组（桶地址表）而非页面数组来表示桶数组。</li><li>指针数组能动态增长，且数组长度总是2的幂，因此数组每增长一次，桶的数量就翻倍。</li><li>并非每个桶都单独拥有一个页面。如果多个桶的记录只需一个页面就能放下，那么这些桶可能共享一个页面，即多个桶指针指向同一个页面。</li><li>散列函数h为每个键计算出一个长度为N的二进制序列，N的值足够大（比如32），但是在某一时刻，这个序列中只有前i位（i≤N）被使用，此时桶的数量为 2i个。<br><img src="/posts/41900/image-20230914211706915.png" alt></li></ul><p>向可扩展散列表中插入键值为K的记录的方法如下：</p><ol><li>计算h(K)，取出该二进制序列的前i位，并找到桶数组中编号与之相等的项，定位到该项对应的页面，假设该页面的编号为j；</li><li>如果页面j中还有剩余空间，则将该记录插入该页面，操作结束；</li><li>如果页面j已满，则需要分裂该页面：<br> a) 如果i＝ij，说明在桶地址表中只有一个表项指向页面j，此时分裂该页，需要增加桶地址表的 大小，以容纳由于分裂而产生的两个桶指针。令i=i+1，使桶地址表的大小翻倍。桶地址表扩 展后，原表中的每个表项都被两个表项替代，且这两个表项都包含和原始表项一样的指针， 所以也应该有两个表项指向页面j。此时，分配一个新的页面n，并让第二个表项指向页面n。 将ij和in的值均置为当前的i值，并将原页面j中的各条记录重新散列，根据前i位来确定该记录 是放在页面j中还是页面n中，然后再次尝试插入新记录。极端情况下，新纪录要插入的页面 可能仍然是满的，说明原页面j中的所有记录在分裂后仍然被散列到了同一个页面中，此时需 要继续上述分裂过程，直至为新纪录找到可存放的空间。<br> b) 如果i&gt; ij，说明在桶地址表中有多个表项指向页面j，此时不需要扩大桶地址表就能分裂页面 j。分配一个新的页面n，将ij和in置为原ij加1后的值；调整桶地址表中原来指向页面j的表项， 其中一半仍指向页面j，另一半则指向新创建的页面n；重新散列页面j中的各条记录，将其分 配到页面j或页面n中，并再次尝试插入新记录。与上一种情况一样，插入仍有可能失败，此 时需继续进行页面分裂的处理。</li></ol><p>以下是一个可扩展散列表的例子。图1所示为一个小型的可扩展散列表，假设其散列函数h能产生4位二进制序列，即N=4。散列表只使用了1位，即i=1。此时桶数组只有2项，一个编号为0，一个编号为1，分别指向两个页面。第一页存放所有散列值以0开头的记录，第二页存放所有散列值以1开头的记录。每个页面上都标注了一个数字，表示由散列函数得到的二进制序列中的前几位用于判定记录在该页面中的成员资格。目前两个页面都只用了1位。</p><p>接下来向表中插人一个散列值为1010序列的记录。因为第一位是1，所以该记录应放入第二个页面，但第二页已经满了，因此需要分裂该页。而此时i2=i=l，因此先要将桶数组翻倍，令i=2，将数组的长度扩展为4。</p><p>扩展桶数组后，以0开头的两个项都指向存放散列值以0开头的记录的第一页，且该页上标注数字仍然为1, 说明该页中记录的成员资格只由其散列值的第一位判定。而原本存放散列值以1开头的记录的页面则需要分裂，把这个页面中以10开头和11开头的记录分别存放到两个页面中。在这两个页面上方标注的数字是2，表示该页面中记录的成员资格需要使用散列值的前两位来判定。改变后的散列表如图2所示。<br><img src="/posts/41900/image-20230914212007010.png" alt><br>可扩展散列表的优点在于每个桶只有一个页面，所以如果桶地址表小到可以驻留在内存的话，查找一个记录最多只需要一次磁盘I/O。但是由于它是以桶数组翻倍的形式扩展的，所以也存在以下缺点：</p><ul><li>随着i的增大，每次桶数组翻倍时需要做的工作将越来越多，而且这些工作还会阻塞对散列表的并发访问，影响插入和并发操作的效率。</li><li>随着i的增大，桶地址表会越来越大，可能无法全部驻留在内存，或者会挤占其他数据在内存中的空间，导致系统中的磁盘I/O操作增多。</li></ul><h5 id="2-3-2-2线性散列表"><a href="#2-3-2-2线性散列表" class="headerlink" title="2.3.2.2线性散列表"></a>2.3.2.2线性散列表</h5><p>针对可扩展散列表存在的问题，下面介绍另一种动态散列表，称为线性散列表。相对于可扩展散列表，线性散列表中桶的增长较为缓慢，它有以下特点：</p><ul><li>桶数n的大小，要能使所有桶中的实际记录总数与其能容纳的记录总数之间的比值保持在一个指定的阈值之下（如80%），如果超过该阈值，则增加一个新桶。</li><li>允许桶有溢出页，但是所有桶的平均溢出页数远小于1。</li><li>若当前的桶数为n，则桶数组项编号的二进制位数i=⌈ log2n⌉。</li></ul><p>令一个线性散列表当前桶数为n，桶数组项编号的二进制位数为i，向线性散列表中插入键值为K的记录的方法如下：</p><ol><li>计算h(K)，取出该二进制序列右端的i位，假设为a1a2…ai，令a1a2…ai对应的二进制整数为m。如果m&lt;n，说明编号为m的桶存在，将记录存入桶m中；如果n≤m&lt;2i，说明编号为m的桶还不存在，则将记录存入编号为(m-2i-1)的桶中，即将a1a2…ai中的a1改为0时对应的桶。</li><li>如果要插入的桶中没有空间，则创建一个溢出页，将其链到该桶上，并将记录就存入该溢出块中。</li><li>插入记录后，计算 (当前实际记录总数r) / (n个桶能容纳的记录总数) 的值，并跟阈值相比，若超过阈值，则增加一个新桶到线性散列表中。注意，新增加的桶和之前发生插入的桶之间没有任何联系。如果新桶编号的二进制表示为la2a3…ai，则分裂桶号为0a2a3…ai的桶中的记录，根据这些记录的散列值的后i-1位分别散列到这两个桶中。</li></ol><p>当n的值超过2i时，需要将i的值加1。理论上，对于现有的桶编号，要在它们的位序列前面增加一个0，来保证跟新的桶编号的位数一致，但是由于桶编号被解释成二进制整数，因此实际上它们只需要保持原样即可。</p><p>以下是一个线性散列表的例子。</p><p>图1所示为一个桶数n=2 的线性散列表，桶编号所需要的二进制位数i = ⌈ log22⌉ = 1，表中的记录数r=3。图中两个桶的编号分别为0和1，每个桶包含一个页面，每个页面能存放两个记录。假设散列函数产生4位二进制序列，用记录散列值的末位来确定该记录所属的桶，所有散列值以0结尾的记录放入第一个桶，以1结尾的记录放入第二个桶。</p><p>在确定桶数n时，本例使用的阈值是85%，即桶的平均充满率不超过总容量的85%。</p><p>下面先插入散列值为0101的记录。因为0101以1结尾，所以记录应放入第二个桶。插入该记录后，两个桶中存放了四个记录，平均充满率为100%，超过了85%，因此需要增加一个新桶，即桶数n=3。i = ⌈log23⌉ = 2，即桶编号需要2位。新增的桶的编号为10。接着，分裂桶00（即原来的桶0），将散列值为0000 （末两位为00）的记录保留在桶00中，散列值为1010（末两位为10）的记录存入桶10中，改变后的散列表如图2所示。</p><p>接下来再插入散列值为0001的记录。因为0001的末两位为01，所以应将该记录存入桶01中。不巧的是，该桶的页面已经装满，所以需要增加一个溢出页来提供存储空间。插入后，3个桶中有5条记录，平均充满率约83%，未超过85%，所以不需要创建新桶。改变后的散列表如图3所示。<br><img src="/posts/41900/image-20230914212247020.png" alt></p><h3 id="2-4B-树补充"><a href="#2-4B-树补充" class="headerlink" title="2.4B+树补充"></a>2.4B+树补充</h3><p>B树和B+树的目的是实现一个自组织的多级索引，B+树与B树相比，B+树的内部节点只存储键值对的键，而不存储数据。所有数据都存储在叶子节点中。叶子节点之间通过指针链接形成一个有序链表，以便支持范围查询。在插入和删除时，B树可能需要在内部节点中进行数据的移动，而B+树只需要在叶子节点中进行操作。</p><p>B+树的通过叶子结点的Pnext指针范围查询时，其IO读取次数不是一次。在B+树中，每一个叶子结点都是一页，即IO单位读取的字节大小，每遍历一个叶子节点时，都会有一次IO读取。</p><p><strong>B+树相比B树减少了IO次数的真正原因</strong>：B+树的索引页不包含数据，因此一个数据页可查询到很多索引，降低下一次去磁盘再拿索引页的可能性。</p><p>对应的B+树也就是类似于操作系统中的多级索引，通过增加索引，用少量的存储空间来换取对应的快速查找，减少访问块拿取数据所耗的时间，使得一个块中尽可能多的包含所需的信息（无论是查找还是所需数据）。</p><p>为什么用B+树？<strong>InnoDB一棵B+树可以存放多少行数据?</strong></p><blockquote><p>这个问题的简单回答是：约2千万行。  </p></blockquote><ul><li>在计算机中，磁盘存储数据最小单元是扇区，一个扇区的大小是512字节。</li><li>文件系统中，最小单位是块，一个块大小就是4k;</li><li>InnoDB存储引擎最小储存单元是页，一页大小就是16k。</li></ul><p><img src="/posts/41900/image-20230915160729536.png" alt></p><p>因为B+树叶子存的是数据，内部节点存的是键值+指针。索引组织表通过非叶子节点的二分查找法以及指针确定数据在哪个页中，进而再去数据页中找到需要的数据;</p><p><img src="/posts/41900/image-20230915160744079.png" alt></p><p>假设B+树的高度为2的话，即有一个根结点和若干个叶子结点。这棵B+树的存放总记录数为=根结点指针数*单个叶子节点记录行数。  </p><ul><li>如果一行记录的数据大小为1k，那么单个叶子节点可以存的记录数 =16k/1k =16.</li><li>非叶子节点内存放多少指针呢?我们假设主键ID为bigint类型，长度为8字节，而指针大小在InnoDB源码中设置为6字节，所以就是8+6=14字节，16k/14B =16*1024B/14B = 1170</li></ul><p>因此，一棵高度为2的B+树，能存放1170 * 16=18720条这样的数据记录。同理一棵高度为3的B+树，能存放1170 *1170 *16 =21902400，也就是说，可以存放两千万左右的记录。B+树高度一般为1-3层，已经满足千万级别的数据存储。</p><h4 id="2-4-1B-树的插入操作"><a href="#2-4-1B-树的插入操作" class="headerlink" title="2.4.1B+树的插入操作"></a>2.4.1B+树的插入操作</h4><p>在B+树中插入关键字时，需要注意以下几点：</p><ul><li>插入的操作全部都在叶子结点上进行，且不能破坏关键字自小而大的顺序；</li><li>由于 B+树中各结点中存储的关键字的个数有明确的范围，做插入操作可能会出现结点中关键字个数超过阶数的情况，此时需要将该结点进行 “分裂”；</li></ul><p>B+树的阶数 <code>M = 3</code> ，且 <code>⌈M/2⌉ = 2（取上限）</code> 、<code>⌊M/2⌋ = 1（取下限）</code>,B+树的阶数是指一个B+树节点中最多可以包含的子节点数量（子树的数量），这个参数决定了B+树的节点大小以及树的结构，其中<strong>键的数量为阶数-1</strong>。</p><p>B+树中做插入关键字的操作，有以下 3 种情况：</p><ul><li>1、 若被插入关键字所在的结点，其含有关键字数目小于阶数 M，则直接插入；</li></ul><p>比如插入关键字 <code>12</code> ，插入关键字所在的结点的 <code>[10，15]</code> 包含两个关键字，小于 <code>M</code> ，则直接插入关键字 <code>12</code> 。</p><p><img src="/posts/41900/v2-386cefe3c3c93b726387ee2abc577691_b.webp" alt></p><ul><li>2、 若被插入关键字所在的结点，其含有关键字数目等于阶数 M，则需要将该结点分裂为两个结点，一个结点包含 <code>⌊M/2⌋</code> ，另一个结点包含 <code>⌈M/2⌉</code> 。同时，将<code>⌈M/2⌉</code>的关键字上移至其双亲结点。假设其双亲结点中包含的关键字个数小于 M，则插入操作完成。</li></ul><p>插入关键字 <code>95</code> ，插入关键字所在结点 <code>[85、91、97]</code> 包含 3 个关键字，等于阶数 <code>M</code> ，则将 <code>[85、91、97]</code> 分裂为两个结点 <code>[85、91]</code> 和结点 <code>[97]</code> , 关键字 <code>95</code> 插入到结点 <code>[95、97]</code> 中，并将关键字 <code>91</code> 上移至其双亲结点中，发现其双亲结点 <code>[72、97]</code> 中包含的关键字的个数 2 小于阶数 <code>M</code> ，插入操作完成。<br><img src="/posts/41900/v2-4e621ab9044dcb42643066f6031226b0_b.webp" alt></p><ul><li>3、在第 2 情况中，如果上移操作导致其双亲结点中关键字个数大于 M，则应继续分裂其双亲结点。</li></ul><p>插入关键字 <code>40</code> ，按照第 2 种情况将结点分裂，并将关键字 <code>37</code> 上移到父结点，发现父结点 <code>[15、37、44、59]</code> 包含的关键字的个数大于 <code>M</code> ，所以将结点 <code>[15、37、44、59]</code> 分裂为两个结点 <code>[15、37]</code> 和结点 <code>[44、59]</code> ，并将关键字 <code>37</code> 上移到父结点中 <code>[37、59、97]</code> . 父结点包含关键字个数没有超过 <code>M</code> ，插入结束。</p><p><img src="/posts/41900/v2-467b2c27f41bad29b01be13e1e5cd1bb_b.webp" alt></p><ul><li>4、若插入的关键字比当前结点中的最大值还大，破坏了B+树中从根结点到当前结点的所有索引值，此时需要及时修正后，再做其他操作。</li></ul><p>插入关键字 <code>100</code>，由于其值比最大值 <code>97</code> 还大，插入之后，从根结点到该结点经过的所有结点中的所有值都要由 <code>97</code> 改为 <code>100</code>。改完之后再做分裂操作。<br><img src="/posts/41900/v2-85fb69b1f6d5134f45808fc884ad2e4a_b.webp" alt></p><h4 id="2-4-2B-树的删除操作"><a href="#2-4-2B-树的删除操作" class="headerlink" title="2.4.2B+树的删除操作"></a>2.4.2B+树的删除操作</h4><p>在 B+树中删除关键字时，有以下几种情况：</p><ul><li>1、 找到存储有该关键字所在的结点时，由于该结点中关键字个数大于<code>⌈M/2⌉</code>，做删除操作不会破坏 B+树，则可以直接删除。</li></ul><p>删除关键字 <code>91</code>，包含关键字 <code>91</code> 的结点 <code>[85、91、97]</code> 中关键字的个数 3 大于 <code>⌈M/2⌉ = 2</code> ，做删除操作不会破坏 B+树的特性，直接删除。</p><p><img src="/posts/41900/v2-7607b34265b14b3527101d53ce9c2b70_b.webp" alt></p><ul><li>2、 当删除某结点中最大或者最小的关键字，就会涉及到更改其双亲结点一直到根结点中所有索引值的更改。</li></ul><p>以删除整颗 B+树中最大的关键字 <code>97</code> 为例，查找并删除关键字 <code>97</code> ， 然后向上回溯，将所有关键字 <code>97</code> 替换为次最大的关键字 <code>91</code> :</p><p><img src="/posts/41900/v2-3aee225a4ba3e3a1b428e3f30e312637_b.webp" alt></p><ul><li>3、 当删除该关键字，导致当前结点中关键字个数小于 <code>⌈M/2⌉</code>，若其兄弟结点中含有多余的关键字，可以从兄弟结点中借关键字完成删除操作。</li></ul><p>当删除某个关键字之后，结点中关键字个数小于 <code>⌈M/2⌉</code> ，则不符合 B+树的特性，则需要按照 3 he 4 两种情况分别处理。以删除关键字 <code>51</code> 为例，由于其兄弟结点 <code>[21、37、44]</code> 中含有 3 个关键字，所以可以选择借一个关键字 <code>44</code>，同时将双亲结点中的索引值 <code>44</code> 修改 <code>37</code> ，删除过程如下图所示：</p><p><img src="/posts/41900/v2-8dae05b8aa006d6d1fc6bb54c24169a5_b.webp" alt></p><ul><li>4、 第 3 种情况中，如果其兄弟结点没有多余的关键字，则需要同其兄弟结点进行合并。</li></ul><p>为了说明这种情况，我们在第 3 种情况最终得到的 B+树之上进行删除操作。第 3 种情况删除关键字 <code>51</code> 之后得到如下所示 B+树：<br><img src="/posts/41900/image-20230915141924729.png" alt></p><p>我们以删除上面这个 B+树中的关键字 <code>59</code> 说明第 4 种情况，首先查找到关键 <code>59</code> 所在结点 <code>[44、59]</code> ，发现该结点的兄弟结点 <code>[21、37]</code> 包含的关键字的个数 2 等于 <code>⌈M/2⌉</code>， 所以删除关键字 <code>59</code> ，并将结点 <code>[21、37]</code> 和 <code>[44]</code> 进行合并 <code>[21、37、44]</code> ，然后向上回溯，将所有关键字 <code>59</code> 替换为次最大的关键字 <code>44</code> :</p><p><img src="/posts/41900/v2-c33a70c8eaa38e96c3052a6bddc9d0d4_b.webp" alt></p><ul><li>5、 当进行合并时，可能会产生因合并使其双亲结点破坏 B+树的结构，需要依照以上规律处理其双亲结点。</li></ul><p>删除关键字 <code>63</code>，当删除关键字后，该结点中只剩关键字 <code>72</code>，且其兄弟结点 <code>[85、91]</code> 中只有 2 个关键字，所以将 <code>[72]</code> 和 <code>[85、91]</code> 进行合并，向上回溯，删除结点 <code>[72、91]</code> 当中的关键字 <code>72</code> ，此时结点中只有关键 <code>91</code> ，不满足 B+树中结点关键字个数要求，但其兄弟结点 <code>[15、44、59]</code> 中包含的 3 个关键字，所以从其兄弟结点当中借一个关键字 <code>59</code> , 再对其兄弟结点的父结点中的关键字进行调整，将关键字 <code>59</code> 替换为 <code>44</code> .</p><p><img src="/posts/41900/v2-ae4011609fdf74e80d10fefb9e47dbb8_b.webp" alt></p><p>总之，在 B+树中做删除关键字的操作，采取如下的步骤：</p><ol><li>删除该关键字，如果不破坏 B+树本身的性质，直接完成删除操作（情况 1）；</li><li>如果删除操作导致其该结点中最大（或最小）值改变，则应相应改动其父结点中的索引值（情况 2）；</li><li>在删除关键字后，如果导致其结点中关键字个数不足，有两种方法：一种是向兄弟结点去借，另外一种是同兄弟结点合并（情况 3、4 和 5）。（注意这两种方式有时需要更改其父结点中的索引值。）</li></ol><h3 id="2-5动态散列表补充"><a href="#2-5动态散列表补充" class="headerlink" title="2.5动态散列表补充"></a>2.5动态散列表补充</h3><p>静态哈希有一个<strong>大前提就是我们事前是知道哈希表需要容纳多少键值对的</strong>，否则如果出现预设的容量过大或者过小问题时对其扩容或者缩容的代价都比较大（可以采用一致性哈希）。</p><p>因此，为了解决这个问题，提出了一些<strong>动态</strong>的哈希方案，即哈希表的运行的过程中<strong>可以按需增长或者减小</strong>。下面介绍三种动态哈希方案：</p><h4 id="2-5-1-链式哈希"><a href="#2-5-1-链式哈希" class="headerlink" title="2.5.1 链式哈希"></a>2.5.1 链式哈希</h4><p>这是最简单的动态哈希方案，也是java或者jvm中默认的哈希方案。链式哈希中，哈希表中数组的成员是buckets的链表，因此，当发生冲突时，将<strong>元素添加到对应Bucket的末尾</strong>即可，<strong>如果Bucket已满，则创建一个新的Bucket即可。</strong><br><img src="/posts/41900/v2-8514108512a37c72b1b7538ff6a4b433_720w.webp" alt></p><h4 id="2-5-2-可扩展哈希"><a href="#2-5-2-可扩展哈希" class="headerlink" title="2.5.2 可扩展哈希"></a>2.5.2 可扩展哈希</h4><p>链式哈希的一种改进，每个桶不<strong>再链式的生长</strong>，而是用<strong>分裂的方式来扩展</strong>，分裂的过程只会移动被分裂的桶中的元素，而不会影响其他的元素。</p><p>如下图所示，可扩展哈希方式<strong>包含一个slot数组和一系列的桶，每个slot中保存对应桶的指针。对于slot数组有一个全局bit位</strong>，记录在这个哈希表中<strong>需要多少位</strong>才能找到对应桶，对于每一个桶，有一个本地bit位，<strong>记录找到本地的桶需要多少位</strong>。<br>[注意]: 公式$$global_{bit} = \max(local_{bit})$$下图全局bit和本地bit的关系。<br><img src="/posts/41900/image-20230916192810224.png" alt></p><ul><li><strong>Global Depth</strong>：假设global depth为n，那么当前的directory必定有 2� 个entry。例如，当前n=2，那么就有4个entry，n=3就有8个entry。同时，给定一个key，需要用global depth取出这个key的低n位的二进制值。例如，一个key的二进制是10111，如果global depth是3，通过<code>IndexOf(key)</code>函数，得到返回值的二进制值是111，即为7。这个值用来索引directory[111]位置的bucket。</li><li><strong>Local Depth</strong>：local depth指的是（假设local depth为n），在当前的bucket之下，每个元素的key的低n位都是相同的。</li></ul><p>两者之间有什么关系呢？</p><ul><li>对于一个bucket来说，如果当前的global depth等于local depth，那说明这个bucket只有一个指针指向它。</li><li>如果当前的global depth大于local depth，必定不止一个指针指向它。</li><li>计算当前bucket有几个指针指向它的公示是$2^{globalDepth-localDepth}$ 。</li></ul><p><img src="/posts/41900/image-20230918171023892.png" alt></p><p>关于对应的entry的增长，这一步有一个很重要的点，新增长的entry怎么分配到对应的bucket？如果和上图的情况一样，从1增长到2，只需要把多出来的一个拉到唯一的bucket上就可以了，但如果从2到4，从4到8呢？多出来的若干个如何处理？其实只需要将多出来的一部分指针完全复制之前的一份就可以了。</p><p>这样做法我觉得是可扩展哈希的比较重要的细节，由于可扩展哈希扩展direcotry时是按照当前大小的两倍进行扩展，新增长出来的部分作为之前directory的对等实体，每一个新的entry都对应了之前对应的entry，指向相同的bucket。唯一的不同就是之前的direcotry的索引最高位是0，扩展出来的最高位是1。</p><p><img src="/posts/41900/image-20230918171031231.png" alt></p><p>一个比较好的解释可以看<a href="https://zhuanlan.zhihu.com/p/622221722">这份实验解说</a>，讨论了可拓展哈希表的一些细节。</p><h4 id="2-5-3-线性哈希"><a href="#2-5-3-线性哈希" class="headerlink" title="2.5.3 线性哈希"></a>2.5.3 线性哈希</h4><p>线性哈希是可扩展哈希的改进，可扩展哈希有一个<strong>小的性能瓶颈</strong>，在桶分裂且需要扩展slot array时，需要对整个slot array加锁直到桶分裂完成。为了解决这个问题，提出了线性哈希方式。哈希表<strong>维护一个指针</strong>，指向下一个准备分裂的桶，并且线性哈希采用<strong>多个哈希函数</strong>来寻找正确的桶。</p><p><strong>当插入过程中</strong>，任何一个桶溢出，都将分裂指针指向桶（无论这个桶是否溢出）。最初，指针指向第一个桶，即当任何一个桶发生溢出时，都分裂第一个桶。且现在只有一个哈希函数。<br><img src="/posts/41900/image-20230916192838988.png" alt></p><p>现需要插入17，发现对应的桶已满，发生了溢出，因此需要分裂第一个桶.</p><p><img src="/posts/41900/image-20230916192850195.png" alt></p><p>现在将第一个桶分裂，就需要增加一个桶，那么哈希表中已经有了5个桶，原来的哈希函数中的n为4，不能满足使用要求，需要增加新的哈希函数$ℎasℎ_2$。然后使用新的哈希函数重新分配第一个桶中的元素。<br><img src="/posts/41900/image-20230916192924840.png" alt></p><p>现在再来观察查询过程，现在需要查询20，首先使用第一个哈希函数，发现哈希值为0，即第一个桶。但是这个哈希值落在了分裂指针的上面，即要查询的值落在一个已经分裂的桶上，而这个桶中的所有键值对已经用第二个哈希函数重新分配位置，因此，需要用第二个哈希函数重新计算哈希值为4，即第五个桶中，然后在这个桶中循序查询即可。<br><img src="/posts/41900/image-20230916192937036.png" alt></p><h3 id="2-6SQL索引背后"><a href="#2-6SQL索引背后" class="headerlink" title="2.6SQL索引背后"></a>2.6SQL索引背后</h3><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。因为数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构就是索引。</p><p><img src="/posts/41900/image-20230915145557510.png" alt></p><p>以上图为例子，左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在(O(log_2n))的复杂度内获取到相应数据。</p><h4 id="2-6-1为什么使用B-Tree"><a href="#2-6-1为什么使用B-Tree" class="headerlink" title="2.6.1为什么使用B+Tree"></a>2.6.1为什么使用B+Tree</h4><p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。下面先介绍内存和磁盘存取原理，然后再结合这些原理分析B-/+Tree作为索引的效率。</p><h5 id="2-6-1-1主存存取原理"><a href="#2-6-1-1主存存取原理" class="headerlink" title="2.6.1.1主存存取原理"></a>2.6.1.1主存存取原理</h5><p>目前计算机使用的主存基本都是随机读写存储器（RAM），现代RAM的结构和存取原理比较复杂，这里本文抛却具体差别，抽象出一个十分简单的存取模型来说明RAM的工作原理。<br><img src="/posts/41900/image-20230915151546160.png" alt><br>从抽象角度看，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。每个存储单元有唯一的地址，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元。</p><p>主存的存取过程如下：</p><ul><li>当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。</li><li>写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。</li><li>这里可以看出，主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的。<h5 id="2-6-1-2磁盘存取原理"><a href="#2-6-1-2磁盘存取原理" class="headerlink" title="2.6.1.2磁盘存取原理"></a>2.6.1.2磁盘存取原理</h5>索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。</li></ul><p>一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）。</p><p><img src="/posts/41900/image-20230915152123723.png" alt></p><p>盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。</p><p>当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。在得到对应块后，再在对应的块内部通过偏移量得到所需的字节。</p><p><strong>局部性原理与磁盘预读</strong></p><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：</p><p>当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p><p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p><h4 id="2-6-2MySQL索引实现"><a href="#2-6-2MySQL索引实现" class="headerlink" title="2.6.2MySQL索引实现"></a>2.6.2MySQL索引实现</h4><p>在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文主要讨论MyISAM和InnoDB两个存储引擎的索引实现方式。</p><h5 id="2-6-2-1-MyISAM索引实现"><a href="#2-6-2-1-MyISAM索引实现" class="headerlink" title="2.6.2.1 MyISAM索引实现"></a>2.6.2.1 MyISAM索引实现</h5><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：<br><img src="/posts/41900/image-20230915152512991.png" alt></p><p>这里设表一共有三列，假设我们以Col1为主键，则图8是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：<br><img src="/posts/41900/image-20230915152644649.png" alt><br>同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p><h5 id="2-6-2-2InnoDB索引实现"><a href="#2-6-2-2InnoDB索引实现" class="headerlink" title="2.6.2.2InnoDB索引实现"></a>2.6.2.2InnoDB索引实现</h5><p><img src="/posts/41900/image-20230916210637354.png" alt></p><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。第一个重大区别是InnoDB的<strong>数据文件本身就是索引文件</strong>。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p><p><img src="/posts/41900/image-20230915153212935.png" alt></p><p>上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p><p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，下图为定义在Col3上的一个辅助索引：<br><img src="/posts/41900/image-20230915154149440.png" alt></p><p>这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p><p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p><ul><li>聚簇索引：数据是按照主键索引组织，也就是行的数据聚集在了主键索引里面。即主键B+树的叶子结点结构和磁盘上存储的文件页是相同的，方便扫描搜索。</li><li>非聚簇索引：主键索引本身是key和数据存储位置，即存储的是页号与slot号的索引。</li></ul><p>对于高效的存储介质，可以把B+树节点大小设置小一点，因为这样可以尽量减少读取的冗余数据。</p><h3 id="2-7LSM-Tree"><a href="#2-7LSM-Tree" class="headerlink" title="2.7LSM-Tree"></a>2.7LSM-Tree</h3><p>LSM-Tree 的全称为日志结构合并树〈Log-Structured Merge Tree)，核心思想是将内存中的缓存数据以记录日志的形式追加写入到存储介质，初衷是为了将小粒度的随机写聚合成大粒度的顺序追加写，从而减少机械磁盘悬臂的频繁机械运动，提升I/O效率。</p><p>具体来说 LSM 的数据更新是日志式的，修改数据时直接追加一条新记录（为被修改数据创建一个新版本），而使用 B/B+ 树的数据库则需要找到数据在磁盘上的位置并在原地进行修改。<br><img src="/posts/41900/image-20231007214850642.png" alt></p><p>LSM-Tree 的基本结构如上图，数据被分成了多层，其中CO存储在内存，其他层存储在外存，数据在每一层按照Key的大小依次排列，并且这些层的容量依次成倍增加。</p><p>LSM 树将离散的随机写请求都转换成批量的顺序写请求（WAL + memtable），以此提高写性能。但也带来了一些问题：</p><ul><li>读放大（Read Amplification）。按照上面【读操作】的描述，读操作有可能会访问大量的文件；</li><li>空间放大（Space Amplification）。因为所有的写入都是顺序写（Append-only）的，不是在对数据进行直接更新（in-place update），所以过期数据不会马上被清理掉</li></ul><p>所以维护和减少 SST 文件数量是很有必要的。RocksDB 会根据配置的不同 Compaction 算法策略，进行 Compaction 操作。<strong>Compaction 操作会删除过期 或者标记为删除/重复的 key，对数据进行重新合并来提高查询效率。</strong></p><p>当键值对写入LSM-Tree时，首先会被插入到位于内存中的C0，当C0满了以后，C0中的数据会和C1中的数据进行合并，合并后的结果会重新写入C1。同理，当Cn满了时，Cn也会和Cn+1合并，合并后的结果写入Cn+1。这些合并操作被称为Compaction操作。</p><p><img src="/posts/41900/image-20231007150101267.png" alt></p><p>比如常见的LevelDB中就使用了这一数据结构，如前文中提到的，对于LSM-Tree而言维护着内存外存两部分，分别是在内存的Memtable（内存表）部分和Inmutable Memtable（只读内存表）两部分，即前文的c0。</p><p>另一部分存储在外存，同时按存储的量级上升，其中外存部分每层有Sorted string table（顺序字符串表）文件，其中k-v数据就存储在这些SSTable文件中，除了L0其他层都是按key的顺序排列的，也就是层间存放的key范围是不重叠的。</p><p>除了数据，LevelDB还有Log、Mainfest以及Current文件：</p><ul><li>Log 文件存储最近的数据更新，采用追加的方式将每次的更新数据写到日志文件的末尾，每个日志文件对应当前的Memtable，更新操作先写入日志文件然后更新内存表。当内存表被写入SSTable 文件后，相应的日志文件会被删除。Log 文件也可做故障恢复。</li><li>Mainfest文件存储当前数据库元数据，如每层包含哪些SSTable文件、每个文件中 key的范围以及其他的元数据信息，如日志文件等。</li><li>Current文件是一个简单的文本文件，记录当前使用的Mainfest文件名，通常通过判断当前文件是否存在来判断数据库是否已经创建。</li></ul><p>Compaction 虽然减少了读放大（减少 SST 文件数量）和空间放大（清理无效数据），但也因此带来了写放大（Write Amplification）的问题（底层 I/O 被 Compaction 操作消耗，会大于上层请求速递）<br><img src="/posts/41900/image-20231007212259173.png" alt></p><p>LevelDB的数据写入流程可以理解为两步:</p><ol><li>追加一条日志记录到Log 文件。</li><li>写入Memtable，其中 Memtable被实现为跳表，跳表的功能和平衡树类似，但实现更为简单，并且维持平衡的操作更轻量。</li></ol><p><img src="/posts/41900/image-20231007152515592.png" alt></p><p>当Memtable容量达到上限时，它会转变为一个Immutable Memtable，只允许读而不允许写，并创建一个新的Memtable 提供写入。Immutable Memtable未来将转换成SSTable文件并flush到L0，为了更快速的下刷，L0的SSTable是直接生成的，因此文件之间是可能重叠的。</p><p>而随着Memtable不断的被转化成SSTable文件并写入L0后，L0的文件数量会超过容量限制，进而触发Compaction操作。</p><p><img src="/posts/41900/image-20231007153153896.png" alt></p><p>同时由于L0层有范围重叠，如上图所示，读取时从L0层读取所有文件，并在L0的下一层，即L1层找到Key范围与L0所读取文件有重叠的所有文件，然后将这些文件中的数据在内存进行合并排序后，重新生成新的SSTable文件写入L1层。由于可能有重复的新旧数据，合并过程中会删除旧数据，因此合并后一般能够减少文件的总量。其他层的合并也是类似的，只是每次只从当前层选取一个SSTable文件与下层进行合并。</p><p>Compaction操作是LSM-Tree内部数据整合的机制，也是其中最复杂的过程之一，具体实现起来有很多细节与优化方法。</p><p>对于查询来说，首先是依次在Memtable和Immutable Memtable 中查询，如果都没有找到，则在外存中继续查找。在外存中查找时，我们会从mainfest文件中读取各层中 SSTable文件的Key范围，然后找出可能包含查询Key 的 SSTable文件，这个信息一般会被缓存在内存中。<br><img src="/posts/41900/image-20231007153432918.png" alt></p><p>除了 L0 层外，其他各层最多只有一个 SSTable 文件可能包含查询键。也就是L0无序，除 L0 外的层都是全局有序的。随后我们将这些文件按所在层排序，位于 L0 层的在前，L0 层内的文件按时间先后逆序排列，然后按照顺序依次在SSTable 文件内查找。</p><p>SSTable 文件内的数据是排序的，并被切割成多个数据块，由内部的索引信息记录者各个数据块中 key 的范围。因此查询一般首先通过索引信息确定可能包含 Key 的数据块，然后在数据块内查找。</p><p>LevelDB 在每个 SSTable 文件中为每个数据块建立了一个布隆过滤器，在数据块内的查找前可以通过布隆过滤器来提前检验，如果确定不存在，则继续到下一个 SSTable 文件进行查找。更具体的详细实现可以看<a href="https://zhuanlan.zhihu.com/p/415799237">这篇LSM总结博客</a>。</p><h3 id="2-8LSM-Tree补充"><a href="#2-8LSM-Tree补充" class="headerlink" title="2.8LSM-Tree补充"></a>2.8LSM-Tree补充</h3><h4 id="LSM-Tree"><a href="#LSM-Tree" class="headerlink" title="LSM-Tree"></a>LSM-Tree</h4><p>LSM 树将离散的随机写请求都转换成批量的顺序写请求（WAL + memtable），以此提高写性能。但也带来了一些问题：</p><ul><li>读放大（Read Amplification）。按照上面【读操作】的描述，读操作有可能会访问大量的文件；</li><li>空间放大（Space Amplification）。因为所有的写入都是顺序写（Append-only）的，不是在对数据进行直接更新（in-place update），所以过期数据不会马上被清理掉</li></ul><p>所以维护和减少 SST 文件数量是很有必要的。<br><strong>定义</strong></p><ol><li>LSM树是一个横跨内存和磁盘的，包含多颗”子树”的一个森林。</li><li>LSM树分为Level 0，Level 1，Level 2 … Level n 多颗子树，其中只有Level 0在内存中，其余Level 1-n在磁盘中。</li><li>内存中的Level 0子树一般采用排序树（红黑树/AVL树）、跳表或者TreeMap等这类有序的数据结构，方便后续顺序写磁盘。</li><li>磁盘中的Level 1-n子树，本质是数据排好序后顺序写到磁盘上的文件，只是叫做树而已。</li><li>每一层的子树都有一个阈值大小，达到阈值后会进行合并，合并结果写入下一层。</li><li>只有内存中数据允许原地更新，磁盘上数据的变更只允许追加写，不做原地更新<br><img src="/posts/41900/image-20231007211728835.png" alt></li></ol><p>WAL (write-ahead log)是一种有利于顺序写的持久化日志文件。很多存储系统中都有类似的设计（如 MySQL 的 redo log/undo log、ZK 的 WAL）；</p><p>RocksDB 每次写数据都会先写入 WAL 再写入 memtable，在发生故障时，通过重放 WAL 恢复内存中的数据，保证数据一致性。</p><p>这种设计有什么好处呢？这样 LSM 树就可以将有易失性（volatile）的内存看做是持久型存储，并且信任内存上的数据。</p><p>至于 WAL 的创建删除时机，每次 flush 一个 CF（列族数据） 后，都会新建一个 WAL。<strong>这并不意味着旧的 WAL 会被删除，因为别的 CF 数据可能还没有落盘，只有所有的 CF 数据都被 flush 且所有的 WAL 有关的 data 都落盘，相关的 WAL 才会被删除</strong>。</p><p>其中SSTable (sorted string table)，全称是 Sorted String Table，存在于磁盘，是一个持久化的、有序的、不可更改的 Map 结构，Key 和 Value 都是任意的 Byte 串。上文提到内存中的 memtable 在满足条件的情况下会执行 flush 操作，SSTable 的 文件结构如下：<br><img src="/posts/41900/image-20231007211940551.png" alt></p><ul><li>数据块 Data Block，存储<strong>有序</strong>键值对，是 SSTable 的数据实体；<strong>为了节省存储空间，并不会为每一对 key-value 对都存储完整的 key 值，而是存储与上一个 key 非共享的部分，避免了 key 重复内容的存储（这种通过 delta encode 的方式节省空间的方式在其他存储中间件底层中也很常见）</strong>。</li><li>Meta Block，存储 Filter 相关信息，用于加快 sst 中查询数据的效率；Filter 通过 <strong>Bloom Filter</strong> 来过滤判断指定的 data block 中是否存在要查询的数据。</li><li>Meta Index Block，对 Meta Block 的索引，它只有一条记录，key 是 meta index 的名字（也就是 Filter 的名字），value 为指向 meta index 的位置；</li><li>Index Block，index block 用来存储所有 data block 的相关索引信息。indexblock 包含若干条记录，每一条记录代表一个 data block 的索引信息；</li><li>Footer，指向各个分区的位置和大小。<strong>Footer 是定长的，读取 SSTable 文件的时候，就是从文件末尾，固定读取字节数，进而得到了 Footer 信息。 Footer 中的信息，</strong>指明了 MetaIndexBlock 和 IndexBlock 的位置，进而找到 MetaBlock 和 DataBlock。****</li></ul><h4 id="读-amp-写"><a href="#读-amp-写" class="headerlink" title="读&amp;写"></a>读&amp;写</h4><p><img src="/posts/41900/dc23c8f5d4fa3fa86dbb9a8852d9dcd7725636a9.png@1256w_972h_!web-article-pic.avif" alt></p><ol><li>在 active memtable 中查找；</li><li>如果 active memtable 没有，则在 immutable memtable 中查找；</li><li>如果 immutable memtable 没有，则在 L0 SSTable 中查找（RocksDB 采用遍历的方法查找 L0 SSTable，为了提高查找效率会控制 L0 文件的个数）；</li><li>如果找不到，则在剩余的 SSTable 中查找（对于 L1 层以及 L1 层以上层级的文件，每个 SSTable 没有交叠，可以使用二分查找快速找到 key 所在的 Level 以及 SSTable）</li></ol><p>每个 SSTable 在查找之前通过 bloom filter 快速判断数据是否存在于当前文件，减少不必要的 IO。  RocksDB 为 SST 中访问频繁的 data blocks 设置了一个读缓存结构 Block cache，并提供了两种开箱即用的实现 LRUCache 和 ClockCache 。</p><p><img src="/posts/41900/aa15606705994a08c8dc307b386b133bf25f1d0d.png@1256w_562h_!web-article-pic.avif" alt></p><ol><li>写操作会先写 WAL 文件，保证数据不丢失；</li><li>完成 WAL 写入后，将数据写入到 内存中的 active memtable 中（为了保证有序性，RocksDB 使用跳表数据结构实现 memtable）；</li><li>然后等 memtable 数据达到一定规模时，会转变成 immutable memtable，同时生成新的 memtable 提供服务；</li><li>在满足落盘条件后，immutable memtable 会被合并刷入到硬盘的 SST 中；</li></ol><p>顺带一提，默认情况下 RocksDB 中的写磁盘行为都是异步写，仅仅把数据写进了操作系统的缓存区就返回了（pageCache），而这些数据被写进磁盘是一个异步的过程。异步写的吞吐率是同步写的一千多倍。<strong>异步写的缺点是机器或者操作系统崩溃时可能丢掉最近一批写请求发出的由操作系统缓存的数据，但是 RocksDB 自身崩溃并不会导致数据丢失。而机器或者操作系统崩溃的概率比较低，所以大部分情况下可以认为异步写是安全的</strong>。</p><h4 id="LSM-树设计思想总结"><a href="#LSM-树设计思想总结" class="headerlink" title="LSM 树设计思想总结"></a>LSM 树设计思想总结</h4><p>LSM 树将对磁盘的随机写入转化为了磁盘友好型的顺序写（无论机械磁盘还是 SSD，随机读写都要远远慢于顺序读写），从而大大提高了写性能。</p><p>那么是怎么转化的呢？核心就是在内存中维护一个有序的内存表（memtable），当内存表大于阈值的时候批量刷入磁盘，生成最新的 SSTable 文件。因为本身 memtable 已经维护了按键排序的键值对，所以这个步骤可以高效地完成。</p><p><strong>写入内存表时先将数据写入 WAL 日志，用以在发生故障时，通过重放 WAL 恢复内存中的数据，保证数据库的数据一致性。</strong></p><p>在这种追加（Append-only）写入模式下，删除数据变成了对数据添加删除标记，更新数据变成了写入新的 value，在同一个时间数据库中会存在同个 key 的新值和旧值。这种影响被称之为 <strong>空间放大（Space Amplification）</strong>。随着数据的写入，底层的 SSTable 文件也会越来越多。</p><p>读请求在这个模式下，变成了先在内存中寻找关键字，如果找不到则在磁盘中按照新-&gt; 旧查找 SSTable 文件。<strong>为了优化这种访问模式的读性能，存储引擎通常使用常见的针对读的优化策略，比如使用额外的 Bloom Filter、读 Cache</strong>。</p><p>这种需要多次读取的过程（或者说影响）被称之为<strong>读放大（Read Amplification）</strong>。很显然，读放大会影响 LSM 树的读性能。为了优化读性能（读放大），同时优化存储空间（空间放大），LSM 树通过在运行合并和压缩过程减少 SSTable 文件数量，删除<strong>无效（被删除或者被覆盖）</strong> 的旧值。这一过程被称之为 <strong>compaction</strong>。</p><p>但是 compaction 也会一些影响，在数据库的生命周期中每次的数据写入实际上会造成多次的磁盘写入。这种影响被称之为写放大（Write Amplification）。在写入繁重的应用程序中，性能瓶颈可能是数据库可以写入磁盘的速度。在这种情况下，写放大会导致直接的性能代价：存储引擎写入磁盘的次数越多，可用磁盘带宽内的每秒写入次数越少。</p><p>这也是我认为 LSM 引擎存储的一个缺点，就是<strong>压缩过程有可能会干扰到正在进行的读写请求</strong>。尽管存储引擎尝试逐步执行压缩而不影响并发访问，但是磁盘资源有限，所以很容易发生请求需要等待磁盘完成昂贵的压缩操作。对吞吐量和平均响应时间的影响通常很小，但是如果是高百分位情况下，有时就会出现查询响应较长的情况。</p><p>具体提到的 RocksDB 实现中，写放大、读放大、空间放大，这三者就像 CAP 定理一样，无法同时达到最优。为此 RocksDB 暴露了很多参数来让使用者进行调优，以适应更多的应用场景。这其中很大一部分工作是在写放大、读放大和空间放大这三个放大因子之间做好 trade off。</p><h3 id="2-9LSM-树-vs-B-树"><a href="#2-9LSM-树-vs-B-树" class="headerlink" title="2.9LSM 树 vs B+ 树"></a>2.9LSM 树 vs B+ 树</h3><h4 id="2-9-1设计理念不同"><a href="#2-9-1设计理念不同" class="headerlink" title="2.9.1设计理念不同"></a>2.9.1设计理念不同</h4><p>虽然像 LSM 树一样，B+ 树保持按键排序的键值对（这允许高效的键值查找和范围查询），但是两者设计理念完全不同。</p><ul><li>LSM 树将数据库分解为可变大小的段，通常是几兆字节或更大的大小，并且总是按顺序编写段。</li><li>相比之下，B+ 树将数据库分解成固定大小的块或页面，传统上大小为 4KB（有时会更大），并且一次只能读取或写入一个页面。这种设计更接近于底层硬件，因为磁盘也被安排在固定大小的块中。</li></ul><h4 id="2-9-2数据的更新和删除方面"><a href="#2-9-2数据的更新和删除方面" class="headerlink" title="2.9.2数据的更新和删除方面"></a>2.9.2数据的更新和删除方面</h4><ul><li>B+树可以做到原地更新和删除（in-place update），这种方式对<strong>数据库事务支持更加友好</strong>，因为一个 key 只会出现一个 Page 页里面；</li><li>但由于 LSM 树只能追加写（out-place update），并且在 L0 层的 SSTable 中会重叠，所以对事务支持较弱，只能在 compaction 的时候进行真正地更新和删除。</li></ul><h4 id="2-9-3性能方面"><a href="#2-9-3性能方面" class="headerlink" title="2.9.3性能方面"></a>2.9.3性能方面</h4><ul><li>LSM 树的优点是支持高吞吐的写（可认为是 O(1)），这个特点在分布式系统上更为看重，当然针对读取普通的 LSM 树结构，读取是 O(n) 的复杂度，在使用索引或者缓存优化后的也可以达到 O（logN）的复杂度。</li><li>B+ 树的优点是支持高效的读（稳定的 O(logN)），但是在大规模的写请求下（复杂度 O(LogN)），效率会变得比较低，因为随着 insert 的操作，为了维护树结构，节点会不断的分裂和合并。操作磁盘的随机读写概率会变大，故导致性能降低。</li></ul><p><strong>通常</strong>来说，我们会说，LSM 树写性能会优于 B 树，而 B 树的读性能会优于 LSM 树。但是请不要忽略 LSM 树写放大的影响，在进行性能判定是要更辩证的思考。<br><img src="/posts/41900/image-20231007214536961.png" alt></p><h2 id="第三章-查询处理"><a href="#第三章-查询处理" class="headerlink" title="第三章 查询处理"></a>第三章 查询处理</h2><h3 id="3-1查询处理概述"><a href="#3-1查询处理概述" class="headerlink" title="3.1查询处理概述"></a>3.1查询处理概述</h3><p><img src="/posts/41900/4-1.png" alt="图 4-1 关系数据库查询处理流程"></p><p>关系数据库管理系统查询处理可以分为4个阶段：查询分析、查询检查、查询优化和查询执行。</p><ol><li><strong>查询分析</strong> ：对用户提交的查询语句进行扫描、词法分析和语法分析，判断是否符合SQL语法规则，若没有语法错误，就会生成一棵语法树。</li><li><strong>查询检查</strong> ：对语法树进行查询检查，首先根据数据字典中的模式信息检查语句中的数据对象，如关系名、属性名是否存在和有效；还要根据数据字典中的用户权限和完整性约束信息对用户的存取权限进行检查。若通过检查，则将数据库对象的外部名称转换成内部表示。这个过程实际上是对语法树进行语义解析的过程，最后语法树被解析为一个具有特定语义的关系代数表达式，其表示形式仍然是一棵树，称为查询树。</li><li><strong>查询优化</strong> ：每个查询都会有多种可供选择的执行策略和操作算法，查询优化就是选择一个能高效执行的查询处理策略。一般将查询优化分为代数优化和物理优化。代数优化指对关系代数表达式进行等价变换，改变代数表达式中操作的次序和组合，使查询执行更高效；物理优化则是指存取路径和底层操作算法的选择，选择依据可以是基于规则、代价、语义的。查询优化之后，形成查询计划。</li><li><strong>查询执行</strong> ：查询计划由一系列操作符构成，每一个操作符实现计划中的一步。查询执行阶段，系统将按照查询计划逐步执行相应的操作序列，得到最终的查询结果。</li></ol><h3 id="3-2-选择运算"><a href="#3-2-选择运算" class="headerlink" title="3.2 选择运算"></a>3.2 选择运算</h3><p>选择操作的典型实现方法有<strong>全表扫描法</strong>和<strong>索引扫描法</strong>。</p><h4 id="3-2-1-全表扫描法"><a href="#3-2-1-全表扫描法" class="headerlink" title="3.2.1 全表扫描法"></a>3.2.1 全表扫描法</h4><p>对查询的基本表顺序扫描，逐一检查每个元组是否满足选择条件，把满足条件的元组作为结果输出。</p><p>假设可以使用的内存为M块，全表扫描的算法思想如下：</p><ol><li>按物理次序读表T的M块到内存；</li><li>检查内存的每个元组t，如果t满足选择条件，则输出t；</li><li>如果表T还有其他块未被处理，重复(1)和(2)。</li></ol><p>这种方法适合小表，对规模大的表要进行顺序扫描，当选择率（即满足条件的元组数占全表比例）较低时，此算法效率很低。</p><h4 id="3-2-2-索引扫描法"><a href="#3-2-2-索引扫描法" class="headerlink" title="3.2.2 索引扫描法"></a>3.2.2 索引扫描法</h4><p>当选择条件中的属性上有索引（例如B+树索引或Hash索引）时，通过索引先找到满足条件的元组指针，再通过元组指针直接在要查询的表中找到元组。</p><p><strong>［例1 ］</strong> 等值查询：<code>select * from t1 where col＝常量</code>，并且col上有索引（B+树索引或Hash索引均可） ，则使用索引得到col为该常量元组的指针，通过元组指针在表t1中检索到结果。</p><p><strong>［例2 ］</strong> 范围查询： <code>select * from t1 where col &gt; 常量</code>，并且col上有B+树索引，使用B+树索引找到col＝常量的索引项，以此为入口点在B+树的顺序集上得到col &gt; 常量的所有元组指针， 通过这些元组指针到t1表中检索满足条件的元组。</p><p><strong>［例 3 ］</strong> 合取条件查询：<code>select * from t1 where col1＝常量a AND col2 &gt;常量b</code>，如果 col1和 col1上有组合索引（col1,col2），则利用此组合索引进行查询筛选；否则，如果 col1和 col2上分别有索引，则：</p><p>方法一：分别利用各自索引查找到满足部分条件的一组元组指针，求这2组指针的交集，再到t1表中检索得到结果。</p><p>方法二：只利用索引查找到满足该部分条件的一组元组指针，通过这些元组指针到t1表中检索，对得到的元组检查另一些选择条件是否满足，把满足条件的元组作为结果输出。</p><p>一般情况下，当选择率较低时，基于索引的选择算法要优于全表扫描。但在某些情况下，如选择率较高、或者要查找的元组均匀分散在表中，这时索引扫描法的性能可能还不如全表扫描法，因为还需要考虑扫描索引带来的额外开销。</p><h3 id="3-3-排序运算"><a href="#3-3-排序运算" class="headerlink" title="3.3 排序运算"></a>3.3 排序运算</h3><p>排序是数据库中的一个基本功能，用户通过Order by子句即能达到将指定的结果集排序的目的，而且不仅仅是Order by子句，Group by、Distinct等子句都会隐含使用排序操作。</p><h4 id="3-3-1-利用索引避免排序"><a href="#3-3-1-利用索引避免排序" class="headerlink" title="3.3.1 利用索引避免排序"></a>3.3.1 利用索引避免排序</h4><p>为了优化查询语句的排序性能，最好的情况是避免排序，合理利用索引是一个不错的方法。因为一些索引本身也是有序的，如B+树，如果在需要排序的字段上面建立了合适的索引，那么就可以跳过排序过程，提高查询速度。</p><p>例如：假设t1表存在B+树索引key1(key_part1, key_part2)，则以下查询可以利用索引来避免排序：</p><pre class="line-numbers language-sql"><code class="language-sql">    <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t1 <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> key_part1<span class="token punctuation">,</span> key_part2<span class="token punctuation">;</span>    <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t1 <span class="token keyword">WHERE</span> key_part1 <span class="token operator">=</span> constant <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> key_part2<span class="token punctuation">;</span>    <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t1 <span class="token keyword">WHERE</span> key_part1 <span class="token operator">></span> constant <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> key_part1<span class="token punctuation">;</span>    <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t1 <span class="token keyword">WHERE</span> key_part1 <span class="token operator">=</span> constant1 <span class="token operator">AND</span> key_part2 <span class="token operator">></span> constant2 <span class="token keyword">ORDER</span> <span class="token keyword">BY</span>     key_part2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果排序字段不在索引中，或者分别存在于多个索引中，或者排序键的字段顺序与组合索引中的字段顺序不一致，则无法利用索引来避免排序。</p><h4 id="3-3-2-数据库内部排序方法"><a href="#3-3-2-数据库内部排序方法" class="headerlink" title="3.3.2 数据库内部排序方法"></a>3.3.2 数据库内部排序方法</h4><p>对于不能利用索引来避免排序的查询，DBMS必须自己实现排序功能以满足用户需求。实现排序的算法可以是文件排序，也可以是内存排序，具体要由排序缓冲区（sort buffer）的大小和结果集的大小来确定。</p><p>数据库内部排序的实现主要涉及3种经典排序算法：快速排序、归并排序和堆排序。对于不能全部放在内存中的关系，需要引入外排序，最常用的就是外部归并排序。外部归并排序分为两个阶段：Phase1 – Sorting，对主存中的数据块进行排序，然后将排序后的数据块写回磁盘；Phase2 – Merging，将已排序的子文件合并成一个较大的文件。</p><h5 id="3-3-2-1-常规排序法"><a href="#3-3-2-1-常规排序法" class="headerlink" title="3.3.2.1 常规排序法"></a>3.3.2.1 常规排序法</h5><p>一般情况下通用的常规排序方法如下：</p><ul><li>(1) 从表t中获取满足WHERE条件的记录；</li><li>(2) 对于每条记录，将记录的主键+排序键(id,colp)取出放入sort buffer；</li><li>(3) 如果sort buffer可以存放所有满足条件的(id,colp)对，则进行排序；否则sort buffer满后，进行排序并固化到临时文件中。（排序算法采用快速排序）；</li><li>(4) 若排序中产生了临时文件，需要利用归并排序算法，保证临时文件中记录是有序的；</li><li>(5) 循环执行上述过程，直到所有满足条件的记录全部参与排序；</li><li>(6) 扫描排好序的(id,colp)对，并利用id去取SELECT需要返回的目标列；</li><li>(7) 将获取的结果集返回给用户。</li></ul><p>从上述流程来看，是否使用文件排序主要看sort buffer是否能容下需要排序的(id,colp)对。此外一次排序涉及两次I/O：第一次是取(id,colp)，第二次是取目标列。由于第一次返回的结果集是按colp排序，因此id是乱序的。通过乱序的id去取目标列时，会产生大量的随机I/O。因此，可以考虑对第二次I/O进行优化，即在取数据之前首先将id排序并放入缓冲区，然后按id顺序去取记录，从而将随机I/O转为顺序I/O。</p><p>为了避免第二次I/O，还可以考虑一次性取出(id,colp,目标列)，当然这样对缓冲区的需求会更大。</p><h5 id="3-3-2-2-堆排序法"><a href="#3-3-2-2-堆排序法" class="headerlink" title="3.3.2.2 堆排序法"></a>3.3.2.2 堆排序法</h5><p>堆排序法适用于形如”order by limit m，n”的这类排序问题，即跳过m条数据，提取n条数据。这种情况下，虽然仍然需要所有元组参与排序，但是只需要m+n个元组的sort buffer空间即可，对于m和n很小的场景，基本不会出现因sort buffer不够而需要使用临时文件进行归并排序的问题。对于升序，采用大顶堆，最终堆中的元素组成了最小的n个元素；对于降序，则采用小顶堆，最终堆中的元素组成了最大的n的元素。</p><h3 id="3-4-连接运算"><a href="#3-4-连接运算" class="headerlink" title="3.4 连接运算"></a>3.4 连接运算</h3><p>连接操作是查询处理中最常用最耗时的操作之一。主要有4种实现方法：嵌套循环、排序-合并、索引连接和散列连接。</p><p>首先引入2个术语：外关系（outer relation）和内关系（inner relation）。外关系是左侧数据集，内关系是右侧数据集。例如：对于A JOIN B，A为外关系，B为内关系。多数情况下，A JOIN B 的成本跟 B JOIN A 的成本是不同的。假定外关系有m个元组，占M个页，内关系有n个元组，占N个页。</p><h4 id="3-4-1-嵌套循环连接"><a href="#3-4-1-嵌套循环连接" class="headerlink" title="3.4.1 嵌套循环连接"></a>3.4.1 嵌套循环连接</h4><p>嵌套循环连接是最简单且通用的连接算法，其执行步骤为：针对外关系的每一行，查看内关系里的所有行来寻找匹配的行。这是一个双重循环，时间复杂度为O(n*m)。</p><p><img src="/posts/41900/4-2.png" alt="图 4-2 嵌套循环连接示意图"></p><p>在磁盘 I/O 方面， 针对外关系的每一行，内部循环需要从内关系读取m行。这个算法需要从磁盘读取 n+ n*m 行。但是，如果外关系足够小，我们可以把它先读入内存，那么就只需要读取 n+m 行。按照这个思路，外关系就应该选更小的那个关系，因为它有更大的机会装入内存。</p><p>当然，内关系如果可以由索引代替，对磁盘 I/O 将更有利。</p><p>当外关系太大无法装入内存时，采用块嵌套循环连接方式，对磁盘 I/O 更加有利。其基本思路是将逐行读取数据，改为以页（块）为单位读取数据。算法如下：</p><ul><li>(1) 从磁盘读取外关系的一个数据页到内存；</li><li>(2) 从磁盘依次读取内关系的所有数据页到内存，与内存中外关系的数据进行比较，保留匹配的结果；</li><li>(3) 从磁盘读取外关系的下一个数据页，并继续执行(2)，直至外关系的最后一个页面。</li></ul><p>与嵌套循环连接算法相比，块嵌套循环连接算法的时间复杂度没有变化，但降低了磁盘访问开销，变为M+M*N。其中，M为外关系的页数，N为内关系的页数。</p><h4 id="3-4-2-索引嵌套循环连接"><a href="#3-4-2-索引嵌套循环连接" class="headerlink" title="3.4.2 索引嵌套循环连接"></a>3.4.2 索引嵌套循环连接</h4><p>在嵌套循环连接中，若在内关系的连接属性上有索引，则可以用索引查找替代文件扫描。对于外关系的每一个元组，可以利用索引查找内关系中与该元组满足连接条件的元组。这种连接方法称为索引嵌套循环连接，它可以在已有索引或者为了计算该连接而专门建立临时索引的情况下使用。</p><p>索引嵌套循环连接的代价可以如下计算。对于外关系的每一个元组，需要先在内关系的索引上进行查找，再检索相关元组。在最坏的情况下，缓冲区只能容纳外关系的一页和索引的一页。此时，读取外关系需M次I/O操作，这里的M指外关系的数据页数；对于外关系中的每个元组，在内关系上进行索引查找，假设索引查找带来的I/O开销为C，则总的I/O开销为：M+(m×C)，其中m为外关系的元组数。</p><p>这个代价计算公式表明，如果两个关系上均有索引时， 一般把元组较少的关系作外关系时效果较好。</p><p><img src="/posts/41900/4-3.png" alt="图4-3 索引连接示意图"></p><h4 id="3-4-3-排序-合并连接"><a href="#3-4-3-排序-合并连接" class="headerlink" title="3.4.3 排序-合并连接"></a>3.4.3 排序-合并连接</h4><p>排序-合并连接算法常用于等值连接，尤其适合参与连接的表已经排好序的情况。其方法如下：</p><p>第一步：如果参与连接的表没有排好序，则根据连接属性排序；</p><p>第二步：sorted_merge：</p><ul><li>(1) 初始化两个指针，分别指向两个关系的第一个元组；</li><li>(2) 比较两个关系的当前元组（当前元组=指针指向的元组）；</li><li>(3) 如果匹配，保留匹配的结果，两个指针均后移一个位置；</li><li>(4) 如果不匹配，就将指向较小元组的那个指针后移一个位置；</li><li>(5) 重复步骤(2)、(3)、(4)，直到其中一个关系的指针移动到末尾。</li></ul><p><img src="/posts/41900/4-4.png" alt="图4-4 排序-合并连接示意图"></p><p>因为两个关系都是已排序的，不需要”回头去找”，所以此方法的时间复杂度为O(n+m)。如果两个关系还需要排序，则还要考虑排序的成本：O(n*Log(n) + m*Log(m))。</p><p>很多情况下，参与连接的数据集已经排好序了，比如：表内部就是有序的，或者参与连接的是查询中已经排好序的中间结果，那么选用排序-合并算法是比较合适的。</p><h4 id="3-4-4-散列连接"><a href="#3-4-4-散列连接" class="headerlink" title="3.4.4 散列连接"></a>3.4.4 散列连接</h4><p>散列连接算法也是适用于等值连接的算法。</p><p>散列连接分成两个阶段：第一步，划分阶段，为较小的关系建立hash表，将连接属性作为hash码；第二步，试探阶段，对另一张表的连接属性用同样的hash函数进行散列，将其与相应桶中匹配的元组连接起来。</p><p>本算法要求内存足够大，小表的hash表如果能全部放进内存，则效果较好。</p><p><img src="/posts/41900/4-5.png" alt="图 4-5 散列连接示意图"></p><p>在时间复杂度方面需要做些假设来简化问题：</p><ul><li>(1) 内关系被划分成 X 个散列桶。散列函数几乎均匀地分布每个关系内数据的散列值，即散列桶大小一致。</li><li>(2) 外关系的元素与散列桶内所有元素的匹配，成本是散列桶内元素的数量。</li></ul><p>算法的开销包括创建散列表的成本(m) +散列函数的计算开销 * n + (m/X) * n。如果散列函数创建的散列桶的规模足够小，则算法复杂度为O(m+n)。</p><h4 id="3-4-5-连接算法的选择"><a href="#3-4-5-连接算法的选择" class="headerlink" title="3.4.5 连接算法的选择"></a>3.4.5 连接算法的选择</h4><p>具体情况下，应该选择以上哪种连接算法，有许多因素要考量：</p><ul><li>(1) 空闲内存：没有足够的内存就无法使用内存中的散列连接。</li><li>(2) 两个数据集的大小。比如，如果一个大表连接一个很小的表，那么嵌套循环连接就比散列连接快，因为后者有创建散列表的高昂成本；如果两个表都非常大，那么嵌套循环连接的CPU成本就很高。</li><li>(3) 是否有索引：如果连接属性上有两个B+树索引的话，合并连接会是很好的选择。</li><li>(4) 关系是否已经排序：这时候合并连接是最好的选择。</li><li>(5) 结果是否需要排序：即使参与连接的是未排序的数据集，也可以考虑使用成本较高的合并连接（带排序的），比如得到排序的结果后，我们还可以将它用于另一个合并联接，或者查询中存在ORDER BY/GROUP BY/DISTINCT等操作符，它们隐式或显式地要求一个排序结果。</li><li>(6) 连接的类型：是等值连接？还是内连接？外连接？笛卡尔积？或者自连接？有些连接算法在某些情况下是不适用的。</li><li>(7) 数据的分布：如果连接条件的数据是倾斜的，用散列连接不是好的选择，因为散列函数将产生分布极不均匀的散列桶。</li><li>(8) 多表连接：连接顺序的选择很重要。</li></ul><p>另外，还可能考虑实现方式问题，比如连接操作使用多线程或多进程的代价考量。因此，DBMS需要通过查询优化器来选择恰当的执行计划。</p><h3 id="3-5-表达式计算"><a href="#3-5-表达式计算" class="headerlink" title="3.5 表达式计算"></a>3.5 表达式计算</h3><p>如何计算包含多个运算步骤的关系代数表达式？有两种方法：物化计算和流水线计算。</p><h4 id="3-5-1-物化计算"><a href="#3-5-1-物化计算" class="headerlink" title="3.5.1 物化计算"></a>3.5.1 物化计算</h4><p>物化计算以适当的顺序每次执行一次操作；每次计算的结果被物化到一个临时关系以备后用。其缺点为：需要构造临时关系，而且这些临时关系必须写到磁盘上（除非很小）。</p><p>表达式的执行顺序可以依据表达式在查询树中的层次而定，从树的底部开始。</p><p><img src="/posts/41900/4-6.png" alt="图4-6 一棵查询树"></p><p>如图所示，此例中只有一个底层运算：department上的选择运算，底层运算的输入是数据库中的关系department。用前面提到的算法执行树中的运算，并将结果存储在临时关系中。在树的高一层中，使用这个临时关系来进行计算，这时输入的要么是临时关系，要么是一个数据库关系。通过重复这一过程，最终可以计算位于树的根节点的运算，从而得到表达式的最终结果。</p><p>由于运算的每个中间结果会被物化用于下一层的运算，此方法称为物化计算。物化计算的代价不仅是那些所涉及的运算代价的总和，还可能包括将中间结果写到磁盘的代价。</p><h4 id="3-5-2-流水线计算"><a href="#3-5-2-流水线计算" class="headerlink" title="3.5.2 流水线计算"></a>3.5.2 流水线计算</h4><p>流水线计算可同时计算多个运算，运算的结果传递给下一个，而不必保存临时关系。这种方法通过减少查询执行中产生的临时文件的数量，来提高查询执行的效率。</p><p>比如在上一章里面，可以将选择、连接操作和投影操作组合起来，放入一条流水线，选择得到一个结果传给连接、连接产生一个结果元组马上传送给投影操作去做处理，避免中间结果的创建，从而直接产生最终结果。</p><p>创建一个操作的流水线可以带来的好处是：</p><ul><li>(1) 消除读和写临时关系的代价，从而减少查询计算代价。</li><li>(2) 流水线产生查询结果，边生成边输出给用户，提高响应时间。</li></ul><p>流水线可按两种方式来执行：</p><ul><li>方式一：需求驱动方式，在操作树的顶端的将数据往上拉。</li><li>方式二：生产者驱动方式，将数据从操作树的底层往上推。</li></ul><p>需求驱动的流水线方法比生产者驱动的流水线方法使用更广泛，因为它更容易实现。但流水线技术限制了能实现操作的可用算法。例如，若连接运算的左端输入来自流水线，则不能使用排序-合并连接，但可以用索引连接算法。由于这些限制，并非所有情况下流水线方法的代价都小于物化方法。</p><h2 id="第四章-查询优化"><a href="#第四章-查询优化" class="headerlink" title="第四章 查询优化"></a>第四章 查询优化</h2><h3 id="4-1-查询优化概述"><a href="#4-1-查询优化概述" class="headerlink" title="4.1 查询优化概述"></a>4.1 查询优化概述</h3><p>查询优化即求解给定查询语句的高效执行计划的过程。它既是关系数据库管理系统实现的关键技术，又是关系系统的优点所在。由DBMS进行查询优化的好处在于：查询优化的优点不仅在于用户不必考虑如何最好的表达查询以获得较高的效率，而且在于系统可以比用户程序的”优化”做得更好。</p><p>查询计划，从形式上看是一颗二叉树，树叶是每个单表对象，两个树叶的父节点是一个连接操作符连接后的中间结果（另外还有一些其他节点如排序等也可以作为中间结果），这个结果是一个临时关系，这样直至根节点。</p><p>从一个查询计划看，涉及的主要”关系节点”包括：</p><ul><li>单表节点：考虑单表的获取方式（全表扫描，或索引获取，或索引定位再I/O到数据块获取数据）。这是一个物理存储到内存解析成逻辑字段的过程。</li><li>两表节点：考虑两表以何种方式连接，代价有多大，连接路径有哪些等。表示内存中的元组如何进行元组间的连接。此时，元组通常已经存在于内存中。这是一个完整用户语义的逻辑操作，但只是局部操作，只涉及两个具体的关系。完成用户全部语义，需要配合多表的连接顺序的操作。</li><li>多表中间节点：考虑多表连接顺序如何构成代价最少的”执行计划”。决定连接执行的顺序。</li></ul><p>查询优化的总目标是选择有效的策略，求得给定关系表达式的值，使得查询代价较小。因为查询优化的搜索空间有时非常大，实际系统选择的策略不一定是最优的，而是较优的。</p><p>查询优化主要包括逻辑优化和物理优化。其中，逻辑优化又可包含语法级查询优化、基于规则的优化等；而物理优化主要指基于代价的优化。语法级优化是基于语法的等价转换；基于规则的优化（如依据关系代数的规则或依据经验的规则等）具有操作简单且能快速确定执行方式的优点，但这种方法只是排除了一部分不好的可能；基于代价的优化是在查询计划生成过程中，计算每条存取路径进行量化比较，从而得到开销最小的情况，但如果组合情况多则开销的判断时间就很多。查询优化器的实现，多是这两种优化策略的组合使用。</p><h3 id="4-2-逻辑优化"><a href="#4-2-逻辑优化" class="headerlink" title="4.2 逻辑优化"></a>4.2 逻辑优化</h3><p>查询优化器在逻辑优化阶段主要解决的问题是：如何找出SQL语句的等价变换形式，使SQL执行更高效。</p><h4 id="4-2-1代数优化"><a href="#4-2-1代数优化" class="headerlink" title="4.2.1代数优化"></a>4.2.1代数优化</h4><p>代数优化是基于关系代数等价变换规则的优化方法。</p><p>代数优化策略是通过对关系代数表达式的等价变换来提高查询效率。所谓关系代数表达式的等价是指用相同的关系代替两个表达式中相应的关系所得到的结果是相同的。两个关系表达式E1和E2是等价的。</p><h5 id="4-2-1-1-关系代数表达式等价变换规则"><a href="#4-2-1-1-关系代数表达式等价变换规则" class="headerlink" title="4.2.1.1 关系代数表达式等价变换规则"></a>4.2.1.1 关系代数表达式等价变换规则</h5><p>常用的关系代数等价变换规则如下：</p><ol><li><strong>连接、笛卡尔积的交换律</strong></li></ol><p>设E1和E2为关系代数表达式，F为连接运算条件，则有：</p><p> E1×E2 ≡ E2×E1</p><p> E1⋈E2 ≡ E2⋈E1</p><p> <img src="/posts/41900/5.2.1.1-1.png" alt="5.2.1.1-1"> ≡ <img src="/posts/41900/5.2.1.1-2.png" alt="5.2.1.1-2"></p><p>对于连接和笛卡尔积运算，可以交换前后位置，其结果不变。例如，两表连接算法中有嵌套循环连接算法，对外表和内表有要求，外表尽可能小则有利于做”基于块的嵌套循环连接”，所以通过交换律可以将元组少的表作为外表。</p><ol><li><strong>连接、笛卡尔积结合律</strong></li></ol><p>设E1、E2、E3为关系代数表达式，F1、F2为连接运算条件。则有：</p><p> (E1×E2)×E3 ≡ E1×(E2×E3)</p><p> (E1⋈E2)⋈E3 ≡ E1⋈(E2⋈E3)</p><p> <img src="/posts/41900/5.2.1.1-3.png" alt="5.2.1.1-3"> ≡ <img src="/posts/41900/5.2.1.1-4.png" alt="5.2.1.1-4"></p><p>对于连接、笛卡尔积运算，如果新的结合有利于减少中间关系的大小，则可以优先处理。</p><ol><li><strong>投影的串接定律</strong></li></ol><p>设E为关系代数表达式，Ai（i=1,2,3,…,n），Bj（j=1,2,3,…,m）是属性名，且{A1,A2,…,An}为{B1,B2,…,Bm}的子集。则有：</p><p> ∏A1,A2,…,An(∏B1,B2,…,Bm(E)) ≡ ∏A1,A2,…,An (E)</p><p>在同一个关系上，只需做一次投影运算，且一次投影时选择多列同时完成。所以许多数据库优化引擎会为一个关系收集齐该关系上的所有列，即目标列和WHERE、GROUP BY等子句中涉及到的所有该关系的列。</p><ol start="2"><li><strong>选择的串接律</strong></li></ol><p>设E为关系代数表达式，F1、F2为选择条件。则有：</p><p> σF1(σF2(E)) ≡ σF1∧F2(E)</p><p>此变换规则对于优化的意义在于：选择条件可以合并，使得一次选择运算就可检查全部条件，而不必多次过滤元组，所以可以把同层的合取条件收集在一起，统一进行判断。</p><ol start="3"><li><strong>选择和投影的交换律</strong></li></ol><p>设E为关系代数表达式，F为选择条件，Ai（i=1,2,3,…,n）是属性名。选择条件F只涉及属性A1,A2,…,An。则有：</p><p> σF(∏A1,A2,…,An (E)) ≡∏A1,A2,…,An(σF(E))</p><p>此变换规则对于优化的意义在于：先投影后选择可以改为先选择后投影，这对于以行为单位来存储关系的主流数据库而言，很有优化意义。按照这种存储方式，系统总是先获取元组，然后才能解析得到其中的列。</p><p>设E为关系代数表达式，F为选择条件，Ai（i=1,2,3…,n）是属性名，选择条件F中有不属于A1,A2,…,An的属性B1,B2,…,Bn。则有：</p><p> ∏A1,A2,…,An(σF(E)) ≡ ∏A1,A2,…,An(σF(∏A1,A2,…,An,B1,B2,…,Bm(E)))</p><p>此变换规则对于优化的意义在于：先选择后投影可以改为先做带有选择条件中的列的投影，然后选择，最后再完成最外层的投影。这样内层的选择和投影可以同时进行，不会增加过多的计算开销，但能减小中间结果集的规模。</p><ol start="4"><li><strong>选择与笛卡尔积的交换律</strong></li></ol><p>设E1、E2为关系代数表达式，F为选择条件，F中涉及的属性都是E1中的属性，则有：</p><p> σF(E1×E2) ≡ σF(E1)×E2</p><p>如果F=F1∧F2，且F1只涉及E1中的属性，F2只涉及E2中的属性，则有：</p><p> σF(E1×E2) ≡ σF1(E1)×σF2(E2)</p><p>此变换规则对于优化的意义在于：条件下推到相关的关系上，先做选择后做笛卡尔积运算，这样可以减小中间结果的大小。</p><ol start="5"><li><strong>选择与并的分配律</strong></li></ol><p>如果E1和E2有相同的属性名，且E= E1∪E2，则有：</p><p> σF(E1∪E2) ≡ σF(E1) ∪σF (E2)</p><p>此变换规则对于优化的意义在于：条件下推到相关的关系上，先选择后做并运算，可以减小每个关系输出结果的大小。</p><ol start="6"><li><strong>选择与差的分配律</strong></li></ol><p>如果E1­和E2有相同的属性名，则：</p><p> σF(E1－E2) ≡ σF(E1)－σF(E2)</p><p>此变换规则对于优化的意义在于：条件下推到相关的关系上，先选择后做差运算，可以减小每个关系输出结果的大小。</p><ol start="7"><li><strong>投影与笛卡尔积的交换律</strong></li></ol><p>设A1,A2,…,An是E1的属性，B1,B2,…,Bm是E2的属性，则有：</p><p> ∏A1,A2,…,An,B1,B2,…,Bm(E1×E2) ≡ ∏A1,A2,…,An(E1)×∏B1,B2,…,Bm(E2)</p><p>此变换规则对于优化的意义在于：先投影后做笛卡尔积，可减少做笛卡尔积前每个元组的长度，使得计算后得到的新元组的长度也变短。</p><ol start="8"><li><strong>投影与并的交换律</strong></li></ol><p>如果E1和E2有相同的属性名，则有：</p><p> ∏A1,A2,…,An (E1∪E2) ≡ ∏A1,A2,…,An (E1)∪∏A1,A2,…,An (E2)</p><p>此变换规则对于优化的意义在于：先投影后做并运算，可减少做并运算前每个元组的长度。</p><h5 id="4-2-1-2-针对不同运算符的优化规则"><a href="#4-2-1-2-针对不同运算符的优化规则" class="headerlink" title="4.2.1.2 针对不同运算符的优化规则"></a>4.2.1.2 针对不同运算符的优化规则</h5><p>针对不同运算符的优化规则如表所示。</p><p>运算符主导的优化:<br><img src="/posts/41900/image-20231003165105278.png" alt></p><ol><li>如WHERE A.a=B.b AND B.b=C.c可以合并为={A.a,B.b,C.c}而不是两个等式={A.a,B.b}和={B.b,C.c}。</li><li>如WHERE A.a=3 OR A.b&gt;8,如果A.a、A.b列上分别有索引，也许SELECT * FROM A WHERE A.a=3 UNION SELECT * FROM A WHERE A.b&gt;8可以分别利用各自的索引提高查询效率。</li></ol><p>选择下推到集合的运算</p><table><thead><tr><th>初始式</th><th>优化后的等价表达式</th><th></th><th></th></tr></thead><tbody><tr><td>等价表达式一</td><td>等价表达式二</td><td>等价表达式三</td><td></td></tr><tr><td>σA(R－S)</td><td>σA(R)－σA(S)</td><td>σA(R)－S</td><td></td></tr><tr><td>σA(R∪S)</td><td>σA(R)∪σA(S)</td><td></td><td></td></tr><tr><td>σA(R∩S)</td><td>σA(R)∩σA (S)</td><td>σA(R)∩S</td><td>R∩σA(S)</td></tr></tbody></table><p>投影下推到集合的运算</p><table><thead><tr><th><strong>初始式</strong></th><th><strong>优化后的等价表达式</strong></th></tr></thead><tbody><tr><td>∏A1,A2,…,An(R－S)</td><td>∏A1,A2,…,An(R)－ ∏A1,A2,…,An(S)</td></tr><tr><td>∏A1,A2,…,An(R∪S)</td><td>∏A1,A2,…,An(R) ∪∏A1,A2,…,An(S)</td></tr><tr><td>∏A1,A2,…,An(R∩S)</td><td>∏A1,A2,…,An(R) ∩∏A1,A2,…,An(S)</td></tr></tbody></table><h5 id="4-2-1-3-查询树启发式规则"><a href="#4-2-1-3-查询树启发式规则" class="headerlink" title="4.2.1.3 查询树启发式规则"></a>4.2.1.3 查询树启发式规则</h5><p>包括：</p><ol><li>选择运算应尽可能先做。</li><li>把投影运算和选择运算同时进行。如有若干投影和选择运算，并且它们都对同一个关系操作，则可以在扫描次关系的同时完成所有这些运算以避免重复扫描关系。</li><li>把投影同其前或后的双目运算结合起来，没有必要为了去掉某些字段而扫描一遍关系。</li><li>把某些选择同在它前面要执行的笛卡尔积结合起来称为一个连接运算。连接（特别是等值连接）运算比笛卡尔积性能高很多。</li><li>找出公共子表达式，将其计算结果缓存起来，避免重复计算。</li></ol><h4 id="4-2-2-语法级查询优化"><a href="#4-2-2-语法级查询优化" class="headerlink" title="4.2.2 语法级查询优化"></a>4.2.2 语法级查询优化</h4><p>语法级优化要解决的主要问题是找出SQL语句的等价变换形式，使得SQL执行更高效，包括：</p><ul><li>子句局部优化。如等价谓词重写、where和having条件简化等。</li><li>关联优化。如子查询优化、连接消除、视图重写等。</li><li>形式变化优化。如嵌套连接消除等。</li></ul><p>以下介绍几种常见的优化方法。</p><h5 id="4-2-2-1-子查询优化"><a href="#4-2-2-1-子查询优化" class="headerlink" title="4.2.2.1 子查询优化"></a>4.2.2.1 子查询优化</h5><p>早期的查询优化器对子查询都采用嵌套执行的方式，即对父查询中的每一行都执行一次子查询，这样效率很低，因此对其进行优化很有必要。例如，将子查询转为连接操作之后，有如下好处：</p><ul><li>子查询不用多次执行；</li><li>优化器可以根据统计信息来选择不同的连接方法和不同的连接顺序；</li><li>子查询中的连接条件、过滤条件分别变成了父查询的连接条件和过滤条件，优化器可以对这些条件进行下推，以提高执行效率。</li></ul><ol><li><strong>常见子查询优化技术</strong></li></ol><p><strong>(1)</strong> <strong>子查询合并</strong></p><p>在语义等价条件下，多个子查询可以合并成一个子查询，这样多次表扫描，多次连接减少为单次表扫描和单次连接。例如：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> t1<span class="token keyword">WHERE</span> <span class="token number">a1</span><span class="token operator">&lt;</span><span class="token number">10</span> <span class="token operator">AND</span> <span class="token punctuation">(</span><span class="token keyword">EXISTS</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token number">a2</span> <span class="token keyword">FROM</span> t2 <span class="token keyword">WHERE</span> t2<span class="token number">.a2</span><span class="token operator">&lt;</span><span class="token number">5</span> <span class="token operator">AND</span> t2<span class="token number">.b2</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">OR</span><span class="token keyword">EXISTS</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token number">a2</span> <span class="token keyword">FROM</span> t2 <span class="token keyword">WHERE</span> t2<span class="token number">.a2</span><span class="token operator">&lt;</span><span class="token number">5</span> <span class="token operator">AND</span> t2<span class="token number">.b2</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可优化为：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> t1<span class="token keyword">WHERE</span> <span class="token number">a1</span><span class="token operator">&lt;</span><span class="token number">10</span> <span class="token operator">AND</span> <span class="token punctuation">(</span><span class="token keyword">EXISTS</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token number">a2</span> <span class="token keyword">FROM</span> t2 <span class="token keyword">WHERE</span> t2<span class="token number">.a2</span><span class="token operator">&lt;</span><span class="token number">5</span> <span class="token operator">AND</span> <span class="token punctuation">(</span>t2<span class="token number">.b2</span><span class="token operator">=</span><span class="token number">1</span> <span class="token operator">OR</span> t2<span class="token number">.b2</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此例中，两个EXISTS子查询合并为一个子查询，查询条件也进行了合并。</p><p><strong>(2)</strong> <strong>子查询展开</strong></p><p>子查询展开又称子查询反嵌套，子查询上拉。实质是把某些子查询重写为等价的多表连接操作。带来好处是，有关的访问路径、连接方法和连接顺序可能被有效使用，使得查询语句的层次尽可能地减少。常见的IN / ANY / SOME / ALL / EXISTS依据情况转为半连接（SEMI JOIN）。例如：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> t1<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t2 <span class="token keyword">WHERE</span> t2<span class="token number">.a2</span><span class="token operator">></span><span class="token number">10</span><span class="token punctuation">)</span> v_t2<span class="token keyword">WHERE</span> t1<span class="token number">.a1</span><span class="token operator">&lt;</span><span class="token number">10</span> <span class="token operator">AND</span> v_t2<span class="token number">.a2</span><span class="token operator">&lt;</span><span class="token number">20</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可优化为：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> t1<span class="token punctuation">,</span> t2<span class="token keyword">WHERE</span> t1<span class="token number">.a1</span><span class="token operator">&lt;</span><span class="token number">10</span> <span class="token operator">AND</span> t2<span class="token number">.a2</span><span class="token operator">&lt;</span><span class="token number">20</span> <span class="token operator">AND</span> t2<span class="token number">.a2</span><span class="token operator">></span><span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此例中，原本的子查询变为了t1、t2表的连接操作，相当于把t2表从子查询中上拉了一层。</p><p>子查询展开是一种最常用的子查询优化技术，如果子查询是只包含选择、投影、连接操作的简单语句，没有聚集函数或者group子句，则可以上拉，前提是上拉后的结果不能带来多余元组，需遵循以下规则：</p><ul><li>如果上层查询结果没有重复（select包含主键），则可以展开子查询，并且展开后的查询的select子句前应加上distinct标志；</li><li>如果上层查询的select语句中有distinct标志，则可以直接子查询展开；</li><li>如果内层查询结果没有重复元组，则可以展开。</li></ul><p>子查询展开的具体步骤如下：</p><ol><li>将子查询和上层查询的from子句连接为同一个from子句，并且修改相应的运行参数；</li><li>将子查询的谓词符号进行相应修改（如IN修改为=ANY）；</li><li>将子查询的where条件作为一个整体与上层查询的where条件进行合并，并用and连接，从而保证新生成的谓词与原谓词的语义相同，成为一个整体。</li></ol><p><strong>(3)</strong> <strong>聚集子查询消除</strong></p><p>这种方法将聚集子查询的计算上推，使得子查询只需计算一次，并与父查询的部分或全表做左外连接。例如：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> t1<span class="token keyword">WHERE</span> t1<span class="token number">.a1</span> <span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">avg</span><span class="token punctuation">(</span>t2<span class="token number">.a2</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> t2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可优化为：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> t1<span class="token punctuation">.</span><span class="token operator">*</span><span class="token keyword">FROM</span> t1<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">avg</span><span class="token punctuation">(</span>t2<span class="token number">.a2</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> t2<span class="token punctuation">)</span> <span class="token keyword">as</span> tm<span class="token punctuation">(</span>avg_a2<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token keyword">WHERE</span> t1<span class="token number">.a1</span> ? tm<span class="token punctuation">.</span>avg_a2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>(4)</strong> <strong>其他</strong></p><p>此外还有利用窗口函数消除子查询、子查询推进等技术</p><ol start="2"><li><strong>针对不同类型子查询的优化方法</strong></li></ol><p><strong>(1) IN类型子查询</strong></p><p>IN类型有３种格式：</p><p>格式一：</p><pre class="line-numbers language-sql"><code class="language-sql">outer_expr <span class="token punctuation">[</span><span class="token operator">not</span><span class="token punctuation">]</span> <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token keyword">select</span> inner_expr <span class="token keyword">from</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">where</span> subquery_where<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>格式二：</p><pre class="line-numbers language-sql"><code class="language-sql">outer_expr <span class="token operator">=</span> <span class="token keyword">any</span> <span class="token punctuation">(</span><span class="token keyword">select</span> inner_expr <span class="token keyword">from</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">where</span> subquery_where<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>格式三：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token punctuation">(</span>oe_1<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> oe_N<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token operator">not</span><span class="token punctuation">]</span> <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token keyword">select</span> ie_1<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> ie_N <span class="token keyword">from</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">where</span> subquery_where<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于in类型子查询的优化，IN类型子查询优化的几种情况</p><p><img src="/posts/41900/5.2.2.1-1.png" alt="5.2.2.1-1"></p><p>情况一：outer_expr和inner_expr均为非NULL值。</p><p>优化后的表达式为：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">exists</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token number">1</span> <span class="token keyword">from</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">where</span> subquery_where <span class="token operator">and</span> outer_expr<span class="token operator">=</span>inner_expr<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>子查询优化需要满足2个条件：</p><ul><li><p>outer_expr和inner_expr不能为NULL；</p></li><li><p>不需要从结果为FALSE的子查询中区分NULL。</p></li></ul><p>情况二：outer_expr是非空值。</p><p>优化后的表达式为：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">exists</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token number">1</span> <span class="token keyword">from</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">where</span> subquery_where <span class="token operator">and</span><span class="token punctuation">(</span>outer_expr<span class="token operator">=</span>inner_expr <span class="token operator">or</span> inner_expr <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>情况三：outer_expr为空值。</p><p>则原表达式等价为：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token boolean">NULL</span> <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token keyword">select</span> inner_expr <span class="token keyword">FROM</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">where</span> subquery_where<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当outer_expr为空时，如果子查询结果为：</p><ul><li>NULL，select语句产生任意行数据；</li><li>FALSE，select语句不产生数据。</li></ul><p>对上面的等价形式，还有2点需说明：</p><ul><li>谓词IN等价于=ANY。如：以下2条SQL语句是等价的。</li></ul><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> col1 <span class="token keyword">from</span> t1 <span class="token keyword">where</span> col1 <span class="token operator">=</span><span class="token keyword">ANY</span> <span class="token punctuation">(</span><span class="token keyword">select</span> col1 <span class="token keyword">from</span> t2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">select</span> col1 <span class="token keyword">from</span> t1 <span class="token keyword">where</span> col1 <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">select</span> col1 <span class="token keyword">from</span> t2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>带有IN谓词的子查询，如果满足上述3种情况，可做等价变换，把外层条件下推到子查询中，变形为EXISTS类型的逻辑表达式判断。而EXISTS子查询可以被半连接算法实现优化。</li></ul><p><strong>(2) ALL/ANY/SOME类型子查询</strong></p><p>ALL/ANY/SOME子查询格式如下：</p><pre class="line-numbers language-sql"><code class="language-sql">outer_expr operator <span class="token keyword">ALL</span> <span class="token punctuation">(</span>subquery<span class="token punctuation">)</span>outer_expr operator <span class="token keyword">ANY</span> <span class="token punctuation">(</span>subquery<span class="token punctuation">)</span>outer_expr operator <span class="token keyword">SOME</span> <span class="token punctuation">(</span>subquery<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中，operator是操作符，可以是&gt;、&gt;=、=、&lt;、&lt;=中任何一个。其中，</p><ul><li>=ANY与IN含义相同，可采用IN子查询优化方法；</li><li>SOME与ANY含义相同；</li><li>NOT IN 与 &lt;&gt;ALL含义相同；</li></ul><p>如果子查询中没有group by子句，也没有聚集函数，则以下表达式可以使用聚集函数MAX/MIN做等价转换：</p><ul><li><code>val&gt;=ALL (select ...)</code> 等价变换为：<code>val&gt;= (select MAX...)</code></li><li><code>val&lt;=ALL (select ...)</code> 等价变换为：<code>val&lt;= (select MAX...)</code></li><li><code>val&gt;=ANY (select ...)</code> 等价变换为：<code>val&gt;= (select MIN...)</code></li><li><code>val&gt;=ANY (select ...)</code> 等价变换为：<code>val&gt;= (select MAX...)</code></li></ul><p><strong>(3) EXISTS类型子查询</strong></p><p>存在谓词子查询格式为：[NOT] EXISTS (subquery)</p><p>需要注意几点：</p><ul><li>EXISTS(subquery)值为TRUE/FALSE，不关心subquery返回的内容。</li><li>EXISTS(subquery)自身有”半连接”的语义，部分DBMS用半连接来实现它；NOT EXISTS通常会被标识为”反半连接”处理。</li><li>IN(subquery)等子查询可以被转换为EXISTS(subquery)格式。</li></ul><p>所谓半连接（Semi Join），是一种特殊的连接类型。如果用”t1.x semi= t2.y”来表示表T1和表T2做半连接，则其含义是：只要在表T2中找到一条记录满足t1.x=t2.y，则马上停止搜索表T2，并直接返回表T1中满足条件t1.x=t2.y的记录，因此半连接的执行效率高于普通的内连接。</p><h5 id="4-2-2-2-等价谓词重写"><a href="#4-2-2-2-等价谓词重写" class="headerlink" title="4.2.2.2 等价谓词重写"></a>4.2.2.2 等价谓词重写</h5><p>等价谓词重写包括：LIKE规则、BETWEEN-AND规则、IN转换OR规则、IN转换ANY规则、OR转换ANY规则、ALL/ANY转换集函数规则、NOT规则等，相关原理比较简单，有兴趣的同学可以自行查找相关查询重写规则。</p><h5 id="4-2-2-3-条件化简"><a href="#4-2-2-3-条件化简" class="headerlink" title="4.2.2.3 条件化简"></a>4.2.2.3 条件化简</h5><p>WHERE、HAVING和ON条件由许多表达式组成，而这些表达式在某些时候彼此间存在一定的联系。利用等式和不等式性质，可将WHERE、HAVING和ON条件简化，但不同数据库的实现可能不完全相同。</p><p>将WHERE、HAVING和ON条件简化的方式通常包括如下几个：</p><ol><li><p>去除表达式中冗余的括号：以减少语法分析时产生的AND和OR树的层次；</p></li><li><p>常量传递：对不同关系可使用条件分离后有效实施”选择下推”，从而减小中间关系的规模。如：</p><p> <code>col1=col2 AND col2=3</code> 可化简为：<code>col1=3 AND col2=3</code></p><p> 操作符=、&lt;、&gt;、&lt;=、&gt;=、&lt;&gt;、LIKE中的任何一个，在<code>col1&lt;操作符&gt;col2</code>条件中都会发生常量传递</p></li><li><p>消除死码。化简条件，将不必要的条件去除。如：</p><p> <code>WHERE (0&gt;1 AND s1=5)</code>, <code>0&gt;1</code>使得<code>AND</code>为恒假，去除即可。</p></li><li><p>表达式变换。化简条件（如反转关系操作符的操作数顺序），从而改变某些表的访问路径。如：-a=3可化简为a=-3，若a上有索引，则可利用。</p></li><li><p>不等式变换。化简条件，将不必要的重复条件去除。如：</p><p> <code>a&gt;10 AND b=6 AND a&gt;2</code> 可化简为：<code>a&gt;10 AND b=6</code>。</p></li><li><p>布尔表达式变换。包括：</p></li></ol><ul><li>谓词传递闭包。如：<code>a&gt;b AND b&gt;2</code>可推导出<code>a&gt;2</code>，减少a、b比较元组数。</li><li>任何一个布尔表达式都能被转换为一个等价的合取范式。一个合取项为假，则整个表达式为假。</li></ul><h3 id="4-3-物理优化"><a href="#4-3-物理优化" class="headerlink" title="4.3 物理优化"></a>4.3 物理优化</h3><p>代数优化改变查询语句中操作的次序和组合，但不涉及底层的存取路径。物理优化就是要选择高效合理的操作算法或存取路径，求得优化的查询计划，达到查询优化的目标。</p><p>查询优化器在物理优化阶段，主要解决的问题是：</p><ul><li>从可选的单表扫描方式中，挑选什么样的单表扫描方式最优？</li><li>对于两表连接，如何连接最优？</li><li>对于多表连接，哪种连接顺序最优？</li><li>对于多表连接，是否需要对每种连接顺序都探索？如果不全部探索，如何找到一种最优组合？</li></ul><p>选择的方法可以是：</p><ol><li>基于规则的启发式优化。</li><li>基于代价估算的优化。</li><li>两者结合的优化方法。常常先使用启发式规则选取若干个较优的候选方案，减少代价估算的工作量，然后分别计算这些候选方案的执行代价，较快地选出最终的优化方法。</li></ol><p>启发式规则优化是定性的选择，比较粗糙，但是实现简单而且优化本身的代价较小，适合解释执行的系统。因为解释执行的系统，其优开销包含在查询总开销之中，在编译执行的系统中，一次编译优化，多次执行，查询优化和查询执行是分开的，因此，可以用精细复杂一些的基于代价的优化方法。</p><h4 id="4-3-1-基于代价的优化"><a href="#4-3-1-基于代价的优化" class="headerlink" title="4.3.1 基于代价的优化"></a>4.3.1 基于代价的优化</h4><h5 id="4-3-1-1-查询代价估算"><a href="#4-3-1-1-查询代价估算" class="headerlink" title="4.3.1.1 查询代价估算"></a>4.3.1.1 查询代价估算</h5><p>查询代价估算基于CPU代价和I/O代价，计算公式如下：</p><pre><code>总代价 = I/O代价 + CPU代价COST = P * a_page_cpu_time + W * T</code></pre><p>其中：</p><p>P是计划运行时访问的页面数，a_page_cpu_time是每个页面读取的时间开销，其乘积反映了I/O开销。</p><p>T为访问的元组数，如果是索引扫描，还要考虑索引读取的开销，反映了数据读取到内存的CPU开销。</p><p>W为权重因子，表明I/O到CPU的相关性，又称选择率（selectivity），用于表示在关系R中，满足条件“A a”的元组数与R的所有元组数N的比值。</p><p>选择率在代价估算模型中占有重要地位，其精确程度直接影响最优计划的选取。选择率计算常用方法如下：</p><ol><li>无参数方法：使用ad hoc（点对点）数据结构或直方图维护属性值的分布，直方图最常用；</li><li>参数法：使用具有一些自由统计参数（参数是预先估计出来的）的数学分布函数逼近真实分布；</li><li>曲线拟合法：为克服参数法的不灵活性，用一般多项式来标准最小方差来逼近属性值的分布；</li><li>抽样法：从数据库中抽取部分样本元组，针对这些样本进行查询，然后收集统计数据；</li><li>综合法：将以上几种方法结合起来，如抽样法和直方图法结合。</li></ol><p>由于其中I/O代价占比最大，通常以I/O代价为主来进行代价估算。</p><ol><li>全表扫描算法的代价估算公式</li></ol><ul><li><p>如果基本表大小为 B 块，全表扫描算法的代价 cost = B；</p></li><li><p>如果选择条件是”码＝值”，则平均搜索代价 cost = B/2。</p><ol start="2"><li>索引扫描算法的代价估算公式</li></ol></li><li><p>如果选择条件为”码=值”，则采用该表的主索引，若为B+树，设索引层数为L，需要存取B+树中从根节点到叶节点L块，再加上基本表中该元组所在的那一块，cost=L+1。</p></li><li><p>如果选择条件涉及非码属性，若为B+树索引，选择条件是相等比较，S为索引选择基数（有S个元组满足条件），假设满足条件的元组保存在不同块上，则最坏情况下cost=L+S。</p></li><li><p>l 若比较条件为&gt;,&gt;=,&lt;,&lt;=，假设有一半元组满足条件，则需要存取一半的叶节点，并通过索引访问一半的表存储块，cost=L+Y/2+B/2。若可以获得更准确的选择基数，可进一步修正Y/2与B/2。</p><p>3.嵌套循环连接算法的代价估算公式</p></li><li><p>嵌套循环连接算法的代价为：cost=Br+BrBs/(K-1), 且K&lt;B(R)&lt;B(S)，其中K表示缓冲区大小为K块；</p></li><li><p>若需要把中间结果写回磁盘，则代价为：cost=Br+BrBs/(K-1) +　(Frs*Nr*Ns)/Mrs。Frs为连接选择率，表示连接结果数的比例，Mrs为块因子，表示每块中可以存放的结果元组数目。</p><p>4.排序合并连接算法的代价估算公式</p></li><li><p>如 果 连 接 表 已 经 按 照 连 接 属 性 排 好 序 ， 则 cost =Br+Bs+(Frs*Nr*Ns)/Mrs。</p></li><li><p>如果必须对文件排序，需要在代价函数中加上排序的代价对 于 包 含 B 个 块 的 文 件 排 序 的 代 价 大 约 是：cost =(2*B)+(2*B*log2B)。</p></li></ul><h5 id="4-3-1-2-基于代价的连接顺序选择"><a href="#4-3-1-2-基于代价的连接顺序选择" class="headerlink" title="4.3.1.2 基于代价的连接顺序选择"></a>4.3.1.2 基于代价的连接顺序选择</h5><p>多表连接算法实现的是在查询路径生成的过程中，根据代价估算，从各种可能的候选路径中找出最优的路径。它需要解决两个问题：</p><ul><li>多表连接的顺序</li><li>多表连接的搜索空间：N个表的连接可能有N！种连接组合，这可能构成一个巨大的搜索空间。如何将搜索空间限制在一个可接受的范围内，并高效生成查询执行计划将成为一个难点。</li></ul><p>多表间的连接顺序表示了查询计划树的基本形态。在1990年，Schneder等人在研究查询树模型时提出了左深树，右深树和紧密树3种形态</p><p><img src="/posts/41900/5-1.png" alt="图5-1 三种树的形态"></p><p>即使是同一种树的生成方式，也有细节需要考虑。如图5-1-a中{A,B}和{B,A}两种连接方式开销可能不同。比如最终连接结果{A,B,C}则需要验证比较6种连接方式，找出最优的一种作为下次和其他表连接的依据。</p><p>多表连接搜索最优查询树，有很多算法，如启发式、分枝界定计划枚举、贪心、动态规划、爬山法、System R优化方法等。其中，常用算法如下。</p><ol><li><p><strong>动态规划</strong></p><p> 在数据库领域，动态规划算法主要解决多表连接的问题。它是自底向上进行的，即从叶子开始做第一层，然后开始对每层的关系做两两连接（如果满足内连接进行两两连接，不满足则不可对全部表进行两两连接），构造出上层，逐次递推到树根。以下介绍具体步骤：</p><p> 初始状态：构造第一层关系，即叶子结点，每个叶子对应一个单表，为每一个待连接的关系计算最优路径（单表的最优路径就是单表的最佳访问方式，通过评估不同的单表的数据扫描方式代价，找出代价最小的作为每个单表的局部最优路径）</p><p> 归纳：当第1层到第n-1层的关系已经生成，那么求解第n层的关系方法为：将第n-1层的关系与第一层中的每个关系连接，生成新的关系（对新关系的大小进行估算），放于第n层，且每一个新关系，均求解最优路径。每层路径的生成都是基于下层生成的最优路径，这满足最优化原理的要求。</p><p> 还有的改进算法，在生成第n层的时候，除了通过第n-1层和第一层连接外，还可以通过第n-2层和第二层连接…。</p><p> PostgreSQL查询优化器求解多表连接时，采用了这种算法。</p></li><li><p><strong>启发式算法</strong></p><p> 启发式算法是相对最优化算法提出的，是一个基于直观或者经验构造的算法，不能保证找到最好的查询计划。在数据库的查询优化器中，启发式一直贯穿于整个查询优化阶段，在逻辑查询优化阶段和物理查询优化阶段，都有一些启发式规则可用。PostgreSQL，MySQL，Oracle等数据库在实现查询优化器时，采用了启发式和其他方式相结合的方式。</p><p> 物理查询优化阶段常用启发式规则如下：</p><ul><li>关系R在列X上建立索引，且对R的选择操作发生在列X上，则采用索引扫描方式；</li><li>R连接S，其中一个关系上的连接列存在索引，则采用索引连接且此关系作为内表；</li><li>R连接S，其中一个关系上的连接列是排序的，则采用排序连接比hash连接好。</li></ul></li><li><p><strong>贪心算法</strong></p><p> 贪心算法最后得到的是局部最优解，不一定全局最优，其实现步骤如下：</p><p> (1) 初始，算法选出的候选对象集合为空；</p><p> (2) 根据选择函数，从剩余候选对象中选出最有可能构成解的对象；</p><p> (3) 如果集合中加上该对象后不可行，那么该对象就被丢弃并不再考虑；</p><p> (4) 如果集合中加上该对象后可行，就加到集合里；</p><p> (5) 扩充集合，检查该集合是否构成解；</p><p> (6) 如果贪心算法正确工作，那么找到的第一个解通常都是最优的，可以终止算法；</p><p> (7) 继续执行第二步。</p><p> MySQL查询优化器求解多表连接时采用了这种算法。</p></li><li><p><strong>System-R算法</strong></p></li></ol><p>对自底向上的动态规划算法进行了改进，主要思想是把子树的查询计划的最优查询计划和次优查询计划保留，用于上层的查询计划生成，以便使得查询计划总体上最优。</p><p>多表连接常用算法比较</p><table><thead><tr><th><strong>算法名称</strong></th><th><strong>特点与适用范围</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td>启发式算法</td><td>适用于任何范围，与其它算法结合，能有效提高整体效率</td><td>不知道得到的解是否最优</td></tr><tr><td>贪婪算法</td><td>非穷举类型的算法。适合解决较多关系的搜索</td><td>得到局部最优解</td></tr><tr><td>爬山法</td><td>适合查询中包含较多关系的搜索，基于贪婪算法</td><td>随机性强，得到局部最优解</td></tr><tr><td>遗传算法</td><td>非穷举类型的算法。适合解决较多关系的搜索</td><td>得到局部最优解</td></tr><tr><td>动态规划算法</td><td>穷举类型的算法。适合查询中包含较少关系的搜索，可得到全局最优解</td><td>搜索空间随关系个数增长呈指数增长</td></tr><tr><td>System R优化</td><td>基于自底向上的动态规划算法，为上层提供更多可能的备选路径，可得到全局最优解</td><td>搜索空间可能比动态规划算法更大一些</td></tr></tbody></table><h4 id="4-3-2-基于规则的优化"><a href="#4-3-2-基于规则的优化" class="headerlink" title="4.3.2 基于规则的优化"></a>4.3.2 基于规则的优化</h4><p>基于代价优化的一个缺点是优化本身的代价。因此，查询优化器使用启发式方法来减少优化代价。</p><ul><li>选择操作的启发式规则：</li></ul><p>1) 对于小关系，全表扫描；</p><p>2) 对于大关系：</p><pre><code>(1) 若选择条件是主码，则可以选择主码索引，因为主码索引一般是被自动建立的；(2) 若选择条件是非主属性的等职查询，并且选择列上有索引，如果选择比例较小（10%）可以使用索引扫描，否则全表扫描；(3) 若选择条件是属性上的非等值查询或者范围查询，同上；(4) 对于用and连接的合取选择条件，若有组合索引，优先用组合索引方法；如果某些属性上有一般索引，则用索引扫描，否则全表扫描；(5) 对于用OR连接的析取选择条件，全表扫描。</code></pre><ul><li>连接操作的启发式规则</li></ul><p>1) 若两个表都已经按连接属性排序，则选用排序-合并算法；</p><p>2) 若一个表在连接属性上有索引，则使用索引连接方法；</p><p>3) 若其中一个表较小，则选用hash join；</p><p>4) 最后可以使用嵌套循环，小表作为外表。</p><h2 id="第五章-事务处理"><a href="#第五章-事务处理" class="headerlink" title="第五章 事务处理"></a>第五章 事务处理</h2><h3 id="5-1-事务概念"><a href="#5-1-事务概念" class="headerlink" title="5.1 事务概念"></a>5.1 事务概念</h3><p>在数据库系统中，事务是指由一系列数据库操作组成的一个完整的逻辑过程。数据库提供了增、删、改、查等几种基础操作，用户可以灵活地组合这几种操作来实现复杂的语义。在很多场景下，用户希望一组操作可以做为一个整体一起生效，这就是事务的产生背景。</p><blockquote><p>例如，一个银行转帐业务，在数据库中需要通过两个修改操作来实现：</p><ol><li>从账户A扣除指定金额；</li><li>向账户B添加指定金额。</li></ol><p>这两个操作构成了一个完整的逻辑过程，不可拆分。如果第一个操作成功而第二个操作失败，说明转账没有成功。在这种情况下，对于银行来说，数据库中的账户数据是处于一种不正确的状态的，必须撤销掉第一个操作对数据库的修改，让账户数据恢复到转账前的状态。由此例可见，事务是数据库状态变更的基本单元，在事务将数据库从一个正确状态变更到另一个正确状态的过程中，数据库的那些中间状态，既不应该被其他事务看到或干扰，也不应该在事务结束后依然保留。</p></blockquote><p>根据以上描述的事务概念，事务应具有四个特性，称为事务的ACID特性。它们分别是：</p><ul><li><strong>原子性</strong> （Atomicity）：一个事务中的所有操作，要么全做，要么全不做。事务如果在执行过程中发生错误，该事务修改过的数据应该被恢复到事务开始前的状态，就像这个事务从来没有执行过一样。</li><li><strong>一致性</strong> （Consistency）：当数据库只包含成功事务提交的结果时，称数据库处于一致性状态。事务执行的结果必须使数据库从一个一致性状态变到另一个一致性状态。由此可见，一致性与原子性是密切相关的。</li><li><strong>隔离性</strong> （Isolation）：一个事务的执行不能被其他事务干扰。DBMS允许多个并发事务同时执行，隔离性可以防止多个事务并发执行时由于相互干扰而导致数据的不一致。</li><li><strong>持久性</strong> （Durability）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><p>在数据库运行过程中，刚插入的数据往往不会直接写入磁盘，而是先缓存在内存中。对于一个运行中的数据库，可以将其地址空间简单分成三个部分:</p><ul><li>1.持久化保存数据的磁盘空间</li><li>2.缓冲区对应的内存或虚拟内存空间</li><li>3.事务的局部地址空间〈也在内存中)</li></ul><p>事务要读取数据，首先要将数据取到缓冲区中，然后缓冲区的数据可以被事务读取到局部空间。事务的写入过程与此相反，先在局部空间中创建新值，然后再将新数据拷贝到缓冲区中。缓冲区中的数据通常是由缓冲区管理器决定何时写入磁盘，而不是立刻持久化到磁盘。</p><p>在SQL中，开始和结束事务的语句如下：</p><ul><li>BEGIN TRANSACTION：开始一个事务。除了用该语句显式地开始一个事务，DBMS也允许隐式的开始一个事务。隐式开始事务时无需执行任何语句，每当用户连接成功，即开始一个事务，前一个事务结束时，即自动开始下一个事务。</li><li>COMMIT：提交一个事务。此语句表示事务正常结束，DBMS应永久保存该事务对数据库的修改。</li><li>ROLLBACK：回滚一个事务。此语句表示事务异常结束，DBMS应撤销该事务对数据库的所有修改。需要注意的是，当事务发生故障时，即使用户没有显式执行ROLLBACK语句，DBMS也应自动回滚事务。</li></ul><p>一个支持事务的DBMS必须能保证事务的ACID特性，这部分工作是由事务处理机制来负责的。事务处理机制又分为并发控制机制和故障恢复机制两部分，以下分别介绍。</p><p><img src="/posts/41900/image-20231009204945330.png" alt></p><h3 id="5-2-并发控制"><a href="#5-2-并发控制" class="headerlink" title="5.2 并发控制"></a>5.2 并发控制</h3><p>所谓并发操作，是指在多用户共享的数据库中，多个事务可能同时对同一数据进行操作。如果对这些操作不加控制，则可能导致数据的不一致问题。因此，为了保证事务的一致性和隔离性，DBMS需要对并发操作进行正确调度。这就是并发控制机制的任务。</p><h4 id="5-2-1-并发错误"><a href="#5-2-1-并发错误" class="headerlink" title="5.2.1 并发错误"></a>5.2.1 并发错误</h4><p>并发操作带来的数据不一致性包括丢失修改、读脏和不可重复读。</p><ol><li><p>丢失修改</p><p> 两个以上事务从数据库中读入同一数据并修改，其中一个事务（后提交的事务）的提交结果破坏了另一事务（先提交的事务）的提交结果，导致先提交的事务对数据库的修改被丢失。</p></li><li><p>读脏</p><p> 事务读取了被其他事务修改且未提交的数据，即从数据库中读到了临时性数据。</p></li><li><p>不可重复读</p><p> 一个事务读取数据后，该数据又被另一事务修改，导致前一事务无法再现前一次的读取结果。</p><p> 不可重复读又可分为两种情况：一种情况是第一次读到的数据的值在第二次读取时发生了变化；还有一种情况是事务第二次按相同条件读取数据时，返回结果中多了或者少了一些记录。后者又被称为幻读。</p></li></ol><h4 id="5-2-2-并发控制的正确性标准"><a href="#5-2-2-并发控制的正确性标准" class="headerlink" title="5.2.2 并发控制的正确性标准"></a>5.2.2 并发控制的正确性标准</h4><p>并发控制机制的任务就是对并发事务进行正确的调度，但是什么样的调度才是正确的呢？我们需要一个正确性的判断标准。</p><h5 id="5-2-2-1-可串行化"><a href="#5-2-2-1-可串行化" class="headerlink" title="5.2.2.1 可串行化"></a>5.2.2.1 可串行化</h5><p>串行调度是指多个事务依序串行执行，仅当一个事务的所有操作执行完后才执行另一个事务。这种调度方式下，不可能出现多个事务同时访问同一数据的问题，自然也就不可能出现并发错误。串行调度显然是正确的，但是串行调度无法充分利用系统资源，因此其效率显然也是用户难以接受的。</p><p>并发调度是指在数据库系统中同时执行多个事务。DBMS对多个并发事务进行调度时，可能产生多个不同的调度序列，从而得到不同的执行结果。如何判断某个调度是不是正确呢？如果这些并发事务的执行结果与它们按某一次序串行执行的结果相同，则认为该并发调度是正确的，我们称之为可串行化调度。</p><h5 id="5-2-2-2-冲突可串行化"><a href="#5-2-2-2-冲突可串行化" class="headerlink" title="5.2.2.2 冲突可串行化"></a>5.2.2.2 冲突可串行化</h5><p>可串行化是并发控制的正确性准则。但是按照可串行化的定义，如果想要判断一个并发调度是不是可串行化调度，需要知道这批事务所有可能的串行调度的结果，然后将该并发调度的结果与这些结果进行比较，这显然是难以实施的。因此，我们需要一种可操作的判断标准，即冲突可串行化。</p><p>冲突可串行化是可串行化的充分条件。如果一个并发调度是冲突可串行化的，那么它一定是可串行化的。在定义冲突可串行化之前，需要先了解什么是冲突操作。</p><p>冲突操作是指不同的事务对同一个数据的读写操作或写写操作。例如，事务1对数据A的读操作”r1(A)”与事务2对数据A的写操作”w2(A)”就是一对冲突操作。</p><p>我们规定，不同事务的冲突操作和同一事务的两个操作是不能交换的。因为如果改变冲突操作的次序，则最后的数据库状态会发生变化。按照这个规定，在保证一个并发调度中的冲突操作次序不变的情况下，如果通过交换两个事务的非冲突操作，能够得到一个串行调度，则称该并发调度是冲突可串行化的。</p><p>例如，对于以下两个并发调度序列：</p><p>SC1：r1(A) w1(B) r2(B) w1(C) w2(B)</p><p>SC2：r1(B) r2(A) w1(A) w2(B)</p><p>SC1就是冲突可串行化的，因为可以通过交换非冲突操作3和4得到一个串行调度序列。而SC2则是非冲突可串行化的，因为操作2和3是冲突操作，无法交换。</p><h4 id="5-2-3-事务隔离级别"><a href="#5-2-3-事务隔离级别" class="headerlink" title="5.2.3 事务隔离级别"></a>5.2.3 事务隔离级别</h4><p>可串行化是一个很严格的正确性标准。在实际应用中，有时候可能会希望降低这个标准，通过牺牲一定的正确性，达到提高并发度的目的。为此，SQL标准将事务的隔离程度划分为四个等级，允许用户根据需要自己指定事务的隔离级。这四种隔离级包括读未提交（Read Uncommitted）、读提交（Read Committed）、可重复读（Repeatable Read）和可串行化（Serializable）。</p><ol><li>读未提交：在该隔离级别，事务可以看到其他未提交事务的执行结果，即允许读脏数据。</li><li>读提交：这是大多数DBMS的默认隔离级别，它要求事务只能看见已提交事务所做的修改，因此可以避免读脏数据。但是由于在某个事务的执行期间，同一个数据可能被另一个事务修改并提交，所以该事务对该数据的两次读取可能会返回不同的值，即出现不可重复读错误。</li><li>可重复读：在该隔离级别，同一事务多次读取同一数据时，总是会读到同样的值。不过理论上，该隔离级不能避免幻读，即使用相同条件多次读取时，满足读取条件的数据的数量可能有变化，比如多出一些满足条件的数据。</li><li>可串行化：这是最高的隔离级别，能够避免所有并发错误。可串行化的概念前面已经介绍过，此处不再赘述。</li></ol><h3 id="5-3-封锁机制"><a href="#5-3-封锁机制" class="headerlink" title="5.3 封锁机制"></a>5.3 封锁机制</h3><h4 id="5-3-1什么是封锁"><a href="#5-3-1什么是封锁" class="headerlink" title="5.3.1什么是封锁"></a>5.3.1什么是封锁</h4><p>封锁机制是一种常用的并发控制手段，它包括三个环节：第一个环节是申请加锁，即事务在操作前对它要使用的数据提出加锁请求；第二个环节是获得锁，即当条件满足时，系统允许事务对数据加锁，使事务获得数据的控制权；第三个环节是释放锁，即完成操作后事务放弃数据的控制权。为了达到并发控制的目的，在使用时事务应选择合适的锁，并遵从一定的封锁协议。</p><p>基本的封锁类型有两种：排它锁（Exclusive Locks，简称X锁）和共享锁（Share Locks，简称S锁）。</p><ol><li><p>排它锁</p><p> 排它锁也称为独占锁或写锁。一旦事务T对数据对象A加上了排它锁（X锁），则其他任何事务不能再对A加任何类型的锁，直到T释放A上的锁为止。</p></li><li><p>共享锁</p><p> 共享锁又称读锁。如果事务T对数据对象A加上了共享锁（S锁），其他事务对A就只能加S锁而不能加X锁，直到事务T释放A上的S锁为止。</p></li></ol><h4 id="5-3-2-封锁协议"><a href="#5-3-2-封锁协议" class="headerlink" title="5.3.2 封锁协议"></a>5.3.2 封锁协议</h4><p>简单地对数据加X锁和S锁并不能保证数据库的一致性。在对数据对象加锁时，还需要约定一些规则，包括何时申请锁、申请什么类型的锁、何时释放锁等，这些规则称为封锁协议。不同的规则形成了各种不同的封锁协议。封锁协议分三级，它们对并发操作带来的丢失修改、读脏和不可重复读等并发错误，可以在不同程度上予以解决。</p><ol><li><p>一级封锁协议</p><p> 一级封锁协议是指事务T在修改数据之前必须先对其加X锁，直到事务结束才释放。</p><p> 一级封锁协议可有效地防止丢失修改，并能够保证事务T的可恢复性。但是，由于一级封锁没有要求对读数据进行加锁，所以不能防止读脏和不可重复读。遵循一级封锁协议的事务可以达到读未提交的事务隔离级。</p></li><li><p>二级封锁协议</p><p> 二级封锁协议是指事务T在修改数据之前必须先加X锁，直到事务结束才释放X锁；在读取数据之前必须先加S锁，读完后即可释放S锁。</p><p> 二级封锁协议不但能够防止丢失修改，还可进一步防止读脏。遵循二级封锁协议的事务可以达到读提交的事务隔离级。</p></li><li><p>三级封锁协议</p><p> 三级封锁协议是事务T在读取数据之前必须先对其加S锁，在修改数据之前必须先对其加X锁，直到事务结束后才释放所有锁。</p><p> 由于三级封锁协议强调即使事务读完数据A之后也不释放S锁，从而使得别的事务无法更改数据A，所以三级封锁协议不但能够防止丢失修改和读脏，而且能够防止不可重复读。遵循三级封锁协议的事务至少可以达到可重复读的事务隔离级，至于是否能到达可串行化级别，则取决于S锁的粒度。比如，如果只对要读取的记录加锁，则无法避免幻读问题；但如果是对整个表加锁，则幻读问题可以避免，代价是并发度的下降。</p></li></ol><h4 id="5-3-3-封锁的实现"><a href="#5-3-3-封锁的实现" class="headerlink" title="5.3.3 封锁的实现"></a>5.3.3 封锁的实现</h4><p>锁管理器可以实现为一个进程或线程，它从事务接受请求消息并反馈结果消息。对于事务的加锁请求消息，锁管理器返回授予锁消息，或者要求事务回滚的消息（发生死锁时）；对于事务的解锁请求消息，只需返回一个确认消息，但可能触发锁管理器向正在等待该事务解锁的其他事务发送授予锁消息。</p><p>锁管理器使用以下数据结构：</p><ul><li>为目前已加锁的每个数据对象维护一个链表，链表中的每个结点代表一个加锁请求，按请求到达的顺序排序。一个加锁请求包含的信息有：提出请求的事务ID，请求的锁的类型，以及该请求是否已被授予锁。</li><li>使用一个以数据对象ID为索引的散列表来查找数据对象（如果有的话），这个散列表叫做锁表。</li></ul><p>下图是一个锁表的示例图，该表包含5个不同的数据对象14、17、123、144和1912的锁。锁表采用溢出链表示法，因此对于锁表的每一个表项都有一个数据对象的链表。每一个数据对象都有一个已授予锁或等待授予锁的事务请求列表，已授予锁的请求用深色阴影方块表示，等待授予锁的请求则用浅色阴影方块表示。 例如，事务T23在数据对象17和1912上已被授予锁，并且正在等待对数据对象14加锁。</p><p><img src="/posts/41900/image-20231003184009931.png" alt></p><p>虽然图没有标示出来，但对锁表还应当维护一个基于事务标识符的索引，这样它可以快速确定一个给定事务持有的锁的集合。</p><p>锁管理器这样处理请求：</p><ul><li>当一条加锁请求消息到达时，如果锁表中存在相应数据对象的链表，则在该链表末尾增加一个请求；否则，新建一个仅包含该请求的链表。对于当前没有加锁的数据对象，总是满足事务对其的第一次加锁请求，但当事务向已被加锁的数据对象申请加锁时，只有当该请求与当前持有的锁相容、并且所有之前的请求都已授予锁的条件下，锁管理器才为该请求授予锁，否则，该请求只能等待。</li><li>当锁管理器收到一个事务的解锁消息时，它先找到对应的数据对象链表，删除其中该事务的请求，然后检查其后的请求，如果有，则看该请求能否被满足，如果能，锁管理器授权该请求，再按相同的方式处理后续的请求。</li><li>如果一个事务被中止，锁管理器首先删除该事务产生的正在等待加锁的所有请求；当系统采取适当动作撤销了该事务后，该中止事务持有的所有锁也将被释放。</li></ul><p>这个算法保证了锁请求无饿死现象，因为在先接收到的请求正在等待加锁时，后来的请求不可能获得授权。</p><p>为了避免消息传递的开销，在许多DBMS中，事务通过直接更新锁表来实现封锁，而不是向锁管理器发送请求消息。事务加锁和解锁的操作逻辑与上述锁管理器的处理方法类似，但是有两个明显的区别：</p><ul><li>由于多个事务可以同时访问锁表，因此必须确保对锁表的互斥访问。</li><li>如果因为锁冲突而不能立刻获得锁，加锁事务需要知道自己何时可以被授予锁，解锁事务需要标记出那些可以被授予锁的事务并通知它们。这个功能可以通过操作系统的信号量机制来实现。</li></ul><h4 id="5-3-4-死锁处理"><a href="#5-3-4-死锁处理" class="headerlink" title="5.3.4 死锁处理"></a>5.3.4 死锁处理</h4><p>封锁机制有可能导致死锁，DBMS必须妥善地解决死锁问题，才能保障系统的正常运行。</p><p>如果事务T1和T2都需要修改数据Rl和R2，并发执行时Tl封锁了数据R1，T2封锁了数据R2；然后T1又请求封锁R2，T2又请求封锁Rl；因T2已封锁了R2，故T1等待T2释放R2上的锁。同理，因T1已封锁了R1，故T2等待T1释放R1上的锁。由于Tl和T2都没有获得全部需要的数据，所以它们不会结束，只能继续等待。这种多事务交错等待的僵持局面称为死锁。</p><p>一般来讲，死锁是不可避免的。DBMS的并发控制子系统一旦检测到系统中存在死锁，就要设法解除。通常采用的方法是选择一个处理死锁代价最小的事务，将其中止，释放此事务持有的所有的锁，使其他事务得以继续运行下去。当然，被中止的事务已经执行的所有数据修改操作都必须被撤销。</p><p>数据库中解决死锁问题主要有两类方法：一类方法是允许发生死锁，然后采用一定手段定期诊断系统中有无死锁，若有则解除之，称为死锁检测；另一类方法是采用一定措施来预防死锁的发生，称为死锁预防。</p><h5 id="5-3-4-1-死锁检测"><a href="#5-3-4-1-死锁检测" class="headerlink" title="5.3.4.1 死锁检测"></a>5.3.4.1 死锁检测</h5><p>锁管理器通过waits-for图记录事务的等待关系，如图6-2所示。其中结点代表事务，有向边代表事务在等待另一个事务解锁。当waits-for图出现环路时，就说明出现了死锁。锁管理器会定时检测waits-for图，如果发现环路，则需要选择一个合适的事务中止它。</p><p><img src="/posts/41900/6-2.png" alt="图6-2 waits-for图示例图"></p><p>图6-2 waits-for图示例图</p><h5 id="5-3-4-2-死锁避免"><a href="#5-3-4-2-死锁避免" class="headerlink" title="5.3.4.2 死锁避免"></a>5.3.4.2 死锁避免</h5><p>当事务请求的锁与其他事务出现锁冲突时，系统为防止死锁，杀死其中一个事务。选择要杀死的事务时，一般持续越久的事务，保留的优先级越高。这种防患于未然的方法不需要waits-for图，但提高了事务被杀死的比率。</p><h4 id="5-3-5-封锁粒度"><a href="#5-3-5-封锁粒度" class="headerlink" title="5.3.5 封锁粒度"></a>5.3.5 封锁粒度</h4><p>封锁粒度是指封锁对象的大小。封锁对象可以是逻辑单元，也可以是物理单元。以关系数据库为例，封锁对象可以是属性值、属性值的集合、记录、表、直至整个数据库；也可以是一些物理单元，例如页（数据页或索引页）、块等。封锁粒度与系统的并发度及并发控制的开销密切相关。封锁的粒度越小，并发度越高，系统开销也越大；封锁的粒度越大，并发度越低，系统开销也越小。</p><p>如果一个DBMS能够同时支持多种封锁粒度供不同的事务选择，这种封锁方法称为多粒度封锁。选择封锁粒度时应该综合考虑封锁开销和并发度两个因素，选择适当的封锁粒度以求得最优的效果。通常，需要处理一个表中大量记录的事务可以以表为封锁粒度；需要处理多个表中大量记录的事务可以以数据库为封锁粒度；而对于只处理少量记录的事务，则以记录为封锁粒度比较合适。</p><h3 id="5-4-故障恢复"><a href="#5-4-故障恢复" class="headerlink" title="5.4 故障恢复"></a>5.4 故障恢复</h3><p>故障恢复机制是在数据库发生故障时确保数据库一致性、事务原子性和持久性的技术。当崩溃发生时，内存中未提交到磁盘的所有数据都有丢失的风险。故障恢复的作用是防止崩溃后的信息丢失。</p><p>故障恢复机制包含两个部分:</p><ul><li>为了确保DBMS能从故障中恢复，在正常事务处理过程中需要执行的操作，如登记日志、备份数据等。</li><li>发生故障后，将数据库恢复到原子性、一致性和持久性状态的操作。</li></ul><h4 id="5-4-1-故障分类"><a href="#5-4-1-故障分类" class="headerlink" title="5.4.1 故障分类"></a>5.4.1 故障分类</h4><p>由于DBMS根据底层存储设备被划分为不同的组件，因此DBMS需要处理许多不同类型的故障。</p><ol><li><p>事务故障</p><p> 一个事务出现错误且必须中止，称其为事务故障。可能导致事务失败的两种错误是逻辑错误和内部状态错误。逻辑错误是指事务由于某些内部条件无法继续正常执行，如非法输入、找不到数据、溢出等；内部状态错误是指系统进入一种不良状态，使当前事务无法继续正常执行，如死锁。</p></li><li><p>系统故障</p><p> 系统故障是指导致系统停止运转、需要重新启动的事件。系统故障可能由软件或硬件的问题引起。软件问题是指由于DBMS的实现问题（如未捕获的除零异常）导致系统不得不停止；硬件问题是指DBMS所在的计算机出现崩溃，如系统突然掉电、CPU故障等。发生系统故障时，内存中的数据会丢失，但外存数据不受影响。</p></li><li><p>介质故障</p><p> 介质故障是指当物理存储损坏时发生的不可修复的故障，如磁盘损坏、磁头碰撞、强磁场干扰等。当存储介质失效时，DBMS必须通过备份版本进行恢复。</p></li></ol><h4 id="5-4-2-缓冲池管理策略"><a href="#5-4-2-缓冲池管理策略" class="headerlink" title="5.4.2 缓冲池管理策略"></a>5.4.2 缓冲池管理策略</h4><p>缓冲池管理策略是指，对于已提交和未提交的事务，它们在内存缓冲池中修改的数据页被写出到磁盘的时机。</p><p>对于已提交事务，存在两种策略：</p><ul><li>FORCE：事务提交时必须强制将其修改的数据页写盘；</li><li>NOFORCE：允许在事务提交后延迟执行写盘操作。</li></ul><p>对于未提交事务，也存在两种策略：</p><ul><li>STEAL：允许在事务提交前就将其修改的数据页写盘；</li><li>NOSTEAL：不允许在事务提交前执行写盘操作。</li></ul><p>对于恢复来说，FORCE+ NOSTEAL是最简单的策略，但是这种策略的一个缺点是要求内存能放下事务需要修改的所有数据，否则该事务将无法执行，因为DBMS不允许在事务提交之前将脏页写入磁盘。</p><p>从高效利用内存和降低磁盘I/O开销的角度出发，NOFORCE+ STEAL策略是最灵活的，这也是很多DBMS采用的策略。在这种策略下，一旦发生故障，恢复机制可能需要执行以下操作：</p><ul><li>UNDO：发生故障时，尚未完成的事务的结果可能已写入磁盘，为保证数据一致性，需要清除这些事务对数据库的修改。</li><li>REDO：发生故障时，已完成事务提交的结果可能尚未写回到磁盘，故障使得这些事务对数据库的修改丢失，这也会使数据库处于不一致状态，因此应将这些事务已提交的结果重新写入磁盘。</li></ul><p>为了保证在恢复时能够得到足够的信息进行UNDO和REDO，DBMS在事务正常执行期间需要登记事务对数据库所做的修改，这就是日志机制。</p><h4 id="5-4-3-日志"><a href="#5-4-3-日志" class="headerlink" title="5.4.3 日志"></a>5.4.3 日志</h4><h5 id="5-4-3-1-日志的原理"><a href="#5-4-3-1-日志的原理" class="headerlink" title="5.4.3.1 日志的原理"></a>5.4.3.1 日志的原理</h5><p>日志是由日志记录构成的文件，几乎所有DBMS都采用基于日志的恢复机制。它的基本思路是：DBMS在对磁盘页面进行修改之前，先将其对数据库所做的所有更改记录到磁盘上的日志文件中，日志文件包含足够的信息来执行必要的UNDO和REDO操作，以便在故障后恢复数据库。DBMS必须先将对数据库对象所做修改的日志记录写入日志文件，然后才能将该对象刷新到磁盘，这一过程称为WAL（Write Ahead Log）。WAL的执行过程如图6-3所示。事务开始后，所有对数据库的修改在发送到缓冲池之前都被记录在内存中的WAL缓冲区中。事务提交时，必须把WAL缓冲区刷新到磁盘。一旦WAL缓冲区被安全地写进磁盘，事务的修改结果就也可以写盘了。</p><p><img src="/posts/41900/6-3.png" alt="图6-3 WAL过程示意图"></p><p>日志文件中应该记录以下信息：</p><ul><li>l 事务开始时，向日志中写入一条该事务的开始记录。</li><li>l 事务结束时，向日志中写入一条该事务的结束记录，结束记录包括两类：正常结束记录，和异常结束记录。</li><li>事务对每个数据对象的修改操作对应一条日志记录，其中包含以下信息:<ul><li>事务ID</li><li>对象ID</li><li>修改前的值（用于UNDO）</li><li>修改后的值（用于REDO）</li></ul></li></ul><p>将日志记录从日志缓冲区写入磁盘的时机有这样几个：</p><ul><li>接收到提交事务的命令后，在返回提交成功的消息之前，DBMS必须将该事务的所有日志记录写入磁盘。系统可以使用”组提交”的方式来批处理多个事务的提交，以降低I/O开销。</li><li>日志缓冲区空间不足的时候，需要将缓冲区中的日子记录写入磁盘。</li><li>在将一个脏数据页写入磁盘之前，与更新该页有关的所有日志记录都必须先被写入磁盘。</li></ul><p>需要注意的是，登记日志时必须严格按事务的操作顺序记录，并且写到磁盘中的日志记录顺序必须与写入日志缓冲区的顺序完全一致。</p><h5 id="5-4-3-2-日志的类型"><a href="#5-4-3-2-日志的类型" class="headerlink" title="5.4.3.2 日志的类型"></a>5.4.3.2 日志的类型</h5><p>根据实现时采用的恢复方法的不同，日志中记录的内容也不一样，分为以下几类。</p><ol><li>物理日志：物理日志中记录的是事务对数据库中特定位置的字节级更改。例如，日志中记录的是事务对指定数据页中从指定位置开始的若干字节的修改。</li><li>逻辑日志：逻辑日志中记录的是事务执行的逻辑操作。例如，日志中记录的是事务执行的UPDATE、DELETE和INSERT语句。与物理日志相比，逻辑日志需要写的数据更少，因为每条日志记录可以在多个页面上更新多个元组。然而，当系统中存在并发事务时，通过逻辑日志实现恢复很困难。</li><li>混合日志：日志中记录的是事务对指定页面中指定槽号内元组的更改，而不是对页中指定偏移位置的更改。</li></ol><h4 id="5-4-4-恢复算法"><a href="#5-4-4-恢复算法" class="headerlink" title="5.4.4 恢复算法"></a>5.4.4 恢复算法</h4><h5 id="5-4-4-1-事务故障的恢复"><a href="#5-4-4-1-事务故障的恢复" class="headerlink" title="5.4.4.1 事务故障的恢复"></a>5.4.4.1 事务故障的恢复</h5><p>事务故障是指事务在运行至正常终止点前被终止，这时恢复子系统应利用日志文件UNDO此事务己对数据库进行的修改。事务故障的恢复应由DBMS自动完成，对用户完全透明。恢复步骤如下：</p><ol><li>反向扫描日志文件，查找该事务的更新日志记录。</li><li>对该事务的更新操作执行逆操作， 即将日志记录中 “更新前的值” 写入数据库。如果记录中是插入操作，则逆操作相当于做删除操作：若记录中是删除操作，则逆操作相当于做插入操作；若是修改操作，则逆操作相当于用修改前的值代替修改后的值。</li><li>继续反向扫描日志文件，查找该事务的其他更新日志记录并做相同处理，直至读到此事务的开始标记。</li></ol><h5 id="5-4-4-2-系统故障的恢复"><a href="#5-4-4-2-系统故障的恢复" class="headerlink" title="5.4.4.2 系统故障的恢复"></a>5.4.4.2 系统故障的恢复</h5><p>系统故障导致数据库处于不一致状态的原因，一方面是未提交事务对数据库的更新已经被写入数据库，另一方面则是已提交事务对数据库的更新没有被完全写入数据库。因此对于系统故障的恢复操作，就是要UNDO故障发生时未提交的事务，REDO已提交的事务。系统故障也是由DBMS在重启时自动完成，对用户完全透明。恢复步骤如下：</p><ol><li>正向扫描日志文件，通过事务开始记录和COMMIT记录找出在故障发生前已提交的事务集合和未提交的事务集合。已提交的事务既有开始记录也有COMMIT记录，未提交的事务则只有开始记录，没有相应的COMMIT记录。将已提交的事务加入重做队列（REDO-LIST），未提交的事务加入撤销队列（UNDO-LIST）。</li><li>反向扫描日志文件，对UNDO-LIST中的各个事务进行UNDO处理。</li><li>正向扫描日志文件，对REDO-LIST中的各个事务进行REDO处理。</li></ol><h5 id="5-4-4-3-介质故障的恢复"><a href="#5-4-4-3-介质故障的恢复" class="headerlink" title="5.4.4.3 介质故障的恢复"></a>5.4.4.3 介质故障的恢复</h5><p>发生介质故障后，磁盘上的物理数据和日志文件被破坏，这是最严重的一种故障，恢复方法是重装数据库，然后重做已完成的事务。介质故障的恢复需要用户人工介入，由DBA装入最新的数据库备份及日志文件备份，然后执行系统提供的恢复命令。</p><p>DBA装入相关备份文件后，系统执行的恢复过程与系统故障的恢复过程类似，也是通过扫描日志文件构造REDO-LIST和UNDO-LIST，然后对REDO-LIST和UNDO-LIST中的事务分别进行REDO和UNDO处理，这样就可以将数据库恢复到最近一次备份时的一致性状态。</p><h4 id="5-4-5-检查点"><a href="#5-4-5-检查点" class="headerlink" title="5.4.5 检查点"></a>5.4.5 检查点</h4><p>以上讨论的基于日志的恢复算法存在两个问题：1. 构造REDO-LIST和UNDO-LIST需要搜索整个日志文件，耗费大量的时间；2.处理REDO-LIST时，很多事务的修改实际上已经写入了磁盘，但是仍然不得不进行REDO处理，浪费大量时间。为了解决上述问题，提高恢复效率，很多DBMS都采用了检查点技术，通过周期性地对日志做检查点来避免故障恢复时检查整个日志。</p><p>检查点技术的基本思路是：在日志文件中增加一类记录——检查点记录，并增加一个文件——重新开始文件。恢复子系统周期性地执行以下操作：</p><ol><li>将日志缓冲区中的日志记录全部写入磁盘中的日志文件；</li><li>在日志文件中写入一个检查点记录；</li><li>将数据缓冲区中的数据写入磁盘；</li><li>将检查点记录在日志文件中的地址写入重新开始文件。</li></ol><p>其中，检查点记录中包含以下信息：</p><ul><li>检查点时刻，当前所有正在执行的事务清单</li><li>清单中每个事务最近一个日志记录的地址</li></ul><p><img src="/posts/41900/6-4.png" alt="图6-4 带检查点的日志文件和重新开始文件"></p><p>由检查点时刻系统执行的操作可知，如果一个事务在一个检查点之前已经提交了，那么它对数据库所做的修改一定都被写入了磁盘，因此在进行恢复处理时，就没有必要再对该事务执行REDO操作了。</p><p>增加了检查点之后，基于日志的恢复步骤如下：</p><ol><li>从重新开始文件中找到最后一个检查点记录在日志文件中的地址，根据该地址在日志文件中找到最后一个检查点记录。</li><li>由该检查点记录得到检查点时刻正在执行的事务清单ACTIVE-LIST。初始化两个事务队列UNDO-LIST和REDO-LIST，令UNDO-LIST = ACTIVE-LIST，令REDO队列为空。</li><li>从检查点开始正向扫描日志文件直到日志文件结束，如有新开始的事务，则将其放入UNDO-LIST，如有提交的事务，则将其从UNDO-LIST队列移到REDO-LIST队列。</li><li>对UNDO-LIST和REDO-LIST中的每个事务，分别执行UNDO和REDO操作。</li></ol><h2 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h2><h3 id="火山模型"><a href="#火山模型" class="headerlink" title="火山模型"></a>火山模型</h3><p>火山模型是数据库界已经很成熟的解释计算模型，该计算模型将关系代数中每一种操作抽象为一个 Operator，将整个 SQL 构建成一个 Operator 树，从根节点到叶子结点自上而下地递归调用 next() 函数。这里的一个造作也可以视作为一个算子。作为一个树节点，往往会存在父节点和子节点，当作为父节点时，他需要调用子节点的操作，而作为子节点则需要在被父节点调用的时候，提供数据返回给父节点。</p><p>这种设计的优点在于每一个节点（Operator），不需要关心自己的父节点和子节点是什么类型的算子和具体的实现，他只需要提供相应的接口和调用即可。树的结构是千变万化的，那么即使是有限的算子，也可以通过组成各种各样的树结构来支持复杂的查询计划。同时如果想要新增算子，也只需要实现该算子的相应接口，并加入到构建中即可，有着良好的可扩展性。</p><ul><li>一般Operator的next() 接口实现分为三步<br>  （1）调用子节点Operator的next() 接口获取一行数据(tuple)<br>  （2）对tuple进行Operator特定的处理(如filter 或project 等)<br>  （3）返回处理后的tuple。</li></ul><p>所以经常能在代码中看到这样的代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Operator<span class="token punctuation">.</span>Children<span class="token punctuation">.</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如 SQL：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> Id<span class="token punctuation">,</span> Name<span class="token punctuation">,</span> Age<span class="token punctuation">,</span> <span class="token punctuation">(</span>Age <span class="token operator">-</span> <span class="token number">30</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">50</span> <span class="token keyword">AS</span> Bonus<span class="token keyword">FROM</span> People<span class="token keyword">WHERE</span> Age <span class="token operator">></span> <span class="token number">30</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对应火山模型如下：</p><p><img src="/posts/41900/image-20231008164342333.png" alt></p><ul><li>User：客户端。负责获取用户的sql，也负责发送给客户端sql的执行结果。</li><li>Project：垂直分割（投影），选择字段。对应于sql为：“SELECT Id, Name, Age, (Age - 30) * 50 AS Bonus”，接收子节点数据后，通过处理，得到需要返回给上层的结果值。</li><li>Select（或 Filter）：水平分割（选择)，用于过滤行，也称为谓词。对应于sql为：“WHERE Age &gt; 30”，接收子节点数据后，过滤掉不符合条件的数据。</li><li>Scan：扫描数据。将数据从存储层拉到计算层。比如将People的表数据从磁盘拉到内存。对应sql为：“FROM People”</li></ul><blockquote><p>这里包含了 3 个 Operator，首先 User 调用最上方的 Operator（Project）希望得到 next tuple，Project 调用子节点（Select），而 Select 又调用子节点（Scan），Scan 获得表中的 tuple 返回给 Select，Select 会检查是否满足过滤条件，如果满足则返回给 Project，如果不满足则请求 Scan 获取 next tuple。Project 会对每一个 tuple 选择需要的字段或者计算新字段并返回新的 tuple 给 User。当 Scan 发现没有数据可以获取时，则返回一个结束标记告诉上游已结束。</p></blockquote><p>为了更好地理解一个 Operator 中发生了什么，下面通过伪代码来理解 Select Operator：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Tuple Select<span class="token operator">::</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Tuple candidate <span class="token operator">=</span> child<span class="token operator">-</span><span class="token operator">></span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 从子节点中获取 next tuple</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>candidate <span class="token operator">==</span> EndOfStream<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 是否得到结束标记</span>            <span class="token keyword">return</span> EndOfStream<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token operator">-</span><span class="token operator">></span><span class="token function">check</span><span class="token punctuation">(</span>candidate<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 是否满足过滤条件</span>            <span class="token keyword">return</span> candidate<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回 tuple</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考一个案例： select name from student where teacher = ‘Karim’<br><img src="/posts/41900/image-20231008161654927.png" alt></p><p>从上面的图和右边的代码可以简单的了解下火山模型的调用和实现的思路。</p><ul><li>Projection: 投影算子，用于获取数据中的具体需要的字段，在该案例中是Name字段。Next()中的实现会首先调用 Children的Next()方法，获取数据，并取出Name这一列返回。</li><li>Selection：过滤算子，用于将数据中 Teacher = ‘Karim’ 的记录过滤出来，返回给上一层。Next()中的实现同样是先调用Children的Next()方法来获取数据。</li><li>Scan：扫描算子，用于从存储节点中获取所有的数据，并返回到父节点。因为Scan一般都是叶子节点，不需要再继续要调用Children的Next()方法。</li></ul><p>通过这种设计思路，将每个算子封装成一个Operator来独自处理，配合树结构的执行策略，有着非常优秀的可扩展性，同时兄弟节点之间的操作可以并行处理，所以火山模型同样也有着一定的并行处理能力。</p><p>在上面代码中，可以关注一个细节，也就是Next方法中其实都是只处理一行数据的，这种方式在当时是为了对内存使用的优化，那个年代的内存资源是非常昂贵的，而相比CPU的执行效率，IO执行效率会更低，所以火山模型将内存资源更多的放在IO上，而不是CPU的执行优化上。</p><p>但是现在看来，这种处理方式也会有着些许缺点，每次一整个Next调用链只会处理一行数据，效率非常的低，而同时一行数据处理就得调用多次Next()方法，大量数据处理下，函数调用的开销也会非常的大</p><h4 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h4><p><strong>首先</strong>，考虑到大量虚函数的调用，那我能否写一个循环去执行 Operator 中的计算逻辑呢？执行完成后再向上传递，这样将之前的自上而下的拉模型改成了自下而上的推模型。</p><p><strong>其次</strong>，火山模型中一次只取一条数据，如果每次取多条数据呢？因为可以将每次 next 带来的 CPU 开销被一组数据给分摊。这样当 CPU 访问元组中的某个列时会将该元组加载到 CPU Cache（如果该元组大小小于 CPU Cache 缓存行的大小）, 访问后继的列将直接从 CPU Cache 中获取，从而具有较高的 CPU Cache 命中率，然而如果只访问一个列或者少数几个列时 CPU 命中率仍然不理想。即<strong>向量化/批处理模型（Vectorized / Batch Model）</strong>，<strong>向量化模型 和 火山模型 类似，每个 operator 需要实现一个 next() 函数，但是每次调用 next() 函数会返回一批的元组（tuples），而不是一个元组，所以向量化模型也可称为批处理模型。</strong> 目前很多数据库采取的都是这种处理模式。</p><p>在算子间传递数据不再是一条一条记录，而是一批数据，算子每次执行的时候都会在内部攒一批数据，数据大小尽可能和CPU cache对齐，不仅大大提高了cache命中率，而且有效了减少了函数调用次数。</p><p>另外，我们再想想什么时候可以做到取多条数据同时计算呢？当然是同一列的时候，所以针对的是<strong>列存</strong>的场景，因为输入是同列的一组数据，面对的是相同的操作，这正是向量寄存器干的事情，这是 CPU 层面计算性能的优化，因此称为向量化。并且如果每次只取一列的部分数据，返回一个可以放到 CPU Cache 的向量，那么又可以利用到 CPU Cache。</p><h4 id="火山模型中的查询并行实现"><a href="#火山模型中的查询并行实现" class="headerlink" title="火山模型中的查询并行实现"></a>火山模型中的查询并行实现</h4><p>关系查询处理引擎中实现并行查询主要包括以下两个方向：</p><ol><li><strong>算子间并行（inter-operator parallelism）</strong>：查询处理使用 operator 树执行，这些 operator 可以划分为多条 pipeline 在独立的进程或处理器上运行，称为算子间的并行。  </li><li><strong>算子内并行（intra-operator parallelism）</strong>：每个 operator 的 input 数据可以被划分为不相交的子集，从而同时执行相同的 operator，称为算子内部的并行。  </li></ol><p><strong>火山模型中负责实现并行执行的是 Exchange 运算符，它是一个有</strong> <strong><em>open, next, close</em></strong> <strong>方法的 iterator，可以被插到查询执行树中的任何一个或多个位置</strong>。<br><img src="/posts/41900/image-20231008161923746.png" alt></p><h4 id="算子间并行（inter-operator-parallelism）"><a href="#算子间并行（inter-operator-parallelism）" class="headerlink" title="算子间并行（inter-operator parallelism）"></a>算子间并行（inter-operator parallelism）</h4><p>Exchange 的 <em>open</em> 方法用于创建进程，Exchange 算子上方作为父进程，下方作为子进程，例如图5中的查询树执行 <em>open</em> 方法后，创建的进程将如图所示。</p><p><img src="/posts/41900/image-20231008162040948.png" alt></p><p>Exchange 采用<strong>生产者消费者模型，父进程会作为消费者，子进程会作为生产者</strong>，同时在共享内存中创建一个数据结构 <strong><em>port</em></strong> 用于同步和数据交换。例如 Scan 算子会作为生产者，上方的 Join 算子作为消费者。</p><p><strong>生产者端的 exchange 算子会作为 driver 驱动查询执行</strong>，其输出会放到 <strong><em>packet</em></strong> 里面。 <em>packet</em> 被填满后，会被放到 <strong><em>port</em></strong> 中，同时发送一个信号量来提醒消费者。</p><p><strong>消费者端的 exchange 算子就和普通的迭代器一样</strong>，只不过它接收输入时会通过进程间的通信而不是内部的方法调用。</p><p>注意，<strong>火山模型中所有其他模块都是基于 demand-driven</strong>，即 iterator 调用 Next() 方法后，数据流再从下游传到上游，控制流和数据流的方向相反。而 **Exchange 算子则是基于data-driven，生产者侧的数据就绪后再通知消费者执行，数据流和控制流的方向相同。可参见下图的 Pull 模型和 Push 模型的比较，容易理解。这主要有两方面的原因：</p><ol><li>Data-driven 的方式更容易实现算子内的并行，因为算子内并行需要对数据进行分区，然后基于不交叉的数据进行; </li><li>这种模式避免了多余的控制流来 Request data，进程间通信时这些不避免要的控制流会导致延迟。</li></ol><p><img src="/posts/41900/image-20231008162354074.png" alt></p><p>同时，<strong>data-driven 的模式下允许流量控制（flow control） 或者说反压（back pressure）</strong>。比如说，当生产者的生产速度大于消费者的消费速度时，会导致数据堆积，占用较大内存的问题。这时可以通过消费者端发送一个信号量，告诉生产者降低生产速度或停止生产，等消费者消费完后再进行，从而解决问题。即改用拉取模型和推送模型。</p><h4 id="算子内并行（intra-operator-parallelism）"><a href="#算子内并行（intra-operator-parallelism）" class="headerlink" title="算子内并行（intra-operator parallelism）"></a>算子内并行（intra-operator parallelism）</h4><p><strong>算子内的并行需要对输入数据进行分区，输入数据主要包括数据存储和中间结果。</strong></p><ul><li>数据存储的分区主要依赖物理分区，比如不同设备，不同文件。  </li><li>中间结果分区则主要依靠在 <em>port</em> 中使用不同的队列。生产者使用分区 support function 来决定放到哪个队列里。  </li></ul><p>图7中展示了为了实现算子内并行创建的进程，Join 算子有三个进程执行，Scan 算子由一个或两个进程执行。<strong>通过规定_并发_度（degree of parallelism）来确定执行的进程数。</strong>因为同时有三个进程在执行 Join 算子，因此必须对 Scan 得到的数据进行重分区，以交给不同的进程执行。</p><p><img src="/posts/41900/v2-47a15bb24240e083e5eaed813e5e7a61_720w.webp" alt></p><p>所有的 Scan 进程都可以传递数据给所有的 Join 进程，但是 <strong>Join 算子间的数据传递只允许在每个 Join 进程内部进行</strong>。此时，如果使用了基于分区的并行 Join 方法，且图7中两个 Join 是针对不同属性进行的，则会导致出现问题。因为第一个 Join 是用属性 1 做的分区，此时属性2 相同的 tuple 可能落在不同的 Join 进程中。这个问题可以使用 exchange 算子的变式来解决，称为 <strong><em>inter-change</em></strong>.</p><h4 id="Exchange-算子的变式"><a href="#Exchange-算子的变式" class="headerlink" title="Exchange 算子的变式"></a>Exchange 算子的变式</h4><p>目前，我们提到的 exchange 算子都只能在一个进程的顶部或底部出现（要么提供输入，要么进行输出）。除此之外，<strong>Exchange 还可以在一个进程的 operator tree 的中间出现，其功能只限于提供一个数据交换的窗口。其 next 方法从下游的算子中获取输入，并可能把它发送给同一个 Group 的其他进程（如果属于自己的分区就自己用）。</strong>这种操作模式称为 <em>inter-change</em>.</p><p>另外，还有能把输出广播给所有消费者的 exchange 算子， 比如 HashJoin 中广播小表构建的哈希表；根据 producer 把 input 分别存储的 exchange 算子，以便上游可以区分输入的来源。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://link.zhihu.com/?target=https%3A//paperhub.s3.amazonaws.com/dace52a42c07f7f8348b08dc2b186061.pdf">Volcano - An Extensible and Parallel Query Evaluation System</a><br><a href="https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1610.09166">Push vs. Pull-Based Loop Fusion in Query Engines</a><br><a href="https://link.zhihu.com/?target=https%3A//databricks.com/blog/2016/05/23/apache-spark-as-a-compiler-joining-a-billion-rows-per-second-on-a-laptop.html">Apache Spark as a Compiler: Joining a Billion Rows per Second on a Laptop</a><br><a href="https://zhuanlan.zhihu.com/p/72953129">为什么向量化计算(vectorization)会这么快？</a><br><a href="https://link.zhihu.com/?target=http%3A//mysql.taobao.org/monthly/2017/01/06/">PgSQL · 引擎介绍 · 向量化执行引擎简介</a><br><a href="https://link.zhihu.com/?target=https%3A//io-meter.com/2018/11/01/sql-query-optimization-volcano/">SQL 查询优化原理与 Volcano Optimizer 介绍</a><br><a href="https://link.zhihu.com/?target=https%3A//www.infoq.cn/article/an-article-mastering-sql-on-hadoop-core-technology">一篇文章掌握 Sql-On-Hadoop 核心技术</a><br><a href="https://www.zhihu.com/question/52220920/answer/340220500">知乎问答-马晓宇-PinCAP</a><br><a href="https://link.zhihu.com/?target=https%3A//zhewuzhou.github.io/2018/09/13/SQL_Compilation_Technology_For_Performance/">数据库性能之翼：SQL 语句运行时编译</a><br><a href="https://link.zhihu.com/?target=https%3A//chenyansong.site/2017/04/18/bigdata/spark%25E4%25BB%258E%25E5%2585%25A5%25E9%2597%25A8%25E5%2588%25B0%25E7%25B2%25BE%25E9%2580%259A_%25E7%25AC%2594%25E8%25AE%25B0/Spark2.0%25E6%2596%25B0%25E7%2589%25B9%25E6%2580%25A7%25E4%25B9%258BVolcano%2520Iterator%2520Model%28%25E7%2581%25AB%25E5%25B1%25B1%25E8%25BF%25AD%25E4%25BB%25A3%25E5%2599%25A8%25E6%25A8%25A1%25E5%259E%258B%29/">Spark2.0新特性之spark1.x的Volcano Iterator Model(火山迭代器模型)</a><br><a href="https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/fe7d5e2d66e7">向量化与编译执行浅析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一章-数据库的存储结构&quot;&gt;&lt;a href=&quot;#第一章-数据库的存储结构&quot; class=&quot;headerlink&quot; title=&quot;第一章 数据库的存储结构&quot;&gt;&lt;/a&gt;第一章 数据库的存储结构&lt;/h2&gt;&lt;h3 id=&quot;1-1文件组织结构&quot;&gt;&lt;a href=&quot;#1-1文
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://JoyTsing.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://JoyTsing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MiniOB答疑解惑</title>
    <link href="https://joytsing.github.io/posts/29042/"/>
    <id>https://joytsing.github.io/posts/29042/</id>
    <published>2024-04-25T08:33:36.000Z</published>
    <updated>2024-04-25T09:11:25.815Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>对比赛时miniob官方文档的学习，但由于后面miniob迭代过同时官方文档更新不及时，可能有与实际不匹配的地方，但根本原理上是不变的。</p><h2 id="MiniOB框架"><a href="#MiniOB框架" class="headerlink" title="MiniOB框架"></a>MiniOB框架</h2><p>为了参加oceanbase数据库的比赛，首先得先学习了解初赛使用的MiniOB，功能模块的设计比较简单，类似于一个toy一样的数据库，好处是可以比较方便的上手和练习。</p><p><img src="/posts/29042/image-20230926195652396.png" alt></p><p>存储引擎控制整个数据、记录是如何在文件和磁盘中存储，以及如何跟内部 SQL 模块之间进行交互。存储引擎中有三个关键模块：</p><ul><li>Record Manager：组织记录一行数据在文件中如何存放。</li><li>Buffer Pool：文件跟内存交互的关键组件。</li><li>B+Tree：索引结构。</li></ul><p>如图所示左边是客户端，右边是服务端。客户端发起命令，通过网络通讯和服务端的网络模块去通讯收发命令。服务端的网络模块收到 SQL 请求后，交给词法/语法解析模块（Parser 模块），经过词法解析和语法解析模块将 SQL 请求字符串转换成带有语法结构信息的内存数据结构（语法树），再转发给下一个 Plan Cache，Plan Cache 目前不做特殊处理，直接再转发给 Resolver 模块。</p><p>Resolver 模块会将判断模块解析出来的语法树，进一步细化后转换成真实的对象。比如查询一张表，会把表名转换成具体的表对象；如果是查询某个字段，会转换成对应的字段名；如果是 select *，会把 <code>*</code> 转换成对应表的各个字段。除此之外还会做一些预检，比如查询一张不存在的表，就会提前返回错误。</p><p>经过 Resolver 阶段，会把处理的结果给到 Transformer 和下一个优化阶段。这两个阶段在部分数据库中，就是优化模块，如 MySQL。虽然图中是两个模块，但不一定按照 Transformer 和 Optimizer 的流程顺序来执行，可能会多次的循环，在保证低成本下选择较优的查询方案。</p><p>Transformer 可以理解为根据一些规则去做转换，让后面的优化器能更好地优化。比如在查询表时，查询条件为 where 1=1，永远是真，那就会直接把这个条件删除。</p><p>经过这个规则转换后，交给优化模块。优化模块会根据一些条件找到更好的查询路径。比如查询数据，需要先判断直接使用索引查询，速度更快，还是通过全表遍历查询速度更快。因为有时部分因素或条件会导致索引查询更慢，所以优化模块会做一些判断，选择较好的查询计划，再转发给下一个执行模块。</p><p>执行模块（Executor）会按照查询计划去执行，访问索引、Buffer Pool、记录管理、以及底层的模块。然后把查询的结果返回给网络模块。网络模块再通过 Socket 返回给客户端。</p><p>总结一下，即：</p><ul><li>网络模块：负责与客户端交互，收发客户端请求与应答；</li><li>SQL解析：将用户输入的SQL语句解析成语法树；</li><li>执行计划缓存：执行计划缓存模块会将该 SQL第一次生成的执行计划缓存在内存中，后续的执行可以反复执行这个计划，避免了重复查询优化的过程（未实现）。</li><li>语义解析模块：将生成的语法树，转换成数据库内部数据结构（部分实现）；</li><li>查询缓存：将执行的查询结果缓存在内存中，下次查询时，可以直接返回（未实现）；</li><li>查询优化：根据一定规则和统计数据，调整/重写语法树。当前实现为空，留作实验题目；</li><li>计划执行：根据语法树描述，执行并生成结果；</li><li>会话管理：管理用户连接、调整某个连接的参数；</li><li>元数据管理：记录当前的数据库、表、字段和索引元数据信息；</li><li>客户端：作为测试工具，接收用户请求，向服务端发起请求。</li></ul><h3 id="各模块工作原理介绍"><a href="#各模块工作原理介绍" class="headerlink" title="各模块工作原理介绍"></a>各模块工作原理介绍</h3><h4 id="seda异步事件框架"><a href="#seda异步事件框架" class="headerlink" title="seda异步事件框架"></a>seda异步事件框架</h4><p>miniob使用了seda框架，在介绍其它模块之前有必要先了解一下seda。 SEDA全称是：stage event driver architecture，它旨在结合事件驱动和多线程模式两者的优点，从而做到易扩展，解耦合，高并发。 各个stage之间的通信由event来传递，event的处理由stage的线程池异步处理。线程池内部会维护一个事件队列。 在miniob中，从接收请求开始，到SQL解析、查询优化、计划执行都使用event来传递数据，并且可以通过seda来配置线程池的个数。</p><h4 id="服务端启动过程"><a href="#服务端启动过程" class="headerlink" title="服务端启动过程"></a>服务端启动过程</h4><p>虽然代码是模块化的，并且面向对象设计思想如此流行，但是很多同学还是喜欢从main函数看起。那么就先介绍一下服务端的启动流程。</p><p>main函数参考 <code>main@src/observer/main.cpp</code>。启动流程大致如下：</p><ul><li>解析命令行参数 <code>parse_parameter@src/observer/main.cpp</code></li><li>加载配置文件<code>Ini::load@deps/common/conf/ini.cpp</code></li><li>初始化日志<code>init_log@src/observer/init.cpp</code></li><li>初始化seda <code>init_seda@src/observer/init.cpp</code></li><li>初始化网络服务 <code>init_server@src/observer/main.cpp</code></li><li>启动网络服务 <code>Server::serve@src/net/server.cpp</code></li></ul><p>建议把精力更多的留在核心模块上，以更快的了解数据库的工作。</p><h4 id="网络模块"><a href="#网络模块" class="headerlink" title="网络模块"></a>网络模块</h4><p>网络模块代码参考<code>src/observer/net</code>，主要是Server类。 在这里，采用了libevent作为网络IO工具。libevent的工作原理可以参考libevent官方网站。 网络服务启动时，会监听端口，接受到新的连接，会将新的连接描述字加入到libevent中。在有网络事件到达时（一般期望是新的消息到达），libevent会调用我们注册的回调函数(参考<code>Server::recv@src/observer/net/server.cpp</code>)。当连接接收到新的消息时，我们会创建一个SessionEvent(参考seda中的事件概念），然后交由seda调度。</p><h4 id="SQL解析"><a href="#SQL解析" class="headerlink" title="SQL解析"></a>SQL解析</h4><p>SQL解析模块是接收到用户请求，开始正式处理的第一步。它将用户输入的数据转换成内部数据结构，一个语法树。 解析模块的代码在<code>src/observer/sql/parser</code>下，其中<code>lex_sql.l</code>是词法解析代码，<code>yacc_sql.y</code>是语法解析代码，<code>parse_defs.h</code>中包含了语法树中各个数据结构。 对于词法解析和语法解析，原理概念可以参考《编译原理》。 其中词法解析会把输入（这里比如用户输入的SQL语句）解析成成一个个的“词”，称为token。解析的规则由自己定义，比如关键字SELECT，或者使用正则表达式，比如<code>&quot;[A-Za-z_]+[A-Za-z0-9_]*&quot;</code> 表示一个合法的标识符。 对于语法分析，它根据词法分析的结果（一个个token），按照编写的规则，解析成“有意义”的“话”，并根据这些参数生成自己的内部数据结构。比如<code>SELECT * FROM T</code>，可以据此生成一个简单的查询语法树，并且知道查询的<code>columns</code>是”*”，查询的<code>relation</code>是”T”。 NOTE：在查询相关的地方，都是用关键字relation、attribute，而在元数据中，使用table、field与之对应。</p><h4 id="计划执行"><a href="#计划执行" class="headerlink" title="计划执行"></a>计划执行</h4><p>在miniob的实现中，SQL解析之后，就直接跳到了计划执行，中间略去了很多重要的阶段，但是不影响最终结果。 计划执行的代码在<code>src/observer/sql/executor/</code>下，主要参考<code>execute_stage.cpp</code>的实现。</p><h4 id="seda编程注意事项"><a href="#seda编程注意事项" class="headerlink" title="seda编程注意事项"></a>seda编程注意事项</h4><p>seda使用异步事件的方式，在线程池中调度。每个事件(event)，再每个阶段完成处理后，都必须调用done接口。比如</p><ul><li><code>event-&gt;done()</code>; // seda异步调用event的善后处理</li><li><code>event-&gt;done_immediate()</code>; // seda将直接在当前线程做event的删除处理</li><li><code>event-&gt;done_timeout()</code>; // 一般不使用</li></ul><p>当前Miniob为了方便和简化，都执行<code>event-&gt;done_immediate</code>。</p><p>在event完成之后，seda会调用event的回调函数。通过 <code>event-&gt;push_callback</code> 放置回调函数，在event完成后，会按照<code>push_callback</code>的反向顺序调用回调函数。 注意，如果执行某条命令后，长时间没有返回结果，通过pstack也无法找到执行那条命令的栈信息，就需要检查下，是否有event没有调用done操作。 当前的几种event流程介绍：</p><ul><li><code>recv@server.cpp</code>接收到用户请求时创建<code>SessionEvent</code>并交给<code>SessionStage</code></li><li><code>SessionStage</code>处理<code>SessionEvent</code>并创建<code>SQLStageEvent</code>，流转-&gt;</li><li><code>ParseStage</code> 处理 <code>SQLStageEvent</code> 流转到-&gt;</li><li><code>ResolveStage</code> 流转 <code>SQLStageEvent</code> -&gt;</li><li><code>QueryCacheStage</code> 流转 <code>SQLStageEvent</code> -&gt;</li><li><code>PlanCacheStage</code> 流转 <code>SQLStageEvent</code> -&gt;</li><li><code>OptimizeStage</code> 流转 <code>ExecutionPlanEvent</code> -&gt;</li><li><code>ExecuteStage</code> 处理 <code>ExecutionPlanEvent</code> 并创建 <code>StorageEvent</code>，流转到-&gt;</li><li><code>DefaultStorageStage</code> 处理 <code>StorageEvent</code></li></ul><h4 id="元数据管理模块"><a href="#元数据管理模块" class="headerlink" title="元数据管理模块"></a>元数据管理模块</h4><p>元数据是指数据库一些核心概念，包括db、table、field、index等，记录它们的信息。比如db，记录db文件所属目录；field，记录字段的类型、长度、偏移量等。代码文件分散于<code>src/observer/storage/table,field,index</code>中，文件名中包含<code>meta</code>关键字。</p><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>这里的客户端提供了一种测试miniob的方法。从标准输入接收用户输入，将请求发给服务端，并展示返回结果。这里简化了输入的处理，用户输入一行，就认为是一个命令。</p><h4 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h4><p>miniob采用TCP通信，纯文本模式，使用’\0’作为每个消息的终结符。 注意：测试程序也使用这种方法，_<strong>请不要修改协议，后台测试程序依赖这个协议</strong>_。 注意：返回的普通数据结果中不要包含’\0’，也不支持转义处理。</p><p>当前MiniOB已经支持了MySQL协议，具体请参考<a href="https://oceanbase.github.io/miniob/design/miniob-mysql-protocol.html">MiniOB 通讯协议简介</a>。</p><h3 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h3><p><a href="https://github.com/oceanbase/kernel-quickstart/blob/V1.0.0/zh-CN/1.database-system-overview/5.miniob-github-gitee-instructions.md">官方教程</a>提供了非常详细的流程，跟着设置好Gitee提测流程即可，这里官方额外提供了日常使用的git命令来方便使用，可以学习使用。</p><ul><li><p>查看当前分支</p><pre class="line-numbers language-shell"><code class="language-shell">git branch  # 查看本地分支git branch -a # 查看所有分支，包括远程分支<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>创建分支</p><pre class="line-numbers language-shell"><code class="language-shell">git checkout -b 'your branch name'git branch -d 'your branch name'  # 删除一个分支<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>切换分支</p><pre class="line-numbers language-shell"><code class="language-shell">git checkout 'branch name'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>提交代码</p><pre class="line-numbers language-shell"><code class="language-shell"># 添加想要提交的文件或文件夹git add 'the files or directories you want to commit'# 这一步也可以用 git add . 添加当前目录# 提交到本地仓库# -m 中是提交代码的消息，建议写有意义的信息，方便后面查找git commit -m 'commit message'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>推送代码到远程仓库</p><pre class="line-numbers language-shell"><code class="language-shell">git push# 可以将多次提交，一次性 push 到远程仓库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>合并代码</p><pre class="line-numbers language-shell"><code class="language-shell"># 假设当前处于分支 develop 下git merge feature/update# 会将 feature/update 分支的修改，merge 到 develop 分支<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>临时修改另一个分支的代码</p><pre class="line-numbers language-shell"><code class="language-shell"># 有时候，正在开发一个新功能时，突然来了一个紧急 BUG，这时候需要切换到另一个分  去开发# 这时可以先把当前的代码提交上去，然后切换分支。# 或者也可以这样：git stash # 将当前的修改保存起来git checkout main # 切换到主分支，或者修复 BUG 的分支git checkout -b fix/xxx  # 创建一个新分支，用于修复问题# 修改完成后，merge 到 main 分支# 然后，继续我们的功能开发git checkout feature/update # 假设我们最开始就是在这个分支上git stash pop# stash 还有很多好玩的功能，大家可以探索一下<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="构建官方MiniOB"><a href="#构建官方MiniOB" class="headerlink" title="构建官方MiniOB"></a>构建官方MiniOB</h4><ol><li><p>下载源码</p><pre class="line-numbers language-shell"><code class="language-shell">git clone https://github.com/oceanbase/miniob.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>环境初始化<br>如果是第一次在这个环境上编译 MiniOB，需要执行如下命令安装 MiniOB 的依赖库。</p></li></ol><pre class="line-numbers language-shell"><code class="language-shell">git clone https://github.com/oceanbase/miniob.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令执行后，脚本会自动拉取依赖库，并编译安装到系统目录。</p><ol start="3"><li>编译<br>执行如下命令将编译 debug 版本的 MiniOB。</li></ol><pre class="line-numbers language-shell"><code class="language-shell">bash build.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行如下命令将编译 release 版本的 MiniOB。</p><pre class="line-numbers language-shell"><code class="language-shell">bash build.sh release<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>详细使用方法可执行 <code>bash build.sh -h</code> 查看帮助信息。</p><h3 id="MiniOB运行"><a href="#MiniOB运行" class="headerlink" title="MiniOB运行"></a>MiniOB运行</h3><p>编译完成后，可在 build 目录（build_debug 或 build_release）下找到 <code>bin/observer</code> 目录，这是 MiniOB 的服务端进程，<code>bin/obclient</code> 是自带的客户端进程，当前服务端程序启动已经支持了多种模式，可以以 TCP、unix socket 方式启动，这时需要启动客户端以发起命令。observer 还支持直接执行命令的模式，这时不需要启动客户端，直接在命令行输入命令即可。observer 提供的参数可通过 <code>./bin/observer -h</code> 命令查看帮助。</p><h4 id="以直接执行命令启动服务端进程"><a href="#以直接执行命令启动服务端进程" class="headerlink" title="以直接执行命令启动服务端进程"></a>以直接执行命令启动服务端进程</h4><p>可执行如下命令以直接执行命令的方式启动服务端程序，这种情况下可以直接输入命令，不需要启动客户端，所有请求都会以单线程的方式运行，配置项中的线程数不再有实际意义。</p><pre class="line-numbers language-shell"><code class="language-shell">./bin/observer -f ../etc/observer.ini -P cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="以监听-TCP-端口方式启动"><a href="#以监听-TCP-端口方式启动" class="headerlink" title="以监听 TCP 端口方式启动"></a>以监听 TCP 端口方式启动</h4><p>可执行如下命令以监听端口的方式启动服务端程序，此处以 6789 端口为例。</p><pre class="line-numbers language-shell"><code class="language-shell">./bin/observer -f ../etc/observer.ini -p 6789<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这种情况下需执行如下命令启动客户端程序，启动后客户端会连接到服务端的 6789 端口。</p><pre class="line-numbers language-shell"><code class="language-shell">./bin/obclient -p 6789<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="以监听-unix-socket-方式启动"><a href="#以监听-unix-socket-方式启动" class="headerlink" title="以监听 unix socket 方式启动"></a>以监听 unix socket 方式启动</h4><p>可执行如下命令以监听 unix socket 的方式启动服务端程序。</p><pre class="line-numbers language-shell"><code class="language-shell">./bin/observer -f ../etc/observer.ini -s miniob.sock<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这种情况下需执行如下命令启动客户端程序，启动后客户端会连接到服务端的 miniob.sock 文件。</p><pre class="line-numbers language-shell"><code class="language-shell">./bin/obclient -s miniob.sock<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="并发模式"><a href="#并发模式" class="headerlink" title="并发模式"></a>并发模式</h4><p>默认情况下，编译后的程序不支持并发操作，如若需要支持并发，需要在编译时增加 <code>-DCONCURRENCY=ON</code> 选项，示例如下。</p><pre class="line-numbers language-shell"><code class="language-shell">cmake -DCONCURRENCY=ON ..<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或执行如下命令，在vscode中需要再<code>.vscode</code>中修改tasks.json，在<code>build_debug</code>或者其他阶段添加command如下：</p><pre class="line-numbers language-shell"><code class="language-shell">bash build.sh -DCONCURRENCY=ON<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后使用上述命令启动服务端进程，即可支持并发操作。</p><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><p><strong>问题现象</strong>：在启动服务端进程时出现报错找不到链接库 A。<br><strong>可能原因</strong>：安装依赖时，默认安装在 <code>/usr/local/</code> 目录下，而环境变量中没有将目录包含到动态链接库查找路径。<br><strong>解决方法</strong>：<br>您可将如下命令添加到 HOME 目录的 <code>.bashrc</code> 中，之后执行 <code>source ~/.bashrc</code> 命令加载环境变量后重新启动程序。</p><pre class="line-numbers language-shell"><code class="language-shell">export LD_LIBRARY_PATH=/usr/local/lib64:$LD_LIBRARY_PATH<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>LD_LIBRARY_PATH</code> 是 Linux 环境中运行时查找动态链接库的路径，路径之间以冒号（<code>:</code>）分隔。将数据写入 bashrc 或其它文件中，下次启动程序时会自动加载，而不需要再次执行 source 命令加载。</p><pre><code>**注意**：如果终端脚本使用的不是 bash，而是 zsh，那么就需要修改 `.zshrc`。</code></pre><h3 id="MiniOB调试"><a href="#MiniOB调试" class="headerlink" title="MiniOB调试"></a>MiniOB调试</h3><h4 id="MiniOB-的关键数据结构"><a href="#MiniOB-的关键数据结构" class="headerlink" title="MiniOB 的关键数据结构"></a>MiniOB 的关键数据结构</h4><pre class="line-numbers language-cpp"><code class="language-cpp">parse_def<span class="token punctuation">.</span>h<span class="token operator">:</span>    <span class="token keyword">struct</span> Selects<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//查询相关</span>    <span class="token keyword">struct</span> CreateTable<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//建表相关</span>    <span class="token keyword">struct</span> DropTable<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//删表相关</span>    <span class="token keyword">enum</span> SqlCommandFlag<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//SQL 语句对应的 command 枚举</span>    <span class="token keyword">union</span> Queries<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//各类 DML 和 DDL 操作的联合</span>table<span class="token punctuation">.</span>h    <span class="token keyword">class</span> <span class="token class-name">Table</span><span class="token punctuation">;</span>db<span class="token punctuation">.</span>h    <span class="token keyword">class</span> <span class="token class-name">Db</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="MiniOB-的关键接口"><a href="#MiniOB-的关键接口" class="headerlink" title="MiniOB 的关键接口"></a>MiniOB 的关键接口</h4><pre class="line-numbers language-cpp"><code class="language-cpp">RC <span class="token function">parse</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>st<span class="token punctuation">,</span> Query <span class="token operator">*</span>sqln<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//sql parse 入口</span>ExecuteStage<span class="token operator">::</span>handle_requestExecuteStage<span class="token operator">::</span>do_selectDefaultStorageStage<span class="token operator">::</span>handle_eventDefaultHandler<span class="token operator">::</span>create_indexDefaultHandler<span class="token operator">::</span>insert_recordDefaultHandler<span class="token operator">::</span>delete_recordDefaultHandler<span class="token operator">::</span>update_recordDb<span class="token operator">::</span>create_tableDb<span class="token operator">::</span>find_tableTable<span class="token operator">::</span>createTable<span class="token operator">::</span>scan_recordTable<span class="token operator">::</span>insert_recordTable<span class="token operator">::</span>update_recordTable<span class="token operator">::</span>delete_recordTable<span class="token operator">::</span>scan_recordTable<span class="token operator">::</span>create_index<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="打印日志调试"><a href="#打印日志调试" class="headerlink" title="打印日志调试"></a>打印日志调试</h4><p>MiniOB 提供的日志接口:</p><pre class="line-numbers language-cpp"><code class="language-cpp">deps<span class="token operator">/</span>common<span class="token operator">/</span>log<span class="token operator">/</span>log<span class="token punctuation">.</span>h<span class="token operator">:</span><span class="token macro property">#<span class="token directive keyword">define</span> LOG_PANIC(fmt, ...)</span><span class="token macro property">#<span class="token directive keyword">define</span> LOG_ERROR(fmt, ...)</span><span class="token macro property">#<span class="token directive keyword">define</span> LOG_WARN(fmt, ...)</span><span class="token macro property">#<span class="token directive keyword">define</span> LOG_INFO(fmt, ...)</span><span class="token macro property">#<span class="token directive keyword">define</span> LOG_DEBUG(fmt, ...)</span><span class="token macro property">#<span class="token directive keyword">define</span> LOG_TRACE(fmt, ...)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>日志相关配置项 observer.ini:</p><pre class="line-numbers language-cpp"><code class="language-cpp">LOG_FILE_NAME <span class="token operator">=</span> observer<span class="token punctuation">.</span>log<span class="token macro property">#  LOG_LEVEL_PANIC = 0,</span><span class="token macro property">#  LOG_LEVEL_ERR = 1,</span><span class="token macro property">#  LOG_LEVEL_WARN = 2,</span><span class="token macro property">#  LOG_LEVEL_INFO = 3,</span><span class="token macro property">#  LOG_LEVEL_DEBUG = 4,</span><span class="token macro property">#  LOG_LEVEL_TRACE = 5,</span><span class="token macro property">#  LOG_LEVEL_LAST</span>LOG_FILE_LEVEL<span class="token operator">=</span><span class="token number">5</span>LOG_CONSOLE_LEVEL<span class="token operator">=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>工具</strong></p><p>为了帮助定位与调试问题，写了一个简单的日志解析工具，可以在miniob编译后找到二进制文件clog_reader，使用方法如下：</p><p><code>clog_reader miniob/db/sys/</code></p><h4 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h4><ul><li><a href="https://github.com/tpn/pdfs/blob/master/ARIES%20-%20A%20Transaction%20Recovery%20Method%20Supporting%20Fine-Granularity%20Locking%20and%20Partial%20Rollbacks%20Using%20Write-Ahead%20Logging%20(1992).pdf">ARIES: A Transaction Recovery Method Supporting Fine-Granularity Locking and Partial Rollbacks Using Write-Ahead Logging</a> 该论文提出了ARIES算法，这是一种基于日志记录的恢复算法，支持细粒度锁和部分回滚，可以在数据库崩溃时恢复事务。如果想要对steal/no-force的概念有比较详细的了解，可以直接阅读该论文相关部分。</li><li><a href="https://www.geeksforgeeks.org/shadow-paging-dbms/">Shadow paging</a> 除了日志做恢复，Shadow paging 是另外一种做恢复的方法。</li><li><a href="http://www.pandis.net/resources/vldb10aether.pdf">Aether: A Scalable Approach to Logging</a> 介绍可扩展日志系统的。</li><li><a href="http://catkang.github.io/2020/02/27/mysql-redo.html">InnoDB之REDO LOG</a> 非常详细而且深入的介绍了一下InnoDB的redo日志。</li><li><a href="http://catkang.github.io/2022/10/05/btree-crash-recovery.html">B+树恢复</a> 介绍如何恢复B+树。</li><li><a href="https://15445.courses.cs.cmu.edu/spring2023/slides/19-logging.pdf">CMU 15445 Logging</a></li></ul><h3 id="MiniOB线程模型"><a href="#MiniOB线程模型" class="headerlink" title="MiniOB线程模型"></a>MiniOB线程模型</h3><h4 id="SEDA框架"><a href="#SEDA框架" class="headerlink" title="SEDA框架"></a>SEDA框架</h4><p>Resolver、优化器等处理阶段在 SEDA 中都是一个个的 Stage，各个 Stage 之间通过事件来传递数据。MiniOB 的多线程能力是基于 SEDA 来做的，SEDA 本身就是支持线程池的。</p><p>下图所示是一个简单的 SEDA 框架图，能够很好的帮助理解 MiniOB 中的每个 Stage 和 event，以及线程池之间的关系。线程池可以有多个，每个线程池可以包含多个 Stage，一个 Stage 会绑定到某一个线程池里面。每个线程池可以设置自己的线程的个数、事件队列的大小，线程池中的多个 Stage 之间是通过事件通讯的。虽然示例图中写的都是 StageEvent，但也可以是不同的名字。另外，不同的线程池之间的 Stage 也可以通过事件通讯，并且每一个线程池里面的 Stage 可以是不同的。<br><img src="/posts/29042/image-20230927195441330.png" alt><br>SEDA 框架有一个好处是可以将 Stage 进行分类，比如把处理 SQL 的分作一类，把 IO 处理的分作为一类，并把不同的分类分配到不同的线程池。这样在处理任务时不容易受到其他干扰，并且也能够根据真实的业务场景去调整每个线程池的大小。</p><p>接下来看一个简单的 Stage 模型。一个 Stage 对应一个类型的事件，事件是放在线程池事件队列中的。线程池事件指当事件队列有事件后，就将其交给对应的 Stage 来处理。</p><p><img src="/posts/29042/image-20230927200024512.png" alt></p><h4 id="事件的生命周期"><a href="#事件的生命周期" class="headerlink" title="事件的生命周期]"></a>事件的生命周期]</h4><p>创建 event 的时候，它就会被加到一个线程事件队列里面（参考 <code>net/server.cpp</code> 中 <code>session_stage_-&gt;add_event(sev);</code>）。添加到事件队列里面之后，就会由 Stage 调用 handle_event 去处理（参考 <code>session/session_stage.cpp</code> 中 <code>SessionStage::handle_event</code>）。处理完成之后，event 就结束了。<br><img src="/posts/29042/image-20230927200230325.png" alt></p><p>事件在处理的时候，还可以增加一些回调函数（比如 <code>session/session_stage.cpp</code> 中的 <code>sev-&gt;push_callback(cb);</code>），后续将事件交给其它的 Stage 做处理，处理完成后就会调用回调函数。也可以在回调函数中做一些任务处理，在代码里可以看到很多，比如 done_immediate 就是立即处理完成（比如 <code>parser/parse_stage.cpp</code> 中的 <code>event-&gt;done_immediate()</code>）。</p><h4 id="事件执行过程"><a href="#事件执行过程" class="headerlink" title="事件执行过程"></a>事件执行过程</h4><p>客户端通过网络发送一个请求到服务端，服务端在接收到消息后会创建一个消息包，并创建对应的 SessionEvent。然后调用 add_event 把 SessionEvent 添加到 SessionStage 里（参考 <code>net/server.cpp</code> 中 <code>session_stage_-&gt;add_event(sev);</code>），再放到对应的事件队列中。SessionStage 以及后续处理事件的几个 Stage，都在 SQLThreads 线程池中。</p><p>SessionStage 处理 SessionEvent 后，会创建一个 SQLStageEvent 传递给后面的 Stage。后续的 Stage 都是处理这个 SQLStageEvent 的事件。如下图所示，事件经过一个流转，处理完成后返回结果给客户端。</p><p><img src="/posts/29042/image-20230927200624124.png" alt></p><p><a href="https://github.com/oceanbase/kernel-quickstart/blob/V1.0.0/zh-CN/1.database-system-overview/7.miniob-thread-model.md#miniob-%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB">MiniOB 代码中的 SEDA 框架、线程池以及各个 Stage代码解读</a>，在配置文件 <code>etc/observer.ini</code> 中可以很清晰的看到 MiniOB 有哪些线程池（SQL、IO 和 Default）以及 Stage。每个 Stage 可以配置自己位于哪个线程池、关联的下一个 Stage 以及所属线程池，如果不配置，则使用默认的线程池。<br><img src="/posts/29042/image-20231012170513853.png" alt></p><h2 id="MiniOB存储实现"><a href="#MiniOB存储实现" class="headerlink" title="MiniOB存储实现"></a>MiniOB存储实现</h2><p>首先介绍 MiniOB 中文件是怎么存放，文件需要管理一些基础对象，如数据结构、表、索引。数据库在 MiniOB 这里体现就是一个文件夹，如下图所示，最上面就是一个目录，MiniOB 启动后会默认创建一个 sys 数据库，所有的操作都默认在 sys 中。</p><p><img src="/posts/29042/image-20231002190851802.png" alt></p><p>一个数据库下会有多张表。上图示例中只有三张表，接下来以 test1 表为例介绍一下表里都存放什么内容。</p><ul><li>test1.table：元数据文件，这里面存放了一些元数据。如：表名、数据的索引、字段类型、类型长度等。</li><li>test1.data：数据文件，真正记录存放的文件。</li><li>test1-i_name.index：索引文件，索引文件有很多个，这里只展示一个示例。</li></ul><h3 id="记录修改"><a href="#记录修改" class="headerlink" title="记录修改"></a>记录修改</h3><p>对于记录的修改，一般就存在三种，插入更新以及删除：</p><h4 id="数据插入"><a href="#数据插入" class="headerlink" title="数据插入"></a>数据插入</h4><p>数据插入在存储中的流程可以简单概括为以下几步：</p><ol><li>找到空闲块。</li><li>把记录插入块的空闲位置。</li><li>维护新插入记录的偏移。</li></ol><p>如下图所示，先从未使用的空间中找到可以插入的位置，写入记录后，再把记录相对于块的偏移写入到偏移表中进行维护。</p><p><img src="/posts/29042/image-20240425164831969.png" alt></p><h4 id="数据删除"><a href="#数据删除" class="headerlink" title="数据删除"></a>数据删除</h4><p>数据删除一般在数据库中的实现，并非把实际的数据内容马上从存储介质中擦除，而是在需要删除的记录中打上一个删除的标记，例如删除了记录 1，则把记录 1 前面的一个字节或一个 bit 标记为 delete，然后数据库系统再根据具体的场景（如 GC 流程），再统一回收这部分的空间。</p><p><img src="/posts/29042/image-20240425164848485.png" alt></p><h4 id="数据修改"><a href="#数据修改" class="headerlink" title="数据修改"></a>数据修改</h4><p>记录的修改主要有两种场景：</p><ul><li><p>定长记录的修改<br>定长记录的修改，因为记录定长，因此可以使用覆盖写的方式进行修改，把修改后的数据在原地址中覆盖写入。</p></li><li><p>变长记录的修改<br>变长记录的修改，因为修改后数据的长度可能会发生变更，所以不能使用覆盖写这种方式。而是会在块中重新查找空闲的位置，把修改的记录写入到新位置中，最后对原记录打上删除的标记，避免旧数据被访问。</p></li></ul><h3 id="MiniOB-Buffer-Pool"><a href="#MiniOB-Buffer-Pool" class="headerlink" title="MiniOB Buffer Pool"></a>MiniOB Buffer Pool</h3><p>Buffer Pool 在传统数据库里是非常重要的基础组件，数据库的数据是存放在磁盘里的，但不能直接从磁盘中读取数据，而是需要先把磁盘的数据读取到内存中，再在 CPU 做一些运算之后，展示给前端用户。写入也是一样的，一般都会先写入到内存，再把内存中的数据写入到磁盘。这种做法也是一个很常见的缓存机制。<br><img src="/posts/29042/image-20231002191355838.png" alt></p><p>接着来看 Buffer Pool 在 MiniOB 中是如何组织的。如上图所示，左边是内存，把内存拆分成不同的帧（frame）。假如内存中有四个 frame，对应了右边的多个文件，每个文件按照每页来划分，每个页的大小都是固定的，每个页读取时是以页为单位跟内存中的一个 frame 相对应。</p><p>Buffer Pool 在 MiniOB 里面组织的时候，一个 DiskBufferPool 对象对应一个物理文件。所有的 DiskBufferPool 都使用一个内存页帧管理组件 BPFrameManager，他是公用的。</p><p>再来看下读取文件时，怎么跟内存去做交互的。如上图所示，frame1 关联了磁盘中一个文件的页面，frame2 关联了另一个页面，frame3 是空闲页面，没有关联任何磁盘文件，frame4 也关联了一个页面。</p><p>比如现在要去读取 file3 的 Page3 页面，首先需要从 BPFrameManager 里面去找一个空闲的 frame，很明显，就是 frame3，然后再把 frame3 跟它关联起来，把 Page3 的数据读取到 frame3 里。现在内存中的所有 frame 都对应了物理页面。</p><p>如果再去读取一个页面，如 Page5，这时候已经找不到内存了，通常有两种情况：</p><ul><li>内存还有空闲空间，可以再申请一个 frame，跟 Page5 关联起来。</li><li>内存没有空闲空间，还要再去读 Page4，已经没有办法去申请新的内存了。此时就需要从现有的 frame 中淘汰一个页面，比如把 frame1 淘汰掉了，然后把 frame1 跟 Page4 关联起来，再把 Page4 的数据读取到 frame1 里面。淘汰机制也是有一些淘汰条件和算法的，可以先做简单的了解，暂时先不深入讨论细节。</li></ul><p><img src="/posts/29042/image-20231002191815577.png" alt></p><p>再来看一下，一个物理的文件上面都有哪些组织结构，如上图所示。</p><ul><li>文件上的第一页称为页头或文件头。文件头是一个特殊的页面，这个页面上会存放一个页号，这个页号肯定都是零号页，即 page num 是 0。</li><li>page count 表示当前的文件一共有多少个页面。</li><li>allocated pages 表示已经分配了多少个页面。如图所示标灰的是已经分配的三个页面。</li><li>Bitmap 表示每一个 bit 位当前对应的页面的分配状态，1 已分配页面，0 空闲页面。</li></ul><p>当前这一种组织结构是有一个缺陷的，整个文件能够支持的页面的个数受页面大小的限制，也就是说能够申请的页面的个数受页面大小的限制的。</p><p>接下来介绍一下普通页面（除 PageHeader 外），普通页面对 Buffer Pool 来说，第一个字段是用四字节的 int 来表示，就是 page num。接下来是数据，这个数据是由使用 Buffer Pool 的一些模块去控制。比如 Record Manage 或 B+Tree，他们会定义自己的结构，但第一个字段都是 page num，业务模块使用都是 page data 去做组织。</p><h3 id="MiniOB-记录管理"><a href="#MiniOB-记录管理" class="headerlink" title="MiniOB 记录管理"></a>MiniOB 记录管理</h3><p>记录管理模块（Record Manager）主要负责组织记录在磁盘上的存放，以及处理记录的新增与删除。需要尽可能高效的利用磁盘空间，尽量减少空洞，支持高效的查找和新增操作。</p><p>MiniOB 的 Record Manager 做了简化，有一些假设，记录通常都是比较短的，加上页表头，不会超出一个页面的大小。另外记录都是固定长度的，这个简化让学习 MiniOB 变得更简单一点。</p><p><img src="/posts/29042/image-20240425164933042.png" alt><br>上面的图片展示了 MiniOB 的 Record Manager 是怎么实现的，以及 Record 在文件中是如何组织的。</p><p>Record Manage 是在 Buffer Pool 的基础上实现的，比如 page0 是 Buffer Pool 里面使用的元数据，Record Manage 利用了其他的一些页面。每个页面有一个头信息 Page Header，一个 Bitmap，Bitmap 为 0 表示最近的记录是不是已经有有效数据；1 表示有有效数据。Page Header 中记录了当前页面一共有多少记录、最多可以容纳多少记录、每个记录的实际长度与对齐后的长度等信息。</p><h3 id="MiniOB-B-Tree实现"><a href="#MiniOB-B-Tree实现" class="headerlink" title="MiniOB B+Tree实现"></a>MiniOB B+Tree实现</h3><p>MiniOB中的B+Tree和其他B+Tree是一致的，查询和插入都是从根逐层定位到叶子节点，再从叶结点内获取或者插入。如果插入过程发生叶节点满则进行分裂并向上递归。<br><img src="/posts/29042/image-20231007163542212.png" alt></p><p>如上图，每个结点组织丞一个固定大小的page，其中page_num表示page在文件中的序号，每个结点page都有一个头，具体实现为IndexNode结构，其中当parent=-1时说明结点没有父节点为根节点。</p><p>除此之外，Leaf page还有左结点和右节点的page_num，用来最后遍历查询时使用，除此之外剩余的部分用来顺序存储键值对，叶节点所存放的key是索引列的值加上RID（该行数据在磁盘上的位置），value则是RID。也就是说键值数据存放在叶结点上，和B+Tree中叶结点的值是指向记录的指针不同，即类似Innode一样是类似聚集索引。</p><p><img src="/posts/29042/image-20231007164916038.png" alt></p><p>内部结点和叶结点相比，内部结点不存在左右结点的page num，其次是data中存放的value是page num，标识了子结点的page位置。键值对在内部结点的表示中，第一个键值对中的key是无效的，只有k1和k2用于比较。</p><p><img src="/posts/29042/image-20231007172134993.png" alt></p><p>所有的结点（即page）都存储在外存中的索引文件IndexFile中，其中文件的第一个page是索引文件头，存储了索引相关的元数据。</p><p>对于MiniOB来说，其B+树的实现进行了简化，具体可以看官方教程中的第三章。</p><h3 id="MiniOB-并发B-Tree实现"><a href="#MiniOB-并发B-Tree实现" class="headerlink" title="MiniOB 并发B+Tree实现"></a>MiniOB 并发B+Tree实现</h3><h4 id="Crabing-Protocol"><a href="#Crabing-Protocol" class="headerlink" title="Crabing Protocol"></a>Crabing Protocol</h4><p>在操作B+树时加对应的读写锁是一种最简单粗暴但是有效的方法，只是这样实现效率不高。于是就有一些研究创建了更高效的并发协议，并且会在协议设计上防止死锁的发生。</p><p>B+树是一个树状的结构，并且所有的数据都是在叶子节点上，每次操作，几乎都是从根节点开始向下遍历，直到找到对应的叶子节点。然后在叶子节点执行相关操作，如果对上层节点会产生影响，必须需要重新平衡，那就反方向回溯调整节点。 Crabing协议是从根节点开始加锁，找到对应的子节点，就加上子节点的锁。一直循环到叶子节点。在拿到某个子节点锁时，如果当前节点是“安全的”，那就可以释放上级节点的锁。</p><p><strong>什么是“安全的”</strong> 如果在操作某个节点时，可以确定这个节点上的动作，不会影响到它的父节点，那就说是“安全的”。 B+树上节点的操作有三个：插入、删除和查询。</p><ul><li>插入：一次仅插入一个数据。如果插入一个数据后，这个节点不需要分裂，就是当前节点元素个数再增加一个，也不会达到一个节点允许容纳的最大个数，那就是安全的。不会分裂就不会影响到父节点。</li><li>删除：一次仅删除一个数据。如果删除一个数据后，这个节点不需要与其它节点合并，就是当前节点元素个数删除一个后，也不会达到节点允许容纳的最小值，那就是安全的。不需要合并就不会影响到父节点。</li><li>查询：读取数据对节点来说永远是安全的。</li></ul><p>B+树的操作除了上述的插入、删除和查询，还有一个扫描操作。比如遍历所有的数据，通常是从根节点，找到最左边的叶子节点，然后从向右依次访问各个叶子节点。此时与加锁的顺序，与之前描述的几种方式是不同的，那为了防止死锁，就需要对遍历做特殊处理。一种简单的方法是，在访问某个叶子节点时，尝试对叶子节点加锁，如果判断需要等待，那就退出本次遍历扫描操作，重新来一遍。当然这种方法很低效，Concurrency of Operations on B-Trees可以了解更高效的扫描加锁方案。</p><h4 id="B-树与Buffer-Pool"><a href="#B-树与Buffer-Pool" class="headerlink" title="B+树与Buffer Pool"></a>B+树与Buffer Pool</h4><p>在MiniOB中，Buffer Pool的实现是 <code>class DiskBufferPool</code>。对Buffer Pool实现不太了解也没关系，这里接单介绍一下。</p><p><code>DiskBufferPool</code> 将一个磁盘文件按照页来划分(假设一页是8K，但是不一定)，每次从磁盘中读取文件或者将数据写入到文件，都是以页为单位的。在将文件某个页面加载到内存中时，需要申请一块内存。内存通常会比磁盘要小很多，就需要引入内存管理。在这里引入Frame（页帧）的概念(参考 <code>class Frame</code>)，每个Frame关联一个页面。<code>FrameManager</code>负责分配、释放Frame，并且在没有足够Frame的情况下，淘汰掉一些Frame，然后将这些Frame关联到新的磁盘页面。</p><p>那如何知道某个Frame关联的页面是否可以释放，然后可以与其它页面关联？ 如果这个Frame没有任何人使用，就可以重新关联到其它页面。这里使用的方法是引用计数，称为 <code>pin_count</code>。每次获取某个Frame时，<code>pin_count</code>就加1，操作完释放时，<code>pin_count</code>减1。如果<code>pin_count</code>是0，就可以将页面数据刷新到磁盘（如果需要的话），然后将Frame与磁盘文件的其它数据块关联起来。</p><p>为了支持并发操作，Frame引入了读写锁。操作B+树时，就需要加对应的读写锁。</p><p>B+ 树的数据保存在磁盘，其树节点，包括内部节点和叶子节点，都对应一个页面。当对某个节点操作时，需要申请相应的Frame，<code>pin_count</code>加1，然后加读锁/写锁。由于访问子节点时，父节点的锁可能可以释放，也可能不能释放，那么需要记录下某个某个操作在整个过程中，加了哪些锁，对哪些frame 做了pin操作，以便在合适的时机，能够释放掉所有相关的资源，防止资源泄露。这里引入<code>class LatchMemo</code> 记录当前访问过的页面，加过的锁。</p><blockquote><p>问题：为什么一定要先执行解锁，再执行unpin(frame引用计数减1)?<br>   如果子节点调用 <code>UnlockAncestors()</code> 来释放祖先节点上的锁，注意这里是先解锁再 <code>Unpin()</code>，如果先 <code>Unpin()</code> 可能导致在解锁之前页被换出，这时候解锁的是别人的页了：</p></blockquote><h4 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h4><p>B+树相关的操作一共有4个：插入、删除、查找和遍历/扫描。这里对每个操作的流程都做一个汇总说明，希望能帮助大家了解大致的流程。</p><p><strong>插入操作</strong> 除了查询和扫描操作需要加读锁，其它操作都是写锁。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token operator">-</span> leaf_node <span class="token operator">=</span> find_leaf <span class="token comment" spellcheck="true">// 查找叶子节点是所有操作的基本动作</span>    memo<span class="token punctuation">.</span>init <span class="token comment" spellcheck="true">// memo &lt;=> LatchMemo，记录加过的锁、访问过的页面</span>    lock root page  <span class="token operator">-</span> node <span class="token operator">=</span> <span class="token function">crabing_protocal_fetch_page</span><span class="token punctuation">(</span>root_page<span class="token punctuation">)</span>    loop<span class="token operator">:</span> <span class="token keyword">while</span> node is <span class="token operator">not</span> leaf <span class="token comment" spellcheck="true">// 循环查找，直到找到叶子节点</span>      child_page <span class="token operator">=</span> <span class="token function">get_child</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span>    <span class="token operator">-</span> node <span class="token operator">=</span> <span class="token function">crabing_protocal_fetch_page</span><span class="token punctuation">(</span>child_page<span class="token punctuation">)</span>        frame <span class="token operator">=</span> <span class="token function">get_page</span><span class="token punctuation">(</span>child_page<span class="token punctuation">,</span> memo<span class="token punctuation">)</span>        <span class="token function">lock_write</span><span class="token punctuation">(</span>memo<span class="token punctuation">,</span> frame<span class="token punctuation">)</span>        node <span class="token operator">=</span> <span class="token function">get_node</span><span class="token punctuation">(</span>frame<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 如果当前节点是安全的，就释放掉所有父节点和祖先节点的锁、pin_count</span>        <span class="token function">release_parent</span><span class="token punctuation">(</span>memo<span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token function">is_safe</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token operator">-</span> <span class="token function">insert_entry_into_leaf</span><span class="token punctuation">(</span>leaf_node<span class="token punctuation">)</span>  <span class="token operator">-</span> split <span class="token keyword">if</span> node<span class="token punctuation">.</span>size <span class="token operator">==</span> node<span class="token punctuation">.</span>max_size  <span class="token operator">-</span> loop<span class="token operator">:</span> insert_entry_into_parent <span class="token comment" spellcheck="true">// 如果执行过分裂，那么父节点也会受到影响</span><span class="token operator">-</span> memo<span class="token punctuation">.</span>release_all <span class="token comment" spellcheck="true">// LatchMemo 帮我们做资源释放</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>删除操作</strong> 与插入一样，需要对操作的节点加写锁。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token operator">-</span> leaf_node <span class="token operator">=</span> find_leaf <span class="token comment" spellcheck="true">// 查找的逻辑与插入中的相同</span><span class="token operator">-</span> leaf_node<span class="token punctuation">.</span>remove_entry<span class="token operator">-</span> node <span class="token operator">=</span> leaf_node<span class="token operator">-</span> loop<span class="token operator">:</span> <span class="token function">coalesce_or_redistribute</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token keyword">if</span> node<span class="token punctuation">.</span>size <span class="token operator">&lt;</span> node<span class="token punctuation">.</span>min_size <span class="token operator">and</span> node is <span class="token operator">not</span> root    neighbor_node <span class="token operator">=</span> <span class="token function">get_neighbor</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 两个节点间的数据重新分配一下</span>    <span class="token function">redistribute</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> neighbor_node<span class="token punctuation">)</span> <span class="token keyword">if</span> node<span class="token punctuation">.</span>size <span class="token operator">+</span> neighbor_node<span class="token punctuation">.</span>size <span class="token operator">></span> node<span class="token punctuation">.</span>max_size    <span class="token comment" spellcheck="true">// 合并两个节点</span>    <span class="token function">coalesce</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> neighbor_node<span class="token punctuation">)</span> <span class="token keyword">if</span> node<span class="token punctuation">.</span>size <span class="token operator">+</span> neighbor_node<span class="token punctuation">.</span>size <span class="token operator">&lt;=</span> node<span class="token punctuation">.</span>max_size  memo<span class="token punctuation">.</span>release_all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>查找操作</strong> 查找是只读的，所以只加读锁</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token operator">-</span> leaf_node <span class="token operator">=</span> find_leaf <span class="token comment" spellcheck="true">// 与插入的查找叶子节点逻辑相同。不过对所有节点的操作都是安全的</span><span class="token operator">-</span> <span class="token keyword">return</span> leaf_node<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span><span class="token operator">-</span> memo<span class="token punctuation">.</span>release_all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>扫描/遍历操作</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token operator">-</span> leaf_node <span class="token operator">=</span> find_left_node  loop<span class="token operator">:</span> node <span class="token operator">!=</span> <span class="token keyword">nullptr</span>      scan node      node_right <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>right <span class="token comment" spellcheck="true">// 遍历直接从最左边的叶子节点，一直遍历到最右边</span>      <span class="token keyword">return</span> LOCK_WAIT <span class="token keyword">if</span> node_right<span class="token punctuation">.</span>try_read_lock <span class="token comment" spellcheck="true">// 不直接加锁，而是尝试加锁，一旦失败就返回</span>      node <span class="token operator">=</span> node_right      memo<span class="token punctuation">.</span>release_last <span class="token comment" spellcheck="true">// 释放当前节点之前加到的锁</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="根节点处理"><a href="#根节点处理" class="headerlink" title="根节点处理"></a>根节点处理</h4><p>前面描述的几个操作，没有特殊考虑根节点。根节点与其它节点相比有一些特殊的地方：</p><ul><li>B+树有一个单独的数据记录根节点的页面ID，如果根节点发生变更，这个数据也要随着变更。这个数据不是被Frame的锁保护的；</li><li>根节点具有一定的特殊性，它是否“安全”，就是根节点是否需要变更，与普通节点的判断有些不同。</li></ul><p>按照上面的描述，我们在更新（插入/删除）执行时，除了对节点加锁，还需要对记录根节点的数据加锁，并且使用独特的判断是否“安全的”方法。</p><p>在MiniOB中，可以参考<code>LatchMemo</code>，是直接使用xlatch/slatch对Mutex来记录加过的锁，这里可以直接把根节点数据保护锁，告诉LatchMemo，让它来负责相关处理工作。 判断根节点是否安全，可以参考<code>IndexNodeHandler::is_safe</code>中<code>is_root_node</code>相关的判断。</p><h4 id="如何测试"><a href="#如何测试" class="headerlink" title="如何测试"></a>如何测试</h4><p>想要保证并发实现没有问题是在太困难了，虽然有一些工具来证明自己的逻辑模型没有问题，但是这些工具使用起来也很困难。这里使用了一个比较简单的方法，基于google benchmark框架，编写了一个多线程请求客户端。如果多个客户端在一段时间内，一直能够比较平稳的发起请求与收到应答，就认为B+树的并发没有问题。测试代码在<code>bplus_tree_concurrency_test.cpp</code>文件中，这里包含了多线程插入、删除、查询、扫描以及混合场景测试。</p><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><h5 id="有条件的开启并发"><a href="#有条件的开启并发" class="headerlink" title="有条件的开启并发"></a>有条件的开启并发</h5><p>MiniOB是一个用来学习的小型数据库，为了简化上手难度，只有使用-DCONCURRENCY=ON时，并发才能生效，可以参考 mutex.h中<code>class Mutex</code>和<code>class SharedMutex</code>的实现。当CONCURRENCY=OFF时，所有的加锁和解锁函数相当于什么都没做。</p><h5 id="并发中的调试"><a href="#并发中的调试" class="headerlink" title="并发中的调试"></a>并发中的调试</h5><p>死锁是让人非常头疼的事情，我们给Frame增加了调试日志，并且配合pin_count的动作，每次加锁、解锁以及pin/unpin都会打印相关日志，并在出现非预期的情况下，直接ABORT，以尽早的发现问题。这个调试能力需要在编译时使用条件 <code>-DDEBUG=ON</code> 才会生效。 以写锁为例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> Frame<span class="token operator">::</span><span class="token function">write_latch</span><span class="token punctuation">(</span>intptr_t xid<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token punctuation">{</span>    std<span class="token operator">::</span>scoped_lock <span class="token function">debug_lock</span><span class="token punctuation">(</span>debug_lock_<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 如果非DEBUG模式编译，什么都不会做</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>pin_count_<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">// 加锁时，pin_count必须大于0，可以想想为什么？</span>           <span class="token string">"frame lock. write lock failed while pin count is invalid. "</span>           <span class="token string">"this=%p, pin=%d, pageNum=%d, fd=%d, xid=%lx, lbt=%s"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 这里会打印各种相关的数据，帮助调试</span>           <span class="token keyword">this</span><span class="token punctuation">,</span> pin_count_<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> page_<span class="token punctuation">.</span>page_num<span class="token punctuation">,</span> file_desc_<span class="token punctuation">,</span> xid<span class="token punctuation">,</span> <span class="token function">lbt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// lbt会打印出调用栈信息</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>write_locker_ <span class="token operator">!=</span> xid<span class="token punctuation">,</span> <span class="token string">"frame lock write twice."</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>read_lockers_<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>xid<span class="token punctuation">)</span> <span class="token operator">==</span> read_lockers_<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>           <span class="token string">"frame lock write while holding the read lock."</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  lock_<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  write_locker_ <span class="token operator">=</span> xid<span class="token punctuation">;</span>  <span class="token function">LOG_DEBUG</span><span class="token punctuation">(</span><span class="token string">"frame write lock success."</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 加锁成功也打印一个日志。注意日志级别是DEBUG</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="MiniOB中的事务"><a href="#MiniOB中的事务" class="headerlink" title="MiniOB中的事务"></a>MiniOB中的事务</h2><p>事务是数据库中非常基础的一个模块，也是非常核心的功能。事务有一些基本的概念，叫做ACID，分别是原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)和持久性(Durability)。</p><h4 id="实现简介"><a href="#实现简介" class="headerlink" title="实现简介"></a>实现简介</h4><p>MiniOB 作为一个帮助学习数据库的代码，为了使其学习起来更简单，实现了两种类型的事务。一个叫做Vacuous，另一个叫做MVCC，可以在启动observer时，选择特定的事务模块。</p><p><strong>Vacuous（真空）</strong><br>顾名思义，这个事务模块，将不会做任何事务相关的处理，这保留了原始的简单性，有利于学习其它模块时，简化调试。</p><p><strong>MVCC</strong><br>多版本并发控制，是一种常见的事务实现。著名的MySQL数据库也支持MVCC，<a href="https://github.com/oceanbase/oceanbase">OceanBase</a>也实现了此机制。</p><p>简单来说，MVCC 会在修改 <em>数据MiniOB当前支持插入和删除</em> 时，不会直接在现有的数据上修改，而是创建一个新的行记录，将旧数据复制出来，在新数据上做修改。并将新旧数据使用链表的方式串联起来。每个数据都会有自己的版本号（或者称为时间戳），而版本号通常使用单调递增的数字表示，每个事务根据自己的版本号与数据的版本号，来判断当前能够访问哪个版本的数据。由此可见，MVCC 一个优点就是可以提高只读事务的并发度，它不与其它的写事务产生冲突，因为它访问旧版本的数据就可以了。</p><h4 id="如何运行与测试"><a href="#如何运行与测试" class="headerlink" title="如何运行与测试"></a>如何运行与测试</h4><p>当前MiniOB支持两种类型的事务模型，并且默认情况下是Vacuous，即不开启事务特性。<br><strong>测试MVCC</strong></p><p>编译时增加选项 <code>-DCONCURRENCY=ON</code>:</p><p>然后在build目录执行 make。编译完成后启动 observer 服务端进程。</p><blockquote><p>也可以使用 bash build.sh -DCONCURRENCY=ON 来编译</p></blockquote><p>可以在启动observer时，增加 <code>-t mvcc</code> 选项来开启MVCC，假设当前目录是build(或build_debug之类)：</p><p><code>./bin/observer -f ../etc/observer.ini -s miniob.sock -t mvcc</code></p><blockquote><p>-f 是配置文件，-s 指使用unix socket，-t 指定使用的事务模型, 启动observer后，可以使用obclient连接observer：</p></blockquote><p><code>./bin/obclient -s miniob.sock</code></p><p>可以开启多个客户端。在命令行界面执行 <code>begin</code> 可以开启事务，执行 <code>commit</code> 提交事务，<code>rollback</code> 回滚事务。</p><h4 id="更多的实现原理"><a href="#更多的实现原理" class="headerlink" title="更多的实现原理"></a>更多的实现原理</h4><p>事务代码位于 <code>src/observer/storage/trx</code> 目录下，代码很少。</p><h4 id="事务模型选择"><a href="#事务模型选择" class="headerlink" title="事务模型选择"></a>事务模型选择</h4><p>trx.h 文件中有一个抽象类 <code>TrxKit</code>，它可以根据运行时参数传入的名字来创建对应的 <code>VacuousTrxKit</code> 和 <code>MvccTrxKit</code>。这两个类可以创建相应的事务对象，并且按照需要，初始化行数据中事务需要的额外表字段。当前 Vacuous 什么字段都不需要，而MVCC会额外使用一些表字段。</p><h4 id="事务接口"><a href="#事务接口" class="headerlink" title="事务接口"></a>事务接口</h4><p>不同的事务模型，使用了一些统一的接口，这些接口定义在 <code>Trx</code> 中。</p><p><strong>事务本身相关的操作</strong></p><ul><li>start_if_need。开启一个事务。在SQL请求处理过程中，通常需要开启一个事务；</li><li>commit。提交一个事务；</li><li>rollback。回滚一个事务。</li></ul><p><strong>行数据相关的操作</strong></p><ul><li>insert_record。插入一行数据。事务可能需要对记录做一些修改，然后调用table的插入记录接口。提交之前插入的记录通常对其它事务不可见；</li><li>delete_record。删除一行数据。与插入记录类似，也会对记录做一些修改，对MVCC来说，并不是真正的将其删除，而是让他对其它事务不可见（提交后）；</li><li>visit_record。访问一行数据。当遍历记录，访问某条数据时，需要由事务来判断一下，这条数据是否对当前事务可见，或者事务有访问冲突。</li></ul><h3 id="MVCC-相关实现"><a href="#MVCC-相关实现" class="headerlink" title="MVCC 相关实现"></a>MVCC 相关实现</h3><p><strong>版本号与可见性</strong></p><p>与常见的MVCC实现方案相似，这里也使用单调递增的数字来作为版本号。并且在表上增加两个额外的字段来表示这条记录有效的版本范围。两个版本字段是<code>begin_xid</code>和<code>end_xid</code>。每个事务在开始时，就会生成一个自己的版本号，当访问某条记录时，判断自己的版本号是否在该条记录的版本号的范围内，如果在，就是可见的，否则就不可见。</p><blockquote><p>有些文章或者某些数据库实现中，使用”时间戳”来表示版本号。如果可以保证时间戳也是单调递增的，那这个时间戳确实更好可以作为版本号，并且在分布式系统中，比单纯的单调递增数字更好用。</p></blockquote><p><strong>记录版本号与事务版本号</strong></p><p>行数据上的版本号，是事务设置的，这个版本号也是事务的版本号。一个写事务，通常会有两个版本号，在启动时，会生成一个版本号，用来在运行时做数据的可见性判断。在提交时，会再生成一个版本号，这个版本号是最终设置在记录上的。</p><pre class="line-numbers language-cpp"><code class="language-cpp">trx start<span class="token operator">:</span>  trx_id <span class="token operator">=</span> <span class="token function">next_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  read record<span class="token operator">:</span> <span class="token function">is_visible</span><span class="token punctuation">(</span>trx_id<span class="token punctuation">,</span> record_begin_xid<span class="token punctuation">,</span> record_end_xid<span class="token punctuation">)</span>trx commit<span class="token operator">:</span>  commit_id <span class="token operator">=</span> <span class="token function">next_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  foreach updated record<span class="token operator">:</span> update record begin<span class="token operator">/</span>end xid with commit_id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>Q:为什么一定要在提交时生成一个新的版本号？只用该事务之前的版本号不行吗？会有什么问题？</p></blockquote><p><strong>版本号与插入删除</strong></p><p>新插入的记录，在提交后，它的版本号是 <code>begin_xid</code> = 事务提交版本号，<code>end_xid</code> = 无穷大。表示此数据从当前事务开始生效，对此后所有的新事务都可见。 而删除相反，<code>begin_xid</code> 保持不变，而 <code>end_xid</code> 变成了当前事务提交的版本号。表示这条数据对当前事务之后的新事务，就不可见了。 记录还有一个中间状态，就是事务刚插入或者删除，但是还没有提交时，这里的修改对其它事务应该都是不可见的。</p><p>比如新插入一条数据，只有当前事务可见，而新删除的数据，只有当前事务不可见。需要使用一种特殊的方法来标记，当然也是在版本号上做动作。对插入的数据，<code>begin_xid</code> 改为 (-当前事务版本号)(负数)，删除记录将<code>end_xid</code>改为 (-当前事务版本号)。在做可见性判断时，对负版本号做特殊处理即可。</p><p>假设某个事务运行时trx id是 Ta，提交时是 Tc</p><table><thead><tr><th>operation</th><th>trx state</th><th>begin xid</th><th>end xid</th></tr></thead><tbody><tr><td>inserted</td><td>committed</td><td>Tc</td><td>+∞</td></tr><tr><td>deleted</td><td>committed</td><td>some trx_id</td><td>Tc</td></tr><tr><td>insert</td><td>uncommit</td><td>-Ta</td><td>+∞</td></tr><tr><td>delete</td><td>uncommit</td><td>some trx_id</td><td>-Ta</td></tr></tbody></table><p><strong>并发冲突处理</strong></p><p>MVCC很好的处理了只读事务与写事务的并发，只读事务可以在其它事务修改了某个记录后，访问它的旧版本。但是写事务与写事务之间，依然是有冲突的。这里解决的方法简单粗暴，就是当一个写事务想要修改某个记录时，如果看到有另一个事务也在修改，就直接回滚。如何判断其它事务在修改？判断<code>begin_xid</code>或<code>end_xid</code>是否为负数就可以。</p><p><strong>隔离级别</strong></p><p>我们通常在聊事务隔离级别时，都会说脏读(Read Uncommitted)、读提交(Read Committed)、可重复读(Repeatable Read)和可串行化(Serializable)，说这些时也通常都会提到大名鼎鼎的MySQL。但实际上隔离级别不止是这4种。 不过这里也没有对隔离级别做特殊的处理，让它顺其自然。</p><blockquote><p>Q: 通过上面的描述，你知道这里的MVCC是什么隔离级别吗？</p></blockquote><h3 id="遗留问题和扩展"><a href="#遗留问题和扩展" class="headerlink" title="遗留问题和扩展"></a>遗留问题和扩展</h3><p>当前的MVCC是一个简化版本，还有一些功能没有实现，并且还有一些已知BUG。同时还可以扩展更多的事务模型。</p><ul><li><p><strong>事务提交时，对外原子可见</strong></p><p>当前事务在提交时，会逐个修改之前修改过的行数据，调整版本号。这造成的问题是，在某个时刻，有些行数据的版本号已经修改了，有些还没有。那可能会存在一个事务，能够看到已经修改完成版本号的行，但是看不到未修改的行。 比如事务A，插入了3条数据，在提交的时候，逐个修改版本号，某个情况下可能会存在下面的场景(假设A的事务ID是90，commit id是100)：</p></li></ul><table><thead><tr><th>record</th><th>begin xid</th><th>end xid</th><th>data</th></tr></thead><tbody><tr><td>R1</td><td>100</td><td>+∞</td><td>…</td></tr><tr><td>R2</td><td>100</td><td>+∞</td><td>…</td></tr><tr><td>R3</td><td>-90</td><td>+∞</td><td>…</td></tr></tbody></table><p>此时有一个新的事务，假设事务号是 110，那么它可以看到记录R1和R2，但是看不到R3，因为R3从记录状态来看，还没有提交。</p><ul><li><p><strong>垃圾回收</strong></p><p>随着数据库进程的运行，不断有事务更新数据，不断产生新版本的数据，会占用越来越多的资源。此时需要一种机制，来回收对任何事务都不再可见的数据，这称为垃圾回收。垃圾回收也是一个很有趣的话题，实现方式有很多种。最常见的是，开启一个或多个后台线程，定期的扫描所有的行数据，检查它们的版本。如果某个数据对当前所有活跃事务都不可见，那就认为此条数据是垃圾，可以回收掉。当然，这种回收方法最简单，也是最低效的，同学们如何优化或者实现新的回收方法。</p></li><li><p><strong>多版本存储</strong></p><p>当前miniob仅实现了插入和删除，并不支持更新操作。而插入和删除最多会存在两个版本的数据，从实现上来看，最多需要一条数据就可以。这大大简化了MVCC的实现。但是也因此没有涉及到MVCC非常核心的多版本数据存储问题。如何合理的存储多个版本的数据，对数据库的性能影响也是巨大的。比如多个版本数据串联时，使用从新到旧，还是从旧到新。两种方式都有合理性，适用于不同的场景。另外还有，多版本的数据存储在哪里？内存还是磁盘，是与原有的数据放在同一个存储空间，还是规划单独的空间，各有什么优缺点，都适用于什么场景。还有，更新数据时，复制整行数据，还是仅记录更新的字段。各有什么优缺点，各适用于什么场景。</p></li><li><p><strong>持久化事务</strong></p><p>持久性是事务的基本要素之一，是指事务修改后的数据，在数据库重启或者出现异常时，能够从磁盘中将数据恢复出来。除了将修改的数据直接写入到磁盘，还有一个常用的技术手段是WAL，比如Redo日志和Undo日志。那么什么情况下使用Redo，什么时候使用Undo，以及如果只使用Redo或者只使用Undo会有什么问题。另外还有如何存储这些日志，B+树的持久化怎么处理等。有兴趣的同学可以再了解一下 <code>Steal/No-Steal</code> 和 <code>Force/No-Force</code> 的概念。</p></li><li><p><strong>MVCC的并发控制</strong></p><p>如前文描述，这里的写事务并发冲突处理过于简单粗暴，以至于可以避免的冲突却没有避免。</p></li><li><p><strong>基于锁的并发控制</strong></p><p>MVCC的并发控制通常认为是乐观事务，就是我们认为此系统中事务之间大部分情况下不会存在冲突。但是在OLTP系统中，访问冲突可能是非常频繁发生的，这时候使用悲观事务，效率会更高一点。常见的悲观事务实现方法就是基于锁来实现。假设使用记录锁(行锁)来实现并发，在读数据时加读锁，写时加写锁，也可以实现多种级别的隔离机制。另外，还可以将使用基于锁的机制与MVCC结合起来，实现更好的并发控制。</p><p>顺便提一下一个常见的问题，就是在使用行锁时，如何与页面锁(latch)协调？ 大家都知道，latch 都是短锁，在latch保护范围内，都不应该出现长期等待的事情。另外，latch没有死锁检测，不处理锁冲突。而行锁是一种长锁，需要做锁冲突处理，可能需要等待。那在拿着某个latch时，需要等待行锁时，如何处理？</p></li></ul><h3 id="补充学习"><a href="#补充学习" class="headerlink" title="补充学习"></a>补充学习</h3><p>事务是非常复杂非常有趣的，相关的话题也已经有非常多的研究。如果对事务感兴趣，可以在了解数据库整体实现基础之上，深入研究事务的实现原理。 这里推荐一些介绍数据库入门的书籍：</p><ul><li>《数据库系统概念》该书是数据库领域的经典教材之一，涵盖了数据库基本概念、关系型数据库设计、事务处理、并发控制等方面的内容，也可以着重阅读事务相关的内容</li><li>《数据库系统实现》：该书是一本数据库系统实现方面的教材，讲解了数据库系统的核心组成部分，包括事务处理、索引、查询优化等方面的内容，对事务处理机制进行了较为细致的讲解</li><li>《MySQL技术内幕：InnoDB存储引擎》：该书是一本MySQL数据库方面的重要教材，对InnoDB存储引擎的事务处理机制进行了详细的阐述，包括事务的隔离级别、MVCC实现、锁机制等方面。</li><li><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf">A Critique of ANSI SQL Isolation Levels</a> 该论文针对ANSI SQL标准中隔离级别的定义进行了深入的分析，提出了一些改进的建议。天天看到RC/RR名词的，可以看看这篇论文，了解更详细一点。</li><li><a href="https://web.stanford.edu/class/cs245/readings/granularity-of-locks.pdf">Granularity of Locks and Degrees of Consistency in a Shared Data Base</a> 这也是一个又老又香的论文，提出了基于锁的并发控制。</li><li><a href="https://www.vldb.org/pvldb/vol10/p781-Wu.pdf">An Empirical Evaluation of InMemory Multi-Version Concurrency Control</a> 介绍MVCC可扩展性的。通过这篇论文可以对MVCC有非常清晰的认识。</li><li><a href="http://www.vldb.org/pvldb/vol13/p128-bottcher.pdf">Scalable Garbage Collection for In-Memory MVCC Systems</a> 这里对各种垃圾回收算法做了说明，并且有些创新算法。</li></ul><h2 id="MiniOB中的-SQL-Parser"><a href="#MiniOB中的-SQL-Parser" class="headerlink" title="MiniOB中的 SQL Parser"></a>MiniOB中的 SQL Parser</h2><p>SQL 解析分为词法分析与语法分析，与编译原理中介绍的类似。这里主要介绍如何扩展MiniOB的SQL解析器，并对词法分析和语法分析文件做一些简单的介绍。</p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><blockquote><p>词法分析文件 lex_sql.l</p></blockquote><p>词法分析的基本功能是读取文件或字符串的一个一个字符，然后按照特定的模式(pattern)去判断是否匹配，然后输出一个个的token。比如对于 <code>CALC 1+2</code>，词法分析器会输出 <code>CALC</code>、<code>1</code>、<code>+</code>、<code>2</code>、<code>EOF</code>。</p><p>扩展功能时，我们最关心的是词法分析的模式如何编写以及flex如何去执行模式解析的。 在lex_sql.l文件中，我们可以看到这样的代码：</p><pre><code>[\-]?{DIGIT}+  yylval-&gt;number=atoi(yytext); RETURN_TOKEN(NUMBER);HELP           RETURN_TOKEN(HELP);DESC           RETURN_TOKEN(DESC);CREATE         RETURN_TOKEN(CREATE);DROP           RETURN_TOKEN(DROP);</code></pre><p>每一行都是一个模式，左边是模式，使用正则表达式编写，右边是我们返回的token，这里的token是枚举类型，是我们在yacc_sql.y中定义的。</p><p><code>[\-]?{DIGIT}+</code> 就是一个表示数字的正则表达式。 <code>HELP</code> 表示完全匹配”HELP” 字符串。</p><p>flex 在匹配这些模式时有一些规则，如果输出的结果与自己的预期不符，可以使用这些规则检查一下，是否自己写的模式和模式中的顺序是否符合这些规则：</p><ul><li>优先匹配最长的模式</li><li>如果有多个模式匹配到同样长的字符串，那么优先匹配在文件中靠前的模式</li></ul><p>另外还有一些词法分析的知识点，都在lex_sql.l中加了注释，不多做赘述，在这里罗列提示一下。</p><ul><li>flex 根据编写的 .l 规则文件，和指定的命令生成.c代码。不过miniob把.c文件改成了.cpp后缀；</li><li><code>%top{}</code> 的代码会放在flex生成的代码最开头的地方；</li><li><code>%{ %}</code> 中的代码会被移动到flex生成的代码中；</li><li>flex提供了一些选项，可以在命令行中指定，也可以在.l文件中，使用 %option指定；</li><li>flex 中编写模式时，有一些变量是预定义的，yylval就是返回值，可以认为是yacc中使用%union定义的结构; yytext 是解析的当前token的字符串，yyleng 是token的长度，yycolumn 是当前的列号，yylineno 是当前行号；</li><li>如果需要每个token在原始文本中的位置，可以使用宏定义 YY_USER_ACTION，但是需要自己编写代码记录才能传递给yacc；</li><li><code>%% %%</code>之间的代码是模式匹配代码，之后的代码会被复制到生成代码的最后。</li></ul><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><blockquote><p>语法分析文件 yacc_sql.y</p></blockquote><p>语法分析的基本功能是根据词法分析的结果，按照语法规则，生成语法树。</p><p>与词法分析类似，语法分析工具(这里使用的是bison)也会根据我们编写的.y规则文件，生成.c代码，miniob 这里把.c代码改成了.cpp代码，因此.y文件中可以使用c++的语法和标准库。</p><p>类似词法分析，我们在扩展语法分析时，最关心的也只有规则编写的部分。</p><p>在yacc_sql.y文件中，我们可以看到这样的代码：</p><pre class="line-numbers language-c"><code class="language-c">expression_list<span class="token punctuation">:</span>    expression    <span class="token punctuation">{</span>      $$ <span class="token operator">=</span> new std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>Expression<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">;</span>      $$<span class="token operator">-></span><span class="token function">emplace_back</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">|</span> expression COMMA expression_list <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>$<span class="token number">3</span> <span class="token operator">!=</span> nullptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        $$ <span class="token operator">=</span> $<span class="token number">3</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        $$ <span class="token operator">=</span> new std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>Expression <span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      $$<span class="token operator">-></span><span class="token function">emplace_back</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个规则描述表达式列表的语法，表达式列表可以是单个表示，或者”单个表达式 逗号 表达式列表”的形式，第二个规则是一个递归的定义。 可以看到，多个规则模式描述使用 “|” 分开。</p><p>为了方便说明，这里再换一个语句：</p><pre class="line-numbers language-c"><code class="language-c">create_table_stmt<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">/*create table 语句的语法解析树*/</span>    CREATE TABLE ID LBRACE attr_def attr_def_list RBRACE    <span class="token punctuation">{</span>      $$ <span class="token operator">=</span> new <span class="token function">ParsedSqlNode</span><span class="token punctuation">(</span>SCF_CREATE_TABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>      CreateTableSqlNode <span class="token operator">&amp;</span>create_table <span class="token operator">=</span> $$<span class="token operator">-></span>create_table<span class="token punctuation">;</span>      create_table<span class="token punctuation">.</span>relation_name <span class="token operator">=</span> $<span class="token number">3</span><span class="token punctuation">;</span>      <span class="token function">free</span><span class="token punctuation">(</span>$<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>AttrInfoSqlNode<span class="token operator">></span> <span class="token operator">*</span>src_attrs <span class="token operator">=</span> $<span class="token number">6</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>src_attrs <span class="token operator">!=</span> nullptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        create_table<span class="token punctuation">.</span>attr_infos<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">*</span>src_attrs<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      create_table<span class="token punctuation">.</span>attr_infos<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token operator">*</span>$<span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">reverse</span><span class="token punctuation">(</span>create_table<span class="token punctuation">.</span>attr_infos<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> create_table<span class="token punctuation">.</span>attr_infos<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      delete $<span class="token number">5</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每个规则描述，比如<code>create_table_stmt</code> 都会生成一个结果，这个结果在.y中以 “$$“ 表示，某个语法中描述的各个token，按照顺序可以使用 “$1 $2 $3” 来引用，比如<code>ID</code> 就是 $3， attr_def 是 $5。”$n” 的类型都是 <code>YYSTYPE</code>。</p><p>YYSTYPE 是bison根据.y生成的类型，对应我们的规则文件就是 %union，YYSTYPE 也是一个union结构。比如 我们在.y文件中说明 <code>%type &lt;sql_node&gt; create_table_stmt</code>，表示 create_table_stmt 的类型对应了 %union 中的成员变量 sql_node。我们在 %union 中定义了 <code>ParsedSqlNode * sql_node;</code>，那么 create_table_stmt 的类型就是 <code>ParsedSqlNode *</code>，对应了 YYSTYPE.sql_node。</p><p>%union 中定义的数据类型，除了简单类型，大部分是在parse_defs.h中定义的，表达式Expression是在expression.h中定义的，Value是在value.h中定义的。</p><p>由于在定义语法规则时，这里都使用了左递归，用户输入的第一个元素会放到最前面，因此在计算得出最后的结果时，我们需要将列表（这里很多使用vector记录）中的元素逆转一下。</p><p><strong>语法分析中如何使用位置信息</strong></p><p>首先我们要在.y文件中增加%locations，告诉bison我们需要位置信息。其次需要与词法分析相配合，需要词法分析返回一个token时告诉语法分析此token的位置信息，包括行号、token起始位置和结束位置。与访问规则结果 $$ 类似，访问某个元素的位置信息可以使用 @$、 @1、@2 等。</p><p>词法分析中，yylineno记录当前是第几行，不过MiniOB当前没有处理多行文本。yycolumn记录当前在第几列，yyleng记录当前token文本的长度。词法分析提供了宏定义 <code>YY_USER_INIT</code> 可以在每次解析之前执行一些代码，而 <code>YY_USER_ACTION</code> 宏在每次解析完token后执行的代码。我们可以在<code>YY_USER_INIT</code>宏中对列号进行初始化，然后在<code>YY_USER_ACTION</code>计算token的位置信息，然后使用 <code>yylloc</code> 将位置信息传递给语法分析。而在引用 @$ 时，就是引用了 yylloc。</p><blockquote><p>这些宏定义和位置的引用可以参考lex_sql.l和yacc_sql.y，搜索相应的关键字即可。</p></blockquote><p>如果觉得位置信息传递和一些特殊符号 $$或 @$ 等使用感到困惑，可以直接看 flex和bison生成的代码，会让自己理解的更清晰。</p><h3 id="如何编译词法分析和语法分析模块"><a href="#如何编译词法分析和语法分析模块" class="headerlink" title="如何编译词法分析和语法分析模块"></a>如何编译词法分析和语法分析模块</h3><p>在 src/observer/sql/parser/ 目录下，执行以下命令：</p><p><code>./gen_parser.sh</code></p><p>将会生成词法分析代码 lex_sql.h 和 lex_sql.cpp，语法分析代码 yacc_sql.hpp 和 yacc_sql.cpp。</p><p>注意：flex 使用 2.5.35 版本测试通过，bison使用<strong>3.7</strong>版本测试通过(请不要使用旧版本，比如macos自带的bision）。</p><p>注意：当前没有把lex_sql.l和yacc_sql.y加入CMakefile.txt中，所以修改这两个文件后，需要手动生成c代码，然后再执行编译。</p><p>如果使用visual studio code，可以直接选择 “终端/Terminal” -&gt; “Run task…” -&gt; “gen_parser”，即可生成代码。</p><h3 id="如何调试词法分析和语法分析模块"><a href="#如何调试词法分析和语法分析模块" class="headerlink" title="如何调试词法分析和语法分析模块"></a>如何调试词法分析和语法分析模块</h3><p>代码中可以直接使用日志模块打印日志，对于yacc_sql.y也可以直接使用gdb调试工具调试。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li>《flex_bison》 flex/bison手册</li><li><a href="https://github.com/westes/flex">flex开源源码</a></li><li><a href="https://www.gnu.org/software/bison/">bison首页</a></li></ul><h2 id="MiniOB中新增支持一种SQL语句"><a href="#MiniOB中新增支持一种SQL语句" class="headerlink" title="MiniOB中新增支持一种SQL语句"></a>MiniOB中新增支持一种SQL语句</h2><p>当前的SQL实现已经比较复杂，这里以新增一个简单的SQL语句为例，介绍如何新增一种类型的SQL语句。 在介绍如何新增一种类型的SQL语句之前，先介绍一下MiniOB的SQL语句的执行流程。</p><h3 id="SQL语句执行流程"><a href="#SQL语句执行流程" class="headerlink" title="SQL语句执行流程"></a>SQL语句执行流程</h3><p>MiniOB的SQL语句执行流程如下图所示：</p><blockquote><p>左侧是执行流程节点，右侧是各个执行节点输出的数据结构。</p></blockquote><pre><code>┌──────────────────┐      ┌──────────────────┐│       SQL        │ ---&gt; │     String       │└────────┬─────────┘      └──────────────────┘         │┌────────▼─────────┐      ┌──────────────────┐│      Parser      │ ---&gt; │   ParsedSqlNode  |└────────┬─────────┘      └──────────────────┘         │         │┌────────▼─────────┐      ┌──────────────────┐│     Resolver     │ ---&gt; │     Statement    │└────────┬─────────┘      └──────────────────┘         │         │┌────────▼─────────┐      ┌──────────────────┐│   Transformer    │ ---&gt; │ LogicalOperator  |└────────┬─────────┘      │ PhysicalOperator │         │                │       or         │┌────────▼─────────┐      │ CommandExecutor  |│    Optimizer     │ ---&gt; │                  │└────────┬─────────┘      └──────────────────┘         │┌────────▼─────────┐      ┌──────────────────┐│     Executor     │ ---&gt; │    SqlResult     │└──────────────────┘      └──────────────────┘</code></pre><ol><li>我们收到了一个SQL请求，此请求以字符串形式存储;</li><li>在Parser阶段将SQL字符串，通过词法解析(lex_sql.l)与语法解析(yacc_sql.y)解析成ParsedSqlNode(parse_defs.h);</li><li>在Resolver阶段，将ParsedSqlNode转换成Stmt(全称 Statement， 参考 stmt.h);</li><li>在Transformer和Optimizer阶段，将Stmt转换成LogicalOperator，优化后输出PhysicalOperator(参考 optimize_stage.cpp)。如果是命令执行类型的SQL请求，会创建对应的 CommandExecutor(参考 command_executor.cpp);</li><li>最终执行阶段 Executor，工作量比较少，将PhysicalOperator(物理执行计划)转换为SqlResult(执行结果)，或者将CommandExecutor执行后通过SqlResult输出结果。</li></ol><h3 id="新增一种类型的SQL语句"><a href="#新增一种类型的SQL语句" class="headerlink" title="新增一种类型的SQL语句"></a>新增一种类型的SQL语句</h3><p>这里将以CALC类型的SQL为例介绍。</p><p>CALC 不是一个标准的SQL语句，它的功能是计算给定的一个四则表达式，比如：</p><p><code>CALC 1+2*3</code></p><p>CALC 在SQL的各个流程中，与SELECT语句非常类似，因此在增加CALC语句时，可以参考SELECT语句的实现。</p><p>首先在Parser阶段，我们需要考虑词法分析和语法分析。CALC 中需要新增的词法不多，简单的四则运算中只需要考虑数字、运算符号和小括号即可。在增加CALC之前，只有运算符号没有全部增加，那我们加上即可。参考 <code>lex_sql.l</code>。</p><pre><code>&quot;+&quot; |&quot;-&quot; |&quot;*&quot; |&quot;/&quot;    { return yytext[0]; }</code></pre><p>在语法分析阶段，我们参考SELECT相关的一些解析，在yacc_sql.y中增加CALC的一些解析规则，以及在parse_defs.h中SELECT解析后的数据类型，编写CALC解析出来的数据类型。 当前CALC是已经实现的，可以直接在parse_defs.h中的类型定义。 yacc_sql.y中需要增加calc_stmt，calc_stmt的类型，以及calc_stmt的解析规则。由于calc_stmt涉及到表达式运算，所以还需要增加表达式的解析规则。具体可以参考yacc_sql.y中关于calc的代码。</p><p>在语法解析结束后，输出了<code>CalcSqlNode</code>，后面resolver阶段，将它转换为Stmt，这里就是新增<code>CalcStmt</code>。通常在resolver阶段会校验SQL语法树的合法性，比如查询的表是否存在，运算类型是否正确。在<code>CalcStmt</code>中，逻辑比较简单，没有做任何校验，只是将表达式记录下来，并且认为这里的表达式都是值类型的计算。</p><p>在Transformer和Optmize阶段，对于查询类型的SQL会生成LogicalOperator和PhysicalOperator，而对于命令执行类型的SQL会生成CommandExecutor。CALC是查询类型的SQL，参考SELECT的实现，在SELECT中，有PROJECT、TABLE_SCAN等类型的算子，而CALC比较简单，我们新增<code>CalcLogicalOperator</code>和<code>CalcPhysicalOperator</code>。</p><p>由于具有执行计划的SQL，在Executor阶段，我们仅需要给SqlResult设置对应的TupleSchema即可，可以参考<code>ExecuteStage::handle_request_with_physical_operator</code>。</p><p>总结一下，新增一种类型的SQL，需要在以下几个地方做修改：</p><ol><li>词法解析，增加新的词法规则(lex_sql.l);</li><li>语法解析，增加新的语法规则(yacc_sql.y);</li><li>增加新的SQL语法树类型(parse_defs.h);</li><li>增加新的Stmt类型(stmt.h);</li><li>增加新的LogicalOperator和PhysicalOperator(logical_operator.h, physical_operator.h, optimize_stage.cpp，如果有需要);</li><li>增加新的CommandExecutor(command_executor.cpp，如果有需要);</li><li>设置SqlResult的TupleSchema(execute_stage.cpp，如果有需要)。</li></ol><h2 id="MiniOB中的表达式解析"><a href="#MiniOB中的表达式解析" class="headerlink" title="MiniOB中的表达式解析"></a>MiniOB中的表达式解析</h2><p>表达式是SQL操作中非常基础的内容。 我们常见的表达式就是四则运算的表达式，比如<code>1+2</code>、<code>3*(10-3)</code>等。在常见的数据库中，比如MySQL、<a href="https://github.com/oceanbase/oceanbase">OceanBase</a>，可以运行 <code>select 1+2</code>、<code>select 3*(10-3)</code>，来获取这种表达式的结果。但是同时在SQL中，也可以执行 <code>select 1</code>、<code>select field1 from table1</code>，来查询一个常量或者一个字段。那我们就可以把表达式的概念抽象出来，认为常量、四则运算、表字段、函数调用等都是表达式。</p><h3 id="MiniOB-中的表达式实现"><a href="#MiniOB-中的表达式实现" class="headerlink" title="MiniOB 中的表达式实现"></a>MiniOB 中的表达式实现</h3><p>当前MiniOB并没有实现上述的所有类型的表达式，而是选择扩展SQL语法，增加了 <code>CALC</code> 命令，以支持算术表达式运算。这里就以 CALC 支持的表达式为例，介绍如何在 MiniOB 中实现表达式。在介绍实现细节之前先看下一个例子以及它的执行结果：</p><p><code>CALC 1+2</code>执行结果：<code>1+2 3</code></p><p>注意这个表达式输出时会输出表达式的原始内容。</p><h3 id="SQL-语句"><a href="#SQL-语句" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><p>MiniOB 从客户端接收到SQL请求后，会创建 <code>SessionEvent</code>，其中 <code>query_</code> 以字符串的形式保存了SQL请求。 比如 <code>CALC 1+2</code>，记录为”CALC 1+2”。</p><h3 id="SQL-Parser"><a href="#SQL-Parser" class="headerlink" title="SQL Parser"></a>SQL Parser</h3><p>Parser部分分为词法分析和语法分析。如果对词法分析语法分析还不了解，建议先查看 <a href="https://oceanbase.github.io/miniob/design/miniob-sql-parser.html">SQL Parser</a>。</p><h4 id="词法分析-1"><a href="#词法分析-1" class="headerlink" title="词法分析"></a>词法分析</h4><p>算术表达式需要整数、浮点数，以及加减乘除运算符。我们在lex_sql.l中可以看到 NUMBER 和 FLOAT的token解析。运算符的相关模式匹配定义如下：</p><p><code>&quot;+&quot; | &quot;-&quot; | &quot;*&quot; | &quot;/&quot;    { return yytext[0]; }</code></p><h4 id="语法分析-1"><a href="#语法分析-1" class="headerlink" title="语法分析"></a>语法分析</h4><p>因为 CALC 也是一个完整的SQL语句，那我们先给它定义一个类型。我们定义一个 CALC 语句可以计算多个表达式的值，表达式之间使用逗号分隔，那 CalcSqlNode 定义应该是这样的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> CalcSqlNode <span class="token punctuation">{</span>     std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>Expression <span class="token operator">*</span><span class="token operator">></span> expressions<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在 yacc_sql.y 文件中，我们增加一种新的语句类型 <code>calc_stmt</code>，与SELECT类似。它的类型也是<code>sql_node</code>：</p><p><code>%type &lt;sql_node&gt; calc_stmt</code></p><p>接下来分析 <code>calc_stmt</code> 的语法规则。</p><pre class="line-numbers language-cpp"><code class="language-cpp">calc_stmt<span class="token operator">:</span>    CALC expression_list    <span class="token punctuation">{</span>      $$ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ParsedSqlNode</span><span class="token punctuation">(</span>SCF_CALC<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// CALC的最终类型还是一个ParsedSqlNode</span>      std<span class="token operator">::</span><span class="token function">reverse</span><span class="token punctuation">(</span>$<span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> $<span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 由于左递归的原因，我们需要得出列表内容后给它反转一下</span>      <span class="token comment" spellcheck="true">// 直接从 expression_list 中拿出数据到目标结构中，省的再申请释放内存</span>      $$<span class="token operator">-</span><span class="token operator">></span>calc<span class="token punctuation">.</span>expressions<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">*</span>$<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">delete</span> $<span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// expression_list 本身的内存不要忘记释放掉</span>    <span class="token punctuation">}</span>    <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>CALC expression_list</code> CALC 仅仅是一个关键字。expression_list 是表达式列表，我们需要对它的规则作出说明，还要在%union和 %type 中增加其类型说明。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token operator">%</span><span class="token keyword">union</span> <span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>Expression <span class="token operator">*</span><span class="token operator">></span> <span class="token operator">*</span>expression_list<span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">%</span>type <span class="token operator">&lt;</span>expression_list<span class="token operator">></span> expression_list<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>expression_list 的规则如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp">expression_list<span class="token operator">:</span>    expression  <span class="token comment" spellcheck="true">// 表达式列表可以是单个表达式</span>    <span class="token punctuation">{</span>      $$ <span class="token operator">=</span> <span class="token keyword">new</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>Expression<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">;</span>      $$<span class="token operator">-</span><span class="token operator">></span><span class="token function">emplace_back</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 表达式列表也可以是逗号分隔的多个表达式，使用递归定义的方式说明规则</span>    <span class="token operator">|</span> expression COMMA expression_list     <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>$<span class="token number">3</span> <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        $$ <span class="token operator">=</span> $<span class="token number">3</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        $$ <span class="token operator">=</span> <span class="token keyword">new</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>Expression <span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 表达式列表的最终类型</span>      <span class="token punctuation">}</span>      $$<span class="token operator">-</span><span class="token operator">></span><span class="token function">emplace_back</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 目标结果中多了一个元素。</span>    <span class="token punctuation">}</span>    <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>expression 的规则会比较简单，加减乘除，以及负号取反。这里与普通的规则不同的是，我们需要关心运算符的优先级，以及负号运算符的特殊性。</p><p>优先级规则简单，乘除在先，加减在后，如果有括号先计算括号的表达式。</p><pre><code>%left &#39;+&#39; &#39;-&#39;%left &#39;*&#39; &#39;/&#39;</code></pre><p>%left 表示左结合，就是遇到指定的符号，先跟左边的符号结合。而定义的顺序就是优先级的顺序，越靠后的优先级越高。</p><p>负号运算符的特殊性除了它的优先级，还有它的结合性。普通的运算，比如 <code>1+2</code>，是两个数字即两个表达式，一个运算符。而负号的表示形式是 <code>-(1+2)</code>，即一个符号，一个表达式。</p><pre><code>%nonassoc UMINUS</code></pre><p>表示 <code>UMINUS</code> 是一个一元运算符，没有结合性。在.y中，放到了 <code>%left &#39;*&#39; &#39;/&#39;</code> 的后面，说明优先级比乘除运算符高。</p><p>expression 的规则如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp">expression <span class="token string">'+'</span> expression <span class="token punctuation">{</span>      $$ <span class="token operator">=</span> <span class="token function">create_arithmetic_expression</span><span class="token punctuation">(</span>ArithmeticExpr<span class="token operator">::</span>Type<span class="token operator">::</span>ADD<span class="token punctuation">,</span> $<span class="token number">1</span><span class="token punctuation">,</span> $<span class="token number">3</span><span class="token punctuation">,</span> sql_string<span class="token punctuation">,</span> <span class="token operator">&amp;</span>@$<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">|</span> expression <span class="token string">'-'</span> expression <span class="token punctuation">{</span>      $$ <span class="token operator">=</span> <span class="token function">create_arithmetic_expression</span><span class="token punctuation">(</span>ArithmeticExpr<span class="token operator">::</span>Type<span class="token operator">::</span>SUB<span class="token punctuation">,</span> $<span class="token number">1</span><span class="token punctuation">,</span> $<span class="token number">3</span><span class="token punctuation">,</span> sql_string<span class="token punctuation">,</span> <span class="token operator">&amp;</span>@$<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">|</span> expression <span class="token string">'*'</span> expression <span class="token punctuation">{</span>      $$ <span class="token operator">=</span> <span class="token function">create_arithmetic_expression</span><span class="token punctuation">(</span>ArithmeticExpr<span class="token operator">::</span>Type<span class="token operator">::</span>MUL<span class="token punctuation">,</span> $<span class="token number">1</span><span class="token punctuation">,</span> $<span class="token number">3</span><span class="token punctuation">,</span> sql_string<span class="token punctuation">,</span> <span class="token operator">&amp;</span>@$<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">|</span> expression <span class="token string">'/'</span> expression <span class="token punctuation">{</span>      $$ <span class="token operator">=</span> <span class="token function">create_arithmetic_expression</span><span class="token punctuation">(</span>ArithmeticExpr<span class="token operator">::</span>Type<span class="token operator">::</span>DIV<span class="token punctuation">,</span> $<span class="token number">1</span><span class="token punctuation">,</span> $<span class="token number">3</span><span class="token punctuation">,</span> sql_string<span class="token punctuation">,</span> <span class="token operator">&amp;</span>@$<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">|</span> LBRACE expression RBRACE <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// '(' expression ')'</span>      $$ <span class="token operator">=</span> $<span class="token number">2</span><span class="token punctuation">;</span>      $$<span class="token operator">-</span><span class="token operator">></span><span class="token function">set_name</span><span class="token punctuation">(</span><span class="token function">token_name</span><span class="token punctuation">(</span>sql_string<span class="token punctuation">,</span> <span class="token operator">&amp;</span>@$<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// %prec 告诉yacc '-' 负号预算的优先级，等于UMINUS的优先级</span>    <span class="token operator">|</span> <span class="token string">'-'</span> expression <span class="token operator">%</span>prec UMINUS <span class="token punctuation">{</span>      $$ <span class="token operator">=</span> <span class="token function">create_arithmetic_expression</span><span class="token punctuation">(</span>ArithmeticExpr<span class="token operator">::</span>Type<span class="token operator">::</span>NEGATIVE<span class="token punctuation">,</span> $<span class="token number">2</span><span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> sql_string<span class="token punctuation">,</span> <span class="token operator">&amp;</span>@$<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">|</span> value <span class="token punctuation">{</span>      $$ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ValueExpr</span><span class="token punctuation">(</span><span class="token operator">*</span>$<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      $$<span class="token operator">-</span><span class="token operator">></span><span class="token function">set_name</span><span class="token punctuation">(</span><span class="token function">token_name</span><span class="token punctuation">(</span>sql_string<span class="token punctuation">,</span> <span class="token operator">&amp;</span>@$<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">delete</span> $<span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>create_arithmetic_expression</code> 是一个创建算术表达式的函数，它的实现在.y文件中，不再罗列。</p><p>表达式的名称，需要在输出结果中展示出来。我们知道当前的SQL语句，也知道某个token的开始列号与截止列号，就可以计算出来这个表达式对应的SQL命令输入是什么。在 expression 规则描述中，就是 <code>$$-&gt;set_name(token_name(sql_string, &amp;@$));</code>，其中 <code>sql_string</code> 就是当前的SQL语句，@$ 是当前的token的位置信息。</p><h3 id="抽象表达式类型"><a href="#抽象表达式类型" class="headerlink" title="抽象表达式类型"></a>抽象表达式类型</h3><p>上面语法分析中描述的都是算术表达式，但是真实的SQL语句中，像字段名、常量、比较运算、函数、子查询等都是表达式。我们需要定义一个基类，然后派生出各种表达式类型。</p><p>这些表达式的定义已经在expression.h中定义，但是没有在语法解析中体现。更完善的做法是在 select 的属性列表、where 条件、insert 的 values等语句中，都使用表达式来表示。</p><h3 id="‘-‘-缺陷"><a href="#‘-‘-缺陷" class="headerlink" title="‘-‘ 缺陷"></a>‘-‘ 缺陷</h3><p>由于在词法分析中，负号’-‘与数字放在一起时，会被认为是一个负值数字，作为一个完整的token返回给语法分析，所以当前的语法分析无法正确的解析下面的表达式：</p><p><code>1 -2;</code></p><p>这个表达式的结果应该是 -1，但是当前的语法分析会认为是两个表达式，一个是1，一个是-2，这样就无法正确的计算出结果。 当前修复此问题的成本较高，需要修改词法分析的规则，所以暂时不做处理。</p><h2 id="SQL引擎"><a href="#SQL引擎" class="headerlink" title="SQL引擎"></a>SQL引擎</h2><h3 id="SQL层整体架构"><a href="#SQL层整体架构" class="headerlink" title="SQL层整体架构"></a>SQL层整体架构</h3><p>数据库在长期发展过程中已经有了成熟的工程结构，对于传统的SQL内核层来说，基本构架图如左图所示，其中oceanBase处理一条SQL请求的架构图如右图所示。<br><img src="/posts/29042/image-20231009143827302.png" alt><br>左图中MySQL在SQL层主要处理了查询缓存部分、分析器、优化器、执行器这几部分。现在按照对应的流程模块走一遍。</p><h4 id="SQL语句结构"><a href="#SQL语句结构" class="headerlink" title="SQL语句结构"></a>SQL语句结构</h4><p>只要接触数据库，不管是使用还是研究内核部分，都应该对SQL语句执行的顺序有了解。</p><pre class="line-numbers language-SQL"><code class="language-SQL">SELECT<字段名>（9）FROM<表名>（1）JOIN<表名>（2）ON<连接条件>〔2）WHERE<筛选条件>〔5）GROUP BY<字段名>（4）HAVING<筛选条件>（5〕ORDER BY<字段名>（7）LIMIT<限制行数>（8）#此处不包含subquery<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每个SQL语句后面的序号就是其执行的序号，可以看到对于正常书写顺序和执行的顺序是不同的，通常来说这样的执行顺序能够降低操作时的数据量。</p><h3 id="Parser和Resolver模块"><a href="#Parser和Resolver模块" class="headerlink" title="Parser和Resolver模块"></a>Parser和Resolver模块</h3><h4 id="Parser模块"><a href="#Parser模块" class="headerlink" title="Parser模块"></a>Parser模块</h4><p>这部分是编译原理部分的内容，当一条SQL请求到达server端时，首先需要到parser模块，这个模块的作用就是根据Yacc和Flex工具自动生成的语法结构，判断SQL语句是否符合语法结构。</p><p>如下图所示，SQL语句<code>SELECT c1+c2 FROM t1 WHERE exists</code>再接着一个子查询，然后子查询是由union all连接的另外两个子查询。Parser模块最终解析出来的是一个逻辑结构图，就像示例图中这样一个树状结构。</p><p><img src="/posts/29042/image-20231009150222816.png" alt></p><p>接下来介绍一下具体是如何实现的，无论是SELECT、FROM还是WHERE，都会有自己所附带的一些成分。</p><ul><li><p>select list是一个表达式操作，即 c1 + c2。再递归解析，它的根节点是+，两个子节点分别是参与运算的两个常量 c1 和 c2 。</p></li><li><p>from list的参数其实是一个relation，也就是一个表名，即t1。</p></li><li><p>Where代表的是condition条件，这里的condition操作符是exists，exists后面是一sub query。这sub query可以递归地向下去分解，它是由union all所连接起来的两个sub query。同理这两个sub query也可以再递归地向下展开。</p></li></ul><p>一条SQL语句，无论写得多么复杂，本质上就是一层一层嵌套的树状结构。Parser模块这一个部分主要做的就是根据用户所写的语法规则正确的识别，并将一条SQL语句转化为一个语法树的结构。但一条符合语法树规则的SQL不一定是一条“合格”的SQL，数据库中还存在着许多约束，一条SQL还必须满足语义的约束，许多语法的约束以及虚视图的展开都是在Resolver模块中完成的。</p><h4 id="Resolver模块"><a href="#Resolver模块" class="headerlink" title="Resolver模块"></a>Resolver模块</h4><p>Resolver模块需要对Parser模块所生成的符合语法规则的语法树进一步进行检查其约束，也就是语义解析的部分。</p><p>虽然说Resolver模块是对Parser模块的语法树的一个检查转换，但是在执行的时候在这一层，数据库会将其转化为STMT（statement）阶段。</p><p>如SQL语句<code>SELECT c1+c2 FROM t1 WHERE exists( seLect c1 from t1 union all seLect c1 from t2)</code>转换成了StatementTree，大家可以观察一下，在OceanBase中Resolver这层是怎么去表示 Statement结构，这个结构是多个OceanBase Statement和表达式对象的集合，多个Statement对象在 OceanBase中可以表达一些查询中的子查询。<br><img src="/posts/29042/image-20231009151211199.png" alt></p><p>Statement结构既不是关系运算的表示，也不是树状结构，而是具体在执行时的工程上的实现。</p><h4 id="Transformer和optimizer模块"><a href="#Transformer和optimizer模块" class="headerlink" title="Transformer和optimizer模块"></a>Transformer和optimizer模块</h4><p>通过前几节的介绍，了解了一条SQL请求在Parser模块主要关注的是语法树逻辑结构，在Resolver模块主要关注的是符合语义要求的树形的结构。在OceanBase中，数据结构在Resolver层实际上是一个Statement，这也是OceanBase后续进行Transformer和optimizer改写的基础。</p><p>不过在Transformer和optimizer层，重点需要关注的是火山模型的结构，Executor模块。这里介绍一个示例来帮助大家理解，示例中SQL的语义是:挑选出某场电影的名字和卖出的票数，并且它的票数需要大于50张。这里假设在七点钟，只有一场电影在播放，并且卖出的票数超过了100张。即当执行这条SQL的时候，会查出这场电影和卖出的票数。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> movie<span class="token punctuation">.</span>name，play<span class="token punctuation">.</span>ticket<span class="token keyword">FROM</span> movie<span class="token keyword">JOIN</span> ptLay<span class="token keyword">ON</span> movie<span class="token punctuation">.</span>time<span class="token operator">=</span>pLay<span class="token punctuation">.</span>time<span class="token keyword">WHERE</span> pLay<span class="token punctuation">.</span>ticket<span class="token operator">></span><span class="token number">59</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下图所示是这条SQL简单的执行计划。首先分别对两张表进行全部字段的遍历，遍历所有字段后做表连接操作，操作的条件为<code>movie.time=pLay.time</code>，即时间一致。连接之后生成一张新表，再去根据条件<code>play.ticker&gt;59</code>去过滤，最后将需要查询的<code>play.ticker</code>和<code>movie.name</code>给投影出来。</p><p><img src="/posts/29042/image-20231009151943193.png" alt></p><p>投影操作实际上只需要投影出特定的列，包括在做Join条件时也是要需要一个时间的字段，所以第一个优化是减少遍历属性，可以将上层的投影给去掉，然后将Scan的操作只遍历特定的属性，两张表都是这样，做完这个优化后，就减少了一个投影操作。</p><p><img src="/posts/29042/image-20231009152055139.png" alt></p><p>第二个优化是因为最终符合条件的只需要卖出的票数大于50张的场次，所以在遍历Play表的时候，不需要将所 有的电影及对应票数都筛选出来，只需要筛选出票数大于50张的排片。 经过优化之后它由四层的结构变成了两层，只需记历出需要的字段，然后做一个Join操作就可以了。不仅操作路 径变短了，而且表的连接项也变得更少了，相比之前查询计划更优。</p><p>这两个模块最重要的部分就是需要如何从一个火山模型的层次调用结构去看是否有更多的优化空间。</p><h4 id="Executor模块"><a href="#Executor模块" class="headerlink" title="Executor模块"></a>Executor模块</h4><p>Executor模块中最经典的模型是VolcanoModel(火山模型)，它是一种基于行的流式迭代模型(Row-BasedStreamingIteratorModel)。在火山模型中，所有的代数运算符(operator)都被看成是一个迭代器，它们都提供一组简单的接口:open( )一next( )一close( )，查询计划树由一个个这样的关系运算符组成，每一次的next( )调用，运算符就返回一行(Row)，每一个运算符的next( )都有自己的流控逻辑，数据通过运算符自上而下的next( )符套调用而被动的进行拉取。</p><p><img src="/posts/29042/image-20231009152609531.png" alt></p><p>火山模型中每一个运算符都将下层的输入看成是一张表，next()接口的一次调用就获取表中的一行数据，这样设计的优点是:每个运算符之间的代数计算是相互独立的，并且运算符可以伴随查询关系的变化出现在查询计划树的任意位置，这使得运算符的算法实现变得简单并且富有拓展性。</p><p>这种设计也会存在一些问题，如果没有一些阻塞性的操作，整个火山模型只需要很少的内存就能运作起来，每次只需要人迭代一个tuple行。但有一些Operator(如sort)，它是阻塞性的操作，要拿到所有的tuple之后，才能进行进行运算，这种操作符实际上是破坏了火山模型整体的流水性的运算。</p><p>目前火山模型在原先基础上有不断改进，具体内容可以搜索了解。</p><h2 id="额外知识补充"><a href="#额外知识补充" class="headerlink" title="额外知识补充"></a>额外知识补充</h2><h3 id="SEDA架构模式"><a href="#SEDA架构模式" class="headerlink" title="SEDA架构模式"></a>SEDA架构模式</h3><p>具体论文为：SEDA: An Architecture for Well-Conditioned, Scalable Internet Services（分阶段事件驱动架构）</p><p>staged event-driven architecture (SEDA) 框架在建模的时候就将负载和资源瓶颈考虑在内，从而可以在高负载的情况下也能工作良好，并且有效防止服务过载。SEDA 架构的基本思想是将业务逻辑切分成一系列通过 queues 连接起来的 stages，组合成一个 data flow 网络去执行。</p><h4 id="基于线程并发"><a href="#基于线程并发" class="headerlink" title="基于线程并发"></a>基于线程并发</h4><p>最简单直接的方式就是每来一个请求就启动一个线程去处理。这么做的好处是编程模型极其简单，调度隔离之类的问题都交给操作系统来保证了，也比较可靠。缺点是在负载较高的时候，会产生不可忽视的开销。因为物理资源是有限的，尽管操作系统层面做了一层抽象，使得看起来我们可以获得非常多的资源，但是这都是假象，在高负载情况下会暴露无遗。每个线程分到的时间片都是有限的，非常多的线程在频繁的进行上下文切换，缓存在不断的抖动，线程调度的开销随着问题规模增加而增加，锁资源争用，这些因素都会带来性能的急剧下降。而且线程频繁创建和销毁也会带来可观的开销。从作者给的图表来看，超过系统承载能力之后再持续加压，会导致系统性能下降。我们预期通过某些手段能够自保，从而维持在巅峰性能附近。<br><img src="/posts/29042/image-20231002153939619.png" alt></p><h4 id="基于线程池并发"><a href="#基于线程池并发" class="headerlink" title="基于线程池并发"></a>基于线程池并发</h4><p>一个简单的改进方法就是使用线程池。这样的话至少可以解决线程数量过多带来的问题。作者在这里提到，在高负载情况下，这样会带来公平性问题。</p><p>公平性问题在多租户系统中确实是一个非常重要的问题，也是系统规模做到一定程度时必须面对的一个问题。这里稍微啰嗦一下，展开说两句。简单来说，多租户服务的资源利用率是远高于单租户服务的。租户足够多，且足够多样性的情况下，有的用户在忙的时候，通常也有一些用户在空闲。这样就带来了整体利用率上的提升。首先我们要做到公平，这样就不会因为有一个人意外使用了特别多的资源，而影响到其他正常使用服务的用户。否则由于用户体验的下降，用户会拒绝使用你的服务。更进一步的，也许我们需要对用户进行分级服务，高优先级的用户可以抢占使用低优先级用户的资源，当然定价可能也是分级的。</p><p>作者提到的公平性问题发生在这样的场景下。负载特别高的情况下，我们处理请求的速度跟不上产生请求的速度。大量的请求堆积在任务分发队列，甚至是网络协议栈上。在这种情况下新来的一个请求，其整体延迟应该是排队等待的延迟加上实际执行处理的延迟。而排队等待延迟是不可控的，并且由于过载的问题没有办法得到妥善的调度，因此有违公平性。更常规的情况是，有部分用户的请求量异常，超出他们自己的配额，但是没有超出整个服务的承载能力，或者超出了整个服务的承载能力，但是不是特别夸张，比如说只超出了一两倍（取决于你业务逻辑的复杂程度）。对于前者，我们通过配额管理，可以在这个请求被调度进行处理的时候，将这个请求拒绝掉，从而避免了执行业务逻辑的负担。通过这种方式，我们可以一定程度上提高我们系统的承载能力。如果负载进一步上升，可能我们拒绝的速度都追不上产生请求的速度，这种情况下，也许我们可以采取网卡队列管理的一些策略，例如 Random Early Discard，进一步提升我们系统的承载能力（但是已经是有损的了）。</p><p>作者也举例了一种比较有意思的场景。比如说空闲的时候来了几个比较大的请求，把线程池里面的线程都用上了（但是没有后续排队的请求）；然后突然来了一堆小请求，尽管我们如果多一个空闲线程就能处理过来，但是现在没有任何一个活动线程能来得及干这个事情。这可能需要 case-by-case 的去做一些更精细的策略调整，比如说对请求大小进行分类，避免一种请求把所有活动线程都占了。</p><h4 id="基于“事件驱动”并发"><a href="#基于“事件驱动”并发" class="headerlink" title="基于“事件驱动”并发"></a>基于“事件驱动”并发</h4><p>从作者的大致描述来看，感觉就是一个传统的使用 epoll 驱动的事件模型。几乎所有的 blocking I/O 都被转化成了 event，然后再被投递到各个子模块中继续处理。每个子模块自己使用状态机管理状态，这样 request context 就被状态机管理起来，而不是直接放到 thread context 上了。由于Scheduler的设计和实现过于复杂，针对于不同的应用和系统的逻辑变更需要不同的实现，导致采用这一模型构建出的系统将十分庞大和难以控制。</p><ol><li>每个子模块需要小心的维护 request context</li><li>所有的业务逻辑需要尽可能地避免 blocking，否则可能阻塞 event dispatcher</li><li>每新增一个子模块可能就需要修改 event dispatcher 的逻辑，特别是调度 event 的逻辑（比如说同一类 event 聚合一波一起处理可能会增加缓存命中率进而提高效率）</li></ol><p><img src="/posts/29042/image-20231002154935339.png" alt></p><h4 id="阶段性事件驱动（SEDA）模型"><a href="#阶段性事件驱动（SEDA）模型" class="headerlink" title="阶段性事件驱动（SEDA）模型"></a>阶段性事件驱动（SEDA）模型</h4><p><img src="/posts/29042/image-20231002155127576.png" alt></p><p>  SEDA架构能对有穷状态机进行分析，而后将相关状态聚集在同一Stage中，Stage间采用队列的方式来进行通信。每一个Stage皆完全独立，均拥有自己的线程池，以及为了专门处理到达这一步骤所必须进行的工作。所有的Stage均通过自身事件队列连接在一起，构成完整的请求处理网络。性能控制器和动态线程池依请求的繁忙程度动态来调整线程池的大小，以达到系统资源的最有分配。每一个Stage由下述四部分组成：  </p><pre><code>   (1)    事件队列：用以维持Stage间之通信。     (2)    事件处理器：用以执行请求到这一个Stage中所应执行的工作。     (3)    线程池：用以提供事件处理器且可以并发执行事件处理之环境。     (4)    性能控制器：用以对该Stage资源（线程数、队列长度等等）进行调整。  </code></pre><p>通过这四部分的协作配合，每一个Stage都可以很好地运行，并且可以控制资源的使用。已经过Stage处理完，若没有后续工作，即可以回收线程池中的线程，来供给其他Stage使用。Stage结构如下图所示。  </p><p>在SEDA架构中，基本的处理单元称为阶段（Stage），一个阶段由事件队列、动态线程池、事件处理器和一个性能控制器四个组件构成。SEDA将一个请求的处理过程分解为一系列的阶段，阶段之间通过事件队列联系，开发人员只负责每个阶段的服务逻辑以及阶段间的连接逻辑，而由各个阶段自身负责资源管理以及负载适应功能。使用这种解耦拆分可以使系统达到高并发性、对负载变化的良好适应性以及高度的可缩放性。</p><p><img src="/posts/29042/image-20231002155216032.png" alt></p><p>这种做法有点类似于 actor model（这里就不展开介绍了 actor model 了，感兴趣的可以看看 akka 的文档和 erlang）。但是传统的 actor model 是把线程 attach 到 actor 上而非 mailbox 上的。但是确实看起来把运算资源 attach 到 queues 或者说 scheduler 上可能更合理一些。Apache Hadoop 和 Microsoft Orleans 貌似都是这么做的。</p><p>论文里还提到了线程池是可以自我调节的，这里提到了可以调节线程池的线程数和一次执行时候的批大小。带自动伸缩功能的线程池其实不算太少见，但是在设计 API 的时候就考虑批执行的 API 还是比较少见的。以个人的经验来看，批执行确实有可能显著的提升计算能力，主要考虑这些方面。</p><ol><li>更少的锁争用（拿一次锁可以跑一批数据而非只跑一条数据）</li><li>更好复用一些临时资源</li><li>更好的缓存利用</li><li>可能从 SIMD 指令集中受益</li></ol><p>在一些特殊的场景中也有可能使用更复杂的策略。</p><h3 id="基础代数符号与操作"><a href="#基础代数符号与操作" class="headerlink" title="基础代数符号与操作"></a>基础代数符号与操作</h3><h4 id="选择操作符"><a href="#选择操作符" class="headerlink" title="选择操作符"></a>选择操作符</h4><p>使用选择操作符时的算法通常是Scan，其中有线性扫描，也有索引扫描。通常对同一张表有多次选择的条件，应该将这多个条件优化到一次。</p><ul><li>示例1:合并多个选择，该方法适合于对同一张表上有多个相同的选择条件而言，此时可以合并多次的选择，以减少多次过滤带来的消耗。比如条件<code>where T.a=T.b and T.b=T.c</code>，这个条件是一个和的操作，需要过滤两次。因此在内部可以将它优化成一个过滤条件，直接判断<code>T.a=T.b=T.c</code>，而不是先判断<code>T.a=T.b</code>，再判断<code>T.b=T.c</code>。</li><li>示例2:分解多个选择，比如SQL语句<code>select * from T where T.a=35 OR T.b&gt;8</code>，假设 T 表的a和b组上都有各自的索引。这时候可以将这个SQL分解为两个SQL(<code>select * from T where T.a=3 UNION select * from T where T.b&gt;8</code>)，各自利用索引加速进行查询，最后再合并结果，而不必因为OR导致索引失效。在实际实现上把OR给改写成UNION是一种很常见的改写。</li></ul><h4 id="投影操作符"><a href="#投影操作符" class="headerlink" title="投影操作符"></a>投影操作符</h4><p>使用投影操作能够减少列从而减少中间临时关系的内存消耗，如果一个操作最后需要投影，那么完全可以先投影后再做其他操作来减小操作中间的复杂度。</p><h4 id="连接操作"><a href="#连接操作" class="headerlink" title="连接操作"></a>连接操作</h4><p>链接除了笛卡尔积和链接，还有inner join、left join、right join、full join。其中inner join称为内连接，其余三个称为外连接(outjoin)。一般来说都会将外连接改写成内连接，因为内连接可以有更多的连接顺序选择、基表谓词条件下压，来更好的查询计划提高查询效率。可以看这个系列的博客<a href="https:/open.oceanbase.com/blog/10900347">SQL改写系列</a></p><p><img src="/posts/29042/image-20231009161317173.png" alt><br>这里列举了几种连接算法的伪码，可以帮助理解每一种连接算法的原理。</p><ul><li>Nest-loop join算法的基本思想就是两个for循环。每次会迭代外表的一行，然后再以此为驱动去迭代内表的每一行tuple，如果满足连接条件，就会加入结果集。这里有一个基本的优化思想，即可以将小表放在外层作为驱动表，这样会减少内表的循环次数，从而也会减少内表的遍历次数。</li></ul><pre><code>For t IN Rt:    For s IN Rs:        resutLt.add(t,S)</code></pre><ul><li>Index Nest-loop join算法是利用索引加速的一个嵌套循环算法。假设在内表有索引，且是一个等值的，每次驱动外表的一行，内表可以利用等值进行一个索引搜索，就不需要去遍历内表的全部元组，从而减少IO的消耗。</li></ul><pre><code>For t IN Rt:    For s IN Rs using index:        resutlt.add(t,S)</code></pre><ul><li>Block Nest-loop join算法的基本思想是每次的迭代不再是一行的tuple，而是按块进行连接运算。先读取Rt表的一个Block，再读遍读取Rs的一个Block，然后将这两个表的元组进行连接。这个算法的基本思想就是不再以行为粒度，而是以块为粒度，从而减少IO的消耗。</li></ul><pre><code>For Bt IN Rt:    For Bs IN Rs:        For t IN Bt:            For s IN Bs:                resutlt.add(t,S)</code></pre><ul><li>merge join算法利用了归并排序的思想，先将两张关联表各自做排序，然后从各自的排序表中去抽取数据到另一个排序表中做一些条件匹配，从而生成结果集，示例中没有把它的伪码写的很详细，但可以说明基本的原理就是归并的思想。</li></ul><pre><code>Ra=Sort(Rt)Rb=Sort(Rs)Merge_join(Ra,Rb)--resuLt.add(t,S)</code></pre><ul><li>hash join算法是将其中一张表先在内存中建立一个哈希表，这张表通常是两张表中比较小的那一张表。需要注意的是，如果这个哈希表比较大，无法一次性构造在内存中，那就需要将这张表分多个Partition写入磁盘，就会多一个写的拆架，也会降低效率。因此hashjoin算法通常适合于较小的表，可以完全存放在内存中。</li></ul><pre><code>HT=BuiLd_hash(Rt)For s IN Rs:    if hask_key(s) found in HT:        resuLt.add(t,s)</code></pre><p>通常merge join的效率会比hash join差，但如果两张关联的表已经排序好了，此时就不需要做排序操作，这时merge join的效率就不一定比hash join差了。</p><h4 id="交、并、差和聚合"><a href="#交、并、差和聚合" class="headerlink" title="交、并、差和聚合"></a>交、并、差和聚合</h4><p>交、并、差是涉及到多表的运算，通常用merge join或者 hash join的思想，与之前连接的去标在于在merge或hash的过程汇总去重</p><p>聚合操作也是同理，通常通过merge或hash将同一组中的元组放在一起，然后在每个组内进行相应聚合函数的实现。</p><ul><li>部分聚合，对于count、min、max和sum，可以保留组中目前找到的元组的聚合值。</li><li>当将部分聚合合并为计数时，将部分聚合相加。</li><li>对于avg，保留sum和count，并在最后用sum除以count。</li></ul><h4 id="启发式规则"><a href="#启发式规则" class="headerlink" title="启发式规则"></a>启发式规则</h4><p>在前文介绍的等价规则转换的基础上，加入代价的判断，有些代价不好估计，但有些规则经过长期的验证，已经确认是有效的。如下列举了一些规则，在优化器里面会考虑这些启发式规则带来的优势，尽量去应用这些启发式的规则。</p><ul><li>选择尽量下推</li><li>投影尽早下推</li><li>连接消除避免完全第卡尔积操作</li><li>连接的一个关系在连接属性上有索引，将这关系放在内层循环中采用索引连接</li><li>连接的一个参数是排序的，用merge join可能比hash join好</li><li>多个关系的并或交时，先对最小关系进行组合</li><li>子查询的消除</li><li>嵌套连接的消除</li><li>使用等价调词重写对条件化简</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;对比赛时miniob官方文档的学习，但由于后面miniob迭代过同时官方文档更新不及时，可能有与实际不匹配的地方，但根本原理上是不变的。&lt;/
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://JoyTsing.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://JoyTsing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="教程" scheme="https://JoyTsing.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Boost中Asio网络编程</title>
    <link href="https://joytsing.github.io/posts/24827/"/>
    <id>https://joytsing.github.io/posts/24827/</id>
    <published>2024-04-21T12:52:08.000Z</published>
    <updated>2024-04-21T13:13:29.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>为什么要学这个呢？首先，arpa那套网络编程只能在linux下用，其次，个人觉得C语言风格的接口实在是太丑陋了，第三，cpp的net库提上日程，大概率是boost的asio，所以可以学习一下，别在用老套的接口了。</p><h2 id="Boost-Asio基本原理"><a href="#Boost-Asio基本原理" class="headerlink" title="Boost.Asio基本原理"></a>Boost.Asio基本原理</h2><p>这一章涵盖了使用Boost.Asio时必须知道的一些事情。我们也将深入研究比同步编程更复杂、更有乐趣(迫真)的异步编程。</p><h3 id="网络API"><a href="#网络API" class="headerlink" title="网络API"></a>网络API</h3><p>这一部分包含了当使用Boost.Asio编写网络应用程序时必须知道的事情。</p><h3 id="Boost-Asio命名空间"><a href="#Boost-Asio命名空间" class="headerlink" title="Boost.Asio命名空间"></a>Boost.Asio命名空间</h3><p>Boost.Asio的所有内容都包含在boost::asio命名空间或者其子命名空间内。</p><ul><li><em><code>boost::asio</code></em>：这是核心类和函数所在的地方。重要的类有<code>io_service</code>(现在是<code>io_context</code>)和<code>streambuf</code>。类似<em>read, read_at, read_until</em>方法，它们的异步方法，它们的写方法和异步写方法等自由函数也在这里。</li><li><em><code>boost::asio::ip</code></em>：这是网络通信部分所在的地方。重要的类有<em><code>address</code>, <code>endpoint</code>, <code>tcp</code>, <code>udp</code>和<code>icmp</code></em>，重要的自由函数有<em><code>connect</code></em>和<em><code>async_connect</code></em>。要注意的是在<em><code>boost::asio::ip::tcp::socket</code></em>中间，<em>socket</em>只是<em><code>boost::asio::ip::tcp</code></em>类中间的一个<em>typedef</em>关键字。</li><li><em><code>boost::asio::error</code></em>：这个命名空间包含了调用I/O例程时返回的错误码</li><li><em><code>boost::asio::ssl</code></em>：包含了SSL处理类的命名空间</li><li><em><code>boost::asio::local</code></em>：这个命名空间包含了POSIX特性的类</li><li><em><code>boost::asio::windows</code></em>：这个命名空间包含了Windows特性的类</li></ul><blockquote><p>小tip:  <code>namespace asio = boost::asio;</code> 可以少打<code>boost::</code></p></blockquote><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>对于IP地址的处理，Boost.Asio提供了<em>ip::address , ip::address_v4</em>和<em>ip::address_v6</em>类。 它们提供了相当多的函数。下面列出了最重要的几个：</p><ul><li><em>ip::address(v4_or_v6_address)</em>:这个函数把一个v4或者v6的地址转换成<em>ip::address</em></li><li><em>ip::address::from_string(str)</em>：这个函数根据一个IPv4地址（用.隔开的）或者一个IPv6地址（十六进制表示）创建一个地址。</li><li><em>ip::address::to_string()</em> ：这个函数返回这个地址的字符串。</li><li><em>ip::address_v4::broadcast([addr, mask])</em>:这个函数创建了一个广播地址 <em>ip::address_v4::any()</em>：这个函数返回一个能表示任意地址的地址。</li><li><em>ip::address_v4::loopback(), ip_address_v6::loopback()</em>：这个函数返回环路地址（为v4/v6协议）</li><li><em>ip::host_name()</em>：这个函数用string数据类型返回当前的主机名。</li></ul><p>大多数情况你会选择用<em>ip::address::from_string</em>：</p><pre class="line-numbers language-ruby"><code class="language-ruby">ip<span class="token punctuation">:</span><span class="token symbol">:address</span> addr <span class="token operator">=</span> ip<span class="token punctuation">:</span><span class="token symbol">:address</span><span class="token punctuation">:</span><span class="token symbol">:from_string</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果你想通过一个主机名进行连接，下面的代码片段是无用的：</p><pre class="line-numbers language-php"><code class="language-php"><span class="token comment" spellcheck="true">// 抛出异常</span>ip<span class="token punctuation">:</span><span class="token punctuation">:</span>address addr <span class="token operator">=</span> ip<span class="token punctuation">:</span><span class="token punctuation">:</span>address<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from_string</span><span class="token punctuation">(</span><span class="token string">"www.yahoo.com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="端点"><a href="#端点" class="headerlink" title="端点"></a>端点</h3><p>端点是使用某个端口连接到的一个地址。不同类型的socket有它自己的<em>endpoint<em>类，比如</em>ip::tcp::endpoint、ip::udp::endpoint<em>和</em>ip::icmp::endpoint</em></p><p>如果想连接到本机的80端口，你可以这样做：</p><pre class="line-numbers language-ruby"><code class="language-ruby">ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:endpoint</span> <span class="token function">ep</span><span class="token punctuation">(</span> ip<span class="token punctuation">:</span><span class="token symbol">:address</span><span class="token punctuation">:</span><span class="token symbol">:from_string</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>有三种方式来让你建立一个端点：</p><ul><li><em>endpoint()</em>：这是默认构造函数，某些时候可以用来创建UDP/ICMP socket。</li><li><em>endpoint(protocol, port)</em>：这个方法通常用来创建可以接受新连接的服务器端socket。</li><li><em>endpoint(addr, port)</em>:这个方法创建了一个连接到某个地址和端口的端点。</li></ul><p>例子如下：</p><pre class="line-numbers language-ruby"><code class="language-ruby">ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:endpoint</span> ep1<span class="token punctuation">;</span>ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:endpoint</span> <span class="token function">ep2</span><span class="token punctuation">(</span>ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:v4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:endpoint</span> <span class="token function">ep3</span><span class="token punctuation">(</span> ip<span class="token punctuation">:</span><span class="token symbol">:address</span><span class="token punctuation">:</span><span class="token symbol">:from_string</span><span class="token punctuation">(</span>"<span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果你想连接到一个主机（不是IP地址），你需要这样做：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>string host <span class="token operator">=</span> <span class="token string">"joytsing.cn"</span><span class="token punctuation">;</span>std<span class="token operator">::</span>string port <span class="token operator">=</span> <span class="token string">"3333"</span><span class="token punctuation">;</span>asio<span class="token operator">::</span>io_context ioc<span class="token punctuation">;</span>sio<span class="token operator">::</span>ip<span class="token operator">::</span>tcp<span class="token operator">::</span>resolver<span class="token operator">::</span>query <span class="token function">resolver_query</span><span class="token punctuation">(</span>    host<span class="token punctuation">,</span> port<span class="token punctuation">,</span> asio<span class="token operator">::</span>ip<span class="token operator">::</span>tcp<span class="token operator">::</span>resolver<span class="token operator">::</span>query<span class="token operator">::</span>numeric_service<span class="token punctuation">)</span><span class="token punctuation">;</span>asio<span class="token operator">::</span>ip<span class="token operator">::</span>tcp<span class="token operator">::</span>resolver <span class="token function">resolver</span><span class="token punctuation">(</span>ioc<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    asio<span class="token operator">::</span>ip<span class="token operator">::</span>tcp<span class="token operator">::</span>resolver<span class="token operator">::</span>iterator it <span class="token operator">=</span> resolver<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>resolver_query<span class="token punctuation">)</span><span class="token punctuation">;</span>    asio<span class="token operator">::</span>ip<span class="token operator">::</span>tcp<span class="token operator">::</span>socket <span class="token function">sock</span><span class="token punctuation">(</span>ioc<span class="token punctuation">)</span><span class="token punctuation">;</span>    asio<span class="token operator">::</span><span class="token function">connect</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> it<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>boost<span class="token operator">::</span>system<span class="token operator">::</span>system_error <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"error. error_code = "</span> <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">code</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"message is "</span> <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span>              <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> e<span class="token punctuation">.</span><span class="token function">code</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以用你需要的socket类型来替换tcp。首先，为你想要查询的名字创建一个查询器，然后用resolve()函数解析它。如果成功，它至少会返回一个入口。你可以利用返回的迭代器，使用第一个入口或者遍历整个列表来拿到全部的入口。</p><p>给定一个端点，可以获得他的地址，端口和IP协议（v4或者v6）：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> ep<span class="token punctuation">.</span><span class="token function">address</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">":"</span> <span class="token operator">&lt;&lt;</span> ep<span class="token punctuation">.</span><span class="token function">port</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> <span class="token string">"/"</span> <span class="token operator">&lt;&lt;</span> ep<span class="token punctuation">.</span><span class="token function">protocol</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>Boost.Asio有三种类型的套接字类：<em>ip::tcp, ip::udp</em>和<em>ip::icmp</em>。当然它也是可扩展的，你可以创建自己的socket类，尽管这相当复杂。如果你选择这样做，参照一下<em>boost/asio/ip/tcp.hpp, boost/asio/ip/udp.hpp</em>和<em>boost/asio/ip/icmp.hpp</em>。它们都是含有内部typedef关键字的超小类。</p><p>你可以把<em>ip::tcp, ip::udp, ip::icmp</em>类当作占位符；它们可以让你便捷地访问其他类/函数，如下所示：</p><ul><li><em>ip::tcp::socket, ip::tcp::acceptor, ip::tcp::endpoint,ip::tcp::resolver, ip::tcp::iostream</em></li><li><em>ip::udp::socket, ip::udp::endpoint, ip::udp::resolver</em></li><li><em>ip::icmp::socket, ip::icmp::endpoint, ip::icmp::resolver</em></li></ul><p><em>socket</em>类创建一个相应的<em>socket</em>。而且总是在构造的时候传入io_service(新版本的是io_context，后面不再提示)实例：</p><pre class="line-numbers language-ruby"><code class="language-ruby">io_service service<span class="token punctuation">;</span>ip<span class="token punctuation">:</span><span class="token symbol">:udp</span><span class="token punctuation">:</span><span class="token symbol">:socket</span> <span class="token function">sock</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span>sock<span class="token punctuation">.</span><span class="token function">set_option</span><span class="token punctuation">(</span>ip<span class="token punctuation">:</span><span class="token symbol">:udp</span><span class="token punctuation">:</span><span class="token symbol">:socket</span><span class="token punctuation">:</span><span class="token symbol">:reuse_address</span><span class="token punctuation">(</span><span class="token keyword">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>每一个socket的名字都是一个typedef关键字</p><ul><li><em>ip::tcp::socket = basic_stream_socket<tcp></tcp></em></li><li><em>ip::udp::socket = basic_datagram_socket<udp></udp></em></li><li><em>ip::icmp::socket = basic_raw_socket<icmp></icmp></em></li></ul><h3 id="同步错误码"><a href="#同步错误码" class="headerlink" title="同步错误码"></a>同步错误码</h3><p>所有的同步函数都有抛出异常或者返回错误码的重载，比如下面的代码片段：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">sync_func</span><span class="token punctuation">(</span> arg1<span class="token punctuation">,</span> arg2 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> argN<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 抛出异常</span>boost<span class="token operator">::</span>system<span class="token operator">::</span>error_code ec<span class="token punctuation">;</span><span class="token function">sync_func</span><span class="token punctuation">(</span> arg1 arg2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> argN<span class="token punctuation">,</span> ec<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回错误码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="socket成员方法"><a href="#socket成员方法" class="headerlink" title="socket成员方法"></a>socket成员方法</h3><p>这些方法被分成了几组。并不是所有的方法都可以在各个类型的套接字里使用。这个部分的结尾将有一个列表来展示各个方法分别属于哪个socket类。</p><p>注意所有的异步方法都立刻返回，而它们相对的同步实现需要操作完成之后才能返回。</p><h3 id="连接相关的函数"><a href="#连接相关的函数" class="headerlink" title="连接相关的函数"></a>连接相关的函数</h3><p>这些方法是用来连接或绑定socket、断开socket字连接以及查询连接是活动还是非活动的：</p><ul><li><em>assign(protocol,socket)</em>：这个函数分配了一个原生的socket给这个socket实例。当处理老（旧）程序时会使用它（也就是说，原生socket已经被建立了）</li><li><em>open(protocol)</em>：这个函数用给定的IP协议（v4或者v6）打开一个socket。你主要在UDP/ICMP socket，或者服务端socket上使用。</li><li><em>bind(endpoint)</em>：这个函数绑定到一个地址</li><li><em>connect(endpoint)</em>：这个函数用同步的方式连接到一个地址</li><li><em>async_connect(endpoint)</em>：这个函数用异步的方式连接到一个地址</li><li><em>is_open()</em>：如果套接字已经打开，这个函数返回true</li><li><em>close()</em>：这个函数用来关闭套接字。调用时这个套接字上任何的异步操作都会被立即关闭，同时返回<em>error::operation_aborted</em>错误码。</li><li><em>shutdown(type_of_shutdown)</em>：这个函数立即使send或者receive操作失效，或者两者都失效。</li><li><em>cancel()</em>：这个函数取消套接字上所有的异步操作。这个套接字上任何的异步操作都会立即结束，然后返回<em>error::operation_aborted</em>错误码。</li></ul><p>例子如下：</p><pre class="line-numbers language-ruby"><code class="language-ruby">ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:endpoint</span> <span class="token function">ep</span><span class="token punctuation">(</span> ip<span class="token punctuation">:</span><span class="token symbol">:address</span><span class="token punctuation">:</span><span class="token symbol">:from_string</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:socket</span> <span class="token function">sock</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:v4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> nsock<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>ep<span class="token punctuation">)</span><span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">write_some</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span><span class="token string">"GET /index.html\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>char buff<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span> sock<span class="token punctuation">.</span><span class="token function">read_some</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>buff<span class="token punctuation">,</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span>ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:socket</span><span class="token punctuation">:</span><span class="token symbol">:shutdown_receive</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="读写函数"><a href="#读写函数" class="headerlink" title="读写函数"></a>读写函数</h3><p>这些是在套接字上执行I/O操作的函数。</p><p>对于异步函数来说，处理程序的格式<em>void handler(const boost::system::error_code&amp; e, size_t bytes)</em>都是一样的</p><ul><li><em>async_receive(buffer, [flags,] handler)</em>：这个函数启动从套接字异步接收数据的操作。</li><li><em>async_read_some(buffer,handler)</em>：这个函数和<em>async_receive(buffer, handler)</em>功能一样。</li><li><em>async_receive_from(buffer, endpoint[, flags], handler)</em>：这个函数启动从一个指定端点异步接收数据的操作。</li><li><em>async_send(buffer [, flags], handler)</em>：这个函数启动了一个异步发送缓冲区数据的操作。</li><li><em>async_write_some(buffer, handler)</em>：这个函数和a<em>sync_send(buffer, handler)</em>功能一致。</li><li><em>async_send_to(buffer, endpoint, handler)</em>：这个函数启动了一个异步send缓冲区数据到指定端点的操作。</li><li><em>receive(buffer [, flags])</em>：这个函数异步地从所给的缓冲区读取数据。在读完所有数据或者错误出现之前，这个函数都是阻塞的。</li><li><em>read_some(buffer)</em>：这个函数的功能和<em>receive(buffer)</em>是一致的。</li><li><ul><li>receive_from(buffer, endpoint [, flags])*：这个函数异步地从一个指定的端点获取数据并写入到给定的缓冲区。在读完所有数据或者错误出现之前，这个函数都是阻塞的。</li></ul></li><li><em>send(buffer [, flags])</em>：这个函数同步地发送缓冲区的数据。在所有数据发送成功或者出现错误之前，这个函数都是阻塞的。</li><li><em>write_some(buffer)</em>：这个函数和<em>send(buffer)</em>的功能一致。</li><li><em>send_to(buffer, endpoint [, flags])</em>：这个函数同步地把缓冲区数据发送到一个指定的端点。在所有数据发送成功或者出现错误之前，这个函数都是阻塞的。</li><li><em>available()</em>：这个函数返回有多少字节的数据可以无阻塞地进行同步读取。</li></ul><p>稍后我们将讨论缓冲区。让我们先来了解一下标记。标记的默认值是0，但是也可以是以下几种：</p><ul><li><em>ip::socket_type::socket::message_peek</em>：这个标记只监测并返回某个消息，但是下一次读消息的调用会重新读取这个消息。</li><li><em>ip::socket_type::socket::message_out_of_band</em>：这个标记处理带外（OOB）数据，OOB数据是被标记为比正常数据更重要的数据。关于OOB的讨论在这本书的内容之外。</li><li><em>ip::socket_type::socket::message_do_not_route</em>：这个标记指定数据不使用路由表来发送。</li><li><em>ip::socket_type::socket::message_end_of_record</em>：这个标记指定的数据标识了记录的结束。在Windows下不支持。</li></ul><p>你最常用的可能是<em>message_peek</em>，使用方法请参照下面的代码片段：</p><pre class="line-numbers language-ruby"><code class="language-ruby">char buff<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">receive</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token punctuation">,</span> ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:socket</span><span class="token punctuation">:</span><span class="token symbol">:message_peek</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">memset</span><span class="token punctuation">(</span>buff<span class="token punctuation">,</span><span class="token number">1024</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token operator">/</span> 重新读取之前已经读取过的内容sock<span class="token punctuation">.</span><span class="token function">receive</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面的是一些教你如何同步或异步地从不同类型的套接字上读取数据的例子：</p><ul><li>例1是在一个TCP套接字上进行同步读写：</li></ul><pre class="line-numbers language-ruby"><code class="language-ruby">ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:endpoint</span> <span class="token function">ep</span><span class="token punctuation">(</span> ip<span class="token punctuation">:</span><span class="token symbol">:address</span><span class="token punctuation">:</span><span class="token symbol">:from_string</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:socket</span> <span class="token function">sock</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>ep<span class="token punctuation">)</span><span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">write_some</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span><span class="token string">"GET /index.html\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token punctuation">:</span><span class="token symbol">:cout</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"bytes available "</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> sock<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> std<span class="token punctuation">:</span><span class="token symbol">:endl</span><span class="token punctuation">;</span>char buff<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>size_t read <span class="token operator">=</span> sock<span class="token punctuation">.</span><span class="token function">read_some</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>例2是在一个UDP套接字上进行同步读写：</li></ul><pre class="line-numbers language-css"><code class="language-css"><span class="token property">ip</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">udp</span><span class="token punctuation">:</span><span class="token punctuation">:</span>socket <span class="token function">sock</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span>sock<span class="token number">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token property">ip</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">udp</span><span class="token punctuation">:</span><span class="token punctuation">:</span>v<span class="token number">4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token property">ip</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">udp</span><span class="token punctuation">:</span><span class="token punctuation">:</span>endpoint receiver_<span class="token function">ep</span><span class="token punctuation">(</span><span class="token string">"87.248.112.181"</span>, <span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sock<span class="token number">.</span>send_<span class="token function">to</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span><span class="token string">"testing\n"</span><span class="token punctuation">)</span>, receiver_ep<span class="token punctuation">)</span><span class="token punctuation">;</span>char buff[<span class="token number">512</span>]<span class="token punctuation">;</span><span class="token property">ip</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">udp</span><span class="token punctuation">:</span><span class="token punctuation">:</span>endpoint sender_ep<span class="token punctuation">;</span>sock<span class="token number">.</span>receive_<span class="token function">from</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span>, sender_ep<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>[？注意：就像上述代码片段所展示的那样，使用receive_from从一个UDP套接字读取数据时，你需要构造一个默认的端点]</em></p><ul><li>例3是从一个UDP服务套接字中异步读取数据：</li></ul><pre class="line-numbers language-php"><code class="language-php">using <span class="token keyword">namespace</span> <span class="token package">boost</span><span class="token punctuation">:</span><span class="token punctuation">:</span>asio<span class="token punctuation">;</span>io_service service<span class="token punctuation">;</span>ip<span class="token punctuation">:</span><span class="token punctuation">:</span>udp<span class="token punctuation">:</span><span class="token punctuation">:</span>socket <span class="token function">sock</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span>boost<span class="token punctuation">:</span><span class="token punctuation">:</span>asio<span class="token punctuation">:</span><span class="token punctuation">:</span>ip<span class="token punctuation">:</span><span class="token punctuation">:</span>udp<span class="token punctuation">:</span><span class="token punctuation">:</span>endpoint sender_ep<span class="token punctuation">;</span>char buff<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>void <span class="token function">on_read</span><span class="token punctuation">(</span><span class="token keyword">const</span> boost<span class="token punctuation">:</span><span class="token punctuation">:</span>system<span class="token punctuation">:</span><span class="token punctuation">:</span>error_code <span class="token operator">&amp;</span> err<span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>size_t read_bytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"read "</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> read_bytes <span class="token operator">&lt;</span><span class="token operator">&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>    sock<span class="token punctuation">.</span><span class="token function">async_receive_from</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token punctuation">,</span> sender_ep<span class="token punctuation">,</span> on_read<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>int <span class="token function">main</span><span class="token punctuation">(</span>int argc<span class="token punctuation">,</span> char<span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ip<span class="token punctuation">:</span><span class="token punctuation">:</span>udp<span class="token punctuation">:</span><span class="token punctuation">:</span>endpoint <span class="token function">ep</span><span class="token punctuation">(</span>ip<span class="token punctuation">:</span><span class="token punctuation">:</span>address<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from_string</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">8001</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sock<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>ep<span class="token punctuation">.</span><span class="token function">protocol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sock<span class="token punctuation">.</span><span class="token function">set_option</span><span class="token punctuation">(</span>boost<span class="token punctuation">:</span><span class="token punctuation">:</span>asio<span class="token punctuation">:</span><span class="token punctuation">:</span>ip<span class="token punctuation">:</span><span class="token punctuation">:</span>udp<span class="token punctuation">:</span><span class="token punctuation">:</span>socket<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">reuse_address</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sock<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>ep<span class="token punctuation">)</span><span class="token punctuation">;</span>    sock<span class="token punctuation">.</span><span class="token function">async_receive_from</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>buff<span class="token punctuation">,</span><span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">,</span> sender_ep<span class="token punctuation">,</span> on_read<span class="token punctuation">)</span><span class="token punctuation">;</span>    service<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="套接字控制："><a href="#套接字控制：" class="headerlink" title="套接字控制："></a>套接字控制：</h3><p>这些函数用来处理套接字的高级选项：</p><ul><li><em>get_io_service()</em>：这个函数返回构造函数中传入的io_service实例</li><li><em>get_option(option)</em>：这个函数返回一个套接字的属性</li><li><em>set_option(option)</em>：这个函数设置一个套接字的属性</li><li><em>io_control(cmd)</em>：这个函数在套接字上执行一个I/O指令</li></ul><p>这些是你可以获取/设置的套接字选项：</p><table><thead><tr><th>名字</th><th>描述</th><th>类型</th></tr></thead><tbody><tr><td>broadcast</td><td>如果为true，允许广播消息</td><td>bool</td></tr><tr><td>debug</td><td>如果为true，启用套接字级别的调试</td><td>bool</td></tr><tr><td>do_not_route</td><td>如果为true，则阻止路由选择只使用本地接口</td><td>bool</td></tr><tr><td>enable_connection_aborted</td><td>如果为true，记录在accept()时中断的连接</td><td>bool</td></tr><tr><td>keep_alive</td><td>如果为true，会发送心跳</td><td>bool</td></tr><tr><td>linger</td><td>如果为true，套接字会在有未发送数据的情况下挂起close()</td><td>bool</td></tr><tr><td>receive_buffer_size</td><td>套接字接收缓冲区大小</td><td>int</td></tr><tr><td>receive_low_watemark</td><td>规定套接字输入处理的最小字节数</td><td>int</td></tr><tr><td>reuse_address</td><td>如果为true，套接字能绑定到一个已用的地址</td><td>bool</td></tr><tr><td>send_buffer_size</td><td>套接字发送缓冲区大小</td><td>int</td></tr><tr><td>send_low_watermark</td><td>规定套接字数据发送的最小字节数</td><td>int</td></tr><tr><td>ip::v6_only</td><td>如果为true，则只允许IPv6的连接</td><td>bool</td></tr></tbody></table><p>每个名字代表了一个内部套接字typedef或者类。下面是对它们的使用：</p><pre class="line-numbers language-ruby"><code class="language-ruby">ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:endpoint</span> <span class="token function">ep</span><span class="token punctuation">(</span> ip<span class="token punctuation">:</span><span class="token symbol">:address</span><span class="token punctuation">:</span><span class="token symbol">:from_string</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:socket</span> <span class="token function">sock</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>ep<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token operator">/</span> <span class="token constant">TCP</span>套接字可以重用地址ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:socket</span><span class="token punctuation">:</span><span class="token symbol">:reuse_address</span> <span class="token function">ra</span><span class="token punctuation">(</span><span class="token keyword">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">set_option</span><span class="token punctuation">(</span>ra<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token operator">/</span> 获取套接字读取的数据ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:socket</span><span class="token punctuation">:</span><span class="token symbol">:receive_buffer_size</span> rbs<span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">get_option</span><span class="token punctuation">(</span>rbs<span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token punctuation">:</span><span class="token symbol">:cout</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> rbs<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> std<span class="token punctuation">:</span><span class="token symbol">:endl</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token operator">/</span> 把套接字的缓冲区大小设置为<span class="token number">8192</span>ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:socket</span><span class="token punctuation">:</span><span class="token symbol">:send_buffer_size</span> <span class="token function">sbs</span><span class="token punctuation">(</span><span class="token number">8192</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">set_option</span><span class="token punctuation">(</span>sbs<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>[?在上述特性工作之前，套接字要被打开。否则，会抛出异常]</em></p><h3 id="TCP-VS-UDP-VS-ICMP"><a href="#TCP-VS-UDP-VS-ICMP" class="headerlink" title="TCP VS UDP VS ICMP"></a>TCP VS UDP VS ICMP</h3><p>就像我之前所说，不是所有的成员方法在所有的套接字类中都可用。我做了一个包含成员函数不同点的列表。如果一个成员函数没有出现在这，说明它在所有的套接字类都是可用的。</p><table><thead><tr><th>名字</th><th>TCP</th><th>UDP</th><th>ICMP</th></tr></thead><tbody><tr><td>async_read_some</td><td>是</td><td>-</td><td>-</td></tr><tr><td>async_receive_from</td><td>-</td><td>是</td><td>是</td></tr><tr><td>async_write_some</td><td>是</td><td>-</td><td>-</td></tr><tr><td>async_send_to</td><td>-</td><td>是</td><td>是</td></tr><tr><td>read_some</td><td>是</td><td>-</td><td>-</td></tr><tr><td>receive_from</td><td>-</td><td>是</td><td>是</td></tr><tr><td>write_some</td><td>是</td><td>-</td><td>-</td></tr><tr><td>send_to</td><td>-</td><td>是</td><td>是</td></tr></tbody></table><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p>其他与连接和I/O无关的函数如下：</p><ul><li><em>local_endpoint()</em>：这个方法返回套接字本地连接的地址。</li><li><em>remote_endpoint()</em>：这个方法返回套接字连接到的远程地址。</li><li><em>native_handle()</em>：这个方法返回原始套接字的处理程序。你只有在调用一个Boost.Asio不支持的原始方法时才需要用到它。</li><li><em>non_blocking()</em>：如果套接字是非阻塞的，这个方法返回true，否则false。</li><li><em>native_non_blocking()</em>：如果套接字是非阻塞的，这个方法返回true，否则返回false。但是，它是基于原生的套接字来调用本地的api。所以通常来说，你不需要调用这个方法（non_blocking()已经缓存了这个结果）；你只有在直接调用native_handle()这个方法的时候才需要用到这个方法。</li><li><em>at_mark()</em>：如果套接字要读的是一段OOB数据，这个方法返回true。这个方法你很少会用到。</li></ul><h3 id="其他需要考虑的事情"><a href="#其他需要考虑的事情" class="headerlink" title="其他需要考虑的事情"></a>其他需要考虑的事情</h3><p>最后要注意的一点，套接字实例不能被拷贝，因为拷贝构造方法和＝操作符是不可访问的。</p><pre class="line-numbers language-ruby"><code class="language-ruby">ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:socket</span> <span class="token function">s1</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">s2</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span>s1 <span class="token operator">=</span> s2<span class="token punctuation">;</span> <span class="token operator">/</span><span class="token operator">/</span> 编译时报错ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:socket</span> <span class="token function">s3</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">/</span><span class="token operator">/</span> 编译时报错<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这是非常有意义的，因为每一个实例都拥有并管理着一个资源（原生套接字本身）。如果我们允许拷贝构造，结果是我们会有两个实例拥有同样的原生套接字；这样我们就需要去处理所有者的问题（让一个实例拥有所有权？或者使用引用计数？还是其他的方法）Boost.Asio选择不允许拷贝（如果你想要创建一个备份，请使用共享指针）</p><pre class="line-numbers language-php"><code class="language-php">typedef boost<span class="token punctuation">:</span><span class="token punctuation">:</span>shared_ptr<span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">ip:</span>:tcp::socket</span><span class="token punctuation">></span></span></span> socket_ptr<span class="token punctuation">;</span>socket_ptr <span class="token function">sock1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ip</span><span class="token punctuation">:</span><span class="token punctuation">:</span>tcp<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">socket</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>socket_ptr <span class="token function">sock2</span><span class="token punctuation">(</span>sock1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok</span>socket_ptr sock3<span class="token punctuation">;</span>           sock3 <span class="token operator">=</span> sock1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="套接字缓冲区"><a href="#套接字缓冲区" class="headerlink" title="套接字缓冲区"></a>套接字缓冲区</h3><p>当从一个套接字读写内容时，你需要一个缓冲区，用来保存读取和写入的数据。缓冲区内存的有效时间必须比I/O操作的时间要长；你需要保证它们在I/O操作结束之前不被释放。 对于同步操作来说，这很容易；当然，这个缓冲区在receive和send时都存在。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">char</span> buff<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>sock<span class="token punctuation">.</span><span class="token function">receive</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">strcpy</span><span class="token punctuation">(</span>buff<span class="token punctuation">,</span> <span class="token string">"ok\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是在异步操作时就没这么简单了，看下面的代码片段：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 非常差劲的代码 ...</span><span class="token keyword">void</span> <span class="token function">on_read</span><span class="token punctuation">(</span><span class="token keyword">const</span> boost<span class="token operator">::</span>system<span class="token operator">::</span>error_code <span class="token operator">&amp;</span> err<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t read_bytes<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> buff<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    sock<span class="token punctuation">.</span><span class="token function">async_receive</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token punctuation">,</span> on_read<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在我们调用<em>async_receive()</em>之后，buff就已经超出有效范围，它的内存当然会被释放。当我们开始从套接字接收一些数据时，我们会把它们拷贝到一片已经不属于我们的内存中；它可能会被释放，或者被其他代码重新开辟来存入其他的数据，结果就是：内存冲突。</p><p>对于上面的问题有几个解决方案：</p><ul><li>使用全局缓冲区</li><li>创建一个缓冲区，然后在操作结束时释放它</li><li>使用一个集合对象管理这些套接字和其他的数据，比如缓冲区数组</li></ul><p>第一个方法显然不是很好，因为我们都知道全局变量非常不好。此外，如果两个实例使用同一个缓冲区怎么办？</p><p>下面是第二种方式的实现：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">on_read</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span> ptr<span class="token punctuation">,</span> <span class="token keyword">const</span> boost<span class="token operator">::</span>system<span class="token operator">::</span>error_code <span class="token operator">&amp;</span> err<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t read_bytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>                           <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ptr<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">char</span> <span class="token operator">*</span> buff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">async_receive</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>buff<span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">,</span> boost<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>on_read<span class="token punctuation">,</span>buff<span class="token punctuation">,</span>_1<span class="token punctuation">,</span>_2<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者，如果你想要缓冲区在操作结束后自动超出范围，使用共享指针</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> shared_buffer <span class="token punctuation">{</span>    boost<span class="token operator">::</span>shared_array<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> buff<span class="token punctuation">;</span>    <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token function">shared_buffer</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">buff</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">size</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    mutable_buffers_1 <span class="token function">asio_buff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">buffer</span><span class="token punctuation">(</span>buff<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 当on_read超出范围时, boost::bind对象被释放了,</span><span class="token comment" spellcheck="true">// 同时也会释放共享指针</span><span class="token keyword">void</span> <span class="token function">on_read</span><span class="token punctuation">(</span>shared_buffer<span class="token punctuation">,</span> <span class="token keyword">const</span> boost<span class="token operator">::</span>system<span class="token operator">::</span>error_code <span class="token operator">&amp;</span> err<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t read_bytes<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>sock<span class="token punctuation">.</span><span class="token function">async_receive</span><span class="token punctuation">(</span>buff<span class="token punctuation">.</span><span class="token function">asio_buff</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> boost<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>on_read<span class="token punctuation">,</span>buff<span class="token punctuation">,</span>_1<span class="token punctuation">,</span>_2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>shared_buffer类拥有实质的<em>shared_array&lt;&gt;</em>，<em>shared_array&lt;&gt;</em>存在的目的是用来保存<em>shared_buffer</em>实例的拷贝－当最后一个<em>share_array&lt;&gt;</em>元素超出范围时，<em>shared_array&lt;&gt;</em>就被自动销毁了，而这就是我们想要的结果。</p><p>因为Boost.Asio会给完成处理句柄保留一个拷贝，当操作完成时就会调用这个完成处理句柄，所以你的目的达到了。那个拷贝是一个boost::bind的仿函数，它拥有着实际的<em>shared_buffer</em>实例。这是非常优雅的！</p><p>第三个选择是使用一个连接对象来管理套接字和其他数据，比如缓冲区，通常来说这是正确的解决方案但是非常复杂。在这一章的末尾我们会对这种方法进行讨论。</p><h3 id="缓冲区封装函数"><a href="#缓冲区封装函数" class="headerlink" title="缓冲区封装函数"></a>缓冲区封装函数</h3><p>纵观所有代码，你会发现：无论什么时候，当我们需要对一个buffer进行读写操作时，代码会把实际的缓冲区对象封装在一个buffer()方法中，然后再把它传递给方法调用：</p><pre class="line-numbers language-css"><code class="language-css">char buff[<span class="token number">512</span>]<span class="token punctuation">;</span>sock<span class="token number">.</span>async_<span class="token function">receive</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span>, on_read<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>基本上我们都会把缓冲区包含在一个类中以便Boost.Asio的方法能遍历这个缓冲区，比方说，使用下面的代码：</p><pre class="line-numbers language-css"><code class="language-css">sock<span class="token number">.</span>async_<span class="token function">receive</span><span class="token punctuation">(</span>some_buffer, on_read<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>实例<em>some_buffer</em>需要满足一些需求，叫做<em>ConstBufferSequence</em>或者<em>MutableBufferSequence</em>（你可以在Boost.Asio的文档中查看它们）。创建你自己的类去处理这些需求的细节是非常复杂的，但是Boost.Asio已经提供了一些类用来处理这些需求。所以你不用直接访问这些缓冲区，而可以使用<em>buffer()</em>方法。</p><p>自信地讲，你可以把下面列出来的类型都包装到一个buffer()方法中：</p><ul><li>一个char[] const 数组</li><li>一个字节大小的void *指针</li><li>一个std::string类型的字符串</li><li>一个POD const数组（POD代表纯数据，这意味着构造器和释放器不做任何操作）</li><li>一个pod数据的std::vector</li><li>一个包含pod数据的boost::array</li><li>一个包含pod数据的std::array</li></ul><p>下面的代码都是有效的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> pod_sample <span class="token punctuation">{</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span> <span class="token keyword">long</span> l<span class="token punctuation">;</span> <span class="token keyword">char</span> c<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">char</span> b1<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span> b2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>std<span class="token operator">::</span>string b3<span class="token punctuation">;</span> b3<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pod_sample b4<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>pod_sample<span class="token operator">></span> b5<span class="token punctuation">;</span> b5<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>boost<span class="token operator">::</span>array<span class="token operator">&lt;</span>pod_sample<span class="token punctuation">,</span><span class="token number">16</span><span class="token operator">></span> b6<span class="token punctuation">;</span>std<span class="token operator">::</span>array<span class="token operator">&lt;</span>pod_sample<span class="token punctuation">,</span><span class="token number">16</span><span class="token operator">></span> b7<span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">async_send</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>b1<span class="token punctuation">)</span><span class="token punctuation">,</span> on_read<span class="token punctuation">)</span><span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">async_send</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>b2<span class="token punctuation">,</span><span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">,</span> on_read<span class="token punctuation">)</span><span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">async_send</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>b3<span class="token punctuation">)</span><span class="token punctuation">,</span> on_read<span class="token punctuation">)</span><span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">async_send</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>b4<span class="token punctuation">)</span><span class="token punctuation">,</span> on_read<span class="token punctuation">)</span><span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">async_send</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>b5<span class="token punctuation">)</span><span class="token punctuation">,</span> on_read<span class="token punctuation">)</span><span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">async_send</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>b6<span class="token punctuation">)</span><span class="token punctuation">,</span> on_read<span class="token punctuation">)</span><span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">async_send</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>b7<span class="token punctuation">)</span><span class="token punctuation">,</span> on_read<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总的来说就是：与其创建你自己的类来处理<em>ConstBufferSequence</em>或者<em>MutableBufferSequence</em>的需求，不如创建一个能在你需要的时候保留缓冲区，然后返回一个mutable_buffers_1实例的类，而我们早在shared_buffer类中就这样做了。</p><h3 id="read-write-connect自由函数"><a href="#read-write-connect自由函数" class="headerlink" title="read/write/connect自由函数"></a>read/write/connect自由函数</h3><p>Boost.Asio提供了处理I/O的自由函数，我们分四组来分析它们。</p><h4 id="connect方法"><a href="#connect方法" class="headerlink" title="connect方法"></a>connect方法</h4><p>这些方法把套接字连接到一个端点。</p><ul><li><em>connect(socket, begin [, end] [, condition])</em>：这个方法遍历队列中从start到end的端点来尝试同步连接。begin迭代器是调用<em>socket_type::resolver::query</em>的返回结果（你可能需要回顾一下端点这个章节）。特别提示end迭代器是可选的；你可以忽略它。你还可以提供一个condition的方法给每次连接尝试之后调用。用法是<em>Iterator connect_condition(const boost::system::error_code &amp; err,Iterator next);</em>。你可以选择返回一个不是<em>next</em>的迭代器，这样你就可以跳过一些端点。</li><li><em>async_connect(socket, begin [, end] [, condition], handler)</em>：这个方法异步地调用连接方法，在结束时，它会调用完成处理方法。用法是<em>void handler(constboost::system::error_code &amp; err, Iterator iterator);</em>。传递给处理方法的第二个参数是连接成功端点的迭代器（或者end迭代器）。</li></ul><p>它的例子如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> <span class="token keyword">namespace</span> boost<span class="token operator">::</span>asio<span class="token operator">::</span>ip<span class="token punctuation">;</span>tcp<span class="token operator">::</span>resolver <span class="token function">resolver</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span>tcp<span class="token operator">::</span>resolver<span class="token operator">::</span>iterator iter <span class="token operator">=</span> resolver<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>tcp<span class="token operator">::</span>resolver<span class="token operator">::</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token string">"www.yahoo.com"</span><span class="token punctuation">,</span><span class="token string">"80"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>tcp<span class="token operator">::</span>socket <span class="token function">sock</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">connect</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> iter<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个主机名可以被解析成多个地址，而<em>connect</em>和<em>async_connect</em>能很好地把你从尝试每个地址然后找到一个可用地址的繁重工作中解放出来，因为它们已经帮你做了这些。</p><h4 id="read-write方法"><a href="#read-write方法" class="headerlink" title="read/write方法"></a>read/write方法</h4><p>这些方法对一个流进行读写操作（可以是套接字，或者其他表现得像流的类）：</p><ul><li><em>async_read(stream, buffer [, completion] ,handler)<em>：这个方法异步地从一个流读取。结束时其处理方法被调用。处理方法的格式是：</em>void handler(const boost::system::error_ code &amp; err, size_t bytes)</em>;。你可以选择指定一个完成处理方法。完成处理方法会在每个<em>read<em>操作调用成功之后调用，然后告诉Boost.Asio *async_read</em>操作是否完成（如果没有完成，它会继续读取）。它的格式是：*size_t completion(const boost::system::error_code&amp; err, size_t bytes_transfered)</em> 。当这个完成处理方法返回0时，我们认<em>为read</em>操作完成；如果它返回一个非0值，它表示了下一个<em>async_read_some</em>操作需要从流中读取的字节数。接下来会有一个例子来详细展示这些。</li><li><em>async_write(stream, buffer [, completion], handler)</em>：这个方法异步地向一个流写入数据。参数的意义和<em>async_read</em>是一样的。</li><li><em>read(stream, buffer [, completion])</em>：这个方法同步地从一个流中读取数据。参数的意义和<em>async_read</em>是一样的。</li><li><em>write(stream, buffer [, completion])</em>: 这个方法同步地向一个流写入数据。参数的意义和<em>async_read</em>是一样的。</li></ul><pre class="line-numbers language-css"><code class="language-css">async_<span class="token function">read</span><span class="token punctuation">(</span>stream, stream_buffer [, completion], handler<span class="token punctuation">)</span>async_<span class="token function">write</span><span class="token punctuation">(</span>strean, stream_buffer [, completion], handler<span class="token punctuation">)</span><span class="token function">write</span><span class="token punctuation">(</span>stream, stream_buffer [, completion]<span class="token punctuation">)</span><span class="token function">read</span><span class="token punctuation">(</span>stream, stream_buffer [, completion]<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>首先，要注意第一个参数变成了流，而不单是socket。这个参数包含了socket但不仅仅是socket。比如，你可以用一个Windows的文件句柄来替代socket。 当下面情况出现时，所有read和write操作都会结束：</p><ul><li>可用的缓冲区满了（当读取时）或者所有的缓冲区已经被写入（当写入时）</li><li>完成处理方法返回0（如果你提供了这么一个方法）</li><li>错误发生时</li></ul><p>下面的代码会异步地从一个socket中间读取数据直到读取到’\n’：</p><pre class="line-numbers language-cpp"><code class="language-cpp">io_service service<span class="token punctuation">;</span>ip<span class="token operator">::</span>tcp<span class="token operator">::</span>socket <span class="token function">sock</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span> buff<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> offset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>size_t <span class="token function">up_to_enter</span><span class="token punctuation">(</span><span class="token keyword">const</span> boost<span class="token operator">::</span>system<span class="token operator">::</span>error_code <span class="token operator">&amp;</span><span class="token punctuation">,</span> size_t bytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bytes<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> buff<span class="token punctuation">[</span>i <span class="token operator">+</span> offset<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'\n'</span><span class="token punctuation">)</span>             <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">on_read</span><span class="token punctuation">(</span><span class="token keyword">const</span> boost<span class="token operator">::</span>system<span class="token operator">::</span>error_code <span class="token operator">&amp;</span><span class="token punctuation">,</span> size_t<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">async_read</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> <span class="token function">buffer</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token punctuation">,</span> up_to_enter<span class="token punctuation">,</span> on_read<span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Boost.Asio也提供了一些简单的完成处理仿函数：</p><ul><li>transfer_at_least(n)</li><li>transfer_exactly(n)</li><li>transfer_all()</li></ul><p>例子如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">char</span> buff<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">on_read</span><span class="token punctuation">(</span><span class="token keyword">const</span> boost<span class="token operator">::</span>system<span class="token operator">::</span>error_code <span class="token operator">&amp;</span><span class="token punctuation">,</span> size_t<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 读取32个字节 </span><span class="token function">async_read</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> <span class="token function">buffer</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">transfer_exactly</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">,</span> on_read<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上述的4个方法，不使用普通的缓冲区，而使用由Boost.Asio的<em>std::streambuf</em>类继承来的<em>stream_buffer</em>方法。stl流和流缓冲区非常复杂；下面是例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp">io_service service<span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">on_read</span><span class="token punctuation">(</span>streambuf<span class="token operator">&amp;</span> buf<span class="token punctuation">,</span> <span class="token keyword">const</span> boost<span class="token operator">::</span>system<span class="token operator">::</span>error_code <span class="token operator">&amp;</span><span class="token punctuation">,</span> size_t<span class="token punctuation">)</span> <span class="token punctuation">{</span>     std<span class="token operator">::</span>istream <span class="token function">in</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>string line<span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">getline</span><span class="token punctuation">(</span>in<span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"first line: "</span> <span class="token operator">&lt;&lt;</span> line <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     HANDLE file <span class="token operator">=</span> <span class="token operator">::</span><span class="token function">CreateFile</span><span class="token punctuation">(</span><span class="token string">"readme.txt"</span><span class="token punctuation">,</span> GENERIC_READ<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> OPEN_ALWAYS<span class="token punctuation">,</span> FILE_ATTRIBUTE_NORMAL <span class="token operator">|</span> FILE_FLAG_OVERLAPPED<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    windows<span class="token operator">::</span>stream_handle <span class="token function">h</span><span class="token punctuation">(</span>service<span class="token punctuation">,</span> file<span class="token punctuation">)</span><span class="token punctuation">;</span>    streambuf buf<span class="token punctuation">;</span>    <span class="token function">async_read</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token function">transfer_exactly</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">,</span> boost<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>on_read<span class="token punctuation">,</span>boost<span class="token operator">::</span><span class="token function">ref</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span>_1<span class="token punctuation">,</span>_2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    service<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里，我向你们展示了如何在一个Windows文件句柄上调用<em>async_read</em>。读取前256个字符，然后把它们保存到缓冲区中，当操作结束时。<em>on_read</em>被调用，再创建<em>std::istream</em>用来传递缓冲区，读取第一行（<em>std::getline</em>），最后把它输出到命令行中。</p><h4 id="read-until-async-read-until方法"><a href="#read-until-async-read-until方法" class="headerlink" title="read_until/async_read_until方法"></a>read_until/async_read_until方法</h4><p>这些方法在条件满足之前会一直读取：</p><ul><li><em>async_read_until(stream, stream_buffer, delim, handler)</em>:这个方法启动一个异步<em>read</em>操作。<em>read</em>操作会在读取到某个分隔符时结束。分隔符可以是字符,<em>std::string</em>或者<em>boost::regex</em>。处理方法的格式为：<em>void handler(const boost::system::error_code &amp; err, size_t bytes);</em>。</li><li><em>async_read_until(strem, stream_buffer, completion, handler)</em>：这个方法和之前的方法是一样的，但是没有分隔符，而是一个完成处理方法。完成处理方法的格式为：<em>pair&lt; iterator,bool &gt; completion(iterator begin, iterator end);</em>，其中迭代器的类型为<em>buffers_iterator&lt; streambuf::const_buffers_type &gt;</em>。你需要记住的是这个迭代器是支持随机访问的。你扫描整个区间（begin，end），然后决定read操作是否应该结束。返回的结果是一个结果对，第一个成员是一个迭代器，它指向最后被这个方法访问的字符；第二个成员指定read操作是否需要结束，需要时返回true，否则返回false。</li><li><em>read_until(stream, stream_buffer, delim)</em>：这个方法执行一个同步的<em>read</em>操作，参数的意义和<em>async_read_until</em>一样。</li><li><em>read_until(stream, stream_buffer, completion)</em>：这个方法执行一个同步的read操作，参数的意义和<em>async_read_until</em>一样。</li></ul><p>下面这个例子在读到一个指定的标点符号之前会一直读取：</p><pre class="line-numbers language-ruby"><code class="language-ruby">typedef buffers_iterator<span class="token operator">&lt;</span>streambuf<span class="token punctuation">:</span><span class="token symbol">:const_buffers_type</span><span class="token operator">></span> iterator<span class="token punctuation">;</span>std<span class="token punctuation">:</span><span class="token symbol">:pair</span><span class="token operator">&lt;</span>iterator<span class="token punctuation">,</span> bool<span class="token operator">></span> <span class="token function">match_punct</span><span class="token punctuation">(</span>iterator <span class="token keyword">begin</span><span class="token punctuation">,</span> iterator <span class="token keyword">end</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token keyword">begin</span> <span class="token operator">!=</span> <span class="token keyword">end</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> std<span class="token punctuation">:</span><span class="token symbol">:ispunct</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">begin</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> std<span class="token punctuation">:</span><span class="token symbol">:make_pair</span><span class="token punctuation">(</span><span class="token keyword">begin</span><span class="token punctuation">,</span><span class="token keyword">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> std<span class="token punctuation">:</span><span class="token symbol">:make_pair</span><span class="token punctuation">(</span><span class="token keyword">end</span><span class="token punctuation">,</span><span class="token keyword">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>void <span class="token function">on_read</span><span class="token punctuation">(</span>const boost<span class="token punctuation">:</span><span class="token symbol">:system</span><span class="token punctuation">:</span><span class="token symbol">:error_code</span> <span class="token operator">&amp;</span><span class="token punctuation">,</span> size_t<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>streambuf buf<span class="token punctuation">;</span><span class="token function">async_read_until</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> match_punct<span class="token punctuation">,</span> on_read<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果我们想读到一个空格时就结束，我们需要把最后一行修改为：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token function">async_read_until</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> buff<span class="token punctuation">,</span> <span class="token string">' '</span><span class="token punctuation">,</span> on_read<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="at方法"><a href="#at方法" class="headerlink" title="*_at方法"></a>*_at方法</h4><p>这些方法用来在一个流上面做随机存取操作。由你来指定<em>read</em>和<em>write</em>操作从什么地方开始（<em>offset</em>）：</p><ul><li><em>async_read_at(stream, offset, buffer [, completion], handler)</em>：这个方法在指定的流的offset处开始执行一个异步的read操作，当操作结束时，它会调用handler。handler的格式为：<em>void handler(const boost::system::error_code&amp; err, size_t bytes);</em>。<em>buffer</em>可以是普通的<em>wrapper()</em>封装或者<em>streambuf</em>方法。如果你指定一个completion方法，它会在每次read操作成功之后调用，然后告诉Boost.Asio <em>async_read_at</em>操作已经完成（如果没有，则继续读取）。它的格式为：<em>size_t completion(const boost::system::error_code&amp; err, size_t bytes);</em>。当completion方法返回0时，我们认为<em>read</em>操作完成了；如果返回一个非零值，它代表了下一次调用流的<em>async_read_some_at</em>方法的最大读取字节数。</li><li><em>async_write_at(stream, offset, buffer [, completion], handler)</em>：这个方法执行一个异步的write操作。参数的意义和<em>async_read_at</em>是一样的</li><li><em>read_at(stream, offset, buffer [, completion])</em>：这个方法在一个执行的流上，指定的<em>offset</em>处开始read。参数的意义和<em>async_read_at</em>是一样的</li><li><em>write_at(stream, offset, buffer [, completion])</em>：这个方法在一个执行的流上，指定的<em>offset</em>处开始write。参数的意义和<em>async_read_at</em>是一样的</li></ul><p>这些方法不支持套接字。它们用来处理流的随机访问；也就是说，流是可以随机访问的。套接字显然不是这样（套接字是不可回溯的）。</p><p>下面这个例子告诉你怎么从一个文件偏移为256的位置读取128个字节：</p><pre class="line-numbers language-cpp"><code class="language-cpp">io_service service<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    HANDLE file <span class="token operator">=</span> <span class="token operator">::</span><span class="token function">CreateFile</span><span class="token punctuation">(</span><span class="token string">"readme.txt"</span><span class="token punctuation">,</span> GENERIC_READ<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> OPEN_ALWAYS<span class="token punctuation">,</span> FILE_ATTRIBUTE_NORMAL <span class="token operator">|</span> FILE_FLAG_OVERLAPPED<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    windows<span class="token operator">::</span>random_access_handle <span class="token function">h</span><span class="token punctuation">(</span>service<span class="token punctuation">,</span> file<span class="token punctuation">)</span><span class="token punctuation">;</span>    streambuf buf<span class="token punctuation">;</span>    <span class="token function">read_at</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token function">transfer_exactly</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>istream <span class="token function">in</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>string line<span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">getline</span><span class="token punctuation">(</span>in<span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"first line: "</span> <span class="token operator">&lt;&lt;</span> line <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h3><p>这部分对异步编程时可能碰到的一些问题进行了深入的探究。我建议你先读一遍，然后在接下来读这本书的过程中，再经常回过头来看看，从而增强你对这部分的理解。</p><h4 id="异步的需求"><a href="#异步的需求" class="headerlink" title="异步的需求"></a>异步的需求</h4><p>就像我之前所说的，同步编程比异步编程简单很多。这是因为，线性的思考是很简单的（调用A，调用A结束，调用B，调用B结束，然后继续，这是以事件处理的方式来思考）。后面你会碰到这种情况，比如：五件事情，你不知道它们执行的顺序，也不知道他们是否会执行！</p><p>尽管异步编程更难，但是你会更倾向于选择使用它，比如：写一个需要处理很多并发访问的服务端。并发访问越多，异步编程就比同步编程越简单。</p><p>假设：你有一个需要处理1000个并发访问的应用，从客户端发给服务端的每个信息都会再返回给客户端，以‘\n’结尾。</p><p>同步方式的代码，1个线程：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> <span class="token keyword">namespace</span> boost<span class="token operator">::</span>asio<span class="token punctuation">;</span><span class="token keyword">struct</span> client <span class="token punctuation">{</span>    ip<span class="token operator">::</span>tcp<span class="token operator">::</span>socket sock<span class="token punctuation">;</span>    <span class="token keyword">char</span> buff<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 每个信息最多这么大</span>    <span class="token keyword">int</span> already_read<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 你已经读了多少</span><span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>client<span class="token operator">></span> clients<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">handle_clients</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token boolean">true</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> clients<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> clients<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sock<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token function">on_read</span><span class="token punctuation">(</span>clients<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">on_read</span><span class="token punctuation">(</span>client <span class="token operator">&amp;</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> to_read <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">min</span><span class="token punctuation">(</span> <span class="token number">1024</span> <span class="token operator">-</span> c<span class="token punctuation">.</span>already_read<span class="token punctuation">,</span> c<span class="token punctuation">.</span>sock<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    c<span class="token punctuation">.</span>sock<span class="token punctuation">.</span><span class="token function">read_some</span><span class="token punctuation">(</span> <span class="token function">buffer</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>buff <span class="token operator">+</span> c<span class="token punctuation">.</span>already_read<span class="token punctuation">,</span> to_read<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    c<span class="token punctuation">.</span>already_read <span class="token operator">+</span><span class="token operator">=</span> to_read<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> std<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>buff<span class="token punctuation">,</span> c<span class="token punctuation">.</span>buff <span class="token operator">+</span> c<span class="token punctuation">.</span>already_read<span class="token punctuation">,</span> <span class="token string">'\n'</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> c<span class="token punctuation">.</span>buff <span class="token operator">+</span> c<span class="token punctuation">.</span>already_read<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> pos <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>buff<span class="token punctuation">,</span> c<span class="token punctuation">.</span>buff <span class="token operator">+</span> c<span class="token punctuation">.</span>already_read<span class="token punctuation">,</span> <span class="token string">'\n'</span><span class="token punctuation">)</span> <span class="token operator">-</span> c<span class="token punctuation">.</span>buff<span class="token punctuation">;</span>        std<span class="token operator">::</span>string <span class="token function">msg</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>buff<span class="token punctuation">,</span> c<span class="token punctuation">.</span>buff <span class="token operator">+</span> pos<span class="token punctuation">)</span><span class="token punctuation">;</span>        std<span class="token operator">::</span><span class="token function">copy</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>buff <span class="token operator">+</span> pos<span class="token punctuation">,</span> c<span class="token punctuation">.</span>buff <span class="token operator">+</span> <span class="token number">1024</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span>buff<span class="token punctuation">)</span><span class="token punctuation">;</span>        c<span class="token punctuation">.</span>already_read <span class="token operator">-</span><span class="token operator">=</span> pos<span class="token punctuation">;</span>        <span class="token function">on_read_msg</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">on_read_msg</span><span class="token punctuation">(</span>client <span class="token operator">&amp;</span> c<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 分析消息，然后返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> msg <span class="token operator">==</span> <span class="token string">"request_login"</span><span class="token punctuation">)</span>        c<span class="token punctuation">.</span>sock<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span> <span class="token string">"request_ok\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有一种情况是在任何服务端（和任何基于网络的应用）都需要避免的，就是代码无响应的情况。在我们的例子里，我们需要<em>handle_clients()</em>方法尽可能少的阻塞。如果方法在某个点上阻塞，任何进来的信息都需要等待方法解除阻塞才能被处理。</p><p>为了保持响应，只在一个套接字有数据的时候我们才读，也就是说，<em>if ( clients[i].sock.available() ) on_read(clients[i])</em>。在<em>on_read</em>时，我们只读当前可用的；调用<em>read_until(c.sock, buffer(…), ‘\n’)</em>会是一个非常糟糕的选择，因为直到我们从一个指定的客户端读取了完整的消息之前，它都是阻塞的（我们永远不知道它什么时候会读取到完整的消息）</p><p>这里的瓶颈就是<em>on_read_msg()</em>方法；当它执行时，所有进来的消息都在等待。一个良好的<em>on_read_msg()</em>方法实现会保证这种情况基本不会发生，但是它还是会发生（有时候向一个套接字写入数据，缓冲区满了时，它会被阻塞） 同步方式的代码，10个线程</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> <span class="token keyword">namespace</span> boost<span class="token operator">::</span>asio<span class="token punctuation">;</span><span class="token keyword">struct</span> client <span class="token punctuation">{</span>　  <span class="token comment" spellcheck="true">// ... 和之前一样</span>    <span class="token keyword">bool</span> <span class="token function">set_reading</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        boost<span class="token operator">::</span>mutex<span class="token operator">::</span>scoped_lock <span class="token function">lk</span><span class="token punctuation">(</span>cs_<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> is_reading_<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 已经在读取</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span> is_reading_ <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">unset_reading</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        boost<span class="token operator">::</span>mutex<span class="token operator">::</span>scoped_lock <span class="token function">lk</span><span class="token punctuation">(</span>cs_<span class="token punctuation">)</span><span class="token punctuation">;</span>        is_reading_ <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    boost<span class="token operator">::</span>mutex cs_<span class="token punctuation">;</span>    <span class="token keyword">bool</span> is_reading_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>client<span class="token operator">></span> clients<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">handle_clients</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        boost<span class="token operator">::</span><span class="token function">thread</span><span class="token punctuation">(</span> handle_clients_thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">handle_clients_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token boolean">true</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> clients<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> clients<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sock<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span> clients<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">set_reading</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">on_read</span><span class="token punctuation">(</span>clients<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    clients<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">unset_reading</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">on_read</span><span class="token punctuation">(</span>client <span class="token operator">&amp;</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 和之前一样</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">on_read_msg</span><span class="token punctuation">(</span>client <span class="token operator">&amp;</span> c<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 和之前一样</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了使用多线程，我们需要对线程进行同步，这就是<em>set_reading()</em>和<em>set_unreading()</em>所做的。<em>set_reading()</em>方法非常重要，比如你想要一步实现“判断是否在读取然后标记为读取中”。但这是有两步的（“判断是否在读取”和“标记为读取中”），你可能会有两个线程同时为一个客户端判断是否在读取，然后你会有两个线程同时为一个客户端调用<em>on_read</em>，结果就是数据冲突甚至导致应用崩溃。</p><p>你会发现代码变得极其复杂。</p><p>同步编程有第三个选择，就是为每个连接开辟一个线程。但是当并发的线程增加时，这就成了一种灾难性的情况。</p><p>然后，让我们来看异步编程。我们不断地异步读取。当一个客户端请求某些东西时，<em>on_read</em>被调用，然后回应，然后等待下一个请求（然后开始另外一个异步的read操作）。</p><p>异步方式的代码，10个线程</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> <span class="token keyword">namespace</span> boost<span class="token operator">::</span>asio<span class="token punctuation">;</span>io_service service<span class="token punctuation">;</span><span class="token keyword">struct</span> client <span class="token punctuation">{</span>    ip<span class="token operator">::</span>tcp<span class="token operator">::</span>socket sock<span class="token punctuation">;</span>    streambuf buff<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 从客户端取回结果</span><span class="token punctuation">}</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>client<span class="token operator">></span> clients<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">handle_clients</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> clients<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token function">async_read_until</span><span class="token punctuation">(</span>clients<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sock<span class="token punctuation">,</span> clients<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>buff<span class="token punctuation">,</span> <span class="token string">'\n'</span><span class="token punctuation">,</span> boost<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>on_read<span class="token punctuation">,</span> clients<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> _1<span class="token punctuation">,</span> _2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        boost<span class="token operator">::</span><span class="token function">thread</span><span class="token punctuation">(</span>handle_clients_thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">handle_clients_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    service<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">on_read</span><span class="token punctuation">(</span>client <span class="token operator">&amp;</span> c<span class="token punctuation">,</span> <span class="token keyword">const</span> error_code <span class="token operator">&amp;</span> err<span class="token punctuation">,</span> size_t read_bytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>istream <span class="token function">in</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">.</span>buff<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>string msg<span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">getline</span><span class="token punctuation">(</span>in<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> msg <span class="token operator">==</span> <span class="token string">"request_login"</span><span class="token punctuation">)</span>        c<span class="token punctuation">.</span>sock<span class="token punctuation">.</span><span class="token function">async_write</span><span class="token punctuation">(</span> <span class="token string">"request_ok\n"</span><span class="token punctuation">,</span> on_write<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 等待同一个客户端下一个读取操作</span>    <span class="token function">async_read_until</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>sock<span class="token punctuation">,</span> c<span class="token punctuation">.</span>buff<span class="token punctuation">,</span> <span class="token string">'\n'</span><span class="token punctuation">,</span> boost<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>on_read<span class="token punctuation">,</span> c<span class="token punctuation">,</span> _1<span class="token punctuation">,</span> _2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发现代码变得有多简单了吧？client结构里面只有两个成员，<em>handle_clients()</em>仅仅调用了<em>async_read_until</em>，然后它创建了10个线程，每个线程都调用<em>service.run()</em>。这些线程会处理所有来自客户端的异步read操作，然后分发所有向客户端的异步write操作。另外需要注意的一件事情是：<em>on_read()</em>一直在为下一次异步read操作做准备（看最后一行代码）。</p><h4 id="异步run-runone-poll-poll-one"><a href="#异步run-runone-poll-poll-one" class="headerlink" title="异步run(), runone(), poll(), poll one()"></a>异步run(), run<em>one(), poll(), poll</em> one()</h4><p>为了实现监听循环，<em>io_service</em>类提供了4个方法，比如：<em>run(), run_one(), poll()</em>和<em>poll_one()</em>。虽然大多数时候使用<em>service.run()</em>就可以，但是你还是需要在这里学习其他方法实现的功能。</p><h5 id="持续运行"><a href="#持续运行" class="headerlink" title="持续运行"></a>持续运行</h5><p>再一次说明，如果有等待执行的操作，<em>run()</em>会一直执行，直到你手动调用<em>io_service::stop()</em>。为了保证<em>io_service</em>一直执行，通常你添加一个或者多个异步操作，然后在它们被执行时，你继续一直不停地添加异步操作，比如下面代码：</p><pre class="line-numbers language-php"><code class="language-php">using <span class="token keyword">namespace</span> <span class="token package">boost</span><span class="token punctuation">:</span><span class="token punctuation">:</span>asio<span class="token punctuation">;</span>io_service service<span class="token punctuation">;</span>ip<span class="token punctuation">:</span><span class="token punctuation">:</span>tcp<span class="token punctuation">:</span><span class="token punctuation">:</span>socket <span class="token function">sock</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span>char buff_read<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">,</span> buff_write<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"ok"</span><span class="token punctuation">;</span>void <span class="token function">on_read</span><span class="token punctuation">(</span><span class="token keyword">const</span> boost<span class="token punctuation">:</span><span class="token punctuation">:</span>system<span class="token punctuation">:</span><span class="token punctuation">:</span>error_code <span class="token operator">&amp;</span>err<span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>size_t bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>void <span class="token function">on_write</span><span class="token punctuation">(</span><span class="token keyword">const</span> boost<span class="token punctuation">:</span><span class="token punctuation">:</span>system<span class="token punctuation">:</span><span class="token punctuation">:</span>error_code <span class="token operator">&amp;</span>err<span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>size_t bytes<span class="token punctuation">)</span><span class="token punctuation">{</span>    sock<span class="token punctuation">.</span><span class="token function">async_read_some</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>buff_read<span class="token punctuation">)</span><span class="token punctuation">,</span> on_read<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>void <span class="token function">on_read</span><span class="token punctuation">(</span><span class="token keyword">const</span> boost<span class="token punctuation">:</span><span class="token punctuation">:</span>system<span class="token punctuation">:</span><span class="token punctuation">:</span>error_code <span class="token operator">&amp;</span>err<span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>size_t bytes<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ... 处理读取操作 ...</span>    sock<span class="token punctuation">.</span><span class="token function">async_write_some</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>buff_write<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> on_write<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>void <span class="token function">on_connect</span><span class="token punctuation">(</span><span class="token keyword">const</span> boost<span class="token punctuation">:</span><span class="token punctuation">:</span>system<span class="token punctuation">:</span><span class="token punctuation">:</span>error_code <span class="token operator">&amp;</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>    sock<span class="token punctuation">.</span><span class="token function">async_read_some</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>buff_read<span class="token punctuation">)</span><span class="token punctuation">,</span> on_read<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>int <span class="token function">main</span><span class="token punctuation">(</span>int argc<span class="token punctuation">,</span> char<span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ip<span class="token punctuation">:</span><span class="token punctuation">:</span>tcp<span class="token punctuation">:</span><span class="token punctuation">:</span>endpoint <span class="token function">ep</span><span class="token punctuation">(</span> ip<span class="token punctuation">:</span><span class="token punctuation">:</span>address<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from_string</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2001</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sock<span class="token punctuation">.</span><span class="token function">async_connect</span><span class="token punctuation">(</span>ep<span class="token punctuation">,</span> on_connect<span class="token punctuation">)</span><span class="token punctuation">;</span>    service<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>当<em>service.run()</em>被调用时，有一个异步操作在等待。</li><li>当socket连接到服务端时，<em>on_connect</em>被调用了，它会添加一个异步操作。</li><li>当<em>on_connect</em>结束时，我们会留下一个等待的操作（<em>read</em>）。</li><li>当<em>on_read</em>被调用时，我们写入一个回应，这又添加了另外一个等待的操作。</li><li>当<em>on_read</em>结束时，我们会留下一个等待的操作<em>（write</em>）。</li><li>当<em>on_write</em>操作被调用时，我们从服务端读取另外一个消息，这也添加了另外一个等待的操作。</li><li>当<em>on_write</em>结束时，我们有一个等待的操作（read）。</li><li>然后一直继续循环下去，直到我们关闭这个应用。</li></ol><h5 id="run-one-poll-poll-one-方法"><a href="#run-one-poll-poll-one-方法" class="headerlink" title="run_one(), poll(), poll_one() 方法"></a>run_one(), poll(), poll_one() 方法</h5><p>我在之前说过异步方法的handler是在调用了<em>io_service::run</em>的线程里被调用的。因为在至少90%～95%的时候，这是你唯一要用到的方法，所以我就把它说得简单了。对于调用了<em>run_one(), poll()</em>或者<em>poll_one()</em>的线程这一点也是适用的。</p><p><em>run_one()</em>方法最多执行和分发一个异步操作：</p><ul><li>如果没有等待的操作，方法立即返回0</li><li>如果有等待操作，方法在第一个操作执行之前处于阻塞状态，然后返回1</li></ul><p>你可以认为下面两段代码是等效的：</p><pre class="line-numbers language-javascript"><code class="language-javascript">io_service service<span class="token punctuation">;</span>service<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 或者</span><span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token operator">!</span>service<span class="token punctuation">.</span><span class="token function">stopped</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> service<span class="token punctuation">.</span><span class="token function">run_once</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>你可以使用<em>run_once()</em>启动一个异步操作，然后等待它执行完成。</p><pre class="line-numbers language-php"><code class="language-php">io_service service<span class="token punctuation">;</span>bool write_complete <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>void <span class="token function">on_write</span><span class="token punctuation">(</span><span class="token keyword">const</span> boost<span class="token punctuation">:</span><span class="token punctuation">:</span>system<span class="token punctuation">:</span><span class="token punctuation">:</span>error_code <span class="token operator">&amp;</span> err<span class="token punctuation">,</span> size_t bytes<span class="token punctuation">)</span><span class="token punctuation">{</span> write_complete <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> …std<span class="token punctuation">:</span><span class="token punctuation">:</span>string data <span class="token operator">=</span> "login ok”<span class="token punctuation">;</span>write_complete <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token function">async_write</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> <span class="token function">buffer</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">,</span> on_write<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">do</span> service<span class="token punctuation">.</span><span class="token function">run_once</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>write_complete<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有一些使用<em>run_one()</em>方法的例子，包含在Boost.Asio诸如<em>blocking_tcp_client.cpp</em>和<em>blocking_udp_client.cpp</em>的文件中。</p><p><em>poll_one</em>方法以非阻塞的方式最多运行一个准备好的等待操作：</p><ul><li>如果至少有一个等待的操作，而且准备好以非阻塞的方式运行，poll_one方法会运行它并且返回1</li><li>否则，方法立即返回0</li></ul><p>操作正在等待并准备以非阻塞方式运行，通常意味着如下的情况：</p><ul><li>一个计时器过期了，然后它的<em>async_wait</em>处理方法需要被调用</li><li>一个I/O操作完成了（比如<em>async_read</em>），然后它的hanlder需要被调用</li><li>之前被加入<em>io_services</em>实例队列中的自定义handler（这会在之后的章节中详解）</li></ul><p>你可以使用<em>poll_one</em>去保证所有I/O操作的handler完成运行，同时做一些其他的工作</p><pre class="line-numbers language-javascript"><code class="language-javascript">io_service service<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 运行所有完成了IO操作的handler</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span> service<span class="token punctuation">.</span><span class="token function">poll_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ... 在这里做其他的事情 …</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>poll()</em>方法会以非阻塞的方式运行所有等待的操作。下面两段代码是等效的：</p><pre class="line-numbers language-javascript"><code class="language-javascript">io_service service<span class="token punctuation">;</span>service<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 或者</span><span class="token keyword">while</span> <span class="token punctuation">(</span> service<span class="token punctuation">.</span><span class="token function">poll_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>所有上述方法都会在失败的时候抛出<em>boost::system::system_error</em>异常。这是我们所不希望发生的事情；这里抛出的异常通常都是致命的，也许是资源耗尽，或者是你handler的其中一个抛出了异常。另外，每个方法都有一个不抛出异常，而是返回一个<em>boost::system::error_code</em>的重载：</p><pre class="line-numbers language-cpp"><code class="language-cpp">io_service service<span class="token punctuation">;</span>boost<span class="token operator">::</span>system<span class="token operator">::</span>error_code err <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>service<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span> err<span class="token punctuation">)</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Error "</span> <span class="token operator">&lt;&lt;</span> err <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="异步工作"><a href="#异步工作" class="headerlink" title="异步工作"></a>异步工作</h4><p>异步工作不仅仅指用异步地方式接受客户端到服务端的连接、异步地从一个socket读取或者写入到socket。它包含了所有可以异步执行的操作。</p><p>默认情况下，你是不知道每个异步handler的调用顺序的。除了通常的异步调用（来自异步socket的读取/写入/接收）。你可以使用<em>service.post()</em>来使你的自定义方法被异步地调用。例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;boost/thread.hpp></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;boost/bind.hpp></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;boost/asio.hpp></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> boost<span class="token operator">::</span>asio<span class="token punctuation">;</span>io_service service<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func called, i= "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">worker_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    service<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        service<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>boost<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    boost<span class="token operator">::</span>thread_group threads<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        threads<span class="token punctuation">.</span><span class="token function">create_thread</span><span class="token punctuation">(</span>worker_thread<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 等待所有线程被创建完</span>    boost<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep</span><span class="token punctuation">(</span> boost<span class="token operator">::</span>posix_time<span class="token operator">::</span><span class="token function">millisec</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    threads<span class="token punctuation">.</span><span class="token function">join_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的例子中，<em>service.post(some_function)</em>添加了一个异步方法调用。</p><p>这个方法在某一个调用了<em>service.run()</em>的线程中请求<em>io_service</em>实例，然后调用给定的<em>some_funtion</em>之后立即返回。在我们的例子中，这个线程是我们之前创建的三个线程中的一个。你不能确定异步方法调用的顺序。你不要期待它们会以我们调用<em>post()</em>方法的顺序来调用。下面是运行之前代码可能得到的结果：</p><pre class="line-numbers language-swift"><code class="language-swift"><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">2</span><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">4</span><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">3</span><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">6</span><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">7</span><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">8</span><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">5</span><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">9</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有时候你会想让一些异步处理方法顺序执行。比如，你去一个餐馆（<em>go_to_restaurant</em>），下单（<em>order</em>），然后吃（<em>eat</em>）。你需要先去餐馆，然后下单，最后吃。这样的话，你需要用到<em>io_service::strand</em>，这个方法会让你的异步方法被顺序调用。看下面的例子：</p><pre class="line-numbers language-php"><code class="language-php">using <span class="token keyword">namespace</span> <span class="token package">boost</span><span class="token punctuation">:</span><span class="token punctuation">:</span>asio<span class="token punctuation">;</span>io_service service<span class="token punctuation">;</span>void <span class="token function">func</span><span class="token punctuation">(</span>int i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"func called, i= "</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> i <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"/"</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> boost<span class="token punctuation">:</span><span class="token punctuation">:</span>this_thread<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>void <span class="token function">worker_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    service<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>int <span class="token function">main</span><span class="token punctuation">(</span>int argc<span class="token punctuation">,</span> char<span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    io_service<span class="token punctuation">:</span><span class="token punctuation">:</span>strand <span class="token function">strand_one</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">strand_two</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        service<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span> strand_one<span class="token punctuation">.</span><span class="token function">wrap</span><span class="token punctuation">(</span> boost<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">bind</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> int i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        service<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span> strand_two<span class="token punctuation">.</span><span class="token function">wrap</span><span class="token punctuation">(</span> boost<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">bind</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    boost<span class="token punctuation">:</span><span class="token punctuation">:</span>thread_group threads<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        threads<span class="token punctuation">.</span><span class="token function">create_thread</span><span class="token punctuation">(</span>worker_thread<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 等待所有线程被创建完</span>    boost<span class="token punctuation">:</span><span class="token punctuation">:</span>this_thread<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">sleep</span><span class="token punctuation">(</span> boost<span class="token punctuation">:</span><span class="token punctuation">:</span>posix_time<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">millisec</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    threads<span class="token punctuation">.</span><span class="token function">join_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上述代码中，我们保证前面的5个线程和后面的5个线程是顺序执行的。<em>func called, i = 0</em>在<em>func called, i = 1</em>之前被调用，然后调用<em>func called, i = 2</em>……同样<em>func called, i = 5</em>在<em>func called, i = 6</em>之前，<em>func called, i = 6</em>在<em>func called, i = 7</em>被调用……你需要注意的是尽管方法是顺序调用的，但是不意味着它们都在同一个线程执行。运行这个程序可能得到的一个结果如下：</p><pre class="line-numbers language-swift"><code class="language-swift"><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">0</span><span class="token operator">/</span>002A60C8<span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">5</span><span class="token operator">/</span>002A6138<span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">6</span><span class="token operator">/</span>002A6530<span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">1</span><span class="token operator">/</span>002A6138<span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">7</span><span class="token operator">/</span>002A6530<span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">2</span><span class="token operator">/</span>002A6138<span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">8</span><span class="token operator">/</span>002A6530<span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">3</span><span class="token operator">/</span>002A6138<span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">9</span><span class="token operator">/</span>002A6530<span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">4</span><span class="token operator">/</span>002A6138<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="异步post-VS-dispatch-VS-wrap"><a href="#异步post-VS-dispatch-VS-wrap" class="headerlink" title="异步post() VS dispatch() VS wrap()"></a>异步post() VS dispatch() VS wrap()</h4><p>Boost.Asio提供了三种让你把处理方法添加为异步调用的方式：</p><ul><li><em>service.post(handler)</em>：这个方法能确保其在请求<em>io_service</em>实例，然后调用指定的处理方法之后立即返回。handler稍后会在某个调用了<em>service.run()</em>的线程中被调用。</li><li><em>service.dispatch(handler)</em>：这个方法请求<em>io_service</em>实例去调用给定的处理方法，但是另外一点，如果当前的线程调用了<em>service.run()</em>，它可以在方法中直接调用handler。</li><li><em>service.wrap(handler)</em>：这个方法创建了一个封装方法，当被调用时它会调用<em>service.dispatch(handler)</em>，这个会让人有点困惑，接下来我会简单地解释它是什么意思。</li></ul><p>在之前的章节中你会看到关于<em>service.post()</em>的一个例子，以及运行这个例子可能得到的一种结果。我们对它做一些修改，然后看看<em>service.dispatch()</em>是怎么影响输出的结果的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> <span class="token keyword">namespace</span> boost<span class="token operator">::</span>asio<span class="token punctuation">;</span>io_service service<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func called, i= "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">run_dispatch_and_post</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    service<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span>boost<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    service<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>boost<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    service<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>run_dispatch_and_post<span class="token punctuation">)</span><span class="token punctuation">;</span>    service<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在解释发生了什么之前，我们先运行程序，观察结果：</p><pre class="line-numbers language-swift"><code class="language-swift"><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">2</span><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">4</span><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">6</span><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">8</span><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">3</span><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">5</span><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">7</span><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">9</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>偶数先输出，然后是奇数。这是因为我用<em>dispatch()</em>输出偶数，然后用<em>post()</em>输出奇数。<em>dispatch()</em>会在返回之前调用hanlder，因为当前的线程调用了<em>service.run()</em>，而<em>post()</em>每次都立即返回了。</p><p>现在，让我们讲讲<em>service.wrap(handler)</em>。<em>wrap()</em>返回了一个仿函数，它可以用来做另外一个方法的参数：</p><pre class="line-numbers language-java"><code class="language-java">using namespace boost<span class="token operator">:</span><span class="token operator">:</span>asio<span class="token punctuation">;</span>io_service service<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">dispatched_func_1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">:</span><span class="token operator">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"dispatched 1"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">:</span><span class="token operator">:</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">dispatched_func_2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">:</span><span class="token operator">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"dispatched 2"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">:</span><span class="token operator">:</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>boost<span class="token operator">:</span><span class="token operator">:</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> func<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">:</span><span class="token operator">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"test"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">:</span><span class="token operator">:</span>endl<span class="token punctuation">;</span>    service<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span>dispatched_func_1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">service_run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    service<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">test</span><span class="token punctuation">(</span> service<span class="token punctuation">.</span><span class="token function">wrap</span><span class="token punctuation">(</span>dispatched_func_2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    boost<span class="token operator">:</span><span class="token operator">:</span>thread <span class="token function">th</span><span class="token punctuation">(</span>service_run<span class="token punctuation">)</span><span class="token punctuation">;</span>    boost<span class="token operator">:</span><span class="token operator">:</span>this_thread<span class="token operator">:</span><span class="token operator">:</span><span class="token function">sleep</span><span class="token punctuation">(</span> boost<span class="token operator">:</span><span class="token operator">:</span>posix_time<span class="token operator">:</span><span class="token operator">:</span><span class="token function">millisec</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    th<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>test(service.wrap(dispatched_func_2));</em>会把<em>dispatched_ func_2</em>包装起来创建一个仿函数，然后传递给<em>test</em>当作一个参数。当<em>test()</em>被调用时，它会分发调用方法1，然后调用<em>func()</em>。这时，你会发现调用<em>func()</em>和<em>service.dispatch(dispatched_func_2)</em>是等价的，因为它们是连续调用的。程序的输出证明了这一点：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">test</span>dispatched 1dispatched 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><em>io_service::strand</em> 类（用来序列化异步调用）也包含了<em>poll(), dispatch()</em>和 <em>wrap()</em>等成员函数。它们的作用和<em>io_service</em>的<em>poll(), dispatch()</em>和<em>wrap()</em>是一样的。然而，大多数情况下你只需要把<em>io_service::strand::wrap()</em>方法做为<em>io_service::poll()</em>或者<em>io_service::dispatch()</em>方法的参数即可。</p><h3 id="保持活动"><a href="#保持活动" class="headerlink" title="保持活动"></a>保持活动</h3><p>假设你需要做下面的操作：</p><pre class="line-numbers language-cpp"><code class="language-cpp">io_service service<span class="token punctuation">;</span>ip<span class="token operator">::</span>tcp<span class="token operator">::</span>socket <span class="token function">sock</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span> buff<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> <span class="token function">buffer</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，<em>sock</em>和<em>buff</em>的存在时间都必须比<em>read()</em>调用的时间要长。也就是说，在调用<em>read()</em>返回之前，它们都必须有效。这就是你所期望的；你传给一个方法的所有参数在方法内部都必须有效。当我们采用异步方式时，事情会变得比较复杂。</p><pre class="line-numbers language-cpp"><code class="language-cpp">io_service service<span class="token punctuation">;</span>ip<span class="token operator">::</span>tcp<span class="token operator">::</span>socket <span class="token function">sock</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span> buff<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">on_read</span><span class="token punctuation">(</span><span class="token keyword">const</span> boost<span class="token operator">::</span>system<span class="token operator">::</span>error_code <span class="token operator">&amp;</span><span class="token punctuation">,</span> size_t<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">async_read</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> <span class="token function">buffer</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token punctuation">,</span> on_read<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，<em>sock</em>和<em>buff</em>的存在时间都必须比<em>read()</em>操作本身时间要长，但是read操作持续的时间我们是不知道的，因为它是异步的。</p><p>当使用socket缓冲区的时候，你会有一个<em>buffer</em>实例在异步调用时一直存在（使用<em>boost::shared_array&lt;&gt;</em>）。在这里，我们可以使用同样的方式，通过创建一个类并在其内部管理socket和它的读写缓冲区。然后，对于所有的异步操作，传递一个包含智能指针的<em>boost::bind</em>仿函数给它：</p><pre class="line-numbers language-java"><code class="language-java">using namespace boost<span class="token operator">:</span><span class="token operator">:</span>asio<span class="token punctuation">;</span>io_service service<span class="token punctuation">;</span>struct connection <span class="token operator">:</span> boost<span class="token operator">:</span><span class="token operator">:</span>enable_shared_from_this<span class="token operator">&lt;</span>connection<span class="token operator">></span> <span class="token punctuation">{</span>    typedef boost<span class="token operator">:</span><span class="token operator">:</span>system<span class="token operator">:</span><span class="token operator">:</span>error_code error_code<span class="token punctuation">;</span>    typedef boost<span class="token operator">:</span><span class="token operator">:</span>shared_ptr<span class="token operator">&lt;</span>connection<span class="token operator">></span> ptr<span class="token punctuation">;</span>    <span class="token function">connection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">sock_</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">started_</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span>ip<span class="token operator">:</span><span class="token operator">:</span>tcp<span class="token operator">:</span><span class="token operator">:</span>endpoint ep<span class="token punctuation">)</span> <span class="token punctuation">{</span>        sock_<span class="token punctuation">.</span><span class="token function">async_connect</span><span class="token punctuation">(</span>ep<span class="token punctuation">,</span> boost<span class="token operator">:</span><span class="token operator">:</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>connection<span class="token operator">:</span><span class="token operator">:</span>on_connect<span class="token punctuation">,</span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> _1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>started_<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        started_ <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        sock_<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    bool <span class="token function">started</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> started_<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">on_connect</span><span class="token punctuation">(</span><span class="token keyword">const</span> error_code <span class="token operator">&amp;</span> err<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 这里你决定用这个连接做什么: 读取或者写入</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>err<span class="token punctuation">)</span> <span class="token function">do_read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">on_read</span><span class="token punctuation">(</span><span class="token keyword">const</span> error_code <span class="token operator">&amp;</span> err<span class="token punctuation">,</span> size_t bytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token function">started</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        std<span class="token operator">:</span><span class="token operator">:</span>string <span class="token function">msg</span><span class="token punctuation">(</span>read_buffer_<span class="token punctuation">,</span> bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> msg <span class="token operator">==</span> <span class="token string">"can_login"</span><span class="token punctuation">)</span> <span class="token function">do_write</span><span class="token punctuation">(</span><span class="token string">"access_data"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> msg<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"data "</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">process_data</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> msg <span class="token operator">==</span> <span class="token string">"login_fail"</span><span class="token punctuation">)</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">on_write</span><span class="token punctuation">(</span><span class="token keyword">const</span> error_code <span class="token operator">&amp;</span> err<span class="token punctuation">,</span> size_t bytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">do_read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">do_read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        sock_<span class="token punctuation">.</span><span class="token function">async_read_some</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>read_buffer_<span class="token punctuation">)</span><span class="token punctuation">,</span> boost<span class="token operator">:</span><span class="token operator">:</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>connection<span class="token operator">:</span><span class="token operator">:</span>on_read<span class="token punctuation">,</span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>   _1<span class="token punctuation">,</span> _2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">do_write</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">:</span><span class="token operator">:</span>string <span class="token operator">&amp;</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token function">started</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 注意: 因为在做另外一个async_read操作之前你想要发送多个消息, </span>        <span class="token comment" spellcheck="true">// 所以你需要多个写入buffer</span>        std<span class="token operator">:</span><span class="token operator">:</span><span class="token function">copy</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> msg<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> write_buffer_<span class="token punctuation">)</span><span class="token punctuation">;</span>        sock_<span class="token punctuation">.</span><span class="token function">async_write_some</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>write_buffer_<span class="token punctuation">,</span> msg<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> boost<span class="token operator">:</span><span class="token operator">:</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>connection<span class="token operator">:</span><span class="token operator">:</span>on_write<span class="token punctuation">,</span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> _1<span class="token punctuation">,</span> _2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">process_data</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">:</span><span class="token operator">:</span>string <span class="token operator">&amp;</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 处理服务端来的内容，然后启动另外一个写入操作</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    ip<span class="token operator">:</span><span class="token operator">:</span>tcp<span class="token operator">:</span><span class="token operator">:</span>socket sock_<span class="token punctuation">;</span>    <span class="token keyword">enum</span> <span class="token punctuation">{</span> max_msg <span class="token operator">=</span> <span class="token number">1024</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> read_buffer_<span class="token punctuation">[</span>max_msg<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> write_buffer_<span class="token punctuation">[</span>max_msg<span class="token punctuation">]</span><span class="token punctuation">;</span>    bool started_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ip<span class="token operator">:</span><span class="token operator">:</span>tcp<span class="token operator">:</span><span class="token operator">:</span>endpoint <span class="token function">ep</span><span class="token punctuation">(</span> ip<span class="token operator">:</span><span class="token operator">:</span>address<span class="token operator">:</span><span class="token operator">:</span><span class="token function">from_string</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">8001</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    connection<span class="token operator">:</span><span class="token operator">:</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">connection</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">start</span><span class="token punctuation">(</span>ep<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在所有异步调用中，我们传递一个<em>boost::bind</em>仿函数当作参数。这个仿函数内部包含了一个智能指针，指向<em>connection</em>实例。只要有一个异步操作等待时，Boost.Asio就会保存<em>boost::bind</em>仿函数的拷贝，这个拷贝保存了指向连接实例的一个智能指针，从而保证<em>connection</em>实例保持活动。问题解决！</p><p>当然，<em>connection</em>类仅仅是一个框架类；你需要根据你的需求对它进行调整（它看起来会和当前服务端例子的情况相当不同）。</p><p>你需要注意的是创建一个新的连接是相当简单的：<em>connection::ptr(new connection)- &gt;start(ep)</em>。这个方法启动了到服务端的（异步）连接。当你需要关闭这个连接时，调用<em>stop()</em>。</p><p>当实例被启动时（<em>start()</em>），它会等待客户端的连接。当连接发生时。<em>on_connect()</em>被调用。如果没有错误发生，它启动一个read操作（<em>do_read()</em>）。当read操作结束时，你就可以解析这个消息；当然你应用的<em>on_read()</em>看起来会各种各样。而当你写回一个消息时，你需要把它拷贝到缓冲区，然后像我在<em>do_write()</em>方法中所做的一样将其发送出去，因为这个缓冲区同样需要在这个异步写操作中一直存活。最后需要注意的一点——当写回时，你需要指定写入的数量，否则，整个缓冲区都会被发送出去。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>网络api实际上要繁杂得多，这个章节只是做为一个参考，当你在实现自己的网络应用时可以回过头来看看。</p><p>Boost.Asio实现了端点的概念，你可以认为是IP和端口。如果你不知道准确的IP，你可以使用<em>resolver</em>对象将主机名，例如<em><a href="http://www.yahoo.com">www.yahoo.com</a></em>转换为一个或多个IP地址。</p><p>我们也可以看到API的核心——socket类。Boost.Asio提供了<em>TCP、UDP</em>和 <em>ICMP</em>的实现。而且你还可以用你自己的协议来对它进行扩展；当然，这个工作不适合缺乏勇气的人。</p><p>异步编程是刚需。你应该已经明白为什么有时候需要用到它，尤其在写服务端的时候。调用<em>service.run()</em>来实现异步循环就已经可以让你很满足，但是有时候你需要更进一步，尝试使用<em>run_one()、poll()</em>或者<em>poll_one()</em>。</p><p>当实现异步时，你可以异步执行你自己的方法；使用<em>service.post()</em>或者<em>service.dispatch()</em>。</p><p>最后，为了使socket和缓冲区（read或者write）在整个异步操作的生命周期中一直活动，我们需要采取特殊的防护措施。你的连接类需要继承自<em>enabled_shared_from_this</em>，然后在内部保存它需要的缓冲区，而且每次异步调用都要传递一个智能指针给<em>this</em>操作。</p><p>下一章会进行实战操作；在实现回显客户端/服务端应用时会有大量的编程实践。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;为什么要学这个呢？首先，arpa那套网络编程只能在linux下用，其次，个人觉得C语言风格的接口实在是太丑陋了，第三，cpp的net库提上日
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>有栈协程与无栈协程</title>
    <link href="https://joytsing.github.io/posts/21849/"/>
    <id>https://joytsing.github.io/posts/21849/</id>
    <published>2024-04-19T08:46:06.000Z</published>
    <updated>2024-04-19T14:50:04.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先，先问自己一个问题，<code>什么是协程？</code>，<code>为什么需要协程？</code>，<code>能解决什么痛点？</code></p><h2 id="协程，what，why？"><a href="#协程，what，why？" class="headerlink" title="协程，what，why？"></a>协程，what，why？</h2><p>什么是协程，现在流行的有几种说法：</p><ul><li>第一种： “可以暂停和恢复执行” 的函数，<strong>其“全部精神就在于控制流的主动让出和恢复”</strong>。这种观点来自协程概念的提出者Conway在1963年发表的论文”<strong><a href="http://melconway.com/Home/pdf/compiler.pdf">Design of a separable transition-diagram compiler</a></strong>“</li><li>第二种：是运行在用户态的线程，避免了向内核态下陷从而提高性能。实现一个用户态线程有两个必须要处理的问题：一是碰着阻塞式I\O会导致整个进程被挂起；二是由于缺乏时钟阻塞，进程需要自己拥有调度线程的能力。如果一种实现使得每个线程需要自己通过调用某个方法，主动交出控制权。那么我们就称这种用户态线程是协作式的，即是<strong>协程</strong>。</li><li>第三种：Coroutines are computer program components that generalize subroutines for non-preemptive multitasking, by allowing execution to be suspended and resumed. —— from <strong><a href="https://en.wikipedia.org/wiki/Coroutine">Wikipieda</a></strong></li></ul><p>所以这几种定义哪个才是协程，还是说他们都对？然后是我们为什么要协程？</p><ul><li>让原来需要使用异步+回调方式写的非人类代码,用看似同步的方式写出来</li><li>既要同步编程风格，能够让业务开发人员很便捷地去开发业务逻辑代码，同时能够达到「异步回调模型的性能」。</li></ul><h2 id="有栈协程与无栈协程"><a href="#有栈协程与无栈协程" class="headerlink" title="有栈协程与无栈协程"></a>有栈协程与无栈协程</h2><p>如今协程已经成为大多数语言的标配，例如 Golang 里的 goroutine，JavaScript 里的 async/await。尽管名称可能不同，但它们都可以被划分为两大类，一类是有栈（stackful）协程，例如 goroutine；一类是无栈（stackless）协程，例如 async/await。</p><p>此处「有栈」和「无栈」的含义不是指协程在运行时是否需要栈，对于大多数语言来说，一个函数调用另一个函数，总是存在调用栈的；而是指协程是否可以在其<strong>任意</strong>嵌套函数中被挂起，此处的嵌套函数读者可以理解为子函数、匿名函数等。显然有栈协程是可以的，而无栈协程则不可以。似乎难以理解？不要慌，让我们先从函数调用栈开始讲起。</p><h3 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h3><p>调用栈是一段连续的地址空间，无论是 caller（调用方）还是 callee（被调用方）都位于这段空间之内。而调用栈中一个函数所占用的地址空间我们称之为「栈帧」（stack frame），调用栈便是由若干个栈帧拼接而成的。</p><p><img src="/posts/21849/call-stack.png" alt="DrawSquare 是 caller，DrawLine 是 callee"></p><p>Stack Pointer 即栈顶指针，总是指向调用栈的顶部地址，该地址由 esp 寄存器存储；Frame Pointer 即基址指针，总是指向当前栈帧（当前正在运行的子函数）的底部地址，该地址由 ebp 寄存器存储。Return Address 则在是 callee 返回后，caller 将继续执行的指令所在的地址；而指令地址是由 eip 寄存器负责读取的，且 eip 寄存器总是预先读取了<strong>当前栈帧中</strong>下一条将要执行的指令的地址。</p><p>我们可以很轻易地构造一段 C 代码，然后将其转换为汇编，看看底层究竟做了什么。网页上推荐使用 <a href="https://godbolt.org/">Compiler Explorer</a> 查看汇编更加简洁清晰。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">callee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// callee:</span>               <span class="token comment" spellcheck="true">//   pushl %ebp</span>               <span class="token comment" spellcheck="true">//   movl  %esp, %ebp</span>               <span class="token comment" spellcheck="true">//   subl  $16, %esp</span>    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//   movl  $0, -4(%ebp)</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//   movl -4(%ebp), %eax</span>               <span class="token comment" spellcheck="true">//   leave</span>               <span class="token comment" spellcheck="true">//   ret</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">caller</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// caller:</span>               <span class="token comment" spellcheck="true">//   pushl %ebp</span>               <span class="token comment" spellcheck="true">//   movl  %esp, %ebp</span>    <span class="token function">callee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//   call  callee</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//   movl  $0, %eax</span>               <span class="token comment" spellcheck="true">//   popl  %ebp</span>               <span class="token comment" spellcheck="true">//   ret</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当 caller 调用 callee 时，执行了以下步骤（注意注释中的执行顺序：</p><pre class="line-numbers language-assembly"><code class="language-assembly">callee:    // 3. 将 caller 的栈帧底部地址入栈保存    pushl %ebp    // 4. 将此时的调用栈顶部地址作为 callee 的栈帧底部地址    movl  %esp, %ebp    // 5. 将调用栈顶部扩展 16 bytes 作为 callee 的栈帧空间；    //    在 x86 平台中，调用栈的地址增长方向是从高位向低位增长的，    //    所以这里用的是 subl 指令而不是 addl 指令    subl  $16, %esp    ...caller:    ...    // "call callee" 等价于如下两条指令：    // 1. 将 eip 存储的指令地址入栈保存；    //    此时的指令地址即为 caller 的 return address，    //    即 caller 的 "movl $0, %eax" 这条指令所在的地址    // 2. 然后跳转到 callee    pushl %eip    jmp callee    ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/21849/caller-to-callee.png" alt="caller 调用 callee 的调用栈变化（忽略传参）">caller 调用 callee 的调用栈变化（忽略传参）</p><p>当 callee 返回 caller 时，则执行了以下步骤（注意注释中的执行顺序：</p><pre class="line-numbers language-assembly"><code class="language-assembly">callee:    ...    // "leave" 等价于如下两条指令：    // 6. 将调用栈顶部与 callee 栈帧底部对齐，释放 callee 栈帧空间    // 7. 将之前保存的 caller 的栈帧底部地址出栈并赋值给 ebp    movl %ebp, %esp    popl %ebp    // "ret" 等价如下指令：    // 8. 将之前保存的 caller 的 return address 出栈并赋值给 eip，    //    即 caller 的 "movl $0, %eax" 这条指令所在的地址    popl eipcaller:    ...    // 9. 从 callee 返回了，继续执行后续指令    movl $0, %eax    ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/21849/callee-to-caller.png" alt="callee 返回 caller 的调用栈变化（忽略传参）">callee 返回 caller 的调用栈变化（忽略传参)</p><p>以上便是函数调用栈的大致运行过程了。当然真实的调用栈运行过程要复杂一些，需要带上参数传递等等，对此感兴趣，则推荐阅读这篇文章 <a href="https://www.csee.umbc.edu/~chang/cs313.s02/stack.shtml">C Function Call Conventions and the Stack</a>。</p><h3 id="有栈协程"><a href="#有栈协程" class="headerlink" title="有栈协程"></a>有栈协程</h3><p>实现一个协程的关键点在于如何保存、恢复和切换上下文。已知函数运行在调用栈上；如果将一个函数作为协程，我们很自然地联想到，保存上下文即是保存从这个函数及其嵌套函数的（连续的）栈帧存储的值，以及此时寄存器存储的值；恢复上下文即是将这些值分别重新写入对应的栈帧和寄存器；而切换上下文无非是保存当前正在运行的函数的上下文，恢复下一个将要运行的函数的上下文。有栈协程便是这种朴素思想下的产物，即类似于内核态线程的实现，不同协程间切换还是要切换对应的栈上下文，只是不用陷入内核而已。</p><p>有栈协程是可以在其任意嵌套函数中被挂起的 —— 毕竟它都能保存和恢复自己完整的上下文了，那自然是在哪里被挂起都可以。我们可以自己实现一个简单的例子证明这个事实，同时也有助于我们从底层理解有栈协程的运行过程。</p><p>首先我们需要申请一段能存储上下文的内存空间。在保存上下文时，我们可以选择把上下文都拷贝到这段内存；亦或者直接将这段内存作为协程运行时的栈帧空间，这样就能避免拷贝带来的性能损失了。注意，如果申请的内存空间小了，协程在运行时会爆栈；如果大了，则浪费内存；不过具体的分配策略我们就不做过多讨论了。</p><p>同时还需要保存寄存器的值。这里便涉及到了函数调用栈中的一个知识点，<a href="https://en.wikipedia.org/wiki/X86_calling_conventions#Caller-saved_(volatile)_registers">根据约定</a>，有的寄存器是由 caller 负责保存的，如 eax、ecx 和 edx；而有的寄存器是 callee 负责保存的，如 ebx、edi 和 esi。对于被调用的协程而言，只需要保存 callee 相关的寄存器的值，调用栈相关的 ebp 和 esp 的值，以及 eip 存储的 return address。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// *(ctx + CTX_SIZE - 1) 存储 return address</span><span class="token comment" spellcheck="true">// *(ctx + CTX_SIZE - 2) 存储 ebx</span><span class="token comment" spellcheck="true">// *(ctx + CTX_SIZE - 3) 存储 edi</span><span class="token comment" spellcheck="true">// *(ctx + CTX_SIZE - 4) 存储 esi</span><span class="token comment" spellcheck="true">// *(ctx + CTX_SIZE - 5) 存储 ebp</span><span class="token comment" spellcheck="true">// *(ctx + CTX_SIZE - 6) 存储 esp</span><span class="token comment" spellcheck="true">// 注意 x86 的栈增长方向是从高位向低位增长的，所以寻址是向下偏移的</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token function">init_ctx</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>func<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 动态申请 CTX_SIZE 内存用于存储协程上下文</span>    size_t size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">*</span> CTX_SIZE<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>ctx <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将 func 的地址作为其栈帧 return address 的初始值，</span>    <span class="token comment" spellcheck="true">// 当 func 第一次被调度时，将从其入口处开始执行</span>    <span class="token operator">*</span><span class="token punctuation">(</span>ctx <span class="token operator">+</span> CTX_SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> func<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// https://github.com/mthli/blog/pull/12</span>    <span class="token comment" spellcheck="true">// 需要预留 6 个寄存器内容的存储空间，</span>    <span class="token comment" spellcheck="true">// 余下的内存空间均可以作为 func 的栈帧空间</span>    <span class="token operator">*</span><span class="token punctuation">(</span>ctx <span class="token operator">+</span> CTX_SIZE <span class="token operator">-</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>ctx <span class="token operator">+</span> CTX_SIZE <span class="token operator">-</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ctx <span class="token operator">+</span> CTX_SIZE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，为了保存和恢复寄存器的值，我们还需要撰写几段汇编代码。假设此时我们已经将存储上下文的内存地址赋值给了 eax，则保存的逻辑如下：</p><pre class="line-numbers language-assembly"><code class="language-assembly">// 依次将各个寄存器的值存储；// 注意 x86 的栈增长方向是从高位向低位增长的，所以寻址是向下偏移的movl %ebx,  -8(%eax)movl %edi, -12(%eax)movl %esi, -16(%eax)movl %ebp, -20(%eax)movl %esp, -24(%eax)//  %esp  存储的是当前调用栈的顶部所在的地址，// (%esp) 是顶部地址所指向的内存区域存储的值，// 将这个值存储为 return addressmovl (%esp), %ecxmovl %ecx, -4(%eax)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而与之相对应的恢复逻辑如下：</p><pre class="line-numbers language-assembly"><code class="language-assembly">// 依次将存储的值写入各个寄存器；// 注意 x86 的栈增长方向是从高位向低位增长的，所以寻址是向下偏移的movl  -8(%eax), %ebxmovl -12(%eax), %edimovl -16(%eax), %esimovl -20(%eax), %ebpmovl -24(%eax), %esp//  %esp  存储的是当前调用栈的顶部所在的地址，// (%esp) 是顶部地址所指向的内存区域存储的值，// 将存储的 return address 写入到该内存区域movl -4(%eax), %ecxmovl %ecx, (%esp)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而前文已经说过，切换上下文无非是保存当前正在运行的函数的上下文，恢复下一个将要运行的函数的上下文。于是我们可以基于上述两段汇编构造一个 <code>void swap_ctx(char **current, char **next)</code> 函数，分别传入 <code>char **init_ctx(char *func)</code> 构造好的上下文即可实现切换。为了方便使用，我们可以将 <code>swap_ctx()</code> 封装成 <code>yield()</code> 函数，在这个函数里简单实现了不同函数的调度逻辑。于是一个简单的例子便完成了：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>MAIN_CTX<span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>NEST_CTX<span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>FUNC_CTX_1<span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>FUNC_CTX_2<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">nest_yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">nest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 随机生成一个整数作为 tag</span>    <span class="token keyword">int</span> tag <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"nest, tag: %d, index: %d\n"</span><span class="token punctuation">,</span> tag<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">nest_yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 随机生成一个整数作为 tag</span>    <span class="token keyword">int</span> tag <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"func, tag: %d, index: %d\n"</span><span class="token punctuation">,</span> tag<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    MAIN_CTX <span class="token operator">=</span> <span class="token function">init_ctx</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> main<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 证明 nest() 可以在其任意嵌套函数中被挂起</span>    NEST_CTX <span class="token operator">=</span> <span class="token function">init_ctx</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> nest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 证明同一个函数在不同的栈帧空间上运行</span>    FUNC_CTX_1 <span class="token operator">=</span> <span class="token function">init_ctx</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> func<span class="token punctuation">)</span><span class="token punctuation">;</span>    FUNC_CTX_2 <span class="token operator">=</span> <span class="token function">init_ctx</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> func<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> tag <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"main, tag: %d, index: %d\n"</span><span class="token punctuation">,</span> tag<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">free</span><span class="token punctuation">(</span>MAIN_CTX <span class="token operator">-</span> CTX_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>NEST_CTX <span class="token operator">-</span> CTX_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>FUNC_CTX_1 <span class="token operator">-</span> CTX_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>FUNC_CTX_2 <span class="token operator">-</span> CTX_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完整的代码可通过 <a href="https://github.com/mthli/blog/blob/master/content/blog/stackful-stackless/">这个链接</a> 获得，使用 <code>gcc -m32 stackful.c stackful.s</code> 编译，然后运行 <code>./a.out</code> 的得到如下结果：</p><p><img src="/posts/21849/image-20240419205041630.png" alt></p><p>可以注意到 <code>tag</code> 的值在每次调度过程中均未改变，而循环叠加 <code>index</code> 的逻辑也并未因为挂起和恢复受到影响。所以 <code>nest()</code> 的确是可以在其任意嵌套函数中被挂起；同时我们还证明了同一个函数被调用多次时，的确是在不同的栈帧空间上运行的。</p><h2 id="无栈协程"><a href="#无栈协程" class="headerlink" title="无栈协程"></a>无栈协程</h2><p>相比于有栈协程直接切换栈帧的思路，无栈协程在不改变函数调用栈的情况下，采用类似生成器（generator）的思路实现了上下文切换，此处请直接阅读文章 <a href="https://mthli.xyz/coroutines-in-c/">使用 C 语言实现协程</a> —— 尽管作者在文中没有说明，但这正是一种无栈协程的实现。<strong>无栈协程的本质就是一个状态机（state machine）</strong>，它可以理解为在另一个角度去看问题，即<strong>同一协程协程的切换本质不过是指令指针寄存器的改变</strong>。</p><p>此外我们还可以通过译文提供的 <a href="https://www.chiark.greenend.org.uk/~sgtatham/coroutine.h">coroutine.h</a> 看到，作者通过 C 语言的宏将所有协程的变量统一包装进了一个结构体，然后再为这个结构体申请内存空间，从而实现了分配确定大小的内存空间，避免了内存浪费 —— 而这正是有栈协程所做不到的。</p><p>从执行时栈的角度来看，其实所有的协程共用的都是一个栈，即系统栈，也就也不必我们自行去给协程分配栈，因为是函数调用，我们当然也不必去显示的保存寄存器的值，而且<strong>相比有栈协程把局部变量放在新开的空间上，无栈协程直接使用系统栈使得CPU cache局部性更好，同时也使得无栈协程的中断和函数返回几乎没有区别</strong>，这样也可以凸显出无栈协程的高效。</p><h2 id="对称协程和非对称协程"><a href="#对称协程和非对称协程" class="headerlink" title="对称协程和非对称协程"></a>对称协程和非对称协程</h2><p>其实对于“对称”这个名词，阐述的实际是协程之间的关系，用大白话来说就是对称协程就是说协程之间人人平等，没有谁调用谁一说，大家都是一样的，而非对称协程就是协程之间存在明显的调用关系。</p><p>简单来说就是这样：</p><ul><li>对称协程 Symmetric Coroutine：任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移。</li><li>非对称协程 Asymmetric Coroutine：协程出让调度权的目标只能是它的调用者，即协程之间存在调用和被调用关系。</li></ul><p>回到开头的问题，协程分为无栈协程和有栈协程两种，无栈指可挂起/恢复的函数，有栈协程则相当于用户态线程。有栈协程切换的成本是用户态线程切换的成本，而无栈协程切换的成本则相当于函数调用的成本。</p><ul><li>无栈协程和线程的区别：无栈协程只能被线程调用，本身并不抢占内核调度，而线程则可抢占内核调度。</li><li>协程函数与普通函数的区别：普通函数执行完返回，则结束，协程函数可以运行到一半，返回并保留上下文；下次唤醒时恢复上下文，可以接着执行。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;首先，先问自己一个问题，&lt;code&gt;什么是协程？&lt;/code&gt;，&lt;code&gt;为什么需要协程？&lt;/code&gt;，&lt;code&gt;能解决什么痛点？&lt;/
      
    
    </summary>
    
    
      <category term="Go" scheme="https://JoyTsing.github.io/categories/Go/"/>
    
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
      <category term="Go" scheme="https://JoyTsing.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go里的GMP协程调度</title>
    <link href="https://joytsing.github.io/posts/59192/"/>
    <id>https://joytsing.github.io/posts/59192/</id>
    <published>2024-04-19T08:42:55.000Z</published>
    <updated>2024-04-19T14:47:38.710Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Go调度器的详细调度过程是什么？</p><h2 id="GMP"><a href="#GMP" class="headerlink" title="GMP"></a>GMP</h2><p>M个协程绑定1个线程，模型大概如下：</p><p><img src="/posts/59192/1460000021951130.png" alt></p><h3 id="G（Goroutine）"><a href="#G（Goroutine）" class="headerlink" title="G（Goroutine）"></a>G（Goroutine）</h3><p>G 取自Goroutine的首字母，一个G代表一个Goroutine，Goroutine是一个与其他Goroutines并行运行在同一地址空间的go函数或方法。当 Goroutine 被调离 CPU 时，调度器代码负责把 CPU 寄存器的值保存在 G 对象的成员变量之中，当 Goroutine 被调度起来运行时，调度器代码又负责把 G 对象的成员变量所保存的寄存器的值恢复到 CPU 的寄存器。</p><p>协程之于Go调度器好比内核线程之于OS调度器，也是有着多种状态的，但因为它不可见底层核心线程的状态，因此会有更细致和复杂的状态迁移图，如下图所示：</p><p><img src="/posts/59192/v2-96be756d5230b84b66a9ce52d4adcde3_720w.webp" alt></p><p>不同状态的描述如下图所示：</p><p><img src="/posts/59192/v2-842e12010eedd6c181adb26ffe955c8d_720w.webp" alt></p><p>Go协程状态图相比进程状态图多了<strong>收缩/扩展栈</strong>和<strong>执行系统调用</strong>两个更加细分的状态，而且同时runnable和running状态和OS的状态<strong>不是一一对应</strong>的，其实用户态无法感知到OS的就绪态、运行态和阻塞态。</p><h3 id="M（Machine）"><a href="#M（Machine）" class="headerlink" title="M（Machine）"></a>M（Machine）</h3><p>OS 底层线程的抽象，它本身就与一个内核线程进行绑定，每个工作线程都有唯一的一个 M 结构体的实例对象与之对应，它代表着真正执行计算的资源，由操作系统的调度器调度和管理。M 结构体对象除了记录着工作线程的诸如栈的起止位置、当前正在执行的 Goroutine 以及是否空闲等等状态信息之外，还通过指针维持着与 P 结构体的实例对象之间的绑定关系。</p><p>最多只会有 GOMAXPROCS 个活跃线程能够正常运行，因为M需要和P绑定才能运行G，而P的个数取决于设置的GOMAXPROCS，一个M阻塞了就会创建新的M。</p><h3 id="P（Processor）"><a href="#P（Processor）" class="headerlink" title="P（Processor）"></a>P（Processor）</h3><p>表示逻辑处理器。对 G 来说，P 相当于 CPU 核，G 只有绑定到 P(在 P 的 local runq 中)才能被调度。对 M 来说，P 提供了<strong>相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)</strong>等。它维护一个局部 Goroutine 可运行 G 队列，工作线程<strong>优先使用自己的局部运行队列，只有必要时才会去访问全局运行队列</strong>，这可以大大减少锁冲突，提高工作线程的并发性，并且可以良好的运用程序的局部性原理。</p><h3 id="GMP概述"><a href="#GMP概述" class="headerlink" title="GMP概述"></a>GMP概述</h3><p><img src="/posts/59192/v2-2b01b8aaabcf52d060a0f128133e6d96_720w.png" alt></p><ol><li><strong>全局队列</strong>（Global Queue）：存放等待运行的G。</li><li><strong>P的本地队列</strong>：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G’时，G’优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。</li><li><strong>P列表</strong>：所有的P都在程序启动时创建，并保存在数组中，最多有<code>GOMAXPROCS</code>(可配置)个。</li><li><strong>M</strong>：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列<strong>拿</strong>一批G放到P的本地队列，或从其他P的本地队列<strong>偷</strong>一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。</li></ol><p><strong>Goroutine调度器和OS调度器是通过M结合起来的，每个M都代表了1个内核线程，OS调度器负责把内核线程分配到CPU的核上执行</strong>。对于<strong>本地运行队列</strong>，每个逻辑处理器有一个本地运行队列。如果创建一个goroutine并准备运行，这个goroutine首先会被放到调度器的全局运行队列中。之后，调度器会将全局运行队列中的goroutine分配给一个逻辑处理器，并放到这个逻辑处理器的本地运行队列中。本地运行队列中的goroutine会一直等待直到被分配的逻辑处理器执行。下图展示了操作系统线程、逻辑处理器和本地运行队列之间的关系：</p><p><img src="/posts/59192/640.webp" alt></p><p>有时，正在运行的goroutine需要执行一个阻塞的系统调用，如打开一个文件。当这类调用发生时，线程和goroutine会从逻辑处理器上分离，该线程会继续阻塞，等待系统调用的返回。与此同时，这个逻辑处理器就失去了用来运行的线程。所以，调度器会创建一个新线程，并将其绑定到该逻辑处理器上。之后，调度器会从本地运行队列里选择另一个goroutine来运行。一旦被阻塞的系统调用执行完成并返回，对应的goroutine会放回到本地运行队列，而之前的线程会保存好，以便之后可以继续使用。</p><p><img src="/posts/59192/640-1713536584650-11.webp" alt></p><p>如果一个goroutine需要做一个网络I/O调用，流程上会有些不一样。在这种情况下，goroutine会和逻辑处理器分离，并移到集成了网络轮询器的运行时。一旦该轮询器指示某个网络读或者写操作已经就绪，对应的goroutine 就会重新分配到逻辑处理器上来完成操作。 </p><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><h3 id="调度器设计策略"><a href="#调度器设计策略" class="headerlink" title="调度器设计策略"></a>调度器设计策略</h3><p><strong>复用线程</strong>：避免频繁的创建、销毁线程，而是对线程的复用。</p><ul><li><p>1）work stealing机制</p><p>当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。</p></li><li><p>2）hand off机制</p><p>当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。</p></li></ul><p><strong>利用并行</strong>：<code>GOMAXPROCS</code>设置P的数量，最多有<code>GOMAXPROCS</code>个线程分布在多个CPU上同时运行。<code>GOMAXPROCS</code>也限制了并发的程度，比如<code>GOMAXPROCS = 核数/2</code>，则最多利用了一半的CPU核进行并行。</p><p><strong>抢占</strong>：在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死，这就是goroutine不同于coroutine的一个地方。</p><p><strong>全局G队列</strong>：在新的调度器中依然有全局G队列，但功能已经被弱化了，当M执行work stealing从其他P偷不到G时，它可以从全局G队列获取G。</p><h3 id="全局goroutine队列"><a href="#全局goroutine队列" class="headerlink" title="全局goroutine队列"></a>全局goroutine队列</h3><p>当创建一个新的G之后优先加入本地队列，如果本地队列满了，会将本地队列的G移动到全局队列里面，当M执行work stealing从其他P偷不到G时，它可以从全局G队列获取G。</p><p>我们创建一个协程 go func()经历过程如下图：</p><p><img src="/posts/59192/webp.webp" alt></p><blockquote><p><strong>说明：</strong></p><p>这里有两个存储G的队列，一个是局部调度器P的本地队列、一个是全局G队列。新创建的G会先保存在P的本地队列中，如果P的本地队列已经满了就会保存在全局的队列中；处理器本地队列是一个使用数组构成的环形链表，它最多可以存储 256 个待执行任务。</p><p>G只能运行在M中，一个M必须持有一个P，M与P是1：1的关系。M会从P的本地队列弹出一个可执行状态的G来执行，如果P的本地队列为空，就会想其他的MP组合偷取一个可执行的G来执行；一个M调度G执行的过程是一个循环机制；会一直从本地队列或全局队列中获取G</p></blockquote><h3 id="M缓冲池"><a href="#M缓冲池" class="headerlink" title="M缓冲池"></a>M缓冲池</h3><p>上面说到P的个数默认等于CPU核数，每个M必须持有一个P才可以执行G，一般情况下M的个数会略大于P的个数，这多出来的M将会在G产生系统调用时发挥作用。类似线程池，Go也提供一个M的池子，需要时从池子中获取，用完放回池子，不够用时就再创建一个。</p><h3 id="调度例外"><a href="#调度例外" class="headerlink" title="调度例外"></a>调度例外</h3><p>如果一切正常，调度器会以上述的那种方式顺畅地运行，但这个世界没这么美好，总有意外发生，以下分析goroutine在两种例外情况下的行为。</p><p>Go runtime会在下面的goroutine被阻塞的情况下运行另外一个goroutine：</p><p><strong>用户态阻塞/唤醒</strong></p><p>当goroutine因为channel操作或者network I/O而阻塞时（实际上golang已经用netpoller实现了goroutine网络I/O阻塞不会导致M被阻塞，仅阻塞G，这里仅仅是举个栗子），对应的G会被放置到某个wait队列(如channel的waitq)，该G的状态由_Gruning变为_Gwaitting，而M会跳过该G尝试获取并执行下一个G，如果此时没有可运行的G供M运行，那么M将解绑P，并进入sleep状态；当阻塞的G被另一端的G2唤醒时（比如channel的可读/写通知），G被标记为，尝试加入G2所在P的runnext（runnext是线程下一个需要执行的 Goroutine。）， 然后再是P的本地队列和全局队列。</p><p><strong>系统调用阻塞</strong></p><p>当M执行某一个G时候如果发生了阻塞操作，M会阻塞，如果当前有一些G在执行，调度器会把这个线程M从P中摘除，然后再创建一个新的操作系统的线程(如果有空闲的线程可用就复用空闲线程)来服务于这个P。当M系统调用结束时候，这个G会尝试获取一个空闲的P执行，并放入到这个P的本地队列。如果获取不到P，那么这个线程M变成休眠状态， 加入到空闲线程中，然后这个G会被放入全局队列中。</p><p><strong>队列轮转</strong></p><p>可见每个P维护着一个包含G的队列，不考虑G进入系统调用或IO操作的情况下，P周期性的将G调度到M中执行，执行一小段时间，将上下文保存下来，然后将G放到队列尾部，然后从队列中重新取出一个G进行调度。</p><p>除了每个P维护的G队列以外，还有一个全局的队列，每个P会周期性地查看全局队列中是否有G待运行并将其调度到M中执行，全局队列中G的来源，主要有从系统调用中恢复的G。之所以P会周期性地查看全局队列，也是为了防止全局队列中的G被饿死。</p><p>除了每个P维护的G队列以外，还有一个全局的队列，每个P会周期性地查看全局队列中是否有G待运行并将其调度到M中执行，全局队列中G的来源，主要有从系统调用中恢复的G。之所以P会周期性地查看全局队列，也是为了防止全局队列中的G被饿死。</p><h3 id="全局队列与公平性"><a href="#全局队列与公平性" class="headerlink" title="全局队列与公平性"></a>全局队列与公平性</h3><ul><li>由于在G1中创建的新协程会优先放到当前P上，因此容易发生<strong>P的runqueue满</strong>的情况，这种情况下会尝试将该P上的一部分G放到别的P上或者放到全局队列中</li><li>为了保证公平，当全局运行队列中有待执行的Goroutine 时，通过schedtick 保证有一定几率（1/61）会从<strong>全局的运行队列</strong>中查找对应的Goroutine</li><li>从处理器本地的运行队列中查找待执行的Goroutine</li><li>如果前两种方法都没有找到Goroutine，会通过runtime.findrunnable 进行阻塞地查找Goroutine，寻找的路径有以下几种，包括：<ol><li>从全局运行队列中查找。</li><li>从网络轮询器中查找是否有Goroutine 等待运行。</li><li>通过runtime.runqsteal 尝试从其他随机的处理器中<strong>窃取</strong>待运行的Goroutine。</li></ol></li></ul><p><img src="/posts/59192/v2-6191a82a67daafeea11387f7b8071b10_720w.png" alt></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="正常情况下"><a href="#正常情况下" class="headerlink" title="正常情况下"></a>正常情况下</h3><p>所有的goroutine运行在同一个M系统线程中，每一个M系统线程维护一个Processor，任何时刻，一个Processor中只有一个goroutine，其他goroutine在runqueue中等待。一个goroutine运行完自己的时间片后，让出上下文，回到runqueue中。 多核处理器的场景下，为了运行goroutines，每个M系统线程会持有一个Processor。</p><p><img src="/posts/59192/v2-cdea56998262fe18039da2832207bc45_720w.webp" alt></p><h3 id="协程创建与更替"><a href="#协程创建与更替" class="headerlink" title="协程创建与更替"></a>协程创建与更替</h3><p>P 拥有 G1，M1 获取 P 后开始运行 G1，G1 使用<code>go func()</code>创建了 G2，为了局部性 G2 优先加入到 P1 的本地队列。G1运行完之后会按照runqueue的顺序继续运行G2。</p><h3 id="协程阻塞"><a href="#协程阻塞" class="headerlink" title="协程阻塞"></a>协程阻塞</h3><p>当正在运行的goroutine（G0）阻塞的时候，例如进行系统调用，会再创建一个系统线程（M1)，当前的M0线程放弃了它的Processor（P），P转到新的线程中去运行。</p><p><img src="/posts/59192/v2-7c530372d59c05b633f10f64088f88cb_720w.webp" alt></p><h2 id="特殊的-M0-和-G0"><a href="#特殊的-M0-和-G0" class="headerlink" title="特殊的 M0 和 G0"></a><strong>特殊的 M0 和 G0</strong></h2><p><strong>M0</strong></p><p>M0是启动程序后的编号为0的主线程，这个M对应的实例会在全局变量rutime.m0中，不需要在heap上分配，M0负责执行初始化操作和启动第一个G，在之后M0就和其他的M一样了</p><p><strong>G0</strong></p><p>G0是每次启动一个M都会第一个创建的goroutine，G0仅用于负责调度G，G0不指向任何可执行的函数，每个M都会有一个自己的G0，在调度或系统调用时会使用G0的栈空间，全局变量的G0是M0的G0</p><p>那么一个G由于调度被中断，此后如何恢复？中断的时候将寄存器里的栈信息，保存到自己的G对象里面。当再次轮到自己执行时，将自己保存的栈信息复制到寄存器里面，这样就接着上次之后运行了。</p><p><a href="https://segmentfault.com/a/1190000021951119">延伸阅读</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Go调度器的详细调度过程是什么？&lt;/p&gt;
&lt;h2 id=&quot;GMP&quot;&gt;&lt;a href=&quot;#GMP&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="Go" scheme="https://JoyTsing.github.io/categories/Go/"/>
    
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
      <category term="Go" scheme="https://JoyTsing.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>虚拟地址空间与编译链接</title>
    <link href="https://joytsing.github.io/posts/60390/"/>
    <id>https://joytsing.github.io/posts/60390/</id>
    <published>2024-04-18T16:04:23.000Z</published>
    <updated>2024-04-20T07:52:03.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>如果它存在，而且你能看见它，它是物理的（real）<br>如果它不存在，但你能看见它，它是虚拟的（virtual）<br>如果它存在，但你看不见它，它是透明的（transparent）</p></blockquote><h2 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h2><p>虚拟地址空间和虚拟内存是两码子事，</p><blockquote><p>虚拟地址空间是一种内存管理技术，它允许程序以一种抽象的方式访问内存资源，从而实现对物理内存的高效管理。虚拟地址空间将物理内存抽象为一个连续的地址空间，使得每个进程都拥有自己独立的虚拟地址空间。操作系统负责管理虚拟地址到物理地址的映射。</p></blockquote><p><strong>在Linux中，虚拟地址空间通常分为两个区域：用户区域和内核区域。</strong></p><ul><li>用户区域： 用户区域包含了用户程序的代码、数据和堆栈等信息。具体包括以下部分：<ul><li>程序代码：存放编译后的可执行二进制代码，这部分内存区域是只读的，防止程序意外或恶意修改代码。</li><li>数据段：存放程序的全局变量和静态变量。</li><li>堆：用于存储程序运行时动态分配的内存。堆从低地址向高地址增长。</li><li>文件映射区(mmap)：存储映射到内存中的文件数据，如用于装载动态共享库、内存映射文件等。</li><li>栈：存放程序的局部变量、函数调用的参数和返回地址等信息。栈从高地址向低地址增长。</li><li>环境变量和命令行参数：存放传递给程序的环境变量和命令行参数。</li></ul></li><li>内核区域：内核区域是操作系统内核代码和数据的存储区域。用户进程无法直接访问这部分内存，只能通过系统调用与内核进行交互。内核空间包括以下部分：<ul><li>内核代码：操作系统内核的代码。</li><li>内核数据：操作系统的全局数据结构，如进程表、文件系统缓存等。</li><li>内核栈：为内核模式下的函数调用提供栈空间。</li><li>物理内存映射：将物理内存映射到内核虚拟地址空间，便于内核访问。</li><li>高速缓存：缓存一些常用的内核数据结构，提高访问速度。</li></ul></li></ul><p>用户空间和内核空间的主要区别在于访问权限和功能。用户空间主要用于存储用户程序的代码和数据，而内核空间则存放操作系统内核的代码和数据。用户空间的程序无法直接访问内核空间，只能通过系统调用与内核进行交互。这种设计有助于保护内核数据结构的完整性，避免用户程序意外或恶意破坏操作系统。</p><p>当计算机程序运行时，它需要访问一些内存，例如使用的变量或代码等。虚拟地址空间是一种使程序可以直接访问这些内存而不必真正了解这些内存在物理上所处的位置的技术。虚拟地址由处理器内存管理单元映射到实际物理地址。每个进程都有自己的独立虚拟地址空间，同时操作系统负责将每个进程的虚拟地址映射到主存中的物理内存地址。</p><p><img src="/posts/60390/238146a26c87497682fc47aac4e908cf.png" alt></p><p><strong>在32位Linux系统中，虚拟地址空间大小为4GB，分为内核空间和用户空间。以下是一个简要概述：</strong></p><ul><li><strong>内核空间</strong>（Kernel Space）：<ul><li><code>内核空间位于高地址段，通常在3GB到4GB之间</code>。这个区域存放内核代码和数据结构，如内存管理、进程管理、设备驱动等。这部分内存只能由内核模式下的代码访问。</li></ul></li><li><strong>用户空间</strong>（User Space）：<ul><li><code>用户空间位于低地址段，通常在0到3GB之间</code>。这个区域存放用户程序和相关数据结构。用户空间从高地址到低地址包含以下部分：<ul><li><strong>环境变量和命令行参数</strong>：位于用户空间的高地址部分。</li><li><strong>栈空间</strong>（Stack）：位于环境变量和命令行参数之下，用于存放函数调用栈、局部变量和返回地址等。</li><li><strong>动态链接库</strong>（Shared Libraries）：位于栈空间下方，存放动态链接的共享库。内存映射文件也会被加载到这个区域。</li><li><strong>堆空间</strong>（Heap）：位于动态链接库下方，用于存放动态分配的内存。堆空间在程序运行期间可以根据需要增长或缩小。</li><li><strong>未初始化数据段</strong>（BSS）、<strong>初始化数据段</strong>（Data）和<strong>代码段</strong>（Text）：位于堆空间下方，存放程序的全局变量、静态变量和程序代码。</li></ul></li></ul></li></ul><p><code>内存映射文件和动态链接库通常位于用户空间的共享库部分</code>。其中应该熟悉的区有这几个：</p><h3 id="BSS段"><a href="#BSS段" class="headerlink" title="BSS段"></a>BSS段</h3><p>   BSS(Block Started by Symbol)段中通常存放程序中以下符号：</p><ul><li><p>未初始化的全局变量和静态局部变量</p></li><li><p>初始值为0的全局变量和静态局部变量(依赖于编译器实现)</p></li><li><p>未定义且初值不为0的符号(该初值即common block的大小)</p><p> C语言中，未显式初始化的静态分配变量被初始化为0(算术类型)或空指针(指针类型)。由于程序加载时，BSS会被操作系统清零，所以未赋初值或初值为0的全局变量都在BSS中。BSS段仅为未初始化的静态分配变量预留位置，在目标文件中并不占据空间，这样可减少目标文件体积。但程序运行时需为变量分配内存空间，故目标文件必须记录所有未初始化的静态分配变量大小总和(通过start_bss和end_bss地址写入机器代码)。当加载器(loader)加载程序时，将为BSS段分配的内存初始化为0。在嵌入式软件中，进入main()函数之前BSS段被C运行时系统映射到初始化为全零的内存(效率较高)。</p><p> 注意，尽管均放置于BSS段，但初值为0的全局变量是强符号，而未初始化的全局变量是弱符号。若其他地方已定义同名的强符号(初值可能非0)，则弱符号与之链接时不会引起重定义错误，但运行时的初值可能并非期望值(会被强符号覆盖)。因此，定义全局变量时，若只有本文件使用，则尽量使用static关键字修饰；否则需要为全局变量定义赋初值(哪怕0值)，保证该变量为强符号，以便链接时发现变量名冲突，而不是被未知值覆盖。</p><p> 某些编译器将未初始化的全局变量保存在common段，链接时再将其放入BSS段。在编译阶段可通过-fno-common选项来禁止将未初始化的全局变量放入common段。</p><p> 此外，由于目标文件不含BSS段，故程序烧入存储器(Flash)后BSS段地址空间内容未知。U-Boot启动过程中<a href="http://blog.csdn.net/king_bingge/article/details/8741987">，</a>将U-Boot的Stage2代码(通常位于lib_xxxx/board.c文件)搬迁(拷贝)到SDRAM空间后必须人为添加清零BSS段的代码，而不可依赖于Stage2代码中变量定义时赋0值。</p></li></ul><blockquote><p>【扩展阅读】<strong>BSS历史</strong> </p><p>BSS(Block Started by Symbol，以符号开始的块)一词最初是UA-SAP汇编器(United Aircraft Symbolic Assembly Program)中的伪指令，用于为符号预留一块内存空间。该汇编器由美国联合航空公司于20世纪50年代中期为IBM 704大型机所开发。   后来该词被作为关键字引入到了IBM 709和7090/94机型上的标准汇编器FAP(Fortran Assembly Program)，用于定义符号并且为该符号预留指定字数的未初始化空间块。   在采用段式内存管理的架构中(如Intel 80x86系统)，BSS段通常指用来存放程序中未初始化全局变量的一块内存区域，该段变量只有名称和大小却没有值。程序开始时由系统初始化清零。   BSS段不包含数据，仅维护开始和结束地址，以便内存能在运行时被有效地清零。BSS所需的运行时空间由目标文件记录，但BSS并不占用目标文件内的实际空间，即BSS节段应用程序的二进制映象文件中并不存在。</p></blockquote><h3 id="Data段"><a href="#Data段" class="headerlink" title="Data段"></a>Data段</h3><p>   数据段通常用于存放程序中已初始化且初值不为0的全局变量和静态局部变量。数据段属于静态内存分配(静态存储区)，可读可写。</p><p>   数据段保存在目标文件中(在嵌入式系统里一般固化在镜像文件中)，其内容由程序初始化。例如，对于全局变量int gVar = 10，必须在目标文件数据段中保存10这个数据，然后在程序加载时复制到相应的内存。</p><p>   数据段与BSS段的区别如下： </p><p>1) BSS段不占用物理文件尺寸，但占用内存空间；数据段占用物理文件，也占用内存空间。</p><p>   对于大型数组如int ar0[10000] = {1, 2, 3, …}和int ar1[10000]，ar1放在BSS段，只记录共有10000*4个字节需要初始化为0，而不是像ar0那样记录每个数据1、2、3…，此时BSS为目标文件所节省的磁盘空间相当可观。</p><p>2) 当程序读取数据段的数据时，系统会出发缺页故障，从而分配相应的物理内存；当程序读取BSS段的数据时，内核会将其转到一个全零页面，不会发生缺页故障，也不会为其分配相应的物理内存。</p><p>   运行时数据段和BSS段的整个区段通常称为数据区。某些资料中“数据段”指代数据段 + BSS段 + 堆。</p><h3 id="text段"><a href="#text段" class="headerlink" title="text段"></a>text段</h3><p>   代码段也称正文段或文本段，通常用于存放程序执行代码(即CPU执行的机器指令)。一般C语言执行语句都编译成机器代码保存在代码段。通常代码段是可共享的，因此频繁执行的程序只需要在内存中拥有一份拷贝即可。代码段通常属于只读，以防止其他程序意外地修改其指令(对该段的写操作将导致段错误)。某些架构也允许代码段为可写，即允许修改程序。</p><p>   代码段指令根据程序设计流程依次执行，对于顺序指令，只会执行一次(每个进程)；若有反复，则需使用跳转指令；若进行递归，则需要借助栈来实现。</p><p>   代码段指令中包括操作码和操作对象(或对象地址引用)。若操作对象是立即数(具体数值)，将直接包含在代码中；若是局部数据，将在栈区分配空间，然后引用该数据地址；若位于BSS段和数据段，同样引用该数据地址。</p><p>   代码段最容易受优化措施影响。</p><h3 id="段和节"><a href="#段和节" class="headerlink" title="段和节"></a>段和节</h3><p>段是程序执行的必要组成部分，在每一个段中，会有着代码或者数据被划分为不同的节。节头表是对这些节的位置和大小的描述，主要用于链接和调试。节头对于程序的执行来说不是必需的，没有节头表，程序仍可以正常执行，因为节头表没有对程序的内存布局进行描述，对程序内存布局的描述是程序头表的任务。节头是对程序头的补充。</p><p>如果二进制文件中缺少节头，并不意味着节不存在，只是没有办法通过节头来引用节，对于调试器或者反编译器程序来说，只是可以参考的信息变少了而已。</p><p><img src="/posts/60390/640.webp" alt></p><p>保留区的上边就是代码段和数据段，它们是从程序的二进制文件中直接加载进内存中的，BSS 段中的数据也存在于二进制文件中，因为内核知道这些数据是没有初值的，所以在二进制文件中只会记录 BSS 段的大小，在加载进内存时会生成一段 0 填充的内存空间。</p><p>堆空间的上边是一段待分配区域，用于扩展堆空间的使用。接下来就来到了文件映射与匿名映射区域。进程运行时所依赖的动态链接库中的代码段，数据段，BSS 段就加载在这里。还有我们调用 mmap 映射出来的一段虚拟内存空间也保存在这个区域。<strong>注意：在文件映射与匿名映射区的地址增长方向是从高地址向低地址增长</strong>。</p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247486732&idx=1&sn=435d5e834e9751036c96384f6965b328">推荐阅读</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;如果它存在，而且你能看见它，它是物理的（real）&lt;br&gt;如果它不存在，但你能看见它，它是虚拟的（virtual）
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://JoyTsing.github.io/categories/Linux/"/>
    
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
      <category term="操作系统" scheme="https://JoyTsing.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>mmap,比想象的更重要一点</title>
    <link href="https://joytsing.github.io/posts/30090/"/>
    <id>https://joytsing.github.io/posts/30090/</id>
    <published>2024-04-18T15:42:56.000Z</published>
    <updated>2024-04-18T16:08:28.852Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、mmap基础概念"><a href="#1、mmap基础概念" class="headerlink" title="1、mmap基础概念"></a>1、mmap基础概念</h2><p>mmap 是一种内存映射文件的方法，即将一个文件或者其他对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一映射关系。</p><p>实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必调用read,write等系统调用函数。相反，内核空间的这段区域的修改也直接反应用户空间，从而可以实现不同进程的文件共享。如下图所示：</p><p><img src="/posts/30090/640.webp" alt></p><p>由上图可以看出，进程的<strong>虚拟地址空间</strong>，由多个<strong>虚拟内存</strong>区域构成。<strong>虚拟内存区域是进程的虚拟地址空间中的一个同质区间</strong>，即具有同样特性的连续地址范围。上图中所示的<code>.text数据段</code>、<code>初始数据段</code>、<code>.bss数据段</code>、堆、栈、内存映射，都是一个独立的虚拟内存区域。而为内存映射服务的地址空间处在堆栈之间的空余部分。</p><p>linux 内核使用的<code>vm_area_struct</code> 结构来表示一个独立的虚拟内存区域，由于每个不同质的虚拟内存区域功能和内部机制不同；因此同一个进程使用多个<code>vm_area_struct</code>结构来分别表示不同类型的虚拟内存区域。各个<code>vm_area_struct</code> 结构使用链表或者树形结构链接，方便进程快速访问。如下图所示：</p><p><img src="/posts/30090/640-1713455374225-1.webp" alt></p><p><code>vm_area_struct</code> 结构中包含区域起始和终止地址以及其他相关信息，同时也包含一个vm_ops 指针，其内部可引出所有针对这个区域可以使用的系统调用函数。这样，进程对某一虚拟内存区域的任何操作都需要的信息，都可以从<code>vm_area_struct</code> 中获得。mmap函数就是要创建一个新的<code>vm_area_struct</code>结构 ，并将其与文件的物理磁盘地址相连。具体步骤如下：</p><h2 id="2、mmap-内存映射原理"><a href="#2、mmap-内存映射原理" class="headerlink" title="2、mmap 内存映射原理"></a>2、mmap 内存映射原理</h2><p>mmap 内存映射实现过程，总的来说可以分为三个阶段：</p><p>（一）进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域</p><p>1、进程在用户空间调用函数mmap ，原型：<code>void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);</code></p><p>2、在当前进程虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址</p><p>3、为此虚拟区分配一个<code>vm_area_struct</code> 结构，接着对这个结构各个区域进行初始化</p><p>4、将新建的虚拟区结构（vm_area_struct）插入进程的虚拟地址区域链表或树中</p><p>（二）调用内核空间的系统调用函数<strong>mmap</strong> （不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系</p><p>5、为映射分配新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文集”中该文件结构体，每个文件结构体维护者和这个已经打开文件相关各项信息。</p><p>6、通过该文件的文件结构体，链接到file_operations模块，调用内核函数mmap，其原型为：int mmap(struct file *filp, struct vm_area_struct *vma)，不同于用户空间库函数。</p><p>7、内核mmap函数通过虚拟文件系统inode模块定位到文件磁盘物理地址。</p><p>8、通过remap_pfn_range函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。此时，这片虚拟地址并没有任何数据关联到主存中。</p><p>（三）进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝。</p><p>前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据拷贝至主存。真正的文件读取是当进程发起读或者写操作时。</p><p>9、进程的读写操作访问虚拟地址空间这一段映射地址后，通过查询页表，先这一段地址并不在物理页面。因为目前只建立了映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。</p><p>10、缺页异常进行一系列判断，确定无法操作后，内核发起请求掉页过程。</p><p>11、调页过程先在交换缓存空间中寻找需要访问的内存页，，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。</p><p>12、之后进程即可对这片主存进行读或者写的操作了，如果写操作改变了内容，一定时间后系统自动回写脏页面到对应的磁盘地址，也即完成了写入到文件的过程。</p><p>注：修改过的脏页面并不会立即更新回文件，而是有一段时间延迟，可以调用msync() 来强制同步，这样所写的内容就能立即保存到文件里了。</p><h2 id="3、mmap和常规文件操作的区别"><a href="#3、mmap和常规文件操作的区别" class="headerlink" title="3、mmap和常规文件操作的区别"></a>3、mmap和常规文件操作的区别</h2><p>首先我们来回顾一下常规文件操作，函数的调用过程：</p><p>1、进程发起读文件请求</p><p>2、内核通过查找进程文件符表。</p><p>3、inode在address_space上查找要请求的文件页是否已经缓存在页缓存中。如果存在，则直接返回这片文件页的内容。</p><p>总的来说，常规文件操作为了提高读写效率和保护磁盘，使用了页缓存机制，这样造成了读文件时需要先将文件页从磁盘拷贝到缓存中，由于页缓存处在内核空间，不能被用户进程直接寻址，所以还需要将页缓存中数据页再次拷贝到内存对用的用户空间中。这样通过两次拷贝过程，才能完成进程对文件内容的获取。写操作也一样，待写入的Buffer在内核空间不能直接访问，必须先拷贝到内核空间对应的主存，再回写磁盘中，也是需要两次数据拷贝。</p><p>而使用mmap 操作文件中，创建新的虚拟内存区域、建立文件磁盘地址和内存区域映射这两步，没有任何文件拷贝操作。而之后访问数据时，发现内存中并无数据而发起的缺失页异常过程，可以通过建立好的映射关系，只使用一次数据拷贝，就从磁盘中将数据传入内存的用户空间中，供过程使用。</p><p><strong>总而言之，常规的文件操作需要从磁盘到页缓存再到用户主存的两次数据拷贝，而mmap操作文件，只需要从磁盘到用户主存的一次数据拷贝过程。</strong>说白了，mmap的关键点是实现了用户空间和内核的数据直接交互省去了空间不同数据不通的繁琐过程。因此 mmap效率更高。</p><h3 id="mmap优点总结"><a href="#mmap优点总结" class="headerlink" title="mmap优点总结"></a>mmap优点总结</h3><p>由上文讨论可知，mmap 优点共有以下几点：</p><ol><li>对文件的读取操作跨过了页缓存，减少了数据的拷贝次数，用内存读写取代了I/O读写，提高了读取的效率。</li><li>实现了用户空间和内核空间的高校交互方式，两空间的各自修改操作可以直接反映在映射的区域内，从而被对方空间及时捕捉。</li><li>提供进程间共享内存及互相通信的方式。不管是父子进程还是无亲缘关系进程，都可以将自身空间用户映射到同一个文件或者匿名映射到同一片区域。从而通过各自映射区域的改动，打到进程间通信和进程间共享的目的。同时，如果进程A和进程 B 都映射了区域C,当A第一次读取C时候，通过缺页从磁盘复制文件页到内存中，但当B再读C的相同页面时，虽然也会产生缺页异常，但是不会从磁盘中复制文件过来，而是直接使用已经保存再内存中的文件数据。</li><li>可用于实现高效的大规模数据传输。内存空间不足，是制约大数据操作的一个方面，解决方案往往是借助于硬盘空间的协助，补充内存的不足。但是进一步造成大量的文件I/O操作，极大影响效率。这个问题可以通过mmap映射很好的解决。换句话说，但凡需要磁盘空间代替内存的时候，mmap都可以发挥功效。</li></ol><h3 id="mmap使用细节"><a href="#mmap使用细节" class="headerlink" title="mmap使用细节"></a>mmap使用细节</h3><p>使用mmap需要注意一点，mmap映射区域大小必须是物理页大小（page_size）的整数倍，原因是：内存的最小粒度是页，而进程虚拟地址空间和内存的映射单位也是以页为单位，为了匹配内存操作，mmap从磁盘到虚拟地址空间的映射也必须是页。</p><p>内核可以跟踪被内存映射的底层对象，大小。就是说，如果文件的大小一直再扩张，只要再映射区域范围内的数据，进程都可以依法得到，这和映射建立时文件的大小无关。</p><p>映射建立后，即使文件关闭，映射依然存在。因为映射的是磁盘的地址，不是文件本身，和文件句柄无关，同时可用于进程间通信的有效地址空间，不完全受限于被映射文件的大小，因为是按页映射。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、mmap基础概念&quot;&gt;&lt;a href=&quot;#1、mmap基础概念&quot; class=&quot;headerlink&quot; title=&quot;1、mmap基础概念&quot;&gt;&lt;/a&gt;1、mmap基础概念&lt;/h2&gt;&lt;p&gt;mmap 是一种内存映射文件的方法，即将一个文件或者其他对象映射到进程的地址
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://JoyTsing.github.io/categories/Linux/"/>
    
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Cpp中move的原理</title>
    <link href="https://joytsing.github.io/posts/1343/"/>
    <id>https://joytsing.github.io/posts/1343/</id>
    <published>2024-04-16T01:12:07.000Z</published>
    <updated>2024-04-16T02:27:14.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>怎么用就不多说了，也不扯语言学家的问题，主要来研究一下实现原理是什么？</p><h2 id="移动不移动"><a href="#移动不移动" class="headerlink" title="移动不移动"></a>移动不移动</h2><p>正如完美转发不完美。</p><p>右值引用本身其实就是一个栈上的普通变量，它是 <strong>lvalue</strong>。而使用右值引用做函数参数是为了优先匹配直接传入函数返回值的情况，从而跟常引用做参数来进行区分。通常情况下，用右值引用接收一个对象，是为了复用它的资源，来进行浅复制的。就好像，我们把原本的资源「移动」到了新的对象当中去，因此称之为「移动语义」。含有移动语义的构造函数就称为「移动构造函数」、含有移动语义的赋值函数就称为「移动赋值函数」。所以大家一定要清楚，这里的「移动」是「语义」上的，并没有真的移动，一般就是用来做浅复制的。</p><p><code>std::move</code>就是帮助我们做一件事情，即在构造一个变量（或者其他情况）的时候不使用拷贝构造而是使用移动构造。我们已经知道，如果想进行移动语义，那么就需要用右值引用来接收。但目前我们要操作的值是一个左值（不然也就不存在需要移动的情况），那么如何让编译器知道我们要进行的操作？让它当作右值来处理，因为就像上文说的，移动不移动，又不会真的去 check 入参的左右性。</p><p>以下面的代码为例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  String str1<span class="token punctuation">;</span>  String str2 <span class="token operator">=</span> str1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这里会调用拷贝构造，因为str1是左值</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要把这个 str1，伪装成右值，骗过编译器去触发右值引用的重载函数。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  String str1<span class="token punctuation">;</span>  String str2 <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>String <span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 强制转成右值引用，去触发移动构造函数</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的=号不是赋值的等号，而是构造参数的语法糖，即等价于：</p><pre class="line-numbers language-cpp"><code class="language-cpp">String <span class="token function">str2</span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>String <span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 构造参数，所以是用来匹配函数参数的</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么<code>std::move</code>怎么实现的大概大家就有个数了：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">constexpr</span> std<span class="token operator">::</span>remove_reference_t<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">&amp;&amp;</span><span class="token function">move</span><span class="token punctuation">(</span>T <span class="token operator">&amp;&amp;</span>ref<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>std<span class="token operator">::</span>remove_reference_t<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>ref<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>一定一定要把握一个原则，<code>std::move</code><strong>的本质是为了伪装，它并不能改变变量的左右性。</strong>也就是说，<code>std::move(str1)</code>并不能把 str 变成 rvalue，它本身是个变量，那么它就是 <strong>lvalue</strong>，一直都是。move 的作用仅仅在于，构造 str2 的时候能触发移动构造函数，仅此而已，其他的什么都没变。</p><p>那么也就是说，尽管我们用了「移动语义」来构造了 str2，但其实 str1 还是存在的，该是什么样还是什么样，并不会真的被「移动」。而此时的 str2 是 str1 的浅复制版本，原本的话它们的 buf_ 会指向同一片空间的，但因为我们在移动构造函数中强制把原来的对象 buf_ 给置空了，因此这里 str1 内部会出现空指针。所以这里有一次印证了「移动语义是软约束」这件事，使用之后行为如何，会不会出问题，完全取决代码怎么写。</p><h3 id="一些实现细节"><a href="#一些实现细节" class="headerlink" title="一些实现细节"></a>一些实现细节</h3><p>理解 std::move() 需要明白如下几点：</p><p>（1）引用折叠</p><ul><li>间接创建（只能间接，如类型别名或模板参数，语法不支持直接创建）引用的引用，这些引用会形成“折叠”</li><li>T&amp; &amp;、T&amp; &amp;&amp;、T&amp;&amp; &amp; 都会折叠成左值引用 T&amp;</li><li>T&amp;&amp; &amp;&amp; 折叠成右值引用 T&amp;&amp;</li></ul><p>（2）模板右值引用参数</p><ul><li>模板函数形参类型是 T&amp;&amp;，而实参是一个左值，推断出的模板实参类型将是 T&amp;，且函数参数将被实例化一个普通的左值引用参数 T&amp;</li><li>模板函数形参类型是 T&amp;&amp;，而实参是一个右值，推断出的模板实参类型将是 T，且函数参数将被实例化一个普通参数 T</li></ul><p>（3）从一个左值 static_cast 到一个右值引用是允许的，而static_cast之所以能使用类型转换，是通过<code>remove_refrence::type</code>模板移除T&amp;&amp;，T&amp;的引用，获取具体类型T</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//原始的，最通用的版本</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span> <span class="token keyword">struct</span> remove_reference<span class="token punctuation">{</span>    <span class="token keyword">typedef</span> T type<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//定义T的类型别名为type</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//部分版本特例化，将用于左值引用和右值引用</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token keyword">struct</span> remove_reference<span class="token operator">&lt;</span>T<span class="token operator">&amp;</span><span class="token operator">></span> <span class="token comment" spellcheck="true">//左值引用</span><span class="token punctuation">{</span> <span class="token keyword">typedef</span> T type<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token keyword">struct</span> remove_reference<span class="token operator">&lt;</span>T<span class="token operator">&amp;&amp;</span><span class="token operator">></span> <span class="token comment" spellcheck="true">//右值引用</span><span class="token punctuation">{</span> <span class="token keyword">typedef</span> T type<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//举例如下,下列定义的a、b、c三个变量都是int类型</span><span class="token keyword">int</span> i<span class="token punctuation">;</span>remove_refrence<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">::</span>type a<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//使用原版本，</span>remove_refrence<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">::</span>type  b<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//左值引用特例版本</span>remove_refrence<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">::</span>type  b<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//右值引用特例版本</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;怎么用就不多说了，也不扯语言学家的问题，主要来研究一下实现原理是什么？&lt;/p&gt;
&lt;h2 id=&quot;移动不移动&quot;&gt;&lt;a href=&quot;#移动不移动
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>人祖传小故事一则</title>
    <link href="https://joytsing.github.io/posts/16525/"/>
    <id>https://joytsing.github.io/posts/16525/</id>
    <published>2024-04-16T00:48:23.000Z</published>
    <updated>2024-04-16T00:54:05.141Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>看小说看到的，感触很大。</p><p>“一个人的坚持有多难？”</p><p>“一定要坚持啊，方源。”</p><p>“活下去，坚持下去。”</p><p>“这是我对你的忠告，唯一的礼物。咱们这种小人物，哭是没有用的，喊也是没人听，只能自己坚持。”</p><p>“坚持下去，直至成就伟大，脱离平凡，或者迎接死亡。“</p><h2 id="人祖传第二十九节-坚持蛊"><a href="#人祖传第二十九节-坚持蛊" class="headerlink" title="人祖传第二十九节-坚持蛊"></a>人祖传第二十九节-坚持蛊</h2><p>人祖的女儿森海轮回，被困在了平凡深渊当中。</p><p>她和一位小人交上了朋友，然后小人带着森海轮回，观看了他的家园——市井。</p><p>森海轮回观看了市井之后，忽然仰头看向天空。</p><p>“我明白了。”森海轮回望着自己的头顶。</p><p>她被困在平凡深渊当中，其实和生活在井底的小人是一样的。小人仰头，看向井口描绘的天空，无异于森海轮回仰头，看向平凡深渊勾勒出来的天空。</p><p>“我决定了，我要自己努力，走出这处深渊，和父亲汇合！”森海轮回捏起双拳，下定了决心。</p><p>小人很高兴：“好啊。我也想离开平凡深渊，看看更大更辽阔的世界。我看到深渊里有不少树木，我们可以将这些树木都砍了，做成梯子，然后一步步地爬出去。”</p><p>森海轮回咦了一声，奇怪地看向小人：“小人啊，小人，你不是长着一对翅膀的吗？为什么不能直接飞走呢？”</p><p>小人苦笑道：“人啊，别看我有这么一对翅膀，其实它薄弱而且无力，只能带动我的身体缓缓地飞一小段距离。我当初离开市井，也是搭梯子爬出来的。”</p><p>“原来是这样啊。”森海轮回恍然大悟。</p><p>接下来的日子里，她便和小人一起，砍伐树木，搭建梯子。</p><p>一棵棵树木倒下来，飞出智慧蛊。</p><p>森海轮回感到很惊讶：“智慧蛊，你怎么在这里？”</p><p>“平凡中隐藏着智慧，我当然能在这里。”智慧蛊答道。</p><p>然后智慧蛊又说：“你们很聪明嘛，懂得运用前人的成就，来帮助自己脱离平凡。但是你们两个想要走出平凡深渊，必须每一个人都搭自己的梯子，整个过程独自完成，否则的话，你们是走不出去的。”</p><p>森海轮回连忙点头：“智慧蛊啊，谢谢你的提醒，我们会注意的。”</p><p>她和小人分别做自己的梯子。</p><p>梯子越做越高，很快，森海轮回的梯子就超越了小人。</p><p>小人的梯子又矮又小，每一个横杆之间，间距也短。</p><p>一比较起来，森海轮回的梯子，又长又高。</p><p>森海轮回就取笑小人：“小人啊小人，我耗费半天时间做出来的梯子，就抵得上你半个月的功夫了。你这样做，何年何月才能做出一个高高的梯子，让你踩着，走出平凡深渊啊？”</p><p>小人无奈地道：“我也没有办法啊。我已经用尽了全力，可是我耗费半天时间，扛过来的木条。你用一只手，就能拿过来一捆。我辛苦好久才能砍断的小树，你两三下就能砍倒。我已经拼尽了全力，只能达到这种程度了。”</p><p>森海轮回点点头：“可惜了，我们只能各自做自己的梯子。”</p><p>小人道：“没错，脱离平凡深渊，可以依赖前人的成就，但是真正依靠的，只有自己。咱们继续加油努力吧。”</p><p>森海轮回和小人便继续伐树，做成梯子。</p><p>树木一棵棵的倒下来，从中又飞出了力量蛊。</p><p>森海轮回感到很惊讶：“力量蛊啊，你怎么在这里？”</p><p>“平凡中潜藏着力量，我当然能在这里。”力量蛊答道。</p><p>森海轮回想了想，问道：“力量蛊啊，你有什么可以指点我的呢？就像智慧蛊那样。”</p><p>力量蛊说：“我没有什么可以指点你的。但是我可以赋予你更强大的力量，只要你奉献出你的青年就可以了。”</p><p>森海轮回陷入犹豫当中。</p><p>力量蛊又道：“按照你现在的力量，什么时候才能搭建出足够高的梯子，走出平凡深渊呢？”</p><p>森海轮回想了想：“时间很长，需要二三十年。”</p><p>力量蛊道：“是啊，那个时候你已经不再年轻，失去了青年，到了中年。与其这样，你不如将青年交给我，虽然你会直接步入中年，但你只需要几年的时间，就能搭建好梯子了。”</p><p>森海轮回一想，点点头：“你说的太对了，力量蛊，就依你吧。”</p><p>于是森海轮回拥有了力量蛊，她建立梯子的速度变得更快了，一次能砍伐的树木更多了。一年之后，她将梯子搭到了很高很高的地方。</p><p>她走在梯子的最高处，往下看。</p><p>她看到树木变得很小，草都化为了一片绿色，很开心：“原来站在高处，平日里很大的东西，都变得很小了。就像我之前看市井一样。”</p><p>她再看一旁，小人搭建的梯子，很矮小，连她的梯子的百分之一都不如，不由地撇撇嘴。</p><p>森海轮回便走下梯子，对小人说：“你怎么才搭建了这么点高度啊，你看我的梯子已经有这么高了！”</p><p>小人仰望着她的梯子，十分崇拜，又十分无奈：“你真是让我羡慕啊，自身的力量就超越了我，现在又有力量蛊帮忙。可惜我什么帮手都没有，只有靠自己。我已经尽力了，每天除了休息和吃饭，我都用来搭建自己的梯子，可是根本比不上你啊。”</p><p>森海轮回点点头：“那是当然的。”</p><p>又一年过去了。</p><p>森海轮回又将梯子搭建得更高。</p><p>她站在最顶端，往下看。</p><p>树木变得跟小草一样，比树更小的东西，她都有点看不清了。</p><p>她再看小人搭建的梯子，虽然它比一般的树更高，但连森海轮回梯子的千分之一都没有。</p><p>森海轮回走下梯子，笑着对小人说：“小人啊小人，我劝你不要费劲了吧。你的力量太小太小，恐怕花费一生的时间，都搭建不了那样的梯子出来。你还不如用这个时间，好好享受一下生活。”</p><p>“其实你已经足够优秀啦，你比你的那些小人同胞见识更广，你已经走出了市井。不如好好地享受一下生活。”</p><p>小人认真地想了想，然后摇摇头：“可是我已经不满足平凡了。当我不满足平凡之后，平凡对我而言就是一座深渊，我想走出去。即便最终不成功，但我也想要努力。因为我如果不努力，我就感到活得不开心。”</p><p>于是，小人继续搭建他的梯子。</p><p>第三年过去了。</p><p>森海轮回再次将梯子建得非常高。</p><p>她站在最顶端，往下看。</p><p>只看到一片片的云和雾，遮蔽了她的视野。</p><p>她想看小人建的梯子，勉勉强强看到了，发现他的梯子和自己相比，连万分之一都不如。</p><p>森海轮回叹息一声，感到了孤独。</p><p>风一吹，她浑身一颤，又感到了寒冷。</p><p>“原来站在高处，不仅孤独，而且寒冷呐。”森海轮回走下了梯子，将这个感受告诉了小人。</p><p>小人摇头道：“我的梯子还不够高，不知道你这种是什么样的感觉。”</p><p>森海轮回感到很无趣。</p><p>她仍旧继续搭建梯子，但是每天耗费在这里的时间，越来越少。</p><p>力量蛊偶尔问她道：“人啊，你怎么不去搭建你的梯子呢？”</p><p>森海轮回便回答道：“梯子太高了，太寒冷，我得好好歇一歇，让身体回暖。”</p><p>就这样一年过去了。</p><p>森海轮回感到很无聊。</p><p>她继续搭建自己的梯子，只是每天努力的时间更少了。</p><p>力量蛊偶然的时候问她：“人啊，你怎么不去搭建你的梯子呢？”</p><p>森海轮回回答道：“梯子太高了，我每一次往下看，都感到有些害怕。我得充分休息，让自己的心平静下来。”</p><p>再一年过去。</p><p>森海轮回变得更加懒散。</p><p>力量蛊问她：“你看你身边的小人，他总是在搭建自己的梯子，从没有懈怠过，拼尽全力。你再这样懒散下去，迟早有一天会被她超越的。”</p><p>森海轮回笑道：“怎么可能？我一天的时间，能抵他辛辛苦苦一个月。我怎么可能被他超越呢？”</p><p>就这样年复一年，日复一日。</p><p>终于有一天，小人找到躺在树荫下休息的森海轮回，对她道：“我的朋友啊，我的梯子已经够上了深渊的崖边，我明天就可以出去，离开平凡深渊了。”</p><p>森海轮回哈哈大笑：“小人啊，你不要骗我了，这种话太可笑。”</p><p>小人摇摇头，认真地道：“伟大和可笑，只是一点点的差距。现在我已经不可笑了，我已经变得伟大，可以脱离这个平凡深渊了。你不相信的话，就看我爬出去吧。”</p><p>于是，小人开始爬他的梯子。</p><p>森海轮回这才吃惊地看到，小人的梯子真的已经搭上了崖边，他就真的这样爬上去，渐渐要离开平凡深渊。</p><p>森海轮回大叫：“小人啊，难道你没有感受到寒冷吗？”</p><p>小人说：“有啊，但我要搭梯子，想要爬出去。”</p><p>森海轮回又大叫：“小人啊，难道没有感到孤独吗？”</p><p>小人说：“有啊，但我要搭梯子，想要爬出去。”</p><p>森海轮回再大叫：“小人啊，难道没有感到害怕吗？”</p><p>小人说：“有啊，但我要搭梯子，想要爬出去。”</p><p>小人答完这三句话后，忽然他的身体绽放出了耀眼的光辉，很快光辉变成了一只蛊虫。</p><p>“我的名字叫做坚持，小人啊，谢谢你孵育了我。”坚持蛊向小人道谢。</p><p>小人笑道：“太好了，我虽然没有力量，但我有坚持。”</p><p>小人说着，爬出了平凡深渊，踏足外面的世界。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;看小说看到的，感触很大。&lt;/p&gt;
&lt;p&gt;“一个人的坚持有多难？”&lt;/p&gt;
&lt;p&gt;“一定要坚持啊，方源。”&lt;/p&gt;
&lt;p&gt;“活下去，坚持下去。
      
    
    </summary>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Cpp中新时代格式化输出方法</title>
    <link href="https://joytsing.github.io/posts/17315/"/>
    <id>https://joytsing.github.io/posts/17315/</id>
    <published>2024-04-15T13:44:57.000Z</published>
    <updated>2024-04-15T14:20:53.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>别的语言早就有的东西，积重难返的C++总是晚了很多年才有，在这之前搞了很多格式化方案，直到C++20才大刀阔斧改掉。</p><p><img src="/posts/17315/image-20240415215042243.png" alt></p><h2 id="Formatting"><a href="#Formatting" class="headerlink" title="Formatting"></a>Formatting</h2><p>最基础的格式化函数 format 开始，其定义是这样:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span>std<span class="token operator">::</span>string <span class="token function">format</span><span class="token punctuation">(</span>std<span class="token operator">::</span>format_string<span class="token operator">&lt;</span>Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span> fmt<span class="token punctuation">,</span> Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第一个参数是格式化字符串，描述文本格式，后续参数就是需要被格式化的其他参数。C++20 在 C++11 的基础上，为 chrono 库提供了完善的 format 支持，我们再也不需要使用旧的 C 风格时间格式化函数了。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 使用 std::chrono 来打印日志的时间</span><span class="token keyword">using</span> TimePoint <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>time_point<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里简单说明一下 format 的格式化字符串格式。格式化字符串由以下三类元素组成。</p><ul><li>普通字符（除了 { 和 } 以外），这些字符会被直接拷贝到输出中，不会做任何更改。</li><li>转义序列，包括 ，在输出中分别会被替换成{和}。</li><li>替换字段，由 { … } 构成，这些替换字段会替换成 format 后续参数中对应的参数，并根据格式控制描述生成输出。</li></ul><p>对于替换字段的两种形式:</p><p><img src="/posts/17315/image-20240415215439722.png" alt></p><p>除了最简单的 format 参数，C++20 还提供了三个有用的工具函数，作为扩展功能: 1. <code>format_to</code> 2.<code>format_to_n</code> 3. <code>formatted_size</code></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;format></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// format_to</span>    <span class="token comment" spellcheck="true">// 将生成的文本输出到一个输出迭代器中，</span>    <span class="token comment" spellcheck="true">// 其他与format一致，这样可以兼容标准STL算法函数的风格，</span>    <span class="token comment" spellcheck="true">// 也便于将文本输出到其他的流中或者自建的字符串类中。</span>    std<span class="token operator">::</span>string resultLine1<span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">format_to</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">back_inserter</span><span class="token punctuation">(</span>resultLine1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"{} + {} = {}"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> resultLine1 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// format_to_n</span>    <span class="token comment" spellcheck="true">// 将生成的文本输出到一个输出迭代器中，同时指定输出的最大字符数量。</span>    <span class="token comment" spellcheck="true">// 其他与format一致，相当于format_to的扩展版本，</span>    <span class="token comment" spellcheck="true">// 在输出目标有字符限制的时候非常有效。</span>    std<span class="token operator">::</span>string <span class="token function">resultLine2</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">format_to_n</span><span class="token punctuation">(</span>resultLine2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">"{} + {} = {}"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> resultLine2 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// formatted_sizes</span>    <span class="token comment" spellcheck="true">// 获取生成文本的长度，参数与format完全一致。</span>    <span class="token keyword">auto</span> resultSize <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">formatted_size</span><span class="token punctuation">(</span><span class="token string">"{} + {} = {}"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> resultSize <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    std<span class="token operator">::</span>string <span class="token function">resultLine3</span><span class="token punctuation">(</span>resultSize<span class="token punctuation">,</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">format_to</span><span class="token punctuation">(</span>resultLine3<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"{} + {} = {}"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> resultLine3 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="格式化参数包"><a href="#格式化参数包" class="headerlink" title="格式化参数包"></a>格式化参数包</h3><p>format 函数，可以直接以函数参数形式进行传递。此外，C++20 还提供了 format_args 相关接口，可以把“待格式化的参数”合并成一个集合，通过 vformat 函数进行文本格式化。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;format></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdint></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>string resultLine1 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">vformat</span><span class="token punctuation">(</span><span class="token string">"{} * {} = {}"</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">make_format_args</span><span class="token punctuation">(</span>        <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">4</span>    <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> resultLine1 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    std<span class="token operator">::</span>format_args args <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">make_format_args</span><span class="token punctuation">(</span>        <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">4</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>string resultLine2<span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">vformat_to</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">back_inserter</span><span class="token punctuation">(</span>resultLine2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"{} * {} = {}"</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> resultLine2 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>针对上述代码中用到的类型和函数:</p><ul><li><strong>第一，format_args 类型</strong>，表示一个待格式化的参数集合，可以包装任意类型的待格式化参数。这里需要注意的是 format_args 中包装的参数是引用语义，也就是并不会拷贝或者扩展包装参数的生命周期，所以开发者需要确保被包装参数的生命周期。所以一般来说，format_args 也就用于格式化函数的参数，不建议用于其他用途。</li><li><strong>第二，make_format_args 函数</strong>，用于通过一系列参数构建一个 format_args 对象。类似地，需要注意返回的 format_args 的引用语义。</li><li><strong>第三，vformat 函数</strong>。包含两个参数，分别是格式化字符串（具体规范与 format 函数完全一致）和 format_args 对象。该函数会根据格式化字符串定义去 format_args 对象中获取相关参数并进行格式化输出，其他与 format 函数没有差异。</li><li><strong>第四，vformat_to 函数</strong>。该函数与 format_to 类似，都是通过一个输出迭代器进行输出的。差异在于，该函数接收的“待格式化参数”，需要通过 format_args 对象进行包装。因此，vformat 可以在某些场景下替代 format。至于具体使用哪个，你可以根据自己的喜好进行选择。</li></ul><h3 id="formatting"><a href="#formatting" class="headerlink" title="formatting"></a>formatting</h3><p>Formatting 库的核心是 formatter 类，对于所有希望使用 format 进行格式化的参数类型来说，都需要按照约定实现 formatter 类的特化版本。</p><p>formatter 类主要完成的工作就是：格式化字符串的解析、数据的实际格式化输出。C++20 为基础类型与 string 类型定义了标准的 formatter。此外，我们还可以通过特化的 formatter 来实现其他类型、自定义类型的格式化输出。</p><h2 id="标准格式化规范"><a href="#标准格式化规范" class="headerlink" title="标准格式化规范"></a>标准格式化规范</h2><p>C++ Formatting 的标准格式化规范，是以 Python 的格式化规范为基础的。基本语法:</p><pre><code>填充与对齐   符号   #   0   宽度   精度L   类型</code></pre><p>这里的每个参数都是可选参数。</p><h3 id="填充与对齐"><a href="#填充与对齐" class="headerlink" title="填充与对齐"></a>填充与对齐</h3><p>第一个为填充与对齐，用于设置填充字符与对齐规则。</p><p>该参数包含两部分，第一部分为填充字符，如果没有设定，默认使用空格作为填充。第二部分为填充数量与对齐方式，填充数量就是指定输出的填充字符数量，对齐方式指的是待格式化参数输出时相对于填充字符的位置。</p><p>目前 C++ 支持三种对齐方式：</p><p><img src="/posts/17315/image-20240415220500132.png" alt></p><h3 id="符号前缀显示"><a href="#符号前缀显示" class="headerlink" title="符号前缀显示"></a>符号前缀显示</h3><p>“符号” “#” 和“0”，用于设定数值类型的前缀显示方式。</p><p><strong>“符号”可以设置数字前缀的正负号显示规则。</strong>需要注意的是，“符号”也会影响 inf 和 nan 的显示方式。</p><p><img src="/posts/17315/image-20240415220544677.png" alt></p><p><strong>“#” 会对整数和浮点数有不同显示行为。</strong></p><p>如果被格式化参数为整数，并且将整数输出设定为二进制、八进制或十六进制时会在数字前添加进制前缀，也就是 0b、0 和 0x。 如果被格式化参数为浮点数，那么即使浮点数没有小数位数，也会强制在数字后面追加一个小数点。</p><p><strong>“0” 用于为数值输出填充 0，并支持设置填充位数。</strong>比如 04 就会填充 4 个 0。</p><h3 id="宽度与精度"><a href="#宽度与精度" class="headerlink" title="宽度与精度"></a>宽度与精度</h3><p>宽度用于设置字段输出的最小宽度，可以使用一个十进制数，也可以通过 {} 引用一个参数。</p><p>精度是一个以 . 符号开头的非负十进制数，也可以通过{}引用一个参数。对于浮点数，该字段可以设置小数点的显示位数。对于字符串，可以限制字符串的字符输出数量。</p><p>宽度与精度都支持通过 {} 引用参数，此时如果参数不是一个非负整数，在执行 format 时就会抛出异常。</p><h3 id="L-与类型"><a href="#L-与类型" class="headerlink" title="L 与类型"></a>L 与类型</h3><p>L 用于指定参数以特定语言环境（locale）方式输出参数，类型选项用于设置参数的显示方式。</p><p><img src="/posts/17315/image-20240415220757769.png" alt></p><h2 id="自定义-formatter"><a href="#自定义-formatter" class="headerlink" title="自定义 formatter"></a>自定义 formatter</h2><p>Formatting 库中的 formatter 类型对各种类型的格式化输出毕竟是有限的——它不可能覆盖所有的场景，特别是我们的自定义类型。我们先看一个最简单的自定义 formatter 案例。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;format></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdint></span></span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">CharT</span><span class="token operator">></span><span class="token keyword">struct</span> std<span class="token operator">::</span>formatter<span class="token operator">&lt;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>int32_t<span class="token operator">></span><span class="token punctuation">,</span> CharT<span class="token operator">></span> <span class="token operator">:</span> std<span class="token operator">::</span>formatter<span class="token operator">&lt;</span>int32_t<span class="token punctuation">,</span> CharT<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">FormatContext</span><span class="token operator">></span>    <span class="token keyword">auto</span> <span class="token function">format</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>int32_t<span class="token operator">></span> t<span class="token punctuation">,</span> FormatContext<span class="token operator">&amp;</span> fc<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>        <span class="token keyword">auto</span> it <span class="token operator">=</span> std<span class="token operator">::</span>formatter<span class="token operator">&lt;</span>int32_t<span class="token punctuation">,</span> CharT<span class="token operator">></span><span class="token operator">::</span><span class="token function">format</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>int32_t v <span class="token operator">:</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token operator">*</span>it <span class="token operator">=</span> <span class="token string">' '</span><span class="token punctuation">;</span>            it<span class="token operator">++</span><span class="token punctuation">;</span>            it <span class="token operator">=</span> std<span class="token operator">::</span>formatter<span class="token operator">&lt;</span>int32_t<span class="token punctuation">,</span> CharT<span class="token operator">></span><span class="token operator">::</span><span class="token function">format</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> fc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> it<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>int32_t<span class="token operator">></span> v <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 首先，调用format输出vector的长度，</span>    <span class="token comment" spellcheck="true">// 然后遍历vector，每次输出一个空格后再调用format输出数字。</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"{:#x}"</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这段代码中，实现了格式化显示 vector 类型的对象的功能。我们重点关注的是第 7 行实现的 formatter 特化——std::formatter, CharT&gt;。</p><p>其中，CharT 表示字符类型，它可以根据用户的实际情况替换成 char 或者 wchar_t 等。</p><p>通过代码你会发现，我们重载了 format 成员函数，该函数用于控制格式化显示。该函数包含两个参数:</p><ul><li>t: std::vector: 被传入的待格式化参数</li><li>fc: FormatContext&amp;: 描述格式化的上下文</li></ul><h2 id="一个实践"><a href="#一个实践" class="headerlink" title="一个实践"></a>一个实践</h2><p>可以尝试用<code>format</code>库和<code>source_location</code>配合实现一个日志库，当然能用就行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;别的语言早就有的东西，积重难返的C++总是晚了很多年才有，在这之前搞了很多格式化方案，直到C++20才大刀阔斧改掉。&lt;/p&gt;
&lt;p&gt;&lt;img
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="读书笔记" scheme="https://JoyTsing.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Cpp中还不完美的Coroutines</title>
    <link href="https://joytsing.github.io/posts/55948/"/>
    <id>https://joytsing.github.io/posts/55948/</id>
    <published>2024-04-15T07:23:58.000Z</published>
    <updated>2024-04-19T13:16:56.133Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Coroutines重要的不是它的性能，而是它带来的编程思维的改变，它能让你用同步的眼光去编写代码，也就是在对网络编程来说能消灭掉那些烦人的回调函数，仅此一点它的重要程度就不下于C++11，其次本篇文章为极客时间卢誉声老师的现代 C++20 实战高手课笔记，如果觉得本篇文章对你有帮助可以前去购买。</p><h2 id="C-协程"><a href="#C-协程" class="headerlink" title="C++协程"></a>C++协程</h2><p>首先，需要先纠正网络上盛传的观点“线程是轻量的进程，协程是更轻量的线程”，协程用一句话概括就是可以暂停恢复的函数。</p><p>而现代 C++20 标准下的协程，是一种可休眠、可恢复、不基于栈实现的函数。协程相较于函数来说是一个更加泛化的概念。函数只有“调用”和“返回”两个行为，而协程在这一基础上进行了扩展，增加了“休眠”和“恢复”。</p><p>同时，C++的协程属于无栈协程（与传统意义上的GO的协程不同），因此 C++ 并没有提供标准调度器，需要开发者按照规定的规则实现所需的接口约定（也就是需要在类或者结构体内部按照约定的名称命名函数，俗称硬编码），一般需要实现这么几个：</p><ul><li>调用者的传参方式。</li><li>将值返回给调用者的方式。</li><li>休眠与恢复执行的规则。</li><li>异常处理方式。</li></ul><h3 id="协程执行"><a href="#协程执行" class="headerlink" title="协程执行"></a>协程执行</h3><p>相较于函数，协程是一种可休眠、可恢复、不基于栈实现的函数。因此，它的生命周期管理自然与普通函数不同。也可以预见，C++ 中的协程是基于堆来实现的：</p><p><img src="/posts/55948/image-20240415154637876.png" alt></p><ol><li>调用函数在堆上创建协程帧（coroutine frame），用于存储协程的各类数据。协程帧的结构属于内存模型，因此不同编译器可能会有不同实现。</li><li>调用被调协程，开始执行协程代码。</li><li>被调协程执行到某个特定点，通过 co_await/co_yield 将当前协程休眠，线程 1 恢复自身原本的执行流程继续执行剩余代码</li><li>线程 2 通过协程句柄 coroutine_handle 的恢复函数 resume 恢复协程执行。</li><li>协程在线程 2 上恢复执行，继续向下执行，直到协程执行结束为止。结束后回到线程 2 的原本执行流程继续执行代码。</li><li>最后，线程 2 负责通过协程句柄 coroutine_handle 销毁协程帧。</li></ol><p>C++ 中的协程并不会像函数调用那样在栈上执行，它的状态储存在堆上。因此，我们只能在函数调用过程中，通过协程句柄 coroutine_handle 改变“部分”协程的状态——恢复或销毁。</p><p><img src="/posts/55948/v2-7c27069e79979fc3bc5c206d03dc8eab_720w.webp" alt></p><p>图中浅蓝色部分的方法就是 Return_t 关联的 promise 对象的函数，浅红色部分就是 co_await 等待的 awaiter。这个流程的驱动是由编译器根据协程函数生成的代码驱动的，分成三部分：</p><ul><li>协程创建；</li><li>co_await awaiter 等待 task 完成；</li><li>获取协程返回值和释放协程帧。</li></ul><h2 id="接口规定"><a href="#接口规定" class="headerlink" title="接口规定"></a>接口规定</h2><p>C++ 的协程要求开发者实现大量接口约定，而我们很难通过阅读标准文档来编写实际的代码，所以我们有必要学习一下实现接口约定的实践方法，这对我们在 C++ 里熟练应用协程非常重要。</p><p>实践里，有两个重要的用户自定义类型 Promise 和 Awaitable。我们先来看看 Promise（这里的promise和std::future里的promise没有任何关系，是协程和开发者约定的数据类型），Promise允许我们通过这个对象提供值，这个值会在之后计算得出：</p><p><img src="/posts/55948/image-20240415155849323.png" alt></p><p>生成器 Generator 用来控制协程，包括协程调用、返回值的操作、co_await/co_yield 的具体行为以及 promise_type 的具体定义。</p><p>我们要从 coroutine_traits 这一 concept 开始说起。标准中提供的代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span><span class="token keyword">struct</span> coroutine_traits <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">R</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span>requires requires <span class="token punctuation">{</span> <span class="token keyword">typename</span> R<span class="token operator">::</span>promise_type<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">struct</span> coroutine_traits<span class="token operator">&lt;</span>R<span class="token punctuation">,</span> Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">using</span> promise_type <span class="token operator">=</span> <span class="token keyword">typename</span> R<span class="token operator">::</span>promise_type<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际编程代码中特化的 coroutine_traits 必须定义一个公有的 promise_type 成员（见代码第 7 行）。否则，这就不是一个有效的协程类且属于未定义行为。也就是说，编译器会查找协程类中的 promise_type 作为 Promise，若 promise_type 不存在，就会发生编译时报错。</p><p>与此同时，一个协程类需要包含三个成员，分别是 <code>promise_type</code>、<code>coroutine_handle</code>和<code>coroutine_state</code>，这些都是硬编码，编译器不会给你任何提示（支持还不够好），其中：</p><p><strong>promise_type</strong> 在协程内操作时使用，它必须满足一定规则的类型，包含一系列约束的函数来支持休眠和恢复等功能，包括提交协程的返回值、提交协程异常。通常来说，编译器会通过 promise_type 的具体实现来判断协程是否合法。</p><p><strong>coroutine_handle</strong> 在协程外部操作时使用，可供调用者使用来休眠协程。它的类型是标准库提供的模板类，封装了协程帧的指针以及恢复、销毁协程帧的接口。</p><p><strong>coroutine_state</strong> 用于支持协程的生命周期，是运行时分配在堆（如果开启了编译器优化选项，则有可能会被优化使用寄存器）上的对象，目的是进一步规范说明协程执行时在堆上创建的数据，包括以下内容:</p><ul><li>promise 对象</li><li>参数（在协程创建时，会拷贝所有函数参数进入协程帧）</li><li>当前休眠的状态（在运行时，供后续恢复或销毁协程帧使用）</li><li>局部变量（在运行时，供协程帧使用）</li><li>临时变量（在运行时，供协程帧使用，它的生命周期是整个协程帧的生命周期）</li></ul><p>coroutine_state 参数还可以细分成这两种情况。</p><ul><li>值类型的参数会被移动或拷贝。</li><li>引用类型的参数会拷贝引用，当被引用的内存被释放了，那么协程状态中的引用会变成一个野引用。</li></ul><p>这三个成员里，coroutine_state 是比较特殊的抽象，是支持协程运行时的。</p><h3 id="promise-type"><a href="#promise-type" class="headerlink" title="promise_type"></a>promise_type</h3><p>对于 promise_type，它是实现协程的最关键一环。开发者需要自己来实现它，代码如下所示:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">struct</span> promise<span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">struct</span> Generator <span class="token operator">:</span> std<span class="token operator">::</span>coroutine_handle<span class="token operator">&lt;</span>promise<span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token punctuation">{</span>  <span class="token keyword">using</span> promise_type <span class="token operator">=</span> promise<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">struct</span> promise <span class="token punctuation">{</span>  T _value<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 待计算的值</span>  std<span class="token operator">::</span>exception_ptr _exception<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 待抛出的异常</span>  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Ty<span class="token operator">></span>  <span class="token function">promise</span><span class="token punctuation">(</span>Ty<span class="token operator">&amp;&amp;</span> lambdaObj<span class="token punctuation">,</span> T value<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_value</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token function">promise</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_value</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token function">promise</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  Generator<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">get_return_object</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span> Generator<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">from_promise</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  std<span class="token operator">::</span>suspend_always <span class="token function">initial_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  std<span class="token operator">::</span>suspend_always <span class="token function">final_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// optional，但co_yield需要这一函数实现</span>  std<span class="token operator">::</span>suspend_always <span class="token function">yield_value</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span> <span class="token punctuation">{</span>      _value <span class="token operator">=</span> value<span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// optional，但co_return需要这一函数实现或return_void</span>  std<span class="token operator">::</span>suspend_always <span class="token function">return_value</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span> <span class="token punctuation">{</span>      _value <span class="token operator">=</span> value<span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">return_void</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">unhandled_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> _exception <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">current_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体的调用流程和需要实现的函数如下：</p><p><img src="/posts/55948/image-20240415162354807.png" alt></p><h3 id="coroutine-handle"><a href="#coroutine-handle" class="headerlink" title="coroutine_handle"></a>coroutine_handle</h3><p>看看标准库提供的 coroutine_handle 这一模版类的定义：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Promise</span><span class="token operator">></span><span class="token keyword">struct</span> coroutine_handle <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 构造函数和赋值函数</span>  <span class="token keyword">constexpr</span> <span class="token function">coroutine_handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>  <span class="token keyword">constexpr</span> <span class="token function">coroutine_handle</span><span class="token punctuation">(</span>nullptr_t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>  <span class="token keyword">static</span> coroutine_handle <span class="token function">from_promise</span><span class="token punctuation">(</span>Promise<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  coroutine_handle<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>nullptr_t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 导入和导出</span>  <span class="token keyword">constexpr</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">address</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获取coroutine_handle内部数据的指针</span>  <span class="token keyword">static</span> <span class="token keyword">constexpr</span> coroutine_handle <span class="token function">from_address</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> addr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将内部数据指针转换为对应的coroutine_handle对象，会创建一个新对象</span>  <span class="token comment" spellcheck="true">// 转换函数</span>  <span class="token keyword">constexpr</span> <span class="token keyword">operator</span> coroutine_handle<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 查询协程状态</span>  <span class="token keyword">constexpr</span> <span class="token keyword">explicit</span> <span class="token keyword">operator</span> <span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用于确定coroutine_handle是否有效</span>  <span class="token keyword">bool</span> <span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用于确定协程是否已经执行完成</span>  <span class="token comment" spellcheck="true">// 控制协程执行</span>  <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 行为同resume，用于唤醒协程</span>  <span class="token keyword">void</span> <span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用于唤醒协程</span>  <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用于销毁协程</span>  <span class="token comment" spellcheck="true">// 访问Promise对象</span>  Promise<span class="token operator">&amp;</span> <span class="token function">promise</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>  <span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// exposition only </span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">struct</span> coroutine_handle<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 构造函数和赋值函数</span>  <span class="token keyword">constexpr</span> <span class="token function">coroutine_handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>  <span class="token keyword">constexpr</span> <span class="token function">coroutine_handle</span><span class="token punctuation">(</span>nullptr_t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>  coroutine_handle<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>nullptr_t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 导入和导出</span>  <span class="token keyword">constexpr</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">address</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>  <span class="token keyword">static</span> <span class="token keyword">constexpr</span> coroutine_handle <span class="token function">from_address</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> addr<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 查询协程状态</span>  <span class="token keyword">constexpr</span> <span class="token keyword">explicit</span> <span class="token keyword">operator</span> <span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>  <span class="token keyword">bool</span> <span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 恢复协程执行</span>  <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>  <span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// exposition only</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相比于 void 类型的特化版本，如果开发者指定了 promise 类型，那么就会用通用版本的 coroutine_handle，这个类多了以下几个成员函数。</p><ul><li>from_promise：获取 promise 对应的 coroutine_handle。实际行为会根据 promise 创建新的 coroutine_handle 对象。</li><li>operator coroutine_handle&lt;&gt;：将 promise 版本的 coroutine_handle 转换为 void 类型的 coroutine_handle。</li><li>promise：获取 coroutine_handle 内部的 promise 对象。</li></ul><p>两个版本最后一行用“exposition only”标识出来的部分，就是 coroutine_handle 的内部存储内容，这部分只是为了说明标准做的示例，实际不同编译器可以根据自己的需求定义这里的实现。</p><h2 id="协程调度"><a href="#协程调度" class="headerlink" title="协程调度"></a>协程调度</h2><p>除了定义外，还需要学习如何对协程进行调度，包括协程休眠、控制权转移和待计算值的传递。对协程进行调度的关键在于 co_await 和 co_yield 操作符（关键字）。</p><h3 id="co-await"><a href="#co-await" class="headerlink" title="co_await"></a>co_await</h3><p>co_await 是协程中必须要了解的与编译器的约定。只有了解它，我们才能知道如何通过 co_await 灵活处理线程的休眠与唤醒。而搞清楚 co_await 操作符的具体行为表现，是我们理解 Awaitable 的重点。co_await 操作符用于休眠协程，并将控制权返还给协程调用者，用法如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp">co_await 表达式<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>与此同时，co_await 的表达式需要满足下列两个条件之一。</p><ul><li>表达式类型必须定义了 co_await 操作符重载。</li><li>可以通过当前协程的 Promise::await_transform 转换为定义了 co_await 操作符的类型。</li></ul><p>co_await 只能出现在函数体的执行表达式中，不能出现在异常处理、声明语句、简单声明表达式、默认参数和带 static 和 thread_local 的局部变量定义中。另外，co_await 的执行过程较为复杂，其中涉及到两个类型。</p><ul><li>Awaitable：用于获取 Awaiter 对象。</li><li>Awaiter：用于控制实际的休眠操作细节。</li></ul><p>我们需要将其分为编译时和运行时两个阶段来理解。先看编译时:</p><p><img src="/posts/55948/image-20240415164924809.png" alt></p><p><strong>编译时，</strong>编译器通过以下方式，将表达式转换成 Awaitable 对象。</p><ul><li>如果表达式是通过初始休眠点、结束休眠点或 yield 产生的，那么表达式本身就是 Awaitable 对象。</li><li>否则，如果当前协程的 promise 中包含 await_transform 函数，那么就会调用 promise.await_transform 将表达式转换为 Awaitable 对象。</li><li>否则，表达式本身就是 Awaitable 对象。</li></ul><p>接着，编译器就会通过以下操作获取 Awaiter 对象。</p><ul><li>如果 Awaitable 类型包含 co_await 操作符重载，那么就会将 co_await 重载的执行结果作为 Awaiter。</li><li>如果没有找到 co_await 操作符重载，那么就会将 Awaitable 对象自身作为 Awaiter 对象。</li></ul><p>再了解一下 co_await 在运行时的执行过程:</p><p><img src="/posts/55948/image-20240415165240467.png" alt></p><p>在运行时，代码会调用 Awaiter 对象的 await_ready 函数，如果该函数返回值为 false，那么就会执行以下行为：首先，将协程休眠；然后，使用当前协程的句柄，调用 Awaiter 对象的 await_suspend(handle) 函数。</p><p>我们可以在 await_suspend 中通过句柄获取到当前协程的各种信息，在自己编写的调度器中选择何时唤醒或者销毁这个协程。</p><p><img src="/posts/55948/image-20240415165319160.png" alt></p><p>在唤醒协程时，会调用 Awaiter 的 await_resume 函数，并使用该函数的返回值作为 co_await 表达式的值。其中，await_resume 函数的执行，会根据 await_ready 和 await_suspend 的执行结果有所不同。</p><p><img src="/posts/55948/image-20240415165331019.png" alt></p><p>这里可能会有一些关于多线程上执行协程的疑问。<strong>如果协程的执行涉及在不同线程上执行，会有线程安全问题吗？</strong>答案其实是不会。协程在进入 await_suspend 之前会休眠，因此 await_suspend 函数可以将协程句柄传递给任意的线程，而不需要考虑额外的线程同步问题。</p><p>举例来说，通过协程处理异步任务，await_suspend 函数是某个 Awaiter 类的成员函数，其 this 指针指向 Awaiter 对象。</p><p><img src="/posts/55948/image-20240415165503995.png" alt></p><p>我们将句柄存储在一个回调函数中（如图中的 lambda 表达式）。然后，在预先设定的线程池中完成异步任务。最后，调用回调函数利用协程句柄调度唤醒协程。</p><p>在这种情况下，代码块 2 依然会在本线程继续执行，回调函数中的代码则会在其他线程执行。由于其他线程的调度时序是未知的，因此本线程在执行代码块 2 时，协程可能已经被其他线程唤醒。这种多线程同时访问同一内存块上数据的情况，我们通常称为数据竞争问题。</p><p>为了避免出现这种数据竞争问题，将协程句柄传递给其他线程后，await_suspend 后续代码（示例中代码块 2）必须假定 *this（也就是调用 await_suspend 的 Awaiter 对象）已经被销毁，并且再也不对其进行访问。</p><p>这是一种典型的使用异步 I/O 处理的场景。</p><h3 id="生成器和-co-yield"><a href="#生成器和-co-yield" class="headerlink" title="生成器和 co_yield"></a>生成器和 co_yield</h3><p>除了 co_await，在协程的上下文中还有一个常见操作符（关键字）——co_yield，它本质上是 co_await 的语法糖，一般用在生成器这种协程的常见场景中。那么，<strong>什么是生成器呢？</strong></p><p>生成器是基于协程的异步编程中常见的一种编程模式。最常见的应用场景就是，通过生成或其他数据源来获取某种序列。</p><p>生成器的核心思路是让协程的调用者和被调用的协程进行协同调度，其中被调用的协程就是生成器。</p><p>这个协同调度过程是这样的：首先，调用者唤醒生成器，生成器返回一个值，接着就会主动进入休眠状态；然后，调用者使用这个值来执行相应代码逻辑，然后重新唤醒生成器……这个过程如此往复，直到调用者从生成器获取了所需的值为止。</p><p><img src="/posts/55948/image-20240415165933860.png" alt></p><p>从图中可以看出，在生成器这种模式下，主要就是两个操作。</p><ul><li>调用者作为调度方恢复协程执行。</li><li>协程将获取或生成的值返回给调用者并继续休眠，等待调用者恢复执行。</li></ul><p>而其中的关键就是 co_yield 关键字，用法是这样。</p><pre class="line-numbers language-cpp"><code class="language-cpp">co_yield 表达式<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>协程可以通过该关键字将表达式的结果传回给调用方并自动休眠。代码等价于：</p><pre class="line-numbers language-cpp"><code class="language-cpp">co_await promise<span class="token punctuation">.</span><span class="token function">yield_value</span><span class="token punctuation">(</span>表达式<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看出，调用 co_yield 的本质就是调用了 promise 的 yield_value 函数，并通过 co_await 将自身休眠。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;coroutine></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdint></span></span><span class="token keyword">struct</span> CountGenerator <span class="token punctuation">{</span>    <span class="token keyword">struct</span> promise_type <span class="token punctuation">{</span>        int32_t _value<span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token operator">~</span><span class="token function">promise_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"promise_type 对象销毁"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        CountGenerator <span class="token function">get_return_object</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">{</span>              <span class="token punctuation">.</span>_handle <span class="token operator">=</span> std<span class="token operator">::</span>coroutine_handle<span class="token operator">&lt;</span>promise_type<span class="token operator">></span><span class="token operator">::</span><span class="token function">from_promise</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        std<span class="token operator">::</span>suspend_never <span class="token function">initial_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>        std<span class="token operator">::</span>suspend_always <span class="token function">final_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">void</span> <span class="token function">unhandled_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        std<span class="token operator">::</span>suspend_always <span class="token function">yield_value</span><span class="token punctuation">(</span>int32_t value<span class="token punctuation">)</span> <span class="token punctuation">{</span>            _value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">void</span> <span class="token function">return_void</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>coroutine_handle<span class="token operator">&lt;</span>promise_type<span class="token operator">></span> _handle<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>CountGenerator <span class="token function">doCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>int32_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        co_yield i<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> h <span class="token operator">=</span> <span class="token function">doCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>_handle<span class="token punctuation">;</span>    <span class="token keyword">auto</span><span class="token operator">&amp;</span> promise <span class="token operator">=</span> h<span class="token punctuation">.</span><span class="token function">promise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>h<span class="token punctuation">.</span><span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"计数: "</span> <span class="token operator">&lt;&lt;</span> promise<span class="token punctuation">.</span>_value <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token function">h</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    h<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里定义了一个协程类 CountGenerator，比较特殊的是，这个类定义了一个 yield_value 成员函数，用于把 co_yield 的表达式值存储到 promise 对象内部，调用者通过这一方式来获取值。</p><p>由于调用方不知道协程什么时候结束执行，所以通过 coroutine_handle 中的 done 函数获取运行时状态。如果协程尚未结束执行，就获取相应的值并继续，否则就销毁协程并退出程序。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;coroutine></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span><span class="token keyword">namespace</span> Coroutine <span class="token punctuation">{</span>  <span class="token keyword">struct</span> task <span class="token punctuation">{</span>    <span class="token keyword">struct</span> promise_type <span class="token punctuation">{</span>      <span class="token function">promise_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"1.create promie object\n"</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      task <span class="token function">get_return_object</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"2.create coroutine return object, and the coroutine is created now\n"</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>std<span class="token operator">::</span>coroutine_handle<span class="token operator">&lt;</span>task<span class="token operator">::</span>promise_type<span class="token operator">></span><span class="token operator">::</span><span class="token function">from_promise</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      std<span class="token operator">::</span>suspend_never <span class="token function">initial_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"3.do you want to susupend the current coroutine?\n"</span><span class="token punctuation">;</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"4.don't suspend because return std::suspend_never, so continue to execute coroutine body\n"</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      std<span class="token operator">::</span>suspend_never <span class="token function">final_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"13.coroutine body finished, do you want to susupend the current coroutine?\n"</span><span class="token punctuation">;</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"14.don't suspend because return std::suspend_never, and the continue will be automatically destroyed, bye\n"</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">void</span> <span class="token function">return_void</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"12.coroutine don't return value, so return_void is called\n"</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">void</span> <span class="token function">unhandled_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>coroutine_handle<span class="token operator">&lt;</span>task<span class="token operator">::</span>promise_type<span class="token operator">></span> handle_<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">struct</span> awaiter <span class="token punctuation">{</span>    <span class="token keyword">bool</span> <span class="token function">await_ready</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"6.do you want to suspend current coroutine?\n"</span><span class="token punctuation">;</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"7.yes, suspend becase awaiter.await_ready() return false\n"</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">await_suspend</span><span class="token punctuation">(</span>      std<span class="token operator">::</span>coroutine_handle<span class="token operator">&lt;</span>task<span class="token operator">::</span>promise_type<span class="token operator">></span> handle<span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"8.execute awaiter.await_suspend()\n"</span><span class="token punctuation">;</span>      std<span class="token operator">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token punctuation">[</span>handle<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">mutable</span> <span class="token punctuation">{</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"9.a new thread lauched, and will return back to caller\n"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">await_resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  task <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"5.begin to execute coroutine body, the thread id="</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//#1</span>    co_await awaiter<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"11.coroutine resumed, continue execcute coroutine body now, the thread id="</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//#3</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// namespace Coroutine</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  Coroutine<span class="token operator">::</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"10.come back to caller becuase of co_await awaiter\n"</span><span class="token punctuation">;</span>  std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre><code>1.create promie object2.create coroutine return object, and the coroutine is created now3.do you want to susupend the current coroutine?4.don&#39;t suspend because return std::suspend_never, so continue to execute coroutine body5.begin to execute coroutine body, the thread id=0x10e1c1dc06.do you want to suspend current coroutine?7.yes, suspend becase awaiter.await_ready() return false8.execute awaiter.await_suspend()9.a new thread lauched, and will return back to caller10.come back to caller becuase of co_await awaiter11.coroutine resumed, continue execcute coroutine body now, the thread id=0x700001dc700012.coroutine don&#39;t return value, so return_void is called13.coroutine body finished, do you want to susupend the current coroutine?14.don&#39;t suspend because return std::suspend_never, and the continue will be automatically destroyed, bye</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>协程是彻底迈向现代编程语言的关键标志之一，一个协程类（Generator 类）包含 promise_type、coroutine_handle、coroutine_state。</p><p>但是 C++20 的协程缺乏具体实现，<strong>接口约定都需要开发者来实现，换句话说目前只提供了跟编译器沟通的协议，</strong>相信以后的标准肯定会支持得更加完美。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// ============= Promise的Concept定义 ===================</span><span class="token comment" spellcheck="true">// PromiseType是Promise的类型，ValueType是协程中待计算的值的类型</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> PromiseType<span class="token punctuation">,</span> <span class="token keyword">typename</span> ValueType<span class="token operator">></span>concept Promise <span class="token operator">=</span> <span class="token function">requires</span><span class="token punctuation">(</span>PromiseType promise<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token punctuation">{</span> promise<span class="token punctuation">.</span><span class="token function">get_return_object</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token operator">-</span><span class="token operator">></span> Coroutine<span class="token operator">&lt;</span>PromiseType<span class="token operator">></span><span class="token punctuation">;</span>  <span class="token punctuation">{</span> promise<span class="token punctuation">.</span><span class="token function">initial_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token operator">-</span><span class="token operator">></span> Awaiter<span class="token punctuation">;</span>  <span class="token punctuation">{</span> promise<span class="token punctuation">.</span><span class="token function">final_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token operator">-</span><span class="token operator">></span> Awaiter<span class="token punctuation">;</span>  <span class="token function">requires</span> <span class="token punctuation">(</span><span class="token function">requires</span><span class="token punctuation">(</span>ValueType value<span class="token punctuation">)</span> <span class="token punctuation">{</span> promise<span class="token punctuation">.</span><span class="token function">return_value</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token operator">||</span> <span class="token punctuation">{</span> promise<span class="token punctuation">.</span><span class="token function">return_void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span> promise<span class="token punctuation">.</span><span class="token function">unhandled_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ============= Awaiter的Concept定义 ===================</span><span class="token comment" spellcheck="true">// AwaitSuspendResult约束了await_suspend的返回值类型</span><span class="token comment" spellcheck="true">// AwaiterType是Awaiter的类型，Promise是协程的Promise类型，下同</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> ResultType<span class="token punctuation">,</span> <span class="token keyword">typename</span> Promise<span class="token operator">></span>concept AwaitSuspendResult <span class="token operator">=</span> std<span class="token operator">::</span>same_as<span class="token operator">&lt;</span>ResultType<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">></span> <span class="token operator">||</span>  std<span class="token operator">::</span>same_as<span class="token operator">&lt;</span>ResultType<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span> <span class="token operator">||</span>  std<span class="token operator">::</span>same_as<span class="token operator">&lt;</span>ResultType<span class="token punctuation">,</span> std<span class="token operator">::</span>coroutine_handle<span class="token operator">&lt;</span>Promise<span class="token operator">>></span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Awaiter约束定义，Awaiter类型必须满足requires中的所有接口约定</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> AwaiterType<span class="token punctuation">,</span> <span class="token keyword">typename</span> Promise<span class="token operator">></span>concept Awaiter <span class="token operator">=</span> <span class="token function">requires</span><span class="token punctuation">(</span>AwaiterType awaiter<span class="token punctuation">,</span> std<span class="token operator">::</span>coroutine_handle<span class="token operator">&lt;</span>Promise<span class="token operator">></span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>    awaiter<span class="token punctuation">.</span><span class="token function">await_resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">{</span> awaiter<span class="token punctuation">.</span><span class="token function">await_ready</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token operator">-</span><span class="token operator">></span> std<span class="token operator">::</span>same_as<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token punctuation">;</span>    <span class="token punctuation">{</span> awaiter<span class="token punctuation">.</span><span class="token function">await_suspend</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token operator">-</span><span class="token operator">></span> AwaitSuspendResult<span class="token operator">&lt;</span>Promise<span class="token operator">></span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ============= Awaitable的Concept定义 ===================</span><span class="token comment" spellcheck="true">// ValidCoAwait约束用于判断对于AwaitableType是否存在正确的co_await操作符重载</span><span class="token comment" spellcheck="true">// co_await可以重载为成员函数或者非成员函数，约束中都需要判断</span><span class="token comment" spellcheck="true">// AwaitableType是Awaitable的类型，Promise是协程的Promise类型，下同</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> AwaitableType<span class="token punctuation">,</span> <span class="token keyword">typename</span> Promise<span class="token operator">></span>concept ValidCoAwait <span class="token operator">=</span> <span class="token function">requires</span><span class="token punctuation">(</span>AwaitableType awaitable<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">{</span> awaitable<span class="token punctuation">.</span><span class="token keyword">operator</span> <span class="token function">co_await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token operator">-</span><span class="token operator">></span> Awaiter<span class="token operator">&lt;</span>Promise<span class="token operator">></span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token operator">||</span> <span class="token function">requires</span><span class="token punctuation">(</span>AwaitableType awaitable<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">{</span> <span class="token keyword">operator</span> <span class="token function">co_await</span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>AwaitableType<span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>awaitable<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token operator">-</span><span class="token operator">></span> Awaiter<span class="token operator">&lt;</span>Promise<span class="token operator">></span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Awaitable约束定义</span><span class="token comment" spellcheck="true">// Awaitable必须存在正确的co_await操作符重载，或者自身是一个Awaiter</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> AwaitableType<span class="token punctuation">,</span> <span class="token keyword">typename</span> Promise<span class="token operator">></span>concept Awaitable <span class="token operator">=</span> ValidCoAwait<span class="token operator">&lt;</span>AwaitableType<span class="token punctuation">,</span> Promise<span class="token operator">></span> <span class="token operator">||</span>  Awaiter<span class="token operator">&lt;</span>AwaitableType<span class="token punctuation">,</span> Promise<span class="token operator">></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Coroutines重要的不是它的性能，而是它带来的编程思维的改变，它能让你用同步的眼光去编写代码，也就是在对网络编程来说能消灭掉那些烦人的
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="读书笔记" scheme="https://JoyTsing.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Redis会遇到的15个坑</title>
    <link href="https://joytsing.github.io/posts/42709/"/>
    <id>https://joytsing.github.io/posts/42709/</id>
    <published>2024-04-11T15:21:45.000Z</published>
    <updated>2024-04-10T16:41:15.669Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先，这篇文章是转载的，哥们暂时还没这个工程经验（捂脸）。</p><ul><li>明明一个 key 设置了过期时间，怎么变成不过期了？</li><li>使用 O(1) 复杂度的 SETBIT 命令，Redis 竟然被 OOM 了？</li><li>执行 RANDOMKEY 随机拿出一个 key，竟然也会阻塞 Redis？</li><li>同样的命令，为什么主库查不到数据，从库却可以查到？</li><li>从库内存为什么比主库用得还多？</li><li>写入到 Redis 的数据，为什么莫名其妙丢了？</li><li>…</li></ul><p>这些问题划分成了三大部分：</p><ol><li>常见命令有哪些坑？</li><li>数据持久化有哪些坑？</li><li>主从库同步有哪些坑？</li></ol><h2 id="常见命令有哪些坑？"><a href="#常见命令有哪些坑？" class="headerlink" title="常见命令有哪些坑？"></a>常见命令有哪些坑？</h2><p>首先，我们来看一下，平时在使用 Redis 时，有哪些常见的命令会遇到「意料之外」的结果。</p><p><strong>1) 过期时间意外丢失？</strong></p><p>你在使用 Redis 时，肯定经常使用 SET 命令，它非常简单。</p><p>SET 除了可以设置 key-value 之外，还可以设置 key 的过期时间，就像下面这样：</p><pre><code>127.0.0.1:6379&gt; SET testkey val1 EX 60OK127.0.0.1:6379&gt; TTL testkey(integer) 59</code></pre><p>此时如果你想修改 key 的值，但只是单纯地使用 SET 命令，而没有加上「过期时间」的参数，那这个 key 的过期时间将会被「擦除」。</p><pre><code>127.0.0.1:6379&gt; SET testkey val2OK127.0.0.1:6379&gt; TTL testkey  // key永远不过期了！(integer) -1</code></pre><p>看到了么？testkey 变成永远不过期了！</p><p><img src="/posts/42709/640.webp" alt></p><p>导致这个问题的原因在于：<strong>SET 命令如果不设置过期时间，那么 Redis 会自动「擦除」这个 key 的过期时间。</strong></p><p>如果你发现 Redis 的内存持续增长，而且很多 key 原来设置了过期时间，后来发现过期时间丢失了，很有可能是因为这个原因导致的。</p><p>这时你的 Redis 中就会存在大量不过期的 key，消耗过多的内存资源。</p><p>所以，你在使用 SET 命令时，如果刚开始就设置了过期时间，那么之后修改这个 key，也务必要加上过期时间的参数，避免过期时间丢失问题。</p><p><strong>2) DEL 竟然也会阻塞 Redis？</strong></p><p>删除一个 key，你肯定会用 DEL 命令，不知道你没有思考过它的时间复杂度是多少？O(1)？其实不一定。</p><p>如果有阅读 Redis 的官方文档，就会发现：<strong>删除一个 key 的耗时，与这个 key 的类型有关。</strong></p><p>Redis 官方文档在介绍 DEL 命令时，是这样描述的：</p><ul><li>key 是 String 类型，DEL 时间复杂度是 O(1)</li><li>key 是 List/Hash/Set/ZSet 类型，DEL 时间复杂度是 O(M)，M 为元素数量</li></ul><p><strong>也就是说，如果你要删除的是一个非 String 类型的 key，这个 key 的元素越多，那么在执行 DEL 时耗时就越久！</strong></p><p>为什么会这样？原因在于，删除这种 key 时，Redis 需要依次释放每个元素的内存，元素越多，这个过程就会越耗时。</p><p>而这么长的操作耗时，势必会阻塞整个 Redis 实例，影响 Redis 的性能。</p><p><img src="/posts/42709/640-1712762722266-3.webp" alt></p><p>所以，当你在删除 List/Hash/Set/ZSet 类型的 key 时，一定要格外注意，不能无脑执行 DEL，而是应该用以下方式删除：</p><ol><li>查询元素数量：执行 LLEN/HLEN/SCARD/ZCARD 命令</li><li>判断元素数量：如果元素数量较少，可直接执行 DEL 删除，否则分批删除</li><li>分批删除：执行 LRANGE/HSCAN/SSCAN/ZSCAN + LPOP/RPOP/HDEL/SREM/ZREM 删除</li></ol><p>了解了 DEL 对于 List/Hash/Set/ZSet 类型数据的影响，我们再来分析下，删除一个 String 类型的 key 会不会有这种问题？啊？前面不是提到，Redis 官方文档的描述，删除 String 类型的 key，时间复杂度是 O(1) 么？这不会导致 Redis 阻塞吧？</p><p>其实这也不一定！如果这个 key 占用的内存非常大呢？</p><p>例如，这个 key 存储了 500MB 的数据（很明显，它是一个 bigkey），那在执行 DEL 时，耗时依旧会变长！这是因为，Redis 释放这么大的内存给操作系统，也是需要时间的，所以操作耗时也会变长。</p><p>所以，对于 String 类型来说，你最好也不要存储过大的数据，否则在删除它时，也会有性能问题。此时，你可能会想：<strong>Redis 4.0 不是推出了 lazy-free 机制么？打开这个机制，释放内存的操作会放到后台线程中执行，那是不是就不会阻塞主线程了？</strong></p><p>这个问题非常好。真的会是这样吗？<strong>即使 Redis 打开了 lazy-free，在删除一个 String 类型的 bigkey 时，它仍旧是在主线程中处理，而不是放到后台线程中执行。所以，依旧有阻塞 Redis 的风险！</strong></p><p><strong>3) RANDOMKEY 竟然也会阻塞 Redis？</strong></p><p>如果想随机查看 Redis 中的一个 key，通常会使用 RANDOMKEY 这个命令。这个命令会从 Redis 中「随机」取出一个 key。</p><p>既然是随机，那这个执行速度肯定非常快吧？其实不然。</p><p>要解释清楚这个问题，就要结合 Redis 的过期策略来讲。如果你对 Redis 的过期策略有所了解，应该知道 Redis 清理过期 key，是采用定时清理 + 懒惰清理 2 种方式结合来做的。</p><p>而 RANDOMKEY 在随机拿出一个 key 后，首先会先检查这个 key 是否已过期。如果该 key 已经过期，那么 Redis 会删除它，这个过程就是<strong>懒惰清理</strong>。但清理完了还不能结束，Redis 还要找出一个「不过期」的 key，返回给客户端。此时，Redis 则会继续随机拿出一个 key，然后再判断是它否过期，直到找出一个未过期的 key 返回给客户端。</p><p>整个流程就是这样的：</p><ol><li>master 随机取出一个 key，判断是否已过期</li><li>如果 key 已过期，删除它，继续随机取 key</li><li>以此循环往复，直到找到一个不过期的 key，返回</li></ol><p>但这里就有一个问题了：<strong>如果此时 Redis 中，有大量 key 已经过期，但还未来得及被清理掉，那这个循环就会持续很久才能结束，而且，这个耗时都花费在了清理过期 key + 寻找不过期 key 上。</strong></p><p>导致的结果就是，RANDOMKEY 执行耗时变长，影响 Redis 性能。</p><p><img src="/posts/42709/640-1712766321625-6.webp" alt></p><p>以上流程，其实是在 master 上执行的。如果在 slave 上执行 RANDOMEKY，那么问题会更严重！</p><p>为什么？</p><p>主要原因就在于，slave 自己是不会清理过期 key。那 slave 什么时候删除过期 key 呢？其实，当一个 key 要过期时，master 会先清理删除它，之后 master 向 slave 发送一个 DEL 命令，告知 slave 也删除这个 key，以此达到主从库的数据一致性。</p><p>还是同样的场景：Redis 中存在大量已过期，但还未被清理的 key，那在 slave 上执行 RANDOMKEY 时，就会发生以下问题：</p><ol><li>slave 随机取出一个 key，判断是否已过期</li><li>key 已过期，但 slave 不会删除它，而是继续随机寻找不过期的 key</li><li>由于大量 key 都已过期，那 slave 就会寻找不到符合条件的 key，此时就会陷入「<strong>死循环</strong>」！</li></ol><p><strong>也就是说，在 slave 上执行 RANDOMKEY，有可能会造成整个 Redis 实例卡死！</strong></p><p><img src="/posts/42709/640-1712766365074-9.webp" alt></p><p>是不是没想到？在 slave 上随机拿一个 key，竟然有可能造成这么严重的后果？这其实是 Redis 的一个 Bug，这个 Bug 一直持续到 5.0 才被修复。</p><p>修复的解决方案是，在 slave 上执行 RANDOMKEY 时，会先判断整个实例所有 key 是否都设置了过期时间，如果是，为了避免长时间找不到符合条件的 key，<strong>slave 最多只会在哈希表中寻找 100 次</strong>，无论是否能找到，都会退出循环。</p><p>这个方案就是增加上了一个最大重试次数，这样一来，就避免了陷入死循环。虽然这个方案可以避免了 slave 陷入死循环、卡死整个实例的问题，但是，在 master 上执行这个命令时，依旧有概率导致耗时变长。</p><p>所以，你在使用 RANDOMKEY 时，如果发现 Redis 发生了「抖动」，很有可能是因为这个原因导致的！</p><p><strong>4) O(1) 复杂度的 SETBIT，竟然会导致 Redis OOM？</strong></p><p>在使用 Redis 的 String 类型时，除了直接写入一个字符串之外，还可以把它当做 bitmap 来用。具体来讲就是，我们可以把一个 String 类型的 key，拆分成一个个 bit 来操作，就像下面这样：</p><pre><code>127.0.0.1:6379&gt; SETBIT testkey 10 1(integer) 1127.0.0.1:6379&gt; GETBIT testkey 10(integer) 1</code></pre><p><img src="/posts/42709/640-1712766388874-12.webp" alt></p><p>其中，操作的每一个 bit 位叫做 offset。但是，这里有一个坑，你需要注意起来。如果这个 key 不存在，或者 key 的内存使用很小，此时你要操作的 offset 非常大，那么 Redis 就需要分配「更大的内存空间」，这个操作耗时就会变长，影响性能。</p><p><img src="/posts/42709/640-1712766400480-15.webp" alt></p><p>所以，当你在使用 SETBIT 时，也一定要注意 offset 的大小，操作过大的 offset 也会引发 Redis 卡顿。这种类型的 key，也是典型的 bigkey，除了分配内存影响性能之外，在删除它时，耗时同样也会变长。</p><p><strong>5) 执行 MONITOR 也会导致 Redis OOM？</strong></p><p>这个坑你肯定听说过很多次了。当你在执行 MONITOR 命令时，Redis 会把每一条命令写到客户端的「输出缓冲区」中，然后客户端从这个缓冲区读取服务端返回的结果。</p><p><img src="/posts/42709/640-1712766412176-18.webp" alt></p><p>但是，如果你的 Redis QPS 很高，这将会导致这个输出缓冲区内存持续增长，占用 Redis 大量的内存资源，如果恰好你的机器的内存资源不足，那 Redis 实例就会面临被 OOM 的风险。所以，你需要谨慎使用 MONITOR，尤其在 QPS 很高的情况下。</p><p>以上这些问题场景，都是我们在使用常见命令时发生的，而且，很可能都是「无意」就会触发的。</p><p>下面我们来看 Redis「数据持久化」都存在哪些坑？</p><h2 id="数据持久化有哪些坑？"><a href="#数据持久化有哪些坑？" class="headerlink" title="数据持久化有哪些坑？"></a>数据持久化有哪些坑？</h2><p>Redis 的数据持久化，分为 RDB 和 AOF 两种方式。其中，RDB 是数据快照，而 AOF 会记录每一个写命令到日志文件中。在数据持久化方面发生问题，主要也集中在这两大块，我们依次来看。</p><p><strong>1) master 宕机，slave 数据也丢失了？</strong></p><p>如果你的 Redis 采用如下模式部署，就会发生数据丢失的问题：</p><ul><li>master-slave + 哨兵部署实例</li><li>master 没有开启数据持久化功能</li><li>Redis 进程使用 supervisor 管理，并配置为「进程宕机，自动重启」</li></ul><p>如果此时 master 宕机，就会导致下面的问题：</p><ul><li>master 宕机，哨兵还未发起切换，此时 master 进程立即被 supervisor 自动拉起</li><li>但 master 没有开启任何数据持久化，启动后是一个「空」实例</li><li>此时 slave 为了与 master 保持一致，它会自动「清空」实例中的所有数据，slave 也变成了一个「空」实例</li></ul><p>看到了么？在这个场景下，master / slave 的数据就全部丢失了。这时，业务应用在访问 Redis 时，发现缓存中没有任何数据，就会把请求全部打到后端数据库上，这还会进一步引发「缓存雪崩」，对业务影响非常大。</p><p>所以，一定要避免这种情况发生：</p><ol><li>Redis 实例不使用进程管理工具自动拉起</li><li>master 宕机后，让哨兵发起切换，把 slave 提升为 master</li><li>切换完成后，再重启 master，让其退化成 slave</li></ol><p>你在配置数据持久化时，要避免这个问题的发生。</p><p><strong>2) AOF everysec 真的不会阻塞主线程吗？</strong></p><p>当 Redis 开启 AOF 时，需要配置 AOF 的刷盘策略。基于性能和数据安全的平衡，你肯定会采用<code>appendfsync everysec</code> 这种方案。这种方案的工作模式为，Redis 的后台线程每间隔 1 秒，就把 AOF page cache 的数据，刷到磁盘（fsync）上。这种方案的优势在于，把 AOF 刷盘的耗时操作，放到了后台线程中去执行，避免了对主线程的影响。但真的不会影响主线程吗？</p><p>答案是否定的。其实存在这样一种场景：<strong>Redis 后台线程在执行 AOF page cache 刷盘（fysnc）时，如果此时磁盘 IO 负载过高，那么调用 fsync 就会被阻塞住。</strong>此时，主线程仍然接收写请求进来，那么此时的主线程会先判断，上一次后台线程是否已刷盘成功。如何判断呢？</p><p>后台线程在刷盘成功后，都会记录刷盘的时间。主线程会根据这个时间来判断，距离上一次刷盘已经过去多久了。整个流程是这样的：</p><ol><li>主线程在写 AOF page cache（write系统调用）前，先检查后台 fsync 是否已完成？</li><li>fsync 已完成，主线程直接写 AOF page cache</li><li>fsync 未完成，则检查距离上次 fsync 过去多久？</li><li>如果距离上次 fysnc 成功在 2 秒内，那么主线程会直接返回，不写 AOF page cache</li><li>如果距离上次 fysnc 成功超过了 2 秒，那主线程会强制写 AOF page cache（write系统调用）</li><li>由于磁盘 IO 负载过高，此时，后台线程 fynsc 会发生阻塞，那主线程在写 AOF page cache 时，也会发生阻塞等待（操作同一个 fd，fsync 和 write 是互斥的，一方必须等另一方成功才可以继续执行，否则阻塞等待）</li></ol><p><img src="/posts/42709/640-1712766433045-21.webp" alt></p><p>通过分析我们可以发现，即使你配置的 AOF 刷盘策略是 appendfsync everysec，也依旧会有阻塞主线程的风险。其实，产生这个问题的重点在于，磁盘 IO 负载过高导致 fynsc 阻塞，进而导致主线程写 AOF page cache 也发生阻塞。</p><p>所以，你一定要保证磁盘有充足的 IO 资源，避免这个问题。</p><p><strong>3) AOF everysec 真的只会丢失 1 秒数据？</strong></p><p>接着上面的问题继续分析。如上所述，这里我们需要重点关注上面的步骤 4。</p><p>也就是：主线程在写 AOF page cache 时，会先判断上一次 fsync 成功的时间，如果距离上次 fysnc 成功在 2 秒内，那么主线程会直接返回，不再写 AOF page cache。这就意味着，<strong>后台线程在执行 fsync 刷盘时，主线程最多等待 2 秒不会写 AOF page cache。</strong></p><p>如果此时 Redis 发生了宕机，那么，AOF 文件中丢失是 2 秒的数据，而不是 1 秒！我们继续分析，Redis 主线程为什么要等待 2 秒不写 AOF page cache 呢？</p><p>其实，Redis AOF 配置为 appendfsync everysec 时，正常来讲，后台线程每隔 1 秒执行一次 fsync 刷盘，如果磁盘资源充足，是不会被阻塞住的。也就是说，Redis 主线程其实根本不用关心后台线程是否刷盘成功，只要无脑写 AOF page cache 即可。</p><p>但是，Redis 作者考虑到，如果此时的磁盘 IO 资源比较紧张，那么后台线程 fsync 就有概率发生阻塞风险。所以，Redis 作者在主线程写 AOF page cache 之前，先检查一下距离上一次 fsync 成功的时间，如果大于 1 秒没有成功，那么主线程此时就能知道，fsync 可能阻塞了。</p><p>所以，主线程会等待 2 秒不写 AOF page cache，其目的在于：</p><ol><li>降低主线程阻塞的风险（如果无脑写 AOF page cache，主线程则会立即阻塞住）</li><li>如果 fsync 阻塞，主线程就会给后台线程留出 1 秒的时间，等待 fsync 成功</li></ol><p>但代价就是，如果此时发生宕机，AOF 丢失的就是 2 秒的数据，而不是 1 秒。这个方案应该是 Redis 作者对性能和数据安全性的进一步权衡。无论如何，这里你只需要知道的是，即使 AOF 配置为每秒刷盘，在发生上述极端情况时，AOF 丢失的数据其实是 2 秒。</p><p><strong>4) RDB 和 AOF rewrite 时，Redis 发生 OOM？</strong></p><p>最后，我们来看一下，当 Redis 在执行 RDB 快照和 AOF rewrite 时，会发生的问题。</p><p>Redis 在做 RDB 快照和 AOF rewrite 时，会采用创建子进程的方式，把实例中的数据持久化到磁盘上。创建子进程，会调用操作系统的 fork 函数。fork 执行完成后，父进程和子进程会同时共享同一份内存数据。</p><p>但此时的主进程依旧是可以接收写请求的，而进来的写请求，会采用 Copy On Write（写时复制）的方式操作内存数据。也就是说，主进程一旦有数据需要修改，Redis 并不会直接修改现有内存中的数据，而是先将这块内存数据拷贝出来，再修改这块新内存的数据，这就是所谓的「写时复制」。</p><p>写时复制你也可以理解成，谁需要发生写操作，谁就先拷贝，再修改。你应该发现了，如果父进程要修改一个 key，就需要拷贝原有的内存数据，到新内存中，这个过程涉及到了「新内存」的申请。</p><p>如果你的业务特点是「写多读少」，而且 OPS 非常高，那在 RDB 和 AOF rewrite 期间，就会产生大量的内存拷贝工作。这会有什么问题呢？</p><p><strong>因为写请求很多，这会导致 Redis 父进程会申请非常多的内存。在这期间，修改 key 的范围越广，新内存的申请就越多。</strong>如果你的机器内存资源不足，这就会导致 Redis 面临被 OOM 的风险！</p><p><img src="/posts/42709/640-1712766433046-22.webp" alt></p><p>这就是你会从 DBA 同学那里听到的，要给 Redis 机器预留内存的原因。其目的就是避免在 RDB 和 AOF rewrite 期间，防止 Redis OOM。</p><p>下面我们再来看「主从复制」会存在哪些问题。</p><h2 id="主从复制有哪些坑？"><a href="#主从复制有哪些坑？" class="headerlink" title="主从复制有哪些坑？"></a>主从复制有哪些坑？</h2><p>Redis 为了保证高可用，提供了主从复制的方式，这样就可以保证 Redis 有多个「副本」，当主库宕机后，我们依旧有从库可以使用。在主从同步期间，依旧存在很多坑，我们依次来看。</p><p><strong>1) 主从复制会丢数据吗？</strong></p><p>首先，你需要知道，Redis 的主从复制是采用「异步」的方式进行的。这就意味着，如果 master 突然宕机，可能存在有部分数据还未同步到 slave 的情况发生。</p><p>这会导致什么问题呢？</p><p>如果你把 Redis 当做纯缓存来使用，那对业务来说没有什么影响。master 未同步到 slave 的数据，业务应用可以从后端数据库中重新查询到。但是，对于把 Redis 当做数据库，或是当做分布式锁来使用的业务，有可能因为异步复制的问题，导致数据丢失 / 锁丢失。</p><blockquote><p>关于 Redis 分布式锁可靠性的更多细节，这里先不展开，后面会单独写一篇文章详细剖析这个知识点。这里你只需要先知道，Redis 主从复制是有概率发生数据丢失的。</p></blockquote><p><strong>2) 同样命令查询一个 key，主从库却返回不同的结果？</strong></p><p>不知道你是否思考过这样一个问题：<strong>如果一个 key 已过期，但这个 key 还未被 master 清理，此时在 slave 上查询这个 key，会返回什么结果呢？</strong></p><ol><li>slave 正常返回 key 的值</li><li>slave 返回 NULL</li></ol><p>你认为是哪一种？可以思考一下。答案是：<strong>不一定</strong>。</p><p>其实，返回什么结果，这要取决于以下 3 个因素：</p><ol><li>Redis 的版本</li><li>具体执行的命令</li><li>机器时钟</li></ol><p>先来看 Redis 版本。</p><p>如果你使用的是 Redis 3.2 以下版本，只要这个 key 还未被 master 清理，那么，在 slave 上查询这个 key，它会永远返回 value 给你。</p><p><strong>也就是说，即使这个 key 已过期，在 slave 上依旧可以查询到这个 key。</strong></p><pre><code>// Redis 2.8 版本 在 slave 上执行127.0.0.1:6479&gt; TTL testkey(integer) -2    // 已过期127.0.0.1:6479&gt; GET testkey&quot;testval&quot;       // 还能查询到!</code></pre><p>但如果此时在 master 上查询这个 key，发现已经过期，就会把它清理掉，然后返回 NULL。</p><pre><code>// Redis 2.8 版本 在 master 上执行127.0.0.1:6379&gt; TTL testkey(integer) -2127.0.0.1:6379&gt; GET testkey(nil)</code></pre><p>发现了吗？在 master 和 slave 上查询同一个 key，结果竟然不一样？其实，slave 应该要与 master 保持一致，key 已过期，就应该给客户端返回 NULL，而不是还正常返回 key 的值。为什么会发生这种情况？</p><p>其实这是 Redis 的一个 Bug：<strong>3.2 以下版本的 Redis，在 slave 上查询一个 key 时，并不会判断这个 key 是否已过期，而是直接无脑返回给客户端结果。</strong>这个 Bug 在 3.2 版本进行了修复，但是，它修复得「不够彻底」。</p><p>什么叫修复得「不够彻底」？这就要结合前面提到的，第 2 个影响因素「具体执行的命令」来解释了。Redis 3.2 虽然修复了这个 Bug，但却遗漏了一个命令：<strong>EXISTS</strong>。</p><p>也就是说，一个 key 已过期，在 slave 直接查询它的数据，例如执行 GET/LRANGE/HGETALL/SMEMBERS/ZRANGE 这类命令时，slave 会返回 NULL。但如果执行的是 EXISTS，slave 依旧会返回：<strong>key 还存在</strong>。</p><pre><code>// Redis 3.2 版本 在 slave 上执行127.0.0.1:6479&gt; GET testkey(nil)           // key 已逻辑过期127.0.0.1:6479&gt; EXISTS testkey(integer) 1     // 还存在！</code></pre><p>原因在于，EXISTS 与查询数据的命令，使用的不是同一个方法。Redis 作者只在查询数据时增加了过期时间的校验，但 EXISTS 命令依旧没有这么做。</p><p>直到 Redis 4.0.11 这个版本，Redis 才真正把这个遗漏的 Bug 完全修复。如果你使用的是这个之上的版本，那在 slave 上执行数据查询或 EXISTS，对于已过期的 key，就都会返回「不存在」了。</p><p>这里我们先小结一下，slave 查询过期 key，经历了 3 个阶段：</p><ol><li>3.2 以下版本，key 过期未被清理，无论哪个命令，查询 slave，均正常返回 value</li><li>3.2 - 4.0.11 版本，查询数据返回 NULL，但 EXISTS 依旧返回 true</li><li>4.0.11 以上版本，所有命令均已修复，过期 key 在 slave 上查询，均返回「不存在」</li></ol><p>最后，我们来看影响查询结果的第 3 个因素：「机器时钟」。</p><p>假设我们已规避了上面提到的版本 Bug，例如，我们使用 Redis 5.0 版本，在 slave 查询一个 key，还会和 master 结果不同吗？答案是，还是有可能会的。</p><p>这就与 master / slave 的机器时钟有关了。无论是 master 还是 slave，在判断一个 key 是否过期时，都是基于「本机时钟」来判断的。</p><p>如果 slave 的机器时钟比 master 走得「快」，那就会导致，即使这个 key 还未过期，但以 slave 上视角来看，这个 key 其实已经过期了，那客户端在 slave 上查询时，就会返回 NULL。是不是很有意思？一个小小的过期 key，竟然藏匿这么多猫腻。</p><p>如果你也遇到了类似的情况，就可以通过上述步骤进行排查，确认是否踩到了这个坑。</p><p><strong>3) 主从切换会导致缓存雪崩？</strong></p><p>这个问题是上一个问题的延伸。</p><p>我们假设，slave 的机器时钟比 master 走得「快」，而且是「快很多」。此时，从 slave 角度来看，Redis 中的数据存在「大量过期」。如果此时操作「主从切换」，把 slave 提升为新的 master。</p><p>它成为 master 后，就会开始大量清理过期 key，此时就会导致以下结果：</p><ol><li>master 大量清理过期 key，主线程发生阻塞，无法及时处理客户端请求</li><li>Redis 中数据大量过期，引发缓存雪崩</li></ol><p>你看，当 master / slave 机器时钟严重不一致时，对业务的影响非常大！所以，如果你是 DBA 运维，一定要保证主从库的机器时钟一致性，避免发生这些问题。</p><p><strong>4) master / slave 大量数据不一致？</strong></p><p>还有一种场景，会导致 master / slave 的数据存在大量不一致。这就涉及到 Redis 的 maxmemory 配置了。Redis 的 maxmemory 可以控制整个实例的内存使用上限，超过这个上限，并且配置了淘汰策略，那么实例就开始淘汰数据。</p><p>但这里有个问题：<strong>假设 master / slave 配置的 maxmemory 不一样，那此时就会发生数据不一致。</strong></p><p>例如，master 配置的 maxmemory 为 5G，而 slave 的 maxmemory 为 3G，当 Redis 中的数据超过 3G 时，slave 就会「提前」开始淘汰数据，此时主从库数据发生不一致。</p><p><img src="/posts/42709/640-1712766433046-23.webp" alt></p><p>另外，尽管 master / slave 设置的 maxmemory 相同，如果你要调整它们的上限，也要格外注意，否则也会导致 slave 淘汰数据：</p><ul><li>调大 maxmemory 时，先调整 slave，再调整 master</li><li>调小 maxmemory 时，先调整 master，再调整 slave</li></ul><p>以此方式操作，就避免了 slave 提前超过 maxmemory 的问题。其实，你可以思考一下，发生这些问题的关键在哪？其根本原因在于，<strong>slave 超过 maxmemory 后，会「自行」淘汰数据</strong>。</p><p>如果不让 slave 自己淘汰数据，那这些问题是不是都可以规避了？没错。</p><p>针对这个问题，Redis 官方应该也收到了很多用户的反馈。在 Redis 5.0 版本增加了一个配置项：replica-ignore-maxmemory，默认 yes。这个参数表示，尽管 slave 内存超过了 maxmemory，也不会自行淘汰数据了！</p><p><strong>这样一来，slave 永远会向 master 看齐，只会老老实实地复制 master 发送过来的数据，不会自己再搞「小动作」。</strong></p><p>至此，master / slave 的数据就可以保证完全一致了！</p><blockquote><p>如果你使用的恰好是 5.0 版本，就不用担心这个问题了。</p></blockquote><p><strong>5) slave 竟然会有内存泄露问题？</strong></p><p>这是怎么发生的？我们具体来看一下。</p><p>当你在使用 Redis 时，符合以下场景，就会触发 slave 内存泄露：</p><ul><li>Redis 使用的是 4.0 以下版本</li><li>slave 配置项为 read-only=no（从库可写）</li><li>向 slave 写入了有过期时间的 key</li></ul><p>这时的 slave 就会发生内存泄露：<strong>slave 中的 key，即使到了过期时间，也不会自动清理。</strong>如果你不主动删除它，那这些 key 就会一直残留在 slave 内存中，消耗 slave 的内存。</p><p>最麻烦的是，你使用命令查询这些 key，却还查不到任何结果！这就 slave 「内存泄露」问题。</p><p><img src="/posts/42709/640-1712766433046-24.webp" alt></p><p>这其实也是 Redis 的一个 Bug，Redis 4.0 才修复了这个问题。解决方案是，<strong>在可写的 slave 上，写入带有过期时间 key 时，slave 会「记录」下来这些 key。</strong>然后 slave 会定时扫描这些 key，如果到达过期时间，则清理之。</p><p>如果你的业务需要在 slave 上临时存储数据，而且这些 key 也都设置了过期时间，那么就要注意这个问题了。你需要确认你的 Redis 版本，如果是 4.0 以下版本，一定要避免踩这个坑。</p><p>其实，最好的方案是，制定一个 Redis 使用规范，slave 必须强制设置为 read-only，不允许写，这样不仅可以保证 master / slave 的数据一致性，还避免了 slave 内存泄露问题。</p><p><strong>6) 为什么主从全量同步一直失败？</strong></p><p>在主从全量同步时，你可能会遇到同步失败的问题，具体场景如下：slave 向 master 发起全量同步请求，master 生成 RDB 后发给 slave，slave 加载 RDB。由于 RDB 数据太大，slave 加载耗时也会变得很长。此时你会发现，slave 加载 RDB 还未完成，master 和 slave 的连接却断开了，数据同步也失败了。</p><p>之后你又会发现，slave 又发起了全量同步，master 又生成 RDB 发送给 slave。同样地，slave 在加载 RDB 时，master / slave 同步又失败了，以此往复。</p><p>这是怎么回事？其实，这就是 Redis 的「复制风暴」问题。</p><p>什么是复制风暴？就像刚才描述的：<strong>主从全量同步失败，又重新开始同步，之后又同步失败，以此往复，恶性循环，持续浪费机器资源。</strong></p><p>为什么会导致这种问题呢？如果你的 Redis 有以下特点，就有可能发生这种问题：</p><ul><li>master 的实例数据过大，slave 在加载 RDB 时耗时太长</li><li>复制缓冲区（slave client-output-buffer-limit）配置过小</li><li>master 写请求量很大</li></ul><p>主从在全量同步数据时，master 接收到的写请求，会先写到主从「复制缓冲区」中，这个缓冲区的「上限」是配置决定的。当 slave 加载 RDB 太慢时，就会导致 slave 无法及时读取「复制缓冲区」的数据，这就引发了复制缓冲区「溢出」。</p><p>为了避免内存持续增长，此时的 master 会「强制」断开 slave 的连接，这时全量同步就会失败。之后，同步失败的 slave 又会「重新」发起全量同步，进而又陷入上面描述的问题中，以此往复，恶性循环，这就是所谓的「复制风暴」。</p><p>如何解决这个问题呢？</p><ol><li>Redis 实例不要太大，避免过大的 RDB</li><li>复制缓冲区配置的尽量大一些，给 slave 加载 RDB 留足时间，降低全量同步失败的概率</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;首先，这篇文章是转载的，哥们暂时还没这个工程经验（捂脸）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;明明一个 key 设置了过期时间，怎么变成不过期了？&lt;
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://JoyTsing.github.io/categories/Redis/"/>
    
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="数据库" scheme="https://JoyTsing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="https://JoyTsing.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Cpp包管理工具Conan2</title>
    <link href="https://joytsing.github.io/posts/36734/"/>
    <id>https://joytsing.github.io/posts/36734/</id>
    <published>2024-04-11T08:53:27.000Z</published>
    <updated>2024-04-11T10:25:32.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先，先把<a href="https://conan.io/center">官网</a>和<a href="https://docs.conan.io/2/introduction.html">官方文档</a>放在这里。</p><p><img src="/posts/36734/conan-systems.png" alt></p><p>这个工具能让cpp开发者免去每个项目依赖都去make install或者都要源码编译的痛苦，相信就这一点经常写cpp的同志们就知道有切中痛点了，能够像pip一样帮你快速构建。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>建议cpp跟python一样内置一个包管理工具，2024年了在这种切实痛点的地方modern一点。</p><p>conan的安装非常简单，只需要</p><pre class="line-numbers language-sh"><code class="language-sh">pip install conan<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><a href="https://docs.conan.io/2/tutorial/consuming_packages/build_simple_cmake_project.html">官方教程</a>中，把对应项目clone下来，按照对应的地方修改即可，注意，和之前vscode配置的不同，在使用conan初始化项目后编译链就确定了（或者你需要自己手写一套settings），默认的编译链则是输入：</p><pre class="line-numbers language-sh"><code class="language-sh">conan profile detect --force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于clang编译链则是如下：</p><pre class="line-numbers language-sh"><code class="language-sh">[settings]arch=x86_64build_type=Releasecompiler=clangcompiler.cppstd=23compiler.version=17os=Windows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>msvc编译链如下：</p><pre class="line-numbers language-sh"><code class="language-sh">[settings]arch=x86_64build_type=Releasecompiler=msvccompiler.cppstd=14compiler.runtime=dynamiccompiler.version=193os=Windows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>gcc编译链如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token punctuation">[</span>settings<span class="token punctuation">]</span>arch<span class="token operator">=</span>x86_64build_type<span class="token operator">=</span>Releasecompiler<span class="token operator">=</span>gcccompiler<span class="token punctuation">.</span>cppstd<span class="token operator">=</span><span class="token number">23</span>compiler<span class="token punctuation">.</span>libcxx<span class="token operator">=</span>libstdc<span class="token operator">++</span>compiler<span class="token punctuation">.</span>version<span class="token operator">=</span><span class="token number">13</span>os<span class="token operator">=</span>Windows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="安装包依赖"><a href="#安装包依赖" class="headerlink" title="安装包依赖"></a>安装包依赖</h3><p>对应的在conanfile.txt中写入需要的，对于官方的例子则是给好了：</p><pre><code>[requires]zlib/1.2.11[generators]CMakeDepsCMakeToolchain</code></pre><p>写好依赖后只需要</p><pre class="line-numbers language-sh"><code class="language-sh">conan install . --output-folder=build --build=missing<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就帮你配置好依赖性了，非常方便。</p><h3 id="CMake对接"><a href="#CMake对接" class="headerlink" title="CMake对接"></a>CMake对接</h3><p>使用后会帮你生成<code>CMakeUserPresets.json</code>，这时候需要重新点工具链:</p><p><img src="/posts/36734/769b2dae762e41d18208c6469ca11504.png" alt></p><p>选择conan为你生成的toolchain即可，别的都一样</p><p><img src="/posts/36734/6f8cae5feb374f54bfe65845fb065285.png" alt></p><h3 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h3><p>开 <code>CMakeLists.txt</code> 文件，找到之前安装包的时候产生的命令行输出，添加 <code>find_package(你的包 REQUIRED)</code> 一行。并在 <strong>add_executable</strong> 的后面添加 <code>target_link_libraries(${PROJECT_NAME} 你的包::需要的模块)</code>。</p><p>好了，可以正常爽用了，不用再费劲写third-party的cmakelist和编译了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;首先，先把&lt;a href=&quot;https://conan.io/center&quot;&gt;官网&lt;/a&gt;和&lt;a href=&quot;https://docs.co
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="Tool" scheme="https://JoyTsing.github.io/tags/Tool/"/>
    
  </entry>
  
  <entry>
    <title>Redis最佳实践</title>
    <link href="https://joytsing.github.io/posts/41948/"/>
    <id>https://joytsing.github.io/posts/41948/</id>
    <published>2024-04-10T16:56:49.000Z</published>
    <updated>2024-04-10T17:20:38.233Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>学习他人的经验，首先还是抛出问题：</p><ul><li>我的 Redis 内存为什么增长这么快？</li><li>为什么我的 Redis 操作延迟变大了？</li><li>如何降低 Redis 故障发生的频率？</li><li>日常运维 Redis 需要注意什么？</li><li>部署 Redis 时，如何做好资源规划？</li><li>Redis 监控重点要关注哪些指标？</li></ul><h2 id="如何使用-Redis-更节省内存？"><a href="#如何使用-Redis-更节省内存？" class="headerlink" title="如何使用 Redis 更节省内存？"></a>如何使用 Redis 更节省内存？</h2><p>首先来看一下 Redis 内存方面的优化。</p><p>众所周知，Redis 的性能之所以如此之高，原因就在于它的数据都存储在「内存」中，所以访问 Redis 中的数据速度极快。但从资源利用率层面来说，机器的内存资源相比于磁盘，还是比较昂贵的。</p><p>当你的业务应用在 Redis 中存储数据很少时，你可能并不太关心内存资源的使用情况。但随着业务的发展，你的业务存储在 Redis 中的数据就会越来越多。如果没有提前制定好内存优化策略，那么等业务开始增长时，Redis 占用的内存也会开始膨胀。</p><p>所以，提前制定合理的内存优化策略，对于资源利用率的提升是很有必要的。</p><p><strong>1) 控制 key 的长度</strong></p><p>最简单直接的内存优化，就是控制 key 的长度。在开发业务时，你需要提前预估整个 Redis 中写入 key 的数量，如果 key 数量达到了百万级别，那么，过长的 key 名也会占用过多的内存空间。</p><p>所以，你需要保证 key 在简单、清晰的前提下，尽可能把 key 定义得短一些。例如，原有的 key 为 user:book:123，则可以优化为 u:bk:123。这样一来，你的 Redis 就可以节省大量的内存，这个方案对内存的优化非常直接和高效。</p><p><strong>2) 避免存储 bigkey</strong></p><p>除了控制 key 的长度之外，你同样需要关注 value 的大小，如果大量存储 bigkey，也会导致 Redis 内存增长过快。除此之外，客户端在读写 bigkey 时，还有产生性能问题（下文会具体详述）。</p><p>所以，你要避免在 Redis 中存储 bigkey：</p><ul><li>String：大小控制在 10KB 以下</li><li>List/Hash/Set/ZSet：元素数量控制在 1 万以下</li></ul><p><strong>3) 选择合适的数据类型</strong></p><p>Redis 提供了丰富的数据类型，这些数据类型在实现上，也对内存使用做了优化。具体来说就是，一种数据类型对应多种数据结构来实现：</p><p><img src="/posts/41948/640.webp" alt></p><p>例如，String、Set 在存储 int 数据时，会采用整数编码存储。Hash、ZSet 在元素数量比较少时（可配置），会采用压缩列表（ziplist）存储，在存储比较多的数据时，才会转换为哈希表和跳表。</p><p>作者这么设计的原因，就是为了进一步节约内存资源。那么你在存储数据时，就可以利用这些特性来优化 Redis 的内存。这里我给你的建议如下：</p><ul><li>String、Set：尽可能存储 int 类型数据</li><li>Hash、ZSet：存储的元素数量控制在转换阈值之下，以压缩列表存储，节约内存</li></ul><p><strong>4) 把 Redis 当作缓存使用</strong></p><p>Redis 数据存储在内存中，这也意味着其资源是有限的。你在使用 Redis 时，要把它当做缓存来使用，而不是数据库。所以，应用写入到  Redis 中的数据，尽可能地都设置「过期时间」。</p><p>业务应用在 Redis 中查不到数据时，再从后端数据库中加载到 Redis 中。</p><p><img src="/posts/41948/640-1712768648600-1.webp" alt></p><p>采用这种方案，可以让 Redis 中只保留经常访问的「热数据」，内存利用率也会比较高。</p><p><strong>5) 实例设置 maxmemory + 淘汰策略</strong></p><p>虽然你的 Redis key 都设置了过期时间，但如果你的业务应用写入量很大，并且过期时间设置得比较久，那么短期间内 Redis 的内存依旧会快速增长。如果不控制 Redis 的内存上限，也会导致使用过多的内存资源。</p><p>对于这种场景，需要提前预估业务数据量，然后给这个实例设置 maxmemory 控制实例的内存上限，这样可以避免 Redis 的内存持续膨胀。配置了 maxmemory，此时你还要设置数据淘汰策略，而淘汰策略如何选择，你需要结合你的业务特点来决定：</p><ul><li>volatile-lru / allkeys-lru：优先保留最近访问过的数据</li><li>volatile-lfu / allkeys-lfu：优先保留访问次数最频繁的数据（4.0+版本支持）</li><li>volatile-ttl ：优先淘汰即将过期的数据</li><li>volatile-random / allkeys-random：随机淘汰数据</li></ul><p><strong>6) 数据压缩后写入 Redis</strong></p><p>以上方案基本涵盖了 Redis 内存优化的各个方面。如果还想进一步优化 Redis 内存，还可以在业务应用中先将数据压缩，再写入到 Redis 中（例如采用 snappy、gzip 等压缩算法）。</p><p>当然，压缩存储的数据，客户端在读取时还需要解压缩，在这期间会消耗更多 CPU 资源，需要根据实际情况进行权衡。</p><h2 id="如何持续发挥-Redis-的高性能？"><a href="#如何持续发挥-Redis-的高性能？" class="headerlink" title="如何持续发挥 Redis 的高性能？"></a>如何持续发挥 Redis 的高性能？</h2><p>当决定引入 Redis 时，想必看中它最关键的一点就是：<strong>性能</strong>。</p><p>我们知道，一个单机版 Redis 就可以达到 10W QPS，这么高的性能，也意味着如果在使用过程中发生延迟情况，就会与我们的预期不符。所以，在使用 Redis 时，如何持续发挥它的高性能，避免操作延迟的情况发生，也是我们的关注焦点。</p><p><strong>1) 避免存储 bigkey</strong></p><p>存储 bigkey 除了前面讲到的使用过多内存之外，对 Redis 性能也会有很大影响。</p><p>由于 Redis 处理请求是单线程的，当你的应用在写入一个 bigkey 时，更多时间将消耗在「内存分配」上，这时操作延迟就会增加。同样地，删除一个 bigkey 在「释放内存」时，也会发生耗时。而且，当你在读取这个 bigkey 时，也会在「网络数据传输」上花费更多时间，此时后面待执行的请求就会发生排队，Redis 性能下降。</p><p><img src="/posts/41948/640-1712768648600-2.webp" alt></p><p>所以，业务应用尽量不要存储 bigkey，避免操作延迟发生。</p><blockquote><p>如果确实有存储 bigkey 的需求，可以把 bigkey 拆分为多个小 key 存储。</p></blockquote><p><strong>2) 开启 lazy-free 机制</strong></p><p>如果无法避免存储 bigkey，那么开启 Redis 的 lazy-free 机制。（4.0+版本支持）当开启这个机制后，Redis 在删除一个 bigkey 时，释放内存的耗时操作，将会放到后台线程中去执行，这样可以在最大程度上，避免对主线程的影响。</p><p><img src="/posts/41948/640-1712768648600-3.webp" alt></p><p><strong>3) 不使用复杂度过高的命令</strong></p><p>Redis 是单线程模型处理请求，除了操作 bigkey 会导致后面请求发生排队之外，在执行复杂度过高的命令时，也会发生这种情况。因为执行复杂度过高的命令，会消耗更多的 CPU 资源，主线程中的其它请求只能等待，这时也会发生排队延迟。</p><p>所以，你需要避免执行例如 SORT、SINTER、SINTERSTORE、ZUNIONSTORE、ZINTERSTORE 等聚合类命令。对于这种聚合类操作，我建议你把它放到客户端来执行，不要让 Redis 承担太多的计算工作。</p><p><strong>4) 执行 O(N) 命令时，关注 N 的大小</strong></p><p>规避使用复杂度过高的命令，就可以高枕无忧了么？答案是否定的。</p><p>当在执行 O(N) 命令时，同样需要注意 N 的大小。如果一次性查询过多的数据，也会在网络传输过程中耗时过长，操作延迟变大。所以，对于容器类型（List/Hash/Set/ZSet），在元素数量未知的情况下，一定不要无脑执行 LRANGE key 0 -1 / HGETALL / SMEMBERS / ZRANGE key 0 -1。</p><p>在查询数据时，你要遵循以下原则：</p><ol><li>先查询数据元素的数量（LLEN/HLEN/SCARD/ZCARD）</li><li>元素数量较少，可一次性查询全量数据</li><li>元素数量非常多，分批查询数据（LRANGE/HASCAN/SSCAN/ZSCAN）</li></ol><p><strong>5) 关注 DEL 时间复杂度</strong></p><p>你没看错，在删除一个 key 时，如果姿势不对，也有可能影响到 Redis 性能。删除一个 key，我们通常使用的是 DEL 命令，回想一下，你觉得 DEL 的时间复杂度是多少？O(1) ？其实不一定。</p><p>当你删除的是一个 String 类型 key 时，时间复杂度确实是 O(1)。但当你要删除的 key 是 List/Hash/Set/ZSet 类型，它的复杂度其实为 O(N)，N 代表元素个数。<strong>也就是说，删除一个 key，其元素数量越多，执行 DEL 也就越慢！</strong></p><p>原因在于，删除大量元素时，需要依次回收每个元素的内存，元素越多，花费的时间也就越久！而且，这个过程默认是在主线程中执行的，这势必会阻塞主线程，产生性能问题。</p><p>那删除这种元素比较多的 key，如何处理呢？分批删除：</p><ul><li>List类型：执行多次 LPOP/RPOP，直到所有元素都删除完成</li><li>Hash/Set/ZSet类型：先执行 HSCAN/SSCAN/SCAN 查询元素，再执行 HDEL/SREM/ZREM 依次删除每个元素</li></ul><p>没想到吧？一个小小的删除操作，稍微不小心，也有可能引发性能问题，在操作时需要格外注意。</p><p><strong>6) 批量命令代替单个命令</strong></p><p>当需要一次性操作多个 key 时，应该使用批量命令来处理。批量操作相比于多次单个操作的优势在于，可以显著减少客户端、服务端的来回网络 IO 次数。</p><ul><li>String / Hash 使用 MGET/MSET 替代 GET/SET，HMGET/HMSET 替代 HGET/HSET</li><li>其它数据类型使用 Pipeline，打包一次性发送多个命令到服务端执行</li></ul><p><img src="/posts/41948/640-1712768648600-4.webp" alt></p><p><strong>7) 避免集中过期 key</strong></p><p>Redis 清理过期 key 是采用定时 + 懒惰的方式来做的，而且这个过程都是在主线程中执行。如果业务存在大量 key 集中过期的情况，那么 Redis 在清理过期 key 时，也会有阻塞主线程的风险。</p><p><img src="/posts/41948/640-1712768648600-5.webp" alt></p><p>想要避免这种情况发生，你可以在设置过期时间时，增加一个随机时间，把这些 key 的过期时间打散，从而降低集中过期对主线程的影响。</p><p><strong>8) 使用长连接操作 Redis，合理配置连接池</strong></p><p>业务应该使用长连接操作 Redis，避免短连接。当使用短连接操作 Redis 时，每次都需要经过 TCP 三次握手、四次挥手，这个过程也会增加操作耗时。同时，客户端应该使用连接池的方式访问 Redis，并设置合理的参数，长时间不操作 Redis 时，需及时释放连接资源。</p><p><strong>9) 只使用 db0</strong></p><p>尽管 Redis 提供了 16 个 db，但只建议你使用 db0。为什么呢？</p><ol><li>在一个连接上操作多个 db 数据时，每次都需要先执行 SELECT，这会给 Redis 带来额外的压力</li><li>使用多个 db 的目的是，按不同业务线存储数据，那为何不拆分多个实例存储呢？拆分多个实例部署，多个业务线不会互相影响，还能提高 Redis 的访问性能</li><li>Redis Cluster 只支持 db0，如果后期你想要迁移到 Redis Cluster，迁移成本高</li></ol><p><strong>10) 使用读写分离 + 分片集群</strong></p><p>如果业务读请求量很大，那么可以采用部署多个从库的方式，实现读写分离，让 Redis 的从库分担读压力，进而提升性能。</p><p><img src="/posts/41948/640-1712768648600-6.webp" alt></p><p>如果业务写请求量很大，单个 Redis 实例已无法支撑这么大的写流量，那么此时你需要使用分片集群，分担写压力。</p><p><img src="/posts/41948/640-1712768648600-7.webp" alt></p><p><strong>11) 不开启 AOF 或 AOF 配置为每秒刷盘</strong></p><p>如果对于丢失数据不敏感的业务，我建议你不开启 AOF，避免 AOF 写磁盘拖慢 Redis 的性能。如果确实需要开启 AOF，那么建议配置为 appendfsync everysec，把数据持久化的刷盘操作，放到后台线程中去执行，尽量降低 Redis 写磁盘对性能的影响。</p><p><strong>12) 使用物理机部署 Redis</strong></p><p>Redis 在做数据持久化时，采用创建子进程的方式进行。而创建子进程会调用操作系统的 fork 系统调用，这个系统调用的执行耗时，与系统环境有关。虚拟机环境执行 fork 的耗时，要比物理机慢得多，所以Redis 应该尽可能部署在物理机上。</p><p><strong>13) 关闭操作系统内存大页机制</strong></p><p>Linux 操作系统提供了内存大页机制，其特点在于，每次应用程序向操作系统申请内存时，申请单位由之前的 4KB 变为了 2MB。</p><p>这会导致什么问题呢？当 Redis 在做数据持久化时，会先 fork 一个子进程，此时主进程和子进程共享相同的内存地址空间。当主进程需要修改现有数据时，会采用写时复制（Copy On Write）的方式进行操作，在这个过程中，需要重新申请内存。如果申请内存单位变为了 2MB，那么势必会增加内存申请的耗时，如果此时主进程有大量写操作，需要修改原有的数据，那么在此期间，操作延迟就会变大。</p><p><img src="/posts/41948/640-1712768648600-8.webp" alt></p><p>所以，为了避免出现这种问题，需要在操作系统上关闭内存大页机制。</p><h2 id="如何保证-Redis-的可靠性？"><a href="#如何保证-Redis-的可靠性？" class="headerlink" title="如何保证 Redis 的可靠性？"></a>如何保证 Redis 的可靠性？</h2><p>保证 Redis 可靠性其实并不难，但难的是如何做到「持续稳定」。</p><p>下面会从「资源隔离」、「多副本」、「故障恢复」这三大维度，分析保障 Redis 可靠性的最佳实践。</p><p><strong>1) 按业务线部署实例</strong></p><p>提升可靠性的第一步，就是「资源隔离」。最好按不同的业务线来部署 Redis 实例，这样当其中一个实例发生故障时，不会影响到其它业务。这种资源隔离的方案，实施成本是最低的，但成效却是非常大的。</p><p><strong>2) 部署主从集群</strong></p><p>如果只使用单机版 Redis，那么就会存在机器宕机服务不可用的风险。所以，你需要部署「多副本」实例，即主从集群，这样当主库宕机后，依旧有从库可以使用，避免了数据丢失的风险，也降低了服务不可用的时间。</p><p>在部署主从集群时，还需要注意，主从库需要分布在不同机器上，避免交叉部署。这么做的原因在于，通常情况下，Redis 的主库会承担所有的读写流量，所以我们一定要优先保证主库的稳定性，即使从库机器异常，也不要对主库造成影响。</p><p>而且，有时我们需要对 Redis 做日常维护，例如数据定时备份等操作，这时就可以只在从库上进行，这只会消耗从库机器的资源，也避免了对主库的影响。</p><p><strong>3) 合理配置主从复制参数</strong></p><p>在部署主从集群时，如果参数配置不合理，也有可能导致主从复制发生问题：</p><ul><li>主从复制中断</li><li>从库发起全量复制，主库性能受到影响</li></ul><p>在这方面有以下 2 点：</p><ol><li>设置合理的 repl-backlog 参数：过小的 repl-backlog 在写流量比较大的场景下，主从复制中断会引发全量复制数据的风险</li><li>设置合理的 slave client-output-buffer-limit：当从库复制发生问题时，过小的 buffer 会导致从库缓冲区溢出，从而导致复制中断</li></ol><p><strong>4) 部署哨兵集群，实现故障自动切换</strong></p><p>只部署了主从节点，但故障发生时是无法自动切换的，所以，你还需要部署哨兵集群，实现故障的「自动切换」。而且，多个哨兵节点需要分布在不同机器上，实例为奇数个，防止哨兵选举失败，影响切换时间。</p><p>以上这些就是保障 Redis「高可靠」实践优化，这些都是部署和运维层的优化。</p><h2 id="日常运维-Redis-需要注意什么？"><a href="#日常运维-Redis-需要注意什么？" class="headerlink" title="日常运维 Redis 需要注意什么？"></a>日常运维 Redis 需要注意什么？</h2><p><strong>1) 禁止使用 KEYS/FLUSHALL/FLUSHDB 命令</strong></p><p>执行这些命令，会长时间阻塞 Redis 主线程，危害极大，所以你必须禁止使用它。如果确实想使用这些命令：</p><ul><li>SCAN 替换 KEYS</li><li>4.0+版本可使用 FLUSHALL/FLUSHDB ASYNC，清空数据的操作放在后台线程执行</li></ul><p><strong>2) 扫描线上实例时，设置休眠时间</strong></p><p>不管是使用 SCAN 扫描线上实例，还是对实例做 bigkey 统计分析，在扫描时一定记得设置休眠时间。防止在扫描过程中，实例 OPS 过高对 Redis 产生性能抖动。</p><p><strong>3) 慎用 MONITOR 命令</strong></p><p>有时在排查 Redis 问题时，你会使用 MONITOR 查看 Redis 正在执行的命令。但如果 Redis OPS 比较高，那么在执行 MONITOR 会导致 Redis 输出缓冲区的内存持续增长，这会严重消耗 Redis 的内存资源，甚至会导致实例内存超过 maxmemory，引发数据淘汰。</p><p><img src="/posts/41948/640-1712768648600-9.webp" alt></p><p>所以在执行 MONITOR 命令时，一定要谨慎，尽量少用。</p><p><strong>4) 从库必须设置为 slave-read-only</strong></p><p>从库必须设置为 slave-read-only 状态，避免从库写入数据，导致主从数据不一致。除此之外，从库如果是非 read-only 状态，如果你使用的是 4.0 以下的 Redis，它存在这样的 Bug：</p><p><strong>从库写入了有过期时间的数据，不会做定时清理和释放内存。</strong></p><p>这会造成从库的内存泄露！这个问题直到 4.0 版本才修复，你在配置从库时需要格外注意。</p><p><strong>5) 合理配置 timeout 和 tcp-keepalive 参数</strong></p><p>如果因为网络原因，导致大量客户端连接与 Redis 意外中断，恰好 Redis 配置的 maxclients 参数比较小，此时有可能导致客户端无法与服务端建立新的连接（服务端认为超过了 maxclients）。</p><p>造成这个问题原因在于，客户端与服务端每建立一个连接，Redis 都会给这个客户端分配了一个 client fd。<strong>当客户端与服务端网络发生问题时，服务端并不会立即释放这个 client fd。</strong>什么时候释放呢？</p><p>Redis 内部有一个定时任务，会定时检测所有 client 的空闲时间是否超过配置的 timeout 值。如果 Redis 没有开启 tcp-keepalive 的话，服务端直到配置的 timeout 时间后，才会清理释放这个 client fd。</p><p>在没有清理之前，如果还有大量新连接进来，就有可能导致 Redis 服务端内部持有的 client fd 超过了 maxclients，这时新连接就会被拒绝。针对这种情况的优化建议是：</p><ol><li>不要配置过高的 timeout：让服务端尽快把无效的 client fd 清理掉</li><li>Redis 开启 tcp-keepalive：这样服务端会定时给客户端发送 TCP 心跳包，检测连接连通性，当网络异常时，可以尽快清理僵尸 client fd</li></ol><p><strong>6) 调整 maxmemory 时，注意主从库的调整顺序</strong></p><p>Redis 5.0 以下版本存在这样一个问题：<strong>从库内存如果超过了 maxmemory，也会触发数据淘汰。</strong></p><p>在某些场景下，从库是可能优先主库达到 maxmemory 的（例如在从库执行 MONITOR 命令，输出缓冲区占用大量内存），那么此时从库开始淘汰数据，主从库就会产生不一致。</p><p>要想避免此问题，在调整 maxmemory 时，一定要注意主从库的修改顺序：</p><ul><li>调大 maxmemory：先修改从库，再修改主库</li><li>调小 maxmemory：先修改主库，再修改从库</li></ul><p>直到 Redis 5.0，Redis 才增加了一个配置 replica-ignore-maxmemory，默认从库超过 maxmemory 不会淘汰数据，才解决了此问题。</p><h2 id="Redis-安全如何保证？"><a href="#Redis-安全如何保证？" class="headerlink" title="Redis 安全如何保证？"></a>Redis 安全如何保证？</h2><p>无论如何，在互联网时代，安全问题一定是我们需要随时警戒的。你可能听说过 Redis 被注入可执行脚本，然后拿到机器 root 权限的安全问题，都是因为在部署 Redis 时，没有把安全风险注意起来。针对这方面：</p><ol><li>不要把 Redis 部署在公网可访问的服务器上</li><li>部署时不使用默认端口 6379</li><li>以普通用户启动 Redis 进程，禁止 root 用户启动</li><li>限制 Redis 配置文件的目录访问权限</li><li>推荐开启密码认证</li><li>禁用/重命名危险命令（KEYS/FLUSHALL/FLUSHDB/CONFIG/EVAL）</li></ol><p>只要你把这些做到位，基本上就可以保证 Redis 的安全风险在可控范围内。</p><h2 id="如何预防-Redis-问题？"><a href="#如何预防-Redis-问题？" class="headerlink" title="如何预防 Redis 问题？"></a>如何预防 Redis 问题？</h2><p>要想提前预防 Redis 问题，你需要做好以下两个方面：</p><ol><li>合理的资源规划</li><li>完善的监控预警</li></ol><p>先来说资源规划。在部署 Redis 时，如果你可以提前做好资源规划，可以避免很多因为资源不足产生的问题：</p><ol><li>保证机器有足够的 CPU、内存、带宽、磁盘资源</li><li>提前做好容量规划，主库机器预留一半内存资源，防止主从机器网络故障，引发大面积全量同步，导致主库机器内存不足的问题</li><li>单个实例内存建议控制在 10G 以下，大实例在主从全量同步、RDB 备份时有阻塞风险</li></ol><p>再来看监控如何做。监控预警是提高稳定性的重要环节，完善的监控预警，可以把问题提前暴露出来，这样我们才可以快速反应，把问题最小化：</p><ol><li>做好机器 CPU、内存、带宽、磁盘监控，资源不足时及时报警，任意资源不足都会影响 Redis 性能</li><li>设置合理的 slowlog 阈值，并对其进行监控，slowlog 过多及时报警</li><li>监控组件采集 Redis INFO 信息时，采用长连接，避免频繁的短连接</li><li>做好实例运行时监控，重点关注 expired_keys、evicted_keys、latest_fork_usec 指标，这些指标短时突增可能会有阻塞风险</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;学习他人的经验，首先还是抛出问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我的 Redis 内存为什么增长这么快？&lt;/li&gt;
&lt;li&gt;为什么我的 Red
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://JoyTsing.github.io/categories/Redis/"/>
    
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="数据库" scheme="https://JoyTsing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="https://JoyTsing.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis集群进化之路</title>
    <link href="https://joytsing.github.io/posts/51730/"/>
    <id>https://joytsing.github.io/posts/51730/</id>
    <published>2024-04-10T09:14:02.000Z</published>
    <updated>2024-04-10T14:38:41.246Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>我使用 Redis 的场景很简单，只使用单机版 Redis 会有什么问题吗？</li><li>我的 Redis 故障宕机了，数据丢失了怎么办？如何能保证我的业务应用不受影响？</li><li>为什么需要主从集群？它有什么优势？</li><li>什么是分片集群？我真的需要分片集群吗？</li><li>…</li></ul><p>高性能的 Redis 集群为了做到稳定、高性能，都采取了哪些优化方案，为什么要这么做？</p><h2 id="从最简单的开始：单机版-Redis"><a href="#从最简单的开始：单机版-Redis" class="headerlink" title="从最简单的开始：单机版 Redis"></a>从最简单的开始：单机版 Redis</h2><p>首先从最简单的场景开始。假设现在有一个业务应用，需要引入 Redis 来提高应用的性能，可以选择部署一个单机版的 Redis 来使用，就像这样：</p><p><img src="/posts/51730/640.webp" alt></p><p>这个架构非常简单，业务应用可以把 Redis 当做缓存来使用，从 MySQL 中查询数据，然后写入到 Redis 中，之后业务应用再从 Redis 中读取这些数据，由于 Redis 的数据都存储在内存中，所以这个速度飞快。</p><p>如果业务体量并不大，那这样的架构模型基本可以满足你的需求。是不是很简单？随着时间的推移，你的业务体量逐渐发展起来了，Redis 中存储的数据也越来越多，此时你的业务应用对 Redis 的依赖也越来越重。但是突然有一天Redis 因为某些原因宕机了，这时所有业务流量，都会打到后端 MySQL 上，这会导致 MySQL 压力剧增，严重的话甚至会压垮 MySQL。</p><p><img src="/posts/51730/640-1712746680741-3.webp" alt></p><p>这时你应该怎么办？首先肯定需要赶紧重启 Redis，让它可以继续提供服务。但是，因为之前 Redis 中的数据都在内存中，尽管你现在把 Redis 重启了，之前的数据也都丢失了。重启后的 Redis 虽然可以正常工作，但是由于 Redis 中没有任何数据，业务流量还是都会打到后端 MySQL 上，MySQL 的压力还是很大。</p><p>这可怎么办？有没有什么好的办法解决这个问题？既然 Redis 只把数据存储在内存中，那是否可以把这些数据也写一份到磁盘上呢？如果采用这种方式，当 Redis 重启时，我们把磁盘中的数据快速<strong>恢复</strong>到内存中，这样它就可以继续正常提供服务了。是的，这是一个很好的解决方案，这个把内存数据写到磁盘上的过程，就是「数据持久化」。</p><h2 id="数据持久化：有备无患"><a href="#数据持久化：有备无患" class="headerlink" title="数据持久化：有备无患"></a>数据持久化：有备无患</h2><p>数据持久化具体应该怎么做呢？最容易想到的一个方案是，Redis 每一次执行写操作，除了写内存之外，同时也写一份到磁盘上，就像这样：</p><p><img src="/posts/51730/640-1712746720874-7.webp" alt></p><p>但仔细想一下，这个方案有个问题：客户端的每次写操作，既需要写内存，又需要写磁盘，而写磁盘的耗时相比于写内存来说，肯定要慢很多！这势必会影响到 Redis 的性能。如何规避这个问题？</p><p>可以这样优化：Redis 写内存由主线程来做，写内存完成后就给客户端返回结果，然后 Redis 用另一个线程去写磁盘，这样就可以避免主线程写磁盘对性能的影响。这确实是一个好方案。除此之外，我们可以换个角度，思考一下还有什么方式可以持久化数据？</p><p>这时就要结合 Redis 的使用场景来考虑了。在使用 Redis 时，通常把它用作什么场景？缓存。把 Redis 当做缓存来用，意味着尽管 Redis 中没有保存全量数据，对于不在缓存中的数据，我们的业务应用依旧可以通过查询后端数据库得到结果，只不过查询后端数据的速度会慢一点而已，但对业务结果其实是没有影响的。基于这个特点，我们的 Redis 数据持久化还可以用「数据快照」的方式来做。</p><p>那什么是数据快照呢？简单来讲可以这么理解：</p><ol><li>把 Redis 想象成一个水杯，向 Redis 写入数据，就相当于往这个杯子里倒水</li><li>此时拿一个相机给这个水杯拍一张照片，拍照的这一瞬间，照片中记录到这个水杯中水的容量，就是水杯的数据快照</li></ol><p><img src="/posts/51730/640-1712746819053-12.webp" alt></p><p>也就是说，Redis 的数据快照，是记录某一时刻下 Redis 中的数据，然后只需要把这个数据快照写到磁盘上就可以了。它的优势在于，只在需要持久化时，把数据「一次性」写入磁盘，其它时间都不需要操作磁盘。基于这个方案可以<strong>定时</strong>给 Redis 做数据快照，把数据持久化到磁盘上。</p><p><img src="/posts/51730/640-1712746906562-15.webp" alt></p><p>其实，上面说的这些持久化方案，就是 Redis 的「RDB」和「AOF」：</p><ul><li>RDB：只持久化某一时刻的数据快照到磁盘上（创建一个子进程来做）</li><li>AOF：每一次写操作都持久到磁盘（主线程写内存，根据策略可以配置由主线程还是子线程进行数据持久化）</li></ul><p>它们的区别除了上面讲到的，还有以下特点：</p><ol><li>RDB 采用二进制 + 数据压缩的方式写磁盘，这样文件体积小，数据恢复速度也快</li><li>AOF 记录的是每一次写命令，数据最全，但文件体积大，数据恢复速度慢</li></ol><p>如果让你来选择持久化方案，可以这样选择：</p><ol><li>如果业务对于数据丢失不敏感，采用 RDB 方案持久化数据</li><li>如果业务对数据完整性要求比较高，采用 AOF 方案持久化数据</li></ol><p>假设业务对 Redis 数据完整性要求比较高，选择了 AOF 方案，那此时你又会遇到这些问题：</p><ol><li>AOF 记录每一次写操作，随着时间增长，AOF 文件体积会越来越大</li><li>这么大的 AOF 文件，在数据恢复时变得非常慢</li></ol><p>这怎么办？数据完整性要求变高了，恢复数据也变困难了？有没有什么方法，可以缩小文件体积？提升恢复速度呢？由于 AOF 文件中记录的都是每一次写操作，但对于同一个 key 可能会发生多次修改，只保留最后一次被修改的值，是不是也可以？这就是「AOF rewrite」，也可以把它理解为 AOF 「瘦身」。</p><p>可以对 AOF 文件定时 rewrite，避免这个文件体积持续膨胀，这样在恢复时就可以缩短恢复时间了。</p><p><img src="/posts/51730/640-1712746985484-18.webp" alt></p><p>再进一步思考一下，还有没有办法继续缩小 AOF 文件？回顾一下我们前面讲到的，RDB 和 AOF 各自的特点：</p><ol><li>RDB 以二进制 + 数据压缩方式存储，文件体积小</li><li>AOF 记录每一次写命令，数据最全</li></ol><p>可否利用它们各自的优势呢？当然可以，这就是 Redis 的「混合持久化」。具体来说，当 AOF rewrite 时，Redis 先以 RDB 格式在 AOF 文件中写入一个数据快照，再把在这期间产生的每一个写命令，追加到 AOF 文件中。因为 RDB 是二进制压缩写入的，这样 AOF 文件体积就变得更小了。</p><p><img src="/posts/51730/640-1712746995883-21.webp" alt></p><blockquote><p>Redis 4.0 以上版本才支持混合持久化。</p></blockquote><p>这么一番优化Redis再也不用担心实例宕机了，当发生宕机时就可以用持久化文件快速恢复 Redis 中的数据。</p><p>但这样就没问题了吗？仔细想一下，虽然我们已经把持久化的文件优化到最小了，但在恢复数据时依旧是需要时间的，在这期间你的业务应用还是会受到影响，这怎么办？有没有更好的方案？</p><p>一个实例宕机，只能用恢复数据来解决，那是否可以部署多个 Redis 实例，然后让这些实例数据保持实时同步，这样当一个实例宕机时，我们在剩下的实例中选择一个继续提供服务就好了。</p><h2 id="主从复制：多副本"><a href="#主从复制：多副本" class="headerlink" title="主从复制：多副本"></a>主从复制：多副本</h2><p>此时，可以部署多个 Redis 实例，架构模型就变成了这样：</p><p><img src="/posts/51730/640-1712759373096-24.webp" alt></p><p>我们这里把实时读写的节点叫做 master，另一个实时同步数据的节点叫做 slave，采用多副本的方案，它的优势是：</p><ol><li>缩短不可用时间：master 发生宕机，我们可以手动把 slave 提升为 master 继续提供服务</li><li>提升读性能：让 slave 分担一部分读请求，提升应用的整体性能</li></ol><p><img src="/posts/51730/640-1712759373096-25.webp" alt></p><p>这个方案不错，不仅节省了数据恢复的时间，还能提升性能，那它有什么问题吗？</p><p>它的问题在于：当 master 宕机时，我们需要「手动」把 slave 提升为 master，这个过程也是需要花费时间的。虽然比恢复数据要快得多，但还是需要人工介入处理。一旦需要人工介入，就必须要算上人的反应时间、操作时间，所以，在这期间业务应用依旧会受到影响。</p><p>怎么解决这个问题？我们是否可以把这个切换的过程，变成自动化呢？对于这种情况，我们需要一个「故障自动切换」机制，这就是我们经常听到的「哨兵」所具备的能力。</p><h2 id="哨兵：故障自动切换"><a href="#哨兵：故障自动切换" class="headerlink" title="哨兵：故障自动切换"></a>哨兵：故障自动切换</h2><p>现在，可以引入一个「观察者」，让这个观察者去实时监测 master 的健康状态，这个观察者就是「哨兵」。具体如何做？</p><ol><li>哨兵每间隔一段时间，询问 master 是否正常</li><li>master 正常回复，表示状态正常，回复超时表示异常</li><li>哨兵发现异常，发起主从切换</li></ol><p><img src="/posts/51730/640-1712759415184-30.webp" alt></p><p>但这里还有一个问题，如果 master 状态正常，但这个哨兵在询问 master 时，它们之间的网络发生了问题，那这个哨兵可能会误判。</p><p><img src="/posts/51730/640-1712759446267-33.webp" alt></p><p>这个问题怎么解决？答案是，可以部署多个哨兵，让它们分布在不同的机器上，它们一起监测 master 的状态，流程就变成了这样：</p><ol><li>多个哨兵每间隔一段时间，询问 master 是否正常</li><li>master 正常回复，表示状态正常，回复超时表示异常</li><li>一旦有一个哨兵判定 master 异常（不管是否是网络问题），就询问其它哨兵，如果多个哨兵（设置一个阈值）都认为 master 异常了，这才判定 master 确实发生了故障</li><li>多个哨兵经过协商后，判定 master 故障，则发起主从切换</li></ol><p>所以，我们用多个哨兵互相协商来判定 master 的状态，这样一来，就可以大大降低误判的概率。哨兵协商判定 master 异常后，这里还有一个问题：<strong>由哪个哨兵来发起主从切换呢？</strong></p><p>答案是，选出一个哨兵「领导者」，由这个领导者进行主从切换。问题又来了，这个领导者怎么选？在选举哨兵领导者时，我们可以制定这样一个选举规则：</p><ol><li>每个哨兵都询问其它哨兵，请求对方为自己投票</li><li>每个哨兵只投票给第一个请求投票的哨兵，且只能投票一次</li><li>首先拿到超过半数投票的哨兵，当选为领导者，发起主从切换</li></ol><p>其实，这个选举的过程就是我们经常听到的：分布式系统领域中的「共识算法」。</p><p>什么是共识算法？我们在多个机器部署哨兵，它们需要共同协作完成一项任务，所以它们就组成了一个「分布式系统」。在分布式系统领域，多个节点如何就一个问题达成共识的算法，就叫共识算法。在这个场景下，多个哨兵共同协商，选举出一个都认可的领导者，就是使用共识算法完成的。</p><p>这个算法还规定节点的数量必须是奇数个，这样可以保证系统中即使有节点发生了故障，剩余超过「半数」的节点状态正常，依旧可以提供正确的结果，也就是说，这个算法还兼容了存在故障节点的情况。</p><blockquote><p>共识算法在分布式系统领域有很多，例如 Paxos、Raft，哨兵选举领导者这个场景，使用的是 Raft 共识算法，因为它足够简单，且易于实现。</p></blockquote><p>现在，我们用多个哨兵共同监测 Redis 的状态，这样一来，就可以避免误判的问题了，架构模型就变成了这样：</p><p><img src="/posts/51730/640-1712759591360-36.webp" alt></p><p>随着时间的发展，业务体量开始迎来了爆炸性增长，此时架构模型，还能够承担这么大的流量吗？一起来分析一下：</p><ol><li>稳定性：Redis 故障宕机，我们有哨兵 + 副本，可以自动完成主从切换</li><li>性能：读请求量增长，我们可以再部署多个 slave，读写分离，分担读压力</li><li>性能：写请求量增长，但我们只有一个 master 实例，这个实例达到瓶颈怎么办？</li></ol><p>看到了么，当你的写请求量越来越大时，一个 master 实例可能就无法承担这么大的写流量了。要想完美解决这个问题，此时你就需要考虑使用「分片集群」了。</p><h2 id="分片集群：横向扩展"><a href="#分片集群：横向扩展" class="headerlink" title="分片集群：横向扩展"></a>分片集群：横向扩展</h2><p>什么是「分片集群」？</p><p>简单来讲，一个实例扛不住写压力，那我们是否可以部署多个实例，然后把这些实例按照一定规则组织起来，把它们当成一个整体，对外提供服务，这样不就可以解决集中写一个实例的瓶颈问题吗？</p><p>所以，现在的架构模型就变成了这样：</p><p><img src="/posts/51730/640-1712759631118-39.webp" alt></p><p>现在问题又来了，这么多实例如何组织呢？我们制定规则如下：</p><ol><li>每个节点各自存储一部分数据，所有节点数据之和才是全量数据</li><li>制定一个路由规则，对于不同的 key，把它路由到固定一个实例上进行读写</li></ol><p>而分片集群根据路由规则所在位置的不同，还可以分为两大类：</p><ol><li>客户端分片</li><li>服务端分片</li></ol><p>客户端分片指的是，key 的路由规则放在客户端来做，就是下面这样：</p><p><img src="/posts/51730/640-1712759646445-42.webp" alt></p><p>这个方案的缺点是，客户端需要维护这个路由规则，也就是说，你需要把路由规则写到你的业务代码中。如何做到不把路由规则耦合在业务代码中呢？你可以这样优化，把这个路由规则封装成一个模块，当需要使用时，集成这个模块就可以了。</p><p>这就是 Redis Cluster 的采用的方案。</p><p><img src="/posts/51730/640-1712759661868-45.webp" alt></p><blockquote><p>Redis Cluster 内置了哨兵逻辑，无需再部署哨兵。</p></blockquote><p>当使用 Redis Cluster 时，业务应用需要使用配套的 Redis SDK，这个 SDK 内就集成好了路由规则，不需要你自己编写了。</p><p>再来看服务端分片，这种方案指的是，路由规则不放在客户端来做，而是在客户端和服务端之间增加一个「中间代理层」，这个代理就是我们经常听到的 Proxy。而数据的路由规则，就放在这个 Proxy 层来维护。这样一来，你就无需关心服务端有多少个 Redis 节点了，只需要和这个 Proxy 交互即可。</p><p>Proxy 会把你的请求根据路由规则，转发到对应的 Redis 节点上，而且，当集群实例不足以支撑更大的流量请求时，还可以横向扩容，添加新的 Redis 实例提升性能，这一切对于你的客户端来说，都是透明无感知的。</p><p>业界开源的 Redis 分片集群方案，例如 Twemproxy、Codis 就是采用的这种方案。</p><p><img src="/posts/51730/640-1712759695847-48.webp" alt></p><blockquote><p>分片集群在数据扩容时，还涉及到了很多细节，这块内容不是本文章重点，所以暂不详述。</p></blockquote><p>至此，当使用分片集群后，对于未来更大的流量压力，都可以从容面对了！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如何一步步构建一个稳定、高性能的 Redis 集群：</p><ul><li>首先，在使用最简单的单机版 Redis 时，我们发现当 Redis 故障宕机后，数据无法恢复的问题，因此想到了「数据持久化」，把内存中的数据也持久化到磁盘上一份，这样 Redis 重启后就可以从磁盘上快速恢复数据。</li><li>在进行数据持久化时，我们又面临如何更高效地将数据持久化到磁盘的问题。之后发现 Redis 提供了 RDB 和 AOF 两种方案，分别对应了数据快照和实时的命令记录。当我们对数据完整性要求不高时，可以选择 RDB 持久化方案。如果对于数据完整性要求较高，那么可以选择 AOF 持久化方案。</li><li>但是我们又发现，AOF 文件体积会随着时间增长变得越来越大，此时我们想到的优化方案是，使用 AOF rewrite 的方式对其进行瘦身，减小文件体积，再后来，我们发现可以结合 RDB 和 AOF 各自的优势，在 AOF rewrite 时使用两者结合的「混合持久化」方式，又进一步减小了 AOF 文件体积。</li><li>之后，我们发现尽管可以通过数据恢复的方式还原数据，但恢复数据也是需要花费时间的，这意味着业务应用还是会受到影响。我们进一步优化，采用「多副本」的方案，让多个实例保持实时同步，当一个实例故障时，可以手动把其它实例提升上来继续提供服务。</li><li>但是这样也有问题，手动提升实例上来，需要人工介入，人工介入操作也需要时间，我们开始想办法把这个流程变得自动化，所以我们又引入了「哨兵」集群，哨兵集群通过互相协商的方式，发现故障节点，并可以自动完成切换，这样就大幅降低了对业务应用的影响。</li><li>最后，我们把关注点聚焦在如何支撑更大的写流量上，所以，我们又引入了「分片集群」来解决这个问题，让多个 Redis 实例分摊写压力，未来面对更大的流量，我们还可以添加新的实例，横向扩展，进一步提升集群的性能。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;我使用 Redis 的场景很简单，只使用单机版 Redis 会有什么问题吗？&lt;/li&gt;
&lt;li&gt;我的 Redis 故障宕机了，数
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://JoyTsing.github.io/categories/Redis/"/>
    
    
      <category term="数据库" scheme="https://JoyTsing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="https://JoyTsing.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>解决Redis缓存和数据库一致性问题</title>
    <link href="https://joytsing.github.io/posts/10748/"/>
    <id>https://joytsing.github.io/posts/10748/</id>
    <published>2024-04-10T08:29:14.000Z</published>
    <updated>2024-04-10T09:06:42.280Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>到底是更新缓存还是删缓存？</li><li>到底选择先更新数据库，再删除缓存，还是先删除缓存，再更新数据库？</li><li>为什么要引入消息队列保证一致性？</li><li>延迟双删会有什么问题？到底要不要用？</li><li>…</li></ul><h2 id="引入缓存提高性能"><a href="#引入缓存提高性能" class="headerlink" title="引入缓存提高性能"></a>引入缓存提高性能</h2><p>如果业务处于起步阶段，流量非常小，那无论是读请求还是写请求，直接操作数据库即可，这时架构模型是这样的：</p><p><img src="/posts/10748/640.webp" alt></p><p>但随着业务量的增长，项目请求量越来越大，这时如果每次都从数据库中读数据，那肯定会有性能问题。这个阶段通常的做法是，引入「缓存」来提高读性能，架构模型就变成了这样：</p><p><img src="/posts/10748/640-1712737981539-1.webp" alt></p><p>当下优秀的缓存中间件，当属 Redis 莫属，它不仅性能非常高，还提供了很多友好的数据类型，可以很好地满足我们的业务需求。</p><p>但引入缓存之后，就会面临一个问题：<strong>之前数据只存在数据库中，现在要放到缓存中读取，具体要怎么存呢？</strong></p><p>最简单直接的方案是「全量数据刷到缓存中」：</p><ul><li>数据库的数据，全量刷入缓存（不设置失效时间）</li><li>写请求只更新数据库，不更新缓存</li><li>启动一个定时任务，定时把数据库的数据，更新到缓存中</li></ul><p><img src="/posts/10748/640-1712737981539-2.webp" alt></p><p>这个方案的优点是，所有读请求都可以直接「命中」缓存，不需要再查数据库，性能非常高。但缺点也很明显，有 2 个问题：</p><ol><li><strong>缓存利用率低</strong>：不经常访问的数据，还一直留在缓存中</li><li><strong>数据不一致</strong>：因为是「定时」刷新缓存，缓存和数据库存在不一致（取决于定时任务的执行频率）</li></ol><p>所以，这种方案一般更适合业务「体量小」，且对数据一致性要求不高的业务场景。</p><p>那如果我们的业务体量很大，怎么解决这 2 个问题呢？</p><h2 id="缓存利用率和一致性问题"><a href="#缓存利用率和一致性问题" class="headerlink" title="缓存利用率和一致性问题"></a>缓存利用率和一致性问题</h2><p>先来看第一个问题，如何提高缓存利用率？想要缓存利用率「最大化」，我们很容易想到的方案是，缓存中只保留最近访问的「热数据」。但具体要怎么做呢？</p><p>我们可以这样优化：</p><ul><li>写请求依旧只写数据库</li><li>读请求先读缓存，如果缓存不存在，则从数据库读取，并重建缓存</li><li>同时，写入缓存中的数据，都设置失效时间</li></ul><p><img src="/posts/10748/640-1712738117920-9.webp" alt></p><p>这样一来，缓存中不经常访问的数据，随着时间的推移，都会逐渐「过期」淘汰掉，最终缓存中保留的，都是经常被访问的「热数据」，缓存利用率得以最大化，再来看数据一致性问题。</p><p>要想保证缓存和数据库「实时」一致，那就不能再用定时任务刷新缓存了。所以，当数据发生更新时，我们不仅要操作数据库，还要一并操作缓存。具体操作就是，修改一条数据时，不仅要更新数据库，也要连带缓存一起更新。但数据库和缓存都更新，又存在先后问题，那对应的方案就有 2 个：</p><ol><li>先更新缓存，后更新数据库</li><li>先更新数据库，后更新缓存</li></ol><p>哪个方案更好呢？先不考虑并发问题，正常情况下，无论谁先谁后，都可以让两者保持一致，但现在我们需要重点考虑「异常」情况。因为操作分为两步，那么就很有可能存在「第一步成功、第二步失败」的情况发生。这 2 种方案我们一个个来分析。</p><p><strong>1) 先更新缓存，后更新数据库</strong></p><p>如果缓存更新成功了，但数据库更新失败，那么此时缓存中是最新值，但数据库中是「旧值」。</p><p>虽然此时读请求可以命中缓存，拿到正确的值，但是，一旦缓存「失效」，就会从数据库中读取到「旧值」，重建缓存也是这个旧值。</p><p>这时用户会发现自己之前修改的数据又「变回去」了，对业务造成影响。</p><p><strong>2) 先更新数据库，后更新缓存</strong></p><p>如果数据库更新成功了，但缓存更新失败，那么此时数据库中是最新值，缓存中是「旧值」。之后的读请求读到的都是旧数据，只有当缓存「失效」后，才能从数据库中得到正确的值。</p><p>这时用户会发现，自己刚刚修改了数据，但却看不到变更，一段时间过后，数据才变更过来，对业务也会有影响。可见，无论谁先谁后，但凡后者发生异常，就会对业务造成影响。那怎么解决这个问题呢？</p><p>除了操作失败问题，还有什么场景会影响数据一致性？<strong>并发问题</strong>。</p><h2 id="并发引发的一致性问题"><a href="#并发引发的一致性问题" class="headerlink" title="并发引发的一致性问题"></a>并发引发的一致性问题</h2><p>假设采用「先更新数据库，再更新缓存」的方案，并且两步都可以「成功执行」的前提下，如果存在并发，情况会是怎样的呢？有线程 A 和线程 B 两个线程，需要更新「同一条」数据，会发生这样的场景：</p><blockquote><ol><li>线程 A 更新数据库（X = 1）</li><li>线程 B 更新数据库（X = 2）</li><li>线程 B 更新缓存（X = 2）</li><li>线程 A 更新缓存（X = 1）</li></ol></blockquote><p>最终 X 的值在缓存中是 1，在数据库中是 2，发生不一致。也就是说，A 虽然先于 B 发生，但 B 操作数据库和缓存的时间，却要比 A 的时间短，执行时序发生「错乱」，最终这条数据结果是不符合预期的。</p><blockquote><p>同样地，采用「先更新缓存，再更新数据库」的方案，也会有类似问题，这里不再详述。</p></blockquote><p>除此之外，我们从「缓存利用率」的角度来评估这个方案，也是不太推荐的。这是因为每次数据发生变更，都「无脑」更新缓存，但是缓存中的数据不一定会被「马上读取」，这就会导致缓存中可能存放了很多不常访问的数据，浪费缓存资源。</p><p>而且很多情况下，写到缓存中的值，并不是与数据库中的值一一对应的，很有可能是先查询数据库，再经过一系列「计算」得出一个值，才把这个值才写到缓存中。由此可见，这种「更新数据库 + 更新缓存」的方案，不仅缓存利用率不高，还会造成机器性能的浪费。</p><p>所以此时我们需要考虑另外一种方案：<strong>删除缓存</strong>。</p><h2 id="删除缓存可以保证一致性吗？"><a href="#删除缓存可以保证一致性吗？" class="headerlink" title="删除缓存可以保证一致性吗？"></a>删除缓存可以保证一致性吗？</h2><p>删除缓存对应的方案也有 2 种：</p><ol><li>先删除缓存，后更新数据库</li><li>先更新数据库，后删除缓存</li></ol><p>经过前面的分析我们已经得知，但凡「第二步」操作失败，都会导致数据不一致。重点来看「并发」问题。</p><p><strong>1) 先删除缓存，后更新数据库</strong></p><p>如果有 2 个线程要并发「读写」数据，可能会发生以下场景：</p><blockquote><ol><li>线程 A 要更新 X = 2（原值 X = 1）</li><li>线程 A 先删除缓存</li><li>线程 B 读缓存，发现不存在，从数据库中读取到旧值（X = 1）</li><li>线程 A 将新值写入数据库（X = 2）</li><li>线程 B 将旧值写入缓存（X = 1）</li></ol></blockquote><p>最终 X 的值在缓存中是 1（旧值），在数据库中是 2（新值），发生不一致。</p><p>可见，先删除缓存，后更新数据库，当发生「读+写」并发时，还是存在数据不一致的情况。</p><p><strong>2) 先更新数据库，后删除缓存</strong></p><p>依旧是 2 个线程并发「读写」数据：</p><blockquote><ol><li>缓存中 X 不存在（数据库 X = 1）</li><li>线程 A 读取数据库，得到旧值（X = 1）</li><li>线程 B 更新数据库（X = 2)</li><li>线程 B 删除缓存</li><li>线程 A 将旧值写入缓存（X = 1）</li></ol></blockquote><p>最终 X 的值在缓存中是 1（旧值），在数据库中是 2（新值），也发生不一致。这种情况「理论」来说是可能发生的，但实际真的有可能发生吗？概率「很低」，这是因为它必须满足 3 个条件：</p><ol><li>缓存刚好已失效</li><li>读请求 + 写请求并发</li><li>更新数据库 + 删除缓存的时间（步骤 3-4），要比读数据库 + 写缓存时间短（步骤 2 和 5）</li></ol><p>仔细想一下，条件 3 发生的概率其实是非常低的。因为写数据库一般会先「加锁」，所以写数据库，通常是要比读数据库的时间更长的。这么来看，「先更新数据库 + 再删除缓存」的方案，是可以保证一定程度的数据一致性。</p><p>所以应该采用这种方案，来操作数据库和缓存。解决了并发问题，我们继续来看前面遗留的，<strong>第二步执行「失败」导致数据不一致的问题</strong>。</p><h2 id="如何保证两步都执行成功？"><a href="#如何保证两步都执行成功？" class="headerlink" title="如何保证两步都执行成功？"></a>如何保证两步都执行成功？</h2><p>前面分析到，无论是更新缓存还是删除缓存，只要第二步发生失败，那么就会导致数据库和缓存不一致。</p><p><strong>保证第二步成功执行，就是解决问题的关键。</strong></p><p>想一下，程序在执行过程中发生异常，最简单的解决办法是什么？答案是：<strong>重试</strong>。</p><p>无论是先操作缓存，还是先操作数据库，但凡后者执行失败了就可以发起重试，尽可能地去做「补偿」。那这是不是意味着，只要执行失败，我们「无脑重试」就可以了呢？答案是否定的。现实情况往往没有想的这么简单，失败后立即重试的问题在于：</p><ul><li>立即重试很大概率「还会失败」</li><li>「重试次数」设置多少才合理？</li><li>重试会一直「占用」这个线程资源，无法服务其它客户端请求</li></ul><p>虽然想通过重试的方式解决问题，但这种「同步」重试的方案依旧不严谨。那更好的方案应该怎么做？答案是：<strong>异步重试</strong>。</p><p>把重试请求写到「消息队列」中，然后由专门的消费者来重试，直到成功。或者更直接的做法，为了避免第二步执行失败，我们可以把操作缓存这一步，直接放到消息队列中，由消费者来操作缓存。</p><p>到这里你可能会问，写消息队列也有可能会失败啊？而且，引入消息队列，这又增加了更多的维护成本，这样做值得吗？思考这样一个问题：如果在执行失败的线程中一直重试，还没等执行成功，此时如果项目「重启」了，那这次重试请求也就「丢失」了，那这条数据就一直不一致了。</p><p>所以，这里我们必须把重试或第二步操作放到另一个「服务」中，这个服务用「消息队列」最为合适。这是因为消息队列的特性，正好符合我们的需求：</p><ul><li><strong>消息队列保证可靠性</strong>：写到队列中的消息，成功消费之前不会丢失（重启项目也不担心）</li><li><strong>消息队列保证消息成功投递</strong>：下游从队列拉取消息，成功消费后才会删除消息，否则还会继续投递消息给消费者（符合我们重试的场景）</li></ul><p>至于写队列失败和消息队列的维护成本问题：</p><ul><li><strong>写队列失败</strong>：操作缓存和写消息队列，「同时失败」的概率其实是很小的</li><li><strong>维护成本</strong>：我们项目中一般都会用到消息队列，维护成本并没有新增很多</li></ul><p>所以，引入消息队列来解决这个问题，是比较合适的。这时架构模型就变成了这样：</p><p><img src="/posts/10748/640-1712738505781-12.webp" alt></p><p>如果不想在应用中去写消息队列，是否有更简单的方案，同时又可以保证一致性呢？方案还是有的，这就是近几年比较流行的解决方案：<strong>订阅数据库变更日志，再操作缓存</strong>。</p><p>具体来讲就是，我们的业务应用在修改数据时，「只需」修改数据库，无需操作缓存。那什么时候操作缓存呢？这就和数据库的「变更日志」有关了。拿 MySQL 举例，当一条数据发生修改时，MySQL 就会产生一条变更日志（Binlog），我们可以订阅这个日志，拿到具体操作的数据，然后再根据这条数据，去删除对应的缓存。</p><p><img src="/posts/10748/640-1712738775748-15.webp" alt></p><p>订阅变更日志，目前也有了比较成熟的开源中间件，例如阿里的 canal，使用这种方案的优点在于：</p><ul><li><strong>无需考虑写消息队列失败情况</strong>：只要写 MySQL 成功，Binlog 肯定会有</li><li><strong>自动投递到下游队列</strong>：canal 自动把数据库变更日志「投递」给下游的消息队列</li></ul><p>当然，与此同时需要投入精力去维护 canal 的高可用和稳定性。</p><blockquote><p>如果你有留意观察很多数据库的特性，就会发现其实很多数据库都逐渐开始提供「订阅变更日志」的功能了，相信不远的将来，我们就不用通过中间件来拉取日志，自己写程序就可以订阅变更日志了，这样可以进一步简化流程。</p></blockquote><p>至此可以得出结论，想要保证数据库和缓存一致性，<strong>推荐采用「先更新数据库，再删除缓存」方案，并配合「消息队列」或「订阅变更日志」的方式来做</strong>。</p><h2 id="主从库延迟和延迟双删问题"><a href="#主从库延迟和延迟双删问题" class="headerlink" title="主从库延迟和延迟双删问题"></a>主从库延迟和延迟双删问题</h2><p>到这里，还有 2 个问题是没有重点分析过的。</p><p><strong>第一个问题</strong>，还记得前面讲到的「先删除缓存，再更新数据库」方案，导致不一致的场景么？</p><p>2 个线程要并发「读写」数据，可能会发生以下场景：</p><blockquote><ol><li>线程 A 要更新 X = 2（原值 X = 1）</li><li>线程 A 先删除缓存</li><li>线程 B 读缓存，发现不存在，从数据库中读取到旧值（X = 1）</li><li>线程 A 将新值写入数据库（X = 2）</li><li>线程 B 将旧值写入缓存（X = 1）</li></ol></blockquote><p>最终 X 的值在缓存中是 1（旧值），在数据库中是 2（新值），发生不一致。</p><p><strong>第二个问题</strong>：是关于「读写分离 + 主从复制延迟」情况下，缓存和数据库一致性的问题。</p><p>在「先更新数据库，再删除缓存」方案下，「读写分离 + 主从库延迟」其实也会导致不一致：</p><blockquote><ol><li>线程 A 更新主库 X = 2（原值 X = 1）</li><li>线程 A 删除缓存</li><li>线程 B 查询缓存，没有命中，查询「从库」得到旧值（从库 X = 1）</li><li>从库「同步」完成（主从库 X = 2）</li><li>线程 B 将「旧值」写入缓存（X = 1）</li></ol></blockquote><p>最终 X 的值在缓存中是 1（旧值），在主从库中是 2（新值），也发生不一致。</p><p>这 2 个问题的核心在于：<strong>缓存都被回种了「旧值」</strong>。那怎么解决这类问题呢？最有效的办法就是，<strong>把缓存删掉</strong>。</p><p>但是，不能立即删，而是需要「延迟删」，这就是业界给出的方案：<strong>缓存延迟双删策略</strong>。按照延时双删策略，这 2 个问题的解决方案是这样的：</p><p><strong>解决第一个问题</strong>：在线程 A 删除缓存、更新完数据库之后，先「休眠一会」，再「删除」一次缓存。</p><p><strong>解决第二个问题</strong>：线程 A 可以生成一条「延时消息」，写到消息队列中，消费者延时「删除」缓存。</p><p>这两个方案的目的，都是为了把缓存清掉，这样一来，下次就可以从数据库读取到最新值，写入缓存。但问题来了，这个「延迟删除」缓存，延迟时间到底设置要多久呢？</p><ul><li>问题1：延迟时间要大于「主从复制」的延迟时间</li><li>问题2：延迟时间要大于线程 B 读取数据库 + 写入缓存的时间</li></ul><p><strong>这个时间在分布式和高并发场景下，其实是很难评估的</strong>。很多时候，我们都是凭借经验大致估算这个延迟时间，例如延迟 1-5s，只能尽可能地降低不一致的概率。采用这种方案，也只是尽可能保证一致性而已，极端情况下，还是有可能发生不一致。</p><p>所以实际使用中，建议采用「先更新数据库，再删除缓存」的方案，同时要尽可能地保证「主从复制」不要有太大延迟，降低出问题的概率。</p><h2 id="可以做到强一致吗？"><a href="#可以做到强一致吗？" class="headerlink" title="可以做到强一致吗？"></a>可以做到强一致吗？</h2><p>这些方案还是不够完美，我就想让缓存和数据库「强一致」，到底能不能做到呢？</p><p>其实很难。要想做到强一致，最常见的方案是 2PC、3PC、Paxos、Raft 这类一致性协议，但它们的性能往往比较差，而且这些方案也比较复杂，还要考虑各种容错问题。相反，这时我们换个角度思考一下，我们引入缓存的目的是什么？没错，<strong>性能</strong>。一旦我们决定使用缓存，那必然要面临一致性问题。性能和一致性就像天平的两端，无法做到都满足要求。</p><p>而且，就拿我们前面讲到的方案来说，当操作数据库和缓存完成之前，只要有其它请求可以进来，都有可能查到「中间状态」的数据。所以如果非要追求强一致，那必须要求所有更新操作完成之前期间，不能有「任何请求」进来。虽然我们可以通过加「分布锁」的方式来实现，但我们要付出的代价，很可能会超过引入缓存带来的性能提升。</p><p>所以，既然决定使用缓存，就必须容忍「一致性」问题，我们只能尽可能地去降低问题出现的概率。同时我们也要知道，缓存都是有「失效时间」的，就算在这期间存在短期不一致，我们依旧有失效时间来兜底，这样也能达到最终一致。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、想要提高应用的性能，可以引入「缓存」来解决</p><p>2、引入缓存后，需要考虑缓存和数据库一致性问题，可选的方案有：「更新数据库 + 更新缓存」、「更新数据库 + 删除缓存」</p><p>3、更新数据库 + 更新缓存方案，在「并发」场景下无法保证缓存和数据一致性，且存在「缓存资源浪费」和「机器性能浪费」的情况发生</p><p>4、在更新数据库 + 删除缓存的方案中，「先删除缓存，再更新数据库」在「并发」场景下依旧有数据不一致问题，解决方案是「延迟双删」，但这个延迟时间很难评估，所以推荐用「先更新数据库，再删除缓存」的方案</p><p>5、在「先更新数据库，再删除缓存」方案下，为了保证两步都成功执行，需配合「消息队列」或「订阅变更日志」的方案来做，本质是通过「重试」的方式保证数据一致性</p><p>6、在「先更新数据库，再删除缓存」方案下，「读写分离 + 主从库延迟」也会导致缓存和数据库不一致，缓解此问题的方案是「延迟双删」，凭借经验发送「延迟消息」到队列中，延迟删除缓存，同时也要控制主从库延迟，尽可能降低不一致发生的概率</p><p>换句话说，最佳实践则是：</p><ul><li>性能和一致性不能同时满足，为了性能考虑，通常会采用「最终一致性」的方案</li><li>掌握缓存和数据库一致性问题，核心问题有 3 点：缓存利用率、并发、缓存 + 数据库一起成功问题</li><li>失败场景下要保证一致性，常见手段就是「重试」，同步重试会影响吞吐量，所以通常会采用异步重试的方案</li><li>订阅变更日志的思想，本质是把权威数据源（例如 MySQL）当做 leader 副本，让其它异质系统（例如 Redis / Elasticsearch）成为它的 follower 副本，通过同步变更日志的方式，保证 leader 和 follower 之间保持一致</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;到底是更新缓存还是删缓存？&lt;/li&gt;
&lt;li&gt;到底选择先更新数据库，再删除缓存，还是先删除缓存，再更新数据库？&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://JoyTsing.github.io/categories/Redis/"/>
    
    
      <category term="数据库" scheme="https://JoyTsing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="https://JoyTsing.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis分布式锁安全之问</title>
    <link href="https://joytsing.github.io/posts/39535/"/>
    <id>https://joytsing.github.io/posts/39535/</id>
    <published>2024-04-09T14:39:06.000Z</published>
    <updated>2024-04-10T15:22:04.557Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先进行一个问题的抛出：</p><ul><li>基于 Redis 如何实现一个分布式锁？</li><li>Redis 分布式锁真的安全吗？</li><li>Redis 的 Redlock 有什么问题？一定安全吗？</li><li>业界争论 Redlock，到底在争论什么？哪种观点是对的？</li><li>分布式锁到底用 Redis 还是 Zookeeper？</li><li>实现一个有「容错性」的分布式锁，都需要考虑哪些问题？</li></ul><h2 id="为什么需要分布式锁？"><a href="#为什么需要分布式锁？" class="headerlink" title="为什么需要分布式锁？"></a>为什么需要分布式锁？</h2><p>在开始讲分布式锁之前，有必要简单介绍一下，为什么需要分布式锁？</p><p>与分布式锁相对应的是「单机锁」，我们在写多线程程序时，避免同时操作一个共享变量产生数据问题，通常会使用一把锁来「互斥」，以保证共享变量的正确性，其使用范围是在「同一个进程」中。如果换做是多个进程，需要同时操作一个共享资源，如何互斥呢？</p><p>例如，现在的业务应用通常都是微服务架构，这也意味着一个应用会部署多个进程，那这多个进程如果需要修改 MySQL 中的同一行记录时，为了避免操作乱序导致数据错误，此时，我们就需要引入「分布式锁」来解决这个问题了。</p><p><img src="/posts/39535/640.webp" alt></p><p>想要实现分布式锁，必须借助一个外部系统，所有进程都去这个系统上申请「加锁」。而这个外部系统，必须要实现「互斥」的能力，即两个请求同时进来，只会给一个进程返回成功，另一个返回失败（或等待）。</p><p>这个外部系统，可以是 MySQL，也可以是 Redis 或 Zookeeper。但为了追求更好的性能，通常会选择使用 Redis 或 Zookeeper 来做。下面就以 Redis 为主线，由浅入深，带你深度剖析一下，分布式锁的各种「安全性」问题。</p><h2 id="分布式锁怎么实现？"><a href="#分布式锁怎么实现？" class="headerlink" title="分布式锁怎么实现？"></a>分布式锁怎么实现？</h2><p>从最简单的开始讲起。</p><p>想要实现分布式锁，必须要求 Redis 有「互斥」的能力，我们可以使用 SETNX 命令，这个命令表示<strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists，即如果 key 不存在，才会设置它的值，否则什么也不做。</p><p>两个客户端进程可以执行这个命令，达到互斥，就可以实现一个分布式锁。</p><p>客户端 1 申请加锁，加锁成功：</p><pre><code>127.0.0.1:6379&gt; SETNX lock 1(integer) 1     // 客户端1，加锁成功</code></pre><p>客户端 2 申请加锁，因为它后到达，加锁失败：</p><pre><code>127.0.0.1:6379&gt; SETNX lock 1(integer) 0     // 客户端2，加锁失败</code></pre><p>此时，加锁成功的客户端，就可以去操作「共享资源」，例如，修改 MySQL 的某一行数据，或者调用一个 API 请求。操作完成后，还要及时释放锁，给后来者让出操作共享资源的机会。如何释放锁呢？</p><p>也很简单，直接使用 DEL 命令删除这个 key 即可：</p><pre><code>127.0.0.1:6379&gt; DEL lock // 释放锁(integer) 1</code></pre><p>这个逻辑非常简单，整体的路程就是这样：</p><p><img src="/posts/39535/640-1712760520184-3.webp" alt></p><p>但是，它存在一个很大的问题，当客户端 1 拿到锁后，如果发生下面的场景，就会造成「死锁」：</p><ol><li>程序处理业务逻辑异常，没及时释放锁</li><li>进程挂了，没机会释放锁</li></ol><p>这时，这个客户端就会一直占用这个锁，而其它客户端就「永远」拿不到这把锁了。怎么解决这个问题呢？</p><h2 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h2><p>很容易想到的方案是，在申请锁时，给这把锁设置一个「租期」。</p><p>在 Redis 中实现时，就是给这个 key 设置一个「过期时间」。这里我们假设，操作共享资源的时间不会超过 10s，那么在加锁时，给这个 key 设置 10s 过期即可：</p><pre><code>127.0.0.1:6379&gt; SETNX lock 1    // 加锁(integer) 1127.0.0.1:6379&gt; EXPIRE lock 10  // 10s后自动过期(integer) 1</code></pre><p>这样一来，无论客户端是否异常，这个锁都可以在 10s 后被「自动释放」，其它客户端依旧可以拿到锁。但这样真的没问题吗？还是有问题。</p><p>现在的操作，加锁、设置过期是 2 条命令，有没有可能只执行了第一条，第二条却「来不及」执行的情况发生呢？例如：</p><blockquote><ol><li>SETNX 执行成功，执行 EXPIRE 时由于网络问题，执行失败</li><li>SETNX 执行成功，Redis 异常宕机，EXPIRE 没有机会执行</li><li>SETNX 执行成功，客户端异常崩溃，EXPIRE 也没有机会执行</li></ol></blockquote><p>总之，这两条命令不能保证是原子操作（一起成功），就有潜在的风险导致过期时间设置失败，依旧发生「死锁」问题。怎么办？</p><p>在 Redis 2.6.12 版本之前，我们需要想尽办法，保证 SETNX 和 EXPIRE 原子性执行，还要考虑各种异常情况如何处理。但在 Redis 2.6.12 之后，Redis 扩展了 SET 命令的参数，用这一条命令就可以了：</p><pre><code>// 一条命令保证原子性执行127.0.0.1:6379&gt; SET lock 1 EX 10 NXOK</code></pre><p>这样就解决了死锁问题，也比较简单。试想这样一种场景：</p><blockquote><ol><li>客户端 1 加锁成功，开始操作共享资源</li><li>客户端 1 操作共享资源的时间，「超过」了锁的过期时间，锁被「自动释放」</li><li>客户端 2 加锁成功，开始操作共享资源</li><li>客户端 1 操作共享资源完成，释放锁（但释放的是客户端 2 的锁）</li></ol></blockquote><p>看到了么，这里存在两个严重的问题：</p><ol><li><strong>锁过期</strong>：客户端 1 操作共享资源耗时太久，导致锁被自动释放，之后被客户端 2 持有</li><li><strong>释放别人的锁</strong>：客户端 1 操作共享资源完成后，却又释放了客户端 2 的锁</li></ol><p>导致这两个问题的原因是什么？</p><p><strong>第一个问题，可能是评估操作共享资源的时间不准确导致的。</strong></p><p>例如，操作共享资源的时间「最慢」可能需要 15s，而我们却只设置了 10s 过期，那这就存在锁提前过期的风险。过期时间太短，那增大冗余时间，例如设置过期时间为 20s，这样总可以了吧？这样确实可以「缓解」这个问题，降低出问题的概率，但依旧无法「彻底解决」问题。</p><p>为什么？</p><p>原因在于，客户端在拿到锁之后，在操作共享资源时，遇到的场景有可能是很复杂的，例如，程序内部发生异常、网络请求超时等等。既然是「预估」时间，也只能是大致计算，除非你能预料并覆盖到所有导致耗时变长的场景，但这其实很难。有什么更好的解决方案吗？</p><p><strong>第二个问题在于，一个客户端释放了其它客户端持有的锁。</strong></p><p>想一下，导致这个问题的关键点在哪？重点在于，每个客户端在释放锁时，都是「无脑」操作，并没有检查这把锁是否还「归自己持有」，所以就会发生释放别人锁的风险，这样的解锁流程，很不「严谨」！如何解决这个问题呢？</p><h2 id="锁被别人释放怎么办"><a href="#锁被别人释放怎么办" class="headerlink" title="锁被别人释放怎么办?"></a>锁被别人释放怎么办?</h2><p>解决办法是：客户端在加锁时，设置一个只有自己知道的「唯一标识」进去。例如，可以是自己的线程 ID，也可以是一个 UUID（随机且唯一），这里我们以 UUID 举例：</p><pre><code>// 锁的VALUE设置为UUID127.0.0.1:6379&gt; SET lock $uuid EX 20 NXOK</code></pre><blockquote><p>这里假设 20s 操作共享时间完全足够，先不考虑锁自动过期的问题。</p></blockquote><p>之后，在释放锁时，要先判断这把锁是否还归自己持有，伪代码可以这么写：</p><pre><code>// 锁是自己的，才释放if redis.get(&quot;lock&quot;) == $uuid:    redis.del(&quot;lock&quot;)</code></pre><p>这里释放锁使用的是 GET + DEL 两条命令，这时，又会遇到我们前面讲的原子性问题了。</p><blockquote><ol><li>客户端 1 执行 GET，判断锁是自己的</li><li>客户端 2 执行了 SET 命令，强制获取到锁（虽然发生概率比较低，但我们需要严谨地考虑锁的安全性模型）</li><li>客户端 1 执行 DEL，却释放了客户端 2 的锁</li></ol></blockquote><p>由此可见，这两个命令还是必须要原子执行才行。怎样原子执行呢？Lua 脚本。可以把这个逻辑，写成 Lua 脚本，让 Redis 来执行。</p><p>因为 Redis 处理每一个请求是「单线程」执行的，在执行一个 Lua 脚本时，其它请求必须等待，直到这个 Lua 脚本处理完成，这样一来，GET + DEL 之间就不会插入其它命令了。</p><p><img src="/posts/39535/640-1712760824267-6.webp" alt></p><p>安全释放锁的 Lua 脚本如下：</p><pre class="line-numbers language-lua"><code class="language-lua"><span class="token operator">//</span> 判断锁是自己的，才释放<span class="token keyword">if</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">then</span>    <span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"DEL"</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">else</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>好了，这样一路优化，整个的加锁、解锁的流程就更「严谨」了。基于 Redis 实现的分布式锁，一个严谨的的流程如下：</p><blockquote><ol><li>加锁：SET lock_key $unique_id EX $expire_time NX</li><li>操作共享资源</li><li>释放锁：Lua 脚本，先 GET 判断锁是否归属自己，再 DEL 释放锁</li></ol></blockquote><p><img src="/posts/39535/640-1712760824267-7.webp" alt></p><p>好，有了这个完整的锁模型，让我们重新回到前面提到的第一个问题。锁过期时间不好评估怎么办？</p><h2 id="锁过期时间不好评估怎么办？"><a href="#锁过期时间不好评估怎么办？" class="headerlink" title="锁过期时间不好评估怎么办？"></a>锁过期时间不好评估怎么办？</h2><p>前面我们提到，锁的过期时间如果评估不好，这个锁就会有「提前」过期的风险。当时给的妥协方案是，尽量「冗余」过期时间，降低锁提前过期的概率。</p><p>这个方案其实也不能完美解决问题，那怎么办呢？</p><p>是否可以设计这样的方案：<strong>加锁时，先设置一个过期时间，然后我们开启一个「守护线程」，定时去检测这个锁的失效时间，如果锁快要过期了，操作共享资源还未完成，那么就自动对锁进行「续期」，重新设置过期时间。</strong></p><p><img src="/posts/39535/640-1712761088227-12.webp" alt></p><p>基于 Redis 的实现分布式锁，前面遇到的问题，以及对应的解决方案：</p><ul><li><strong>死锁</strong>：设置过期时间</li><li><strong>过期时间评估不好，锁提前过期</strong>：守护线程，自动续期</li><li><strong>锁被别人释放</strong>：锁写入唯一标识，释放锁先检查标识，再释放</li></ul><p>还有哪些问题场景，会危害 Redis 锁的安全性呢？</p><p>之前分析的场景都是，锁在「单个」Redis 实例中可能产生的问题，并没有涉及到 Redis 的部署架构细节。而在使用 Redis 时，一般会采用<strong>主从集群 + 哨兵</strong>的模式部署，这样做的好处在于，当主库异常宕机时，哨兵可以实现「故障自动切换」，把从库提升为主库，继续提供服务，以此保证可用性。</p><p><strong>那当「主从发生切换」时，这个分布锁会依旧安全吗？</strong></p><p>试想这样的场景：</p><ol><li>客户端 1 在主库上执行 SET 命令，加锁成功</li><li>此时，主库异常宕机，SET 命令还未同步到从库上（主从复制是异步的）</li><li>从库被哨兵提升为新主库，这个锁在新的主库上，丢失了！</li></ol><p><img src="/posts/39535/640-1712761172250-15.webp" alt></p><p>可见，当引入 Redis 副本后，分布锁还是可能会受到影响。怎么解决这个问题？</p><p>为此，Redis 的作者提出一种解决方案，就是我们经常听到的 <strong>Redlock（红锁）</strong>。</p><h2 id="Redlock-真的安全吗？"><a href="#Redlock-真的安全吗？" class="headerlink" title="Redlock 真的安全吗？"></a>Redlock 真的安全吗？</h2><p>Redlock 的方案基于 2 个前提：</p><ol><li>不再需要部署<strong>从库</strong>和<strong>哨兵</strong>实例，只部署<strong>主库</strong></li><li>但主库要部署多个，官方推荐至少 5 个实例</li></ol><p>也就是说，想用使用 Redlock，你至少要部署 5 个 Redis 实例，而且都是主库，它们之间没有任何关系，都是一个个孤立的实例。</p><blockquote><p><strong>注意：不是部署 Redis Cluster，就是部署 5 个简单的 Redis 实例。</strong></p></blockquote><p><img src="/posts/39535/640-1712761502480-18.webp" alt></p><p>Redlock 具体如何使用呢？整体的流程是这样的，一共分为 5 步：</p><ol><li>客户端先获取「当前时间戳T1」</li><li>客户端依次向这 5 个 Redis 实例发起加锁请求（用前面讲到的 SET 命令），且每个请求会设置超时时间（毫秒级，要远小于锁的有效时间），如果某一个实例加锁失败（包括网络超时、锁被其它人持有等各种异常情况），就立即向下一个 Redis 实例申请加锁</li><li>如果客户端从 &gt;=3 个（大多数）以上 Redis 实例加锁成功，则再次获取「当前时间戳T2」，如果 T2 - T1 &lt; 锁的过期时间，此时，认为客户端加锁成功，否则认为加锁失败</li><li>加锁成功，去操作共享资源（例如修改 MySQL 某一行，或发起一个 API 请求）</li><li>加锁失败，向「全部节点」发起释放锁请求（前面讲到的 Lua 脚本释放锁）</li></ol><p>其中有 4 个重点：</p><blockquote><ol><li>客户端在多个 Redis 实例上申请加锁</li><li>必须保证大多数节点加锁成功</li><li>大多数节点加锁的总耗时，要小于锁设置的过期时间</li><li>释放锁，要向全部节点发起释放锁请求</li></ol></blockquote><p>明白了 Redlock 的流程，我们来看 Redlock 为什么要这么做。</p><p><strong>1) 为什么要在多个实例上加锁？</strong></p><p>本质上是为了「容错」，部分实例异常宕机，剩余的实例加锁成功，整个锁服务依旧可用。</p><p><strong>2) 为什么大多数加锁成功，才算成功？</strong></p><p>多个 Redis 实例一起来用，其实就组成了一个「分布式系统」。</p><p>在分布式系统中，总会出现「异常节点」，所以，在谈论分布式系统问题时，需要考虑异常节点达到多少个，也依旧不会影响整个系统的「正确性」。</p><p>这是一个分布式系统「容错」问题，这个问题的结论是：<strong>如果只存在「故障」节点，只要大多数节点正常，那么整个系统依旧是可以提供正确服务的。</strong></p><blockquote><p>这个问题的模型，就是我们经常听到的「拜占庭将军」问题，感兴趣可以去看算法的推演过程。</p></blockquote><p><strong>3) 为什么步骤 3 加锁成功后，还要计算加锁的累计耗时？</strong></p><p>因为操作的是多个节点，所以耗时肯定会比操作单个实例耗时更久，而且，因为是网络请求，网络情况是复杂的，有可能存在<strong>延迟、丢包、超时</strong>等情况发生，网络请求越多，异常发生的概率就越大。</p><p>所以，即使大多数节点加锁成功，但如果加锁的累计耗时已经「超过」了锁的过期时间，那此时有些实例上的锁可能已经失效了，这个锁就没有意义了。</p><p><strong>4) 为什么释放锁，要操作所有节点？</strong></p><p>在某一个 Redis 节点加锁时，可能因为「网络原因」导致加锁失败。</p><p>例如，客户端在一个 Redis 实例上加锁成功，但在读取响应结果时，网络问题导致<strong>读取失败</strong>，那这把锁其实已经在 Redis 上加锁成功了。</p><p>所以，释放锁时，不管之前有没有加锁成功，需要释放「所有节点」的锁，以保证清理节点上「残留」的锁。</p><p>好了，明白了 Redlock 的流程和相关问题，看似 Redlock 确实解决了 Redis 节点异常宕机锁失效的问题，保证了锁的「安全性」。</p><p>但事实真的如此吗？</p><h2 id="分布式专家-Martin-对于-Relock-的质疑"><a href="#分布式专家-Martin-对于-Relock-的质疑" class="headerlink" title="分布式专家 Martin 对于 Relock 的质疑"></a>分布式专家 Martin 对于 Relock 的质疑</h2><p>在他的文章中，主要阐述了 4 个论点：</p><p><strong>1) 分布式锁的目的是什么？</strong></p><p>Martin 表示，你必须先清楚你在使用分布式锁的目的是什么？他认为有两个目的。</p><p><strong>第一，效率。</strong></p><p>使用分布式锁的互斥能力，是避免不必要地做同样的两次工作（例如一些昂贵的计算任务）。如果锁失效，并不会带来「恶性」的后果，例如发了 2 次邮件等，无伤大雅。</p><p><strong>第二，正确性。</strong></p><p>使用锁用来防止并发进程互相干扰。如果锁失效，会造成多个进程同时操作同一条数据，产生的后果是<strong>数据严重错误、永久性不一致、数据丢失</strong>等恶性问题，就像给患者服用了重复剂量的药物，后果很严重。</p><p>他认为，如果你是为了前者——效率，那么使用单机版 Redis 就可以了，即使偶尔发生锁失效（宕机、主从切换），都不会产生严重的后果。而使用 Redlock 太重了，没必要。</p><p><strong>而如果是为了正确性，Martin 认为 Redlock 根本达不到安全性的要求，也依旧存在锁失效的问题！</strong></p><p><strong>2) 锁在分布式系统中会遇到的问题</strong></p><p>Martin 表示，一个分布式系统，更像一个复杂的「野兽」，存在着你想不到的各种异常情况。</p><p>这些异常场景主要包括三大块，这也是分布式系统会遇到的三座大山：<strong>NPC</strong>。</p><ul><li>N：Network Delay，网络延迟</li><li>P：Process Pause，进程暂停（GC）</li><li>C：Clock Drift，时钟漂移</li></ul><p>Martin 用一个进程暂停（GC）的例子，指出了 Redlock 安全性问题：</p><blockquote><ol><li>客户端 1 请求锁定节点 A、B、C、D、E</li><li>客户端 1 的拿到锁后，进入 GC（时间比较久）</li><li>所有 Redis 节点上的锁都过期了</li><li>客户端 2 获取到了 A、B、C、D、E 上的锁</li><li>客户端 1 GC 结束，认为成功获取锁</li><li>客户端 2 也认为获取到了锁，发生「冲突」</li></ol></blockquote><p><img src="/posts/39535/640-1712761809896-21.webp" alt="图片"></p><p>Martin 认为，GC 可能发生在程序的任意时刻，而且执行时间是不可控的。</p><blockquote><p>注：当然，即使是使用没有 GC 的编程语言，在发生网络延迟、时钟漂移时，也都有可能导致 Redlock 出现问题，这里 Martin 只是拿 GC 举例。</p></blockquote><p><strong>3) 假设时钟正确的是不合理的</strong></p><p>又或者，当多个 Redis 节点「时钟」发生问题时，也会导致 Redlock <strong>锁失效</strong>。</p><blockquote><ol><li>客户端 1 获取节点 A、B、C 上的锁，但由于网络问题，无法访问 D 和 E</li><li>节点 C 上的时钟「向前跳跃」，导致锁到期</li><li>客户端 2 获取节点 C、D、E 上的锁，由于网络问题，无法访问 A 和 B</li><li>客户端 1 和 2 现在都相信它们持有了锁（冲突）</li></ol></blockquote><p>Martin 觉得，Redlock 必须「强依赖」多个节点的时钟是保持同步的，一旦有节点时钟发生错误，那这个算法模型就失效了。</p><blockquote><p>即使 C 不是时钟跳跃，而是「崩溃后立即重启」，也会发生类似的问题。</p></blockquote><p>Martin 继续阐述，机器的时钟发生错误，是很有可能发生的：</p><ul><li>系统管理员「手动修改」了机器时钟</li><li>机器时钟在同步 NTP 时间时，发生了大的「跳跃」</li></ul><p>总之，Martin 认为，Redlock 的算法是建立在「同步模型」基础上的，有大量资料研究表明，同步模型的假设，在分布式系统中是有问题的。</p><p>在混乱的分布式系统的中，你不能假设系统时钟就是对的，所以，你必须非常小心你的假设。</p><p><strong>4) 提出 fecing token 的方案，保证正确性</strong></p><p>相对应的，Martin 提出一种被叫作 fecing token 的方案，保证分布式锁的正确性。</p><p>这个模型流程如下：</p><blockquote><ol><li>客户端在获取锁时，锁服务可以提供一个「递增」的 token</li><li>客户端拿着这个 token 去操作共享资源</li><li>共享资源可以根据 token 拒绝「后来者」的请求</li></ol></blockquote><p><img src="/posts/39535/640-1712761809897-22.webp" alt="图片"></p><p>这样一来，无论 NPC 哪种异常情况发生，都可以保证分布式锁的安全性，因为它是建立在「异步模型」上的。</p><p>而 Redlock 无法提供类似 fecing token 的方案，所以它无法保证安全性。</p><p>他还表示，<strong>一个好的分布式锁，无论 NPC 怎么发生，可以不在规定时间内给出结果，但并不会给出一个错误的结果。也就是只会影响到锁的「性能」（或称之为活性），而不会影响它的「正确性」。</strong></p><p>Martin 的结论：</p><p><strong>1、Redlock 不伦不类</strong>：它对于效率来讲，Redlock 比较重，没必要这么做，而对于正确性来说，Redlock 是不够安全的。</p><p><strong>2、时钟假设不合理</strong>：该算法对系统时钟做出了危险的假设（假设多个节点机器时钟都是一致的），如果不满足这些假设，锁就会失效。</p><p><strong>3、无法保证正确性</strong>：Redlock 不能提供类似 fencing token 的方案，所以解决不了正确性的问题。为了正确性，请使用有「共识系统」的软件，例如 Zookeeper。</p><p>好了，以上就是 Martin 反对使用 Redlock 的观点，看起来有理有据。</p><p>下面我们来看 Redis 作者 Antirez 是如何反驳的。</p><h2 id="Redis-作者-Antirez-的反驳"><a href="#Redis-作者-Antirez-的反驳" class="headerlink" title="Redis 作者 Antirez 的反驳"></a>Redis 作者 Antirez 的反驳</h2><p>在 Redis 作者的文章中，重点有 3 个：</p><p><strong>1) 解释时钟问题</strong></p><p>首先，Redis 作者一眼就看穿了对方提出的最为核心的问题：<strong>时钟问题</strong>。</p><p>Redis 作者表示，Redlock 并不需要完全一致的时钟，只需要大体一致就可以了，允许有「误差」。</p><p>例如要计时 5s，但实际可能记了 4.5s，之后又记了 5.5s，有一定误差，但只要不超过「误差范围」锁失效时间即可，这种对于时钟的精度要求并不是很高，而且这也符合现实环境。</p><p>对于对方提到的「时钟修改」问题，Redis 作者反驳到：</p><ol><li><strong>手动修改时钟</strong>：不要这么做就好了，否则你直接修改 Raft 日志，那 Raft 也会无法工作…</li><li><strong>时钟跳跃</strong>：通过「恰当的运维」，保证机器时钟不会大幅度跳跃（每次通过微小的调整来完成），实际上这是可以做到的</li></ol><blockquote><p>为什么 Redis 作者优先解释时钟问题？因为在后面的反驳过程中，需要依赖这个基础做进一步解释。</p></blockquote><p><strong>2) 解释网络延迟、GC 问题</strong></p><p>之后，Redis 作者对于对方提出的，网络延迟、进程 GC 可能导致 Redlock 失效的问题，也做了反驳：</p><p>我们重新回顾一下，Martin 提出的问题假设：</p><ol><li>客户端 1 请求锁定节点 A、B、C、D、E</li><li>客户端 1 的拿到锁后，进入 GC</li><li>所有 Redis 节点上的锁都过期了</li><li>客户端 2 获取节点 A、B、C、D、E 上的锁</li><li>客户端 1 GC 结束，认为成功获取锁</li><li>客户端 2 也认为获取到锁，发生「冲突」</li></ol><p><img src="/posts/39535/640-1712761809896-21.webp" alt="图片"></p><p>Redis 作者反驳到，这个假设其实是有问题的，Redlock 是可以保证锁安全的。这是怎么回事呢？</p><p>还记得前面介绍 Redlock 流程的那 5 步吗？</p><ol><li>客户端先获取「当前时间戳T1」</li><li>客户端依次向这 5 个 Redis 实例发起加锁请求（用前面讲到的 SET 命令），且每个请求会设置超时时间（毫秒级，要远小于锁的有效时间），如果某一个实例加锁失败（包括网络超时、锁被其它人持有等各种异常情况），就立即向下一个 Redis 实例申请加锁</li><li>如果客户端从 3 个（大多数）以上 Redis 实例加锁成功，则再次获取「当前时间戳T2」，如果 T2 - T1 &lt; 锁的过期时间，此时，认为客户端加锁成功，否则认为加锁失败</li><li>加锁成功，去操作共享资源（例如修改 MySQL 某一行，或发起一个 API 请求）</li><li>加锁失败，向「全部节点」发起释放锁请求（前面讲到的 Lua 脚本释放锁）</li></ol><p><strong>注意，重点是 1-3，在步骤 3，加锁成功后为什么要重新获取「当前时间戳T2」？还用 T2 - T1 的时间，与锁的过期时间做比较？</strong></p><p>Redis 作者强调：如果在 1-3 发生了网络延迟、进程 GC 等耗时长的异常情况，那在第 3 步 T2 - T1，是可以检测出来的，如果超出了锁设置的过期时间，那这时就认为加锁会失败，之后释放所有节点的锁就好了！</p><p>Redis 作者继续论述，如果对方认为，发生网络延迟、进程 GC 是在步骤 3 之后，也就是客户端确认拿到了锁，去操作共享资源的途中发生了问题，导致锁失效，那这<strong>不止是 Redlock 的问题，任何其它锁服务例如 Zookeeper，都有类似的问题，这不在讨论范畴内。</strong></p><p>举个例子解释一下这个问题：</p><ol><li>客户端通过 Redlock 成功获取到锁（通过了大多数节点加锁成功、加锁耗时检查逻辑）</li><li>客户端开始操作共享资源，此时发生网络延迟、进程 GC 等耗时很长的情况</li><li>此时，锁过期自动释放</li><li>客户端开始操作 MySQL（此时的锁可能会被别人拿到，锁失效）</li></ol><p>Redis 作者这里的结论就是：</p><ul><li>客户端在拿到锁之前，无论经历什么耗时长问题，Redlock 都能够在第 3 步检测出来</li><li>客户端在拿到锁之后，发生 NPC，那 Redlock、Zookeeper 都无能为力</li></ul><p>所以，Redis 作者认为 Redlock 在保证时钟正确的基础上，是可以保证正确性的。</p><p><strong>3) 质疑 fencing token 机制</strong></p><p>Redis 作者对于对方提出的 fecing token 机制，也提出了质疑，主要分为 2 个问题:</p><p><strong>第一</strong>，这个方案必须要求要操作的「共享资源服务器」有拒绝「旧 token」的能力。</p><p>例如，要操作 MySQL，从锁服务拿到一个递增数字的 token，然后客户端要带着这个 token 去改 MySQL 的某一行，这就需要利用 MySQL 的「事物隔离性」来做。</p><pre><code>// 两个客户端必须利用事物和隔离性达到目的// 注意 token 的判断条件UPDATE table T SET val = $new_val WHERE id = $id AND current_token &lt; $token</code></pre><p>但如果操作的不是 MySQL 呢？例如向磁盘上写一个文件，或发起一个 HTTP 请求，那这个方案就无能为力了，这对要操作的资源服务器，提出了更高的要求。</p><p>也就是说，大部分要操作的资源服务器，都是没有这种互斥能力的。</p><p><strong>再者，既然资源服务器都有了「互斥」能力，那还要分布式锁干什么？</strong></p><p>所以，Redis 作者认为这个方案是站不住脚的。</p><p><strong>第二</strong>，退一步讲，即使 Redlock 没有提供 fecing token 的能力，但 Redlock 已经提供了随机值（就是前面讲的 UUID），利用这个随机值，也可以达到与 fecing token 同样的效果。</p><p>如何做呢？</p><blockquote><p>Redis 作者只是提到了可以完成 fecing token 类似的功能，但却没有展开相关细节，大概流程应该如下</p></blockquote><ol><li>客户端使用 Redlock 拿到锁</li><li>客户端在操作共享资源之前，先把这个锁的 VALUE，在要操作的共享资源上做标记</li><li>客户端处理业务逻辑，最后，在修改共享资源时，判断这个标记是否与之前一样，一样才修改（类似 CAS 的思路）</li></ol><p>还是以 MySQL 为例，举个例子就是这样的：</p><ol><li>客户端使用 Redlock 拿到锁</li><li>客户端要修改 MySQL 表中的某一行数据之前，先把锁的 VALUE 更新到这一行的某个字段中（这里假设为 current_token 字段)</li><li>客户端处理业务逻辑</li><li>客户端修改 MySQL 的这一行数据，把 VALUE 当做 WHERE 条件，再修改</li></ol><pre><code>UPDATE table T SET val = $new_val WHERE id = $id AND current_token = $redlock_value</code></pre><p>可见，这种方案依赖 MySQL 的事物机制，也达到对方提到的 fecing token 一样的效果。</p><p>但这里还有个小问题，是网友参与问题讨论时提出的：<strong>两个客户端通过这种方案，先「标记」再「检查+修改」共享资源，那这两个客户端的操作顺序无法保证啊？</strong></p><p>而用 Martin 提到的 fecing token，因为这个 token 是单调递增的数字，资源服务器可以拒绝小的 token 请求，保证了操作的「顺序性」！</p><p>Redis 作者对这问题做了不同的解释，他解释道：<strong>分布式锁的本质，是为了「互斥」，只要能保证两个客户端在并发时，一个成功，一个失败就好了，不需要关心「顺序性」。</strong></p><blockquote><p>前面 Martin 的质疑中，一直很关心这个顺序性问题，但 Redis 的作者的看法却不同。</p></blockquote><p>综上，Redis 作者的结论：</p><p><strong>1、作者同意对方关于「时钟跳跃」对 Redlock 的影响，但认为时钟跳跃是可以避免的，取决于基础设施和运维。</strong></p><p><strong>2、Redlock 在设计时，充分考虑了 NPC 问题，在 Redlock 步骤 3 之前出现 NPC，可以保证锁的正确性，但在步骤 3 之后发生 NPC，不止是 Redlock 有问题，其它分布式锁服务同样也有问题，所以不在讨论范畴内。</strong></p><h2 id="基于-Zookeeper-的锁安全吗？"><a href="#基于-Zookeeper-的锁安全吗？" class="headerlink" title="基于 Zookeeper 的锁安全吗？"></a>基于 Zookeeper 的锁安全吗？</h2><p>没用过，但是查询后知道，基于它实现的分布式锁是这样的：</p><ol><li>客户端 1 和 2 都尝试创建「临时节点」，例如 /lock</li><li>假设客户端 1 先到达，则加锁成功，客户端 2 加锁失败</li><li>客户端 1 操作共享资源</li><li>客户端 1 删除 /lock 节点，释放锁</li></ol><p>Zookeeper 不像 Redis 那样，需要考虑锁的过期时间问题，它是采用了「临时节点」，保证客户端 1 拿到锁后，只要连接不断，就可以一直持有锁。而且，如果客户端 1 异常崩溃了，那么这个临时节点会自动删除，保证了锁一定会被释放。</p><p><strong>不错，没有锁过期的烦恼，还能在异常时自动释放锁，是不是觉得很完美？</strong>其实不然。思考一下，客户端 1 创建临时节点后，Zookeeper 是如何保证让这个客户端一直持有锁呢？</p><p>原因就在于，<strong>客户端 1 此时会与 Zookeeper 服务器维护一个 Session，这个 Session 会依赖客户端「定时心跳」来维持连接。</strong>如果 Zookeeper 长时间收不到客户端的心跳，就认为这个 Session 过期了，也会把这个临时节点删除。</p><p><img src="/posts/39535/640-1712762020030-27.webp" alt="图片"></p><p>同样地，基于此问题，我们也讨论一下 GC 问题对 Zookeeper 的锁有何影响：</p><blockquote><ol><li>客户端 1 创建临时节点 /lock 成功，拿到了锁</li><li>客户端 1 发生长时间 GC</li><li>客户端 1 无法给 Zookeeper 发送心跳，Zookeeper 把临时节点「删除」</li><li>客户端 2 创建临时节点 /lock 成功，拿到了锁</li><li>客户端 1 GC 结束，它仍然认为自己持有锁（冲突）</li></ol></blockquote><p>可见，即使是使用 Zookeeper，也无法保证进程 GC、网络延迟异常场景下的安全性。</p><p><strong>这就是前面 Redis 作者在反驳的文章中提到的：如果客户端已经拿到了锁，但客户端与锁服务器发生「失联」（例如 GC），那不止 Redlock 有问题，其它锁服务都有类似的问题，Zookeeper 也是一样！</strong></p><p>所以，这里我们就能得出结论了：<strong>一个分布式锁，在极端情况下，不一定是安全的。</strong>如果业务数据非常敏感，在使用分布式锁时，一定要注意这个问题，不能假设分布式锁 100% 安全。</p><p>Zookeeper 的优点：</p><ol><li>不需要考虑锁的过期时间</li><li>watch 机制，加锁失败，可以 watch 等待锁释放，实现乐观锁</li></ol><p>但它的劣势是：</p><ol><li>性能不如 Redis</li><li>部署和运维成本高</li><li>客户端与 Zookeeper 的长时间失联，锁被释放问题</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>1) 到底要不要用 Redlock？</strong></p><p>前面也分析了，Redlock 只有建立在「时钟正确」的前提下，才能正常工作，如果你可以保证这个前提，那么可以拿来使用。但保证时钟正确并不是想的那么简单就能做到的。</p><p>在不使用Redlock的时候可以考虑使用主从+ 哨兵的模式 实现分布式锁。</p><p><strong>2) 如何正确使用分布式锁？</strong></p><p>在分析 Martin 观点时，它提到了 fecing token 的方案，虽然这种方案有很大的局限性，但对于保证「正确性」的场景，是一个非常好的思路。所以，我们可以把这两者结合起来用：</p><p><strong>1、使用分布式锁，在上层完成「互斥」目的，虽然极端情况下锁会失效，但它可以最大程度把并发请求阻挡在最上层，减轻操作资源层的压力。</strong></p><p><strong>2、但对于要求数据绝对正确的业务，在资源层一定要做好「兜底」，设计思路可以借鉴 fecing token 的方案来做。</strong></p><p>两种思路结合对于大多数业务场景，已经可以满足要求了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;首先进行一个问题的抛出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于 Redis 如何实现一个分布式锁？&lt;/li&gt;
&lt;li&gt;Redis 分布式锁真的安全
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://JoyTsing.github.io/categories/Redis/"/>
    
    
      <category term="数据库" scheme="https://JoyTsing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="https://JoyTsing.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Linux网络学习笔记(七)</title>
    <link href="https://joytsing.github.io/posts/48821/"/>
    <id>https://joytsing.github.io/posts/48821/</id>
    <published>2024-04-09T09:04:07.000Z</published>
    <updated>2024-04-10T08:58:09.896Z</updated>
    
    <content type="html"><![CDATA[<p>在应用程序里，我们使用多少内存都是自己能掌握和控制的，但是纵观Linux整台服务器，除了应用程序以外，内核也会申请和管理大量的内存。</p><h3 id="一、相关实际问题"><a href="#一、相关实际问题" class="headerlink" title="一、相关实际问题"></a>一、相关实际问题</h3><ol><li>内核是如何管理内存的</li><li>如何查看内核使用的内存信息</li><li>服务器上一条ESTABLISH状态的空连接需要消耗多少内存</li><li>机器上出现了3万多个TIME_WAIT，内存开销会不会很大</li></ol><h3 id="二、Linux内核如何管理内存"><a href="#二、Linux内核如何管理内存" class="headerlink" title="二、Linux内核如何管理内存"></a>二、Linux内核如何管理内存</h3><p>内核针对自己的应用场景，使用了一种叫做SLAB/SLUB的内存管理机制。这种管理机制通过四个步骤把物理内存条管理起来，供内核申请和分配内核对象。</p><h4 id="1）node划分"><a href="#1）node划分" class="headerlink" title="1）node划分"></a>1）node划分</h4><p>早期的计算机中，内存控制器还没有整合到CPU，所有的内存访问都需要经过北桥芯片组来完成，即内存控制器集成在北桥中。<strong>CPU访存需要通过前端总线连接到北桥芯片，然后北桥芯片连接到内存，这样的架构被称为UMA（一致性内存访问）</strong>。总线模型保证了所有的内存访问都是一致的（即每个处理器共享相同的内存地址空间）。<strong>在UMA架构下，CPU和内存之间的通信全部都要通过前端总线，而提高性能的方式就是不断提高CPU、前端总线和内存的工作频率。</strong></p><p>而随着物理条件的限制，CPU朝着高频率的方向发展遇到了天花板，性能的提升开始供提高主频转向增加CPU数量（多核、多CPU）。<strong>而越来越多的 CPU 对前端总线的争用，使前端总线成为了瓶颈。为了消除 UMA 架构的瓶颈，NUMA（非一致性内存访问）架构诞生了。</strong>在NUMA架构下，<strong>每个CPU会有自己的独立的内存控制器，并且独立连接到一部分内存（直连的这部分内存称为本地内存），组成一个node，不同node之间通过QPI（Quick Path Interconnect）进行通信访问远程内存。</strong>如下图所示：</p><p><img src="/posts/48821/d4611b458796469c8caacfa92107d0b1.png" alt></p><p>在 NUMA 架构下，内存的访问出现了本地和远程的区别：访问远程内存的延时会明显高于访问本地内存。</p><blockquote><p>系统 boot 的时候，硬件会把 NUMA 信息发送给 os，如果系统支持 NUMA ，会发生以下几件事：</p><ul><li>获取 NUMA 配置信息</li><li>将 processors（不是 cores） 分成很多 nodes，一般是一个 processor 一个 node。</li><li>将 processor 附近的 memory 分配给它。</li><li>计算node 间通信的cost（距离）。</li></ul></blockquote><p>Linux 识别到 NUMA 架构后，每个进程、线程都会继承一个 numa policy，定义了可以使用那些CPU（甚至是那些 core），哪些内存可以使用，以及 policy 的强制程度，即是优先还是强制性只允许。<strong>每个 thread 被分配到了一个”优先” 的 node 上面运行</strong>，thread 可以在其他地方运行（如果 policy 允许的话），但是 os 会尝试让他在优先地 node 上面去运行。默认的内存分配方案是：<strong>优先从本地分配内存。如果本地内存不足，优先淘汰本地内存中无用的内存。使内存页尽可能地和调用线程处在同一个 node。</strong></p><blockquote><p>只是优先从本地分配内存，进程同样可以访问到其他内存条。因为在计算机系统中，物理内存地址是由内存管理单元（Memory Management Unit，MMU）管理的，它会把CPU发出的地址请求转换为实际的物理内存地址。即使系统中有多个内存条（也就是说，有多个物理内存块），MMU也会把它们看作是一个连续的地址空间进行管理。</p><p>当系统启动时，BIOS或者UEFI会检测所有的硬件设备，包括内存条。每个内存条的大小和位置信息会被记录在一个叫做内存映射（Memory Map）的数据结构中。这个内存映射会被传递给操作系统。</p><p>在操作系统启动时，它会读取这个内存映射，然后建立起自己的物理内存管理数据结构，如页帧数组。操作系统会把每个物理内存页的地址和状态（比如是否被使用，被哪个进程使用）记录在struct page的一个实例中。页帧数组中的每个元素对应物理内存中的一个页，页帧数组的索引直接映射到物理内存地址。</p><p>在多个内存条的情况下，页帧数组会涵盖所有的内存条。即使内存条在物理上是分离的，但在页帧数组中它们看起来是连续的。当一个物理页面被分配给一个进程时，操作系统会在页表中创建一个页表项，将虚拟地址映射到这个物理页面的地址。</p></blockquote><p>这种默认的分配策略一般情况下可能没有问题，但是对于一些需要分配大量内存的应用上可能会出现性能问题。如使用MySQL时，假如每个node有32G的内存，而MySQL配置了48G 的 innodb buffer pool，那么可能会出现尽管系统还有很多空余的内容，但是很多内存都被 swap 出去了。这就是因为默认的内存分配方案是优先从本地分配，所以当node0内存快被占满时，尽管node1还有很多内存，但是node0里面的内存还是会被swap出去。</p><blockquote><p>以上是硬件层面上的NUMA（hardware view），而作为软件层面的Linux，则对NUMA的概念进行了抽象。即便硬件上是一整块连续内存的UMA，Linux也可将其划分为若干的node（所有node其实是个软件上的概念）。同样，即便硬件上是物理内存不连续的NUMA，Linux也可将其视作UMA（software view）。</p><p>所以，在<a href="https://so.csdn.net/so/search?q=Linux系统&spm=1001.2101.3001.7020">Linux系统</a>中，你可以基于一个UMA的平台测试NUMA上的应用特性。从另一个角度，UMA就是只有一个node的特殊NUMA，所以两者可以统一用NUMA模型表示。</p></blockquote><h4 id="2）zone划分"><a href="#2）zone划分" class="headerlink" title="2）zone划分"></a>2）zone划分</h4><p>NUMA模型中，<strong>物理内存</strong>被划分为几个节点（node），一个node对应一个内存簇bank，即每个内存簇认为是一个节点。</p><p>首先，内存被划分为结点，每个节点关联到系统中的一个处理器。接着各个节点又被划分为内存管理区域，一个管理区域通过struct zone_struct描述，其被定义为zone_t，用以表示内存的某个范围。主要分为以下几种类型的内存管理区域：</p><ol><li>ZONE_DMA：地址段最低的一块内存区域（物理内存起始的16M），供IO设备DMA访问。<ul><li>一些使用 DMA 的外设并没有像 CPU 那样的 32 位地址总线，比如只有 16 位总线，就只能访问 64 KB 的空间，24 位总线就只能访问 16 MB 的空间，如果给 DMA 分配的内存地址超出了这个范围，设备就没法（寻址）访问了。也应该成为ZONE_DMA24</li></ul></li><li>ZONE_DMA32：到了 64 位系统，外设的寻址能力增强，因此又加入了一个 ZONE_DMA32，空间大小为 16MB 到 4GB</li><li>ZONE_NORMAL：可<strong>直接映射</strong>到内核的普通内存域（16M-896M），在X86-64架构下，DMA和DMA32之外的内存全部在NORMAL的zone里管理</li><li>ZONE_HIGHMEM：高端内存，内核不能直接使用（896M-4G），<strong>动态映射</strong>到内核空间3G+896M-4G的位置。即要访问的物理地址空间大于虚拟地址空间，不能直接建立映射的场景。适用于32位CPU系统，64位的CPU系统虚拟地址空间足够大，直接映射即可，所以都是NORMAL。</li></ol><p><img src="/posts/48821/969d18e411f3417abe1318c9b2349f45.png" alt></p><p>每个zone下都包含了许许多多个Page（页面），在Linux下一个页面的大小一般是4KB（处理器架构决定的，操作系统编译的时候固定下来）。</p><p>可以使用zoneinfo命令查看机器上zone的划分，也可以看到每个zone下所管理的页面有多少。</p><h4 id="3）基于伙伴系统管理空闲页面"><a href="#3）基于伙伴系统管理空闲页面" class="headerlink" title="3）基于伙伴系统管理空闲页面"></a>3）基于伙伴系统管理空闲页面</h4><blockquote><p>伙伴系统中的伙伴指的是两个内存块、大小相同、地址连续，同属于一个大块区域</p></blockquote><p>每个zone下面都有很多的页面，Linux使用伙伴系统对这些页面进行高效的管理。在内核中，表示zone的数据结构是struct zone。其下面的一个数组free_area管理了绝大部分可用的空闲页面。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> MAX_ORDER 11</span><span class="token keyword">struct</span> zone<span class="token punctuation">{</span>    free_area free_area<span class="token punctuation">[</span>MAX_ORDER<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>free_area是一个包含11个元素的数组。每一个元素分别代表不同大小（4KB、8KB、16KB、32KB…）的空闲可分配的连续内存链表。</strong></p><p>即每一个元素都代表一种大小的内存块，数组的索引表示了内存块包含的页框数量。例如，free_area[0]中存放的是单独的空闲页框（4KB），free_area[1]中存放的是包含两个页框的空闲内存块（8KB），等等。这种方式可以方便地查找和分配满足特定大小需求的内存块。</p><p><img src="/posts/48821/a74c3cf0ab4d4c61b2c5db5a79870151.png" alt></p><p>每个free_area元素都有一个或多个链表：</p><ol><li>MIGRATE_UNMOVABLE：表示不可移动的pages，例如内核数据结构的pages。</li><li>MIGRATE_RECLAIMABLE：表示可回收的pages，例如系统中的缓存，当内存紧张时可以回收其内存。</li><li>MIGRATE_MOVABLE：表示可移动的pages，例如用户进程的pages。当需要大块连续的内存空间，或者进行内存碎片整理时，可以移动这类page。</li><li>MIGRATE_PCPTYPES：表示特殊用途的pages，一般用于不可移动和可回收page的临时备份。</li><li>MIGRATE_HIGHATOMIC：表示高优先级的分配请求，这种类型的page只有在内存非常紧张时才会被使用。</li></ol><p>链表中的每一个元素都是一个空闲内存块。这些内存块在物理内存中是连续的，也就是说，它们包含的页框在物理内存中是紧邻的。这样，当内核需要分配一个连续的内存区域时，可以直接从这些链表中查找和分配。但要注意，虽然这些内存块在物理内存中是连续的，但在虚拟内存中可能并不连续。因为虚拟地址到物理地址的映射是通过页表完成的，不同的页框可以被映射到虚拟内存中的任意位置（不一定在相邻的页表项）。</p><blockquote><p>free_area数组里的链表元素存储了一个叫struct page的结构体。struct page是内核用来描述<strong>物理内存页</strong>的主要数据结构。</p><p>每个物理页在内核中都有一个对应的struct page实例。这个结构体包含了许多用于页管理的字段，如用于链接空闲页的链表节点字段等。内核可以通过这个结构体找到对应的物理页。为了映射物理内存和struct page实例，Linux内核使用了一种叫做mem_map的数组。这个数组的每个元素都是一个struct page实例，整个数组的顺序与物理内存页的顺序相同。因此，内核可以通过简单的指针运算在物理地址和对应的struct page实例之间进行转换。</p></blockquote><p>通过cat /proc/pagetypeinfo可以看到当前系统中伙伴系统各个尺寸的可用连续内存块数量。</p><p>内核提供分配器函数alloc_pages到上面的多个链表中寻找可用连续页面。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> page <span class="token operator">*</span> <span class="token function">alloc_pages</span><span class="token punctuation">(</span>gfp_t gfp_mask<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> order<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>假如要申请8KB（连续两个页框的内存），<strong>在基于伙伴系统的内存分配中，有可能需要将大块内存拆分成两个小伙伴。在释放中，可能会将两个小伙伴合并，在此组成更大块的连续内存。</strong>具体的工作步骤：</p><ol><li>先到free_area[1]，即8KB的链表中查询</li><li>如果无可用，则到free_area[2]，即16KB的链表中查询</li><li>如果找到了则将其拆分成两个小伙伴，使用掉其中一个</li><li>将另一个小伙伴放置到8KB的链表中</li></ol><h4 id="4、slab分配器"><a href="#4、slab分配器" class="headerlink" title="4、slab分配器"></a>4、slab分配器</h4><p>到目前介绍的内存分配都是以页面4KB为单位的。而内核代码经常需要在运行时分配和释放小块的内存区域。如果每次都使用普通的页分配器（即每次分配至少一个页的内存）来完成，可能会浪费大量内存。为了更高效地分配小块内存，内核在伙伴系统之上又引入了一个专用的内存分配器slab（或叫slub）</p><p>这个分配器最大的特点就是<strong>一个slab内只分配特定大小、甚至是特定的对象，当一个对象释放内存后，另一个同类对象可以直接使用这块内存</strong>。通过这样的方式极大地降低了碎片发生的概率。</p><p>在SLAB分配器中，<strong>当内核需要频繁创建和销毁某种类型的对象时（比如文件描述符、进程描述符等），它会创建一个kmem_cache，并根据需要的对象大小进行初始化</strong>。<strong>每个kmem_cache都包含一些预分配的内存块（SLABs）</strong>，这些内存块的大小都与需要的对象大小相匹配。当内核代码需要分配一个新的对象时，可以直接从对应的kmem_cache中取出一个预先分配的内存块，而不需要每次都去进行页分配。同样，当一个对象被释放时，它的内存块可以被直接归还到kmem_cache中，以便再次使用。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> kmem_cache <span class="token punctuation">{</span>    <span class="token keyword">struct</span> kmem_cache_node <span class="token operator">*</span><span class="token operator">*</span>node<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">struct</span> kmem_cache_node <span class="token punctuation">{</span>    <span class="token keyword">struct</span> list_head slabs_partial<span class="token punctuation">;</span>    <span class="token keyword">struct</span> list_head slabs_full<span class="token punctuation">;</span>    <span class="token keyword">struct</span> list_head slabs_free<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>一个kmem_cache可以有多个kmem_cache_node，每个kmem_cache_node代表该kmem_cache在一个特定的NUMA节点上的状态。</strong>NUMA是一种针对多处理器系统的内存架构，其主要思想是将物理内存划分为多个节点，每个处理器可以直接访问所有的内存，但访问不同节点的内存的延迟和带宽可能会有所不同。因此，在NUMA系统中，内存的分配策略可能会影响到程序的性能。为了在NUMA系统中更高效地管理内存，Linux内核引入了kmem_cache_node。在每个kmem_cache中，每个NUMA节点都有一个对应的kmem_cache_node。这个kmem_cache_node包含了该节点上的空闲对象列表，以及其他一些与该节点相关的信息。当从kmem_cache中分配或释放对象时，内核会优先考虑当前CPU对应的NUMA节点，这样可以提高内存访问的性能。</p><p><strong>每个kmem_cache_node中都有满、半满、空三个链表。每个链表节点都对应一个slab，一个slab由一个或多个内页也组成。</strong></p><p><strong>每一个slab内都保存的是同等大小的对象。</strong></p><p>当cache中内存不够时，会调用基于伙伴系统的分配器请求整页连续内存的分配。</p><p><img src="/posts/48821/c5a0449280aa42e593cf86d90c29092d.png" alt></p><p>内核中会有很多个kmem_cache存在，它们是在Linux初始化或者是运行的过程中分配出来的。其中有的是通用的，有的是专用的。</p><p><img src="/posts/48821/d06a875b50c649e5bb57d84ddfb1986d.png" alt></p><p>从图中可以<strong>看到socket_alloc内核对象都存在TCP的专用kmem_cache中</strong>。通过查看/proc/slabinfo可以查看所有的kmem_cahce。</p><p><strong>并不是所有的对象都会使用SLAB分配器进行分配。SLAB分配器是针对频繁分配和释放的小型对象设计的</strong>，比如内核中的各种数据结构（例如，文件描述符、信号量、进程描述符等）。对于这些对象，SLAB分配器可以显著提高分配效率，减少内存碎片，并提高缓存利用率。然而，对于大型对象（比如用户请求的大块内存），或者不常用的对象（即分配和释放不频繁的对象），直接使用页分配器（Page Allocator）或者伙伴系统（Buddy System）进行分配通常更为高效。页分配器可以处理任何大小的内存请求，但对于小型对象，可能会造成内存的浪费。</p><p>此外，用户空间的内存分配（例如，通过malloc()或者new进行的分配）通常不直接使用SLAB分配器。用户空间的内存分配通常由C库（例如，glibc）提供的内存分配器处理，这个分配器使用系统调用（例如，brk()或者mmap()）从内核获取或释放内存。</p><blockquote><p>Linux还提供了一个特别方便的命令slabtop来按照内存从大到小进行排列，可以用来分析slab内存开销。</p><p>此外slab管理器组件提供了若干接口函数方便使用：</p><ol><li>kmem_cache_create：创建一个基于slab的内核对象管理器。</li><li>kmem_cache_alloc：快速为某个对象申请内存。</li><li>kmem_cache_free：将对象占用的内存归还给slab分配器</li></ol></blockquote><h4 id="5）小结"><a href="#5）小结" class="headerlink" title="5）小结"></a>5）小结</h4><p>内核使用内存的方式：</p><ol><li>把所有内存条和CPU换分成node</li><li>把每一个node划分成zone</li><li>每个zone下都用伙伴系统管理空闲页面</li><li>内核提供slab分配器为自己专用</li></ol><p><strong>前三步是基础模块，为应用程序分配内存时的请求调页组件页能够用到，但是第四步就是内核给自己专用的了。</strong></p><h3 id="三、TCP连接相关内核对象"><a href="#三、TCP连接相关内核对象" class="headerlink" title="三、TCP连接相关内核对象"></a>三、TCP连接相关内核对象</h3><p>TCP连接建立的过程中，每申请一个内核对象也都需要到相应的缓存里申请一块内存。</p><h4 id="1）socket函数直接创建"><a href="#1）socket函数直接创建" class="headerlink" title="1）socket函数直接创建"></a>1）socket函数直接创建</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">__sock_create</span><span class="token punctuation">(</span><span class="token keyword">struct</span> net <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">int</span> family<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 分配socket对象</span>    sock <span class="token operator">=</span> <span class="token function">sock_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用协议族的创建函数创建sock对象</span>    err <span class="token operator">=</span> pf<span class="token operator">-></span><span class="token function">create</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> sock<span class="token punctuation">,</span> protocol<span class="token punctuation">,</span> kern<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-sock-inode-cache对象申请"><a href="#1-sock-inode-cache对象申请" class="headerlink" title="1. sock_inode_cache对象申请"></a>1. sock_inode_cache对象申请</h5><p>在sock_alloc函数中，申请了一个struct socket_alloc的内核对象。<strong>socket_alloc内核对象将socket和inode信息关联了起来。</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> socket_alloc <span class="token punctuation">{</span>    <span class="token keyword">struct</span> socket socket<span class="token punctuation">;</span>    <span class="token keyword">struct</span> inode vfs_inode<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在sock_alloc的实现逻辑中，最后就<strong>调用了kmem_cache_alloc从sock_inode_cache中申请了一个struct socket_alloc对象</strong>。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> inode <span class="token operator">*</span><span class="token function">sock_alloc_inode</span><span class="token punctuation">(</span><span class="token keyword">struct</span> super_block <span class="token operator">*</span>sb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> socket_alloc <span class="token operator">*</span>ei<span class="token punctuation">;</span>    <span class="token keyword">struct</span> socket_wq <span class="token operator">*</span>wq<span class="token punctuation">;</span>    ei <span class="token operator">=</span> <span class="token function">kmem_cache_alloc</span><span class="token punctuation">(</span>sock_inode_cachep<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>ei<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    wq <span class="token operator">=</span> <span class="token function">kmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>wq<span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>sock_inode_cache是专门用来存储struct socket_alloc的slab缓存</strong>，它是在init_inodecache中通过<code>kmem_cache(&quot;sock_inode_cache&quot;, sizeof(struct socket_alloc), ...)</code>初始化的。</p><p>另外还可以看到通过kmalloc申请了一个socket_wq，这是个用来记录在socket上等待事件的等待项。</p><h5 id="2-tcp对象申请"><a href="#2-tcp对象申请" class="headerlink" title="2. tcp对象申请"></a>2. tcp对象申请</h5><p>对于IPv4来说，inet协议族对应的create函数是inet_create，因此__sock_create中对pf-&gt;create的调用会执行到inet_create中去。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">inet_create</span><span class="token punctuation">(</span><span class="token keyword">struct</span> net <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">int</span> protocol<span class="token punctuation">,</span> <span class="token keyword">int</span> kern<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 这个answer_prot其实就是tcp_prot</span>    answer_prot <span class="token operator">=</span> answer<span class="token operator">-></span>prot<span class="token punctuation">;</span>    sk <span class="token operator">=</span> <span class="token function">sk_alloc</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> PF_INET<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">,</span> answer_prot<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">struct</span> sock <span class="token operator">*</span><span class="token function">sk_alloc</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    sturct sock <span class="token operator">*</span>sk<span class="token punctuation">;</span>    sk <span class="token operator">=</span> <span class="token function">sk_prot_alloc</span><span class="token punctuation">(</span>prot<span class="token punctuation">,</span> priority <span class="token operator">|</span> __GFP_ZERO<span class="token punctuation">,</span> family<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">struct</span> sock <span class="token operator">*</span><span class="token function">sk_prot_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> proto <span class="token operator">*</span>prot<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    slab <span class="token operator">=</span> prot<span class="token operator">-></span>slab<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>slab <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      sk <span class="token operator">=</span> <span class="token function">kmem_cache_alloc</span><span class="token punctuation">(</span>slab<span class="token punctuation">,</span> priority <span class="token operator">&amp;</span> <span class="token operator">~</span>__GFP_ZERO<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个函数中，<strong>将会到TCP这个slab缓存中使用kmem_cache_alloc从slab中申请一个struct sock内核对象出来</strong>。TCP这个slab缓存是在协议栈初始化的时候在inet_init中使用<code>kmem_cache_create(prot-&gt;name, prot-&gt;obj_size, ...)</code>（这里prot是一个tcp_prot）初始化好的一个名为TCP、大小为sizeof(struct tcp_sock)的kmem_cache，并把它记到tcp_prot-&gt;slab的字段下。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> proto tcp_prot <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"TCP"</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">.</span>obj_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> tcp_sock<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要记住的是，在<strong>TCP slab缓存中实际存放的是struct tcp_sock对象，是struct sock的扩展</strong>，由于tcp_sock、inet_connection_sock、inet_sock、sock是逐层嵌套的关系，所以tcp_sock是可以当作sock来使用的。</p><h5 id="3-dentry和flip对象申请"><a href="#3-dentry和flip对象申请" class="headerlink" title="3. dentry和flip对象申请"></a>3. dentry和flip对象申请</h5><p>回到socket系统调用的入口处，除了sock_create以外，还调用了一个sock_map_fd</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">SYSCALL_DEFINE</span><span class="token punctuation">(</span>socket<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> family<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> protocol<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">sock_create</span><span class="token punctuation">(</span>family<span class="token punctuation">,</span> type<span class="token punctuation">,</span> protocol<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sock_map_fd</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> flags <span class="token operator">&amp;</span> <span class="token punctuation">(</span>0_CLOEXEC <span class="token operator">|</span> ONONBLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以此为入口将完成struct dentry的和struct file申请。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> dentry <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">struct</span> dentry <span class="token operator">*</span>d_parent<span class="token punctuation">;</span>    <span class="token keyword">struct</span> qstr d_name<span class="token punctuation">;</span>    <span class="token keyword">struct</span> inode <span class="token operator">*</span>d_inode<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> d_iname<span class="token punctuation">[</span>DNAME_INLINE_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>内核初始化的时候创建好了一个dentry slab和flip slab缓存，所有的struct dentry对象和struct file对象都将由它们进行分配。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">sock_map_fd</span><span class="token punctuation">(</span><span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> file <span class="token operator">*</span>newfile<span class="token punctuation">;</span>    <span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">get_unused_fd_flags</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 1.申请dentry、file内核对象</span>    newfile <span class="token operator">=</span> <span class="token function">sock_alloc_file</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>newfile<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 2.关联到socket及进程</span>      <span class="token function">fd_install</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> newfile<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> fd<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">struct</span> file <span class="token operator">*</span><span class="token function">sock_alloc_file</span><span class="token punctuation">(</span><span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>dname<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 申请dentry</span>    path<span class="token punctuation">.</span>dentry <span class="token operator">=</span> <span class="token function">d_alloc_pseudo</span><span class="token punctuation">(</span>sock_mnt<span class="token operator">-></span>mnt_sb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 申请flip</span>    file <span class="token operator">=</span> <span class="token function">alloc_file</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>path<span class="token punctuation">,</span> FMOD_READ <span class="token operator">|</span> FMODE_WRITE<span class="token punctuation">,</span> <span class="token operator">&amp;</span>socket_file_ops<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>在sock_alloc_file中完成内核对象的申请，其中会去进行struct dentry和struct file两个内核对象的申请。</strong>dentry对象的申请最终同样是是调用到了kmem_cache_alloc函数（对应的slab缓存dentry在内核初始化时的dcache_init中创建的），而file对象的申请最终是调用了kmem_cache_zalloc函数进行分配（对应的slab缓存flip是在内核初始化时的files_init中创建的）</p><blockquote><p>kmem_cache_alloc()和kmem_cache_zalloc()都是用于从指定的kmem_cache中分配对象的函数。它们的主要区别在于，kmem_cache_zalloc()在分配内存后，会自动将内存区域初始化为0。</p><p>具体来说：</p><ul><li>kmem_cache_alloc()：从指定的kmem_cache分配一个对象的内存空间。返回的内存空间中的内容是不确定的，也就是说，它可能包含任何数据。调用者需要自己对内存进行初始化。</li><li>kmem_cache_zalloc()：从指定的kmem_cache分配一个对象的内存空间，并自动将整个内存区域初始化为0。这意味着调用者可以直接使用返回的内存，无需再进行初始化。</li></ul><p>在一些情况下，使用kmem_cache_zalloc()可能更方便，因为它可以确保内存区域的内容被初始化为0。然而，如果你知道你会立即覆盖整个内存区域的内容，那么使用kmem_cache_alloc()可能会更高效，因为它避免了不必要的内存初始化。</p></blockquote><h5 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h5><p>调用链：</p><ul><li>SYSCALL_DEFINE3<ul><li>sock_create<ul><li>__sock_create<ul><li>sock_alloc =&gt; =&gt; sock_alloc_inode：申请socket_alloc和socket_wq</li><li>inet_create<ul><li>sk_alloc =&gt; sk_prot_alloc：申请tcp_sock</li></ul></li></ul></li></ul></li><li>sock_map_fd<ul><li>sock_alloc_file<ul><li>d_alloc_pseudo =&gt; __d_alloc：申请dentry</li><li>alloc_file =&gt; get_empty_flip：申请file</li></ul></li></ul></li></ul></li></ul><p>socket系统调用完毕之后，在内核中就申请了配套的一组内核对象。这些内核对象并不是鼓励地存在，而是互相保留着和其他内存对象的关联关系。</p><p><img src="/posts/48821/6d424f2828a1426d973ef066379d1b47.png" alt></p><p>所有网络相关的操作，包括数据接收和发送等都以这些数据结构为基础来进行的</p><h4 id="2）服务端socket创建"><a href="#2）服务端socket创建" class="headerlink" title="2）服务端socket创建"></a>2）服务端socket创建</h4><p>除了直接创建socket意外，服务端还可以通过accept函数在接受连接请求时完成相关内核对象的创建。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">SYSCALL_DEFINE</span><span class="token punctuation">(</span>accept4<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> sockaddr __user <span class="token operator">*</span><span class="token punctuation">,</span> upeerp_sockaddr<span class="token punctuation">,</span> <span class="token keyword">int</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> upeer_addrlen<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token operator">*</span>newsock<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 根据fd查找到监听的socket</span>    sock <span class="token operator">=</span> <span class="token function">sockfd_lookup_light</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 申请并初始化新的socket</span>    newsock <span class="token operator">=</span> <span class="token function">sock_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    newsock<span class="token operator">-></span>type <span class="token operator">=</span> sock<span class="token operator">-></span>type<span class="token punctuation">;</span>    newsock<span class="token operator">-></span>ops <span class="token operator">=</span> sock<span class="token operator">-></span>ops<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 申请新的file对象，并设置到新的socket上</span>    newfile <span class="token operator">=</span> <span class="token function">sock_alloc_file</span><span class="token punctuation">(</span>newsock<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 接受连接</span>    err <span class="token operator">=</span> sock<span class="token operator">-></span>ops<span class="token operator">-></span><span class="token function">accept</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> newsock<span class="token punctuation">,</span> sock<span class="token operator">-></span>file<span class="token operator">-></span>f_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将新文件添加到当前进程的打开文件列表</span>    <span class="token function">fd_install</span><span class="token punctuation">(</span>newfd<span class="token punctuation">,</span> newfile<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到socket_alloc、file、dentry对象的分配都是相同的方式，唯一的区别是tcp_sock对象是在第三次握手的时候创建的，所以这里在接收连接的时候直接从全连接队列拿出request_sock的sock成员就可以了，无需再单独申请。</p><h3 id="四、问题解答"><a href="#四、问题解答" class="headerlink" title="四、问题解答"></a>四、问题解答</h3><ol><li>内核是如何管理内存的：内核采用SLAB的方式来管理内存，总共分为四部<ul><li>把所有的内存条和CPU进行分组，组成node</li><li>把每一个node划分成多个zone</li><li>每个zone下都用伙伴系统来管理空闲页面</li><li>提供slab分配器来管理各种内核对象</li><li>前三步时基础模块，为应用程序分配内存时的请求调页组件也能够用到，而第四步是内核专用的。每个slab缓存都是用来存储固定大小，甚至是特定的一种内核对象。这样当一个对象释放内存后，另一个同类对象可以直接使用这块内存，几乎没有任何碎片。极大地提高了分配效率，同时降低了碎片率。</li></ul></li><li>如何查看内核使用的内存信息<ul><li>通过/proc/slabinfo可以看到所有的kmem_cache。</li><li>更方便的是slatop命令，它从大到小按照占用内存进行排列。</li></ul></li><li>服务器上一条ESTABLISH状态的空连接需要消耗多少内存：假设连接上绝大部分时间都是空闲的，也就是假设没有发送缓存区和接收缓存区的开销，那么一个socket大约需要如下几个内核对象<ul><li>struct socket_alloc：大约0.62KB， slab缓存名是sock_inode_cache</li><li>struct top_sock：大约1.94KB，slab缓存名是tcp</li><li>struct dentry：大约0.19KB，slab缓存名是dentry</li><li>struct file：大约为0.25KB，slab缓存名是flip</li><li>加上slab多少会存在一点碎片无法使用，这组内核对象的大小大约是3.3KB左右。所以即使一万条连接也只需要占用33MB的内存</li><li>至于CPU开销，没有数据包的接收和处理是不需要消耗CPU的。长连接上在没有数据传输的情况下，只有极少量的保护包传输，CPU开销可以忽略不计</li></ul></li><li>机器上出现了3万多个TIME_WAIT，内存开销会不会很大<ul><li>从内存的角度来考虑，一条TIME_WAIT状态的连接仅仅是0.4KB左右的内存而已</li><li>从端口的角度来考虑，占用的端口只是针对特定服务器来说是占用了，只要下次连接的服务端不一样（IP或者端口不一样），那么这个端口仍然可以用来发起TCP连接</li><li>只有在连接同一个server的时候端口占用才能算得上是问题。如果想解决这个问题可以考虑使用tcp_max_tw_buckets来限制TIME_WAIT连接总数，或者打开tcp_tw_recycle、tcp_tw_reuse来快速回收端口，或者干脆使用长连接代替频繁的短连接。</li></ul></li></ol><p><strong>拓展阅读</strong>：</p><p><a href="https://zhuanlan.zhihu.com/p/62795773">Linux 内核 101：NUMA架构 - 知乎 (zhihu.com)</a></p><p><a href="https://www.jianshu.com/p/0607c5f62c51">浅解NUMA机制 - 简书 (jianshu.com)</a></p><p><a href="https://www.cnblogs.com/linhaostudy/p/10006723.html">Linux内存描述之内存区域zone–Linux内存管理(三) - yooooooo - 博客园 (cnblogs.com)</a></p><p><a href="https://www.dingmos.com/index.php/archives/23/#cl-2">Linux 内核 | 内存管理——Slab 分配器 - 一丁点儿 (dingmos.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/68465952">Linux中的物理内存管理 [一] - 知乎 (zhihu.com)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在应用程序里，我们使用多少内存都是自己能掌握和控制的，但是纵观Linux整台服务器，除了应用程序以外，内核也会申请和管理大量的内存。&lt;/p&gt;
&lt;h3 id=&quot;一、相关实际问题&quot;&gt;&lt;a href=&quot;#一、相关实际问题&quot; class=&quot;headerlink&quot; title=&quot;一、
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
      <category term="C" scheme="https://JoyTsing.github.io/tags/C/"/>
    
      <category term="源码阅读" scheme="https://JoyTsing.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
</feed>
