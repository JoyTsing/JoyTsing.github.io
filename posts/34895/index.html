<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="深入理解Linux网络学习笔记(四), joytsing blog"><meta name="description" content="内核是如何发送网络包的"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="theme-color" content="white"><title>深入理解Linux网络学习笔记(四) | JoyTsing</title><link rel="apple-touch-icon" href="/"><link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="/favicon.ico"><link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css"><link rel="stylesheet" type="text/css" href="/libs/aos/aos.css"><link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css"><link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" type="text/css" href="/css/matery.css"><link rel="stylesheet" type="text/css" href="/css/my.css"><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style><script src="/libs/jquery/jquery.min.js"></script><script src="https://cdn-go.cn/aegis/aegis-sdk/latest/aegis.min.js"></script><script>const aegis=new Aegis({id:"6ojk8FlnQlqWeL6vQo",uin:"joyblog",reportApiSpeed:!0,reportAssetSpeed:!0,spa:!0,hostUrl:"https://rumt-sg.com"});console.log("aegis load")</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="JoyTsing" type="application/atom+xml"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><img src="/apple-touch-icon.png" class="logo-img" alt="LOGO"> <span class="logo-span">JoyTsing</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fa fa-home"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-tags"></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-bookmark"></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-archive"></i> <span>归档</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa fa-user-circle-o"></i> <span>关于</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa fa-envelope"></i> <span>留言</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa fa-address-book"></i> <span>友链</span></a></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fa fa-search" title="搜索"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="/medias/avatars/touxiang2.jpg" class="logo-img circle responsive-img"><div class="logo-name">JoyTsing</div><div class="logo-desc">joytsing的个人网站</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="m-nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-fw fa-bookmark"></i> 分类</a></li><li class="m-nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li class="m-nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa fa-fw fa-user-circle-o"></i> 关于</a></li><li class="m-nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa fa-fw fa-envelope"></i> 留言</a></li><li class="m-nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa fa-fw fa-address-book"></i> 友链</a></li><li><div class="divider"></div></li><li><a href="https://github.com/JoyTsing" class="waves-effect waves-light" target="_blank"><i class="fa fa-github-square fa-fw"></i>Follow Me</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#000;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href="https://github.com/JoyTsing" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Follow Me" data-position="left" data-delay="50"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a></nav></header><div class="bg-cover pd-header post-cover" style="background-image:url(/medias/featureimages/18.jpg)"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">深入理解Linux网络学习笔记(四)</h1></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{width:345px;padding-left:20px}.toc-widget .toc-title{margin:35px 0 15px 0;padding-left:17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content{height:calc(100vh - 250px);overflow:auto}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px;position:absolute;right:23.5vw;display:block}#toc-content .is-active-link{color:#42b983}#floating-toc-btn{position:fixed;right:15px;bottom:76px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/Linux/"><span class="chip bg-color">Linux</span> </a><a href="/tags/C/"><span class="chip bg-color">C</span> </a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="chip bg-color">计算机网络</span> </a><a href="/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"><span class="chip bg-color">源码阅读</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-category">计算机网络</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp; 2024-04-02</div><div class="post-date info-break-policy"><i class="fa fa-calendar-check-o fa-fw"></i>更新日期:&nbsp;&nbsp; 2024-04-07</div><div class="info-break-policy"><i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp; 8.6k</div><div class="info-break-policy"><i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp; 31 分</div><div id="busuanzi_container_page_pv" class="info-break-policy"><i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp; <span id="busuanzi_value_page_pv"></span></div></div></div><hr class="clearfix"><div class="card-content article-card-content"><div id="articleContent"><h2 id="内核是如何发送网络包的"><a href="#内核是如何发送网络包的" class="headerlink" title="内核是如何发送网络包的"></a>内核是如何发送网络包的</h2><h3 id="1）网络包发送过程总览"><a href="#1）网络包发送过程总览" class="headerlink" title="1）网络包发送过程总览"></a>1）网络包发送过程总览</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">bind</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">listen</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cfd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 接收用户请求</span>
    <span class="token function">read</span><span class="token punctuation">(</span>cfd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 用户请求处理</span>
    <span class="token function">dosomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 给用户返回结果</span>
    <span class="token function">send</span><span class="token punctuation">(</span>cfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码中，调用send之后内核是怎样把数据包发送出去的？</p><p><img src="/posts/34895/7889902380838845028.png" alt></p><p>如上图所示，可以看到用户数据被拷贝到内核态，然后经过协议栈处理后进入RingBuffer。随后网卡驱动真正将数据发送了出去。当发送完成的时候，是通过硬中断来通知CPU，然后清理RingBuffer。</p><p>总体的流程图如下：</p><p><img src="/posts/34895/8223474428938309457.png" alt></p><p>虽然数据这时已经发送完毕，但是其实还有一件重要的事情没有做，那就是释放缓存队列等内存。</p><p>那内核是如何知道什么时候才能释放内存的呢，当然是等网络发送完毕之后。网卡在发送完毕的时候，会给 CPU 发送一个硬中断来通知 CPU。更完整的流程看图：</p><p><img src="/posts/34895/6645374755730163142.png" alt></p><h3 id="2）网卡启动准备"><a href="#2）网卡启动准备" class="headerlink" title="2）网卡启动准备"></a>2）网卡启动准备</h3><p>现在的服务器上的网卡一般都是支持多队列的。每一个队列都是由一个RingBuffer表示的，开启了多队列以后的网卡就会对应有多个RingBuffer，如下图所示：</p><p><img src="/posts/34895/5740764547427485556.png" alt></p><p>网卡在启动时最重要的任务之一就是分配和初始化RingBuffer，接下来看看网卡启动时分配传输队列<code>RingBuffer</code>的实际过程。在网卡启动的时候，会调用<code>__igb_open</code>函数，<code>RingBuffer</code>就是在这里分配的</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// drivers/net/ethernet/intel/igb/igb_main.c</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">__igb_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> net_device <span class="token operator">*</span>netdev<span class="token punctuation">,</span> bool resuming<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> igb_adapter <span class="token operator">*</span>adapter <span class="token operator">=</span> <span class="token function">netdev_priv</span><span class="token punctuation">(</span>netdev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment" spellcheck="true">// 分配传输描述符数组</span>
    err <span class="token operator">=</span> <span class="token function">igb_setup_all_tx_resources</span><span class="token punctuation">(</span>adapter<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment" spellcheck="true">// 分配接收描述符数组</span>
    err <span class="token operator">=</span> <span class="token function">igb_setup_all_rx_resources</span><span class="token punctuation">(</span>adapter<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment" spellcheck="true">// 开启全部队列</span>
    <span class="token function">netif_tx_start_all_queues</span><span class="token punctuation">(</span>netdev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的<code>__igb_open</code>函数调用<code>igb_setup_all_tx_resources</code>分配所有的传输<code>RingBuffer</code>，调用<code>igb_setup_all_rx_resources</code>分配所有的接收<code>RingBuffer</code></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// drivers/net/ethernet/intel/igb/igb_main.c</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">igb_setup_all_tx_resources</span><span class="token punctuation">(</span><span class="token keyword">struct</span> igb_adapter <span class="token operator">*</span>adapter<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment" spellcheck="true">// 有几个队列就构造几个RingBuffer</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> adapter<span class="token operator">-></span>num_tx_queues<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        err <span class="token operator">=</span> <span class="token function">igb_setup_tx_resources</span><span class="token punctuation">(</span>adapter<span class="token operator">-></span>tx_ring<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>真正的<code>RingBuffer</code>构造过程是在<code>igb_setup_tx_resources</code>中完成的</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// drivers/net/ethernet/intel/igb/igb_main.c</span>
<span class="token keyword">int</span> <span class="token function">igb_setup_tx_resources</span><span class="token punctuation">(</span><span class="token keyword">struct</span> igb_ring <span class="token operator">*</span>tx_ring<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 1.申请igb_tx_buffer数组内存</span>
    size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> igb_tx_buffer<span class="token punctuation">)</span> <span class="token operator">*</span> tx_ring<span class="token operator">-></span>count<span class="token punctuation">;</span>

    tx_ring<span class="token operator">-></span>tx_buffer_info <span class="token operator">=</span> <span class="token function">vzalloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment" spellcheck="true">// 2.申请e1000_adv_tx_desc DMA数组内存</span>
    tx_ring<span class="token operator">-></span>size <span class="token operator">=</span> tx_ring<span class="token operator">-></span>count <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">union</span> e1000_adv_tx_desc<span class="token punctuation">)</span><span class="token punctuation">;</span>
    tx_ring<span class="token operator">-></span>size <span class="token operator">=</span> <span class="token function">ALIGN</span><span class="token punctuation">(</span>tx_ring<span class="token operator">-></span>size<span class="token punctuation">,</span> <span class="token number">4096</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    tx_ring<span class="token operator">-></span>desc <span class="token operator">=</span> <span class="token function">dma_alloc_coherent</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> tx_ring<span class="token operator">-></span>size<span class="token punctuation">,</span>
                       <span class="token operator">&amp;</span>tx_ring<span class="token operator">-></span>dma<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment" spellcheck="true">// 3.初始化队列成员</span>
    tx_ring<span class="token operator">-></span>next_to_use <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    tx_ring<span class="token operator">-></span>next_to_clean <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上述源码可以看到，一个传输RingBuffer的内部也不仅仅是一个环形队列数组：</p><ul><li><code>igb_tx_buffer</code>数组：这个数组是内核使用的，通过<code>vzalloc</code>申请</li><li><code>e1000_adv_tx_desc</code>数组：这个数组是网卡硬件使用的，通过<code>dma_alloc_coherent</code>分配</li></ul><p>这个时候它们之间还没有啥联系。将来在发送的时候，这两个环形数组中相同位置的指针将都将指向同一个 skb。这样，内核和硬件就能共同访问同样的数据了，内核往 skb 里写数据，网卡硬件负责发送。</p><p><img src="/posts/34895/6701590266695649995.png" alt></p><p>最后调用<code>netif_tx_start_all_queues</code>开启队列。另外，硬中断的处理函数<code>igb_msix_ring</code>其实也是在<code>__igb_open</code>中注册的</p><h3 id="3）数据从用户进程到网卡的详细过程"><a href="#3）数据从用户进程到网卡的详细过程" class="headerlink" title="3）数据从用户进程到网卡的详细过程"></a>3）数据从用户进程到网卡的详细过程</h3><h4 id="1）send系统调用实现"><a href="#1）send系统调用实现" class="headerlink" title="1）send系统调用实现"></a>1）send系统调用实现</h4><p>send系统调用的源码位于net/socket.c中。在这个系统调用里，内部其实真正使用的是sendto系统调用。主要干了两件事情：</p><ol><li>在内核中把真正的socket找出来，在这个对象里记录着各种协议栈的函数地址</li><li>构造一个struct msghdr对象，把用户传入的数据，比如buffer地址、数据长度什么的，都装进去</li></ol><p><img src="/posts/34895/5127322427803208878.png" alt></p><p>有了上面的了解，我们再看起源码就要容易许多了。源码如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: net/socket.c</span>
<span class="token function">SYSCALL_DEFINE4</span><span class="token punctuation">(</span>send<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> buff<span class="token punctuation">,</span> size_t<span class="token punctuation">,</span> len<span class="token punctuation">,</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
 <span class="token keyword">return</span> <span class="token function">sys_sendto</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buff<span class="token punctuation">,</span> len<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">SYSCALL_DEFINE6</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
 <span class="token comment" spellcheck="true">//1.根据 fd 查找到 socket</span>
 sock <span class="token operator">=</span> <span class="token function">sockfd_lookup_light</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>err<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fput_needed<span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token comment" spellcheck="true">//2.构造 msghdr</span>
 <span class="token keyword">struct</span> msghdr msg<span class="token punctuation">;</span>
 <span class="token keyword">struct</span> iovec iov<span class="token punctuation">;</span>

 iov<span class="token punctuation">.</span>iov_base <span class="token operator">=</span> buff<span class="token punctuation">;</span>
 iov<span class="token punctuation">.</span>iov_len <span class="token operator">=</span> len<span class="token punctuation">;</span>
 msg<span class="token punctuation">.</span>msg_iovlen <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

 msg<span class="token punctuation">.</span>msg_iov <span class="token operator">=</span> <span class="token operator">&amp;</span>iov<span class="token punctuation">;</span>
 msg<span class="token punctuation">.</span>msg_flags <span class="token operator">=</span> flags<span class="token punctuation">;</span>
 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

 <span class="token comment" spellcheck="true">//3.发送数据</span>
 <span class="token function">sock_sendmsg</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从源码可以看到，我们在用户态使用的 send 函数和 sendto 函数其实都是 sendto 系统调用实现的。send 只是为了方便，封装出来的一个更易于调用的方式而已。在 sendto 系统调用里，首先根据用户传进来的 socket 句柄号来查找真正的 socket 内核对象。接着把用户请求的 buff、len、flag 等参数都统统打包到一个 struct msghdr 对象中。</p><p>接着调用了 sock_sendmsg =&gt; <strong>sock_sendmsg ==&gt; __sock_sendmsg_nosec。在</strong>sock_sendmsg_nosec 中，调用将会由系统调用进入到协议栈，我们来看它的源码。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: net/socket.c</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">__sock_sendmsg_nosec</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
 <span class="token keyword">return</span> sock<span class="token operator">-></span>ops<span class="token operator">-></span><span class="token function">sendmsg</span><span class="token punctuation">(</span>iocb<span class="token punctuation">,</span> sock<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2）传输层处理"><a href="#2）传输层处理" class="headerlink" title="2）传输层处理"></a>2）传输层处理</h4><p><strong>传输层拷贝</strong></p><p>在进入协议栈inet_sendmsg以后，内核接着会找到socket上的具体协议发送函数。对于TCP协议来说，那就是tcp_sendmsg（同样也是通过socket内核对象找到的）</p><p>在这个函数中，内核会申请一个内核态的skb内存，将用户待发送的数据拷贝进去。注意，这个时候不一定会真正开始发送，如果没有达到发送条件，很可能这次调用直接就返回了，大概过程如下图所示：</p><p><img src="/posts/34895/6212660484899004570.png" alt></p><p>在进入协议栈inet_sendmsg以后，内核接着会找到sock中具体的协议处理函数，对于TCP协议而言，sk_prot操作函数集实例为tcp_prot，其中.sendmsg的实现为tcp_sendmsg（对于UDP而言中的为udp_sendmsg）。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">inet_sendmsg</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> sk<span class="token operator">-></span>sk_prot<span class="token operator">-></span><span class="token function">sendmsg</span><span class="token punctuation">(</span>iocb<span class="token punctuation">,</span> sk<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">tcp_sendmsg</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  
<span class="token comment" spellcheck="true">// 获取用户传递过来的数据和标志</span>
iov <span class="token operator">=</span> msg<span class="token operator">-></span>msg_iov<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用户数据地址</span>
iovlen <span class="token operator">=</span> msg<span class="token operator">-></span>msg_iovlen<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 数据块数为1</span>
flags <span class="token operator">=</span> msg<span class="token operator">-></span>msg_flags<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 各种标志</span>
copied <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 已拷贝到发送队列的字节数</span>

<span class="token comment" spellcheck="true">// 遍历用户层的数据块</span>
<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">--</span>iovlen <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment" spellcheck="true">// 待发送数据块的长度</span>
size_t seglen <span class="token operator">=</span> iov<span class="token operator">-></span>len<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 待发送数据块的地址</span>
<span class="token keyword">unsigned</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>from <span class="token operator">=</span> iov<span class="token operator">-></span>iov_base<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 指向下一个数据块</span>
iovlen<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>seglen <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> copy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> max <span class="token operator">=</span> size_goal<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 单个skb最大的数据长度</span>

    skb <span class="token operator">=</span> <span class="token function">tcp_write_queue_tail</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获取发送队列最后一个skb</span>
    <span class="token comment" spellcheck="true">// 用于返回发送队列第一个数据包，如果不是NULL说明还有未发送的数据</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">tcp_send_head</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    copy <span class="token operator">=</span> max <span class="token operator">-</span> skb<span class="token operator">-></span>len<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 该skb还可以存放的字节数</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 需要申请新的skb</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>copy <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 发送队列的总大小大于等于发送缓存的上限，或尚发送缓存中未发送的数据量超过了用户的设置值，进入等待</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">sk_stream_memory_free</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">goto</span> wait_for_sndbuf<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 申请一个skb</span>
    skb <span class="token operator">=</span> <span class="token function">sk_stream_alloc_skb</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token function">select_size</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> sg<span class="token punctuation">)</span><span class="token punctuation">,</span> sk<span class="token operator">-></span>sk_allocation<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment" spellcheck="true">// 把skb添加到sock的发送队列尾部</span>
    <span class="token function">skb_entail</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>copy <span class="token operator">></span> seglen<span class="token punctuation">)</span>
    copy <span class="token operator">=</span> seglen<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// skb的线性数据区中有足够的空间</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">skb_availroom</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    copy <span class="token operator">=</span> <span class="token function">min_t</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> copy<span class="token punctuation">,</span> <span class="token function">skb_availroom</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 将用户空间的数据拷贝到内核空间，同时计算校验和</span>
    err <span class="token operator">=</span> <span class="token function">skb_add_data_nocache</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> from<span class="token punctuation">,</span> copy<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
        <span class="token keyword">goto</span> do_fault<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 线性数据区用完，使用分页区</span>
    <span class="token keyword">else</span><span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个函数的实现逻辑比较复杂，代码总只显示了skb拷贝的相关部分，总体逻辑如下：</p><ol><li>如果使用了TCP Fast Open，则会在发送SYN包的同时带上数据</li><li>如果连接尚未建好，不处于ESTABLISHED或者CLOSE_WAIT状态则进程进入睡眠，等待三次握手的完成</li><li>获取当前的MSS（最大报文长度）和size_goal（一个理想的TCP数据包大小，受MTU、MSS、TCP窗口大小影响）<ul><li>如果网卡支持GSO（利用网卡分片），size_goal会是MSS的整数倍</li></ul></li><li><strong>遍历用户层的数据块数组</strong><ol><li><strong>获取发送队列的最后一个skb，如果是尚未发送的，且长度未到达size_goal，那么向这个skb继续追加数据</strong></li><li><strong>否则申请一个新的skb来装载数据</strong><ol><li>如果发送队列的总大小大于等于发送缓存的上限，或者发送缓存中尚未发送的数据量超过了用户的设置值：设置发送时发送缓存不够的标志，进入等待</li><li>申请一个skb，其线性区的大小为通过select_size()得到的线性数据区中TCP负荷的大小和最大的协议头长度，申请失败则等待可用内存</li><li>前两步成功则更新skb的TCP控制块字段，把skb加入发送队列队尾，增加发送队列的大小，减少预分配缓存的大小</li></ol></li><li><strong>将数据拷贝至skb中</strong><ol><li><strong>如果skb的线性数据区还有剩余，就复制到线性数据区同时计算校验和</strong></li><li><strong>如果已经用完则使用分页区</strong><ol><li>检查分页区是否有可用空间，没有则申请新的page，申请失败则说明内存不足，之后会设置TCP内存压力标志，减小发送缓冲区的上限，睡眠等待内存</li><li>判断能否往最后一个分页追加数据，不能追加时，检查分页数是否已经达到了上限或网卡是否不支持分散聚合，如果是的话就将skb设置为PSH标志，然后回到4.2中重新申请一个skb来继续填装数据</li><li>从系统层面判断此次分页发送缓存的申请是否合法</li><li>拷贝用户空间的数据到skb的分页中，同时计算校验和。更新skb的长度字段，更新sock的发送队列大小和预分配缓存</li><li>如果把数据追加到最后一个分页了，更新最后一个分页的数据大小。否则初始化新的分页</li></ol></li></ol></li><li>拷贝成功后更新：发送队列的最后一个序号、skb的结束序号、已经拷贝到发送队列的数据量</li><li>发送数据<ol><li>如果所有数据都拷贝好了就退出循环进行发送</li><li>如果skb还可以继续装填数据或者发送的是带外数据那么就继续拷贝数据先不发送</li><li>如果为发送的数据已经超过最大窗口的一半则设置PUSH标志后尽可能地将发送队列中的skb发送出去</li><li>如果当前skb就是发送队列中唯一一个skb，则将这一个skb发送出去</li><li><em>如果上述过程中出现缓存不足，且已经有数据拷贝到发送队列了也直接发送</em></li></ol></li></ol></li></ol><blockquote><p>这里的发送数据只是指调用tcp_push或者tcp_push_one（情况4）或者__tcp_push_pending_frames（情况3）尝试发送，并不一定真的发送到网络（tcp_sendmsg主要任务只是将应用程序的数据封装成网络数据包放到发送队列）。</p><p>数据何时实际被发送到网络，取决于许多因素，包括但不限于：</p><ul><li>TCP的拥塞控制算法：TCP使用了复杂的拥塞控制算法来防止网络过载。如果TCP判断网络可能出现拥塞，它可能会延迟发送数据。</li><li>发送窗口的大小：TCP使用发送窗口和接收窗口来控制数据的发送和接收。如果发送窗口已满（即已发送但未被确认的数据量达到了发送窗口的大小），那么TCP必须等待接收到确认信息后才能发送更多的数据。</li><li>网络设备（如网卡）的状态：如果网络设备繁忙或出现错误，数据可能会被暂时挂起而无法立即发送。</li></ul><p>struct sk_buff（常简称为skb）在Linux网络栈中表示一个网络包。它有两个主要的数据区用来存储数据，分别是线性数据区（linear data area）和分页区（paged data area）。</p><ol><li>线性数据区（linear data area）: 这个区域连续存储数据，并且能够容纳一个完整的网络包的所有协议头，比如MAC头、IP头和TCP/UDP头等。除了协议头部，线性数据区还可以包含一部分或全部的数据负载。每个skb都有一个线性数据区。</li><li>分页区（paged data area）: 一些情况下，为了优化内存使用和提高性能，skb的数据负载部分可以存储在一个或多个内存页中，而非线性数据区。分页区的数据通常只包含数据负载部分，不包含协议头部。如果一个skb的数据全部放入了线性数据区，那么这个skb就没有分页区。</li></ol><p>这种设计的好处是，对于大的数据包，可以将其数据负载部分存储在分页区，避免对大块连续内存的分配，从而提高内存使用效率，减少内存碎片。另外，这种设计也可以更好地支持零拷贝技术。例如，当网络栈接收到一个大数据包时，可以直接将数据包的数据负载部分留在原始的接收缓冲区（即分页区），而无需将其拷贝到线性数据区，从而节省了内存拷贝的开销。</p></blockquote><p><strong>传输层发送</strong></p><p><img src="/posts/34895/6494688155226641158.png" alt></p><p>上面的发送数据步骤，不论是调用__tcp_push_pending_frames还是tcp_push_one，最终都会执行到<strong>tcp_write_xmit</strong>（在网络协议中学到滑动窗口、拥塞控制就是在这个函数中完成的），函数的主要逻辑如下：</p><ol><li>如果要发送多个数据段则先发送一个路径mtu探测</li><li><strong>检测拥塞窗口的大小</strong>，如果窗口已满（通过窗口大小-正在网络上传输的包数目判断）则不发送</li><li><strong>检测当前报文是否完全在发送窗口内</strong>，如果不是则不发送</li><li><strong>判断是否需要延时发送</strong>（取决于拥塞窗口和发送窗口）</li><li><strong>根据需要对数据包进行分段</strong>（取决于拥塞窗口和发送窗口）</li><li><strong>tcp_transmit_skb发送数据包</strong></li><li>如果push_one则结束循环，否则继续遍历队列发送</li><li>结束循环后如果本次有数据发送，则对TCP拥塞窗口进行检查确认</li></ol><p>这里我们只关注发送的主过程，其他部分不过多展开，即来到<strong>tcp_transmit_skb</strong>函数</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">tcp_transmit_skb</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">int</span> clone_it<span class="token punctuation">,</span> gfp_t gfp_mask<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 1.克隆新的skb出来</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>clone_it<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     skb <span class="token operator">=</span> <span class="token function">skb_clone</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> gfp_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 2.封装TCP头</span>
    th <span class="token operator">=</span> <span class="token function">tcp_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
    th<span class="token operator">-></span>source <span class="token operator">=</span> inet<span class="token operator">-></span>inet_sport<span class="token punctuation">;</span>
    th<span class="token operator">-></span>dest <span class="token operator">=</span> inet<span class="token operator">-></span>inet_dport<span class="token punctuation">;</span>
    th<span class="token operator">-></span>window <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
    th<span class="token operator">-></span>urg <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    <span class="token comment" spellcheck="true">// 3.调用网络层发送接口</span>
    err <span class="token operator">=</span> icsk<span class="token operator">-></span>icsk_af_ops<span class="token operator">-></span><span class="token function">xmit</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>inet<span class="token operator">-></span>cort<span class="token punctuation">.</span>fl<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一件事就是先<strong>克隆一个新的skb</strong>，因为skb后续在调用网络层，最后到达网卡发送完成的时候，这个skb会被释放掉。而<strong>TCP协议是支持丢失重传的，在收到对方的ACK之前，这个skb不能被删除掉。所以内核的做法就是每次调用网卡发送的时候，实际上传递出去的是skb的一个拷贝</strong>。等收到ACK再真正删除。</p><p>第二件事是修<strong>改skb的TCP头</strong>，根据实际情况把TCP头设置好。实际上<strong>skb内部包含了网络协议中所有的头，在设置TCP头的时候，只是把指针指向skb合适的位置</strong>。后面设置IP头的时候，再把指针挪动一下即可，避免了频繁的内存申请和拷贝，提高效率。</p><p>tcp_transmit_skb是发送数据位于传输层的最后一步，调用了网络层提供的发送接口icsk-&gt;icsk_Af_ops-&gt;queue_xmit()之后就可以进入网络层进行下一层的操作了。</p><h4 id="3）网络层发送处理"><a href="#3）网络层发送处理" class="headerlink" title="3）网络层发送处理"></a>3）网络层发送处理</h4><p><img src="/posts/34895/7977866705463715655.png" alt></p><p>在tcp_ipv4中，queue_xmit指向的是ip_queue_xmit，具体实现如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">ip_queue_xmit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">struct</span> flowi <span class="token operator">*</span>fl<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 检查socket中是否有缓存的路由表</span>
    rt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> rtable<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">__sk_dst_check</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>rt <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 没有缓存则展开查找路由项并缓存到socket中</span>
    rt <span class="token operator">=</span> <span class="token function">ip_route_output_ports</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token function">sk_setup_caps</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rt<span class="token operator">-></span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 为skb设置路由表</span>
    <span class="token function">skb_dst_set_noref</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rt<span class="token operator">-></span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 设置IP头</span>
    iph <span class="token operator">=</span> <span class="token function">ip_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ip<span class="token operator">-></span>protocol <span class="token operator">=</span> sk<span class="token operator">-></span>sk_protocol<span class="token punctuation">;</span>
    iph<span class="token operator">-></span>ttl <span class="token operator">=</span> <span class="token function">ip_select_ttl</span><span class="token punctuation">(</span>inet<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rt<span class="token operator">-></span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ip<span class="token operator">-></span>frag_off <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
    <span class="token function">ip_copy_addr</span><span class="token punctuation">(</span>iph<span class="token punctuation">,</span> f14<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    <span class="token comment" spellcheck="true">// 发送</span>
    <span class="token function">ip_local_out</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个函数主要做的就是<strong>找到该把这个包发往哪，并构造好IP包头</strong>。它会去查询socket中是否有缓存的路由表，如果有则直接构造包头，如果没有就去查询并缓存到sokect，然后为skb设置路由表，最后封装ip头，发往ip_local_out函数。</p><p>ip_local_out中主要会经过__ip_local_out =&gt; nf_hook 的过程<strong>进行netfilter的过滤</strong>。如果使用iptables配置了一些规则，那么这里将检测到是否命中规则，然后进行相应的操作，如网络地址转换、数据包内容修改、数据包过滤等。如果设置了非常复杂的netfilter规则，则在这个函数会导致进程CPU的开销大增。经过netfilter处理之后，（忽略其他部分）调用dst_output(skb)函数。</p><p>dst_output会去调用skb_dst(skb)-&gt;output(skb)，即<strong>找到skb的路由表</strong>（dst条目），然后<strong>调用路由表的output方法</strong>。这里是个函数指针，指向的是ip_output方法。</p><p>在ip_output方法中首先会进行一些<strong>简单的统计工作</strong>，随后<strong>再次执行netfilter过滤</strong>。过滤通过之后<strong>回调ip_finish_output</strong>。</p><p>在ip_finish_output中，会<strong>校验数据包的长度，如果大于MTU，就会执行分片</strong>。MTU的大小是通过MTU发现机制确定，在以太网中为1500字节。分片会带来两个问题：</p><ol><li>需要进行额外的处理，会有性能开销</li><li>只要一个分片丢失，整个包都要重传</li></ol><p>如果不需要分片则调用ip_finish_output2函数，根据下一跳的IP地址查找邻居项，找不到就创建一个，然后发给下一层——邻居子系统。</p><p>总体过程如下：</p><ol><li>ip_queue_xmit<ol><li>查找并设置路由项</li><li>设置IP头</li></ol></li><li>ip_local_out：netfilter过滤</li><li>ip_output<ol><li>统计工作</li><li>再次netfilter过滤</li></ol></li><li>ip_finish_output<ol><li>大于MTU的话进行分片</li><li>调用ip_finish_output2</li></ol></li></ol><h4 id="4）邻居子系统"><a href="#4）邻居子系统" class="headerlink" title="4）邻居子系统"></a>4）邻居子系统</h4><p><img src="/posts/34895/698520973817362620.png" alt></p><p><strong>邻居子系统是位于网络层和数据链路层中间的一个系统，其作用是为网络层提供一个下层的封装，让网络层不用关心下层的地址信息，让下层来决定发送到哪个MAC地址。</strong></p><blockquote><p>邻居子系统不位于协议栈net/ipv4/目录内，而是位于net/core/neighbour.c，因为无论对于ipv4还是ipv6都需要使用该模块</p></blockquote><p>在邻居子系统中主要<strong>查找或者创建邻居项</strong>，在创建邻居项时有可能会发出实际的arp请求。然后<strong>封装MAC头</strong>，将发生过程再<strong>传递给更下层的网络设备子系统</strong>。</p><p>ip_finish_output2的实现逻辑大致流程如下：</p><ol><li>rt_nexthop：<strong>获取路由下一跳的IP信息</strong></li><li>__ipv4_neigh_lookup_noref：<strong>根据下一条IP信息在arp缓存中查找邻居项</strong></li><li>__neigh_create：<strong>创建一个邻居项，并加入邻居哈希表</strong></li><li>dst_neight_output =&gt; neighbour-&gt;output（实际指向neigh_resolve_output）：<ol><li><strong>封装MAC头（可能会先触发arp请求）</strong></li><li><strong>调用dev_queue_xmit发送到下层</strong></li></ol></li></ol><h4 id="5）网络设备子系统"><a href="#5）网络设备子系统" class="headerlink" title="5）网络设备子系统"></a>5）网络设备子系统</h4><p>邻居子系统通过dev_queue_xmit进入网络设备子系统，dev_queue_xmit的工作逻辑如下</p><ol><li><strong>选择发送队列</strong></li><li><strong>获取排队规则</strong></li><li><strong>存在队列则调用__dev_xmit_skb继续处理</strong></li></ol><p>在前面讲过，网卡是有多个发送队列的，所以首先需要选择一个队列进行发送。队列的选择首先是通过获取用户的XPS配置（为队列绑核），如果没有配置则调用skb_tx_hash去计算出选择的队列。接着会根据与此队列关联的qdisc得到该队列的排队规则。</p><p><img src="/posts/34895/3920606513907107361.png" alt></p><p>最后会根据是否存在队列（如果是发给回环设备或者隧道设备则没有队列）来决定后续数据包流向。对于存在队列的设备会进入__dev_xmit_skb函数。</p><blockquote><p>在Linux网络子系统中，qdisc（Queueing Discipline，队列规则）是一个用于管理网络包排队和发送的核心组件。它决定了网络包在发送队列中的排列顺序，以及何时从队列中取出包进行发送。qdisc还可以应用于网络流量控制，包括流量整形（traffic shaping）、流量调度（traffic scheduling）、流量多工（traffic multiplexing）等。</p><p>Linux提供了许多预定义的qdisc类型，包括：</p><ul><li>pfifo_fast：这是默认的qdisc类型，提供了基本的先入先出（FIFO）队列行为。</li><li>mq：多队列时的默认类型，本身并不进行任何数据包的排队或调度，而是为网络设备的每个发送队列创建和管理一个子 qdisc。</li><li>tbf (Token Bucket Filter)：提供了基本的流量整形功能，可以限制网络流量的速率。</li><li>htb (Hierarchical Token Bucket)：一个更复杂的流量整形qdisc，可以支持多级队列和不同的流量类别。</li><li>sfq (Stochastic Fairness Queueing)：提供了公平队列调度，可以防止某一流量占用过多的带宽。</li></ul><p>每个网络设备（如eth0、eth1等）都有一个关联的qdisc，用于管理这个设备的发送队列。用户可以通过tc（traffic control）工具来配置和管理qdisc。</p><p>对于支持多队列的网卡，Linux内核为发送和接收队列分别分配一个qdisc。每个qdisc独立管理其对应的队列，包括决定队列中的数据包发送顺序，应用流量控制策略等。这样，可以实现每个队列的独立调度和流量控制，提高整体网络性能。</p><p>我们可以说，<strong>对于支持多队列的网卡，内核中的每个发送队列都对应一个硬件的发送队列（也就是 Ring Buffer）</strong>。选择哪个内核发送队列发送数据包，也就决定了数据包将被放入哪个 Ring Buffer。<strong>数据包从 qdisc 的发送队列出队后，会被放入 Ring Buffer，然后由硬件发送到网络线路上。所以，Ring Buffer 在发送路径上位于发送队列之后。</strong></p><p>将struct sock的发送队列和网卡的Ring Buffer之间设置一个由qdisc（队列规则）管理的发送队列，可以提供更灵活的网络流量控制和调度策略，以适应不同的网络环境和需求。</p><p>下面是一些具体的原因：</p><ol><li><strong>流量整形和控制</strong>：qdisc可以实现各种复杂的排队规则，用于控制数据包的发送顺序和时间。这可以用于实现流量整形（比如限制数据的发送速率以避免网络拥塞）和流量调度（比如按照优先级或服务质量（QoS）要求来调度不同的数据包）。</li><li><strong>对抗网络拥塞</strong>：qdisc可以通过管理发送队列，使得在网络拥塞时可以控制数据的发送，而不是简单地将所有数据立即发送出去，这可以避免网络拥塞的加剧。</li><li><strong>公平性</strong>：在多个网络连接共享同一个网络设备的情况下，qdisc可以确保每个连接得到公平的网络带宽，而不会因为某个连接的数据过多而饿死其他的连接。</li><li><strong>性能优化</strong>：qdisc可以根据网络设备的特性（例如，对于支持多队列（Multi-Queue）的网卡）和当前的网络条件来优化数据包的发送，以提高网络的吞吐量和性能。</li></ol></blockquote><p>__dev_xmit_skb分为三种情况：</p><ol><li>qdisc停用：释放数据并返回代码设置为NET_XMIT_DROP</li><li>qdisc允许绕过排队系统&amp;&amp;没有其他包要发送&amp;&amp;qdisc没有运行：绕过排队系统，调用sch_direct_xmit发送数据</li><li>其他情况：正常排队<ol><li>调用q-&gt;enqueue入队</li><li>调用__qdisc_run开始发送</li></ol></li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">__qdisc_run</span><span class="token punctuation">(</span><span class="token keyword">struct</span> Qdisc <span class="token operator">*</span>q<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> quota <span class="token operator">=</span> weight_p<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 循环从队列取出一个skb并发送</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">qdisc_restart</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 如果quota耗尽或其他进程需要CPU则延后处理</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">--</span>quota <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> need_resched<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 将触发一次NET_TX_SOFTIRQ类型的softirq</span>
        <span class="token function">__netif_shcedule</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上述代码中可以看到，<strong>while循环不断地从队列中取出skb并进行发送，这个时候其实占用的都是用户进程系统态时间sy，只有当quota用尽或者其他进程需要CPU的时候才触发软中断进行发送</strong>。</p><p>这就是为什么服务器上查看/proc/softirqs，一般NET_RX要比NET_TX大得多的原因。<strong>对于接收来说，都要经过NET_RX软中断，而对于发送来说，只有系统配额用尽才让软中断上</strong>。</p><p>这里我们聚焦于qdisc_restart函数上，这个函数用于从qdisc队列中取包并发给网络驱动</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">qdisc_restart</span><span class="token punctuation">(</span><span class="token keyword">struct</span> Qdisc <span class="token operator">*</span>q<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb <span class="token operator">=</span> <span class="token function">dequeue_skb</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>skb<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> <span class="token function">sch_direct_xmit</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> q<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> txq<span class="token punctuation">,</span> root_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先调用 dequeue_skb() <strong>从 qdisc 中取出要发送的 skb</strong>。如果队列为空，返回 0， 这将导致上层的 qdisc_restart() 返回 false，继而退出 while 循环。</p><p>如果拿到了skb则<strong>调用sch_direct_xmit继续发送</strong>，该函数会<strong>调用dev_hard_start_xmit，进入驱动程序发包，如果无法发送则重新入队</strong>。</p><p>即整个__qdisc_run的整体逻辑为：while 循环调用 qdisc_restart()，后者取出一个 skb，然后尝试通过 sch_direct_xmit() 来发送；sch_direct_xmit 调用 dev_hard_start_xmit 来向驱动程序进行实际发送。任何无法发送的 skb 都重新入队，将在 NET_TX softirq 中进行发送。</p><h4 id="6）软中断调度"><a href="#6）软中断调度" class="headerlink" title="6）软中断调度"></a>6）软中断调度</h4><p>上一部分中如果发送网络包的时候CPU耗尽了，会调用进入<strong>netif_schedule，该函数会进入</strong>netif_reschedule，<strong>将发送队列设置到softnet_data上，并最终发出一个NET_TX_SOFTIRQ类型的软中断</strong>。软中断是由内核进程运行的，该进程会进入net_tx_action函数，在该函数中能<strong>获得发送队列，并最终也调用到驱动程序的入口函数dev_hard_start_xmit</strong>。</p><p><img src="/posts/34895/8847982115340149470.png" alt></p><p>从触发软中断开始以后发送数据消耗的CPU就都显示在si中，而不会消耗用户进程的系统时间</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">net_tx_action</span><span class="token punctuation">(</span><span class="token keyword">struct</span> softirq_action <span class="token operator">*</span>h<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> softnet_data <span class="token operator">*</span>sd <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">__get_cpu_var</span><span class="token punctuation">(</span>softnet_data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 如果softnet_data设置了发送队列</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>sd<span class="token operator">-></span>output_queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment" spellcheck="true">// 将head指向第一个qdisc</span>
       head <span class="token operator">=</span> sd<span class="token operator">-></span>output_queue<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 遍历所有发送队列</span>
       <span class="token keyword">while</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> Qdisc <span class="token operator">*</span>q <span class="token operator">=</span> head<span class="token punctuation">;</span>
         head <span class="token operator">=</span> head<span class="token operator">-></span>next_sched<span class="token punctuation">;</span>
         <span class="token comment" spellcheck="true">// 处理数据</span>
        <span class="token function">qdisc_run</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">qdisc_run</span><span class="token punctuation">(</span><span class="token keyword">struct</span> Qdisc <span class="token operator">*</span>q<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">qdisc_run_begin</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span>
     <span class="token function">__qdisc_run</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到软中断的处理中，最后和前面一样都是调用了<strong>qdisc_run。也就是说不管是在qdisc_restart中直接处理，还是软中断来处理，最终实际都会来到dev_hard_start_xmit（</strong>qdisc_run =&gt; qdisc_restart =&gt; dev_hard_start_xmit）。</p><h4 id="7）igb网卡驱动发送"><a href="#7）igb网卡驱动发送" class="headerlink" title="7）igb网卡驱动发送"></a>7）igb网卡驱动发送</h4><p>通过前面的介绍可知，<strong>无论对于用户进程的内核态，还是对于软中断上下文，都会调用网络设备子系统的dev_hard_start_xmit函数</strong>，在这个函数中，会<strong>调用驱动里的发送函数igb_xmit_frame</strong>。在驱动函数里，会<strong>将skb挂到RingBuffer上</strong>，驱动调用完毕，<strong>数据包真正从网卡发送出去</strong>。</p><p><img src="/posts/34895/2639590539896627397.png" alt></p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">dev_hard_start_xmit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">struct</span> net_device <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token keyword">struct</span> netdev_queue <span class="token operator">*</span>txq<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 获取设备的回调函数ops</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> net_device_ops <span class="token operator">*</span> ops <span class="token operator">=</span> dev<span class="token operator">-></span>netdev_ops<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 获取设备支持的功能列表</span>
    features <span class="token operator">=</span> <span class="token function">netif_skb_features</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 调用驱动的ops里的发送回调函数ndo_start_xmit将数据包传给网卡设备</span>
    skb_len <span class="token operator">=</span> skb<span class="token operator">-></span>len<span class="token punctuation">;</span>
    rc <span class="token operator">=</span> ops<span class="token operator">-></span><span class="token function">ndo_start_xmit</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里ndo_start_xmit是网卡驱动要实现的函数，igb网卡驱动中的实现是igb_xmit_frame（在网卡驱动程序初始化的时候赋值的）。igb_xmit_frame主要会去调用igb_xmit_frame_ring函数</p><p><img src="/posts/34895/1444488744580676143.png" alt></p><pre class="line-numbers language-c"><code class="language-c">netdev_tx_t <span class="token function">igb_xmit_frame_ring</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">struct</span> igb_ring <span class="token operator">*</span>tx_ring<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 获取TX queue中下一个可用缓冲区的信息</span>
    first <span class="token operator">=</span> <span class="token operator">&amp;</span>tx_ring<span class="token operator">-></span>tx_buffer_info<span class="token punctuation">[</span>tx_ring<span class="token operator">-></span>next_to_use<span class="token punctuation">]</span><span class="token punctuation">;</span>
    first<span class="token operator">-></span>skb <span class="token operator">=</span> skb<span class="token punctuation">;</span>
    first<span class="token operator">-></span>bytecount <span class="token operator">=</span> skb<span class="token operator">-></span>len<span class="token punctuation">;</span>
    first<span class="token operator">-></span>gso_segs <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 准备给设备发送的数据</span>
    <span class="token function">igb_tx_map</span><span class="token punctuation">(</span>tx_ring<span class="token punctuation">,</span> first<span class="token punctuation">,</span> hdr_len<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">igb_tx_map</span><span class="token punctuation">(</span><span class="token keyword">struct</span> igb_ring <span class="token operator">*</span>tx_ring<span class="token punctuation">,</span> <span class="token keyword">struct</span> igb_tx_buffer <span class="token operator">*</span>first<span class="token punctuation">,</span> <span class="token keyword">const</span> u8 hdr_len<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 获取下一个可用的描述符指针</span>
    tx_desc <span class="token operator">=</span> <span class="token function">IGB_TX_DESC</span><span class="token punctuation">(</span>tx_ring<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 为skb->data构造内存映射，以允许设备通过DMA从RAM中读取数据</span>
    dma <span class="token operator">=</span> <span class="token function">dma_map_single</span><span class="token punctuation">(</span>tx_ring<span class="token operator">-></span>dev<span class="token punctuation">,</span> skb<span class="token operator">-></span>data<span class="token punctuation">,</span> size<span class="token punctuation">,</span> DMA_TO_DEVICE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 遍历该数据包的所有分片，为skb的每个分片生成有效映射</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>frag <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">skb_shinfo</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-></span>frags<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> flag<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    tx_desc<span class="token operator">-></span>read<span class="token punctuation">.</span>buffer_addr <span class="token operator">=</span> <span class="token function">cpu_to_le64</span><span class="token punctuation">(</span>dma<span class="token punctuation">)</span><span class="token punctuation">;</span>
        tx_desc<span class="token operator">-></span>read<span class="token punctuation">.</span>cmd_type_len <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
      tx_desc<span class="token operator">-></span>read<span class="token punctuation">.</span>olinfo_status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 设置最后一个descriptor</span>
    cmd_type <span class="token operator">|</span><span class="token operator">=</span> size <span class="token operator">|</span> IGB_TXD_DCMD<span class="token punctuation">;</span>
    tx_desc<span class="token operator">-></span>read<span class="token punctuation">.</span>cmd_type_len <span class="token operator">=</span> <span class="token function">cpu_to_le32</span><span class="token punctuation">(</span>cmd_type<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>在这里从网卡的发送队列的RingBuffer上取下来一个元素，并将skb挂到元素上。然后使用igb_tx_map函数将skb数据映射到网卡可访问的内存DMA区域。</strong></p><blockquote><p>这里可以理解为&amp;tx_ring-&gt;tx_buffer_info[tx_ring-&gt;next_to_use]拿到了RingBuffer发送队列中指针数组（前文提到的igb_tx_buffer，网卡启动的时候创建的供内核使用的数组）的下一个可用的元素，然后为其填充skb、byte_count等数据。</p><p>填充完成之后，获取描述符数组（前文提到的e1000_adv_tx_desc，网卡启动的时候创建的供网卡使用的数组）的下一个可用元素。</p><p>调用dma_map_single函数创建内存和设备之间的DMA映射，tx_ring-&gt;dev是设备的硬件描述符，即网卡，skb-&gt;data是要映射的地址，size是映射的数据的大小，即数据包的大小，DMA_TO_DEVICE是指映射的方向，这里是数据将从内存传输到设备，返回的调用结果是一个DMA地址，存储在dma变量中，设备可以直接通过这个地址访问到skb的数据。</p><p>最后就是为前面拿到的描述符填充信息，将dma赋值给buffer_addr，网卡使用的时候就是从这里拿到数据包的地址。</p></blockquote><p>当所有需要的描述符都建好，且skb的所有数据都映射到DMA地址后，驱动就会进入到它的最后一步，触发真实的发送。</p><blockquote><p>到目前为止我们可以这么理解：</p><p>应用程序将数据发送到 socket，这些数据会被放入与 sock 中的发送队列。然后，网络协议栈（例如 TCP 或 UDP）将这些数据从 socket 的发送队列中取出，往下层封装，然后将这些数据包放入由 qdisc 管理的设备发送队列中。最后，这些数据包将从设备发送队列出队，放置到RingBuffer的指针数组中，通过dma将数据包的地址映射到可供网卡访问的内存DMA区域，由硬件读取后发送到网络上。</p></blockquote><h3 id="4）RingBuffer内存回收"><a href="#4）RingBuffer内存回收" class="headerlink" title="4）RingBuffer内存回收"></a>4）RingBuffer内存回收</h3><p>当数据发送完以后，其实工作并没有结束，因为内存还没有清理。<strong>当发送完成的时候，网卡设备会触发一个硬中断（硬中断会去触发软中断）来释放内存</strong>。</p><p><img src="/posts/34895/8196118784844985864.png" alt></p><p>这里需要注意的就是，<strong>虽然是数据发送完成通知，但是硬中断触发的软中断是NET_RX_SOFTIRQ</strong>，这也就是为什么软中断统计中RX要高于TX的另一个原因。</p><p>硬中断中会向softnet_data添加poll_list，<strong>软中断中轮询后调用其poll回调函数</strong>，具体实现是igb_poll，其会<strong>在q_vector-&gt;tx.ring存在时去调用igb_clean_tx_irq</strong>。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> bool <span class="token function">igb_clean_tx_irq</span><span class="token punctuation">(</span><span class="token keyword">struct</span> igb_q_vector <span class="token operator">*</span>q_vector<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 释放skb</span>
    <span class="token function">dev_kfree_skb_any</span><span class="token punctuation">(</span>tx_buffer<span class="token operator">-></span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 清除tx_buffer数据</span>
    tx_buffer<span class="token operator">-></span>skb <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 将tx_buffer指定的DMA缓冲区的长度设置为0</span>
    <span class="token function">dma_unmap_len_set</span><span class="token punctuation">(</span>tx_buffer<span class="token punctuation">,</span> len <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 清除最后的DMA位置，解除映射</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>tx_desc <span class="token operator">!=</span> eop_desc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实逻辑无非就是清理了skb（其中data保存的数据包没有释放），解决了DMA映射等，到了这一步传输才算基本完成。</p><p>当然因为传输层需要保证可靠性，所以数据包还没有删除，此时还有前面的拷贝过的skb指向它，它得等到收到对方的ACK之后才会真正删除。</p><p><img src="/posts/34895/8261733188501617381.png" alt></p><h3 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h3><ol><li>查看内核发送数据消耗的CPU时应该看sy还是si<ul><li>在网络包发送过程中，用户进程（在内核态）完成了绝大部分的工作，甚至连调用驱动的工作都干了。只有当内核态进程被切走前才会发起软中断。发送过程中百分之九十以上的开销都是在用户进程内核态消耗掉的，只有一少部分情况才会触发软中断，有软中断ksoftirqd内核线程来发送。</li><li>所以在监控网络IO对服务器造成的CPU开销的时候，不能近看si，而是应该把si、sy（内核占用CPU时间比例）都考虑进来。</li></ul></li><li>在服务器上查看/proc/softirqs，为什么NET_RX要比NET_TX大得多<ul><li>对于读来说，都是要经过NET_RX软中断的，都走ksoftirqd内核线程。而对于发送来说，绝大部份工作都是在用户进程内核态处理了，只有系统态配额用尽才会发出NET_TX，让软中断处理。</li><li>当数据发送完以后，通过硬中断的方式来通知驱动发送完毕。但是硬中断无论是有数据接收还是发送完毕，触发的软中断都是NET_RX_SOFTIRQ而不是NET_TX_SOFTIRQ。</li></ul></li><li>发送网络数据的时候都涉及那些内存拷贝操作<ul><li>这里只指内存拷贝</li><li>内核申请完skb之后，将用户传递进来的buffer里的数据拷贝到skb。如果数据量大，这个拷贝操作还是开销不小的。</li><li>从传输层进入网络层时。每个skb都会被克隆出一个新的副本，目的是保存原始的skb，当网络对方没有发挥ACK的时候还可以重新发送，易实现TCP中要求的可靠传输。不过这次只是浅拷贝，只拷贝skb描述符本身，所指向的数据还是复用的。</li><li>第三次拷贝不是必须的，只有当IP层发现skb大于MTU时才需要进行，此时会再申请额外的skb，并将原来的skb拷贝成多个小的skb。</li></ul></li><li>零拷贝到底是怎么回事<ul><li>如果想把本机的一个文件通过网络发送出去，需要先调用read将文件读到内存，之后再调用send将文件发送出去</li><li>假设数据之前没有读去过，那么read系统调用需要两次拷贝才能到用户进程的内存。第一次是从硬盘DMA到Page Cache。第二次是从Page Cache拷贝到内存。send系统调用也同理，先CPU拷贝到socket发送队列，之后网卡进行DMA拷贝。</li><li>如果要发送的数据量较大，那么就需要花费不少的时间在数据拷贝上。而sendfile就是内核提供的一个可用来减少发送文件时拷贝开销的一个技术方案。在sendfile系统调用里，数据不需要拷贝到用户空间，在内核态就能完成发送处理，减少了拷贝的次数。</li></ul></li></ol></div><hr><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/tags/Linux/"><span class="chip bg-color">Linux</span> </a><a href="/tags/C/"><span class="chip bg-color">C</span> </a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="chip bg-color">计算机网络</span> </a><a href="/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"><span class="chip bg-color">源码阅读</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="wechat,qq" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="/libs/share/js/social-share.min.js"></script></div></div></div></div></div><style>.valine-card{margin:1.5rem auto}.valine-card .card-content{padding:20px 20px 5px 20px}#vcomments textarea{box-sizing:border-box;background:url(/medias/comment_bg.png) 100% 100% no-repeat}#vcomments p{margin:2px 2px 10px;font-size:1.05rem;line-height:1.78rem}#vcomments blockquote p{text-indent:.2rem}#vcomments a{padding:0 2px;color:#4cbf30;font-weight:500;text-decoration:none}#vcomments img{max-width:100%;height:auto;cursor:pointer}#vcomments ol li{list-style-type:decimal}#vcomments ol,ul{display:block;padding-left:2em;word-spacing:.05rem}#vcomments ul li,ol li{display:list-item;line-height:1.8rem;font-size:1rem}#vcomments ul li{list-style-type:disc}#vcomments ul ul li{list-style-type:circle}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}#vcomments table,td,th{border:0}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments h1{font-size:1.85rem;font-weight:700;line-height:2.2rem}#vcomments h2{font-size:1.65rem;font-weight:700;line-height:1.9rem}#vcomments h3{font-size:1.45rem;font-weight:700;line-height:1.7rem}#vcomments h4{font-size:1.25rem;font-weight:700;line-height:1.5rem}#vcomments h5{font-size:1.1rem;font-weight:700;line-height:1.4rem}#vcomments h6{font-size:1rem;line-height:1.3rem}#vcomments p{font-size:1rem;line-height:1.5rem}#vcomments hr{margin:12px 0;border:0;border-top:1px solid #ccc}#vcomments blockquote{margin:15px 0;border-left:5px solid #42b983;padding:1rem .8rem .3rem .8rem;color:#666;background-color:rgba(66,185,131,.1)}#vcomments pre{font-family:monospace,monospace;padding:1.2em;margin:.5em 0;background:#272822;overflow:auto;border-radius:.3em;tab-size:4}#vcomments code{font-family:monospace,monospace;padding:1px 3px;font-size:.92rem;color:#e96900;background-color:#f8f8f8;border-radius:2px}#vcomments pre code{font-family:monospace,monospace;padding:0;color:#e8eaf6;background-color:#272822}#vcomments pre[class*=language-]{padding:1.2em;margin:.5em 0}#vcomments code[class*=language-],pre[class*=language-]{color:#e8eaf6}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}#vcomments b,strong{font-weight:700}#vcomments dfn{font-style:italic}#vcomments small{font-size:85%}#vcomments cite{font-style:normal}#vcomments mark{background-color:#fcf8e3;padding:.2em}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}.v .vlist .vcard{padding-top:2.5em!important}</style><div class="card valine-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;left:20px;top:15px;padding-bottom:5px"><i class="fa fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="vcomments" class="card-content" style="display:grid"></div></div><script src="/libs/valine/av-min.js"></script><script src="/libs/valine/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"98JpzSGcrl9jFqHO13vqxHvX-gzGzoHsz",appKey:"mDmr2h9PB20xvPMNqgyRnNIC",notify:!0,verify:!0,visitor:!0,avatar:"mm",pageSize:"10",lang:"zh-cn",placeholder:"just go go"})</script><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fa fa-chevron-left"></i>&nbsp;上一篇</div><div class="card"><a href="/posts/24283/"><div class="card-image"><img src="/medias/featureimages/17.jpg" class="responsive-img" alt="当Redis碰上消息队列"> <span class="card-title">当Redis碰上消息队列</span></div></a><div class="card-content article-content"><div class="summary block-with-text">Redis当作队列来用?</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2024-04-02 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/Redis/" class="post-category">Redis</a></span></div></div><div class="card-action article-tags"><a href="/tags/Redis/"><span class="chip bg-color">Redis</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fa fa-chevron-right"></i></div><div class="card"><a href="/posts/14820/"><div class="card-image"><img src="/medias/featureimages/24.jpg" class="responsive-img" alt="Cpp的异常处理额外开销是个啥"> <span class="card-title">Cpp的异常处理额外开销是个啥</span></div></a><div class="card-content article-content"><div class="summary block-with-text">唉，异常</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2024-04-01 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/Cpp/" class="post-category">Cpp</a></span></div></div><div class="card-action article-tags"><a href="/tags/Cpp/"><span class="chip bg-color">Cpp</span> </a><a href="/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"><span class="chip bg-color">原理剖析</span></a></div></div></div></div></article></div><script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script><script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script><script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script><script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget"><div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fa fa-list"></i></a></div><script src="/libs/tocbot/tocbot.min.js"></script><script>$(function(){tocbot.init({tocSelector:"#toc-content",contentSelector:"#articleContent",headingsOffset:-(.4*$(window).height()-45),headingSelector:"h2, h3, h4, h5"});let t=0;var e="toc-heading-";$("#toc-content a").each(function(){$(this).attr("href","#"+e+ ++t)}),t=0,$("#articleContent").children("h2, h3, h4, h5").each(function(){$(this).attr("id",e+ ++t)});var n=parseInt(.4*$(window).height()-64);let o=$(".toc-widget");$(window).scroll(function(){var t=$(window).scrollTop();n<t?o.addClass("toc-fixed"):o.removeClass("toc-fixed")});var i="expanded";let a=$("#toc-aside"),c=$("#main-content");$("#floating-toc-btn .btn-floating").click(function(){a.hasClass(i)?(a.removeClass(i).hide(),c.removeClass("l9")):(a.addClass(i).show(),c.addClass("l9")),function(){let e=$("#artDetail");if(0!==e.length){let t=e.width();450<=t?t+=21:350<=t&&t<450?t+=18:300<=t&&t<350?t+=16:t+=14,$("#prenext-posts").width(t)}}()})})</script></main><footer class="page-footer bg-color"><div class="container row center-align"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2019</span> <a href="/about" rel="external nofollow noreferrer">JoyTsing</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br><span id="sitetime">载入运行时间...</span> <span id="busuanzi_container_site_pv">|&nbsp;<i class="fa fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span>&nbsp;次 </span><span id="busuanzi_container_site_uv">|&nbsp;<i class="fa fa-user"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv" class="white-color"></span>&nbsp;人</span><br>&nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;<span class="white-color">607.8k</span>&nbsp;字 <span id="icp"><img src="/medias/icp.png" style="vertical-align:text-bottom" alt="icp"> <a href="https://beian.miit.gov.cn/" target="_blank">陕公网安备61019002002862号 滇ICP备2024026466号-1</a></span><script>function siteTime(){var e=864e5,t="2019",n=(m=new Date).getFullYear(),o=m.getMonth()+1,r=m.getDate(),a=m.getHours(),i=m.getMinutes(),l=m.getSeconds(),m=Date.UTC(t,"7","24","0","0","0"),r=Date.UTC(n,o,r,a,i,l)-m,a=Math.floor(r/31536e6),i=Math.floor(r/e-365*a),l=Math.floor((r-(365*a+i)*e)/36e5),m=Math.floor((r-(365*a+i)*e-36e5*l)/6e4),M=Math.floor((r-(365*a+i)*e-36e5*l-6e4*m)/1e3);t==n?(document.getElementById("year").innerHTML=n,document.getElementById("sitetime").innerHTML="本站已安全运行 "+i+" 天 "+l+" 小时 "+m+" 分钟 "+M+" 秒"):(document.getElementById("year").innerHTML=t+" - "+n,document.getElementById("sitetime").innerHTML="本站已安全运行 "+a+" 年 "+i+" 天 "+l+" 小时 "+m+" 分钟 "+M+" 秒")}setInterval(siteTime,1e3)</script></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/JoyTsing" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fa fa-github"></i> </a><a href="/medias/wechat.jpg" target="_blank" data-tooltip="添加我的微信: [object Object]" data-position="top" data-delay="50"><i class="fa fa-weixin"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script src="/js/search.js"></script><script type="text/javascript">$(function(){searchFunc("/search.xml","searchInput","searchResult")})</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fa fa-angle-up"></i></a></div><script src="/libs/materialize/materialize.min.js"></script><script src="/libs/masonry/masonry.pkgd.min.js"></script><script src="/libs/aos/aos.js"></script><script src="/libs/scrollprogress/scrollProgress.min.js"></script><script src="/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="/js/matery.js"></script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?3a39d92b69933ae56c7eb41ffb9aa2e0";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js",(e=document.getElementsByTagName("script")[0]).parentNode.insertBefore(t,e)}()</script><script async src="/libs/others/busuanzi.pure.mini.js"></script><script type="text/javascript">var st,OriginTitile=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="(oﾟvﾟ)ノ Hi",clearTimeout(st)):(document.title="(*´∇｀*) 欢迎回来！",st=setTimeout(function(){document.title=OriginTitile},3e3))})</script><script type="text/javascript" color="0,0,255" pointcolor="0,0,255" opacity="0.8" zindex="-1" count="150" src="/libs/background/canvas-nest.js"></script><script src="/libs/instantpage/instantpage.js" type="module"></script><script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script><script>const hasAttr = (e,a) => a.some(_=> e.attr(_)!==undefined);
        $('a').each(function() {
          const $this = $(this);
          if(hasAttr($this,["data-fancybox","ignore-external-link"])) return;
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== '' || window.location.host) {
                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/shizuku.model.json"},display:{position:"left",width:150,height:200},mobile:{show:!1},react:{opacity:.7}})</script></body></html>