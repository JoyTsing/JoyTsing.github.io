<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="深入理解Linux网络学习笔记(七), joytsing blog"><meta name="description" content="TCP连接的开销有多大？"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="theme-color" content="white"><title>深入理解Linux网络学习笔记(七) | JoyTsing</title><link rel="apple-touch-icon" href="/"><link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="/favicon.ico"><link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css"><link rel="stylesheet" type="text/css" href="/libs/aos/aos.css"><link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css"><link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" type="text/css" href="/css/matery.css"><link rel="stylesheet" type="text/css" href="/css/my.css"><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style><script src="/libs/jquery/jquery.min.js"></script><script src="https://cdn-go.cn/aegis/aegis-sdk/latest/aegis.min.js"></script><script>const aegis=new Aegis({id:"6ojk8FlnQlqWeL6vQo",uin:"joyblog",reportApiSpeed:!0,reportAssetSpeed:!0,spa:!0,hostUrl:"https://rumt-sg.com"});console.log("aegis load")</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="JoyTsing" type="application/atom+xml"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><img src="/apple-touch-icon.png" class="logo-img" alt="LOGO"> <span class="logo-span">JoyTsing</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fa fa-home"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-tags"></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-bookmark"></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-archive"></i> <span>归档</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa fa-user-circle-o"></i> <span>关于</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa fa-envelope"></i> <span>留言</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa fa-address-book"></i> <span>友链</span></a></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fa fa-search" title="搜索"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="/medias/avatars/touxiang2.jpg" class="logo-img circle responsive-img"><div class="logo-name">JoyTsing</div><div class="logo-desc">joytsing的个人网站</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="m-nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-fw fa-bookmark"></i> 分类</a></li><li class="m-nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li class="m-nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa fa-fw fa-user-circle-o"></i> 关于</a></li><li class="m-nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa fa-fw fa-envelope"></i> 留言</a></li><li class="m-nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa fa-fw fa-address-book"></i> 友链</a></li><li><div class="divider"></div></li><li><a href="https://github.com/JoyTsing" class="waves-effect waves-light" target="_blank"><i class="fa fa-github-square fa-fw"></i>Follow Me</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#000;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href="https://github.com/JoyTsing" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Follow Me" data-position="left" data-delay="50"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a></nav></header><div class="bg-cover pd-header post-cover" style="background-image:url(/medias/featureimages/6.jpg)"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">深入理解Linux网络学习笔记(七)</h1></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{width:345px;padding-left:20px}.toc-widget .toc-title{margin:35px 0 15px 0;padding-left:17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content{height:calc(100vh - 250px);overflow:auto}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px;position:absolute;right:23.5vw;display:block}#toc-content .is-active-link{color:#42b983}#floating-toc-btn{position:fixed;right:15px;bottom:76px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="chip bg-color">计算机网络</span> </a><a href="/tags/Linux/"><span class="chip bg-color">Linux</span> </a><a href="/tags/C/"><span class="chip bg-color">C</span> </a><a href="/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"><span class="chip bg-color">源码阅读</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-category">计算机网络</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp; 2024-04-09</div><div class="post-date info-break-policy"><i class="fa fa-calendar-check-o fa-fw"></i>更新日期:&nbsp;&nbsp; 2024-05-14</div><div class="info-break-policy"><i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp; 9.4k</div><div class="info-break-policy"><i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp; 34 分</div><div id="busuanzi_container_page_pv" class="info-break-policy"><i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp; <span id="busuanzi_value_page_pv"></span></div></div></div><hr class="clearfix"><div class="card-content article-card-content"><div id="articleContent"><p>在应用程序里，我们使用多少内存都是自己能掌握和控制的，但是纵观Linux整台服务器，除了应用程序以外，内核也会申请和管理大量的内存。</p><h3 id="一、相关实际问题"><a href="#一、相关实际问题" class="headerlink" title="一、相关实际问题"></a>一、相关实际问题</h3><ol><li>内核是如何管理内存的</li><li>如何查看内核使用的内存信息</li><li>服务器上一条ESTABLISH状态的空连接需要消耗多少内存</li><li>机器上出现了3万多个TIME_WAIT，内存开销会不会很大</li></ol><h3 id="二、Linux内核如何管理内存"><a href="#二、Linux内核如何管理内存" class="headerlink" title="二、Linux内核如何管理内存"></a>二、Linux内核如何管理内存</h3><p>内核针对自己的应用场景，使用了一种叫做SLAB/SLUB的内存管理机制。这种管理机制通过四个步骤把物理内存条管理起来，供内核申请和分配内核对象。</p><h4 id="1）node划分"><a href="#1）node划分" class="headerlink" title="1）node划分"></a>1）node划分</h4><p>早期的计算机中，内存控制器还没有整合到CPU，所有的内存访问都需要经过北桥芯片组来完成，即内存控制器集成在北桥中。<strong>CPU访存需要通过前端总线连接到北桥芯片，然后北桥芯片连接到内存，这样的架构被称为UMA（一致性内存访问）</strong>。总线模型保证了所有的内存访问都是一致的（即每个处理器共享相同的内存地址空间）。<strong>在UMA架构下，CPU和内存之间的通信全部都要通过前端总线，而提高性能的方式就是不断提高CPU、前端总线和内存的工作频率。</strong></p><p>而随着物理条件的限制，CPU朝着高频率的方向发展遇到了天花板，性能的提升开始供提高主频转向增加CPU数量（多核、多CPU）。<strong>而越来越多的 CPU 对前端总线的争用，使前端总线成为了瓶颈。为了消除 UMA 架构的瓶颈，NUMA（非一致性内存访问）架构诞生了。</strong>在NUMA架构下，<strong>每个CPU会有自己的独立的内存控制器，并且独立连接到一部分内存（直连的这部分内存称为本地内存），组成一个node，不同node之间通过QPI（Quick Path Interconnect）进行通信访问远程内存。</strong>如下图所示：</p><p><img src="/posts/48821/d4611b458796469c8caacfa92107d0b1.png" alt></p><p>在 NUMA 架构下，内存的访问出现了本地和远程的区别：访问远程内存的延时会明显高于访问本地内存。</p><blockquote><p>系统 boot 的时候，硬件会把 NUMA 信息发送给 os，如果系统支持 NUMA ，会发生以下几件事：</p><ul><li>获取 NUMA 配置信息</li><li>将 processors（不是 cores） 分成很多 nodes，一般是一个 processor 一个 node。</li><li>将 processor 附近的 memory 分配给它。</li><li>计算node 间通信的cost（距离）。</li></ul></blockquote><p>Linux 识别到 NUMA 架构后，每个进程、线程都会继承一个 numa policy，定义了可以使用那些CPU（甚至是那些 core），哪些内存可以使用，以及 policy 的强制程度，即是优先还是强制性只允许。<strong>每个 thread 被分配到了一个”优先” 的 node 上面运行</strong>，thread 可以在其他地方运行（如果 policy 允许的话），但是 os 会尝试让他在优先地 node 上面去运行。默认的内存分配方案是：<strong>优先从本地分配内存。如果本地内存不足，优先淘汰本地内存中无用的内存。使内存页尽可能地和调用线程处在同一个 node。</strong></p><blockquote><p>只是优先从本地分配内存，进程同样可以访问到其他内存条。因为在计算机系统中，物理内存地址是由内存管理单元（Memory Management Unit，MMU）管理的，它会把CPU发出的地址请求转换为实际的物理内存地址。即使系统中有多个内存条（也就是说，有多个物理内存块），MMU也会把它们看作是一个连续的地址空间进行管理。</p><p>当系统启动时，BIOS或者UEFI会检测所有的硬件设备，包括内存条。每个内存条的大小和位置信息会被记录在一个叫做内存映射（Memory Map）的数据结构中。这个内存映射会被传递给操作系统。</p><p>在操作系统启动时，它会读取这个内存映射，然后建立起自己的物理内存管理数据结构，如页帧数组。操作系统会把每个物理内存页的地址和状态（比如是否被使用，被哪个进程使用）记录在struct page的一个实例中。页帧数组中的每个元素对应物理内存中的一个页，页帧数组的索引直接映射到物理内存地址。</p><p>在多个内存条的情况下，页帧数组会涵盖所有的内存条。即使内存条在物理上是分离的，但在页帧数组中它们看起来是连续的。当一个物理页面被分配给一个进程时，操作系统会在页表中创建一个页表项，将虚拟地址映射到这个物理页面的地址。</p></blockquote><p>这种默认的分配策略一般情况下可能没有问题，但是对于一些需要分配大量内存的应用上可能会出现性能问题。如使用MySQL时，假如每个node有32G的内存，而MySQL配置了48G 的 innodb buffer pool，那么可能会出现尽管系统还有很多空余的内容，但是很多内存都被 swap 出去了。这就是因为默认的内存分配方案是优先从本地分配，所以当node0内存快被占满时，尽管node1还有很多内存，但是node0里面的内存还是会被swap出去。</p><blockquote><p>以上是硬件层面上的NUMA（hardware view），而作为软件层面的Linux，则对NUMA的概念进行了抽象。即便硬件上是一整块连续内存的UMA，Linux也可将其划分为若干的node（所有node其实是个软件上的概念）。同样，即便硬件上是物理内存不连续的NUMA，Linux也可将其视作UMA（software view）。</p><p>所以，在<a href="https://so.csdn.net/so/search?q=Linux系统&spm=1001.2101.3001.7020">Linux系统</a>中，你可以基于一个UMA的平台测试NUMA上的应用特性。从另一个角度，UMA就是只有一个node的特殊NUMA，所以两者可以统一用NUMA模型表示。</p></blockquote><h4 id="2）zone划分"><a href="#2）zone划分" class="headerlink" title="2）zone划分"></a>2）zone划分</h4><p>NUMA模型中，<strong>物理内存</strong>被划分为几个节点（node），一个node对应一个内存簇bank，即每个内存簇认为是一个节点。</p><p>首先，内存被划分为结点，每个节点关联到系统中的一个处理器。接着各个节点又被划分为内存管理区域，一个管理区域通过struct zone_struct描述，其被定义为zone_t，用以表示内存的某个范围。主要分为以下几种类型的内存管理区域：</p><ol><li>ZONE_DMA：地址段最低的一块内存区域（物理内存起始的16M），供IO设备DMA访问。<ul><li>一些使用 DMA 的外设并没有像 CPU 那样的 32 位地址总线，比如只有 16 位总线，就只能访问 64 KB 的空间，24 位总线就只能访问 16 MB 的空间，如果给 DMA 分配的内存地址超出了这个范围，设备就没法（寻址）访问了。也应该成为ZONE_DMA24</li></ul></li><li>ZONE_DMA32：到了 64 位系统，外设的寻址能力增强，因此又加入了一个 ZONE_DMA32，空间大小为 16MB 到 4GB</li><li>ZONE_NORMAL：可<strong>直接映射</strong>到内核的普通内存域（16M-896M），在X86-64架构下，DMA和DMA32之外的内存全部在NORMAL的zone里管理</li><li>ZONE_HIGHMEM：高端内存，内核不能直接使用（896M-4G），<strong>动态映射</strong>到内核空间3G+896M-4G的位置。即要访问的物理地址空间大于虚拟地址空间，不能直接建立映射的场景。适用于32位CPU系统，64位的CPU系统虚拟地址空间足够大，直接映射即可，所以都是NORMAL。</li></ol><p><img src="/posts/48821/969d18e411f3417abe1318c9b2349f45.png" alt></p><p>每个zone下都包含了许许多多个Page（页面），在Linux下一个页面的大小一般是4KB（处理器架构决定的，操作系统编译的时候固定下来）。</p><p>可以使用zoneinfo命令查看机器上zone的划分，也可以看到每个zone下所管理的页面有多少。</p><h4 id="3）基于伙伴系统管理空闲页面"><a href="#3）基于伙伴系统管理空闲页面" class="headerlink" title="3）基于伙伴系统管理空闲页面"></a>3）基于伙伴系统管理空闲页面</h4><blockquote><p>伙伴系统中的伙伴指的是两个内存块、大小相同、地址连续，同属于一个大块区域</p></blockquote><p>每个zone下面都有很多的页面，Linux使用伙伴系统对这些页面进行高效的管理。在内核中，表示zone的数据结构是struct zone。其下面的一个数组free_area管理了绝大部分可用的空闲页面。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> MAX_ORDER 11</span>
<span class="token keyword">struct</span> zone<span class="token punctuation">{</span>
    free_area free_area<span class="token punctuation">[</span>MAX_ORDER<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>free_area是一个包含11个元素的数组。每一个元素分别代表不同大小（4KB、8KB、16KB、32KB…）的空闲可分配的连续内存链表。</strong></p><p>即每一个元素都代表一种大小的内存块，数组的索引表示了内存块包含的页框数量。例如，free_area[0]中存放的是单独的空闲页框（4KB），free_area[1]中存放的是包含两个页框的空闲内存块（8KB），等等。这种方式可以方便地查找和分配满足特定大小需求的内存块。</p><p><img src="/posts/48821/a74c3cf0ab4d4c61b2c5db5a79870151.png" alt></p><p>每个free_area元素都有一个或多个链表：</p><ol><li>MIGRATE_UNMOVABLE：表示不可移动的pages，例如内核数据结构的pages。</li><li>MIGRATE_RECLAIMABLE：表示可回收的pages，例如系统中的缓存，当内存紧张时可以回收其内存。</li><li>MIGRATE_MOVABLE：表示可移动的pages，例如用户进程的pages。当需要大块连续的内存空间，或者进行内存碎片整理时，可以移动这类page。</li><li>MIGRATE_PCPTYPES：表示特殊用途的pages，一般用于不可移动和可回收page的临时备份。</li><li>MIGRATE_HIGHATOMIC：表示高优先级的分配请求，这种类型的page只有在内存非常紧张时才会被使用。</li></ol><p>链表中的每一个元素都是一个空闲内存块。这些内存块在物理内存中是连续的，也就是说，它们包含的页框在物理内存中是紧邻的。这样，当内核需要分配一个连续的内存区域时，可以直接从这些链表中查找和分配。但要注意，虽然这些内存块在物理内存中是连续的，但在虚拟内存中可能并不连续。因为虚拟地址到物理地址的映射是通过页表完成的，不同的页框可以被映射到虚拟内存中的任意位置（不一定在相邻的页表项）。</p><blockquote><p>free_area数组里的链表元素存储了一个叫struct page的结构体。struct page是内核用来描述<strong>物理内存页</strong>的主要数据结构。</p><p>每个物理页在内核中都有一个对应的struct page实例。这个结构体包含了许多用于页管理的字段，如用于链接空闲页的链表节点字段等。内核可以通过这个结构体找到对应的物理页。为了映射物理内存和struct page实例，Linux内核使用了一种叫做mem_map的数组。这个数组的每个元素都是一个struct page实例，整个数组的顺序与物理内存页的顺序相同。因此，内核可以通过简单的指针运算在物理地址和对应的struct page实例之间进行转换。</p></blockquote><p>通过cat /proc/pagetypeinfo可以看到当前系统中伙伴系统各个尺寸的可用连续内存块数量。</p><p>内核提供分配器函数alloc_pages到上面的多个链表中寻找可用连续页面。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> page <span class="token operator">*</span> <span class="token function">alloc_pages</span><span class="token punctuation">(</span>gfp_t gfp_mask<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> order<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>假如要申请8KB（连续两个页框的内存），<strong>在基于伙伴系统的内存分配中，有可能需要将大块内存拆分成两个小伙伴。在释放中，可能会将两个小伙伴合并，在此组成更大块的连续内存。</strong>具体的工作步骤：</p><ol><li>先到free_area[1]，即8KB的链表中查询</li><li>如果无可用，则到free_area[2]，即16KB的链表中查询</li><li>如果找到了则将其拆分成两个小伙伴，使用掉其中一个</li><li>将另一个小伙伴放置到8KB的链表中</li></ol><h4 id="4、slab分配器"><a href="#4、slab分配器" class="headerlink" title="4、slab分配器"></a>4、slab分配器</h4><p>到目前介绍的内存分配都是以页面4KB为单位的。而内核代码经常需要在运行时分配和释放小块的内存区域。如果每次都使用普通的页分配器（即每次分配至少一个页的内存）来完成，可能会浪费大量内存。为了更高效地分配小块内存，内核在伙伴系统之上又引入了一个专用的内存分配器slab（或叫slub）</p><p>这个分配器最大的特点就是<strong>一个slab内只分配特定大小、甚至是特定的对象，当一个对象释放内存后，另一个同类对象可以直接使用这块内存</strong>。通过这样的方式极大地降低了碎片发生的概率。</p><p>在SLAB分配器中，<strong>当内核需要频繁创建和销毁某种类型的对象时（比如文件描述符、进程描述符等），它会创建一个kmem_cache，并根据需要的对象大小进行初始化</strong>。<strong>每个kmem_cache都包含一些预分配的内存块（SLABs）</strong>，这些内存块的大小都与需要的对象大小相匹配。当内核代码需要分配一个新的对象时，可以直接从对应的kmem_cache中取出一个预先分配的内存块，而不需要每次都去进行页分配。同样，当一个对象被释放时，它的内存块可以被直接归还到kmem_cache中，以便再次使用。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> kmem_cache <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> kmem_cache_node <span class="token operator">*</span><span class="token operator">*</span>node<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> kmem_cache_node <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> list_head slabs_partial<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> list_head slabs_full<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> list_head slabs_free<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>一个kmem_cache可以有多个kmem_cache_node，每个kmem_cache_node代表该kmem_cache在一个特定的NUMA节点上的状态。</strong>NUMA是一种针对多处理器系统的内存架构，其主要思想是将物理内存划分为多个节点，每个处理器可以直接访问所有的内存，但访问不同节点的内存的延迟和带宽可能会有所不同。因此，在NUMA系统中，内存的分配策略可能会影响到程序的性能。为了在NUMA系统中更高效地管理内存，Linux内核引入了kmem_cache_node。在每个kmem_cache中，每个NUMA节点都有一个对应的kmem_cache_node。这个kmem_cache_node包含了该节点上的空闲对象列表，以及其他一些与该节点相关的信息。当从kmem_cache中分配或释放对象时，内核会优先考虑当前CPU对应的NUMA节点，这样可以提高内存访问的性能。</p><p><strong>每个kmem_cache_node中都有满、半满、空三个链表。每个链表节点都对应一个slab，一个slab由一个或多个内页也组成。</strong></p><p><strong>每一个slab内都保存的是同等大小的对象。</strong></p><p>当cache中内存不够时，会调用基于伙伴系统的分配器请求整页连续内存的分配。</p><p><img src="/posts/48821/c5a0449280aa42e593cf86d90c29092d.png" alt></p><p>内核中会有很多个kmem_cache存在，它们是在Linux初始化或者是运行的过程中分配出来的。其中有的是通用的，有的是专用的。</p><p><img src="/posts/48821/d06a875b50c649e5bb57d84ddfb1986d.png" alt></p><p>从图中可以<strong>看到socket_alloc内核对象都存在TCP的专用kmem_cache中</strong>。通过查看/proc/slabinfo可以查看所有的kmem_cahce。</p><p><strong>并不是所有的对象都会使用SLAB分配器进行分配。SLAB分配器是针对频繁分配和释放的小型对象设计的</strong>，比如内核中的各种数据结构（例如，文件描述符、信号量、进程描述符等）。对于这些对象，SLAB分配器可以显著提高分配效率，减少内存碎片，并提高缓存利用率。然而，对于大型对象（比如用户请求的大块内存），或者不常用的对象（即分配和释放不频繁的对象），直接使用页分配器（Page Allocator）或者伙伴系统（Buddy System）进行分配通常更为高效。页分配器可以处理任何大小的内存请求，但对于小型对象，可能会造成内存的浪费。</p><p>此外，用户空间的内存分配（例如，通过malloc()或者new进行的分配）通常不直接使用SLAB分配器。用户空间的内存分配通常由C库（例如，glibc）提供的内存分配器处理，这个分配器使用系统调用（例如，brk()或者mmap()）从内核获取或释放内存。</p><blockquote><p>Linux还提供了一个特别方便的命令slabtop来按照内存从大到小进行排列，可以用来分析slab内存开销。</p><p>此外slab管理器组件提供了若干接口函数方便使用：</p><ol><li>kmem_cache_create：创建一个基于slab的内核对象管理器。</li><li>kmem_cache_alloc：快速为某个对象申请内存。</li><li>kmem_cache_free：将对象占用的内存归还给slab分配器</li></ol></blockquote><h4 id="5）小结"><a href="#5）小结" class="headerlink" title="5）小结"></a>5）小结</h4><p>内核使用内存的方式：</p><ol><li>把所有内存条和CPU换分成node</li><li>把每一个node划分成zone</li><li>每个zone下都用伙伴系统管理空闲页面</li><li>内核提供slab分配器为自己专用</li></ol><p><strong>前三步是基础模块，为应用程序分配内存时的请求调页组件页能够用到，但是第四步就是内核给自己专用的了。</strong></p><h3 id="三、TCP连接相关内核对象"><a href="#三、TCP连接相关内核对象" class="headerlink" title="三、TCP连接相关内核对象"></a>三、TCP连接相关内核对象</h3><p>TCP连接建立的过程中，每申请一个内核对象也都需要到相应的缓存里申请一块内存。</p><h4 id="1）socket函数直接创建"><a href="#1）socket函数直接创建" class="headerlink" title="1）socket函数直接创建"></a>1）socket函数直接创建</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">__sock_create</span><span class="token punctuation">(</span><span class="token keyword">struct</span> net <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">int</span> family<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 分配socket对象</span>
    sock <span class="token operator">=</span> <span class="token function">sock_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 调用协议族的创建函数创建sock对象</span>
    err <span class="token operator">=</span> pf<span class="token operator">-></span><span class="token function">create</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> sock<span class="token punctuation">,</span> protocol<span class="token punctuation">,</span> kern<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-sock-inode-cache对象申请"><a href="#1-sock-inode-cache对象申请" class="headerlink" title="1. sock_inode_cache对象申请"></a>1. sock_inode_cache对象申请</h5><p>在sock_alloc函数中，申请了一个struct socket_alloc的内核对象。<strong>socket_alloc内核对象将socket和inode信息关联了起来。</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> socket_alloc <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> socket socket<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> inode vfs_inode<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在sock_alloc的实现逻辑中，最后就<strong>调用了kmem_cache_alloc从sock_inode_cache中申请了一个struct socket_alloc对象</strong>。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> inode <span class="token operator">*</span><span class="token function">sock_alloc_inode</span><span class="token punctuation">(</span><span class="token keyword">struct</span> super_block <span class="token operator">*</span>sb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> socket_alloc <span class="token operator">*</span>ei<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> socket_wq <span class="token operator">*</span>wq<span class="token punctuation">;</span>

    ei <span class="token operator">=</span> <span class="token function">kmem_cache_alloc</span><span class="token punctuation">(</span>sock_inode_cachep<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>ei<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    wq <span class="token operator">=</span> <span class="token function">kmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>wq<span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>sock_inode_cache是专门用来存储struct socket_alloc的slab缓存</strong>，它是在init_inodecache中通过<code>kmem_cache(&quot;sock_inode_cache&quot;, sizeof(struct socket_alloc), ...)</code>初始化的。</p><p>另外还可以看到通过kmalloc申请了一个socket_wq，这是个用来记录在socket上等待事件的等待项。</p><h5 id="2-tcp对象申请"><a href="#2-tcp对象申请" class="headerlink" title="2. tcp对象申请"></a>2. tcp对象申请</h5><p>对于IPv4来说，inet协议族对应的create函数是inet_create，因此__sock_create中对pf-&gt;create的调用会执行到inet_create中去。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">inet_create</span><span class="token punctuation">(</span><span class="token keyword">struct</span> net <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">int</span> protocol<span class="token punctuation">,</span> <span class="token keyword">int</span> kern<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment" spellcheck="true">// 这个answer_prot其实就是tcp_prot</span>
    answer_prot <span class="token operator">=</span> answer<span class="token operator">-></span>prot<span class="token punctuation">;</span>
    sk <span class="token operator">=</span> <span class="token function">sk_alloc</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> PF_INET<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">,</span> answer_prot<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> sock <span class="token operator">*</span><span class="token function">sk_alloc</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    sturct sock <span class="token operator">*</span>sk<span class="token punctuation">;</span>
    sk <span class="token operator">=</span> <span class="token function">sk_prot_alloc</span><span class="token punctuation">(</span>prot<span class="token punctuation">,</span> priority <span class="token operator">|</span> __GFP_ZERO<span class="token punctuation">,</span> family<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">struct</span> sock <span class="token operator">*</span><span class="token function">sk_prot_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> proto <span class="token operator">*</span>prot<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    slab <span class="token operator">=</span> prot<span class="token operator">-></span>slab<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>slab <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      sk <span class="token operator">=</span> <span class="token function">kmem_cache_alloc</span><span class="token punctuation">(</span>slab<span class="token punctuation">,</span> priority <span class="token operator">&amp;</span> <span class="token operator">~</span>__GFP_ZERO<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个函数中，<strong>将会到TCP这个slab缓存中使用kmem_cache_alloc从slab中申请一个struct sock内核对象出来</strong>。TCP这个slab缓存是在协议栈初始化的时候在inet_init中使用<code>kmem_cache_create(prot-&gt;name, prot-&gt;obj_size, ...)</code>（这里prot是一个tcp_prot）初始化好的一个名为TCP、大小为sizeof(struct tcp_sock)的kmem_cache，并把它记到tcp_prot-&gt;slab的字段下。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> proto tcp_prot <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"TCP"</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">.</span>obj_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> tcp_sock<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要记住的是，在<strong>TCP slab缓存中实际存放的是struct tcp_sock对象，是struct sock的扩展</strong>，由于tcp_sock、inet_connection_sock、inet_sock、sock是逐层嵌套的关系，所以tcp_sock是可以当作sock来使用的。</p><h5 id="3-dentry和flip对象申请"><a href="#3-dentry和flip对象申请" class="headerlink" title="3. dentry和flip对象申请"></a>3. dentry和flip对象申请</h5><p>回到socket系统调用的入口处，除了sock_create以外，还调用了一个sock_map_fd</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">SYSCALL_DEFINE</span><span class="token punctuation">(</span>socket<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> family<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> protocol<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">sock_create</span><span class="token punctuation">(</span>family<span class="token punctuation">,</span> type<span class="token punctuation">,</span> protocol<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sock_map_fd</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> flags <span class="token operator">&amp;</span> <span class="token punctuation">(</span>0_CLOEXEC <span class="token operator">|</span> ONONBLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以此为入口将完成struct dentry的和struct file申请。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> dentry <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">struct</span> dentry <span class="token operator">*</span>d_parent<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> qstr d_name<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> inode <span class="token operator">*</span>d_inode<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> d_iname<span class="token punctuation">[</span>DNAME_INLINE_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>内核初始化的时候创建好了一个dentry slab和flip slab缓存，所有的struct dentry对象和struct file对象都将由它们进行分配。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">sock_map_fd</span><span class="token punctuation">(</span><span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> file <span class="token operator">*</span>newfile<span class="token punctuation">;</span>
    <span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">get_unused_fd_flags</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment" spellcheck="true">// 1.申请dentry、file内核对象</span>
    newfile <span class="token operator">=</span> <span class="token function">sock_alloc_file</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>newfile<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 2.关联到socket及进程</span>
      <span class="token function">fd_install</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> newfile<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">return</span> fd<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> file <span class="token operator">*</span><span class="token function">sock_alloc_file</span><span class="token punctuation">(</span><span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>dname<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 申请dentry</span>
    path<span class="token punctuation">.</span>dentry <span class="token operator">=</span> <span class="token function">d_alloc_pseudo</span><span class="token punctuation">(</span>sock_mnt<span class="token operator">-></span>mnt_sb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 申请flip</span>
    file <span class="token operator">=</span> <span class="token function">alloc_file</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>path<span class="token punctuation">,</span> FMOD_READ <span class="token operator">|</span> FMODE_WRITE<span class="token punctuation">,</span> <span class="token operator">&amp;</span>socket_file_ops<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>在sock_alloc_file中完成内核对象的申请，其中会去进行struct dentry和struct file两个内核对象的申请。</strong>dentry对象的申请最终同样是是调用到了kmem_cache_alloc函数（对应的slab缓存dentry在内核初始化时的dcache_init中创建的），而file对象的申请最终是调用了kmem_cache_zalloc函数进行分配（对应的slab缓存flip是在内核初始化时的files_init中创建的）</p><blockquote><p>kmem_cache_alloc()和kmem_cache_zalloc()都是用于从指定的kmem_cache中分配对象的函数。它们的主要区别在于，kmem_cache_zalloc()在分配内存后，会自动将内存区域初始化为0。</p><p>具体来说：</p><ul><li>kmem_cache_alloc()：从指定的kmem_cache分配一个对象的内存空间。返回的内存空间中的内容是不确定的，也就是说，它可能包含任何数据。调用者需要自己对内存进行初始化。</li><li>kmem_cache_zalloc()：从指定的kmem_cache分配一个对象的内存空间，并自动将整个内存区域初始化为0。这意味着调用者可以直接使用返回的内存，无需再进行初始化。</li></ul><p>在一些情况下，使用kmem_cache_zalloc()可能更方便，因为它可以确保内存区域的内容被初始化为0。然而，如果你知道你会立即覆盖整个内存区域的内容，那么使用kmem_cache_alloc()可能会更高效，因为它避免了不必要的内存初始化。</p></blockquote><h5 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h5><p>调用链：</p><ul><li>SYSCALL_DEFINE3<ul><li>sock_create<ul><li>__sock_create<ul><li>sock_alloc =&gt; =&gt; sock_alloc_inode：申请socket_alloc和socket_wq</li><li>inet_create<ul><li>sk_alloc =&gt; sk_prot_alloc：申请tcp_sock</li></ul></li></ul></li></ul></li><li>sock_map_fd<ul><li>sock_alloc_file<ul><li>d_alloc_pseudo =&gt; __d_alloc：申请dentry</li><li>alloc_file =&gt; get_empty_flip：申请file</li></ul></li></ul></li></ul></li></ul><p>socket系统调用完毕之后，在内核中就申请了配套的一组内核对象。这些内核对象并不是鼓励地存在，而是互相保留着和其他内存对象的关联关系。</p><p><img src="/posts/48821/6d424f2828a1426d973ef066379d1b47.png" alt></p><p>所有网络相关的操作，包括数据接收和发送等都以这些数据结构为基础来进行的</p><h4 id="2）服务端socket创建"><a href="#2）服务端socket创建" class="headerlink" title="2）服务端socket创建"></a>2）服务端socket创建</h4><p>除了直接创建socket意外，服务端还可以通过accept函数在接受连接请求时完成相关内核对象的创建。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">SYSCALL_DEFINE</span><span class="token punctuation">(</span>accept4<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> sockaddr __user <span class="token operator">*</span><span class="token punctuation">,</span> upeerp_sockaddr<span class="token punctuation">,</span> <span class="token keyword">int</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> upeer_addrlen<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token operator">*</span>newsock<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 根据fd查找到监听的socket</span>
    sock <span class="token operator">=</span> <span class="token function">sockfd_lookup_light</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 申请并初始化新的socket</span>
    newsock <span class="token operator">=</span> <span class="token function">sock_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    newsock<span class="token operator">-></span>type <span class="token operator">=</span> sock<span class="token operator">-></span>type<span class="token punctuation">;</span>
    newsock<span class="token operator">-></span>ops <span class="token operator">=</span> sock<span class="token operator">-></span>ops<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 申请新的file对象，并设置到新的socket上</span>
    newfile <span class="token operator">=</span> <span class="token function">sock_alloc_file</span><span class="token punctuation">(</span>newsock<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 接受连接</span>
    err <span class="token operator">=</span> sock<span class="token operator">-></span>ops<span class="token operator">-></span><span class="token function">accept</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> newsock<span class="token punctuation">,</span> sock<span class="token operator">-></span>file<span class="token operator">-></span>f_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 将新文件添加到当前进程的打开文件列表</span>
    <span class="token function">fd_install</span><span class="token punctuation">(</span>newfd<span class="token punctuation">,</span> newfile<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到socket_alloc、file、dentry对象的分配都是相同的方式，唯一的区别是tcp_sock对象是在第三次握手的时候创建的，所以这里在接收连接的时候直接从全连接队列拿出request_sock的sock成员就可以了，无需再单独申请。</p><h3 id="四、问题解答"><a href="#四、问题解答" class="headerlink" title="四、问题解答"></a>四、问题解答</h3><ol><li>内核是如何管理内存的：内核采用SLAB的方式来管理内存，总共分为四部<ul><li>把所有的内存条和CPU进行分组，组成node</li><li>把每一个node划分成多个zone</li><li>每个zone下都用伙伴系统来管理空闲页面</li><li>提供slab分配器来管理各种内核对象</li><li>前三步时基础模块，为应用程序分配内存时的请求调页组件也能够用到，而第四步是内核专用的。每个slab缓存都是用来存储固定大小，甚至是特定的一种内核对象。这样当一个对象释放内存后，另一个同类对象可以直接使用这块内存，几乎没有任何碎片。极大地提高了分配效率，同时降低了碎片率。</li></ul></li><li>如何查看内核使用的内存信息<ul><li>通过/proc/slabinfo可以看到所有的kmem_cache。</li><li>更方便的是slatop命令，它从大到小按照占用内存进行排列。</li></ul></li><li>服务器上一条ESTABLISH状态的空连接需要消耗多少内存：假设连接上绝大部分时间都是空闲的，也就是假设没有发送缓存区和接收缓存区的开销，那么一个socket大约需要如下几个内核对象<ul><li>struct socket_alloc：大约0.62KB， slab缓存名是sock_inode_cache</li><li>struct top_sock：大约1.94KB，slab缓存名是tcp</li><li>struct dentry：大约0.19KB，slab缓存名是dentry</li><li>struct file：大约为0.25KB，slab缓存名是flip</li><li>加上slab多少会存在一点碎片无法使用，这组内核对象的大小大约是3.3KB左右。所以即使一万条连接也只需要占用33MB的内存</li><li>至于CPU开销，没有数据包的接收和处理是不需要消耗CPU的。长连接上在没有数据传输的情况下，只有极少量的保护包传输，CPU开销可以忽略不计</li></ul></li><li>机器上出现了3万多个TIME_WAIT，内存开销会不会很大<ul><li>从内存的角度来考虑，一条TIME_WAIT状态的连接仅仅是0.4KB左右的内存而已</li><li>从端口的角度来考虑，占用的端口只是针对特定服务器来说是占用了，只要下次连接的服务端不一样（IP或者端口不一样），那么这个端口仍然可以用来发起TCP连接</li><li>只有在连接同一个server的时候端口占用才能算得上是问题。如果想解决这个问题可以考虑使用tcp_max_tw_buckets来限制TIME_WAIT连接总数，或者打开tcp_tw_recycle、tcp_tw_reuse来快速回收端口，或者干脆使用长连接代替频繁的短连接。</li></ul></li></ol><h2 id="五、全书问题小结"><a href="#五、全书问题小结" class="headerlink" title="五、全书问题小结"></a>五、全书问题小结</h2><h3 id="问题1：虚拟化时代，65535-的端口号更不够用了吧？"><a href="#问题1：虚拟化时代，65535-的端口号更不够用了吧？" class="headerlink" title="问题1：虚拟化时代，65535 的端口号更不够用了吧？"></a>问题1：虚拟化时代，65535 的端口号更不够用了吧？</h3><p><strong>问</strong>：一个 linux 最多能 65535 个端口，那么在虚拟化盛行的现在，这个 65535 更容易被占满了吧，怎么处理？</p><p><strong>答</strong>：首先一个 linux 最多能 65535 个端口的说法是不确切的。因为即使在一台 Linux 上也是可以配置多 ip 的，每个 ip 都可以有 65535个 端口可用。</p><p>另外再说说现代的虚拟化。在 2008 年发布的 Linux2.6.24 内核版本里，引入了一个叫网络命名空间的东东。这个就是现代容器虚拟化的基石。在每一个命名空间里，都可以拥有自己独立的 ip、端口号、路由表等等网络资源。对于现在常用的 docker ，一个 docker 里就对应一个网络命名空间（非host模式下）。每个容器都是 65536 个端口可用的。</p><p>另外还有一个要知道的是，如果连接不同的服务器端的时候，即使只有一个 ip，同一个端口号也是可以用于连接不同的服务端的。所以不要担心 65535 的限制。</p><h3 id="问题2：访问本机的-ip-会通过交换机或者路由器吗？"><a href="#问题2：访问本机的-ip-会通过交换机或者路由器吗？" class="headerlink" title="问题2：访问本机的 ip 会通过交换机或者路由器吗？"></a>问题2：访问本机的 ip 会通过交换机或者路由器吗？</h3><p><strong>问</strong>：ip 填写自己本机的 ip 会通过交换机或者路由器吗。</p><p><strong>答</strong>：不会的，你可以试试，无论是使用本机 ip，还是 127.0.0.1 都是只过回环设备 lo。通过在 lo 上抓包即可看到，而在真正的物理网卡下是抓不到包的。</p><h3 id="问题3：服务器端只有一个端口，收发请求不会乱吗？"><a href="#问题3：服务器端只有一个端口，收发请求不会乱吗？" class="headerlink" title="问题3：服务器端只有一个端口，收发请求不会乱吗？"></a>问题3：服务器端只有一个端口，收发请求不会乱吗？</h3><p><strong>问</strong>：老师我本来没觉得我不明白 但是看了上面 列举的问题 &lt;一台机器最多能支持多少条 TCP 连接&gt;就有点疑惑了 就是服务器作为接收 WEB 或者其他端请求时 不管是 80 还是 443， 对外暴露的基本上是一样的端口，http请求来了之后 请求之间不会相互干扰吗？或者同一个端口可以有多少个http请求，我自己都凌乱了，谢谢老师！</p><p><strong>答</strong>：我们分三步来理解你说的问题。</p><p>第一、服务器端在接收到新连接的时候会创建新的 socket 出来。这个新的socket 上有完整的四元组（内部源 IP、源端口、目的 IP 和目的端口）信息，并以 hashtable 的方式管理。</p><p>第二、TCP 网络包体内部源 IP、源端口、目的 IP 和目的端口等信息都是携带在包头里的。</p><p>第三。内核在接收到网络包的时候，在协议栈处理的时候会解析包头，根据这个包头中完整的四元组和内核中 hashtable 中管理的 socket 进行匹配，只有四元组信息完全一致，才能把接收到的数据放到该 socket 的接收队列中。不同的请求的 socket 上四元组信息并不完全一致，所以请求之间不会相互干扰。</p><h3 id="问题4：网上著名的-C10K-并发连接问题-具体是怎么回事？"><a href="#问题4：网上著名的-C10K-并发连接问题-具体是怎么回事？" class="headerlink" title="问题4：网上著名的 C10K 并发连接问题 具体是怎么回事？"></a>问题4：网上著名的 C10K 并发连接问题 具体是怎么回事？</h3><p><strong>问</strong>：网上著名的 C10K 并发连接问题 具体是怎么回事？</p><p><strong>答</strong>：C10K 问题算是历史上的一个问题，在 Linux 上最早的开发模型里，只有线程编程模型，来一个用户就需要使用一个进程来处理。但随着互联网发展的井喷，服务器端要支持的并发数越来越高。如果还继续沿用这个模型的话，就需要投入巨量的服务器资源。所以 C10K 问题的提出，就是要处理如何让一台服务器同时处理 1 万个用户连接请求。在 epoll 诞生以后，C10K 已经不是问题了。</p><h3 id="问题5：网络丢包该如何排查"><a href="#问题5：网络丢包该如何排查" class="headerlink" title="问题5：网络丢包该如何排查"></a>问题5：网络丢包该如何排查</h3><p><strong>问</strong>：刚好遇到疑似 TCP 传输丢包的问题，想请教老师科普下这种问题排查的整体思路和顺序是什么</p><p><strong>答</strong>：TCP 传输丢包问题使用 tcpdump 抓包看看，看看重试是如何发生的，使用 wireshark 打开，使用过滤器 tcp.analysis.retransmission 找到重传的包。还有一个基于 eBPF 的轻量级工具 tcpretrans ，也可以试试。不过 eBPF 对 Linux 版本要求较高。</p><h3 id="问题6：一台机器最多能支持多少条-TCP-连接"><a href="#问题6：一台机器最多能支持多少条-TCP-连接" class="headerlink" title="问题6：一台机器最多能支持多少条 TCP 连接?"></a>问题6：一台机器最多能支持多少条 TCP 连接?</h3><p><strong>问</strong>：一台机器最多能支持多少条 TCP 连接? 这个公式是什么？怎么计算，64GB 的 Linux 服务器，可以支持多少条？</p><p><strong>答</strong>：一台机器最多能支持多少条 TCP 连接。只说服务器端吧，一是受限于 Linux 里配置的可打开文件句柄数等内核参数，但这些都很好修改，调几个参数就行了。二就是内存了，这个是硬性限制。最少也得是 3.3 KB 左右。所以如果算极限情况下的TCP连接数，64 GB 除以 3.3KB 就行了。但一般都会给收发缓存区以及其它应用留一些 buffer</p><h3 id="问题7：一条-TCP-需要消耗多大的内存"><a href="#问题7：一条-TCP-需要消耗多大的内存" class="headerlink" title="问题7：一条 TCP 需要消耗多大的内存"></a>问题7：一条 TCP 需要消耗多大的内存</h3><p><strong>问</strong>：一条 TCP 连接需要消耗多大的内存 ，像mysql这种连接数，和用户登录这种 session 信息，也是一条 tcp 连接吗？</p><p><strong>答</strong>：TCP 连接在内核里消耗内存主要是两块，一是表示 TCP 连接的 socket，大约是 3.3K 左右。二是接收和发送数据的缓存区，这个可大可小，大了收发速度更快，小了更省内存。但在较新的版本里，只要收发结束，内存就都可以回收了。你说的 mysql 的用户登录、session 等信息这个数据 TCP 里传输的数据。这个数据就看用户进程里是怎么存储的了，如果存在内存里就占内存，存到磁盘里就占磁盘。</p><h3 id="问题8：CPU-飙高到-100"><a href="#问题8：CPU-飙高到-100" class="headerlink" title="问题8：CPU 飙高到 100%"></a>问题8：CPU 飙高到 100%</h3><p><strong>问</strong>：老师好，我的线上服务总是莫名其妙 CPU 飙高到 100%，然后到某一个时刻突然掉下来，内存和 IO 几乎都正常值，请问应该从哪方面入手排查呢？</p><p><strong>答</strong>：这个就得具体问题具体分析了。得看看是用户态内存消耗的高，还是内核态消耗的高。相关的命令有 top、vmstat、sar、mpstat 等。如果是内核态就用 strace 命令统计一下系统调用的耗时情况，看有没有耗时特别长的。还可以考虑使用 perf 火焰图分析一下。</p><h3 id="问题9：有没有推荐网络调优和监控的工具"><a href="#问题9：有没有推荐网络调优和监控的工具" class="headerlink" title="问题9：有没有推荐网络调优和监控的工具"></a>问题9：有没有推荐网络调优和监控的工具</h3><p><strong>问</strong>：请问张老师， 有没有推荐网络调优和监控的工具。</p><p><strong>答：</strong>网络比较复杂，最好先了解它内部的工作原理，看一下《深入理解Linux网络》，然后再找相应步骤的工具，可以看看《性能之巅》，这样更好一些。</p><h3 id="问题10：net-ipv4-有非常多的属性，难道要挨个背下来？"><a href="#问题10：net-ipv4-有非常多的属性，难道要挨个背下来？" class="headerlink" title="问题10：net.ipv4 有非常多的属性，难道要挨个背下来？"></a>问题10：net.ipv4 有非常多的属性，难道要挨个背下来？</h3><p><strong>问</strong>：net.ipv4 有非常多的属性，难道要挨个背下来？现在就处于不知道从何看起的阶段，不知道直接看您的这本书是否能帮忙建立起知识结构，能知其然且知其所以然</p><p><strong>答</strong>：不需要背，最重要的是要理解网络工作底层工作原理，这样再看这些参数的时候就非常容易理解了。这就好比庖丁解牛，你如果对牛的骨骼肌肉的内部原理理解非常透彻的时候，你解牛的时候自然就非常容易。而不是去死记硬背这些内核参数。</p><p>咱们《深入理解Linux网络》就是这样一本介绍网络底层工作原理的书。书中会介绍到半连接队列、全连接是如何工作的，理解这个原理你就能轻松理解 syncookie 这个参数了。而且再遭遇 TCP 中的三次握手等问题的时候，你也能快速排查和定位原因了。</p><h3 id="问题11：线上被冲垮，帮忙-review-一下"><a href="#问题11：线上被冲垮，帮忙-review-一下" class="headerlink" title="问题11：线上被冲垮，帮忙 review 一下"></a>问题11：线上被冲垮，帮忙 review 一下</h3><p><strong>问</strong>：你好，曾经解决过一次线上服务器高峰时被冲垮的问题，原因是网络相关，靠着搜索引擎解决了后还是处于知其然不知其所以然的情况，麻烦帮忙 review 下</p><p>首先高峰被冲垮，看了 mysql ,程序都没异常，怀疑是网络问题。然后 netstat -n | awk 统计各种tcp连接状态的数量，发现别的都很少，established 单机上万了，time_wait 也非常高。带宽直接被打满</p><p>然后修改 file-max 和 sysctl 配置了如下和一些其他属性后，time_wait 瞬间下降。</p><pre><code>net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_tw_recycle = 1</code></pre><p>最后又加上 nginx ip 限流解决。虽然搜索到了生效的几个 net.ipv4 配置的意思，但是依然不知道为什么会有这么多的 time_wait</p><p><strong>答</strong>：你的问题的根本原因是在大流量（可能是攻击流量）请求的情况下使用了短连接。每一个短连接的主动释放连接的一方的 socket 都不会直接消失，而是会先释放一部分内核对象后进入 TIME_WAIT 状态，然后这个 socket 会一直占用一个端口号大约 2 分钟左右。recycle 和 reuse 的共同的作用都是尽量减少 socket 在 TIME_WAIT 上呆的时间，这样就能尽快释放端口。尽快地退出 TIME_WAIT 可以释放端口，保证后面的用户来的时候，服务器请求如 mysql 等数据服务器的时候，可以有充足的端口可用。</p><h3 id="问题12：Linux-网络连接建立以后，在文件层发生的变化是什么样的？"><a href="#问题12：Linux-网络连接建立以后，在文件层发生的变化是什么样的？" class="headerlink" title="问题12：Linux 网络连接建立以后，在文件层发生的变化是什么样的？"></a>问题12：Linux 网络连接建立以后，在文件层发生的变化是什么样的？</h3><p><strong>问：</strong>Linux 网络连接建立以后，在文件层发生的变化是什么样的？都说linux中所有的东西是文件，我如何通过网络连接去寻找该连接对应的文件？是一个文件还是多个文件？</p><p><strong>答</strong>：linux一切皆是文件，说的其实是一个 struct file 结构体。磁盘上的文件，socket 都有这样一个 struct file 对象，是一个内核上层的抽象。</p><p>但是在内核底层上磁盘文件、socket 还是完完全全不一样的东西。cat命令也并不能把一个socket中的数据内容给展示出来。如果你非得想用类似 cat 的功能，linux 下有个 ncat 命令你可以玩玩。</p><p>服务器端</p><pre><code># ncat -v -lp 8081
Ncat: Version 6.40 ( http://nmap.org/ncat )
......
hello world</code></pre><p>客户端</p><pre><code># nc -v 127.0.0.1 8081
Ncat: Version 6.40 ( http://nmap.org/ncat )
Ncat: Connected to 127.0.0.1:8081.
hello world</code></pre><h3 id="问题13：有没有通用的线上配置核心参数"><a href="#问题13：有没有通用的线上配置核心参数" class="headerlink" title="问题13：有没有通用的线上配置核心参数"></a>问题13：有没有通用的线上配置核心参数</h3><p><strong>问：</strong>关于连接和性能瓶颈，线上我们经常是遇到问题再去搜方案，有没有通用的必须要在线上配置的核心参数呢。<br><strong>答：</strong>通用的其实内核都已经用默认值的方式给弄好了。无奈业务之间差异太多，所以想一套参数适配所有的业务，基本上还是不可能的。还得靠工程师根据当前业务的特点来适当灵活调整。</p><p><strong>拓展阅读</strong>：</p><p><a href="https://zhuanlan.zhihu.com/p/62795773">Linux 内核 101：NUMA架构 - 知乎 (zhihu.com)</a></p><p><a href="https://www.jianshu.com/p/0607c5f62c51">浅解NUMA机制 - 简书 (jianshu.com)</a></p><p><a href="https://www.cnblogs.com/linhaostudy/p/10006723.html">Linux内存描述之内存区域zone–Linux内存管理(三) - yooooooo - 博客园 (cnblogs.com)</a></p><p><a href="https://www.dingmos.com/index.php/archives/23/#cl-2">Linux 内核 | 内存管理——Slab 分配器 - 一丁点儿 (dingmos.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/68465952">Linux中的物理内存管理 [一] - 知乎 (zhihu.com)</a></p></div><hr><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="chip bg-color">计算机网络</span> </a><a href="/tags/Linux/"><span class="chip bg-color">Linux</span> </a><a href="/tags/C/"><span class="chip bg-color">C</span> </a><a href="/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"><span class="chip bg-color">源码阅读</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="wechat,qq" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="/libs/share/js/social-share.min.js"></script></div></div></div></div></div><style>.valine-card{margin:1.5rem auto}.valine-card .card-content{padding:20px 20px 5px 20px}#vcomments textarea{box-sizing:border-box;background:url(/medias/comment_bg.png) 100% 100% no-repeat}#vcomments p{margin:2px 2px 10px;font-size:1.05rem;line-height:1.78rem}#vcomments blockquote p{text-indent:.2rem}#vcomments a{padding:0 2px;color:#4cbf30;font-weight:500;text-decoration:none}#vcomments img{max-width:100%;height:auto;cursor:pointer}#vcomments ol li{list-style-type:decimal}#vcomments ol,ul{display:block;padding-left:2em;word-spacing:.05rem}#vcomments ul li,ol li{display:list-item;line-height:1.8rem;font-size:1rem}#vcomments ul li{list-style-type:disc}#vcomments ul ul li{list-style-type:circle}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}#vcomments table,td,th{border:0}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments h1{font-size:1.85rem;font-weight:700;line-height:2.2rem}#vcomments h2{font-size:1.65rem;font-weight:700;line-height:1.9rem}#vcomments h3{font-size:1.45rem;font-weight:700;line-height:1.7rem}#vcomments h4{font-size:1.25rem;font-weight:700;line-height:1.5rem}#vcomments h5{font-size:1.1rem;font-weight:700;line-height:1.4rem}#vcomments h6{font-size:1rem;line-height:1.3rem}#vcomments p{font-size:1rem;line-height:1.5rem}#vcomments hr{margin:12px 0;border:0;border-top:1px solid #ccc}#vcomments blockquote{margin:15px 0;border-left:5px solid #42b983;padding:1rem .8rem .3rem .8rem;color:#666;background-color:rgba(66,185,131,.1)}#vcomments pre{font-family:monospace,monospace;padding:1.2em;margin:.5em 0;background:#272822;overflow:auto;border-radius:.3em;tab-size:4}#vcomments code{font-family:monospace,monospace;padding:1px 3px;font-size:.92rem;color:#e96900;background-color:#f8f8f8;border-radius:2px}#vcomments pre code{font-family:monospace,monospace;padding:0;color:#e8eaf6;background-color:#272822}#vcomments pre[class*=language-]{padding:1.2em;margin:.5em 0}#vcomments code[class*=language-],pre[class*=language-]{color:#e8eaf6}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}#vcomments b,strong{font-weight:700}#vcomments dfn{font-style:italic}#vcomments small{font-size:85%}#vcomments cite{font-style:normal}#vcomments mark{background-color:#fcf8e3;padding:.2em}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}.v .vlist .vcard{padding-top:2.5em!important}</style><div class="card valine-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;left:20px;top:15px;padding-bottom:5px"><i class="fa fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="vcomments" class="card-content" style="display:grid"></div></div><script src="/libs/valine/av-min.js"></script><script src="/libs/valine/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"98JpzSGcrl9jFqHO13vqxHvX-gzGzoHsz",appKey:"mDmr2h9PB20xvPMNqgyRnNIC",notify:!0,verify:!0,visitor:!0,avatar:"mm",pageSize:"10",lang:"zh-cn",placeholder:"just go go"})</script><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fa fa-chevron-left"></i>&nbsp;上一篇</div><div class="card"><a href="/posts/39535/"><div class="card-image"><img src="/medias/featureimages/20.jpg" class="responsive-img" alt="Redis分布式锁安全之问"> <span class="card-title">Redis分布式锁安全之问</span></div></a><div class="card-content article-content"><div class="summary block-with-text">分布式，现代架构的金钥匙</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2024-04-09 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/Redis/" class="post-category">Redis</a></span></div></div><div class="card-action article-tags"><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="chip bg-color">数据库</span> </a><a href="/tags/Redis/"><span class="chip bg-color">Redis</span> </a><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="chip bg-color">分布式</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fa fa-chevron-right"></i></div><div class="card"><a href="/posts/42952/"><div class="card-image"><img src="/medias/featureimages/5.jpg" class="responsive-img" alt="TCP协议中三次握手和四次挥手"> <span class="card-title">TCP协议中三次握手和四次挥手</span></div></a><div class="card-content article-content"><div class="summary block-with-text">该怎么深挖呢</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2024-04-07 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-category">计算机网络</a></span></div></div><div class="card-action article-tags"><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="chip bg-color">计算机网络</span> </a><a href="/tags/Linux/"><span class="chip bg-color">Linux</span></a></div></div></div></div></article></div><script>$("#articleContent").on("copy",function(e){var n,t,o,i;void 0!==window.getSelection&&((""+(n=window.getSelection())).length<Number.parseInt("120")||(t=document.getElementsByTagName("body")[0],(o=document.createElement("div")).style.position="absolute",o.style.left="-99999px",t.appendChild(o),o.appendChild(n.getRangeAt(0).cloneContents()),"PRE"===n.getRangeAt(0).commonAncestorContainer.nodeName&&(o.innerHTML="<pre>"+o.innerHTML+"</pre>"),i=document.location.href,o.innerHTML+='<br />来源: JoyTsing<br />文章作者: JoyTsing<br />文章链接: <a href="'+i+'">'+i+"</a><br />本文章著作权归作者joytsing所有，请任何形式的转载都请注明出处并在文章评论区处告知。",n.selectAllChildren(o),window.setTimeout(function(){t.removeChild(o)},200)))})</script><script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script><script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script><script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script><script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget"><div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fa fa-list"></i></a></div><script src="/libs/tocbot/tocbot.min.js"></script><script>$(function(){tocbot.init({tocSelector:"#toc-content",contentSelector:"#articleContent",headingsOffset:-(.4*$(window).height()-45),headingSelector:"h2, h3, h4, h5"});let t=0;var e="toc-heading-";$("#toc-content a").each(function(){$(this).attr("href","#"+e+ ++t)}),t=0,$("#articleContent").children("h2, h3, h4, h5").each(function(){$(this).attr("id",e+ ++t)});var n=parseInt(.4*$(window).height()-64);let o=$(".toc-widget");$(window).scroll(function(){var t=$(window).scrollTop();n<t?o.addClass("toc-fixed"):o.removeClass("toc-fixed")});var i="expanded";let a=$("#toc-aside"),c=$("#main-content");$("#floating-toc-btn .btn-floating").click(function(){a.hasClass(i)?(a.removeClass(i).hide(),c.removeClass("l9")):(a.addClass(i).show(),c.addClass("l9")),function(){let e=$("#artDetail");if(0!==e.length){let t=e.width();450<=t?t+=21:350<=t&&t<450?t+=18:300<=t&&t<350?t+=16:t+=14,$("#prenext-posts").width(t)}}()})})</script></main><footer class="page-footer bg-color"><div class="container row center-align"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2019</span> <a href="/about" rel="external nofollow noreferrer">JoyTsing</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br><span id="sitetime">载入运行时间...</span> <span id="busuanzi_container_site_pv">|&nbsp;<i class="fa fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span>&nbsp;次 </span><span id="busuanzi_container_site_uv">|&nbsp;<i class="fa fa-user"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv" class="white-color"></span>&nbsp;人</span><br>&nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;<span class="white-color">843.5k</span>&nbsp;字 <span id="icp"><img src="/medias/icp.png" style="vertical-align:text-bottom" alt="icp"> <a href="https://beian.miit.gov.cn/" target="_blank">陕公网安备61019002002862号 滇ICP备2024026466号-1</a></span><script>function siteTime(){var e=864e5,t="2019",n=(m=new Date).getFullYear(),o=m.getMonth()+1,r=m.getDate(),a=m.getHours(),i=m.getMinutes(),l=m.getSeconds(),m=Date.UTC(t,"7","24","0","0","0"),r=Date.UTC(n,o,r,a,i,l)-m,a=Math.floor(r/31536e6),i=Math.floor(r/e-365*a),l=Math.floor((r-(365*a+i)*e)/36e5),m=Math.floor((r-(365*a+i)*e-36e5*l)/6e4),M=Math.floor((r-(365*a+i)*e-36e5*l-6e4*m)/1e3);t==n?(document.getElementById("year").innerHTML=n,document.getElementById("sitetime").innerHTML="本站已安全运行 "+i+" 天 "+l+" 小时 "+m+" 分钟 "+M+" 秒"):(document.getElementById("year").innerHTML=t+" - "+n,document.getElementById("sitetime").innerHTML="本站已安全运行 "+a+" 年 "+i+" 天 "+l+" 小时 "+m+" 分钟 "+M+" 秒")}setInterval(siteTime,1e3)</script></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/JoyTsing" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fa fa-github"></i> </a><a href="/medias/wechat.jpg" target="_blank" data-tooltip="添加我的微信: [object Object]" data-position="top" data-delay="50"><i class="fa fa-weixin"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script src="/js/search.js"></script><script type="text/javascript">$(function(){searchFunc("/search.xml","searchInput","searchResult")})</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fa fa-angle-up"></i></a></div><script src="/libs/materialize/materialize.min.js"></script><script src="/libs/masonry/masonry.pkgd.min.js"></script><script src="/libs/aos/aos.js"></script><script src="/libs/scrollprogress/scrollProgress.min.js"></script><script src="/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="/js/matery.js"></script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?3a39d92b69933ae56c7eb41ffb9aa2e0";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="/libs/others/busuanzi.pure.mini.js"></script><script type="text/javascript">var st,OriginTitile=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="(oﾟvﾟ)ノ Hi",clearTimeout(st)):(document.title="(*´∇｀*) 欢迎回来！",st=setTimeout(function(){document.title=OriginTitile},3e3))})</script><script type="text/javascript" color="0,0,255" pointcolor="0,0,255" opacity="0.8" zindex="-1" count="150" src="/libs/background/canvas-nest.js"></script><script src="/libs/instantpage/instantpage.js" type="module"></script><script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script><script>const hasAttr = (e,a) => a.some(_=> e.attr(_)!==undefined);
        $('a').each(function() {
          const $this = $(this);
          if(hasAttr($this,["data-fancybox","ignore-external-link"])) return;
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== '' || window.location.host) {
                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/shizuku.model.json"},display:{position:"left",width:150,height:200},mobile:{show:!1},react:{opacity:.7}})</script></body></html>