<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="Cpp Core Guidelines, joytsing blog"><meta name="description" content="前言这篇文章实际上是C++ Core Guidelines解析的转载加上一些自己的理解(相当于自己集合一些觉得精华的内容放在自己blog上),废话少说。开始挖坑！
C++ Core Guidelines 由 16 个主要部分组成：

简介
"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="theme-color" content="white"><title>Cpp Core Guidelines | JoyTsing</title><link rel="apple-touch-icon" href="/"><link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="/favicon.ico"><link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css"><link rel="stylesheet" type="text/css" href="/libs/aos/aos.css"><link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css"><link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" type="text/css" href="/css/matery.css"><link rel="stylesheet" type="text/css" href="/css/my.css"><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style><script src="/libs/jquery/jquery.min.js"></script><script src="https://cdn-go.cn/aegis/aegis-sdk/latest/aegis.min.js"></script><script>const aegis=new Aegis({id:"6ojk8FlnQlqWeL6vQo",uin:"joyblog",reportApiSpeed:!0,reportAssetSpeed:!0,spa:!0,hostUrl:"https://rumt-sg.com"});console.log("aegis load")</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="JoyTsing" type="application/atom+xml"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><img src="/apple-touch-icon.png" class="logo-img" alt="LOGO"> <span class="logo-span">JoyTsing</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fa fa-home"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-tags"></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-bookmark"></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-archive"></i> <span>归档</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa fa-user-circle-o"></i> <span>关于</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa fa-envelope"></i> <span>留言</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa fa-address-book"></i> <span>友链</span></a></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fa fa-search" title="搜索"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="/medias/avatars/touxiang2.jpg" class="logo-img circle responsive-img"><div class="logo-name">JoyTsing</div><div class="logo-desc">joytsing的个人网站</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="m-nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-fw fa-bookmark"></i> 分类</a></li><li class="m-nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li class="m-nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa fa-fw fa-user-circle-o"></i> 关于</a></li><li class="m-nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa fa-fw fa-envelope"></i> 留言</a></li><li class="m-nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa fa-fw fa-address-book"></i> 友链</a></li><li><div class="divider"></div></li><li><a href="https://github.com/JoyTsing" class="waves-effect waves-light" target="_blank"><i class="fa fa-github-square fa-fw"></i>Follow Me</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#000;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href="https://github.com/JoyTsing" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Follow Me" data-position="left" data-delay="50"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a></nav></header><div class="bg-cover pd-header post-cover" style="background-image:url(/medias/featureimages/23.jpg)"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">Cpp Core Guidelines</h1></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{width:345px;padding-left:20px}.toc-widget .toc-title{margin:35px 0 15px 0;padding-left:17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content{height:calc(100vh - 250px);overflow:auto}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px;position:absolute;right:23.5vw;display:block}#toc-content .is-active-link{color:#42b983}#floating-toc-btn{position:fixed;right:15px;bottom:76px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/Cpp/"><span class="chip bg-color">Cpp</span> </a><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="chip bg-color">读书笔记</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="post-category">读书笔记</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp; 2023-12-05</div><div class="post-date info-break-policy"><i class="fa fa-calendar-check-o fa-fw"></i>更新日期:&nbsp;&nbsp; 2024-03-21</div><div class="info-break-policy"><i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp; 24.7k</div><div class="info-break-policy"><i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp; 95 分</div><div id="busuanzi_container_page_pv" class="info-break-policy"><i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp; <span id="busuanzi_value_page_pv"></span></div></div></div><hr class="clearfix"><div class="card-content article-card-content"><div id="articleContent"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章实际上是<a href="https://zhuanlan.zhihu.com/p/662592729">C++ Core Guidelines</a>解析的转载加上一些自己的理解(相当于自己集合一些觉得精华的内容放在自己blog上),废话少说。开始挖坑！</p><p>C++ Core Guidelines 由 16 个主要部分组成：</p><ul><li>简介</li><li>理念</li><li>接口</li><li>函数</li><li>类和类的层次结构</li><li>枚举</li><li>资源管理</li><li>表达式和语句</li><li>性能</li><li>并发性</li><li>错误处理</li><li>常量和不变性</li><li>模板和泛型编程</li><li>C 风格编程</li><li>源文件</li></ul><h2 id="理念"><a href="#理念" class="headerlink" title="理念"></a>理念</h2><p>理念性规则概览：理念性规则强调一般性，因此，无法进行检查。不过，理念性规则为下面的具体规则提供了理论依据。一共有 13 条理念性规则。可以简单理解为一般情况下的编码规范。</p><h3 id="P-1-在代码中直接表达思想"><a href="#P-1-在代码中直接表达思想" class="headerlink" title="P.1 在代码中直接表达思想"></a>P.1 在代码中直接表达思想</h3><p>编译器是不会去读注释（或设计文档）的，许多程序员也（固执地）不去读它们。 而代码中所表达的东西是带有 明确的语义 的，并且（原则上）是可以由编译器和其他工具进行检验的。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Date</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    Month <span class="token function">month</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 好</span>
    <span class="token keyword">int</span> <span class="token function">month</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 不好</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一个 <code>month</code> 比第二个，有更多的信息，以 <code>const</code> 修饰，代表不会修改当前的日期，返回类型 <code>Month</code> 也非常明确。</p><blockquote><p>成员函数修饰 <code>const</code> 是为什么，能做什么。只是默认，不修改当前类的数据成员就要加 <code>const</code>，明确语义，增加可读性。 <strong>但不够正确，也远不止如此</strong>。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>

<span class="token keyword">class</span> <span class="token class-name">Date</span> <span class="token punctuation">{</span>
    <span class="token keyword">using</span> Month <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    Month m<span class="token punctuation">;</span>

    <span class="token keyword">int</span> <span class="token function">month</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> m<span class="token punctuation">;</span> <span class="token punctuation">}</span>          
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date<span class="token operator">&amp;</span> date<span class="token punctuation">)</span><span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> date<span class="token punctuation">.</span><span class="token function">month</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    Date d<span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">func</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码会得到一个编译错误，这应该是很常见的调用方式。为什么呢？显然，就是因为 <code>month</code> 成员函数没有以 <code>const</code> 修饰。<strong><code>C++</code> 不允许 const 的对象调用没有以 const 修饰的成员函数</strong>，事实上这个语义非常的合理：我都是 const 对象了，你为啥要修改？但是明明 <code>month</code> 函数根本没有修改对象的数据，所以这其实是开发者的问题，不应该写出这种代码。当前的语境很简单，我们只需要改成：</p><p>但是明明 <code>month</code> 函数根本没有修改对象的数据，所以这其实是开发者的问题，不应该写出这种代码。</p><p>当前的语境很简单，我们只需要改成：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Month <span class="token function">month</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> m<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// const 对象和非 const 对象都能调用</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果你阅读过 <code>STL</code> 源码，或者看过基本的<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/container/array">文档</a>，会知道，<strong>大部分成员函数都要提供 <code>const</code> 和非 <code>const</code> 两种版本，我们以 <code>std::array</code> 的 <code>operator[]</code> 为例</strong>。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> reference <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span> size_type pos <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">constexpr</span> const_reference <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span> size_type pos <span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两个成员函数都不会修改自己存储的对象，但是为什么要写 <code>const</code> 版本呢？<strong>注意返回类型</strong>。</p><ul><li>如果没有以 const 修饰的 std::array 对象，那么它调用 <code>operator[]</code> 自然是可以修改的，行为就像普通数组那样，我们就返回 <code>reference</code>。</li><li>如果是以 const 修饰的 std::array 对象，那么它调用 <code>operator[]</code> 根据我们的语义，自然不该让它外部能够修改，所以我们返回 <code>const_reference</code>。</li></ul><p><strong>一个成员函数是否以 const 修饰，不在于这个成员函数到底是否会修改自己的成员，而在于 “可变性”。</strong></p><p>相对于 标准库（STL）的算法，使用 for 或 while 等方式的手工循环通常也有上面一样的可读性问题。比如下面这样：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                          <span class="token comment" spellcheck="true">//不好</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>
        index <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">auto</span> it <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//更好</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个专业的 C++ 开发者应该了解 <strong>STL 算法</strong>。使用它们的话，你就可以避免显式使用循环，你的代码也会变得更容易理解，更容易维护，因此，也更不容易出错。现代 C++ 中有一句谚语：</p><ul><li><em>如果你显式使用循环的话，说明你不了解 STL 算法。</em></li></ul><blockquote><p>其实就是说成员函数注意返回类型的名字，和 const 修饰，增加可读性。 多使用 STL 算法，而不是自己搓，既能增加可读性也能减少错误。</p></blockquote><h3 id="P-2-用-ISO-标准写代码"><a href="#P-2-用-ISO-标准写代码" class="headerlink" title="P.2 用 ISO 标准写代码"></a>P.2 用 ISO 标准写代码</h3><p>要想得到一个可移植的 C++ 程序，最好的选择就是按照标准写代码。</p><p>使用当前的 C++ 标准，不要使用编译器扩展，同时注意，<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/ub">未定义行为和实现定义行为</a>。</p><p><strong>当你必须使用没有写在 ISO 标准里的扩展时，可以用一个稳定的接口将它们封装起来</strong>。</p><blockquote><p>比如将使用的编译器扩展用宏封装起来，以后如果要修改，或者说要适应别的平台，都很方便。举一个古代<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/jGfGz941G">例子</a>：</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">if</span> __cplusplus >= 201103L</span>
<span class="token macro property">#<span class="token directive keyword">define</span> INLINE inline</span>
<span class="token macro property">#<span class="token directive keyword">else</span></span>
<span class="token macro property">#<span class="token directive keyword">define</span> INLINE __attribute__((__always_inline__))</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="P-3-表达意图"><a href="#P-3-表达意图" class="headerlink" title="P.3 表达意图"></a>P.3 表达意图</h3><p>以下的隐式和显式循环中，你能看出什么意图？</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> v<span class="token operator">:</span> vec<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>                              <span class="token comment" spellcheck="true">// (1)</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> v<span class="token operator">:</span> vec<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>                                    <span class="token comment" spellcheck="true">// (2)</span>
std<span class="token operator">::</span><span class="token function">for_each</span><span class="token punctuation">(</span>std<span class="token operator">::</span>execution<span class="token operator">::</span>par<span class="token punctuation">,</span> vec<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// (3) 很抽象，这种形式其实根本做不到，当伪代码就好</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>循环（1）不修改容器 vec 的元素。（2）有可能修改。算法 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/algorithm/for_each">std::for_each</a>（3）以并行方式（<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/algorithm/execution_policy_tag_t">std::execution::par</a>）执行。这意味着我们不关心处理的顺序。<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/hxfdnT6W8">举个例子</a>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>vec<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span><span class="token function">for_each</span><span class="token punctuation">(</span>std<span class="token operator">::</span>execution<span class="token operator">::</span>par<span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//打印的顺序是随机的</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span><span class="token function">for_each</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//12345</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>表达意图也是良好代码文档的一个重要准测。</p><ul><li><em>文档应该说明代码会做什么，而不是代码会怎么做</em>。</li></ul><blockquote><p>其实这里是在指，文档应该讲功能，而非实现细节。 不过事实上技术文档一般都不会完全这样，多少会提一些实现细节的，具体情况具体分析。</p></blockquote><h3 id="P-4-理想情况下，程序应该是静态类型安全的"><a href="#P-4-理想情况下，程序应该是静态类型安全的" class="headerlink" title="P.4 理想情况下，程序应该是静态类型安全的"></a>P.4 理想情况下，程序应该是静态类型安全的</h3><p>C++ 是一种静态类型的语言。静态类型意味着编译器知道数据的类型，此外，还说明，编译器可以检测到类型错误。 由于现有的问题领域，我们并非一直能够达到这一目标，但对于联合体、转型(cast)、数组退化、范围错误或窄化转换，确实是有办法的。</p><ul><li>在 C++17 中，可以使用 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/utility/variant">std::variant</a> 安全地替代<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/union">联合体</a>。</li><li>基于模板的泛型代码减少了转型的需要，因此，也减少了类型错误。<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/YrfcvsTGY">如</a>。</li><li>当用一个 C 数组调用一个函数时，就会发生<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/implicit_conversion">数组退化</a>。函数需要用指向数组第一个元素的指针，另加数组的长度。这意味着，你从一个类型丰富的数据结构 C 数组开始，却以类型极差的数组首项指针结束。<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/KPPcP5j89">解决方法</a>在 C++20 里：<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/container/span">std::span</a>。std::span 可以自动推算出 C 数组的大小，也可以防止范围错误的发生。如果你还没有使用 C++20，请使用 Guidelines 支持库（GSL）提供的实现。</li><li><a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/list_initialization">窄化转换</a>是对算术值的有精度损失的隐式转换。</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">i1</span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> i2 <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果你使用 {} 初始化语法，编译器就能<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/j6GTbGvvn">检测到窄化转换</a>。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> i1<span class="token punctuation">{</span><span class="token number">3.14</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> i2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">3.14</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="P-5-编译期检查优先于运行期检查"><a href="#P-5-编译期检查优先于运行期检查" class="headerlink" title="P.5 编译期检查优先于运行期检查"></a>P.5 编译期检查优先于运行期检查</h3><ul><li><em>如果可以在编译期检查，那就应该在编译期检查</em>。</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// Int 被用作整数的别名</span>
<span class="token keyword">int</span> bits <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 请勿如此: 可以避免的代码</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>Int i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token punctuation">;</span> i <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token operator">++</span>bits<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>bits <span class="token operator">&lt;</span> <span class="token number">32</span><span class="token punctuation">)</span>
    cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"Int too small\n"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个例子并没有达成其所要达成的目的（因为溢出是未定义行为），应当被替换为简单的 static_assert：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// Int 被用作整数类型的别名</span>
<span class="token keyword">static_assert</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Int<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// do: 编译时检查</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>或者更好的方式是直接利用类型系统，将 int 替换 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/types/integer">int32_t</a>。</p><blockquote><p>如果当前环境有 int32_t 这个别名，那么代表，你的环境支持 32位整数类型。</p></blockquote><p>或用来检测<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/meta%23.E7.B1.BB.E5.9E.8B.E7.89.B9.E6.80.A7">类型特征</a>（type traits），比如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">static_assert</span><span class="token punctuation">(</span>std<span class="token operator">::</span>is_integral_v<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="P-6-不能在编译期检查的事项应该在运行期检查"><a href="#P-6-不能在编译期检查的事项应该在运行期检查" class="headerlink" title="P.6 不能在编译期检查的事项应该在运行期检查"></a>P.6 不能在编译期检查的事项应该在运行期检查</h3><p>因为有 <code>dynamic_cast</code> ，可以安全的将类的指针和引用沿着继承层次结构进行向上，向下以及测向的转换。如果转型失败，</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span> 新类型 <span class="token operator">></span><span class="token punctuation">(</span> 表达式 <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果转型失败且 新类型 是指针类型，那么它会返回该类型的空指针。</p><p>如果转型失败且 新类型 是引用类型，那么它会抛出与类型 <code>std::bad_cast</code> 的处理块匹配的异常。</p><p>第五章中 “dynamic_cast” 一节中会有更多的细节。</p><h3 id="P-7-尽早识别运行期错误"><a href="#P-7-尽早识别运行期错误" class="headerlink" title="P.7 尽早识别运行期错误"></a>P.7 尽早识别运行期错误</h3><p>可以采取很多对策来摆脱运行期错误。管理好指针和 C 数组，检查他们的范围。对于转换，同样需要检测：</p><ul><li><em>如有可能，应尽量避免转换，对于窄化转换，尤其如此。检查输入也属于这个范畴</em>。</li></ul><h3 id="P-8-不要泄露任何资源"><a href="#P-8-不要泄露任何资源" class="headerlink" title="P.8 不要泄露任何资源"></a>P.8 不要泄露任何资源</h3><p>资源可以是内存、文件句柄、套接字，等等。处理资源的惯用法是 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/raii">RAII</a> 。RAII 是资源获取即初始化（Resource Acquisition Is Initialization）。 是一种 C++ 编程技术，它将必须在使用前请求的资源（分配的堆内存、执行线程、打开的套接字、打开的文件、锁定的互斥体、磁盘空间、数据库连接等——任何存在受限供给中的事物）的生命周期与一个对象的生存期相绑定。 即：构造函数中获取资源，析构函数中释放资源。</p><p>C++ 大量使用 RAII：锁负责处理互斥量，智能指针负责处理原始内存，STL 的容器负责处理底层元素，等等。</p><blockquote><p>这里居然用中文的 “锁” 这个字来指代那些通用锁管理类（<code>std::lock_guard</code>），原书这里用这个字描述是有问题的，请不要模仿。</p></blockquote><h3 id="P-9-不要浪费时间和空间"><a href="#P-9-不要浪费时间和空间" class="headerlink" title="P.9 不要浪费时间和空间"></a>P.9 不要浪费时间和空间</h3><p>节省时间和空间都是一种美德。我们用的是 C++。你发现下面循环中的问题了吗？</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">lower</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string s<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> std<span class="token operator">::</span><span class="token function">strlen</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
        s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">tolower</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>虽然是个错误示例，但这代码写的太过愚蠢了，函数形参不用引用直接拷贝是其一，s 明明是个 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/string/basic_string">std::string</a> 对象，不去调用 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/string/basic_string/size">size()</a> 成员函数，跑去用 C 标准库的玩意？</p></blockquote><p>使用 STL 中的算法 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/algorithm/transform">std::transform</a> ，就可以把前面的函数变成一行。</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span><span class="token function">transform</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">tolower</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>与函数 lower 相比，算法 std::transform 自动确定了字符串的大小。因此，你不需要使用 std::strlen 指定字符串的长度。</p><p>下面是另一个经常出现在生产代码中的典型例子。为一个用户定义的数据类型声明拷贝语义。（拷贝构造函数和拷贝赋值运算符）。最终，编译器永远用不了廉价的移动语义。（即使实际上移动是适用的），而只能一直依赖代价高昂的拷贝语义。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> S<span class="token punctuation">{</span>
    std<span class="token operator">::</span>string s_<span class="token punctuation">;</span>
    <span class="token function">S</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string s<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">s_</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token function">S</span><span class="token punctuation">(</span><span class="token keyword">const</span> S<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">s_</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>s_<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    S<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> S<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span> s_ <span class="token operator">=</span> rhs<span class="token punctuation">.</span>s_<span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp"><code class="language-cpp">S s1<span class="token punctuation">;</span>
S s2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//进行拷贝，而不能从 s1.s_ 移动。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>这里没有任何问题，但是我们详细的描述一下，因为我觉得很多人不清楚移动语义能带来什么。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//不修改 S 类</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    S s1<span class="token punctuation">{</span> <span class="token string">"aaaaaaaaaaaaaaaa"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span>s_<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    S s2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span>s_<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/5Kr51KeMo">打印</a>的地址不一样，这代表实际上是复制了 <code>std::string</code> 管理的数据的。</p><p>但是，如果我们修改 S 类，比如直接把复制构造和复制赋值运算符给删了，会怎么样？</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>

<span class="token keyword">struct</span> S<span class="token punctuation">{</span>
    std<span class="token operator">::</span>string s_<span class="token punctuation">;</span>
    <span class="token function">S</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string s<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">s_</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    S s1<span class="token punctuation">{</span><span class="token string">"aaaaaaaaaaaaaaaa"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span>s_<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    S s2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span>s_<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/4rGxq1h5Y">打印</a>的地址完全一致。</p><p>这代表了 std::string 对象管理的数据并没有真的进行复制。</p><p>我们讲一下为什么：没有了复制构造函数和复制赋值运算符后，移动构造不会再被抑制了，编译器可以<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/move_constructor">隐式定义移动构造函数</a>。</p><p>这个隐式定义的移动构造函数，你大约可以理解为，我们的 <code>S s2 = std::move(s1)</code> 这里调用了 S 的移动构造函数，那么，它的数据成员，同时，也会被 移动，如果是类类型，且有移动构造函数的话，会被调用，相当于，<code>std::string</code> 被调用了移动构造，然后进行了转移。我们知道 std::string 的移动构造，是转移所有权（其实你就可以理解为把原对象的指向数据的指针给了我们当前的对象，然后原对象赋空）。</p><p>我们举个例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>

<span class="token keyword">struct</span> X<span class="token punctuation">{</span>
    <span class="token function">X</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
    <span class="token function">X</span><span class="token punctuation">(</span>X<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"X(X&amp;&amp;)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token function">X</span><span class="token punctuation">(</span><span class="token keyword">const</span> X<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"X(const X&amp;)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">X</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> Y<span class="token punctuation">{</span>
    X x<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Y y1<span class="token punctuation">;</span>
    Y y2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>y1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码会打印一个 <code>X(X&amp;&amp;)</code>，这证明了我们前面说的：</p><p>编译器隐式定义的移动构造函数，被调用，相当于会把自身的数据成员也进行移动，如果它是类类型，且有移动构造，那么也会匹配上，进行调用。</p><h3 id="P-10-不可变数据优先于可变数据"><a href="#P-10-不可变数据优先于可变数据" class="headerlink" title="P.10 不可变数据优先于可变数据"></a>P.10 不可变数据优先于可变数据</h3><p>使用不可变数据的理由有很多。首先，当你使用常量时，你的代码更容易验证。<strong>常量也有更高的优化潜力</strong>。但最重要的是，常量在并发程序中具有很大的优势。不可变数据在设计上是没有数据竞争的，因为数据竞争的必要条件就是对数据进行修改。</p><blockquote><p>其实只需要考虑一个事情：<strong>如果它可以是常量，那就把它设置为常量</strong>。</p></blockquote><h3 id="P-11-封装杂乱的构建，不要让它在代码中散布开"><a href="#P-11-封装杂乱的构建，不要让它在代码中散布开" class="headerlink" title="P.11 封装杂乱的构建，不要让它在代码中散布开"></a>P.11 封装杂乱的构建，不要让它在代码中散布开</h3><p>混乱的代码往往是低级代码，易于隐藏错误，容易出问题。如果可能的话，用 STL 中的高级构建（如容器或算法）来取代你的杂乱代码。如果这不可能，就把那些杂乱代码封装到一个用户定义的类型或函数中去。</p><h3 id="P-12-适当使用辅助工具"><a href="#P-12-适当使用辅助工具" class="headerlink" title="P.12 适当使用辅助工具"></a>P.12 适当使用辅助工具</h3><p>计算机比人类更擅长做枯燥和重复性的工作。也就是说，应该使用静态分析工具、并发工具和测试工具来自动完成这些验证步骤。<strong>用一个以上的 C++ 编译器来编译代码，往往是验证代码的最简方式</strong>。一个编译器可能检测不到某种未定义行为，而另一个编译器可能会在同样情况下发出警告或产生错误。</p><h3 id="P-13-适当使用支持库"><a href="#P-13-适当使用支持库" class="headerlink" title="P.13 适当使用支持库"></a>P.13 适当使用支持库</h3><p>这也很好解释。你应该去找设计良好、文档齐全、支持良好的库。你会得到经过良好测试、<strong>几乎</strong>没有错误的库，其中的算法经过领域专家的高度优化。突出的例子包括：<strong>C++ 标准库</strong>、Guidelines 支持库和 Boost 库。</p><blockquote><p>我觉得一定有人看到这段会嗤之以鼻，但是总体其实没错的。</p></blockquote><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口是服务的提供者和使用者之间的契约。根据 C++ Core Guidelines，接口”可能是代码辅助中最重要的一个方面”。“接口”这一部分大约有 20 条规则。</p><blockquote><p><em>让接口易于正确使用，难以错误使用</em>。</p></blockquote><h3 id="I-2-避免非-const-的全局变量"><a href="#I-2-避免非-const-的全局变量" class="headerlink" title="I.2 避免非 const 的全局变量"></a>I.2 避免非 const 的全局变量</h3><p>当然，你应该避免非 const 的全局变量。但是为什么呢？为什么全局变量（尤其是当它不是常量时）会很糟糕？<strong>全局变量会在函数中注入隐藏的依赖，而该依赖并不是接口的一部分</strong>。下面的代码片段说明了我的观点：</p><blockquote><p>加粗的话注意理解。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> glob<span class="token punctuation">{</span> <span class="token number">2011</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">multiply</span><span class="token punctuation">(</span><span class="token keyword">int</span> fac<span class="token punctuation">)</span><span class="token punctuation">{</span>
    glob <span class="token operator">*</span><span class="token operator">=</span> glob<span class="token punctuation">;</span>
    <span class="token keyword">return</span> glob <span class="token operator">*</span> fac<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数 multiply 的执行有一个副作用——会改变全局变量 glob 的值。因此，<strong>你无法对函数进行孤立测试或推理</strong>。当更多的线程并发地使用 multiply 时，你就必须对变量 glob 加以保护。非 const 的全局变量还有更多其他弊端。<strong>如果函数 multiply 没有副作用，那你可以为了性能而将之前的结果存储到缓存中以进行复用。</strong></p><blockquote><p>注意到我们加粗的内容了吗？这非常重要，自行理解。 我们就讲一下最后一句，这其实是在描述<strong>编译器优化</strong> ，我们举个例子：什么情况才可能会是我们说的：<strong>没有副作用，那你可以为了性能而将之前的结果存储到缓存中以进行复用</strong>。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实无非就是：编译器看到你用同样的入参调用了两次 就可以干掉第二次调用。之前的结果被缓存了。（前提是这得是<a href="https://en.m.wikipedia.org/wiki/Pure_function">纯函数</a>）。</p><p>但是我们前面依赖了全局变量，就不行，它有外部的副作用，返回的结果可能会根据全局变量的不同而不同，没办法缓存。不能保证：<strong>多次调用传入的数据相同就能得到完全一致的结果</strong>。</p><h3 id="3-1-非-const-全局变量的弊端"><a href="#3-1-非-const-全局变量的弊端" class="headerlink" title="3.1 非 const 全局变量的弊端"></a>3.1 非 const 全局变量的弊端</h3><p>非 const 的全局变量有许多弊端。首当其冲的弊端是，<strong>非 const 的全局变量破坏了封装。这种对封装的破坏让你无法对函数/类（实体）进行独立思考</strong>。下面列举非 const 全局变量的主要弊端。</p><ul><li><strong>可测试性</strong>：无法孤立地测试你的实体。如果单元不存在，那么单元测试也将不存在。你只能进行系统测试。实体的执行效果要依赖整个系统状态。</li><li><strong>重构</strong>：因为你无法孤立地对代码进行推理，重构它会相当有挑战。</li><li><strong>优化</strong>：你无法轻易地重新安排函数调用或者在不同的线程上进行函数调用，因为可能有隐藏的依赖。缓存之前函数调用的结果也极为危险。</li><li><strong>并发</strong>：产生数据竞争的必要条件是有共享而可变的状态。而非 const 全局变量正是共享而可变的。</li></ul><h3 id="I-3-避免单例"><a href="#I-3-避免单例" class="headerlink" title="I.3 避免单例"></a>I.3 避免单例</h3><p>有时，全局变量伪装得很好。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// singleton.cpp</span>

<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>

<span class="token keyword">class</span> <span class="token class-name">MySingleton</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">MySingleton</span><span class="token punctuation">(</span><span class="token keyword">const</span> MySingleton<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
    MySingleton<span class="token operator">&amp;</span> <span class="token keyword">operator</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> MySingleton<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>

    <span class="token keyword">static</span> MySingleton<span class="token operator">*</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>instance<span class="token punctuation">)</span><span class="token punctuation">{</span>
            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">MySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">static</span> MySingleton<span class="token operator">*</span> instance<span class="token punctuation">;</span>
    <span class="token function">MySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
    <span class="token operator">~</span><span class="token function">MySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

MySingleton<span class="token operator">*</span> MySingleton<span class="token operator">::</span>instance <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><em>单例就是全局变量，因此你应当尽可能*</em>避免单例***。</li></ul><p>单例简单、直接地保证该类最多只有一个实例存在。作为全局变量，单例注入了一个依赖，而该依赖忽略了函数的接口。这是因为作为静态变量，单例通常会被直接调用，正如上面例子主函数中的两行所展示的那样：Singleton::getInstance()。而对单例的直接调用有一些严重的后果。你无法对有单例的函数进行<strong>单元测试</strong>，因为单元不存在。此外，你也不能创建单例的伪对象并在运行期替换，因为单例并不是函数接口的一部分。</p><blockquote><p>我们先聊一下最后一句话：其实就是说，我没办法创造一个和单例一样类型的对象，然后进行函数传参。因为单例不是函数接口的一部分，它通常会被直接调用。 另外，我们要明白，“单例” 它是<strong>带状态</strong>的，单例的状态是经常变化和难以确定的，因为大家都使用和修改这个单例。如果某个函数使用了这个单例，就没办法对它进行单独的单元测试，因为单例的状态无法确定，单例的状态依赖于所有修改它的代码。这也就是前面说的：<strong>你无法对有单例的函数进行单元测试</strong>。</p></blockquote><ul><li><em>简而言之，单例破坏了代码的可测试性</em>。</li></ul><p>实现单例看似小事一桩，但其实不然。你将面对几个挑战：</p><ul><li>谁来负责单例的销毁？</li><li>是否应该允许从单例派生？</li><li>如何以线程安全的方式初始化单例？</li><li>当单例互相依赖并属于不同的翻译单元时，应该以何种顺序初始化这些单例？这里要吓唬吓唬你了。这一难题被称为<strong><a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/xd3G9sh7P">静态初始化顺序问题</a></strong>。</li></ul><h3 id="3-2-运用依赖注入化解"><a href="#3-2-运用依赖注入化解" class="headerlink" title="3.2 运用依赖注入化解"></a>3.2 运用依赖注入化解</h3><p><strong>当某个对象使用单例的时候，注入的依赖就被注入对象中</strong>。而借助依赖注入技术，这个依赖可以变成接口的一部分，并且服务时从外界注入的。这样，客户代码和注入的服务之间就没有依赖了。依赖注入的典型方式是构造函数、设置函数（setter）成员或模板参数。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;chrono></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span>

<span class="token keyword">class</span> <span class="token class-name">Logger</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Logger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">SimpleLogger</span><span class="token operator">:</span><span class="token keyword">public</span> Logger<span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> mess<span class="token punctuation">)</span> override<span class="token punctuation">{</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> mess <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">TimeLogger</span><span class="token operator">:</span><span class="token keyword">public</span> Logger<span class="token punctuation">{</span>
    <span class="token keyword">using</span> MySecondTick <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>duration<span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> <span class="token keyword">double</span> <span class="token function">timeSinceEpoch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">auto</span> timeNow <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>system_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">auto</span> duration <span class="token operator">=</span> timeNow<span class="token punctuation">.</span><span class="token function">time_since_epoch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        MySecondTick <span class="token function">sec</span><span class="token punctuation">(</span>duration<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> sec<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> mess<span class="token punctuation">)</span> override<span class="token punctuation">{</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>fixed<span class="token punctuation">;</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Time since epoch: "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">timeSinceEpoch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> mess <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Client</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Client</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Logger<span class="token operator">></span>log<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">logger</span><span class="token punctuation">(</span>log<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        logger<span class="token operator">-</span><span class="token operator">></span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"Message"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">setLogger</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Logger<span class="token operator">></span>log<span class="token punctuation">)</span><span class="token punctuation">{</span>
        logger <span class="token operator">=</span> log<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Logger<span class="token operator">></span>logger<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    Client <span class="token function">cl</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>SimpleLogger<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//（1）</span>
    cl<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cl<span class="token punctuation">.</span><span class="token function">setLogger</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>TimeLogger<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// （2）</span>
    cl<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cl<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-构建良好的接口"><a href="#3-3-构建良好的接口" class="headerlink" title="3.3 构建良好的接口"></a>3.3 构建良好的接口</h3><ul><li><em>函数应该通过接口（而不是全局变量）进行沟通</em>。</li></ul><p>现在我们来到了本章的核心。按照 C++ Core Guidelines，下面是关于接口的建议。</p><ul><li>接口明确（I.1）</li><li>接口精确并具有强类型（I.4）</li><li>保持较低的参数数目（I.23）</li><li>避免相同类型却不相关的参数相邻（I.24）</li></ul><p>下面的函数 showRectangle 违反了刚提及的接口的所有规则：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">showRectangle</span><span class="token punctuation">(</span><span class="token keyword">double</span> a<span class="token punctuation">,</span><span class="token keyword">double</span> b<span class="token punctuation">,</span><span class="token keyword">double</span> c<span class="token punctuation">,</span><span class="token keyword">double</span> d<span class="token punctuation">)</span><span class="token punctuation">{</span>
    a <span class="token operator">=</span> <span class="token function">floor</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    b <span class="token operator">=</span> <span class="token function">ceil</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">showRectangle</span><span class="token punctuation">(</span>Point top_left<span class="token punctuation">,</span> Point bottom_right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 好</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>尽管函数 showRectangle 本应当只显示一个矩形，但修改了它的参数。实质上它有两个目的，因此，它的名字有误导性（I.1）。另外，函数签名没有提供关于参数应该是什么的任何信息，也没有关于应该以什么顺序提供参数的信息（I.23 和 I.24）。此外，参数是没有取值范围约束的双精度浮点数。因此，这种约束必须在函数中确立（I.4）。对比而言，第二个 showRectangle 函数接受两个具体的点对象（Point）。</p><ul><li><em>检查 Point是否合法值是 Point 构造函数的工作。这种检查工作本来就不是函数 showRectangle 的职责</em>。</li></ul><p>进一步阐述规则 <strong>I.23</strong> 和 <strong>I.24</strong> 以及标准模板库（STL）中的函数 <strong><code>std::transform_reduce</code></strong>。首先，需要定义属于“<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/named_req/Callable">可调用</a>”（callable）。可调用实体是在行为上像函数的东西。它可以是函数，也可以是函数对象，或者是 lambda 表达式。如果可调用实体接受一个参数，它就是一元可调用实体；如果它接受两个参数，则称为二元可调用实体。</p><p>std::transform_reduce 先将一元可调用实体应用到一个范围或将二元可调用实体应用在两个范围，然后将二元可调用实体应用到前一步的结果的范围上。当你使用一个一元 lambda 表达式调用 std::transform_reduce时，这种调用易于正确使用。</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span>strVec<span class="token punctuation">{</span><span class="token string">"Only"</span><span class="token punctuation">,</span> <span class="token string">"for"</span><span class="token punctuation">,</span> <span class="token string">"testing"</span><span class="token punctuation">,</span> <span class="token string">"purpose"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>size_t res <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">transform_reduce</span><span class="token punctuation">(</span>
    std<span class="token operator">::</span>execution<span class="token operator">::</span>par<span class="token punctuation">,</span>
    strVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> strVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t a<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t b<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//res 值为 21。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>事实上原书给的上面这段代码是有问题的，无法在 <code>msvc</code> 通过编译，这里使用的是 <code>0</code> 做初始值，有窄化转换，<a href="https://zhuanlan.zhihu.com/p/662592729/https://github.com/microsoft/STL/blob/adea8d5ae280cafb91ae69b8dfaecd1c37a847d9/stl/inc/execution#L4235">msvc 使用的是 {} 初始化</a>。，检测到了，于是编译错误。（但是需要注意，不是简单的 <code>{}</code> 检测的问题，msvc 的实现和其他 stl 从根本上就不一样） 这里其实可以算作是 msvc 的bug，这个场景需要良构 这里应该把 0 换成 <code>Oull</code> （基于当前 64 位环境），或者标准够高使用 <code>0uz</code>，再或者直接 <code>std::size_t{0}</code>。</p></blockquote><p>函数 <code>std::transform_reduce</code> 先将每个字符串变换为它的长度 <code>[](std::string s) {return s.size(); }</code> , 并将二元可调用实体 <code>[](std::size_t a, std::size_t b) {return a + b; },</code> 应用到结果的范围上。求和的初始值是 0。整个计算是并行的 <code>std::execution::par</code>。</p><p>当你使用以下接受两个二元可调用实体的重载版本时，函数声明会变得相当复杂且易错。这违反了 I.23 和 I.24。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ExecutionPolicy</span><span class="token punctuation">,</span>
         <span class="token keyword">class</span> <span class="token class-name">ForwardIt1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">ForwardIt2</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">BinaryOp1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">BinaryOp2</span><span class="token operator">></span>
T <span class="token function">transform_reduce</span><span class="token punctuation">(</span>ExecutionPolicy<span class="token operator">&amp;&amp;</span> policy<span class="token punctuation">,</span>
                   ForwardIt1 first1<span class="token punctuation">,</span> ForwardIt1 last1<span class="token punctuation">,</span> ForwardIt2 first2<span class="token punctuation">,</span>
                   T init<span class="token punctuation">,</span> BinaryOp1 binary_op1<span class="token punctuation">,</span> BinaryOp2 binary_op2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用这个重载函数需要 6 个模板参数和 7 个函数参数。按正确顺序使用两个二元可调用实体，可能也是个挑战。</p><blockquote><p>我们展示一下使用这个重载函数的示例代码</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span>strVec<span class="token punctuation">{</span><span class="token string">"Only"</span><span class="token punctuation">,</span> <span class="token string">"for"</span><span class="token punctuation">,</span> <span class="token string">"testing"</span><span class="token punctuation">,</span> <span class="token string">"purpose"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span>vec<span class="token punctuation">{</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token string">"d"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>size_t res <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">transform_reduce</span><span class="token punctuation">(</span>
    std<span class="token operator">::</span>execution<span class="token operator">::</span>par<span class="token punctuation">,</span>
    strVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> strVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    std<span class="token operator">::</span>size_t<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t a<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t b<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string s<span class="token punctuation">,</span> std<span class="token operator">::</span>string s2<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>res</code> <a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/oeffEexrc">结果</a> 是 25。</p><p>函数 std::transform_reduce 复杂的原因在于两个函数被合并成了一个。更好的选择应该是分别定义函数 transform 和 reduce，并支持管道运算符调用：<strong>transform | reduce</strong>。</p><h3 id="I-13-不要用单个指针来传递数组"><a href="#I-13-不要用单个指针来传递数组" class="headerlink" title="I.13 不要用单个指针来传递数组"></a>I.13 不要用单个指针来传递数组</h3><ul><li><em>不要用单个指针来传递数组</em>。</li></ul><p>这是一条非常特殊的规则，肯定会有很多人不屑一顾。这条规则的出现正是为了解决一些未定义行为。例如下面的函数 copy_n 相当容易出错。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">copy_n</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">*</span> p<span class="token punctuation">,</span> T<span class="token operator">*</span> q<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 从[p:p+n] 拷贝到 [q:q+n]</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">copy_n</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token number">101</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也许某一天累得精疲力尽，就数错了一个。结果会引发一个元素的越界错误，造成未定义行为。补救方法也很简单，使用 STL 中的容器，如 <strong>std::vector</strong>，并在函数体中检查容器大小。C++20 提供的 std::span 能更优雅地解决这个问题。<strong>std::span</strong> 是个对象，它可以指代连续存储的一串对象。 std::span 永远不是所有者（其实就是说它是个视图，没所有权）。而这段连续的内容可以是数组，或是带有大小的指针，或是 std::vector。</p><blockquote><p>函数传参数组不用指针，而是用 C++20 的 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/container/span">std::span</a>。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">copy</span><span class="token punctuation">(</span>std<span class="token operator">::</span>span<span class="token operator">&lt;</span><span class="token keyword">const</span> T<span class="token operator">></span>src<span class="token punctuation">,</span> std<span class="token operator">::</span>span<span class="token operator">&lt;</span>T<span class="token operator">></span> des<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> arr1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> arr2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">copy</span><span class="token punctuation">(</span>arr1<span class="token punctuation">,</span>arr2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>copy 不需要元素的数目。一种常见的错误来源就这样被 <code>std::span&lt;T&gt;</code> 消除了。</p><h3 id="I-27-为了库-ABI-的文档，考虑使用-PImpl"><a href="#I-27-为了库-ABI-的文档，考虑使用-PImpl" class="headerlink" title="I.27 为了库 ABI 的文档，考虑使用 PImpl"></a>I.27 为了库 ABI 的文档，考虑使用 PImpl</h3><p>由于私有数据成员参与类的内存布局，而私有成员函数参与重载决议，<strong>对这些实现细节的改动都要求使用了这类的所有用户全部重新编译</strong>。而持有指向实现的指针（Pimpl）的 非多态的接口类，则可以将类的用户从其实现的改变隔离开来，<strong>而代价是一层间接</strong>。</p><ul><li><strong>接口： Widget.h</strong></li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">widget</span> <span class="token punctuation">{</span>
    <span class="token keyword">class</span> <span class="token class-name">impl</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>impl<span class="token operator">></span> pimpl<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 公开 API 转发给实现</span>
    <span class="token function">widget</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 定义于实现文件中</span>
    <span class="token operator">~</span><span class="token function">widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 定义于实现文件中，其中 impl 将为完整类型</span>
    <span class="token function">widget</span><span class="token punctuation">(</span>widget<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 定义于实现文件中</span>
    <span class="token function">widget</span><span class="token punctuation">(</span><span class="token keyword">const</span> widget<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
    widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>widget<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 定义于实现文件中</span>
    widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> widget<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>实现： Widget.cpp</strong></li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">widget</span><span class="token operator">::</span>impl <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// private data</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token keyword">const</span> widget<span class="token operator">&amp;</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* ... */</span> <span class="token punctuation">}</span>
    <span class="token function">impl</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">n</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> widget<span class="token operator">::</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> pimpl<span class="token operator">-</span><span class="token operator">></span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
widget<span class="token operator">::</span><span class="token function">widget</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token operator">:</span> pimpl<span class="token punctuation">{</span>std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>impl<span class="token operator">></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
widget<span class="token operator">::</span><span class="token function">widget</span><span class="token punctuation">(</span>widget<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
widget<span class="token operator">::</span><span class="token operator">~</span><span class="token function">widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
widget<span class="token operator">&amp;</span> widget<span class="token operator">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>widget<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://link.zhihu.com/?target=http%3A//cppreference.com">http://cppreference.com</a> 提供了关于 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/pimpl">PImpl</a> 惯用法的更多信息。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="4-1-函数定义"><a href="#4-1-函数定义" class="headerlink" title="4.1 函数定义"></a>4.1 函数定义</h3><ul><li><em>好软件的重要原则是好名字</em>。</li></ul><p>这一原则经常被忽视，但对函数而言它尤其适用。</p><h3 id="好名字"><a href="#好名字" class="headerlink" title="好名字"></a>好名字</h3><p>C++ Core Guidelines 用了前三条规则专门讨论好的名字：“F.1：将有意义的操作 ‘打包’ 成精心命名的函数” “F.2：一个函数应该执行单一的逻辑操作” “F.3：使函数保持简短”。</p><blockquote><p>让我从一则轶事开始。几年前，一位软件开发者问我：“我应该如何称呼我的函数？”我告诉他给函数起一个如 verbObject（动词加对象）这样的名字。如果是成员函数，可能用 verb 就可以了，因为该函数已经对一个对象执行了操作。动词代表了对象执行的操作。那位软件开发者反驳这是不可能的；该函数必须被称为 getTimeAndAddToPhonebook 或 processData，因为这些函数执行不止一项工作（单一责任原则）。</p></blockquote><ul><li><em>当你无法为函数找到一个有意义的名称（F.1）时，这充分说明你的函数执行不止一项逻辑操作（F.2），而且你的函数并不简短（F.3）</em>。</li></ul><p>如果一个函数放不进一屏，那就是太长了。一屏意味着大约 60 行，每行 140 个字符，但你的衡量标准可能有所不同。这时，你就应该识别出函数的操作，并将这些操作打包成精心命名的函数。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">read_and_print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//不好</span>
    <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    std<span class="token operator">::</span>cin <span class="token operator">>></span> x<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//检查错误</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于许多原因，函数 read_and_print 不好。该函数与特定的输入和输出捆绑在一起，不能在不同的上下文中使用。将该函数重构为两个函数，可以解决这些问题，使其更易于测试和维护。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">read</span><span class="token punctuation">(</span>std<span class="token operator">::</span>istream<span class="token operator">&amp;</span>is<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//更好</span>
    <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    is <span class="token operator">>></span> x<span class="token punctuation">;</span>
    <span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span>os<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>
    os <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;sstream></span></span>

<span class="token keyword">int</span> <span class="token function">read</span><span class="token punctuation">(</span>std<span class="token operator">::</span>istream<span class="token operator">&amp;</span>is<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//更好</span>
    <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    is <span class="token operator">>></span> x<span class="token punctuation">;</span>
    <span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span>os<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>
    os <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    std<span class="token operator">::</span>stringstream s<span class="token punctuation">{</span><span class="token string">"10 "</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> result <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//从 stringstream 中读取</span>
    <span class="token function">print</span><span class="token punctuation">(</span>std<span class="token operator">::</span>cout<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//输出到标准输出中</span>

    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//打印 stringstream 中的内容</span>

    <span class="token function">print</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//输出到 stringstream 中。</span>
    <span class="token function">print</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//输出到 stringstream 中。</span>
    <span class="token function">print</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//输出到 stringstream 中。</span>

    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//打印 stringstream 中的内容</span>

    s<span class="token punctuation">.</span><span class="token function">seekg</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//需要进行回溯，因为默认读取位置在上一个read到的位置</span>
    <span class="token keyword">auto</span> result2 <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> result2 <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//从 stringstream 中读取</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="F-4-如果函数有可能需要在编译期求值，就把它声明为-constexpr"><a href="#F-4-如果函数有可能需要在编译期求值，就把它声明为-constexpr" class="headerlink" title="F.4 如果函数有可能需要在编译期求值，就把它声明为 constexpr"></a>F.4 如果函数有可能需要在编译期求值，就把它声明为 constexpr</h3><p>constexpr 函数是可能在编译期运行的函数。当你在常量表达式中调用 constexpr 函数时，或者当你要用一个 constexpr 变量来获取 constexpr 函数的结果时，它会在编译期运行。也可以用只能在运行期求值的参数来调用 constexpr 函数。constexpr 函数是隐含内联的。</p><p>编译期求值的 constexpr 的结果通常会被系统标记为只读。性能是 constexpr 函数的一大好处；它的第二大好处是：</p><p><strong>编译期求值的 constexpr 是纯函数，因此 constexpr 函数是线程安全的</strong>。</p><blockquote><p>加粗这句话是因为这句话是 <strong>错误</strong> 的。 我们下面把这句话分开来聊：</p></blockquote><ul><li>“<strong>constexpr 函数是线程安全的</strong>”？</li></ul><p>完全错误。</p><p>这里会涉及到一个问题：</p><ul><li>C++23 前，标准要求至少存在一组实参值，使得函数的一个调用为核心常量表达式的被求值的子表达式（对于构造函数为足以用于常量初始化器）。<strong>不要求诊断是否违反这点</strong>。</li><li>C++23 起，<strong>标准移除了这一要求</strong>。</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//永远不可能编译期求值</span>
    <span class="token keyword">return</span> n <span class="token operator">*</span><span class="token operator">=</span> n<span class="token punctuation">,</span> n <span class="token operator">*</span> v<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token comment" spellcheck="true">//C++23前可能可以通过编译，也可能不行；C++23起能通过编译</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不过这还是太牵强了，我们可以用一个更简单直接的 demo 展示：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token operator">++</span>a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token function">f</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//运行期调用，修改b</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上这段代码显然不是线程安全的，各位可以自己<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/co8TdvEos">测试</a>。<strong>你可能可以看到结果是正确的，但是事实上这没什么价值，某些 CPU 能保证标量类型的读写线程安全</strong>。</p><ul><li>“<strong>编译期求值的 constexpr 函数是纯函数</strong>“？</li></ul><p>完全错误（C++11 以后）</p><blockquote><p>C++11 的常量求值中函数只能表现为纯的，一旦有修改操作就导致常量求值失败</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span>

<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>v<span class="token punctuation">)</span><span class="token punctuation">{</span>
    v <span class="token operator">+</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> v <span class="token operator">*</span> v<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">constexpr</span> std<span class="token operator">::</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> r1 <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> r2 <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span> r1<span class="token punctuation">,</span>r2 <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">auto</span> result <span class="token operator">=</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> result<span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span> <span class="token operator">&lt;&lt;</span> result<span class="token punctuation">.</span>second <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我的函数 f <strong>的确是编译期求值</strong>，没毛病，难不成它是<a href="https://link.zhihu.com/?target=https%3A//en.m.wikipedia.org/wiki/Pure_function">纯函数</a>？你要不看看它都做了什么.</p><blockquote><p>我们回到前面的性能话题</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">auto</span> <span class="token function">gcd</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>b<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">auto</span> t <span class="token operator">=</span> b<span class="token punctuation">;</span>
        b <span class="token operator">=</span> a <span class="token operator">%</span> b<span class="token punctuation">;</span>
        a <span class="token operator">=</span> t<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">gcd</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">121</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//（1）编译期求值</span>

    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">121</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token function">gcd</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//（2）非编译期求值</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>原书这里是要你看<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/qjzxxv5oe">汇编</a>的，友情提示，别开优化，这么点代码，开优化，啥 call 都没有。 下面是使用 gcc13.2 生成的 Intel 风格的汇编代码。</p></blockquote><p><img src="/posts/8961/image.png" alt></p><p>（1）所对应汇编指令就是 26行。（2）所对应的汇编指令就是 31~34 行。</p><p>调用 <code>constexpr int i = gcd(11, 121);</code> 会变成值 11，但调用 <code>int j = gcd(a, b);</code> 却会产生一个函数调用。</p><h3 id="F-6-如果你的函数必定不抛出异常，就把它声明为-noexcept"><a href="#F-6-如果你的函数必定不抛出异常，就把它声明为-noexcept" class="headerlink" title="F.6 如果你的函数必定不抛出异常，就把它声明为 noexcept"></a>F.6 如果你的函数必定不抛出异常，就把它声明为 noexcept</h3><p>通过将函数声明为 noexcept，你减少了备选控制路径的数量；因此，noexcept 对优化器来说是一个有价值的提示。</p><ul><li><em>即使你的函数可以抛出异常，noexcept 往往也合理</em>。</li></ul><p>noexcept 在这种情况下意味着：</p><ul><li><em>我不在乎异常。其原因可能是，你无法对异常做出反应</em>。</li></ul><p>这种情况下，系统处理异常的唯一办法是调用 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/error/terminate">std::terminate()</a>。这个 noexcept 声明也为代码的读者提供了有价值的信息。</p><p>下面的函数会在内存耗尽时崩溃。</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> <span class="token function">collect</span><span class="token punctuation">(</span>std<span class="token operator">::</span>istream<span class="token operator">&amp;</span> is<span class="token punctuation">)</span><span class="token keyword">noexcept</span><span class="token punctuation">{</span>
    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span>res<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>string s<span class="token punctuation">;</span> is <span class="token operator">>></span> s<span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下类型的函数永远不该抛出异常：析构函数（见第 5 章中 “失败的析构函数” 一节）、swap 函数，移动操作和默认构造函数。</p><h3 id="F-8-优先使用纯函数"><a href="#F-8-优先使用纯函数" class="headerlink" title="F.8 优先使用纯函数"></a>F.8 优先使用纯函数</h3><ul><li><em>纯函数是指在给定相同参数时总返回相同结果的函数</em>。</li></ul><blockquote><p>其实还有：该函数没有副作用（局部静态变量、非局部变量、可变引用参数或输入/输出流没有突变）。下面也略微提到了。</p></blockquote><p>函数模板 square 就是纯函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">auto</span> <span class="token function">square</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> t <span class="token operator">*</span> t<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>而非纯函数是指 random() 或 time() 这样的函数，<strong>它们会在不同的调用中返回不同的结果</strong>。换句话说：</p><ul><li><em>与函数体之外的状态交互的函数是不纯的</em>。</li></ul><p>纯函数可以：</p><ul><li>孤立地侧测试</li><li>孤立地验证或重构</li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/Mq-b/Loser-HomeWork/blob/main/C%2B%2BCoreGuidelines%E8%A7%A3%E6%9E%90/%E7%AC%AC3%E7%AB%A0-%E6%8E%A5%E5%8F%A3.md%23i2-%E9%81%BF%E5%85%8D%E9%9D%9E-const-%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F">缓存其结果</a></li><li>被自动重排或在其他线程上执行</li></ul><p>纯函数也被称为数学函数。C++ 中的函数默认情况下不是像纯函数式编程语言 Haskell 中那样的纯函数。 在 C++ 中使用纯函数时要基于程序员的素养。<strong>constexpr 函数在编译期求值时是纯的</strong>。</p><blockquote><p>加粗的原因很简单，因为这句话是<strong>错的</strong> 在 <code>F.4</code> 已经介绍过了。</p></blockquote><p>模板元编程时一种嵌在命令式语言 C++ 中的纯函数式语言。</p><p>第 13 章将简单介绍编译期编程，其中包括模板元编程。</p><h3 id="4-2-参数传递：入与出"><a href="#4-2-参数传递：入与出" class="headerlink" title="4.2 参数传递：入与出"></a>4.2 参数传递：入与出</h3><p>C++ Core Guidelines 有若干条规则表达了在函数中传入和传出参数的各种方式。</p><h3 id="F-15-优先采用简单而约定俗成的信息传递方式"><a href="#F-15-优先采用简单而约定俗成的信息传递方式" class="headerlink" title="F.15 优先采用简单而约定俗成的信息传递方式"></a>F.15 优先采用简单而约定俗成的信息传递方式</h3><p>第一条规则展示了大局。首先，它提供了一个概览，介绍了在函数中传入和传出信息的各种方式（见表 4.1）</p><p>表 4.1 很简洁：表头表述了数据在拷贝和移动开销方面的特征，而各行则表明了参数传递的方向。</p><p><strong>表 4.1 普通的参数传递</strong></p><table><thead><tr><th></th><th>拷贝开销低或不可能拷贝</th><th>移动开销低到中，或者未知</th><th>移动开销高</th></tr></thead><tbody><tr><td>入</td><td>func(x)</td><td>func(const X&amp;)</td><td></td></tr><tr><td>入并保留“拷贝”</td><td></td><td></td><td></td></tr><tr><td>入/出</td><td>func(X&amp;)</td><td></td><td></td></tr><tr><td>出</td><td>X func()</td><td>func(X&amp;)</td><td></td></tr></tbody></table><ul><li>数据类型</li><li><strong>拷贝开销低或不可能拷贝</strong>：<code>int</code> 或 <code>std::unique_ptr</code></li><li><strong>移动开销低</strong>：<code>std::vector&lt;T&gt;</code> 或 <code>BigPOD</code>（POD 代表 Old Data “简旧数据”，意为一般的传统数据——没有析构函数、构造函数以及虚成员函数的类）</li><li><strong>移动开销未知</strong>：模板</li><li><strong>移动开销高</strong>：<code>BigPOD[]</code> 或者 <code>std::array&lt;BigPOD&gt;</code></li><li>参数传递的方向</li><li><strong>入</strong>：输入参数</li><li><strong>入并保留“拷贝”</strong>：被调用者保留一份数据</li><li><strong>入/出</strong>：参数会被修改</li><li><strong>出</strong>：输出参数</li></ul><p>对几个 int 大小的数据的操作是低开销的；在不进行内存分配的前提下，1000 字节左右的操作属于中等开销。</p><p>这些普通的参数传递规则则应当是你的首选。不过，也有高级的参数传递规则（见表4.2）。实质上，就是加入了“入并移入”的语义。</p><p><strong>表 4.2 高级的参数传递</strong></p><table><thead><tr><th></th><th>拷贝开销低或不可能拷贝</th><th>移动开销低到中，或者未知</th><th>移动开销高</th></tr></thead><tbody><tr><td>入</td><td>func(x)</td><td>func(const X&amp;)</td><td></td></tr><tr><td>入并保留“拷贝”</td><td></td><td></td><td></td></tr><tr><td>入并移入</td><td>func(X&amp;&amp;)</td><td></td><td></td></tr><tr><td>入/出</td><td>func(X&amp;)</td><td></td><td></td></tr><tr><td>出</td><td>X func()</td><td>func(X&amp;)</td><td></td></tr></tbody></table><blockquote><p>这两个表的 “<strong>出</strong>” 用的 <code>func(X&amp;)</code> 其实是指代那种老式的写法，传入参数做传出参数，Win32中很常见。 “<strong>不可能拷贝</strong>” 其实是指：<code>f(X{})</code> 这种形式，C++17 起强制的复制消除，不可能再复制。 “<strong>入并移入</strong>” 就是让你 <code>f(std::move(...))</code>。</p></blockquote><p>在 “入并移入” 调用后，参数处在所谓的被移动状态。被移动状态意味着它处于合法但未指定的状态。基本上，你在重新使用被移动的对象前必须对它进行初始化。</p><p>其余的参数传递规则为以上这些表格提供了必要的背景信息。</p><h3 id="F-16-对于-“入”参，拷贝开销低的类型按值传递，其他类型则以-const-引用来传递"><a href="#F-16-对于-“入”参，拷贝开销低的类型按值传递，其他类型则以-const-引用来传递" class="headerlink" title="F.16 对于 “入”参，拷贝开销低的类型按值传递，其他类型则以 const 引用来传递"></a>F.16 对于 “入”参，拷贝开销低的类型按值传递，其他类型则以 const 引用来传递</h3><p>这条规则执行起来直截了当。默认情况下，输入值可以拷贝就拷贝。如果拷贝开销不低，就通过 const 引用来传入。C++ Core Guidelines 给出了回答以下问题的经验法则：</p><p><strong>哪些对象拷贝开销低？哪些对象拷贝高？</strong></p><ul><li><em>如果 `sizeof(par) &lt;= 2 \</em> sizeof(void*)`，则按值传递参数 par*。</li><li><em>如果 `sizeof(par) &gt; 2 \</em> sizeof(void*)`，则按 const 引用 传递参数 par*。</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 可以：按 const 的引用传递；</span>
                                 <span class="token comment" spellcheck="true">// 总是低开销</span>
<span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string s<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 差劲：潜在的高昂开销</span>

<span class="token keyword">void</span> <span class="token function">f3</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// 可以：无可匹敌</span>

<span class="token keyword">void</span> <span class="token function">f4</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 差劲：在 f4() 里面访问时有额外开销</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="F-19-对于“转发”参数，要用-Tp-amp-amp-来传递，并且只-std-forward-该参数"><a href="#F-19-对于“转发”参数，要用-Tp-amp-amp-来传递，并且只-std-forward-该参数" class="headerlink" title="F.19 对于“转发”参数，要用 Tp&amp;&amp; 来传递，并且只 std::forward 该参数"></a>F.19 对于“转发”参数，要用 Tp&amp;&amp; 来传递，并且只 std::forward 该参数</h3><p>这条规则代表了一种特殊的输入值。有时你想完美转发参数 par。这意味着你希望保持左值的左值性，以及右值的右值性，这样才能“完美”地转发参数，使它的语义不发生变化。</p><p>该转发参数的典型用例是工厂函数，工厂函数通过调用某个用户指定对象的构造函数创造处该对象。你不知道参数是不是右值，也不知道构造函数需要多少参数。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;utility></span></span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span><span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>T1<span class="token operator">></span>     <span class="token comment" spellcheck="true">//（1）</span>
T <span class="token function">create</span><span class="token punctuation">(</span>T1<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>t1<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">T</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> MyType<span class="token punctuation">{</span>
    <span class="token function">MyType</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 左值</span>
    <span class="token keyword">int</span> five <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> myFive <span class="token operator">=</span> create<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>five<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 右值</span>
    <span class="token keyword">int</span> myFive2 <span class="token operator">=</span> create<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 无参数</span>
    <span class="token keyword">int</span> myZero <span class="token operator">=</span> create<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 三个参数；（左值，右值，右值）</span>
    MyType myType <span class="token operator">=</span> create<span class="token operator">&lt;</span>MyType<span class="token operator">></span><span class="token punctuation">(</span>myZero<span class="token punctuation">,</span> <span class="token number">5.5</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>形参包的打包和解包</strong></p><p>当省略号在类型参数 T1 的左边时，参数包被打包；当省略号在右边时，参数包被解包。返回语句 <code>T(std::forwardt1(t1)...)</code> 中的这种解包实质上意味着表达式 <code>std::forwardt1(t1)</code> <strong>被不断重复，直到形参包中的所有参数都被消耗掉，并且会在每一个子表达式之间加一个逗号</strong>。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>T1<span class="token operator">></span>     <span class="token comment" spellcheck="true">//（1）</span>
T <span class="token function">create</span><span class="token punctuation">(</span>T1<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>t1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">T</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> X<span class="token punctuation">{</span>
    <span class="token function">X</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">double</span><span class="token punctuation">,</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    X resutl <span class="token operator">=</span> create<span class="token operator">&lt;</span>X<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1.2</span><span class="token punctuation">,</span> <span class="token string">'*'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码的 <code>create</code> 模板，实例化相当于下面这种形式：（也符合前面说的“被不断重复，直到形参包中的所有参数都被消耗掉，并且会在每一个子表达式之间加一个逗号”）</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span>
X create<span class="token operator">&lt;</span>X<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span> __t10<span class="token punctuation">,</span> <span class="token keyword">double</span> <span class="token operator">&amp;&amp;</span> __t11<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">&amp;&amp;</span> __t12<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">X</span><span class="token punctuation">(</span><span class="token function">X</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>__t10<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">(</span>__t11<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span><span class="token punctuation">(</span>__t12<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于好奇的读者 <a href="https://link.zhihu.com/?target=https%3A//cppinsights.io/">C++ Insights</a> 可以展示这个过程。</p><p>转发与变参模板的结合是 C++ 中典型的创建模式。下面是 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/memory/unique_ptr/make_unique">std::make_unique</a> 的一种可能实现。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token operator">></span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">make_unique</span><span class="token punctuation">(</span>Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">T</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Args<span class="token operator">></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="F-17-对于“入-出”参数，使用非-const-的引用来传递"><a href="#F-17-对于“入-出”参数，使用非-const-的引用来传递" class="headerlink" title="F.17 对于“入-出”参数，使用非 const 的引用来传递"></a>F.17 对于“入-出”参数，使用非 const 的引用来传递</h3><p>这条规则把函数的设计意图传递给了调用方：该函数会修改它的参数。</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>myVec<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">modifyVector</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> vec<span class="token punctuation">)</span><span class="token punctuation">{</span>
    vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    vec<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="F-20-对于“出”的输出值，优先使用返回值而非输出参数"><a href="#F-20-对于“出”的输出值，优先使用返回值而非输出参数" class="headerlink" title="F.20 对于“出”的输出值，优先使用返回值而非输出参数"></a>F.20 对于“出”的输出值，优先使用返回值而非输出参数</h3><p>这条规则很简单。</p><ul><li><em>用返回值就好，但别用 const，因为它不但没有附加价值，而且会干扰移动语义</em>。</li></ul><p>也许你认为值的复制开销巨大，这<strong>既对也不对</strong>。原因在于编译器会应用 RVO（return value optimization，返回值优化）或 NRVO（named return value optimization，具名返回值优化）。</p><p>RVO 意味着编译器可以消除不必要的复制操作。到了 C++17，原本只是可能会做的优化成了一种<strong>保证</strong>。</p><pre class="line-numbers language-cpp"><code class="language-cpp">MyType <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> MyType<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// C++17 中不会拷贝</span>
<span class="token punctuation">}</span>
MyType myType <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// C++17 中不会拷贝</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这几行中可能会发生两次不必要的拷贝操作：第一次在返回调用中，第二次在函数调用中。C++17 中则不会有拷贝操作发生。如果这个返回值有名字，我们就称这种优化为 NRVO。你大概也已经猜到了。</p><pre class="line-numbers language-cpp"><code class="language-cpp">MyType <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    NyType myValue<span class="token punctuation">;</span>
    <span class="token keyword">return</span> myValue<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 允许拷贝一次</span>
<span class="token punctuation">}</span>
MyType myType <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 在 C++17 中不会拷贝</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里有一个细微的区别：按照 C++17 编译器仍然可以在返回语句中拷贝值 myValue，但在函数调用的地方则不会发生拷贝。</p><blockquote><p>这里详细聊一下 复制消除 NRVO RVO 吧：</p></blockquote><p>下列环境下，允许但不要求编译器省略类对象的复制和移动 (C++11 起)构造，即使复制/移动 (C++11 起)构造函数和析构函数拥有可观察的副作用。这些对象将直接构造到它们本来要复制/移动到的存储中。<strong>这是一项优化</strong>：即使进行了优化而不调用复制/移动 (C++11 起)构造函数，它仍然必须存在且可访问（如同完全未发生优化），否则程序非良构</p><p><strong>在对象的初始化中，当源对象是无名临时量且与目标对象具有相同类型（忽略 cv 限定）时。当无名临时量为 return 语句的操作数时，称这种复制消除的变体为 RVO，“返回值优化 (return value optimization)”。</strong></p><p>C++17起 返回值优化是<strong>强制要求的</strong>（也就是不再被当成优化），而不再被当做复制消除。</p><p>这就是 RVO 的规则，只要满足，那么在 C++17 就不可能有复制开销。</p><p>我们看到先前的代码示例，之所以第一个示例在 C++17 都不会有额外拷贝就是因为它</p><p><code>return MyType{};</code> 满足了：<strong>当无名临时量为 return 语句的操作数</strong>。</p><p><code>MyType myType = func();</code> 满足了：<strong>在对象的初始化中，当源对象是无名临时量且与目标对象具有相同类型（忽略 cv 限定）时</strong>。</p><p>因为 <strong>NRVO</strong> 的存在，不一定会拷贝，只是不保证而已。</p><p><strong>return 语句中，当操作数是拥有自动存储期的非 volatile 对象的名字，该名字不是函数形参或 catch 子句形参，且其具有与函数返回类型相同的类类型（忽略 cv 限定）时。这种复制消除的变体被称为</strong> NRVO<strong>，“具名返回值优化 (named return value optimization)”。</strong></p><p>函数往往必须返回多于一个值。于是，规则 F.21 来了。</p><h3 id="F-21-要返回多个“出”值，优先考虑返回结构体或者多元组"><a href="#F-21-要返回多个“出”值，优先考虑返回结构体或者多元组" class="headerlink" title="F.21 要返回多个“出”值，优先考虑返回结构体或者多元组"></a>F.21 要返回多个“出”值，优先考虑返回结构体或者多元组</h3><p>当你向 std::set 中插入一个值时，成员函数 insert 的重载会返回一个 std::pair，它由两部分组成：一个指向所插入元素的迭代器；还有一个 bool，如果插入成功，它会被设置为 true。C++11 中的 std::tie 和 C++17 中的结构化绑定是将两个值绑定到某变量的两种优雅方式。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;set></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;tuple></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>

    std<span class="token operator">::</span>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>mySet<span class="token punctuation">;</span>

    std<span class="token operator">::</span>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator iter<span class="token punctuation">;</span>
    <span class="token keyword">bool</span> inserted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span><span class="token function">tie</span><span class="token punctuation">(</span>iter<span class="token punctuation">,</span> inserted<span class="token punctuation">)</span> <span class="token operator">=</span> mySet<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">2011</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//（1）</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>inserted<span class="token punctuation">)</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"2011 was inserted successfully\n"</span><span class="token punctuation">;</span>

    <span class="token keyword">auto</span> <span class="token punctuation">[</span>iter2<span class="token punctuation">,</span> inserted2<span class="token punctuation">]</span> <span class="token operator">=</span> mySet<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">2017</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//（2）</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>inserted2<span class="token punctuation">)</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"2017 was inserted successfully\n"</span><span class="token punctuation">;</span>

    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在（1）处，我们使用 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/utility/tuple/tie">std::tie</a> 将插入操作的返回值解包到 iter 和 inserted 中。而在（2）处，我们使用结构化绑定将插入操作的返回值解包到 iter2 和 inserted2 中。与结构化绑定相比，std::tie 还需要预先声明的变量。<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/3GKbGeYsY">运行结果</a>：</p><pre class="line-numbers language-text"><code class="language-text">2011 was inserted successfully
2017 was inserted successfully<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="4-3-参数传递：所有权语义"><a href="#4-3-参数传递：所有权语义" class="headerlink" title="4.3 参数传递：所有权语义"></a>4.3 参数传递：所有权语义</h3><p>上一节探讨参数的流向：哪些参数是入，哪些参数是入/出或出。但对参数来说，除了流动的方向，还有其他需要考虑的问题。传递参数也事关<strong>所有权语义</strong>。但本节会介绍 5 种典型的参数传递方式：通过拷贝、通过指针、通过引用、通过 std::unique_ptr 和通过 std::shared_ptr 。</p><p>只有通过智能指针传参的相关规则是在本节内新出现的。</p><p>通过拷贝传参的规则是 4.2 节“参数传递：入与出” 的一部分。而通过指针和引用传参的规则是 第 3 章的一部分。</p><p><strong>表 4.3 参数传递的所有权语义</strong></p><table><thead><tr><th>例子</th><th>所有权</th><th>规则</th></tr></thead><tbody><tr><td>func(value)</td><td>func 是资源所有者</td><td>F.16</td></tr><tr><td>func(pointer*)</td><td>func 借用了资源</td><td>I.11 和 F.7</td></tr><tr><td>func(reference&amp;)</td><td>func 借用了资源</td><td>I.11 和 F.7</td></tr><tr><td>func(std::unique_ptr)</td><td>func 是资源的独占所有者</td><td>F.26</td></tr><tr><td>func(std::shared_ptr)</td><td>func 是资源的共享所有者</td><td>F.27</td></tr></tbody></table><p>更多细节如下。</p><ul><li>func(value)：函数 func 自己有一份 value 的拷贝并且就是其所有者。func 会自动释放该资源。</li><li>func(pointer*)：func 借用了资源，所以无权删除该资源。func 在每次使用前都必须检查该指针是否为空指针。</li><li>func(reference&amp;)：func 借用了资源。与指针不同，引用的值总是合法的。</li><li>func(std::unique_ptr)：func 是资源的新所有者。func 的调用方显式地把资源的所有权传给了被调用方。func 会自动释放该资源。</li><li>func(std::shared_ptr)：func 是资源的额外所有者。func 会延长资源的生存期。在 func 结束时，它也会结束对资源的所有权。如果 func 是资源的最后一个所有者，那么它的结束会导致资源的释放。</li></ul><h3 id="谁是所有者？"><a href="#谁是所有者？" class="headerlink" title="谁是所有者？"></a>谁是所有者？</h3><p>务必明确表达出所有权。试想一下，你的程序是用传统 C++ 编写的，只能使用原始指针来表达指针、引用、std::unique_ptr 或 std::shared_ptr 这四种传参方式的所有权语义。</p><ul><li><em>传统 C++ 的关键问题是，谁是所有者？</em></li></ul><p>下面的代码说明了我的观点：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token keyword">double</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">double</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">func</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关键问题是，谁是资源的所有者？是使用该数组的 func 中的被调用方，还是创建该数组的 func 的调用方？如果 func 是所有者，那么它必须释放该资源。如果不是，则func 不可以释放资源。这种情况不能令人满意。如果 func 不释放资源，可能会发生内存泄露。如果 func 释放了资源，可能会导致未定义行为。</p><p>因此，所有权需要记录在文档中。使用现代 C++ 中的类型系统来定义所有权的契约是朝正确方向迈出的一大步，可以消除文档的模糊性。</p><ul><li>！！！！！<em>在应用层面使用 <code>std::move</code> 的意图并不在于移动，而是所有权的转移</em>。</li></ul><p>举例来说，若对 std::unique_ptr 应用 std::move，会将内存的所有权转移到另一个 std::unique_ptr。智能指针 uniquePtr1 是原来的所有者，而 uniquePtr2 将成为新的所有者。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> uniquePtr1 <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">2011</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> uniquePtr2<span class="token punctuation">{</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>uniquePtr1<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>下面是所有权在实践中的五种变体：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;utility></span></span>

<span class="token keyword">class</span> <span class="token class-name">MyInt</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">explicit</span> <span class="token function">MyInt</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">myInt</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">MyInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> myInt <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> myInt<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">funcCopy</span><span class="token punctuation">(</span>MyInt myInt<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">funcPtr</span><span class="token punctuation">(</span>MyInt<span class="token operator">*</span> myInt<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">funcRef</span><span class="token punctuation">(</span>MyInt<span class="token operator">&amp;</span> myInt<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">funcUniqPtr</span><span class="token punctuation">(</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>MyInt<span class="token operator">></span>myInt<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">funcSharedPtr</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>MyInt<span class="token operator">></span>myInt<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>

    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"=== Begin"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>

    MyInt myInt<span class="token punctuation">{</span> <span class="token number">1998</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    MyInt<span class="token operator">*</span> myIntPtr <span class="token operator">=</span> <span class="token operator">&amp;</span>myInt<span class="token punctuation">;</span>
    MyInt<span class="token operator">&amp;</span> myIntRef <span class="token operator">=</span> myInt<span class="token punctuation">;</span>
    <span class="token keyword">auto</span> uniqPtr <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>MyInt<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">2011</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> sharedPtr <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>MyInt<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">2014</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">funcCopy</span><span class="token punctuation">(</span>myInt<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">funcPtr</span><span class="token punctuation">(</span>myIntPtr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">funcRef</span><span class="token punctuation">(</span>myIntRef<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">funcUniqPtr</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>uniqPtr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">funcSharedPtr</span><span class="token punctuation">(</span>sharedPtr<span class="token punctuation">)</span><span class="token punctuation">;</span>

    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"=== End"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/z8Tn197Ph">运行结果</a>：</p><pre class="line-numbers language-text"><code class="language-text">=== Begin
1998
2011
=== End
2014
1998<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果显示，有两个析构函数在 main 函数结束之前被调用，还有两个析构函数在 main 函数结束的地方被调用。</p><p>在 main 函数结束之前析构的是 被<strong>拷贝</strong>到函数中（<code>funcCopy(myInt)</code>），以及被<strong>移动</strong>到函数中 （<code>funcUniqPtr(std::move(uniqPtr))</code>）。</p><ol><li>拷贝拷贝了一份新的 MyInt 到函数 func 中，func 结束的时候，自然进行析构，打印 <code>1998</code>。</li><li>移动转移了智能指针资源的所有权，所以在 func 结束的时候，<code>RAII</code> 释放了内存，打印 <code>2011</code>。</li><li><code>shared_ptr</code> 对象的资源并没有转移，它是共享的，有两个对象共享资源，分别是 main 函数局部的，以及 func 函数中的，所以当 func 结束的时候，只是引用计数减一，不会释放资源。只能等到 main 函数也结束的时候才会析构，释放内存，打印 <code>2014</code> 。</li><li><code>MyInt myInt</code> 析构，打印 <code>1998</code>。其实你可以注意到，打印了两次 <code>1998</code>，因为第一次析构的是复制到函数中的。</li></ol><h3 id="4-4-值返回语义"><a href="#4-4-值返回语义" class="headerlink" title="4.4 值返回语义"></a>4.4 值返回语义</h3><p>本节中的 7 条规则与前面提到的规则 “F.20：对于‘出’的输出值，优先使用返回值而非输出参数”相一致。这一节的规则还与一些特殊用例和不建议的做法相关。</p><h3 id="F-42-返回-T-（仅仅）用于表示位置"><a href="#F-42-返回-T-（仅仅）用于表示位置" class="headerlink" title="F.42 返回 T* （仅仅）用于表示位置"></a>F.42 返回 T* （仅仅）用于表示位置</h3><ul><li><em>指针仅用于表示位置</em></li></ul><p>这正是 find 的作用。</p><pre class="line-numbers language-cpp"><code class="language-cpp">Node <span class="token operator">*</span> <span class="token function">find</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> t<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>t <span class="token operator">||</span> t<span class="token operator">-</span><span class="token operator">></span>name <span class="token operator">==</span> s<span class="token punctuation">)</span><span class="token keyword">return</span> t<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">auto</span> p <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>t<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> p<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">auto</span> p <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>t<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> p<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里指针表示名字与 s 相匹配的 Node 的位置。</p><h3 id="F-44-当不希望发生拷贝，也不需要表达“没有返回对象”时，应返回-T-amp"><a href="#F-44-当不希望发生拷贝，也不需要表达“没有返回对象”时，应返回-T-amp" class="headerlink" title="F.44 当不希望发生拷贝，也不需要表达“没有返回对象”时，应返回 T&amp;"></a>F.44 当不希望发生拷贝，也不需要表达“没有返回对象”时，应返回 T&amp;</h3><p>当不存在“没有返回对象” 这种可能性的时候就可以返回引用而非指针了。</p><p>有时你<strong>想进行链式操作</strong>，但不想为不必要的临时对象进行拷贝和析构。典型的用例是输入和输出流或赋值运算符（“F.47：从赋值运算符返回 T&amp;”）。在下面的代码片段中，通过 <strong>T&amp;</strong> 返回和通过 <strong>T</strong> 返回有什么微秒的区别？</p><pre class="line-numbers language-cpp"><code class="language-cpp">A<span class="token operator">&amp;</span> <span class="token keyword">operator</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
A <span class="token keyword">operator</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

A a1<span class="token punctuation">,</span> a2<span class="token punctuation">,</span> a3<span class="token punctuation">;</span>
a1 <span class="token operator">=</span> a2 <span class="token operator">=</span> a3<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>返回拷贝（A）的拷贝赋值运算符会触发两个额外的 A 类型临时对象的创建。</p><h3 id="局部对象的引用"><a href="#局部对象的引用" class="headerlink" title="局部对象的引用"></a>局部对象的引用</h3><p>返回局部对象的引用（指针）是<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/ub">未定义行为</a>。</p><ul><li><em>未定义行为本质上意味着，不要假想程序的行为</em>。</li></ul><p>先修复未定义行为。程序 <code>lambdaFuncionCapture.cpp</code> 返回了局部对象的引用。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>

<span class="token keyword">auto</span> <span class="token function">makeLambda</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">const</span> std<span class="token operator">::</span>string val <span class="token operator">=</span> <span class="token string">"on stack created"</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>val<span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token keyword">return</span> val<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//（2）</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">auto</span> bad <span class="token operator">=</span> <span class="token function">makeLambda</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//（1）</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">bad</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//（3）</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>main 函数调用函数 makeLambda()（1）。该函数返回一个 Lambda 表达式，它具有对局部变量 val（2）的引用。</p><p>调用 bad()（3）导致了未定义行为，因为 Lambda 表达式使用了局部变量 val 的引用。由于它是局部变量，它的生存期随着 makeLambda() 的作用域结束而结束。</p><p>执行该程序时会得到无法预知的结果。有时我得到整个字符串，有时得到字符串的一部分，有时只得到 0。</p><blockquote><p>且可能随着 C++ 标准的不同，优化的等级等，而<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/GzGe7T97o">变化</a>。纠结这个结果并没有多少价值，<strong>未定义行为本质上意味着，不要假想程序的行为</strong>。</p></blockquote><h3 id="F-45-不要返回-T-amp-amp"><a href="#F-45-不要返回-T-amp-amp" class="headerlink" title="F.45 不要返回 T&amp;&amp;"></a>F.45 不要返回 T&amp;&amp;</h3><p>以及</p><h3 id="F-48-不要返回-std-move-本地变量"><a href="#F-48-不要返回-std-move-本地变量" class="headerlink" title="F.48 不要返回 std::move(本地变量)"></a>F.48 不要返回 std::move(本地变量)</h3><p>两条规则都非常严格。</p><p>不应当以 T&amp;&amp; 作为返回类型。下面的小例子展示了这个问题。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> <span class="token function">returnRvalueReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">auto</span> myInt <span class="token operator">=</span> <span class="token function">returnRvalueReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在编译时，GCC 编译器会立即抱怨对临时对象的引用。准确地说，临时对象的生存期随着整个表达式 <code>auto myInt = returnRvalueReference();</code> 的结束而结束。</p><blockquote><p><strong>在函数调用中绑定到函数形参的临时量，存在到含这次函数调用的全表达式结尾为止：如果函数返回一个生命长于全表达式的引用，那么它会成为悬垂引用。</strong></p></blockquote><pre class="line-numbers language-text"><code class="language-text"><source>: In function 'int&& returnRvalueReference()':
<source>:2:16: warning: returning reference to temporary [-Wreturn-local-addr]
    2 |     return int{};
      |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="std-move-本地变量"><a href="#std-move-本地变量" class="headerlink" title="std::move(本地变量)"></a>std::move(本地变量)</h3><p>由于 RVO 和 NRVO 的拷贝消除，return std::move(本地变量)的使用不是优化而是劣化。劣化意味着<strong>程序可能会变得更慢</strong>。</p><blockquote><p>std::move(本地变量)的确毫无意义，但是 <code>return std::move(expr)</code> 不是，可以看之前的<a href="https://zhuanlan.zhihu.com/p/654113232">文章</a>。</p></blockquote><h3 id="F-46-main-的返回类型是-int"><a href="#F-46-main-的返回类型是-int" class="headerlink" title="F.46 main() 的返回类型是 int"></a>F.46 main() 的返回类型是 int</h3><p>依照 C++ 标准，main 函数体有两种变体：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>第二个版本等效于 <code>int main(int argc, char* argv[]){ ... }</code>。</p><p>main 函数并不需要返回语句。如果控制流抵达 main 函数的末尾而没有碰到一条返回语句，其效果相当于 <code>return 0;</code>。return 0 意味着程序成功执行。</p><blockquote><p>这里最前面说的 <strong>依照 C++ 标准</strong>。 我们都知道 main 函数的形式远不止这些，但那些都是编译器的扩展，我们用 msvc 举几个例子。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">wmain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">wmain</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">wchar_t</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>参见 <a href="https://link.zhihu.com/?target=https%3A//learn.microsoft.com/zh-cn/cpp/cpp/main-function-command-line-args%3Fview%3Dmsvc-170">msvc 文档</a>。</p><h3 id="F-50-当函数不适用时（需要捕获局部变量，或者编写一个局部函数），请使用-Lambda-表达式"><a href="#F-50-当函数不适用时（需要捕获局部变量，或者编写一个局部函数），请使用-Lambda-表达式" class="headerlink" title="F.50 当函数不适用时（需要捕获局部变量，或者编写一个局部函数），请使用 Lambda 表达式"></a>F.50 当函数不适用时（需要捕获局部变量，或者编写一个局部函数），请使用 Lambda 表达式</h3><p>这条规则说明了 Lambda 表达式的使用场合。这立刻引出了问题：</p><ul><li>什么时候必须用 Lambda 表达式？</li><li>什么时候必须用普通函数？</li></ul><p>这里有两条明显的理由。</p><ul><li><strong>如果可调用实体必须捕获局部变量，或者它是在局部作用域内声明的，你就必须使用 Lambda 表达式</strong>。</li><li><strong>如果可调用实体需要支持重载，那么应使用普通函数</strong>。</li></ul><p>现在我想亮出我对 Lambda 表达式的关键论点，它们经常会被忽视。</p><p><strong>表达力</strong></p><p>”明确优于隐晦“这条来自 Python（PEP 20 —— 《Python 之阐》）的元规则也适用于 C++。它意味着代码应该明确地表达其意图（见规则”P.1：在代码中直接表达思想“）。 当然，这对 Lambda 表达式来说尤其正确。</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> myStrVec <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"523345"</span><span class="token punctuation">,</span><span class="token string">"4336893456"</span><span class="token punctuation">,</span><span class="token string">"7234"</span><span class="token punctuation">,</span>
                                    <span class="token string">"564"</span><span class="token punctuation">,</span><span class="token string">"199"</span><span class="token punctuation">,</span><span class="token string">"433"</span><span class="token punctuation">,</span><span class="token string">"2435345"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

std<span class="token operator">::</span><span class="token function">sort</span><span class="token punctuation">(</span>myStrVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> myStrVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> f<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> f<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> myStrVec <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"523345"</span><span class="token punctuation">,</span><span class="token string">"4336893456"</span><span class="token punctuation">,</span><span class="token string">"7234"</span><span class="token punctuation">,</span>
                                        <span class="token string">"564"</span><span class="token punctuation">,</span><span class="token string">"199"</span><span class="token punctuation">,</span><span class="token string">"433"</span><span class="token punctuation">,</span><span class="token string">"2435345"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">bool</span> <span class="token function">lessLength</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> f<span class="token punctuation">,</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> f<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

std<span class="token operator">::</span><span class="token function">sort</span><span class="token punctuation">(</span>myStrVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> myStrVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>lessLength<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Lambda 表达式和函数都为排序算法提供了相同的顺序谓词。如果你不相信他们，你就必须分析其实现。也许这并不可能，因为你只有函数的声明。有了 Lambda 表达式，你的同事无法欺骗你。代码就是真相。让我更挑衅的说：</p><ul><li><strong><em>你的代码的表达能力应该强到不需要文档\</em></strong>。</li></ul><blockquote><p><strong>表达能力与不要重复自己</strong><br>“用 Lambda 编写表达力丰富的代码”这条设计规则往往与另一条重要的设计规则相矛盾：不要重复自己（don’t repeat yourself, DRY）。DRY 意味着你不应该多次编写相同的代码。编写一个可重复使用的单元，如一个函数，并给它指定一个不言自明的名称，是对 DRY 的合适补救。最终，必须在具体的案例中决定是否把表达力看得比 DRY 更重要。</p></blockquote><h3 id="F-52-在局部使用（包括要传递给算法）的-Lambda-表达式中，优先通过引用来捕获"><a href="#F-52-在局部使用（包括要传递给算法）的-Lambda-表达式中，优先通过引用来捕获" class="headerlink" title="F.52 在局部使用（包括要传递给算法）的 Lambda 表达式中，优先通过引用来捕获"></a>F.52 在局部使用（包括要传递给算法）的 Lambda 表达式中，优先通过引用来捕获</h3><p>以及</p><h3 id="F-53-在非局部使用（包括要被返回、存储在堆上或要传给其他线程）的-Lambda-表达式中，避免通过引用来捕获"><a href="#F-53-在非局部使用（包括要被返回、存储在堆上或要传给其他线程）的-Lambda-表达式中，避免通过引用来捕获" class="headerlink" title="F.53 在非局部使用（包括要被返回、存储在堆上或要传给其他线程）的 Lambda 表达式中，避免通过引用来捕获"></a>F.53 在非局部使用（包括要被返回、存储在堆上或要传给其他线程）的 Lambda 表达式中，避免通过引用来捕获</h3><p>这两条规则高度关联，它们可以归结为：<strong>Lambda 表达式应该只对有效数据进行操作</strong>。</p><ul><li>当 Lambda 通过拷贝捕获数据时，根据定义，数据总是有效的。</li><li>当 Lambda 通过引用捕获数据时，数据的生存期必须超过 Lambda 的生存期。</li></ul><p>前面局部对象引用的例子就展示了 Lambda 引用无效数据时的各种问题。</p><p>有时问题还不那么容易发现。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>string str<span class="token punctuation">{</span><span class="token string">"C++11"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    std<span class="token operator">::</span>thread thr<span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token operator">&amp;</span>str<span class="token punctuation">]</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    thr<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在新创建的线程 thr 中使用的 Lambda 表达式通过引用捕获了变量 str。之后，thr 从其创建者（即主线程）的生存期中分离出来。因此，不能保证创建的线程 thr 使用的是有效的字符串 str，因为 str 的生存期与主线程的生存期绑定了。</p><p>可以采用一个直截了断的方法来解决这个问题。通过拷贝捕获 str。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>string str<span class="token punctuation">{</span><span class="token string">"C++11"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    std<span class="token operator">::</span>thread thr<span class="token punctuation">{</span><span class="token punctuation">[</span>str<span class="token punctuation">]</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    thr<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>问题解决了吗？没有！关键的问题是:</p><ul><li><strong>谁是 std::cout 的所有者？</strong></li></ul><p>std::cout 的生存期与进程的生存期绑定。这意味着，在屏幕上打印出“C++11”之前，std::cout 对象可能已经消失了。解决这个问题的方法是汇合（join）线程 thr。这种情况下，创建者会等待，直到被创建者完全任务，因此，通过引用捕获也就可以了。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>string str<span class="token punctuation">{</span><span class="token string">"C++11"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    std<span class="token operator">::</span>thread thr<span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token operator">&amp;</span>str<span class="token punctuation">]</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    thr<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="F-51-在有选择的情况下，优先采用默认参数而非重载"><a href="#F-51-在有选择的情况下，优先采用默认参数而非重载" class="headerlink" title="F.51 在有选择的情况下，优先采用默认参数而非重载"></a>F.51 在有选择的情况下，优先采用默认参数而非重载</h3><p>如果你需要不同数量的参数来调用一个函数，尽可能优先采用默认参数而不是重载。这样你就遵循了 DRY（不要重复自己）原则。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">,</span> format f <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>若要使用重载实现相同的功能，则需要两个函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">,</span> format f<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="F-55-不要使用-va-arg-参数"><a href="#F-55-不要使用-va-arg-参数" class="headerlink" title="F.55 不要使用 va_arg 参数"></a>F.55 不要使用 va_arg 参数</h3><p>当你的函数需要接受任意数量的参数时，要使用变参模板而不是 va_arg 参数。</p><p>变参函数（variadic function）是像 std::printf 这样的函数，可以接受任意数量的参数。问题是，必须假设传递的类型总是正确的。当然，这种假设非常容易出错，其正确性依赖于程序员的素养。</p><blockquote><p>std::printf 不是类型安全的函数，很多东西理论上根本无法检测，但是因为用的太多了，大部分编译器都给它开洞检查类型之类的玩意了。</p></blockquote><p>为了理解变参函数的隐含危险，请看下面的小例子。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdarg></span></span>

<span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    va_list argPointer<span class="token punctuation">;</span>
    <span class="token function">va_start</span><span class="token punctuation">(</span>argPointer<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>num<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
        sum <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>argPointer<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">va_end</span><span class="token punctuation">(</span>argPointer<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sum(1, 5): "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sum(3, 1, 2, 3): "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sum(3, 1, 2, 3, 4): "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//（1）</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sum(3, 1, 2, 3.5): "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3.5</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//（2）</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>sum 是一个变参数函数。它的第一个参数是需要被求和的参数个数。以下是关于 va_arg 宏的背景信息，有助于理解该代码。</p><ul><li><strong>va_list:</strong> 保存下列宏的必要信息。</li><li><strong>va_start:</strong> 启用对变参函数参数的访问。</li><li><strong>va_arg:</strong> 访问下一个变参函数的参数。</li><li><strong>va_end:</strong> 结束对变参函数参数的访问。</li></ul><p>请阅读 <a href="https://link.zhihu.com/?target=http%3A//cppreference.com">http://cppreference.com</a> 中关于<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/variadic_arguments">变参数函数</a>的部分来获取进一步的信息。</p><p>代码行（1）和（2）中出了些状况。（1）中参数 num 的数量是错的；（2）中我提供了一个 double 而不是一个int。<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/nch8fjdf5">输出结果</a>显示了这两个问题。（1）中的最后一个元素丢失了，而 double 被解释为 int（2）。</p><pre class="line-numbers language-text"><code class="language-text">sum(1, 5): 5
sum(3, 1, 2, 3): 6
sum(3, 1, 2, 3, 4): 6
sum(3, 1, 2, 3.5): 539767595<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意，最后一个输出结果并不一定，我们只是按照书上的结果写了。经过实测的话，msvc 和 mingw clang 都是 <strong>6</strong>，gcc 是 <strong>3075</strong>。</p></blockquote><p>这些问题可以通过 C++17 的折叠表达式轻松解决。跟 va_arg 相比，折叠表达式会自动推导出其参数的数量和类型。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token operator">></span>
<span class="token keyword">auto</span> <span class="token function">sum</span><span class="token punctuation">(</span>Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">+</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sum(5): "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sum(1, 2, 3): "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sum(1, 2, 3, 4): "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sum(1, 2, 3.5): "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3.5</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数 sum 可能看起来挺可怕，它需要至少一个参数，并使用 C++11 的变参模板。变参模板可以接受任意数量的参数。这些任意数量的参数由所谓的参数包持有，用省略号（…）表示。此外，在 C++17 中，可以用二元运算符直接对参数包进行归约。这一针对变参模板的增强被称为折叠表达式。在 sum 函数的例子中，应用了二元的 + 运算符（… + args）。想要了解 C++17 折叠表达式的更多信息可参阅 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/fold">https://zh.cppreference.com/w/cpp/language/fold</a> 了解更多细节。</p><p>程序的输出正如预期：</p><pre class="line-numbers language-text"><code class="language-text">sum(5): 5
sum(1, 2, 3): 6
sum(1, 2, 3, 4): 10
sum(1, 2, 3.5): 6.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-6-相关规则"><a href="#4-6-相关规则" class="headerlink" title="4.6 相关规则"></a>4.6 相关规则</h3><p>关于 Lambda 表达式的另一条规则在第 8 章中——“SE.28”：使用 Lambda 表达式进行复杂的初始化（尤其是对 const 变量）。</p><p>我在本章中跳过了 C++20 特性 std::span。我会在第 7 章中提供关于 std::span 的基本信息。</p><hr><p><strong>本章精华</strong></p><p><strong>重要</strong></p><ul><li>一个函数应该执行一个操作，要简短，并有一个精心选择的名字。</li><li>要把可以在编译期运行的函数实现为 constexpr。</li><li>如果可能的话，将你的函数实现为纯函数。</li><li>区分一个函数的入、入/出和出参。对入参使用按值传递或按 const 引用传递，对入/出参使用按引用传递，对出参使用按值传递。</li><li>向函数传递参数涉及所有权语义的问题。按值传递使函数称为资源的独立所有者。按指针或引用传递意味着函数只是借用了该资源。std::unique_ptr 将所有权转移给函数，std::shared_ptr 则使函数称为共享的所有者。</li><li>当你的函数需要接受任意数量的参数时，要使用变参模板而不是 va_arg 参数。</li></ul><h2 id="类和类的层次结构"><a href="#类和类的层次结构" class="headerlink" title="类和类的层次结构"></a>类和类的层次结构</h2><p>类是一种用户定义类型，程序员可以为其指定表示方法、操作和接口。类的层次结构被用来组织相关的结构。</p><p>C++ Core Guidelines 中大约有100条关于用户定义类型的规则。</p><p>Guidelines 先给出了一些概要规则，然后深入讨论了下面的特殊规则：</p><ul><li>具体类型</li><li>构造函数、赋值和析构函数</li><li>类的层次结构</li><li>重载和运算符重载</li><li>联合体</li></ul><p>下面的 8 条概要规则为特殊规则提供了背景。</p><h3 id="5-1-概要规则"><a href="#5-1-概要规则" class="headerlink" title="5.1 概要规则"></a>5.1 概要规则</h3><p>概要规则相当简短，没有涉及太多细节。它们对类概括提供了有价值的深刻见解。</p><blockquote><p><strong>class（类）和struct（结构体）之间的语法差异</strong> 本节经常提到类和结构体之间的语义区别。首先。语法上的差异是什么？差异很小，但很重要： - 在结构体中，所有成员默认为 public（公开）；类为（private）私有。 - 继承情况也是如此。结构体默认继承权限为 public，类为 private。</p></blockquote><p><strong>除此之外，二者在语言语法层面完全一致</strong>。</p><h3 id="C-1-把相关的数据组织到结构（struct-或-class）中"><a href="#C-1-把相关的数据组织到结构（struct-或-class）中" class="headerlink" title="C.1 把相关的数据组织到结构（struct 或 class）中"></a>C.1 把相关的数据组织到结构（struct 或 class）中</h3><p>如何改进 draw 的接口？</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token keyword">int</span> fromX<span class="token punctuation">,</span> <span class="token keyword">int</span> fromY<span class="token punctuation">,</span> <span class="token keyword">int</span> toX<span class="token punctuation">,</span> <span class="token keyword">int</span> toY<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不明显的是，这些 int 代表了什么。因此，调用函数的时候参数顺序可能会出错。可以对比一下上面的 draw 和下面的新函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span>Point from<span class="token punctuation">,</span> Point to<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过将相关元素放在结构体中，函数签名变得可以自我描述，因此，比起之前的函数，新函数更不容易出错。</p><blockquote><p>类对象的构造函数也可以用来检测参数的合法性，不过这里的 Point 类型倒是没啥好检测的了。</p></blockquote><h3 id="C-2-当类具有不变式时使用-class；如果数据成员可以独立变化，则使用-struct"><a href="#C-2-当类具有不变式时使用-class；如果数据成员可以独立变化，则使用-struct" class="headerlink" title="C.2 当类具有不变式时使用 class；如果数据成员可以独立变化，则使用 struct"></a>C.2 当类具有不变式时使用 class；如果数据成员可以独立变化，则使用 struct</h3><blockquote><p>不变式（Invariant）是一个在程序执行过程中永远保持成立的条件。不变式在检测程序是否正确方面非常有用。例如编译器优化就用到了不变式。</p></blockquote><p>类的不变式是用于约束类的实例的不变式。成员函数必须使这个不变式保持成立。 不变式约束了类的实例的可能取值。</p><p>这是 C++ 中一个常见的问题：<em>什么时候该使用 class，什么时候该用 struct？</em></p><p>C++ Core Guidelines 给出了以下建议。<strong>如果类有不变式，就使用 class</strong>。</p><blockquote><p><strong>如果类有一个需要在程序执行过程中永远保持成立的条件，就使用 class</strong>。</p></blockquote><p>一个可能的类的不变式是，（y，m，d）可表示一个有效的日期。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Pair<span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//成员可以独立变化</span>
    string name<span class="token punctuation">;</span>
    <span class="token keyword">int</span> volume<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Date</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment" spellcheck="true">//校验 {yy，mm，dd}是不是合法的日期并进行初始化</span>
    <span class="token function">Date</span><span class="token punctuation">(</span><span class="token keyword">int</span> yy<span class="token punctuation">,</span> Month mm<span class="token punctuation">,</span> <span class="token keyword">char</span> dd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> y<span class="token punctuation">;</span>
    Month m<span class="token punctuation">;</span>
    <span class="token keyword">char</span> d<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//日</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类的不变式在构造函数中被初始化和检查。数据类型 Pair 没有不变式，因为名称（name）和体积（volume）的所有值都是有效的。Pair 是简单的数据持有者，不需要显式提供构造函数。</p><blockquote><p>值得一提的是，很多库并没有很好的遵守，我们举例 <a href="https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/qpoint.html">QPoint</a>，<a href="https://link.zhihu.com/?target=https%3A//codebrowser.dev/qt5/qtbase/src/corelib/tools/qpoint.h.html">源码</a>。</p></blockquote><p>QPoint 显然是没有不变式，它的成员（xp，yp）所有的值都是有效的，但它依旧使用的是 class。 以及，它没有将它的数据成员设置为 public，反而提供了愚蠢的 6 个成员函数进行访问：<code>rx，ry，x，y，setX，setY</code>。</p><h3 id="C-3-在类中体现出接口和实现之间的区别"><a href="#C-3-在类中体现出接口和实现之间的区别" class="headerlink" title="C.3 在类中体现出接口和实现之间的区别"></a>C.3 在类中体现出接口和实现之间的区别</h3><p>类的公开成员函数是类的接口，私有部分则是实现。</p><pre class="line-numbers language-cpp"><code class="language-cpp">类的公开成员函数是类的接口，私有部分则是实现。
<span class="token keyword">class</span> <span class="token class-name">Date</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//校验 {yy，mm，dd}是不是合法的日期并进行初始化</span>
    <span class="token function">Date</span><span class="token punctuation">(</span><span class="token keyword">int</span> yy<span class="token punctuation">,</span> Month mm<span class="token punctuation">,</span> <span class="token keyword">char</span> dd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token function">day</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">;</span>
    Month <span class="token function">month</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token comment" spellcheck="true">// ... 具体的内部表示</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从可维护性的角度看，可以修改 Date 类的实现，而毫不影响该类的使用者。</p><blockquote><p>就是说面向对象的<strong>封装</strong>，数据和操作数据的方法（即类的接口）捆绑在一起，并对外部隐藏对象的内部状态。这样可以确保类的接口有效性和不变性。</p></blockquote><h3 id="C-4-仅当函数需要直接访问类的内部表示时，才把它变成成员"><a href="#C-4-仅当函数需要直接访问类的内部表示时，才把它变成成员" class="headerlink" title="C.4 仅当函数需要直接访问类的内部表示时，才把它变成成员"></a>C.4 仅当函数需要直接访问类的内部表示时，才把它变成成员</h3><p>如果一个函数不需要访问类的内部结构，它就不应该是成员。这样的话，你会得到松耦合，而且类的内部结构的改变不会影响辅助函数。</p><blockquote><p>一个函数不修改类的私有数据成员，它就不该是成员</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Date</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// ... 相对小的接口 ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//辅助函数</span>
Date <span class="token function">next_weekday</span><span class="token punctuation">(</span>Date<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">==</span> <span class="token punctuation">(</span>Date<span class="token punctuation">,</span> Date<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运算符 <code>=</code>、<code>()</code>、<code>[]</code>、<code>-&gt;</code> 必须是类的成员。</p><blockquote><p>事实上这条规则没那么好遵守，有非常多的额外情况，英文原书和我们当前描写的都太少了。可以看<a href="https://link.zhihu.com/?target=https%3A//github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md%23c4-make-a-function-a-member-only-if-it-needs-direct-access-to-the-representation-of-a-class">英文文档</a>，或<a href="https://link.zhihu.com/?target=https%3A//github.com/lynnboy/CppCoreGuidelines-zh-CN/blob/master/CppCoreGuidelines-zh-CN.md%23c4-%E4%BB%85%E5%BD%93%E5%87%BD%E6%95%B0%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E7%B1%BB%E7%9A%84%E5%86%85%E9%83%A8%E8%A1%A8%E7%A4%BA%E6%97%B6%E6%89%8D%E8%AE%A9%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%85%B6%E6%88%90%E5%91%98">国人翻译</a>。</p></blockquote><h3 id="C-5-将辅助函数与它们支持的类放在同一个命名空间中"><a href="#C-5-将辅助函数与它们支持的类放在同一个命名空间中" class="headerlink" title="C.5 将辅助函数与它们支持的类放在同一个命名空间中"></a>C.5 将辅助函数与它们支持的类放在同一个命名空间中</h3><p>辅助函数应该在类的命名空间中，因为它是类的接口的一部分。与成员函数相反，辅助函数不需要直接访问类的内部表示。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">namespace</span> Chrono<span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 在这里放置跟时间有关的服务</span>
    <span class="token keyword">class</span> <span class="token class-name">Date</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 辅助函数：</span>
    <span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">==</span> <span class="token punctuation">(</span>Date<span class="token punctuation">,</span> Date<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Date <span class="token function">next_weekday</span><span class="token punctuation">(</span>Date<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>date1 <span class="token operator">==</span> date2<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true">//（1）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于有<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/adl">实参依赖查找</a>（argument-dependent lookup，ADL），比较 date1 == date2 将额外查找 Chrono 命名空间中的相等运算符。ADL 对于重载的运算符尤其重要，如输出运算符&lt;&lt;。</p><h3 id="C-7-不要在一条语句里定义类或枚举的同时声明该类型的变量"><a href="#C-7-不要在一条语句里定义类或枚举的同时声明该类型的变量" class="headerlink" title="C.7 不要在一条语句里定义类或枚举的同时声明该类型的变量"></a>C.7 不要在一条语句里定义类或枚举的同时声明该类型的变量</h3><p>若在一条语句里定义类或枚举并同时声明其他类型的变量，会引起混淆，因此应该避免。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 不好</span>
<span class="token keyword">struct</span> Date <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*...*/</span> <span class="token punctuation">}</span> date <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*...*/</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 好</span>
<span class="token keyword">struct</span> Date<span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*...*/</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
Date date<span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*...*/</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="C-8-如果有任何非公开成员，就使用-class-而不是-struct"><a href="#C-8-如果有任何非公开成员，就使用-class-而不是-struct" class="headerlink" title="C.8 如果有任何非公开成员，就使用 class 而不是 struct"></a>C.8 如果有任何非公开成员，就使用 class 而不是 struct</h3><p>明确某事被隐藏/抽象。这是一个有用的约定。</p><blockquote><p>除此之外可能还有很多乱七八糟的理由，但总而言之，就是这样，<strong>约定</strong>。</p></blockquote><h3 id="C-9-尽量减少成员的暴露"><a href="#C-9-尽量减少成员的暴露" class="headerlink" title="C.9 尽量减少成员的暴露"></a>C.9 尽量减少成员的暴露</h3><p>数据隐藏和<strong>封装</strong>是面向对象类设计的基石之一：你将类中的成员封装起来，只允许通过公共成员函数进行访问。你的类可能有两种接口：一种是用于外部的 public 接口，一种是用于派生类的 protected 接口。其余成员都应该属于 private。</p><blockquote><p>封装。信息隐藏。最大限度地减少意外访问的机会。这简化了维护。 需要注意的是，也不要什么成员都给封装了，这样会走上 java 的邪路，<code>get</code>、<code>set</code> …</p></blockquote><h3 id="5-2-具体类型"><a href="#5-2-具体类型" class="headerlink" title="5.2 具体类型"></a>5.2 具体类型</h3><p>本节只有两条规则，但引入了具体类型和规范类型这两个术语。 根据 C++ Core Guidelines：</p><p><strong>具体类型是“最简单的一种类”</strong>。它常常被称作值类型，不属于某个类型层次结构的一部分 。</p><p><strong>规范类型是一种“行为类似于 int”的类型</strong>，因此，它必须支持拷贝和赋值、相等比较，以及可交换。更正式的说法是，一个规范类型 X 行为上像 int，支持下列操作。</p><ul><li>默认构造：X()</li><li>拷贝构造：X(const X&amp;)</li><li>拷贝赋值：operator = (const X&amp;)</li><li>移动构造：X(X&amp;&amp;)</li><li>移动赋值：operator = (X&amp;&amp;)</li><li>析构：~X()</li><li>交换操作：swap(X&amp;, X&amp;)</li><li>相等运算符：operator ==(const X&amp;, const X&amp;)</li></ul><h3 id="C-10-优先使用具体类型而不是类层次结构"><a href="#C-10-优先使用具体类型而不是类层次结构" class="headerlink" title="C.10 优先使用具体类型而不是类层次结构"></a>C.10 优先使用具体类型而不是类层次结构</h3><p>如果没有需要类层次结构的用例，就使用具体类型。具体的类型更容易实现，更小，且更快。不必担心继承、虚性、引用或指针，包括内存分配和释放。不会有虚派发，因此也没有运行期开销。</p><p>长话短说：应用 <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/KISS_principle">KISS</a> 原则（“keep it simple,stupid”原则，保持简单，让傻瓜都能理解）。你的类型行为像普通数值一样。</p><h3 id="C-11-让具体类型规范化"><a href="#C-11-让具体类型规范化" class="headerlink" title="C.11 让具体类型规范化"></a>C.11 让具体类型规范化</h3><p>规范类型（如 int）易于理解，它们本身就很直观。这意味着：</p><ul><li>如果你有一个具体类型，可以考虑将它升级为规范类型。</li></ul><p>内置类型（如 int 或 double）是规范类型，而用户定义类型（如 std::string）或容器（std::vector 或 std::unordered_map）也是如此。</p><p>C++20 支持 regular （规范）概念。</p><h3 id="5-3-构造函数、赋值运算符和析构函数"><a href="#5-3-构造函数、赋值运算符和析构函数" class="headerlink" title="5.3 构造函数、赋值运算符和析构函数"></a>5.3 构造函数、赋值运算符和析构函数</h3><p>这一节讨论构造函数、赋值运算符和析构函数，在本章范围内，此类规则的数量是目前为止最多的。它们控制着对象的生命周期：创建、拷贝、移动和销毁。简而言之，我们把它们称为“六大”。下面是这六个特殊的成员函数。</p><ul><li>默认构造函数：X()</li><li>拷贝构造函数：X(const X&amp;)</li><li>拷贝赋值运算符：operator = (const X&amp;)</li><li>移动构造：X(X&amp;&amp;)</li><li>移动赋值运算符：operator = (X&amp;&amp;)</li><li>析构函数：~X()</li></ul><p>编译器可以为这“六大”生成默认实现。本节从有关默认操作的规则开始；接着是有关构造函数、拷贝和移动操作以及析构函数的规则；最后是不属于前四类的其他默认操作的规则。</p><p>根据默认构造函数的声明，你可能有这样的印象：默认构造函数不需要参数。这是不对的。默认构造函数可以在没有参数的情况下被调用，但它可能每个参数都有默认值。</p><h3 id="预置操作"><a href="#预置操作" class="headerlink" title="预置操作"></a>预置操作</h3><p>默认情况下，如果需要，编译器可以生成“六大”。可以定义这六个特殊的成员函数，但也可明确用 = default（预置）来要求编译器提供它们，或者用 = delete（弃置）来删除它们。</p><h3 id="C-20-如果能避免定义默认操作，那么就这么做"><a href="#C-20-如果能避免定义默认操作，那么就这么做" class="headerlink" title="C.20 如果能避免定义默认操作，那么就这么做"></a>C.20 如果能避免定义默认操作，那么就这么做</h3><p>这一规则也被称为“零法则”。这意味着你可以通过使用有合适的拷贝/移动语义的类型，来避免自行编写构造函数、拷贝/移动构造函数、赋值运算符或析构函数。有合适的拷贝/移动语义的类型包括规范类型，如内置类型 bool 或 double，也包括标准模板库（STL）的容器，如 std::vector 或 std::string。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Named_map</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment" spellcheck="true">// ... 没有声明任何默认操作 ...</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token operator">::</span>string name<span class="token punctuation">;</span>
    std<span class="token operator">::</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> rep<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Named_map mm<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 默认构造</span>
Named_map nm2 <span class="token punctuation">{</span>nm<span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 拷贝构造</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认构造和拷贝构造之所以有效，是因为 std::string 和 std::map 已经定义了相应的操作。</p><ul><li><strong>编译器所自动生成的拷贝构造函数会调用当前类所有成员的拷贝构造函数</strong>。</li></ul><blockquote><p>特殊成员函数都是这样，不局限于拷贝构造，这个其实以前在 <strong><a href="https://zhuanlan.zhihu.com/p/662592729/第2章-理念.md">P.9</a></strong> 提起过。（另外强调一下，这些话全说的是类类型）</p></blockquote><h3 id="C-21-如果定义或-delete-了任何默认操作，就对所有默认操作进行定义或-delete"><a href="#C-21-如果定义或-delete-了任何默认操作，就对所有默认操作进行定义或-delete" class="headerlink" title="C.21 如果定义或 =delete 了任何默认操作，就对所有默认操作进行定义或 =delete"></a>C.21 如果定义或 =delete 了任何默认操作，就对所有默认操作进行定义或 =delete</h3><p>“六大”是紧密相关的。由于这种关系，你应该对所有特殊成员函数进行定义或 =delete。因此，这条规则被称为“六法则”。有时你会听到“五法则”，这是因为默认构造函数很特殊，有时会被排除在外</p><table><thead><tr><th></th><th><strong>默认 构造函数</strong></th><th><strong>析构函数</strong></th><th><strong>拷贝 构造函数</strong></th><th><strong>拷贝赋值</strong></th><th><strong>移动 构造函数</strong></th><th><strong>移动赋值</strong></th></tr></thead><tbody><tr><td><strong>全部不声明</strong></td><td>预置</td><td>预置</td><td>预置</td><td>预置</td><td>预置</td><td>预置</td></tr><tr><td><strong>任意构造函数</strong></td><td>不声明</td><td>预置</td><td>预置</td><td>预置</td><td>预置</td><td>预置</td></tr><tr><td><strong>默认构造函数</strong></td><td>用户声明</td><td>预置</td><td>预置</td><td>预置</td><td>预置</td><td>预置</td></tr><tr><td><strong>析构函数</strong></td><td>预置</td><td>用户声明</td><td>预置</td><td>预置</td><td>不声明</td><td>不声明</td></tr><tr><td><strong>拷贝构造函数</strong></td><td>不声明</td><td>预置</td><td>用户声明</td><td>预置</td><td>不声明</td><td>不声明</td></tr><tr><td><strong>拷贝赋值</strong></td><td>预置</td><td>预置</td><td>预置</td><td>用户声明</td><td>不声明</td><td>不声明</td></tr><tr><td><strong>移动构造函数</strong></td><td>不声明</td><td>预置</td><td>弃置</td><td>弃置</td><td>用户声明</td><td>不声明</td></tr><tr><td><strong>移动赋值</strong></td><td>预置</td><td>预置</td><td>弃置</td><td>弃置</td><td>不声明</td><td>用户声明</td></tr></tbody></table><ul><li><em>当你定义*</em>任何构造函数*<em>时，默认构造函数就没有了。默认构造函数是可以在没有参数的情况下调用的构造函数</em>。</li><li><em>当你用 =default 或 =delete 定义或删除*</em>默认构造函数*<em>时，其他特殊成员函数都不受影响</em>。</li><li>当你用 =default 或 =delete 定义或删除<strong>析构函数</strong>、<strong>拷贝构造函数</strong>或<strong>拷贝赋值操作符</strong>时，编译器不会生成移动构造函数和移动赋值运算符。这意味着移动构造或移动赋值这样的移动操作会回退到拷贝构造或拷贝赋值。这种回退的自动操作在表格中以深色标出。</li><li>当用 =default 或 =delete 定义或删除<strong>移动构造函数</strong>或<strong>移动赋值运算符</strong>时，只能得到定义的 =default 或 =delete 的移动构造函数或移动赋值运算符。<strong>后果是，拷贝构造函数和拷贝赋值运算符被设置为 =delete[^2]</strong>。因此调用一个拷贝操作，如拷贝构造或拷贝赋值，将导致编译错误。</li></ul><p>当你不遵循这条规则时，你会得到非常不直观的对象。下面是 Guidelines 中的一个直观的例子。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstddef></span></span>

<span class="token keyword">class</span> <span class="token class-name">BitArray</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">BitArray</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t len<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">len_</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">data_</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">BitArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data_<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token operator">::</span>size_t len_<span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token operator">*</span> data_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    BitArray <span class="token function">bitArray1</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    BitArray <span class="token function">bitArray2</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    bitArray2 <span class="token operator">=</span> bitArray1<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//（1）</span>
<span class="token punctuation">}</span>                               <span class="token comment" spellcheck="true">//（2）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为什么这个程序有未定义行为？例子中默认的拷贝赋值操作 bitArray2 = bitArray1（1）拷贝了 bigArray2 的所有成员。拷贝意味着，在目前情况下，被拷贝的是 data 指针，而不是其指向的数据。因此，bigArray1 和 bigArray2 的析构函数被调用（2），由于<strong>重复释放</strong>，我们得到了未定义行为。</p><p>这个例子中不直观的行为是，编译器生成的 BigArray 的拷贝赋值操作符对 BigArray 进行了浅拷贝，但是 BigArray 的显式实现的析构函数假设了数据的所有权。</p><p><a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/5qzoz6qx3">运行效果</a>：</p><pre class="line-numbers language-text"><code class="language-text">double free or corruption (!prev)
Program terminated with signal: SIGSEGV<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="C-22-让默认操作保持一致"><a href="#C-22-让默认操作保持一致" class="headerlink" title="C.22 让默认操作保持一致"></a>C.22 让默认操作保持一致</h3><p>默认操作是一个概念上相配合的集合。它们的语义是相互关联的。</p><ul><li>如果复制/移动构造和复制/移动赋值所做的是逻辑上不同的事情的话，这会让使用者感觉诡异。</li><li>如果构造函数和析构函数并不提供一种对资源管理的统一视角的话，也会让使用者感觉诡异。</li><li>如果复制和移动操作并不体现出构造函数和析构函数的工作方式的话，同样会让使用者感觉诡异。</li></ul><h4 id="示例，不好"><a href="#示例，不好" class="headerlink" title="示例，不好"></a>示例，不好</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Silly</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 不好: 复制操作不一致</span>
    <span class="token keyword">class</span> <span class="token class-name">Impl</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// ...</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    shared_ptr<span class="token operator">&lt;</span>Impl<span class="token operator">></span> p<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Silly</span><span class="token punctuation">(</span><span class="token keyword">const</span> Silly<span class="token operator">&amp;</span> a<span class="token punctuation">)</span> <span class="token operator">:</span> p<span class="token punctuation">{</span>make_shared<span class="token operator">&lt;</span>Impl<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token punctuation">{</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">*</span>a<span class="token punctuation">.</span>p<span class="token punctuation">;</span> <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// 深复制</span>
    Silly<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Silly<span class="token operator">&amp;</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span> p <span class="token operator">=</span> a<span class="token punctuation">.</span>p<span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">// 浅复制</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些操作在复制语义上并不统一。这将会导致混乱和出现 BUG。</p><h4 id="强制实施"><a href="#强制实施" class="headerlink" title="强制实施"></a>强制实施</h4><ul><li>【复杂】 复制/移动构造函数和对应的复制/移动赋值运算符，应当在相同的解引用层次上向相同的成员变量进行写入。</li><li>【复杂】 在复制/移动构造函数中被写入的任何成员变量，在其他构造函数中也都应当进行初始化。</li><li>【复杂】 如果复制/移动构造函数对某个成员变量进行了深复制，就应当在析构函数中对这个成员变量进行修改。</li><li>【复杂】 如果析构函数修改了某个成员变量，在任何复制/移动构造函数或赋值运算符中就都应当对该成员变量进行写入。</li></ul><h4 id="C-dtor-析构函数"><a href="#C-dtor-析构函数" class="headerlink" title="C.dtor: 析构函数"></a>C.dtor: 析构函数</h4><p>“这个类需要析构函数吗？” 这是一个令人惊讶的富有洞察力的设计问题。对于大多数类，答案是“否”，因为该类没有资源，或者因为销毁是按<strong>零规则<a href="https://github.com/Mq-b/Loser-HomeWork/blob/main/src/C%2B%2BCoreGuidelines/第5章-类和类层次结构.md#user-content-fn-3-c821b79bd6278ecb3a6a345267201bad">4</a></strong> 处理的；也就是说，其成员可以在销毁方面自行解决。如果答案是“是”，则该类的大部分设计都会遵循（请参阅<strong>五规则<a href="https://github.com/Mq-b/Loser-HomeWork/blob/main/src/C%2B%2BCoreGuidelines/第5章-类和类层次结构.md#user-content-fn-4-c821b79bd6278ecb3a6a345267201bad">5</a></strong>）。</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>有 13 条规则涉及对象的构造。粗略来说，它们分为 5 类。</p><ul><li>构造函数通用</li><li>默认构造函数</li><li>单参数构造函数</li><li>成员初始化</li><li>特殊构造函数，如继承或委托构造函数</li></ul><p>最后，我需要警告一下。不要从委托构造函数中调用虚函数。在本章后面的“其他默认操作”一节中，我将在包括析构函数的更广泛的背景下提到这个警告。</p><h3 id="构造函数通用"><a href="#构造函数通用" class="headerlink" title="构造函数通用"></a>构造函数通用</h3><p>我跳过了规则 “C.40: 如果类有不变式，就定义构造函数”，因为我已经在“C.2: 当类具有不变式时使用 class；如果数据成员可以独立变化，则使用 struct”这条规则中写到了相关内容。因此，还剩下两条密切相关的规则：</p><p>“C.41: 构造函数应当创建完全初始化的对象”和“C.42: 如果构造函数无法构造出有效对象，则应抛出异常”。</p><h3 id="C-41-构造函数应当创建完全初始化的对象"><a href="#C-41-构造函数应当创建完全初始化的对象" class="headerlink" title="C.41 构造函数应当创建完全初始化的对象"></a>C.41 构造函数应当创建完全初始化的对象</h3><p>构造函数的职责就是创建完全初始化的对象。类不应有 init（初始化）成员函数，不然就是自找麻烦。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">DiskFile</span><span class="token punctuation">{</span>
    FILE<span class="token operator">*</span> f<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">DiskFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 初始化 f</span>
    <span class="token keyword">void</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 从 f 读取</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    DiskFile file<span class="token punctuation">;</span>
    file<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 崩溃，或错误读取！</span>
    file<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 太晚了</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用户可能会错误地在 init 之前调用 read，或者只是忘了调用 init。将成员函数 init 设为私有，并从所有构造函数中调用它，这样做好一些，但仍不是最佳选择。当一个类的所有构造函数有共同的操作时，请使用<a href="https://zh.cppreference.com/w/cpp/language/constructor#.E5.A7.94.E6.89.98.E6.9E.84.E9.80.A0.E5.87.BD.E6.95.B0">委托构造函数</a>。</p><h3 id="C-42-如果构造函数无法构造出有效对象，则应该抛出异常"><a href="#C-42-如果构造函数无法构造出有效对象，则应该抛出异常" class="headerlink" title="C.42 如果构造函数无法构造出有效对象，则应该抛出异常"></a>C.42 如果构造函数无法构造出有效对象，则应该抛出异常</h3><p>根据前面的规则</p><ul><li><em>如果不能构造出有效的对象，那就该抛异常。</em></li></ul><p>没有太多可补充的东西。如果使用无效的对象，你就总得在使用之前检查对象的状态。这样非常繁琐、低效且容易出错。例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">DiskFile</span><span class="token punctuation">{</span>
    FILE<span class="token operator">*</span> f<span class="token punctuation">;</span>
    <span class="token keyword">bool</span> valid<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">explicit</span> <span class="token function">DiskFile</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> name<span class="token punctuation">)</span> <span class="token operator">:</span>f<span class="token punctuation">{</span> <span class="token function">fopen</span><span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"r"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> valid<span class="token punctuation">{</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span>valid <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// ...</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">bool</span> <span class="token function">is_valid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> valid<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 从 f 读取</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    DiskFile file<span class="token punctuation">{</span> <span class="token string">"Heraclides"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    file<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 崩溃，或读取错误！</span>
    <span class="token comment" spellcheck="true">// ...</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">is_valid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        file<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// ...</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// ...处理错误...</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h3><p>接下来的两条规则回答了这个问题：一个类什么时候需要默认构造函数，什么时候不需要默认构造函数？</p><h3 id="C-43-确保可拷贝的（值类型）类有默认构造函数"><a href="#C-43-确保可拷贝的（值类型）类有默认构造函数" class="headerlink" title="C.43 确保可拷贝的（值类型）类有默认构造函数"></a>C.43 确保可拷贝的（值类型）类有默认构造函数</h3><p>不正式地说，当类的实例缺少有意义的默认值时，该类就不需要默认构造函数。例如，“人”没有有意义的默认值，但是像“银行账户”这样的类型则有。银行账户的初始值可能是零。拥有默认的构造函数，可以使你的类型更容易使用。STL 容器的许多构造函数都要求你的类型有默认构造函数——例如，有序的关联容器（如 std::map）里的值。如果类的所有成员都有默认构造函数，编译器会尽可能为你的类生成默认构造函数</p><p>现在说说不应该提供默认构造函数的情况。</p><h3 id="C-45-不要定义仅初始化数据成员的默认构造函数，而应使用默认成员初始化器"><a href="#C-45-不要定义仅初始化数据成员的默认构造函数，而应使用默认成员初始化器" class="headerlink" title="C.45 不要定义仅初始化数据成员的默认构造函数，而应使用默认成员初始化器"></a>C.45 不要定义仅初始化数据成员的默认构造函数，而应使用默认成员初始化器</h3><p>代码常常胜过千言万语。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span>

<span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">width</span><span class="token punctuation">(</span><span class="token number">640</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">height</span><span class="token punctuation">(</span><span class="token number">480</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">frame</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">visible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">explicit</span> <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">width</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">height</span><span class="token punctuation">(</span><span class="token function">getHeight</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">frame</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">visible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token keyword">int</span> w<span class="token punctuation">,</span> <span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">width</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">height</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">frame</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">visible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token punctuation">{</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>boolalpha <span class="token operator">&lt;&lt;</span> width <span class="token operator">&lt;&lt;</span> <span class="token string">"x"</span> <span class="token operator">&lt;&lt;</span> height
            <span class="token operator">&lt;&lt;</span> <span class="token string">", frame: "</span> <span class="token operator">&lt;&lt;</span> frame
            <span class="token operator">&lt;&lt;</span> <span class="token string">", visible: "</span> <span class="token operator">&lt;&lt;</span> visible <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> w <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">int</span> width<span class="token punctuation">;</span>
    <span class="token keyword">int</span> height<span class="token punctuation">;</span>
    <span class="token keyword">bool</span> frame<span class="token punctuation">;</span>
    <span class="token keyword">bool</span> visible<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">WidgetImpro</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">WidgetImpro</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
    <span class="token keyword">explicit</span> <span class="token function">WidgetImpro</span><span class="token punctuation">(</span><span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">width</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">height</span><span class="token punctuation">(</span><span class="token function">getHeight</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token function">WidgetImpro</span><span class="token punctuation">(</span><span class="token keyword">int</span> w<span class="token punctuation">,</span> <span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">width</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">height</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">{</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>boolalpha <span class="token operator">&lt;&lt;</span> width <span class="token operator">&lt;&lt;</span> <span class="token string">"x"</span> <span class="token operator">&lt;&lt;</span> height
            <span class="token operator">&lt;&lt;</span> <span class="token string">", frame: "</span> <span class="token operator">&lt;&lt;</span> frame
            <span class="token operator">&lt;&lt;</span> <span class="token string">", visible: "</span> <span class="token operator">&lt;&lt;</span> visible <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> w <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">int</span> width<span class="token punctuation">{</span> <span class="token number">640</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> height<span class="token punctuation">{</span> <span class="token number">480</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">bool</span> frame<span class="token punctuation">{</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">bool</span> visible<span class="token punctuation">{</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>

    Widget wVGA<span class="token punctuation">;</span>
    Widget <span class="token function">wSVGA</span><span class="token punctuation">(</span><span class="token number">800</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Widget <span class="token function">wHD</span><span class="token punctuation">(</span><span class="token number">1280</span><span class="token punctuation">,</span> <span class="token number">720</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    wVGA<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    wSVGA<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    wHD<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>

    WidgetImpro wImproVGA<span class="token punctuation">;</span>
    WidgetImpro <span class="token function">wImproSVGA</span><span class="token punctuation">(</span><span class="token number">800</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    WidgetImpro <span class="token function">wImproHD</span><span class="token punctuation">(</span><span class="token number">1280</span><span class="token punctuation">,</span> <span class="token number">720</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    wImproVGA<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    wImproSVGA<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    wImproHD<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类 Widget 仅使用它的三个构造函数来初始化成员。重构后的 WidgetImpro 类直接在类内部初始化其成员，通过将初始化从构造函数移进类的主体，三个构造函数，变得更加容易理解，类也更容易维护。例如，当你在类中添加新成员时，你只需要在类的主体中添加初始化，而不必在所有的构造函数中添加。此外，你也不需要考虑将初始化器按正确的顺序放在构造函数中了。这样，当创建新对象时，也不可能发生对象只是部分初始化的情况了。</p><p>当然，这两个对象的行为是相同的。</p><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><pre><code>640x480, frame: false, visible: true
800x600, frame: false, visible: true
1280x720, frame: false, visible: true

640x480, frame: false, visible: true
800x600, frame: false, visible: true
1280x720, frame: false, visible: true</code></pre><p>我在设计新类时遵循的方法是，在类的主体中定义默认行为。明确定义的构造函数只用来改变默认行为。</p><p>你是否注意到了前面那个只有一个参数的构造函数中的关键字 <a href="https://zh.cppreference.com/w/cpp/language/explicit">explicit</a>？</p><h3 id="C-46-默认情况下，把单参数的构造函数声明为-explicit"><a href="#C-46-默认情况下，把单参数的构造函数声明为-explicit" class="headerlink" title="C.46 默认情况下，把单参数的构造函数声明为 explicit"></a>C.46 默认情况下，把单参数的构造函数声明为 explicit</h3><p>说得更明确一点，一个没有 explicit 的单参数的构造函数是个转换构造函数。转换构造函数接受一个参数，并从该参数中生成该类的一个对象。这种行<strong>为会让人大吃一惊</strong>。</p><blockquote><p>C++11 后：不以说明符 explicit 声明的构造函数被称为<a href="https://zh.cppreference.com/w/cpp/language/converting_constructor">转换构造函数</a>（converting constructor）。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">String</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// BAD</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

String s <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 惊喜: 大小为 10 的String</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简单的说就是，10 会调用转换构造函数，构造出一个临时的 String 对象，然后再初始化 s，即 <strong><code>String s(String(10))</code></strong>，通常我们应该避免这种行为，比如使用 explicit。</p><p>下面是函数传参的形式，其实意思是一样的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">String</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// BAD</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> String<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 相当于 f(String(10))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你确实想要从构造函数参数类型到类类型的隐式转换，请不要使用 explicit。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Complex</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Complex</span><span class="token punctuation">(</span><span class="token keyword">double</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// OK: 我们想要 double 到当前类的转换</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Complex z <span class="token operator">=</span> <span class="token number">10.7</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 奇怪的转换</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="类和类的层次结构-2"><a href="#类和类的层次结构-2" class="headerlink" title="类和类的层次结构-2"></a>类和类的层次结构-2</h2><h3 id="C-47-按成员声明的顺序定义和初始化成员变量"><a href="#C-47-按成员声明的顺序定义和初始化成员变量" class="headerlink" title="C.47 按成员声明的顺序定义和初始化成员变量"></a>C.47 按成员声明的顺序定义和初始化成员变量</h3><p><strong>类成员是按照它们的声明顺序进行初始化的</strong>。如果你在成员初始化列表以不同的顺序初始化它们，你可能会大吃一惊。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>

<span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> m1<span class="token punctuation">;</span>
    <span class="token keyword">int</span> m2<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">:</span>m2<span class="token punctuation">{</span> x <span class="token punctuation">}</span><span class="token punctuation">,</span> m1<span class="token punctuation">{</span> <span class="token operator">++</span>x <span class="token punctuation">}</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 糟糕：初始化顺序会让人误解</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"m1："</span> <span class="token operator">&lt;&lt;</span> m1 <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"m2："</span> <span class="token operator">&lt;&lt;</span> m2 <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    Foo <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre><code>m1：2
m2：2</code></pre><p>许多人认为，首先是 m2 被初始化，然后是 m1。这样 m2 会得到 1，而 m1 会得到 2。</p><ul><li><em>列表中的成员初始化器的顺序和初始化顺序是不相关的</em></li></ul><p>实际的初始化规则远不止如此，参见<a href="https://zh.cppreference.com/w/cpp/language/constructor#.E5.88.9D.E5.A7.8B.E5.8C.96.E9.A1.BA.E5.BA.8F">文档</a>。</p><h3 id="C-48-在使用常量来初始化时，优先选择默认成员初始化器，而不是构造函数的成员初始化"><a href="#C-48-在使用常量来初始化时，优先选择默认成员初始化器，而不是构造函数的成员初始化" class="headerlink" title="C.48 在使用常量来初始化时，优先选择默认成员初始化器，而不是构造函数的成员初始化"></a>C.48 在使用常量来初始化时，优先选择默认成员初始化器，而不是构造函数的成员初始化</h3><p>这条规则有点类似于之前的规则“C.45：不要定义仅初始化数据成员的默认构造函数，而应使用成员初始化器”。默认成员初始化器使你能更容易地定义构造函数。此外，你也不会忘记初始化某个成员了。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">X</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>                          <span class="token comment" spellcheck="true">// 不好</span>
    std<span class="token operator">::</span>string s<span class="token punctuation">;</span>
    <span class="token keyword">int</span> j<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">X</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span>i<span class="token punctuation">{</span> <span class="token number">666</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> s<span class="token punctuation">{</span> <span class="token string">"qqq"</span> <span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// j 没有初始化</span>
    <span class="token keyword">explicit</span> <span class="token function">X</span><span class="token punctuation">(</span><span class="token keyword">int</span> ii<span class="token punctuation">)</span> <span class="token operator">:</span>i<span class="token punctuation">{</span> ii <span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// s 是 ""，而 j 没有初始化</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">X2</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>string s<span class="token punctuation">{</span><span class="token string">"qqq"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> j<span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">X2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// 所有成员都被初始化成默认值</span>
    <span class="token keyword">explicit</span> <span class="token function">X2</span><span class="token punctuation">(</span><span class="token keyword">int</span> ii<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">i</span><span class="token punctuation">(</span>ii<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// s 和 j 被初始化为默认值</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><em>虽然默认成员初始化规定了一个对象的默认行为，但构造函数可以改变这一默认行为</em>。</li></ul><h3 id="C-49-在构造函数里优先使用初始化而不是赋值"><a href="#C-49-在构造函数里优先使用初始化而不是赋值" class="headerlink" title="C.49 在构造函数里优先使用初始化而不是赋值"></a>C.49 在构造函数里优先使用初始化而不是赋值</h3><p>初始化对赋值有两个最明显的优点：首先，你不会因为忘记赋值而使用未初始化的成员；其次，<strong>初始化可能更快，并且绝不会比赋值慢</strong>。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Bad</span><span class="token punctuation">{</span>
    string s1<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Bad</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> s2<span class="token punctuation">)</span> <span class="token punctuation">{</span> s <span class="token operator">=</span> s2<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 不好：先默认初始化再赋值</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="特殊构造函数"><a href="#特殊构造函数" class="headerlink" title="特殊构造函数"></a>特殊构造函数</h4><p>从 C++11 开始，一个构造函数可把它的工作委托给同一个类的另一个构造函数，并且构造函数可以从父类继承。这两种技术都允许程序员编写更简洁、更具有表达力的代码。</p><h3 id="C-51-使用委托构造函数来表示类的所有构造函数的共同动作"><a href="#C-51-使用委托构造函数来表示类的所有构造函数的共同动作" class="headerlink" title="C.51 使用委托构造函数来表示类的所有构造函数的共同动作"></a>C.51 使用委托构造函数来表示类的所有构造函数的共同动作</h3><p>一个构造函数可以把它的工作委托给同一类的另一个构造函数。委托是 C++ 中把所有构造函数的共同动作放到一个构造函数中的现代方式。在 C++11 之前，必须使用一个特殊的初始化函数，它通常被称为 init。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Degree</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">explicit</span> <span class="token function">Degree</span><span class="token punctuation">(</span><span class="token keyword">int</span> deg<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//（1）</span>
        degree <span class="token operator">=</span> deg <span class="token operator">%</span> <span class="token number">360</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>degree <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>degree <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">360</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">Degree</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">Degree</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>             <span class="token comment" spellcheck="true">//（2）</span>
    <span class="token keyword">explicit</span> <span class="token function">Degree</span><span class="token punctuation">(</span><span class="token keyword">double</span> deg<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">Degree</span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">ceil</span><span class="token punctuation">(</span>deg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">//（3）</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> degree<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Degree 类的构造函数（2）和（3）将其初始化工作委托给构造函数（1），后者验证其参数。注意，递归调用构造函数是未定义行为。</p><p>一个简化的实现在类中初始化 Degree，并使用预置的默认构造函数。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Degree</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">explicit</span> <span class="token function">Degree</span><span class="token punctuation">(</span><span class="token keyword">int</span> deg<span class="token punctuation">)</span> <span class="token punctuation">{</span>                              <span class="token comment" spellcheck="true">//（1）</span>
        degree <span class="token operator">=</span> deg <span class="token operator">%</span> <span class="token number">360</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>degree <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>degree <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">360</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">Degree</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>                                     <span class="token comment" spellcheck="true">//（2）</span>

    <span class="token keyword">explicit</span> <span class="token function">Degree</span><span class="token punctuation">(</span><span class="token keyword">double</span> deg<span class="token punctuation">)</span> <span class="token operator">:</span>                           <span class="token comment" spellcheck="true">//（3）</span>
        <span class="token function">Degree</span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">ceil</span><span class="token punctuation">(</span>deg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>        
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> degree <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span><span class="token function">ceil</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="C-52-使用继承构造函数将构造函数导入不需要进一步显式初始化的派生类中"><a href="#C-52-使用继承构造函数将构造函数导入不需要进一步显式初始化的派生类中" class="headerlink" title="C.52 使用继承构造函数将构造函数导入不需要进一步显式初始化的派生类中"></a>C.52 使用继承构造函数将构造函数导入不需要进一步显式初始化的派生类中</h3><p>如果可以的话，在派生类中重用基类的构造函数。当派生类没有成员时，这种重用的想法很合适。如果在可重用构造函数时不用，你就违反了 DRY（don’t repeat yourself 不要重复自己）原则。</p><p>继承的构造函数保留了它们在基类中定义的所有特性，如访问说明符，或属性 explicit 和 constexpr。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Rec</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Rec</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// ... 数据和很多漂亮的构造函数 ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Oper</span> <span class="token operator">:</span> <span class="token keyword">public</span> Rec <span class="token punctuation">{</span>
    <span class="token keyword">using</span> Rec<span class="token operator">::</span>Rec<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// ... 没有数据成员 ...</span>
    <span class="token comment" spellcheck="true">// ... 很多漂亮的工具函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> Rec2 <span class="token operator">:</span> <span class="token keyword">public</span> Rec<span class="token punctuation">{</span>
    <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">using</span> Rec<span class="token operator">::</span>Rec<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Rec2 r<span class="token punctuation">{</span> <span class="token string">"foo"</span><span class="token punctuation">,</span><span class="token number">7</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> val <span class="token operator">=</span> r<span class="token punctuation">.</span>x<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// r.x 没有初始化</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>如果 using 声明指代了正在定义的类的某个直接基类的构造函数（例如 using Base::Base;），那么在<strong>初始化派生类时，该基类的所有构造函数（忽略成员访问）均对重载决议可见</strong>。见<a href="https://zh.cppreference.com/w/cpp/language/using_declaration#.E7.BB.A7.E6.89.BF.E6.9E.84.E9.80.A0.E5.87.BD.E6.95.B0">文档</a>。</p></blockquote><p>使用继承构造函数时会遇到一个危险。如果你的派生类（如 Rec2）有自己的成员，<strong>如 int x，它们不会被初始化</strong>，除非它们有类内初始化器（见“C.48: 在使用常量初始化时，优先选择类内初始化器，而不是构造函数的成员初始化”）。</p><h4 id="拷贝和移动"><a href="#拷贝和移动" class="headerlink" title="拷贝和移动"></a>拷贝和移动</h4><p>尽管 C++CoreGuidelines 有八条关于拷贝和移动的规则，它们可以归结为三类规则：拷贝和移动赋值操作，拷贝和移动语义，还有臭名昭著的分片问题。</p><h5 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h5><p>语法</p><p>“C.60：使用拷贝赋值非 virtual 以 const&amp; 传参，并返回非 const 的引用” 和 “C.63：使移动赋值非 virtual 以 &amp;&amp; 传参，并返回非 const 的引用”这两条规则明确说明了拷贝和移动赋值运算符的语法。std::vector 遵循建议的语法。下面是一个简化版本：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 拷贝赋值</span>
vector<span class="token operator">&amp;</span> <span class="token keyword">operator</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&amp;</span> other<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 移动赋值</span>
vector<span class="token operator">&amp;</span> <span class="token keyword">operator</span> <span class="token operator">=</span> <span class="token punctuation">(</span>vector<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// C++17 前</span>
vector<span class="token operator">&amp;</span> <span class="token keyword">operator</span> <span class="token operator">=</span> <span class="token punctuation">(</span>vector<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// C++17 起</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一小片段代码显示了，移动赋值运算符是 noexcept。在 C++17 中，这条规则非常明显——“C.66：使移动操作 noexcept”。移动操作包括移动构造和移动赋值运算符。一个 noexcept 声明的函数对编译器来说是个优化机会。下面的代码片段显示了 std::vector 的移动操作和声明。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">vector</span><span class="token punctuation">(</span>vector<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// C++17 起</span>
vector<span class="token operator">&amp;</span> <span class="token keyword">operator</span> <span class="token operator">=</span> <span class="token punctuation">(</span>vector<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// C++17 起</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这一小片段代码显示了，移动赋值运算符是 noexcept。在 C++17 中，这条规则非常明显——“C.66：使移动操作 noexcept”。移动操作包括移动构造函数和移动赋值运算符。一个 noexcept 声明的函数对编译器来说是个优化机会。下面的代码片段展示了 std::vector 的移动操作的声明。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">vector</span><span class="token punctuation">(</span>vector<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// C++17 起</span>
vector<span class="token operator">&amp;</span> <span class="token keyword">operator</span> <span class="token operator">=</span> <span class="token punctuation">(</span>vector<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// C++17 起</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="自赋值"><a href="#自赋值" class="headerlink" title="自赋值"></a>自赋值</h4><p>“C.62：使拷贝赋值对自赋值安全”和“C.65：使移动赋值对自赋值安全”这两条规则都涉及自赋值。自赋值安全意味着操作 x = x 不应该改变 x 的值。</p><p>对于 STL 容器、std::string 和内置类型，如 int 等，拷贝/移动赋值对于自赋值是安全的。自动生成的拷贝/移动赋值运算符对于自赋值也是安全的。</p><p>下面的类 Foo 行为正确，自赋值是安全的。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>string s<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    Foo<span class="token operator">&amp;</span> Foo<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Foo<span class="token operator">&amp;</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        s <span class="token operator">=</span> a<span class="token punctuation">.</span>s<span class="token punctuation">;</span>
        i <span class="token operator">=</span> a<span class="token punctuation">.</span>i<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    Foo<span class="token operator">&amp;</span> Foo<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token operator">=</span> <span class="token punctuation">(</span>Foo<span class="token operator">&amp;&amp;</span> a<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">{</span>
        s <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
        i <span class="token operator">=</span> a<span class="token punctuation">.</span>i<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这种情况下，任何多余、高开销的自赋值检查都会不必要地让性能变差。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>string s<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    Foo<span class="token operator">&amp;</span> Foo<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Foo<span class="token operator">&amp;</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 多余的自赋值检查</span>
        s <span class="token operator">=</span> a<span class="token punctuation">.</span>s<span class="token punctuation">;</span>
        i <span class="token operator">=</span> a<span class="token punctuation">.</span>i<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    Foo<span class="token operator">&amp;</span> Foo<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token operator">=</span> <span class="token punctuation">(</span>Foo<span class="token operator">&amp;&amp;</span> a<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 多余的自赋值检查</span>
        s <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
        i <span class="token operator">=</span> a<span class="token punctuation">.</span>i<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="语义"><a href="#语义" class="headerlink" title="语义"></a>语义</h4><p>本节的两条规则听起来很明显：“C.61：拷贝操作应该进行拷贝”和“C.64：移动操作应该进行移动，并使源对象处于有效状态”。那么是什么意思呢？</p><ul><li>拷贝操作<ul><li>在拷贝之后（a = b），a 和 b 必须相同（a == b）。</li><li>拷贝可深可浅。深拷贝意味着对象 a 和 b 之后是相互独立的（值语义）。</li></ul></li><li>移动操作<ul><li>C++ 标准要求被移动的对象之后必须处于一个未指定但有效的状态。通常情况下，这个被移动的状态是移动操作源对象的默认状态。</li></ul></li></ul><h3 id="C-67-多态类应当抑制公开的拷贝-移动操作"><a href="#C-67-多态类应当抑制公开的拷贝-移动操作" class="headerlink" title="C.67 多态类应当抑制公开的拷贝/移动操作"></a>C.67 多态类应当抑制公开的拷贝/移动操作</h3><p>这条规则听起来无伤大雅，但往往是未定义行为的起因。首先，什么是多态类？ 多态类是定义或继承了至少一个虚函数的类。 拷贝一个多态类的操作可能会以切片而告终。切片是 C++ 中最黑暗的部分之一。</p><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><blockquote><p>切片意味着你想要在赋值或初始化过程中拷贝一个对象，但你只得到该对象的一部分。我们给出一个简单的例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Base<span class="token punctuation">{</span>
    <span class="token keyword">int</span> base<span class="token punctuation">{</span> <span class="token number">1998</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> Dervied <span class="token operator">:</span>Base <span class="token punctuation">{</span>
    <span class="token keyword">int</span> derived<span class="token punctuation">{</span> <span class="token number">2011</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">needB</span><span class="token punctuation">(</span>Base b<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    Dervied d<span class="token punctuation">;</span>
    Base b <span class="token operator">=</span> d<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// （1）</span>
    Base <span class="token function">b2</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// （2）</span>
    <span class="token function">needB</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// （3）</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote></div><hr><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/tags/Cpp/"><span class="chip bg-color">Cpp</span> </a><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="chip bg-color">读书笔记</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="wechat,qq" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="/libs/share/js/social-share.min.js"></script></div></div></div></div></div><style>.valine-card{margin:1.5rem auto}.valine-card .card-content{padding:20px 20px 5px 20px}#vcomments textarea{box-sizing:border-box;background:url(/medias/comment_bg.png) 100% 100% no-repeat}#vcomments p{margin:2px 2px 10px;font-size:1.05rem;line-height:1.78rem}#vcomments blockquote p{text-indent:.2rem}#vcomments a{padding:0 2px;color:#4cbf30;font-weight:500;text-decoration:none}#vcomments img{max-width:100%;height:auto;cursor:pointer}#vcomments ol li{list-style-type:decimal}#vcomments ol,ul{display:block;padding-left:2em;word-spacing:.05rem}#vcomments ul li,ol li{display:list-item;line-height:1.8rem;font-size:1rem}#vcomments ul li{list-style-type:disc}#vcomments ul ul li{list-style-type:circle}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}#vcomments table,td,th{border:0}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments h1{font-size:1.85rem;font-weight:700;line-height:2.2rem}#vcomments h2{font-size:1.65rem;font-weight:700;line-height:1.9rem}#vcomments h3{font-size:1.45rem;font-weight:700;line-height:1.7rem}#vcomments h4{font-size:1.25rem;font-weight:700;line-height:1.5rem}#vcomments h5{font-size:1.1rem;font-weight:700;line-height:1.4rem}#vcomments h6{font-size:1rem;line-height:1.3rem}#vcomments p{font-size:1rem;line-height:1.5rem}#vcomments hr{margin:12px 0;border:0;border-top:1px solid #ccc}#vcomments blockquote{margin:15px 0;border-left:5px solid #42b983;padding:1rem .8rem .3rem .8rem;color:#666;background-color:rgba(66,185,131,.1)}#vcomments pre{font-family:monospace,monospace;padding:1.2em;margin:.5em 0;background:#272822;overflow:auto;border-radius:.3em;tab-size:4}#vcomments code{font-family:monospace,monospace;padding:1px 3px;font-size:.92rem;color:#e96900;background-color:#f8f8f8;border-radius:2px}#vcomments pre code{font-family:monospace,monospace;padding:0;color:#e8eaf6;background-color:#272822}#vcomments pre[class*=language-]{padding:1.2em;margin:.5em 0}#vcomments code[class*=language-],pre[class*=language-]{color:#e8eaf6}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}#vcomments b,strong{font-weight:700}#vcomments dfn{font-style:italic}#vcomments small{font-size:85%}#vcomments cite{font-style:normal}#vcomments mark{background-color:#fcf8e3;padding:.2em}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}.v .vlist .vcard{padding-top:2.5em!important}</style><div class="card valine-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;left:20px;top:15px;padding-bottom:5px"><i class="fa fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="vcomments" class="card-content" style="display:grid"></div></div><script src="/libs/valine/av-min.js"></script><script src="/libs/valine/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"98JpzSGcrl9jFqHO13vqxHvX-gzGzoHsz",appKey:"mDmr2h9PB20xvPMNqgyRnNIC",notify:!0,verify:!0,visitor:!0,avatar:"mm",pageSize:"10",lang:"zh-cn",placeholder:"just go go"})</script><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fa fa-chevron-left"></i>&nbsp;上一篇</div><div class="card"><a href="/posts/15264/"><div class="card-image"><img src="/medias/featureimages/26.jpg" class="responsive-img" alt="Effective STL-STL使用经验"> <span class="card-title">Effective STL-STL使用经验</span></div></a><div class="card-content article-content"><div class="summary block-with-text">前言基于接口和实现分离的原则，了解STL的接口和STL的实现。 第 1 条：慎重选择容器类型 标准 STL 序列容器：vector、string、deque、list。 标准 STL 关联容器：set、multiset、map、multim</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2023-12-12 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="post-category">读书笔记</a></span></div></div><div class="card-action article-tags"><a href="/tags/Cpp/"><span class="chip bg-color">Cpp</span> </a><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="chip bg-color">读书笔记</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fa fa-chevron-right"></i></div><div class="card"><a href="/posts/21341/"><div class="card-image"><img src="/medias/featureimages/13.jpg" class="responsive-img" alt="git如何更新新的个人令牌Tokens"> <span class="card-title">git如何更新新的个人令牌Tokens</span></div></a><div class="card-content article-content"><div class="summary block-with-text">前言2021年8月13日开始，GitHub在使用Git操作远程仓库时不再支持使用用户名密码形式进行身份验证，需使用个人访问令牌。使用Git操作GitHub仓库时使用用户名密码进行身份验证会报错： 解决方法使用token登录的方式，就是把你</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2023-10-09 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E6%9D%82%E8%AE%B0/" class="post-category">杂记</a></span></div></div><div class="card-action article-tags"><a href="/tags/%E6%9D%82%E8%AE%B0/"><span class="chip bg-color">杂记</span> </a><a href="/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"><span class="chip bg-color">工程经验</span> </a><a href="/tags/Tool/"><span class="chip bg-color">Tool</span></a></div></div></div></div></article></div><script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script><script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script><script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script><script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget"><div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fa fa-list"></i></a></div><script src="/libs/tocbot/tocbot.min.js"></script><script>$(function(){tocbot.init({tocSelector:"#toc-content",contentSelector:"#articleContent",headingsOffset:-(.4*$(window).height()-45),headingSelector:"h2, h3, h4, h5"});let t=0;var e="toc-heading-";$("#toc-content a").each(function(){$(this).attr("href","#"+e+ ++t)}),t=0,$("#articleContent").children("h2, h3, h4, h5").each(function(){$(this).attr("id",e+ ++t)});var n=parseInt(.4*$(window).height()-64);let o=$(".toc-widget");$(window).scroll(function(){var t=$(window).scrollTop();n<t?o.addClass("toc-fixed"):o.removeClass("toc-fixed")});var i="expanded";let a=$("#toc-aside"),c=$("#main-content");$("#floating-toc-btn .btn-floating").click(function(){a.hasClass(i)?(a.removeClass(i).hide(),c.removeClass("l9")):(a.addClass(i).show(),c.addClass("l9")),function(){let e=$("#artDetail");if(0!==e.length){let t=e.width();450<=t?t+=21:350<=t&&t<450?t+=18:300<=t&&t<350?t+=16:t+=14,$("#prenext-posts").width(t)}}()})})</script></main><footer class="page-footer bg-color"><div class="container row center-align"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2019</span> <a href="/about" rel="external nofollow noreferrer">JoyTsing</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br><span id="sitetime">载入运行时间...</span> <span id="busuanzi_container_site_pv">|&nbsp;<i class="fa fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span>&nbsp;次 </span><span id="busuanzi_container_site_uv">|&nbsp;<i class="fa fa-user"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv" class="white-color"></span>&nbsp;人</span><br>&nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;<span class="white-color">718.4k</span>&nbsp;字 <span id="icp"><img src="/medias/icp.png" style="vertical-align:text-bottom" alt="icp"> <a href="https://beian.miit.gov.cn/" target="_blank">陕公网安备61019002002862号 滇ICP备2024026466号-1</a></span><script>function siteTime(){var e=864e5,t="2019",n=(m=new Date).getFullYear(),o=m.getMonth()+1,r=m.getDate(),a=m.getHours(),i=m.getMinutes(),l=m.getSeconds(),m=Date.UTC(t,"7","24","0","0","0"),r=Date.UTC(n,o,r,a,i,l)-m,a=Math.floor(r/31536e6),i=Math.floor(r/e-365*a),l=Math.floor((r-(365*a+i)*e)/36e5),m=Math.floor((r-(365*a+i)*e-36e5*l)/6e4),M=Math.floor((r-(365*a+i)*e-36e5*l-6e4*m)/1e3);t==n?(document.getElementById("year").innerHTML=n,document.getElementById("sitetime").innerHTML="本站已安全运行 "+i+" 天 "+l+" 小时 "+m+" 分钟 "+M+" 秒"):(document.getElementById("year").innerHTML=t+" - "+n,document.getElementById("sitetime").innerHTML="本站已安全运行 "+a+" 年 "+i+" 天 "+l+" 小时 "+m+" 分钟 "+M+" 秒")}setInterval(siteTime,1e3)</script></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/JoyTsing" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fa fa-github"></i> </a><a href="/medias/wechat.jpg" target="_blank" data-tooltip="添加我的微信: [object Object]" data-position="top" data-delay="50"><i class="fa fa-weixin"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script src="/js/search.js"></script><script type="text/javascript">$(function(){searchFunc("/search.xml","searchInput","searchResult")})</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fa fa-angle-up"></i></a></div><script src="/libs/materialize/materialize.min.js"></script><script src="/libs/masonry/masonry.pkgd.min.js"></script><script src="/libs/aos/aos.js"></script><script src="/libs/scrollprogress/scrollProgress.min.js"></script><script src="/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="/js/matery.js"></script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?3a39d92b69933ae56c7eb41ffb9aa2e0";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js",(e=document.getElementsByTagName("script")[0]).parentNode.insertBefore(t,e)}()</script><script async src="/libs/others/busuanzi.pure.mini.js"></script><script type="text/javascript">var st,OriginTitile=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="(oﾟvﾟ)ノ Hi",clearTimeout(st)):(document.title="(*´∇｀*) 欢迎回来！",st=setTimeout(function(){document.title=OriginTitile},3e3))})</script><script type="text/javascript" color="0,0,255" pointcolor="0,0,255" opacity="0.8" zindex="-1" count="150" src="/libs/background/canvas-nest.js"></script><script src="/libs/instantpage/instantpage.js" type="module"></script><script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script><script>const hasAttr = (e,a) => a.some(_=> e.attr(_)!==undefined);
        $('a').each(function() {
          const $this = $(this);
          if(hasAttr($this,["data-fancybox","ignore-external-link"])) return;
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== '' || window.location.host) {
                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":150,"height":200},"mobile":{"show":false},"react":{"opacity":0.7}});</script></body></html>