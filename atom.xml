<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JoyTsing</title>
  
  <subtitle>深海</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://joytsing.github.io/"/>
  <updated>2024-07-10T07:47:53.881Z</updated>
  <id>https://joytsing.github.io/</id>
  
  <author>
    <name>JoyTsing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>本站dp容灾切换与智能全局流量管理地址池踩坑</title>
    <link href="https://joytsing.github.io/posts/33051/"/>
    <id>https://joytsing.github.io/posts/33051/</id>
    <published>2024-07-09T08:16:03.000Z</published>
    <updated>2024-07-10T07:47:53.881Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本站其实有段时间一直存在登不上去的问题,其实我百分百可以确定dns的问题，之前弄了个负载均衡和容灾切换，导致疯狂给我短信加邮箱轰炸，最近来排查一下。</p><p><img src="/posts/33051/image-20240710150852127.png" alt></p><h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><h3 id="dns查询"><a href="#dns查询" class="headerlink" title="dns查询"></a>dns查询</h3><p><img src="/posts/33051/image-20240710151541682.png" alt></p><h3 id="腾讯云工具排查"><a href="#腾讯云工具排查" class="headerlink" title="腾讯云工具排查"></a>腾讯云工具排查</h3><ul><li>Edge-One排查</li></ul><p><img src="/posts/33051/0cfe1d8e35022be1cdcc14ba2afa1fd7.png" alt></p><ul><li>云解析DNS排查：</li></ul><p><img src="/posts/33051/image-20240710153209925.png" alt></p><ul><li>Edge-one DNS解析：</li></ul><p><img src="/posts/33051/image-20240710153956501.png" alt></p><p>发现6月28号到7月4号这段时间是没有解析的，我猜测那段时间里面用的是源站的访问，但是显然和报警的时间是对不上的，因为报警的时间段是从7月4号开始。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>可以看到基本上确定是dns解析有问题了，这里解释一下本站的工作原理，源站是github.io，然后购买了joytisng.cn的域名，把github.io投射到了.cn域名上，然后又购买了Edge One给joytisng.cn又上了一层缓存加速访问，可以确定基本上是这里出现问题了。</p><p><img src="/posts/33051/image-20240710151756142.png" alt></p><p>同时试着查询github的解析，发现同样不行。</p><p><img src="/posts/33051/image-20240710152718798.png" alt></p><p>查看一下报警策略：</p><p><img src="/posts/33051/image-20240710153458221.png" alt></p><p>目前把报警策略开到了最多，之前疯狂报警是因为在设置负载均衡的时候添加了源站作为地址池，但是显然国内一般来说是很难访问得到github page的，所以会集中在一段时间内疯狂报错。</p><p>总的来说目前先这样吧，暂时按照Edge-One排查结果新增添了一个cname解析，等待后面实际情况吧。</p><p><img src="/posts/33051/image-20240710154257314.png" alt></p><p><img src="/posts/33051/image-20240710154349610.png" alt="解析不稳定"></p><p>尝试把源站暂停解析会如何，减少一层中转能否提高速度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;本站其实有段时间一直存在登不上去的问题,其实我百分百可以确定dns的问题，之前弄了个负载均衡和容灾切换，导致疯狂给我短信加邮箱轰炸，最近来排
      
    
    </summary>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Cpp静态初始化与lambda表达式的结合</title>
    <link href="https://joytsing.github.io/posts/55793/"/>
    <id>https://joytsing.github.io/posts/55793/</id>
    <published>2024-07-09T08:14:44.000Z</published>
    <updated>2024-07-10T08:07:57.363Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>全局变量初始化新姿势。</p><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>Lambda表达式是C++11引入的一个强大特性，它允许开发者在需要时定义匿名函数。Lambda表达式通常用于需要一个小型函数的地方，但又不想为此编写一个完整的函数定义。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>Lambda表达式的一般语法如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">[</span>capture<span class="token punctuation">]</span> <span class="token punctuation">(</span>parameters<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> return_type <span class="token punctuation">{</span> function_body <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>[capture]</code>：捕获子句，可以捕获外部作用域的变量。</li><li><code>(parameters)</code>：参数列表，可以是空的，表示lambda没有参数。</li><li><code>-&gt; return_type</code>：返回类型，可以省略，由编译器根据函数体推断。</li><li><code>{ function_body }</code>：函数体。</li></ul><h3 id="捕获子句"><a href="#捕获子句" class="headerlink" title="捕获子句"></a>捕获子句</h3><p>Lambda可以捕获外部作用域的变量，捕获方式有：</p><ul><li>值捕获：<code>[capture_value]</code>，将捕获的变量复制到lambda内部。</li><li>引用捕获：<code>[&amp;capture_ref]</code>，将捕获的变量作为引用。</li><li>隐式捕获：<code>[=]</code>表示按值捕获所有外部变量，<code>[&amp;]</code>表示按引用捕获。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">auto</span> lambda <span class="token operator">=</span> <span class="token punctuation">[</span>value<span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> value <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="逗号表达式"><a href="#逗号表达式" class="headerlink" title="逗号表达式"></a>逗号表达式</h2><p>逗号运算符允许在一个表达式中执行多个表达式，并且返回最后一个表达式的结果。这在需要执行一系列操作，但只关心最后一个操作结果时非常有用。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>逗号表达式的语法如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp">expression1 <span class="token punctuation">,</span> expression2 <span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">,</span> expressionN<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>每个<code>expression</code>都可以是任何有效的表达式。</li></ul><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>逗号表达式常用于初始化多个变量或在循环中更新多个循环控制变量。</p><h2 id="如何初始化"><a href="#如何初始化" class="headerlink" title="如何初始化"></a>如何初始化</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">int</span> abc<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//code here</span><span class="token punctuation">}</span><span class="token operator">-</span><span class="token operator">></span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//init value</span>    <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>逗号左边的表达式是一个lambda表达式 <code>([]{})</code>，它被立即调用 <code>([]{})()</code>，返回值是 <code>void</code>是因为在C++中，<code>void</code> 类型的表达式在序列点上（比如逗号运算符的左边）会被隐式转换为 <code>0</code>。逗号右边的表达式 <code>0</code> 是一个整数值。</p><p>因此，整个初始化表达式 <code>([]{}(), 0)</code> 实际上是执行了lambda表达式，然后返回了 <code>0</code>。由于 <code>static int abc</code> 需要一个整数值进行初始化，所以最终 <code>abc</code> 被初始化为 <code>0</code>。这种写法在某些情况下可以用于确保某个表达式被执行，即使它的结果不会被使用，比如用于调用一个函数以执行其副作用，然后使用逗号运算符来提供一个用于初始化的值。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">int</span> abc <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token keyword">int</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 这里 abc 将被初始化为 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>为什么用的static，因为实际上在应用场景里面是帮助我们在main函数前使用，用staic可以省略额外去定义一个结构体或者类，然后在构造函数里面这些函数。但是他也并不是没有缺点的，比如如果是进行资源的初始化工作，那么这种写法只能帮助我们在main前面执行，而并不能帮助我们再main函数之后再执行回收工作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;全局变量初始化新姿势。&lt;/p&gt;
&lt;h2 id=&quot;Lambda表达式&quot;&gt;&lt;a href=&quot;#Lambda表达式&quot; class=&quot;headerl
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>如何用函数式编程实现信号槽</title>
    <link href="https://joytsing.github.io/posts/9176/"/>
    <id>https://joytsing.github.io/posts/9176/</id>
    <published>2024-06-24T16:25:34.000Z</published>
    <updated>2024-06-25T07:43:11.916Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>信号槽是 Qt 框架中用于对象间通信的一种方式。这种机制允许对象在发生特定事件时发出信号，而其他对象可以连接这些信号并提供相应的处理函数（槽），以响应这些事件。有一种熟悉的感觉对不对，其实类似于事件驱动编程，现在让我们看看如何实现。</p><h2 id="核心概念和用途"><a href="#核心概念和用途" class="headerlink" title="核心概念和用途"></a>核心概念和用途</h2><ol><li><strong>事件驱动的通信</strong>：Qt 的信号和槽允许对象在发生特定事件时发出通知（信号），并由其他对象响应这些事件（槽）。</li><li><strong>回调的注册与触发</strong>：在 Qt 中，你可以使用 <code>connect</code> 来注册槽函数，使用 <code>emit</code> 来触发信号。</li><li><strong>参数传递</strong>：Qt 的信号可以带有参数，这些参数会传递给槽函数。</li><li><strong>动态行为</strong>：Qt 的信号和槽机制是动态的，可以在运行时连接和断开。</li><li><strong>生命周期管理</strong>：Qt 信号和槽机制可以处理对象的生命周期，例如使用 <code>QObject</code> 的子类。我们可以通过 <code>std::weak_ptr</code> 来处理可能的对象生命周期问题，防止回调尝试访问已经销毁的对象。</li><li><strong>灵活性和通用性</strong>：Qt 的信号和槽非常灵活，可以连接任何可调用的对象。也提供了类似的灵活性，允许连接函数、lambda 表达式、bind 表达式等。</li><li><strong>回调的执行策略</strong>：Qt 中的槽可以是排队的或直接的，可以根据需要选择。</li></ol><h2 id="用Cpp标准实现"><a href="#用Cpp标准实现" class="headerlink" title="用Cpp标准实现"></a>用Cpp标准实现</h2><h3 id="函数成员"><a href="#函数成员" class="headerlink" title="函数成员"></a>函数成员</h3><p>在此之前首先介绍一下封装的函数成员：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">CallbackResult</span> <span class="token punctuation">{</span>    Keep<span class="token punctuation">,</span>    Erase<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> __cpp_lib_move_only_function </span><span class="token comment" spellcheck="true">// standard feature-test macro</span>    <span class="token keyword">using</span> Functor <span class="token operator">=</span> std<span class="token operator">::</span>move_only_function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span>T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">else</span></span>    <span class="token keyword">using</span> Functor <span class="token operator">=</span> std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token function">CallbackResult</span><span class="token punctuation">(</span>T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>Functor<span class="token operator">></span> m_callbacks<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的 <code>Functor</code> 类型有两个可能的定义：</p><ol><li><strong>如果支持 <code>std::move_only_function</code></strong>（C++23 引入）:<ul><li>使用 <code>std::move_only_function</code> 作为 <code>Functor</code> 类型。<code>std::move_only_function</code> 是 C++23 新引入的类型，用于存储只可移动的函数对象。它的优势在于，一旦被移动，源对象将不再可用，这有助于避免悬垂引用等问题。</li><li>这里的 <code>std::move_only_function</code> 模板使用 <code>void(T...)</code> 作为参数，表示回调函数没有返回值，接受 <code>T...</code> 类型的参数列表。</li></ul></li><li><strong>如果不支持 <code>std::move_only_function</code></strong>:<ul><li>回退到使用 <code>std::function</code> 作为 <code>Functor</code> 类型。<code>std::function</code> 是一个通用的多态函数包装器，它可以存储、调用和复制任何可调用对象，其签名与模板参数给定的签名匹配。</li><li>这里的 <code>std::function</code> 模板使用 <code>CallbackResult(T...)</code> 作为参数，表示回调函数返回 <code>CallbackResult</code> 类型，接受 <code>T...</code> 类型的参数列表。</li></ul></li></ol><p><code>Functor</code> 类型在 <code>Signal</code> 类模板中用于：</p><ul><li>存储回调函数，允许 <code>Signal</code> 对象在 <code>emit</code> 被调用时执行这些回调。</li><li>提供类型安全和灵活性，允许存储任何匹配签名的可调用对象。</li></ul><h3 id="Tag类"><a href="#Tag类" class="headerlink" title="Tag类"></a>Tag类</h3><p>保证强类型安全。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">inline</span> <span class="token keyword">constexpr</span> <span class="token keyword">struct</span> once_flag_t <span class="token punctuation">{</span>    <span class="token keyword">explicit</span> <span class="token function">once_flag_t</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span><span class="token punctuation">}</span> once_flag<span class="token punctuation">;</span><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">nth_flag_t</span> <span class="token operator">:</span> size_t <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h3><p>这里展示的是最终重载的版本，对于<code>connect</code>函数，提供了灵活的方式来注册不同类型的回调函数，无论是独立的函数还是对象的成员函数，都可以很容易地连接到 <code>Signal</code> 对象上。</p><h4 id="1-接受可调用对象的-connect-函数模板"><a href="#1-接受可调用对象的-connect-函数模板" class="headerlink" title="1. 接受可调用对象的 connect 函数模板"></a>1. 接受可调用对象的 <code>connect</code> 函数模板</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Func</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">connect</span><span class="token punctuation">(</span>Func cb<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>is_invocable_r_v<span class="token operator">&lt;</span>CallbackResult<span class="token punctuation">,</span> Func<span class="token punctuation">,</span> T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果回调的返回类型是 CallbackResult，直接添加到回调列表</span>        m_callbacks<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>is_invocable_r_v<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">,</span> Func<span class="token punctuation">,</span> T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果回调的返回类型是 bool，包装回调使其返回 CallbackResult 类型</span>        m_callbacks<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">[</span>ca <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ca</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> CallbackResult<span class="token operator">::</span>Erase<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> CallbackResult<span class="token operator">::</span>Keep<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 默认情况，假设回调不需要特殊处理返回值</span>        m_callbacks<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">[</span>ca <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">ca</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> CallbackResult<span class="token operator">::</span>Keep<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>这个 <code>connect</code> 函数接受一个可调用对象 <code>cb</code>，例如函数、lambda 表达式或 <code>std::function</code> 对象。</li><li>它使用 <code>if constexpr</code> 和 <code>std::is_invocable_r_v</code> 来检查 <code>cb</code> 的返回类型是否为 <code>CallbackResult</code> 或 <code>bool</code>。<ul><li>如果返回类型是 <code>CallbackResult</code>，直接将 <code>cb</code> 移动到回调列表 <code>m_callbacks</code> 中。</li><li>如果返回类型是 <code>bool</code>，创建一个新的 lambda 表达式，它调用原始回调 <code>ca</code> 并根据 <code>ca</code> 的返回值转换为 <code>CallbackResult</code> 类型。</li><li>如果回调的返回类型既不是 <code>CallbackResult</code> 也不是 <code>bool</code>，则假设回调不需要处理返回值，并创建一个新的 lambda 表达式，它调用原始回调并返回 <code>CallbackResult::Keep</code>。</li></ul></li></ul><h4 id="2-接受成员函数和对象的-connect-函数模板"><a href="#2-接受成员函数和对象的-connect-函数模板" class="headerlink" title="2. 接受成员函数和对象的 connect 函数模板"></a>2. 接受成员函数和对象的 <code>connect</code> 函数模板</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Self</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">MemFn</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Tag<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">connect</span><span class="token punctuation">(</span>Self self<span class="token punctuation">,</span> MemFn mem_fn<span class="token punctuation">,</span> Tag<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    m_callbacks<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>detail_<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">,</span> mem_fn<span class="token punctuation">,</span> tag<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>这个 <code>connect</code> 函数接受一个对象 <code>self</code>、一个成员函数指针 <code>mem_fn</code> 和一些标签参数 <code>Tag...</code>。</li><li>它使用 <code>detail_::bind</code> 函数来创建一个绑定到成员函数的回调，并将这个回调添加到回调列表 <code>m_callbacks</code> 中。</li><li><code>detail_::bind</code> 根据传入的标签参数 <code>Tag...</code> 创建不同类型的绑定，例如一次性执行或按次数执行的回调。</li></ul><p>这两个 <code>connect</code> 函数模板提供了灵活的方式来注册不同类型的回调函数，无论是独立的函数还是对象的成员函数。</p><h3 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h3><p>bind可以说是整个函数的灵魂，它的作用是创建一个闭包（通常是 lambda 表达式），该闭包在被调用时，会调用与某个对象相关联的成员函数。这个 <code>bind</code> 函数有几个重载版本，用于不同的绑定场景，比如一次性调用、按次数调用，以及处理弱引用（<code>std::weak_ptr</code>）的情况。</p><p>首先是关于weak_ptr的判断：</p><pre class="line-numbers language-cpp"><code class="language-cpp">    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Self</span><span class="token operator">></span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Self<span class="token operator">></span> <span class="token function">lock_if_weak</span><span class="token punctuation">(</span>std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span>Self<span class="token operator">></span> <span class="token keyword">const</span> <span class="token operator">&amp;</span>self<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Self</span><span class="token operator">></span>    Self <span class="token keyword">const</span> <span class="token operator">&amp;</span><span class="token function">lock_if_weak</span><span class="token punctuation">(</span>Self <span class="token keyword">const</span> <span class="token operator">&amp;</span>self<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> self<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-一次性调用的-bind-函数模板"><a href="#1-一次性调用的-bind-函数模板" class="headerlink" title="1. 一次性调用的 bind 函数模板"></a>1. 一次性调用的 <code>bind</code> 函数模板</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Self</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">MemFn</span><span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">bind</span><span class="token punctuation">(</span>Self self<span class="token punctuation">,</span> MemFn mem_fn<span class="token punctuation">,</span> once_flag_t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span>self <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">,</span> mem_fn<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">auto</span> <span class="token keyword">const</span> <span class="token operator">&amp;</span>ptr <span class="token operator">=</span> <span class="token function">lock_if_weak</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> CallbackResult<span class="token operator">::</span>Erase<span class="token punctuation">;</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token operator">*</span>mem_fn<span class="token punctuation">)</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> CallbackResult<span class="token operator">::</span>Erase<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>这个版本接受一个 <code>Self</code> 类型的对象 <code>self</code>，一个成员函数指针 <code>MemFn</code>，以及一个 <code>once_flag_t</code> 类型的标记。</li><li>创建的闭包在第一次调用时会执行成员函数，然后返回 <code>CallbackResult::Erase</code>，表示这个回调应该从回调列表中删除。</li></ul><h4 id="2-按次数调用的-bind-函数模板"><a href="#2-按次数调用的-bind-函数模板" class="headerlink" title="2. 按次数调用的 bind 函数模板"></a>2. 按次数调用的 <code>bind</code> 函数模板</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Self</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">MemFn</span><span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">bind</span><span class="token punctuation">(</span>Self self<span class="token punctuation">,</span> MemFn mem_fn<span class="token punctuation">,</span> nth_flag_t nth<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span>self <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">,</span> mem_fn<span class="token punctuation">,</span>            nth <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>nth<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token keyword">mutable</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nth <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> CallbackResult<span class="token operator">::</span>Erase<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">auto</span> <span class="token keyword">const</span> <span class="token operator">&amp;</span>ptr <span class="token operator">=</span> <span class="token function">lock_if_weak</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> CallbackResult<span class="token operator">::</span>Erase<span class="token punctuation">;</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token operator">*</span>mem_fn<span class="token punctuation">)</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nth<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nth <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> CallbackResult<span class="token operator">::</span>Erase<span class="token punctuation">;</span>        <span class="token keyword">return</span> CallbackResult<span class="token operator">::</span>Keep<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>这个版本接受一个 <code>Self</code> 类型的对象 <code>self</code>，一个成员函数指针 <code>MemFn</code>，以及一个 <code>nth_flag_t</code> 类型的参数，表示回调应该被调用的次数。</li><li>创建的闭包会根据 <code>nth</code> 参数的值来决定是否继续保留回调。每次调用时，<code>nth</code> 都会减一，当 <code>nth</code> 减到 0 或以下时，回调会被删除。</li></ul><h4 id="3-常规-bind-函数模板"><a href="#3-常规-bind-函数模板" class="headerlink" title="3. 常规 bind 函数模板"></a>3. 常规 <code>bind</code> 函数模板</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Self</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">MemFn</span><span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">bind</span><span class="token punctuation">(</span>Self self<span class="token punctuation">,</span> MemFn mem_fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span>self <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">,</span> mem_fn<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">auto</span> <span class="token keyword">const</span> <span class="token operator">&amp;</span>ptr <span class="token operator">=</span> <span class="token function">lock_if_weak</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> CallbackResult<span class="token operator">::</span>Erase<span class="token punctuation">;</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token operator">*</span>mem_fn<span class="token punctuation">)</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> CallbackResult<span class="token operator">::</span>Keep<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>这是最基本的 <code>bind</code> 版本，接受一个 <code>Self</code> 类型的对象 <code>self</code> 和一个成员函数指针 <code>MemFn</code>。</li><li>创建的闭包在每次调用时都会执行成员函数，并返回 <code>CallbackResult::Keep</code>，表示回调应该保留在回调列表中。</li></ul><h4 id="通用特性"><a href="#通用特性" class="headerlink" title="通用特性"></a>通用特性</h4><ul><li>所有 <code>bind</code> 函数模板都会创建一个 lambda 表达式，该表达式捕获 <code>self</code> 和 <code>mem_fn</code>。</li><li><code>self</code> 可能是一个 <code>std::weak_ptr</code>，<code>lock_if_weak</code> 函数用于尝试获取一个强引用（<code>std::shared_ptr</code>）。</li><li>如果 <code>lock_if_weak</code> 返回 <code>nullptr</code>，表示原始对象已经被销毁，回调应该被删除。</li><li>成员函数通过 <code>((*ptr).*mem_fn)(args...)</code> 语法调用，<code>args...</code> 是传递给闭包的参数，使用 <code>std::forward</code> 来保持它们的值类别（左值或右值）。</li></ul><p><code>bind</code> 函数的目的是将成员函数与对象绑定，创建一个可以存储在 <code>Signal</code> 类中的回调。这允许 <code>Signal</code> 类的用户将成员函数作为回调连接到信号上，而不必担心对象的生命周期问题。</p><h4 id="为什么按指捕获"><a href="#为什么按指捕获" class="headerlink" title="为什么按指捕获"></a>为什么按指捕获</h4><p>按值捕获（value capture）意味着 lambda 表达式会复制捕获的变量到其闭包环境中。这与按引用捕获（reference capture）相对，后者仅捕获对原始变量的引用。</p><ul><li><strong>对象的生命周期管理</strong></li></ul><p>使用按值捕获对于对象的生命周期管理至关重要，尤其是当捕获 <code>std::weak_ptr</code> 时：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> <span class="token function">bind</span><span class="token punctuation">(</span>Self self<span class="token punctuation">,</span> MemFn mem_fn<span class="token punctuation">,</span> nth_flag_t nth<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span>self <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">,</span> mem_fn<span class="token punctuation">,</span> nth<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ...</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里，<code>self</code> 是按值捕获的，这意味着 <code>std::weak_ptr</code> 被移动到 lambda 表达式中，并存储为一个局部变量。当 lambda 被调用时，它尝试通过 <code>lock_if_weak</code> 获取一个 <code>std::shared_ptr</code>。如果 <code>self</code> 已经无效（即原始对象已经被销毁），则 <code>lock</code> 将返回 <code>nullptr</code>，这时 lambda 可以决定不执行成员函数或执行一些清理工作。</p><ul><li><strong>避免悬空引用</strong></li></ul><p>按值捕获避免了悬空引用的问题。如果使用按引用捕获，lambda 将直接引用 <code>self</code>，如果 <code>self</code> 在 lambda 调用之前被销毁，那么 lambda 中的引用将变成悬空引用，这可能导致未定义行为。</p><ul><li><strong>确保数据的独立性</strong></li></ul><p>按值捕获确保了每个 lambda 表达式实例拥有其捕获变量的独立副本。这在多线程环境中特别重要，因为它避免了因多个线程访问同一资源而导致的数据竞争问题。</p><ul><li><strong>可移动性</strong></li></ul><p>使用 <code>std::move</code> 与按值捕获结合使用，可以确保资源（如智能指针）的所有权在捕获时被转移给 lambda，而不是共享。这有助于防止资源的意外复制或多次释放。</p><ul><li><strong>模板参数的灵活性</strong></li></ul><p>在模板编程中，按值捕获提供了更大的灵活性，因为模板可以处理不同类型的参数，包括那些没有默认构造函数或不能被复制的类型。在下面这个示例中，通过按值捕获 <code>std::shared_ptr</code> 来避免悬空引用，并且 <code>weakSelf</code> 只在 lambda 内部有效。总之，按值捕获在 <code>signal.h</code> 中的 <code>bind</code> 函数模板中用于确保 lambda 表达式安全地处理可能具有复杂生命周期的对象，同时保持代码的简洁性和灵活性。</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span>SomeClass<span class="token operator">></span> weakPtr <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token keyword">auto</span> callback <span class="token operator">=</span> <span class="token punctuation">[</span>weakSelf <span class="token operator">=</span> weakPtr<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>weakSelf<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 使用 weakSelf 做一些操作</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="模板函数省略的版本"><a href="#模板函数省略的版本" class="headerlink" title="模板函数省略的版本"></a>模板函数省略的版本</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 避免重复声明多个版本</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Self</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">MemFn</span><span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">bind_once</span><span class="token punctuation">(</span>Self self<span class="token punctuation">,</span> MemFn mem_fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span>self <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">,</span> mem_fn<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>self<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token operator">*</span>mem_fn<span class="token punctuation">)</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> CallbackResult<span class="token operator">::</span>Erase<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Self</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">MemFn</span><span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">bind_nth</span><span class="token punctuation">(</span>Self self<span class="token punctuation">,</span> MemFn mem_fn<span class="token punctuation">,</span> size_t nth <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span>self <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">,</span> mem_fn<span class="token punctuation">,</span> nth<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token keyword">mutable</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nth <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> CallbackResult<span class="token operator">::</span>Erase<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>self<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token operator">*</span>mem_fn<span class="token punctuation">)</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nth<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nth <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> CallbackResult<span class="token operator">::</span>Erase<span class="token punctuation">;</span>        <span class="token keyword">return</span> CallbackResult<span class="token operator">::</span>Keep<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Self</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">MemFn</span><span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">bind</span><span class="token punctuation">(</span>std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span>Self<span class="token operator">></span> self<span class="token punctuation">,</span> MemFn mem_fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span>self <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">,</span> mem_fn<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">auto</span> ptr <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> CallbackResult<span class="token operator">::</span>Erase<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token operator">*</span>mem_fn<span class="token punctuation">)</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> CallbackResult<span class="token operator">::</span>Keep<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Self</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">MemFn</span><span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">connect_once</span><span class="token punctuation">(</span>Self self<span class="token punctuation">,</span> MemFn mem_fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>     m_callbacks<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">bind_once</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">,</span> mem_fn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Self</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">MemFn</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">connect_nth</span><span class="token punctuation">(</span>Self self<span class="token punctuation">,</span> MemFn mem_fn<span class="token punctuation">,</span> size_t nth <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    m_callbacks<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">bind_nth</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">,</span> mem_fn<span class="token punctuation">,</span> nth<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Self</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">MemFn</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">connect_weak</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Self<span class="token operator">></span> self<span class="token punctuation">,</span> MemFn mem_fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>    m_callbacks<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">bind</span><span class="token punctuation">(</span>std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span>Self<span class="token operator">></span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">,</span> mem_fn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;信号槽是 Qt 框架中用于对象间通信的一种方式。这种机制允许对象在发生特定事件时发出信号，而其他对象可以连接这些信号并提供相应的处理函数（槽
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>使用std::variant实现非虚运行时多态实现</title>
    <link href="https://joytsing.github.io/posts/63582/"/>
    <id>https://joytsing.github.io/posts/63582/</id>
    <published>2024-06-23T15:28:16.000Z</published>
    <updated>2024-06-23T15:45:08.239Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>C++中常用的多态方案是基于虚函数的运行时多态方案，但是在一些要求高性能场景（或者有些强迫症），性能并不怎么好，因为涉及到查虚表跳转，寻址，还有一些更深层次的原因。性能表现不怎么好函。C++17提出了另一种运行时多态方案,基于<code>std::variant</code>的方案。</p><h2 id="std-variant"><a href="#std-variant" class="headerlink" title="std::variant"></a>std::variant</h2><p>本质上是通过<code>std::variant</code>提供了一种类型安全的联合容器，可以存储不同类型的值，类似于 C 语言中的联合体（union），但具有更强的类型安全性和语法支持。<code>std::variant</code> 的特点和用法如下：</p><ol><li>存储多种类型的值：<code>std::variant</code> 可以存储一组预定义的类型，这些类型可以是基本类型（例如整数、浮点数）、自定义的类类型、指针等。</li><li>类型安全：在编译时，<code>std::variant</code> 会对可能存储的值进行类型检查，不允许存储超出预定义类型范围的值。这提供了更好的类型安全性，避免了潜在的类型错误。</li><li>轻量高效：<code>std::variant</code> 的内存占用只有存储值的最大成员所需的内存大小，没有额外的空间开销。同时，由于类型是静态确定的，不需要运行时的类型信息，因此执行效率较高。</li><li>支持访问和操作：可以使用 <code>std::get</code> 函数或 <code>std::visit</code> 函数来访问和操作 <code>std::variant</code> 中的值。<code>std::get</code> 可以直接获取特定类型的值，而 <code>std::visit</code> 可以通过访问器（visitor）函数来执行对应类型的操作。</li><li>支持默认构造和拷贝：<code>std::variant</code> 支持默认构造、拷贝构造和赋值操作，以及其他与值类型相关的操作，如移动构造和析构函数等。</li></ol><p>我们可以使用<code>std::get</code>来从<code>std::variant</code>中提取出真实的对象，前提是类型是匹配的（否则抛出异常）。<code>std::get_if</code>与<code>std::get</code>功能类似，区别是<code>std::get_if</code>接收指针并且返回指针（类型不匹配返回<code>std::nullptr</code>）。</p><h2 id="std-visit"><a href="#std-visit" class="headerlink" title="std::visit"></a>std::visit</h2><p><code>std::visit</code> 是 C++17 引入的标准库函数，用于访问 <code>std::variant</code> 中存储的值。它提供了一种统一的方式来处理 <code>std::variant</code> 的不同类型成员，允许我们根据成员类型执行相应的操作，<code>std::visit</code> 的基本语法：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span><span class="token function">visit</span><span class="token punctuation">(</span>visitor<span class="token punctuation">,</span> variant<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，<code>visitor</code> 是一个可调用对象，可以是函数指针、函数对象、Lambda 表达式等，用于指定不同类型的访问操作。<code>variant</code> 是要访问的 <code>std::variant</code> 对象。<code>std::visit</code> 的工作原理如下：</p><ol><li>首先，<code>std::visit</code> 会根据传入的 <code>variant</code> 对象，确定当前存储的成员类型。</li><li>然后，它会根据成员类型，选择合适的访问操作，即调用与当前成员类型相匹配的访问器。</li><li>最后，它会将当前成员的值作为参数传递给访问器，并执行相应的操作。</li></ol><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="基础实现"><a href="#基础实现" class="headerlink" title="基础实现"></a>基础实现</h3><p>我们的最终目标是声明和实现的分离，同时要能够做到同步（保证修改支持的多态种类时能够少修改源文件），具有的头文件有：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>variant<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">></span> <span class="token operator">&amp;</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在源文件中我们使用对应的visit就能够快捷访问了：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>variant<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">></span> <span class="token operator">&amp;</span>v<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span><span class="token function">visit</span><span class="token punctuation">(</span>        <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;&amp;</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">using</span> T <span class="token operator">=</span> std<span class="token operator">::</span>decay_t<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>is_same_v<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> T<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"int: "</span> <span class="token operator">&lt;&lt;</span> t <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>is_same_v<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token punctuation">,</span> T<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"double: "</span> <span class="token operator">&lt;&lt;</span> t <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>is_same_v<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> T<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"string: "</span> <span class="token operator">&lt;&lt;</span> t <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** equal to the above code    auto visitor = [](auto arg) {        std::cout &lt;&lt; arg &lt;&lt; std::endl;    };    if (std::holds_alternative&lt;int>(v)) {        visitor(std::get&lt;int>(v));    } else if (std::holds_alternative&lt;double>(v)) {        visitor(std::get&lt;double>(v));    } else if (std::holds_alternative&lt;std::string>(v)) {        visitor(std::get&lt;std::string>(v));    }    **/</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="进阶实现"><a href="#进阶实现" class="headerlink" title="进阶实现"></a>进阶实现</h3><p>可以发现基础实现的编码是比较死的，其次当我们将<code>std::variant</code>里的参数修改时，会发现提示参数不匹配，这个问题其实是很严重的，能不能像之前利用宏函数转化<code>enum</code>一样实现呢？</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> Object <span class="token operator">=</span> std<span class="token operator">::</span>variant<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">,</span> std<span class="token operator">::</span>string<span class="token operator">></span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">add_object</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">print_objects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>首先使用类型别名简化我们的输入，重点在于实现上，利用模板元编程来展开进行循环：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">V</span><span class="token operator">></span><span class="token keyword">struct</span> variant_to_tuple_of_vector<span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span><span class="token keyword">struct</span> variant_to_tuple_of_vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>variant<span class="token operator">&lt;</span>Ts<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">>></span> <span class="token punctuation">{</span>    <span class="token keyword">using</span> type <span class="token operator">=</span> std<span class="token operator">::</span>tuple<span class="token operator">&lt;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>Ts<span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span>size_t N<span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Lambda</span><span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">static_for</span><span class="token punctuation">(</span>Lambda <span class="token operator">&amp;&amp;</span>lambda<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>size_t<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Is<span class="token operator">></span><span class="token punctuation">(</span>std<span class="token operator">::</span>index_sequence<span class="token operator">&lt;</span>Is<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">lambda</span><span class="token punctuation">(</span>std<span class="token operator">::</span>integral_constant<span class="token operator">&lt;</span>size_t<span class="token punctuation">,</span> Is<span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_index_sequence<span class="token operator">&lt;</span>N<span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span>size_t N<span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Lambda</span><span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">static_for_break_if_false</span><span class="token punctuation">(</span>Lambda <span class="token operator">&amp;&amp;</span>lambda<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>size_t<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Is<span class="token operator">></span><span class="token punctuation">(</span>std<span class="token operator">::</span>index_sequence<span class="token operator">&lt;</span>Is<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">lambda</span><span class="token punctuation">(</span>std<span class="token operator">::</span>integral_constant<span class="token operator">&lt;</span>size_t<span class="token punctuation">,</span> Is<span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_index_sequence<span class="token operator">&lt;</span>N<span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span>size_t N<span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Lambda</span><span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">static_for_break_if_true</span><span class="token punctuation">(</span>Lambda <span class="token operator">&amp;&amp;</span>lambda<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>size_t<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Is<span class="token operator">></span><span class="token punctuation">(</span>std<span class="token operator">::</span>index_sequence<span class="token operator">&lt;</span>Is<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">lambda</span><span class="token punctuation">(</span>std<span class="token operator">::</span>integral_constant<span class="token operator">&lt;</span>size_t<span class="token punctuation">,</span> Is<span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_index_sequence<span class="token operator">&lt;</span>N<span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> variant_to_tuple_of_vector<span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token operator">::</span>type objects<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 帮助自动识别</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>逻辑其实不复杂，主要是语法上需要理解，利用静态for展开编写我们需要的函数即可。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">add_object</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>    static_for_break_if_false<span class="token operator">&lt;</span>std<span class="token operator">::</span>variant_size_v<span class="token operator">&lt;</span>Object<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> ic<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> ic<span class="token punctuation">)</span> <span class="token punctuation">{</span>            get<span class="token operator">&lt;</span>ic<span class="token operator">></span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>get<span class="token operator">&lt;</span>ic<span class="token operator">></span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">print_objects</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    static_for<span class="token operator">&lt;</span>std<span class="token operator">::</span>variant_size_v<span class="token operator">&lt;</span>Object<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> ic<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token keyword">const</span> <span class="token operator">&amp;</span>o <span class="token operator">:</span> get<span class="token operator">&lt;</span>ic<span class="token operator">></span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> o <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="跟虚函数运行时多态有哪些优缺点"><a href="#跟虚函数运行时多态有哪些优缺点" class="headerlink" title="跟虚函数运行时多态有哪些优缺点"></a>跟虚函数运行时多态有哪些优缺点</h2><p>使用 <code>std::variant</code> 实现动态多态的优点：</p><ol><li>静态类型检查：<code>std::variant</code> 在编译时就确定了可存储的类型，可以在编译阶段进行静态类型检查，减少运行时错误。</li><li>不需要动态内存分配：<code>std::variant</code> 存储对象时，不需要进行动态内存分配，对象直接存储在 <code>std::variant</code> 容器中，避免了频繁的内存分配和释放。</li><li>无需维护虚函数表：<code>std::variant</code> 不需要维护虚函数表，减少了内存开销。</li><li>更高的性能：由于静态类型检查和减少了虚函数调用的开销，<code>std::variant</code> 在某些情况下可以获得更高的性能。</li></ol><p>使用虚函数实现动态多态的优点：</p><ol><li>灵活性：虚函数机制允许在运行时动态绑定函数调用，根据对象的实际类型决定调用哪个函数，提供了更大的灵活性。</li><li>扩展性：可以通过派生类来扩展已有的基类，实现更多的功能，同时仍然保持多态性。</li><li>容易理解和维护：使用虚函数可以直观地表示对象之间的继承关系和多态特性，使代码更易理解和维护。</li></ol><p>如果需要在编译时进行类型检查和消除动态内存分配的开销或者需要更高的性能，可以考虑使用 <code>std::variant</code>。如果需要更大的灵活性和扩展性，以及表达对象继承关系的需求，使用虚函数是更好的选择。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;C++中常用的多态方案是基于虚函数的运行时多态方案，但是在一些要求高性能场景（或者有些强迫症），性能并不怎么好，因为涉及到查虚表跳转，寻址，
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Windows反复蓝屏与dump定位</title>
    <link href="https://joytsing.github.io/posts/61347/"/>
    <id>https://joytsing.github.io/posts/61347/</id>
    <published>2024-06-21T13:28:39.000Z</published>
    <updated>2024-06-29T13:43:49.861Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/posts/61347/a7dcba59b5f76718e42523488cbd0869.png" alt></p><p>从日志上看其实就能发现了，很早之前就出现过这个问题，但是今天出现得特别频繁，实在不能忍了就计划排除一下这个问题。当然我不知道最后有没有顺利解决（之前发生这种情况，都是把电源拔插重新紧紧就好了，那会可能真的是主板问题，但是今天的情况和之前不一样，在5月那次宕机时还专门买了UPS来稳定电压）。</p><h2 id="WinDbg"><a href="#WinDbg" class="headerlink" title="WinDbg"></a>WinDbg</h2><h3 id="dump1"><a href="#dump1" class="headerlink" title="dump1"></a>dump1</h3><p>众所周知，一个程序的coredump是定位问题的关键（今天就深刻感受到了），Windows的coredump文件存储在C盘下的Windows文件夹中，文件名为Minidump。管理员打开WinDbg Preview，按照<strong>File==&gt;Start debugging==&gt;Open dump file==&gt;xxx.dmp</strong>次序打开记录蓝屏故障的dump文件，dump文件将在Command框进行分析，初步分析需要下载符号文件，因此会比较慢。dump文件加载成功后，Command框中将出现如下代码，</p><p><img src="/posts/61347/image-20240621215055702.png" alt></p><p>目前存储了近期的3次dump文件，其余的在清理垃圾的时候给删除了，逐个分析：</p><p><img src="/posts/61347/image-20240621215244936.png" alt></p><p><img src="/posts/61347/image-20240621215306595.png" alt></p><p><img src="/posts/61347/image-20240621215315973.png" alt></p><p>可以发现是wsl2下的docker导致的，但事实上那会我并没有启动docker，也没有启动wsl，所以这个问题是非常奇怪的。但是啊，我发现在事件查看里面充斥着非常多的不兼容报错，最好不要乱升级。</p><p><img src="/posts/61347/image-20240621215710375.png" alt></p><h3 id="dump2"><a href="#dump2" class="headerlink" title="dump2"></a>dump2</h3><p><img src="/posts/61347/image-20240621215805256.png" alt></p><p><img src="/posts/61347/image-20240621215822668.png" alt></p><p>第二个问题是WSL2下的NVIDIA Share.e的问题。</p><h3 id="dump3"><a href="#dump3" class="headerlink" title="dump3"></a>dump3</h3><p><img src="/posts/61347/image-20240621215952630.png" alt></p><p>第三个也是同理。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>基本上可以锁定是NVIDIA的驱动更新后和Windows的WSL API不兼容的问题了，其实这个早有预兆：</p><p><img src="/posts/61347/image-20240621220116392.png" alt></p><p>之前一直能在wsl2下使用的nvitop命令现在无法使用了。</p><p><img src="/posts/61347/image-20240621220231301.png" alt="不要乱升驱动"></p><p>虽然从内核dump上基本上可以确定问题的关键了，但是还有其他奇怪的点，首先wsl是懒加载的，如果我不启动Ubuntu那么相关的服务是不应该运行的，那么为什么会导致我启动后打开网页不久就蓝屏？除了dump外，我发现在反复崩溃重启后我的外置声卡设置恢复了默认情况不可用，于是我怀疑是外置声卡这个硬件与别的设备冲突了，所以把声卡拔掉后就好了（但愿）。</p><p><img src="/posts/61347/aa8005495fd92e1f35ce68395f81e471.png" alt="诱因"></p><h2 id="尝试复现错误"><a href="#尝试复现错误" class="headerlink" title="尝试复现错误"></a>尝试复现错误</h2><p>将wsl关闭后再启动，果然这个调用错误出现了。</p><p><img src="/posts/61347/image-20240621221049683.png" alt></p><p>再试着跑一个深度学习的实验试试调用GPU：</p><p><img src="/posts/61347/image-20240621221022962.png" alt></p><p><img src="/posts/61347/image-20240621221247716.png" alt></p><p>能成功调用，还算个好消息，至少目前先解决蓝屏的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/posts/61347/a7dcba59b5f76718e42523488cbd0869.png&quot; alt&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>类型擦除与Pimpl</title>
    <link href="https://joytsing.github.io/posts/42968/"/>
    <id>https://joytsing.github.io/posts/42968/</id>
    <published>2024-06-21T07:43:30.000Z</published>
    <updated>2024-06-21T13:44:45.020Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>PIMPL</code>是<code>Pointer to IMPLementation</code>的缩写，意思是指向实现的指针。 是一个Cpp独有的设计模式（严格说也不是，是桥接模式的一种特例），该技巧可以避免在头文件中暴露私有细节，同时通过类型擦除的技巧，不必麻烦用户编写继承相关代码，并能包装任意对象，在STL标准库中，这类设施典型的代表就是<code>std::function</code>。</p><p><strong>Cpp语境下的类型擦除，技术上来说，是编写一个类，它提供模板的构造函数和非虚函数接口提供功能；隐藏了对象的具体类型，但保留其行为</strong>。简单地说，就是库作者把面向对象的代码写了，而不是推给用户写。</p><h2 id="Pimpl惯用法"><a href="#Pimpl惯用法" class="headerlink" title="Pimpl惯用法"></a>Pimpl惯用法</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> task_base <span class="token punctuation">{</span>   <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">task_base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>   <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> F<span class="token operator">></span><span class="token keyword">struct</span> task_model <span class="token operator">:</span> <span class="token keyword">public</span> task_base <span class="token punctuation">{</span>    F functor_<span class="token punctuation">;</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> U<span class="token operator">></span> <span class="token comment" spellcheck="true">// 构造函数是函数模板</span>    <span class="token function">task_model</span><span class="token punctuation">(</span>U<span class="token operator">&amp;&amp;</span> f<span class="token punctuation">)</span> <span class="token operator">:</span>      <span class="token function">functor_</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>U<span class="token operator">></span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> override <span class="token punctuation">{</span>        <span class="token function">functor_</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，抽象基类<code>task_base</code>作为公共接口不变；其子类<code>task_model</code>(角色同上文中的<code>task_impl</code>)写成类模板的形式，其把一个任意类型<code>F</code>的函数对象<code>function_</code>作为数据成员。</p><p>子类写成类模板的具体用意是，<strong>对于用户提供的一个任意的类型<code>F</code>，<code>F</code>不需要知道<code>task_base</code>及其继承体系，而只进行语法上的duck typing检查。</strong> 这种方法避免了继承带来的侵入式设计。换句话说，只要能合乎语法地对<code>F</code>调用预先定义的接口，代码就可以编译，这个技巧就能运作。此例中，预先定义的接口是<code>void()</code>，以<code>functor_();</code>的形式调用。</p><p>然后，我们把它包装起来：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">my_task</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>task_base<span class="token operator">></span> ptr_<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> F<span class="token operator">></span>    <span class="token function">my_task</span><span class="token punctuation">(</span>F<span class="token operator">&amp;&amp;</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">using</span> model_type <span class="token operator">=</span> task_model<span class="token operator">&lt;</span>F<span class="token operator">></span><span class="token punctuation">;</span>        ptr_ <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>model_type<span class="token operator">></span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>F<span class="token operator">></span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>        ptr_<span class="token operator">-</span><span class="token operator">></span><span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">// 其他部分略</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="why"><a href="#why" class="headerlink" title="why?"></a>why?</h3><p>首先，初始动机是用一个类型包装不同的函数对象。然后，考虑这些函数对象需要提供的功能（affordance），此处为使用括号运算符进行函数调用。最后，把这个功能抽取为一个接口，此处为<code>my_task</code>，我们在在这一步擦除了对象具体的类型。这便是类型擦除的本质：<strong>切割类型与其行为，使得不同的类型能用同一个接口提供功能。</strong></p><p>对<code>my_task</code>进行简单测试的代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 普通函数</span><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"type erasure 1"</span><span class="token punctuation">;</span><span class="token punctuation">}</span>my_task t1<span class="token punctuation">{</span> <span class="token operator">&amp;</span>foo <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">t1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出"type erasure 1"</span><span class="token comment" spellcheck="true">// 重载括号运算符的类</span><span class="token keyword">struct</span> foo2 <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"type erasure 2"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>my_task t2<span class="token punctuation">{</span> foo2<span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">t2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出"type erasure 2"</span><span class="token comment" spellcheck="true">// Lambda</span>my_task t3<span class="token punctuation">{</span>    <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"type erasure 3"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token function">t3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出"type erasure 3"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接口简洁，类型参数全部由编译器推断，实现了上文中的需求，当然这里只是一个简单的核心概念demo，实际上的实现需要考虑的比这多，比如<strong>自动类型退化，模板构造函数不匹配或者错误的情况，以及怎么配合SFINAE与concepts</strong>都是需要深入的。</p><h3 id="注意的点"><a href="#注意的点" class="headerlink" title="注意的点"></a>注意的点</h3><p>编写一个类型擦除类，当然也离不开编写它的构造函数、赋值函数和析构函数，而其中大部分纠结都可归为<strong>资源所有权</strong>的问题：一个对象是否拥有（own）其资源的生命周期；如果拥有，是唯一还是共享地拥有？支持复制，还是只支持移动？</p><p><code>my_task</code>有一个<code>std::unique_ptr</code>数据成员，这个智能指针拥有具体任务对象的生命周期；而一个任务也没有创造副本的需求。因此，<code>my_task</code>不需支持复制，仅支持移动构造或赋值。</p><p>析构函数的责任是正确地释放资源。<code>my_task</code>使用了智能指针，智能指针会正确地调用<code>delete</code>，所以使用编译器合成的默认析构函数即可，这里强调一下，当手动实现析构函数的时候，一定要自己实现或者删除掉移动构造，否则就会出现二次析构的问题。</p><p><code>task_model</code>的析构函数会递归调用<code>F</code>的析构函数，这依赖于用户正确编写了<code>F</code>的析构函数，因此<code>task_model</code>也用编译器合成的默认析构函数。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="Pimpl优点"><a href="#Pimpl优点" class="headerlink" title="Pimpl优点"></a>Pimpl优点</h3><ul><li><strong>信息隐藏：</strong>实现细节可以隐藏到Impl类实现中，保护闭源API专有性。同时，接口头文件也能更干净、清晰表达真正的公有接口，易于阅读和理解。</li><li><strong>降低耦合：</strong>接口类只用知道Impl类即可，不用包含私有成员变量所需头文件，也不必包含平台依赖的windows.h或sys/time.h。</li><li><strong>加速编译：</strong>将实现相关头文件移入.cpp，API的引用层次降低，会导致编译时间减少。</li><li><strong>更好的二进制兼容性：</strong>采用Pimpl的对象大小从不改变，因为对象总是单个指针大小。对私有成员变量做任何修改，都只影响隐藏在cpp文件内的实现类大小。而对象的二进制表示可以不变。</li><li>惰性分配：Impl类可以在需要时再构造，而不必在接口类构造时立即构造。</li></ul><h3 id="Pimpl的缺点"><a href="#Pimpl的缺点" class="headerlink" title="Pimpl的缺点"></a>Pimpl的缺点</h3><ul><li>必须为你创建的每个对象分配并释放实现对象。这使得对象增加了一个指针（Impl* impl_），同时增加了通过指针访问成员的开销，增加了new和delete对象的开销。_</li><li><em>必须通过impl</em>-&gt;的形式访问私有成员。</li><li>编译器不能捕获接口类中const对成员变量修改。因为成员变量现在存在于独立的对象（impl_指针所指对象）中。编译器仅检查impl_指针是否发生变化，而不会检查其成员。</li></ul><h2 id="实战篇"><a href="#实战篇" class="headerlink" title="实战篇"></a>实战篇</h2><p>假设我们目前有这么几个类：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">pragma</span> once</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">struct</span> MoveMsg <span class="token punctuation">{</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">int</span> y<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Move "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> JumpMsg <span class="token punctuation">{</span>    <span class="token keyword">int</span> height<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Jump "</span> <span class="token operator">&lt;&lt;</span> height <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> SleepMsg <span class="token punctuation">{</span>    <span class="token keyword">int</span> time<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Sleep "</span> <span class="token operator">&lt;&lt;</span> time <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> ExitMsg <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Exit"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在main中，我们需要用使用到多态，但又不能修改源文件，这时候我们就可以使用P-impl，再配合上工厂模式就可以消灭if-else舒服使用了。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> MsgBase <span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">MsgBase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>    <span class="token keyword">using</span> Ptr <span class="token operator">=</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>MsgBase<span class="token operator">></span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">namespace</span> msg_extra_funcs <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 无法为 Msg 们增加成员函数，只能以重载的形式，外挂追加</span>    <span class="token keyword">void</span> <span class="token function">load</span><span class="token punctuation">(</span>MoveMsg <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cin <span class="token operator">>></span> msg<span class="token punctuation">.</span>x <span class="token operator">>></span> msg<span class="token punctuation">.</span>y<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">load</span><span class="token punctuation">(</span>JumpMsg <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cin <span class="token operator">>></span> msg<span class="token punctuation">.</span>height<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">load</span><span class="token punctuation">(</span>SleepMsg <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cin <span class="token operator">>></span> msg<span class="token punctuation">.</span>time<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">load</span><span class="token punctuation">(</span>ExitMsg <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Msg</span><span class="token operator">></span><span class="token keyword">struct</span> MsgImpl <span class="token operator">:</span> MsgBase <span class="token punctuation">{</span>    Msg msg<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        msg<span class="token punctuation">.</span><span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        msg_extra_funcs<span class="token operator">::</span><span class="token function">load</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> MsgFactoryBase <span class="token punctuation">{</span>    <span class="token keyword">virtual</span> MsgBase<span class="token operator">::</span>Ptr <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">MsgFactoryBase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>    <span class="token keyword">using</span> Ptr <span class="token operator">=</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>MsgFactoryBase<span class="token operator">></span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Msg</span><span class="token operator">></span><span class="token keyword">struct</span> MsgFactoryImpl <span class="token operator">:</span> MsgFactoryBase <span class="token punctuation">{</span>    MsgBase<span class="token operator">::</span>Ptr <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        <span class="token keyword">return</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>MsgImpl<span class="token operator">&lt;</span>Msg<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Msg</span><span class="token operator">></span>MsgFactoryBase<span class="token operator">::</span>Ptr <span class="token function">makeFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>MsgFactoryImpl<span class="token operator">&lt;</span>Msg<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">struct</span> RobotClass <span class="token punctuation">{</span>    <span class="token keyword">inline</span> <span class="token keyword">static</span> <span class="token keyword">const</span> std<span class="token operator">::</span>map<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> MsgFactoryBase<span class="token operator">::</span>Ptr<span class="token operator">></span> factories <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token punctuation">{</span><span class="token string">"Move"</span><span class="token punctuation">,</span> makeFactory<span class="token operator">&lt;</span>MoveMsg<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span><span class="token string">"Jump"</span><span class="token punctuation">,</span> makeFactory<span class="token operator">&lt;</span>JumpMsg<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span><span class="token string">"Sleep"</span><span class="token punctuation">,</span> makeFactory<span class="token operator">&lt;</span>SleepMsg<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span><span class="token string">"Exit"</span><span class="token punctuation">,</span> makeFactory<span class="token operator">&lt;</span>ExitMsg<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">recv_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>string type<span class="token punctuation">;</span>        std<span class="token operator">::</span>cin <span class="token operator">>></span> type<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            msg <span class="token operator">=</span> factories<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>out_of_range <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"no such msg type!\n"</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        msg<span class="token operator">-</span><span class="token operator">></span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>msg<span class="token punctuation">)</span>            msg<span class="token operator">-</span><span class="token operator">></span><span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    MsgBase<span class="token operator">::</span>Ptr msg<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    RobotClass <span class="token class-name">robot</span><span class="token punctuation">;</span>    robot<span class="token punctuation">.</span><span class="token function">recv_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    robot<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;code&gt;PIMPL&lt;/code&gt;是&lt;code&gt;Pointer to IMPLementation&lt;/code&gt;的缩写，意思是指向实现的指
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>nvim下的CMake,编译与Debug</title>
    <link href="https://joytsing.github.io/posts/63066/"/>
    <id>https://joytsing.github.io/posts/63066/</id>
    <published>2024-06-15T11:36:19.000Z</published>
    <updated>2024-06-18T12:49:22.020Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>还有更多功能等着探索，首先先把官方文档放在这里：<a href="https://github.com/mfussenegger/nvim-dap/wiki/Debug-Adapter-installation">Debug Adapter installation · mfussenegger/nvim-dap Wiki · GitHub</a></p><p><img src="/posts/63066/3c8c341d022ac6a9e23ad8195e4a6b6b.png" alt></p><h2 id="编译安装gdb14"><a href="#编译安装gdb14" class="headerlink" title="编译安装gdb14"></a>编译安装gdb14</h2><p>安装的时候遇到了3个问题，首先是说<strong>makeinfo: not found</strong>，这个可以直接<code>sudo apt install texinfo</code>，然后是configure的时候提示：</p><p><img src="/posts/63066/ce9831b799fdb8ad9bc023d6ead3a04f.png" alt></p><p>同理也是先把这两个安装完了就行。</p><h2 id="配置nvim-dap"><a href="#配置nvim-dap" class="headerlink" title="配置nvim-dap"></a>配置nvim-dap</h2><p>新建一个文件，<code>～/.config/nvim/lua/plugins/dap.lua</code>，然后加上我们要写的配置：</p><pre class="line-numbers language-lua"><code class="language-lua"><span class="token keyword">return</span> <span class="token punctuation">{</span>  <span class="token punctuation">{</span>    <span class="token string">"mfussenegger/nvim-dap"</span><span class="token punctuation">,</span>    event <span class="token operator">=</span> <span class="token string">"VeryLazy"</span><span class="token punctuation">,</span>    keys <span class="token operator">=</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">-- add a keymap to browshttps://github.com/cmu-db/bustub.gite plhttps://github.com/cmu-db/bustub.gitugin files</span>      <span class="token comment" spellcheck="true">-- stylua: ignore</span>      <span class="token punctuation">{</span>        <span class="token string">"&lt;f5>"</span><span class="token punctuation">,</span>        <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"dap"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">continue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">end</span><span class="token punctuation">,</span>        desc <span class="token operator">=</span> <span class="token string">"launch/continue gdb"</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token string">"&lt;f10>"</span><span class="token punctuation">,</span>        <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"dap"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">step_over</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">end</span><span class="token punctuation">,</span>        desc <span class="token operator">=</span> <span class="token string">"单步调试"</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token string">"&lt;C-f10>"</span><span class="token punctuation">,</span>        <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"dap"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">step_into</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">end</span><span class="token punctuation">,</span>        desc <span class="token operator">=</span> <span class="token string">"步入"</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token string">"&lt;C-f>"</span><span class="token punctuation">,</span>        <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"dap"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">step_out</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">end</span><span class="token punctuation">,</span>        desc <span class="token operator">=</span> <span class="token string">"步出"</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token string">"&lt;C-f5>"</span><span class="token punctuation">,</span>        <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"dap"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">terminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">end</span><span class="token punctuation">,</span>        desc <span class="token operator">=</span> <span class="token string">"终止程序"</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    config <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token keyword">local</span> dap <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"dap"</span><span class="token punctuation">)</span>      dap<span class="token punctuation">.</span>adapters<span class="token punctuation">.</span>gdb <span class="token operator">=</span> <span class="token punctuation">{</span>        type <span class="token operator">=</span> <span class="token string">"executable"</span><span class="token punctuation">,</span>        executable <span class="token operator">=</span> <span class="token punctuation">{</span>          command <span class="token operator">=</span> vim<span class="token punctuation">.</span>fn<span class="token punctuation">.</span><span class="token function">exepath</span><span class="token punctuation">(</span><span class="token string">"gdb"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>          args <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"-i"</span><span class="token punctuation">,</span> <span class="token string">"dap"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span>      dap<span class="token punctuation">.</span>configurations<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token punctuation">{</span>        name <span class="token operator">=</span> <span class="token string">"Launch file"</span><span class="token punctuation">,</span>        type <span class="token operator">=</span> <span class="token string">"gdb"</span><span class="token punctuation">,</span>        request <span class="token operator">=</span> <span class="token string">"launch"</span><span class="token punctuation">,</span>        program <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token keyword">return</span> vim<span class="token punctuation">.</span>fn<span class="token punctuation">.</span><span class="token function">input</span><span class="token punctuation">(</span><span class="token string">"Path to executable: "</span><span class="token punctuation">,</span> vim<span class="token punctuation">.</span>fn<span class="token punctuation">.</span><span class="token function">getcwd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">..</span> <span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token string">"file"</span><span class="token punctuation">)</span>        <span class="token keyword">end</span><span class="token punctuation">,</span>        gdbpath <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token keyword">return</span> <span class="token string">"/usr/bin/gdb"</span>        <span class="token keyword">end</span><span class="token punctuation">,</span>        cwd <span class="token operator">=</span> <span class="token string">"${workspaceFolder}"</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span>    <span class="token keyword">end</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span>    <span class="token string">"rcarriga/nvim-dap-ui"</span><span class="token punctuation">,</span>    dependencies <span class="token operator">=</span> <span class="token punctuation">{</span>      <span class="token string">"mfussenegger/nvim-dap"</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    opts <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token keyword">local</span> dap<span class="token punctuation">,</span> dapui <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"dap"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"dapui"</span><span class="token punctuation">)</span>      dap<span class="token punctuation">.</span>listeners<span class="token punctuation">.</span>before<span class="token punctuation">.</span>attach<span class="token punctuation">.</span>dapui_config <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        dapui<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token keyword">end</span>      dap<span class="token punctuation">.</span>listeners<span class="token punctuation">.</span>before<span class="token punctuation">.</span>launch<span class="token punctuation">.</span>dapui_config <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        dapui<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token keyword">end</span>      dap<span class="token punctuation">.</span>listeners<span class="token punctuation">.</span>before<span class="token punctuation">.</span>event_terminated<span class="token punctuation">.</span>dapui_config <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        dapui<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token keyword">end</span>      dap<span class="token punctuation">.</span>listeners<span class="token punctuation">.</span>before<span class="token punctuation">.</span>event_exited<span class="token punctuation">.</span>dapui_config <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        dapui<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token keyword">end</span>      <span class="token keyword">return</span> <span class="token punctuation">{</span>        enabled <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">-- enable this plugin (the default)</span>        enabled_commands <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">-- create commands DapVirtualTextEnable, DapVirtualTextDisable, DapVirtualTextToggle, (DapVirtualTextForceRefresh for refreshing when debug adapter did not notify its termination)</span>        highlight_changed_variables <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">-- highlight changed values with NvimDapVirtualTextChanged, else always NvimDapVirtualText</span>        highlight_new_as_changed <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">-- highlight new variables in the same way as changed variables (if highlight_changed_variables)</span>        show_stop_reason <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">-- show stop reason when stopped for exceptions</span>        commented <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">-- prefix virtual text with comment string</span>        only_first_definition <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">-- only show virtual text at first definition (if there are multiple)</span>        all_references <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">-- show virtual text on all all references of the variable (not only definitions)</span>        filter_references_pattern <span class="token operator">=</span> <span class="token string">"&lt;module"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">-- filter references (not definitions) pattern when all_references is activated (Lua gmatch pattern, default filters out Python modules)</span>        <span class="token comment" spellcheck="true">-- Experimental Features:</span>        virt_text_pos <span class="token operator">=</span> <span class="token string">"eol"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">-- position of virtual text, see `:h nvim_buf_set_extmark()`</span>        all_frames <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">-- show virtual text for all stack frames not only current. Only works for debugpy on my machine.</span>        virt_lines <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">-- show virtual lines instead of virtual text (will flicker!)</span>        virt_text_win_col <span class="token operator">=</span> <span class="token keyword">nil</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">-- position the virtual text at a fixed window column (starting from the first text column) ,</span>      <span class="token punctuation">}</span>    <span class="token keyword">end</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span>    <span class="token string">"theHamsta/nvim-dap-virtual-text"</span><span class="token punctuation">,</span>    opts <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里使用了三个插件</p><ol><li><code>mfussenegger/nvim-dap</code> 提供基本的dap支持</li><li><code>rcarriga/nvim-dap-ui</code> 提供调试的ui，类似VSCode 的调试界面那样</li><li><code>theHamsta/nvim-dap-virtual-text</code> 在调试的代码附近用虚显的文件显示变量信息</li></ol><p>官方仓库配置示例：<a href="https://github.com/mfussenegger/nvim-dap/wiki/Debug-Adapter-installation#ccrust-via-vscode-cpptools">https://github.com/mfussenegger/nvim-dap/wiki/Debug-Adapter-installation#ccrust-via-vscode-cpptools</a></p><h3 id="配置完成"><a href="#配置完成" class="headerlink" title="配置完成"></a>配置完成</h3><p>正常情况下按f5(或者你自己的启动配置)或命令模式输入<code>DapContinue</code>会出现这个界面,剩下的就无需多言。</p><p><img src="/posts/63066/image-20240615194720063.png" alt></p><p>至于打断点的行的标志和颜色是可以自己配置的，把乱码的地方改成你喜欢的符号即可</p><pre class="line-numbers language-lua"><code class="language-lua"><span class="token comment" spellcheck="true">-- 设置调试相关的字符和颜色</span><span class="token keyword">local</span> dap_breakpoint_color <span class="token operator">=</span> <span class="token punctuation">{</span>    breakpoint <span class="token operator">=</span> <span class="token punctuation">{</span>        ctermbg<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>        fg<span class="token operator">=</span><span class="token string">'#993939'</span><span class="token punctuation">,</span>        bg<span class="token operator">=</span><span class="token string">'#31353f'</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    logpoing <span class="token operator">=</span> <span class="token punctuation">{</span>        ctermbg<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>        fg<span class="token operator">=</span><span class="token string">'#61afef'</span><span class="token punctuation">,</span>        bg<span class="token operator">=</span><span class="token string">'#31353f'</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    stopped <span class="token operator">=</span> <span class="token punctuation">{</span>        ctermbg<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>        fg<span class="token operator">=</span><span class="token string">'#98c379'</span><span class="token punctuation">,</span>        bg<span class="token operator">=</span><span class="token string">'#31353f'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span>vim<span class="token punctuation">.</span>api<span class="token punctuation">.</span><span class="token function">nvim_set_hl</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'DapBreakpoint'</span><span class="token punctuation">,</span> dap_breakpoint_color<span class="token punctuation">.</span>breakpoint<span class="token punctuation">)</span>vim<span class="token punctuation">.</span>api<span class="token punctuation">.</span><span class="token function">nvim_set_hl</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'DapLogPoint'</span><span class="token punctuation">,</span> dap_breakpoint_color<span class="token punctuation">.</span>logpoing<span class="token punctuation">)</span>vim<span class="token punctuation">.</span>api<span class="token punctuation">.</span><span class="token function">nvim_set_hl</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'DapStopped'</span><span class="token punctuation">,</span> dap_breakpoint_color<span class="token punctuation">.</span>stopped<span class="token punctuation">)</span><span class="token comment" spellcheck="true">-- 输入unicode的方法：ctrl + v + u 再输入unicode码</span><span class="token comment" spellcheck="true">-- 可在https://www.nerdfonts.com/cheat-sheet查询想要的字符</span><span class="token keyword">local</span> dap_breakpoint <span class="token operator">=</span> <span class="token punctuation">{</span>    error <span class="token operator">=</span> <span class="token punctuation">{</span>        text <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span>        texthl <span class="token operator">=</span> <span class="token string">"DapBreakpoint"</span><span class="token punctuation">,</span>        linehl <span class="token operator">=</span> <span class="token string">"DapBreakpoint"</span><span class="token punctuation">,</span>        numhl <span class="token operator">=</span> <span class="token string">"DapBreakpoint"</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    condition <span class="token operator">=</span> <span class="token punctuation">{</span>        text <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">,</span>        texthl <span class="token operator">=</span> <span class="token string">'DapBreakpoint'</span><span class="token punctuation">,</span>        linehl <span class="token operator">=</span> <span class="token string">'DapBreakpoint'</span><span class="token punctuation">,</span>        numhl <span class="token operator">=</span> <span class="token string">'DapBreakpoint'</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    rejected <span class="token operator">=</span> <span class="token punctuation">{</span>        text <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span>        texthl <span class="token operator">=</span> <span class="token string">"DapBreakpoint"</span><span class="token punctuation">,</span>        linehl <span class="token operator">=</span> <span class="token string">"DapBreakpoint"</span><span class="token punctuation">,</span>        numhl <span class="token operator">=</span> <span class="token string">"DapBreakpoint"</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    logpoint <span class="token operator">=</span> <span class="token punctuation">{</span>        text <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">,</span>        texthl <span class="token operator">=</span> <span class="token string">'DapLogPoint'</span><span class="token punctuation">,</span>        linehl <span class="token operator">=</span> <span class="token string">'DapLogPoint'</span><span class="token punctuation">,</span>        numhl <span class="token operator">=</span> <span class="token string">'DapLogPoint'</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    stopped <span class="token operator">=</span> <span class="token punctuation">{</span>        text <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">,</span>        texthl <span class="token operator">=</span> <span class="token string">'DapStopped'</span><span class="token punctuation">,</span>        linehl <span class="token operator">=</span> <span class="token string">'DapStopped'</span><span class="token punctuation">,</span>        numhl <span class="token operator">=</span> <span class="token string">'DapStopped'</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span>vim<span class="token punctuation">.</span>fn<span class="token punctuation">.</span><span class="token function">sign_define</span><span class="token punctuation">(</span><span class="token string">'DapBreakpoint'</span><span class="token punctuation">,</span> dap_breakpoint<span class="token punctuation">.</span>error<span class="token punctuation">)</span>vim<span class="token punctuation">.</span>fn<span class="token punctuation">.</span><span class="token function">sign_define</span><span class="token punctuation">(</span><span class="token string">'DapBreakpointCondition'</span><span class="token punctuation">,</span> dap_breakpoint<span class="token punctuation">.</span>condition<span class="token punctuation">)</span>vim<span class="token punctuation">.</span>fn<span class="token punctuation">.</span><span class="token function">sign_define</span><span class="token punctuation">(</span><span class="token string">'DapBreakpointRejected'</span><span class="token punctuation">,</span> dap_breakpoint<span class="token punctuation">.</span>rejected<span class="token punctuation">)</span>vim<span class="token punctuation">.</span>fn<span class="token punctuation">.</span><span class="token function">sign_define</span><span class="token punctuation">(</span><span class="token string">'DapLogPoint'</span><span class="token punctuation">,</span> dap_breakpoint<span class="token punctuation">.</span>logpoint<span class="token punctuation">)</span>vim<span class="token punctuation">.</span>fn<span class="token punctuation">.</span><span class="token function">sign_define</span><span class="token punctuation">(</span><span class="token string">'DapStopped'</span><span class="token punctuation">,</span> dap_breakpoint<span class="token punctuation">.</span>stopped<span class="token punctuation">)</span><span class="token comment" spellcheck="true">-- end dap</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/63066/image-20240615195649028.png" alt="最后样式"></p><p>至此就可以不用使用gdb -tui加上tmux双开调试了，直接在里面就行。</p><h2 id="配置CMakeTools"><a href="#配置CMakeTools" class="headerlink" title="配置CMakeTools"></a>配置CMakeTools</h2><p>现在可以直接在vim里面调试了，那不如再把cmake加进去。</p><p><img src="/posts/63066/image-20240618150506245.png" alt></p><p>首先nvim先支持cmake，除此之外我们还需要编写配置文件，配合lualine让状态栏能够显示我们要的cmake，怎么编写状态栏还有怎么让鼠标事件生效比较复杂，就不在这里贴了，除此之外还需要修改cmake-tool.lua，他默认生成的文件是在out里面，需要我们改成我们自己需要的，左键点击运行，右键选择更改。</p><p><img src="/posts/63066/image-20240618193939141.png" alt></p><p>lualine设置好后再重新配置dap，直到满足我们的需要。</p><p><img src="/posts/63066/image-20240618203842971.png" alt="终于能选了"></p><p>现在真可以像vscode一样使用了，可喜可贺。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;还有更多功能等着探索，首先先把官方文档放在这里：&lt;a href=&quot;https://github.com/mfussenegger/nvim-
      
    
    </summary>
    
    
      <category term="生产环境" scheme="https://JoyTsing.github.io/categories/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="Tool" scheme="https://JoyTsing.github.io/tags/Tool/"/>
    
  </entry>
  
  <entry>
    <title>Cpp与Callback</title>
    <link href="https://joytsing.github.io/posts/39903/"/>
    <id>https://joytsing.github.io/posts/39903/</id>
    <published>2024-06-06T07:24:34.000Z</published>
    <updated>2024-06-06T09:12:49.741Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>callback的问题可以说老生常谈了，以及怎么通过协程这个语法糖来让异步的代码编写方式变成同步的风格，这个话题在前面的文章已经说过了，这次就谈一谈异步编程必须要跨过的一个槛，沟槽的callback(也是我为什么这样讨厌js的一大原因)，以及怎么让callback写法现代一点(怎么在正儿八经的项目里面用又是另外一个问题了)。</p><h2 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h2><p>一般来说，callback有两种做法：</p><ul><li>一次设置回调，多次调用：主要用于网络编程里面(也是callback最常见的一个地方)，好处显然是不用浪费每次设置回调的开销。但对于复杂逻辑来说，就不太友好了。因为回调入口只有一个，要实现复杂的逻辑，只能自己在回调里想方设法折腾(函数调用链冗长甚至交叉调用)。</li><li>一次设置回调，一次调用：这种模式常用于文件IO，用于异步的写等等，因为这种类似的操作不会有多次结果。坏处是会在设置回调上多了开销，但应对复杂的逻辑来说，具有相当好的深度可供挖掘，同时一次设置，一次调用，还可以根据对失败的处理，细分下使用方式：<ul><li>设置时失败，则返回错误信息，同时不会调用回调接口；</li><li>异步操作失败，不会调用回调接口；</li><li>异步操作失败会调用回调接口，但是取消异步操作则不会调用回调接口；</li><li>任何情况下都会调用回调接口；</li></ul></li></ul><p>怎么处理逻辑就看怎么设计，但是为了接口调用的清爽建议按照第四种情况来，这样就不用将失败处理的逻辑抛给对调用链一无所知的api调用者。</p><h3 id="从例子说起"><a href="#从例子说起" class="headerlink" title="从例子说起"></a>从例子说起</h3><p>通常情况下的异步回调是这个样子的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Input_t<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Callable_t<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">tostring_async</span><span class="token punctuation">(</span>_Input_t<span class="token operator">&amp;&amp;</span> value<span class="token punctuation">,</span> _Callable_t<span class="token operator">&amp;&amp;</span> callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token punctuation">[</span>callback <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">forward</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">,</span> value <span class="token operator">=</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>_Input_t<span class="token operator">></span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// do something</span>            <span class="token function">callback</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">to_string</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体线程里面开什么按照具体业务来定，如果不想麻烦单独开个线程也可以使用<code>std::async</code>配合<code>std::launch::async</code>来使用，他干的事其实就是帮你封装好开个线程。是不是觉得很简单？当业务复杂的时候就不是这样美好了，怎么处理深度连续回调就是当务之急。</p><p>通常是使用调用链来解决，就是future+then方案。代码大致如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Input_t<span class="token operator">></span>std<span class="token operator">::</span>future<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> <span class="token function">tostring_async</span><span class="token punctuation">(</span>_Input_t<span class="token operator">&amp;&amp;</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span><span class="token punctuation">[</span>value <span class="token operator">=</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>_Input_t<span class="token operator">></span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">to_string</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//使用范例代码</span><span class="token function">tostring_async</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string <span class="token operator">&amp;&amp;</span> result<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> result <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可惜标准库里面并没有支持这样的写法，如果使用<code>Boost</code>或者Facebook的<code>folly</code>这样的任务链库就能支持这样的写法。当然这些不是关键，如果只是回调函数比较深，那么做好标记，配合lambda食用，一点点看总能看到头的，然而问题在于用回调模拟循环，然后再涉及到分支去调用其他回调的时候问题就比较大了，同样的这样的逻辑非常丑陋，代码也有一股<code>bad smell</code>，这样的回调函数内部通常是这个样的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">do_accept</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ec<span class="token punctuation">)</span>        <span class="token function">do_read</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">do_read</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ec<span class="token punctuation">)</span>        <span class="token function">do_write</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">do_accept</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">do_write</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ec<span class="token punctuation">)</span>        <span class="token function">do_read</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于经常写异步网络的人来说这样的模式应该是不陌生的，这种代码应该怎么改造，似乎很难回答，当然一个解决方案我们一开始也说过了，利用协程以及<code>co_await</code>改造，但是这样的话就是消灭callback而不是让callback变得更加友好的这个话题了，并且关于现阶段<code>gcc</code>提供的协程栈协议已经在前面说到过了，其实并不完善，就如同<code>gcc</code>下<code>c++20</code>的另一大特性<code>module</code>其实根本用不了一样(import std的支持实在是太差)，其次如果用了一个第三方的异步库，怎么去拓展这个库，怎么适配这个库都是额外引入的开销，所以并没有想象的那么没好。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>之前说了使用原旨callback的异步库所面临的困难：callback本身难于使用，要将异步库改造得支持future-then范式，或者支持协程，需要更改每一个异步函数。而future库/协程库又选择繁多，要全部支持就需要一一的改写每个异步函数，导致工作量是<strong>乘法</strong>数量级。先回到最初的例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Input_t<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Callable_t<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">tostring_async</span><span class="token punctuation">(</span>_Input_t<span class="token operator">&amp;&amp;</span> value<span class="token punctuation">,</span> _Callable_t<span class="token operator">&amp;&amp;</span> callback<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token punctuation">[</span>callback <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">,</span> value <span class="token operator">=</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>_Input_t<span class="token operator">></span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token punctuation">{</span>            <span class="token function">callback</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">to_string</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//使用范例</span><span class="token function">tostring_async</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string <span class="token operator">&amp;&amp;</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>怎么改造成一个更加modern的回调，首先要干的事情和改造function一样，我们得先type erasure</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//回调适配器的模板类</span><span class="token comment" spellcheck="true">//这个默认类以_Callable_t作为真正的回调</span><span class="token comment" spellcheck="true">//返回无意义的int，以便于编译通过</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Callable_t<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Result_t<span class="token operator">></span><span class="token keyword">struct</span> modern_callback_adapter_t<span class="token punctuation">{</span>    <span class="token keyword">using</span> return_type <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">;</span>    <span class="token keyword">using</span> callback_type <span class="token operator">=</span> _Callable_t<span class="token punctuation">;</span>    <span class="token keyword">static</span> std<span class="token operator">::</span>tuple<span class="token operator">&lt;</span>callback_type<span class="token punctuation">,</span> return_type<span class="token operator">></span> <span class="token function">traits</span><span class="token punctuation">(</span>_Callable_t<span class="token operator">&amp;&amp;</span> callback<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>_Callable_t<span class="token operator">></span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后是他的核心部分</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//一个使用回调处理结果的异步函数，会涉及以下概念：</span><span class="token comment" spellcheck="true">//_Input_t...：异步函数的输入参数；</span><span class="token comment" spellcheck="true">//_Signature_t: 此异步回调的函数签名；应当满足‘void(_Exception_t, _Result_t...)’或者‘void(_Result_t...)’类型；</span><span class="token comment" spellcheck="true">//_Callable_t：回调函数或标记，如果是回调函数，则需要符合_Signature_t的签名类型。这个回调，必须调用一次，且只能调用一次；</span><span class="token comment" spellcheck="true">//_Return_t：异步函数的返回值；</span><span class="token comment" spellcheck="true">//_Result_t...：异步函数完成后的结果值，作为回调函数的入参部分；这个参数可以有零至多个；</span><span class="token comment" spellcheck="true">//_Exception_t：回调函数的异常， 如果不喜欢异常的则忽略这个部分，但就得异步代码将异常处置妥当；</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">//在回调适配器模型里，_Input_t/_Result_t/_Exception_t(可选)是异步函数提供的功能所固有的部分；_Callable_t/_Return_t</span><span class="token comment" spellcheck="true">//部分并不直接使用，而是通过适配器去另外处理。这样给予适配器一次扩展到future模式，调用链模式的机会，以及支持协程的机会。</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">//tostring_async 演示了在其他线程里，将_Input_t的输入值，转化为std::string类型的_Result_t。</span><span class="token comment" spellcheck="true">//然后调用_Signature_t为 ‘void(std::string &amp;&amp;)’ 类型的 _Callable_t。</span><span class="token comment" spellcheck="true">//忽视异常处理，故没有_Exception_t。</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Input_t<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Callable_t<span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">tostring_async</span><span class="token punctuation">(</span>_Input_t<span class="token operator">&amp;&amp;</span> value<span class="token punctuation">,</span> _Callable_t<span class="token operator">&amp;&amp;</span> callback<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//-> typename modern_callback_adapter_t&lt;std::decay_t&lt;_Callable_t>, std::string>::return_type</span><span class="token punctuation">{</span>    <span class="token keyword">using</span> _Result_t <span class="token operator">=</span> std<span class="token operator">::</span>string<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//适配器类型</span>    <span class="token keyword">using</span> _Adapter_t <span class="token operator">=</span> modern_callback_adapter_t<span class="token operator">&lt;</span>std<span class="token operator">::</span>decay_t<span class="token operator">&lt;</span>_Callable_t<span class="token operator">></span><span class="token punctuation">,</span> _Result_t<span class="token operator">></span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//通过适配器获得兼容_Callable_t类型的真正的回调，以及返回值_Return_t</span>    <span class="token keyword">auto</span> adapter <span class="token operator">=</span> <span class="token keyword">typename</span> _Adapter_t<span class="token operator">::</span><span class="token function">traits</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>_Callable_t<span class="token operator">></span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//real_callback与callback未必是同一个变量，甚至未必是同一个类型</span>    std<span class="token operator">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token punctuation">[</span>real_callback <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>std<span class="token operator">::</span>get<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">></span><span class="token punctuation">(</span>adapter<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> value <span class="token operator">=</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>_Input_t<span class="token operator">></span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token punctuation">{</span>            <span class="token function">real_callback</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">to_string</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//返回适配器的return_type变量</span>    <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>std<span class="token operator">::</span>get<span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">></span><span class="token punctuation">(</span>adapter<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看似增加了不少代码，但这些代码很模式化，完全可以用宏来简化</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">define</span> MODERN_CALLBACK_TRAITS(type) \    using _Result_t = type; \    using _Adapter_t = modern_callback_adapter_t&lt;std::decay_t&lt;_Callable_t>, _Result_t>; \    auto adapter = typename _Adapter_t::traits(std::forward&lt;_Callable_t>(callback))</span><span class="token macro property">#<span class="token directive keyword">define</span> MODERN_CALLBACK_CALL() callback = std::move(std::get&lt;0>(adapter))</span><span class="token macro property">#<span class="token directive keyword">define</span> MODERN_CALLBACK_RETURN() return std::move(std::get&lt;1>(adapter)) </span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Input_t<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Callable_t<span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">tostring_async</span><span class="token punctuation">(</span>_Input_t<span class="token operator">&amp;&amp;</span> value<span class="token punctuation">,</span> _Callable_t<span class="token operator">&amp;&amp;</span> callback<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">MODERN_CALLBACK_TRAITS</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">MODERN_CALLBACK_CALL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> value <span class="token operator">=</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>_Input_t<span class="token operator">></span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token punctuation">{</span>            <span class="token function">callback</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">to_string</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MODERN_CALLBACK_RETURN</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就能之前怎么用现在还是怎么用，这时候可能就要问了，这样只是换了个包装而已，甚至多了一层开销没有改变本质啊，接下来需要支持future。首先，看看不采用morden callback方案，需要如何支持future-then范式：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Input_t<span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">tostring_async</span><span class="token punctuation">(</span>_Input_t<span class="token operator">&amp;&amp;</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>promise<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> _promise<span class="token punctuation">;</span>    std<span class="token operator">::</span>future<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> _future <span class="token operator">=</span> _promise<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token punctuation">[</span>_promise <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>_promise<span class="token punctuation">)</span><span class="token punctuation">,</span> value <span class="token operator">=</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>_Input_t<span class="token operator">></span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">mutable</span>        <span class="token punctuation">{</span>            _promise<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">to_string</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>_future<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后是继续拓展之前的写法：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//一、做一个辅助类</span><span class="token keyword">struct</span> use_future_t <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//二、申明这个辅助类的全局变量。不申明这个变量也行，就是每次要写use_future_t{}，麻烦些。</span><span class="token comment" spellcheck="true">//以后就使用use_future，替代tostring_async的callback参数了。</span><span class="token comment" spellcheck="true">//这个参数其实不需要实质传参，最后会被编译器优化没了。</span><span class="token comment" spellcheck="true">//仅仅是要指定_Callable_t的类型为use_future_t，</span><span class="token comment" spellcheck="true">//从而在tostring_async函数内，使用偏特化的modern_callback_adapter_t&lt;use_future_t, ...>版本而已。</span><span class="token keyword">inline</span> <span class="token keyword">constexpr</span> use_future_t use_future<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将替换use_future_t的，真正的回调类。</span><span class="token comment" spellcheck="true">//此回调类，符合tostring_async的_Callable_t函数签名。</span><span class="token comment" spellcheck="true">//生成此类的实例作为real_callback交给tostring_async作为异步回调。</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">//future模式下，此类持有一个std::promise&lt;_Result_t>，便于设置值和异常</span><span class="token comment" spellcheck="true">//而将与promise关联的future作为返回值_Return_t，让tostring_async返回。</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Result_t<span class="token operator">></span><span class="token keyword">struct</span> use_future_callback_t<span class="token punctuation">{</span>    <span class="token keyword">using</span> promise_type <span class="token operator">=</span> std<span class="token operator">::</span>promise<span class="token operator">&lt;</span>_Result_t<span class="token operator">></span><span class="token punctuation">;</span>    <span class="token keyword">mutable</span> promise_type _promise<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>_Result_t<span class="token operator">&amp;&amp;</span> value<span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span>        _promise<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>_Result_t<span class="token operator">&amp;&amp;</span> value<span class="token punctuation">,</span> std<span class="token operator">::</span>exception_ptr<span class="token operator">&amp;&amp;</span> eptr<span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>eptr <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>            _promise<span class="token punctuation">.</span><span class="token function">set_exception</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>std<span class="token operator">::</span>exception_ptr<span class="token operator">></span><span class="token punctuation">(</span>eptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            _promise<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>_Result_t<span class="token operator">></span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//偏特化_Callable_t为use_future_t类型的modern_callback_adapter_t</span><span class="token comment" spellcheck="true">//真正的回调类型是use_future_callback_t，返回类型_Return_t是std::future&lt;_Result_t>。</span><span class="token comment" spellcheck="true">//配合use_future_callback_t的std::promise&lt;_Result_t>，正好组成一对promise/future对。</span><span class="token comment" spellcheck="true">//promise在真正的回调里设置结果值；</span><span class="token comment" spellcheck="true">//future返回给调用者获取结果值。</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Result_t<span class="token operator">></span><span class="token keyword">struct</span> modern_callback_adapter_t<span class="token operator">&lt;</span>use_future_t<span class="token punctuation">,</span> _Result_t<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">using</span> return_type <span class="token operator">=</span> std<span class="token operator">::</span>future<span class="token operator">&lt;</span>_Result_t<span class="token operator">></span><span class="token punctuation">;</span>    <span class="token keyword">using</span> callback_type <span class="token operator">=</span> use_future_callback_t<span class="token operator">&lt;</span>_Result_t<span class="token operator">></span><span class="token punctuation">;</span>    <span class="token keyword">static</span> std<span class="token operator">::</span>tuple<span class="token operator">&lt;</span>callback_type<span class="token punctuation">,</span> return_type<span class="token operator">></span> <span class="token function">traits</span><span class="token punctuation">(</span><span class="token keyword">const</span> use_future_t<span class="token operator">&amp;</span><span class="token comment" spellcheck="true">/*没人关心这个变量*/</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        callback_type real_callback<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        return_type future <span class="token operator">=</span> real_callback<span class="token punctuation">.</span>_promise<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>real_callback<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>future<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后改成宏定义就能到处用了，这样的代码只需要针对所选择的future库写一次，就可以支持全部的N个异步函数了。使用范例如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>future<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> f2 <span class="token operator">=</span> <span class="token function">tostring_async</span><span class="token punctuation">(</span><span class="token number">6.0f</span><span class="token punctuation">,</span> use_future<span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> f2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="协程中使用"><a href="#协程中使用" class="headerlink" title="协程中使用"></a>协程中使用</h3><p>只有使用了协程后，才可以非常容易的支持循环+分支逻辑，这个没办法，别的都是治标不治本。以librf为例，看看如何去支持协程：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//同理，可以制作支持C++20的协程的下列一系列类（其实，这才是我的最终目的）</span><span class="token keyword">struct</span> use_awaitable_t <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">inline</span> <span class="token keyword">constexpr</span> use_awaitable_t use_awaitable<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Result_t<span class="token operator">></span><span class="token keyword">struct</span> use_awaitable_callback_t<span class="token punctuation">{</span>    <span class="token keyword">using</span> promise_type <span class="token operator">=</span> librf<span class="token operator">::</span>promise_t<span class="token operator">&lt;</span>_Result_t<span class="token operator">></span><span class="token punctuation">;</span>    <span class="token keyword">using</span> state_type <span class="token operator">=</span> <span class="token keyword">typename</span> promise_type<span class="token operator">::</span>state_type<span class="token punctuation">;</span>    librf<span class="token operator">::</span>counted_ptr<span class="token operator">&lt;</span>state_type<span class="token operator">></span> _state<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>_Result_t<span class="token operator">&amp;&amp;</span> value<span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span>        _state<span class="token operator">-</span><span class="token operator">></span><span class="token function">set_value</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>_Result_t<span class="token operator">></span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>_Result_t<span class="token operator">&amp;&amp;</span> value<span class="token punctuation">,</span> std<span class="token operator">::</span>exception_ptr<span class="token operator">&amp;&amp;</span> eptr<span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>eptr <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>            _state<span class="token operator">-</span><span class="token operator">></span><span class="token function">set_exception</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>std<span class="token operator">::</span>exception_ptr<span class="token operator">></span><span class="token punctuation">(</span>eptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            _state<span class="token operator">-</span><span class="token operator">></span><span class="token function">set_value</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>_Result_t<span class="token operator">></span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Result_t<span class="token operator">></span><span class="token keyword">struct</span> modern_callback_adapter_t<span class="token operator">&lt;</span>use_awaitable_t<span class="token punctuation">,</span> _Result_t<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">using</span> promise_type <span class="token operator">=</span> librf<span class="token operator">::</span>promise_t<span class="token operator">&lt;</span>_Result_t<span class="token operator">></span><span class="token punctuation">;</span>    <span class="token keyword">using</span> return_type <span class="token operator">=</span> librf<span class="token operator">::</span>future_t<span class="token operator">&lt;</span>_Result_t<span class="token operator">></span><span class="token punctuation">;</span>    <span class="token keyword">using</span> callback_type <span class="token operator">=</span> use_awaitable_callback_t<span class="token operator">&lt;</span>_Result_t<span class="token operator">></span><span class="token punctuation">;</span>    <span class="token keyword">static</span> std<span class="token operator">::</span>tuple<span class="token operator">&lt;</span>callback_type<span class="token punctuation">,</span> return_type<span class="token operator">></span> <span class="token function">traits</span><span class="token punctuation">(</span><span class="token keyword">const</span> use_awaitable_t<span class="token operator">&amp;</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        promise_type promise<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span> callback_type<span class="token punctuation">{</span> promise<span class="token punctuation">.</span>_state <span class="token punctuation">}</span><span class="token punctuation">,</span> promise<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后就能直接用了:</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>string result <span class="token operator">=</span> co_await <span class="token function">tostring_async</span><span class="token punctuation">(</span><span class="token number">10.0</span><span class="token punctuation">,</span> use_awaitable<span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> result <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>仅仅是替换callback参数，就达到了使用协程的目的。并且，只需要为选择的协程库写一次适配代码就可以了，假设异步库有N个异步函数，有三种异步支持方案：callback，future-then，coroutine，其中，可选择的库有folly,libco等K个。</p><pre><code>则原旨主义的回调方案，需要做N*K次修改。而采用modern callback方案，只需要做N+K次适配。</code></pre><p>显然，这是一个更好的方案，并且，当异步库修改了M个异步函数后：</p><pre><code>原旨主义的callback方案，需要做M*K次修改；而modern callback不需要在适配上做任何修改，编译一次就好了。</code></pre><p>所以我们进行类型擦除以及包装的最大目的还是为了解耦合，如果有确切的使用的异步库或者不需要支持那么多的适配，其实只用使用最原始的方法就行，没必要过渡包装，毕竟N*1还是N。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;callback的问题可以说老生常谈了，以及怎么通过协程这个语法糖来让异步的代码编写方式变成同步的风格，这个话题在前面的文章已经说过了，这次
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Cpp如何集成Prometheus和Grafana</title>
    <link href="https://joytsing.github.io/posts/45028/"/>
    <id>https://joytsing.github.io/posts/45028/</id>
    <published>2024-06-05T08:59:03.000Z</published>
    <updated>2024-06-05T09:25:44.300Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>监控是非常有必要的，就像打日志对于调试程序一样，日志打得好是可以避免手动gdb一行行排除错误的。同理对于评价一个程序，需要从各个方面的指标去评价，最常见也是最常用的就是QPS的监控了。</p><h2 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h2><p>长话短说，这里用的是<a href="https://github.com/jupp0r/prometheus-cpp">Prometheus Client Library for Modern C++</a>，可以自己make install，不过官方提供了Ubuntu PPA源就直接用Ubuntu PPA源了，添加源后的安装readme里面没说，去ubuntu release看后知道名字叫<code>prometheus-cpp-dev</code>，直接安装即可。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;prometheus/counter.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;prometheus/exposer.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;prometheus/registry.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;array></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;chrono></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">using</span> <span class="token keyword">namespace</span> prometheus<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// create an http server running on port 8080</span>  Exposer exposer<span class="token punctuation">{</span><span class="token string">"127.0.0.1:8080"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// create a metrics registry</span>  <span class="token comment" spellcheck="true">// @note it's the users responsibility to keep the object alive</span>  <span class="token keyword">auto</span> registry <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>Registry<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// add a new counter family to the registry (families combine values with the</span>  <span class="token comment" spellcheck="true">// same name, but distinct label dimensions)</span>  <span class="token comment" spellcheck="true">//</span>  <span class="token comment" spellcheck="true">// @note please follow the metric-naming best-practices:</span>  <span class="token comment" spellcheck="true">// https://prometheus.io/docs/practices/naming/</span>  <span class="token keyword">auto</span><span class="token operator">&amp;</span> packet_counter <span class="token operator">=</span> <span class="token function">BuildCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                             <span class="token punctuation">.</span><span class="token function">Name</span><span class="token punctuation">(</span><span class="token string">"observed_packets_total"</span><span class="token punctuation">)</span>                             <span class="token punctuation">.</span><span class="token function">Help</span><span class="token punctuation">(</span><span class="token string">"Number of observed packets"</span><span class="token punctuation">)</span>                             <span class="token punctuation">.</span><span class="token function">Register</span><span class="token punctuation">(</span><span class="token operator">*</span>registry<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// add and remember dimensional data, incrementing those is very cheap</span>  <span class="token keyword">auto</span><span class="token operator">&amp;</span> tcp_rx_counter <span class="token operator">=</span>      packet_counter<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"protocol"</span><span class="token punctuation">,</span> <span class="token string">"tcp"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"direction"</span><span class="token punctuation">,</span> <span class="token string">"rx"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">auto</span><span class="token operator">&amp;</span> tcp_tx_counter <span class="token operator">=</span>      packet_counter<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"protocol"</span><span class="token punctuation">,</span> <span class="token string">"tcp"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"direction"</span><span class="token punctuation">,</span> <span class="token string">"tx"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">auto</span><span class="token operator">&amp;</span> udp_rx_counter <span class="token operator">=</span>      packet_counter<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"protocol"</span><span class="token punctuation">,</span> <span class="token string">"udp"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"direction"</span><span class="token punctuation">,</span> <span class="token string">"rx"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">auto</span><span class="token operator">&amp;</span> udp_tx_counter <span class="token operator">=</span>      packet_counter<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"protocol"</span><span class="token punctuation">,</span> <span class="token string">"udp"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"direction"</span><span class="token punctuation">,</span> <span class="token string">"tx"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// add a counter whose dimensional data is not known at compile time</span>  <span class="token comment" spellcheck="true">// nevertheless dimensional values should only occur in low cardinality:</span>  <span class="token comment" spellcheck="true">// https://prometheus.io/docs/practices/naming/#labels</span>  <span class="token keyword">auto</span><span class="token operator">&amp;</span> http_requests_counter <span class="token operator">=</span> <span class="token function">BuildCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                                    <span class="token punctuation">.</span><span class="token function">Name</span><span class="token punctuation">(</span><span class="token string">"http_requests_total"</span><span class="token punctuation">)</span>                                    <span class="token punctuation">.</span><span class="token function">Help</span><span class="token punctuation">(</span><span class="token string">"Number of HTTP requests"</span><span class="token punctuation">)</span>                                    <span class="token punctuation">.</span><span class="token function">Register</span><span class="token punctuation">(</span><span class="token operator">*</span>registry<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// ask the exposer to scrape the registry on incoming HTTP requests</span>  exposer<span class="token punctuation">.</span><span class="token function">RegisterCollectable</span><span class="token punctuation">(</span>registry<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">auto</span> random_value <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>random_value <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> tcp_rx_counter<span class="token punctuation">.</span><span class="token function">Increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>random_value <span class="token operator">&amp;</span> <span class="token number">2</span><span class="token punctuation">)</span> tcp_tx_counter<span class="token punctuation">.</span><span class="token function">Increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>random_value <span class="token operator">&amp;</span> <span class="token number">4</span><span class="token punctuation">)</span> udp_rx_counter<span class="token punctuation">.</span><span class="token function">Increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>random_value <span class="token operator">&amp;</span> <span class="token number">8</span><span class="token punctuation">)</span> udp_tx_counter<span class="token punctuation">.</span><span class="token function">Increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> std<span class="token operator">::</span>array<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> <span class="token number">4</span><span class="token operator">></span> methods <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"GET"</span><span class="token punctuation">,</span> <span class="token string">"PUT"</span><span class="token punctuation">,</span> <span class="token string">"POST"</span><span class="token punctuation">,</span> <span class="token string">"HEAD"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> method <span class="token operator">=</span> methods<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>random_value <span class="token operator">%</span> methods<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// dynamically calling Family&lt;T>.Add() works but is slow and should be</span>    <span class="token comment" spellcheck="true">// avoided</span>    http_requests_counter<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"method"</span><span class="token punctuation">,</span> method<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h2><p>想要可视化我们的监控数据，我们还得启动Prometheus服务端，以及可视化的grafana工具，编写个docker-compose脚本拉取最新的就行， node_exporter用来帮助监控系统的数据。</p><pre class="line-numbers language-yml"><code class="language-yml">services:  prometheus:    container_name: prometheus    image: prom/prometheus:latest    network_mode: "host"    volumes:      - prometheus_yml_path :/etc/prometheus/prometheus.yml      - /etc/localtime:/etc/localtime    ports:      - "port1:9090"    restart: on-failure  grafana:    container_name: grafana    image: grafana/grafana:latest    network_mode: "host"    ports:      - "port2:3000"    restart: on-failure    volumes:      - /etc/localtime:/etc/localtime      - ./data/grafana:/var/lib/grafana  # linux node_exporter  node_exporter:    image: quay.io/prometheus/node-exporter:latest    restart: always    container_name: qps_node_exporter    command:      - '--path.rootfs=/host'    ports:      - "port3:9100"    volumes:      - your_path<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后去配置<code>prometheus_yml</code></p><pre class="line-numbers language-yml"><code class="language-yml">global:  scrape_interval: 5s # Set the scrape interval to every 15 seconds. Default is every 1 minute.  evaluation_interval: 10s # Evaluate rules every 15 seconds. The default is every 1 minute.  # scrape_timeout is set to the global default (10s).# Alertmanager configurationalerting:  alertmanagers:    - static_configs:        - targets:          # - alertmanager:9093# Load rules once and periodically evaluate them according to the global 'evaluation_interval'.rule_files:  # - "first_rules.yml"  # - "second_rules.yml"# A scrape configuration containing exactly one endpoint to scrape:# Here it's Prometheus itself.scrape_configs:  # The job name is added as a label `job=<job_name>` to any timeseries scraped from this config.  - job_name: "prometheus"    # metrics_path defaults to '/metrics'    # scheme defaults to 'http'.    static_configs:      - targets: ["ip:port1"]  - job_name: "server"    static_configs:      - targets: ["ip:port2"]  - job_name: "node"    static_configs:      - targets: ["ip:port3"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/45028/9ef52ea3df7ec7aef0164b4d6d81e041.png" alt="docker-compose，启动！"></p><p>一般遇到grafana一直重启的问题，通常是因为文件权限没有给对，直接777即可，一般来说启动成功的结构如下图：</p><p><img src="/posts/45028/2c1125e3629da1c12db3a29da523231d.jpg" alt></p><h2 id="配置-Grafana"><a href="#配置-Grafana" class="headerlink" title="配置 Grafana"></a>配置 Grafana</h2><p>Grafana默认账号密码admin，进去先直接配置数据源。</p><p><img src="/posts/45028/83a422e1cf39e47a9600dc222f384a1f.png" alt></p><p>选择后，在 Prometheus 数据源配置页面，配置这个数据源的 HTTP URL 就可以了。如果你点击“Save &amp; test”按钮后提示成功，那么数据源就配置好了。</p><p>接下来，我们再添加一个 node-exporter 仪表板（dashboard），把从 node-exporter 拉取的度量数据以图形化方式展示出来。这个时候我们不需要手工一个一个设置仪表板上的 panel，Grafana 官方有现成的 node-exporter 仪表板可用，我们只需要在 grafana 的 import 页面中输入相应的 dashboard ID，就可以导入相关仪表板的设置：</p><p><img src="/posts/45028/e483fec0e2a3cfbc258cd92817d820e8.png" alt></p><p>ID 为 1860 的 node-exporter 仪表板，导入成功后，进入这个仪表板页面，等待一段时间后，我们就可以看到类似下面的可视化结果：好了，到这里 node-exporter 的度量数据，已经可以以图形化的形式呈现在我们面前了，至于我们自己的数据怎么添加监控在前面部分就说了。</p><h3 id="添加自定义面板"><a href="#添加自定义面板" class="headerlink" title="添加自定义面板"></a>添加自定义面板</h3><p><a href="https://prometheus.io/docs/prometheus/latest/querying/functions/#rate">rate</a>是我们测试qps等等跟时间有关的部分最常用的函数。以 req_recv_rate 这个 panel 为例，它的 panel 配置是这样：</p><p><img src="https://static001.geekbang.org/resource/image/02/0f/02736fe21512ab8ac983caaa73cc550f.png?wh=1920x1437" alt>****</p><p>我们看到图中的 Metrics Browser 后面的表达式是：rate(tcp_server_demo2_req_recv_total[15s])，这个表达式返回的是在 15 秒内测得的 req_recv_total 的每秒速率，这恰恰是可以反映我们的服务端处理性能的指标。</p><h2 id="配置图"><a href="#配置图" class="headerlink" title="配置图"></a>配置图</h2><p><img src="/posts/45028/6baa8bf8913c317707018875d608561e.png" alt="多指标配置"></p><p>现在可以精准监控了，可喜可贺。</p><p><img src="/posts/45028/0ee46cee59888c30638a64d3774bc288.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;监控是非常有必要的，就像打日志对于调试程序一样，日志打得好是可以避免手动gdb一行行排除错误的。同理对于评价一个程序，需要从各个方面的指标去
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>德尔斐神庙与三句箴言</title>
    <link href="https://joytsing.github.io/posts/32630/"/>
    <id>https://joytsing.github.io/posts/32630/</id>
    <published>2024-06-01T06:17:40.000Z</published>
    <updated>2024-06-11T14:09:44.540Z</updated>
    
    <content type="html"><![CDATA[<h2 id="三句箴言"><a href="#三句箴言" class="headerlink" title="三句箴言"></a>三句箴言</h2><ul><li>认识你自己<ul><li>想要贯彻自己的意志，那么惜字如金，然后充耳不闻就是最好的选择</li></ul></li><li>凡事勿过度<ul><li>沉默又冷酷，但要注意不要太过火，否则没说出口的单词就会演变成暴力。</li></ul></li><li>妄立誓则祸近<ul><li>不要相信其他人，action louder than speak</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;三句箴言&quot;&gt;&lt;a href=&quot;#三句箴言&quot; class=&quot;headerlink&quot; title=&quot;三句箴言&quot;&gt;&lt;/a&gt;三句箴言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;认识你自己&lt;ul&gt;
&lt;li&gt;想要贯彻自己的意志，那么惜字如金，然后充耳不闻就是最好的选择&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CMake与Protobuf教程&amp;踩坑日记</title>
    <link href="https://joytsing.github.io/posts/59761/"/>
    <id>https://joytsing.github.io/posts/59761/</id>
    <published>2024-05-30T13:15:28.000Z</published>
    <updated>2024-06-03T11:28:52.018Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>不讲具体的protobuf使用，主要介绍怎么引入到工程中并且怎么方便作为工程的一部分使用。因为当时去搜索引擎上查了一下并没有特别满意的答案，所以决定自己写一个。当然别忘了外面的summary：<code>It just work!</code>，全文充斥着工程妥协的味道。</p><h2 id="问题一：版本冲突"><a href="#问题一：版本冲突" class="headerlink" title="问题一：版本冲突"></a>问题一：版本冲突</h2><p>在之前有关protobuf的blog里面就介绍了当电脑里面存在两个版本的protobuf的时候会冲突，当时为什么没有用grpc自带的那个最新版本？因为我发现那个版本使用的时候absl会提示一堆找不到的报错，并且就算安装了absl的库后也是同理。</p><p><img src="/posts/59761/66f2db0ff9599db168f991216770f647.png" alt="头皮发麻"></p><p>我当时以为是版本冲突的问题，后面单独使用的时候同样编译不了，提示缺少头文件，但是当配合grpc的时候又能够神奇的work了，所以想来想去反正grpc是动态库，直接在cmake里面加两行就行了。<code>It just work!</code></p><pre class="line-numbers language-cmake"><code class="language-cmake">find_package(Protobuf CONFIG REQUIRED)# TODO:消除absl的报错要靠grpc，无语了find_package(gRPC CONFIG REQUIRED)link_libraries(gRPC::grpc++)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="问题二：怎么集成进CMake项目"><a href="#问题二：怎么集成进CMake项目" class="headerlink" title="问题二：怎么集成进CMake项目"></a>问题二：怎么集成进CMake项目</h2><p>当然不是指的手动 <code>protoc --proto_path=xxxx --cpp_out=xxxx xxx.proto</code>，这样不仅麻烦而且每次修改proto都要重新生成，如果我们有多个proto的话岂不是需要一个一个改？无法忍受这样，所以我们要配合CMake的add_custom_command来使用。</p><p>这里以grpc操作redis的项目为例：</p><pre class="line-numbers language-cmake"><code class="language-cmake"># check thirdparty packagesset(protobuf_MODULE_COMPATIBLE true)find_package(Protobuf CONFIG REQUIRED)message(STATUS "Using Protobuf ${Protobuf_VERSION}")find_package(gRPC CONFIG REQUIRED)message(STATUS "Using gRPC ${gRPC_VERSION}")find_package(hiredis CONFIG REQUIRED)message(STATUS "Using hiredis ${hiredis_VERSION}")# include thirdparty includesinclude_directories(${hiredis_INCLUDE_DIRS})include_directories(${PROTOBUF_INCLUDE_DIRS})# # include thirdparty libsset(HREDIS_LIB_DEPS    ${GRPC_LIBRARIES}    ${HIREDIS_LIBRARIES}    ${Protobuf_LIBRARIES})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先引入三方库，记得要把<code>protobuf_MODULE_COMPATIBLE</code>设为<code>true</code>，因为我们要在后续的命令中使用到protobuf的部分模块。后面就是如何去自动生成我们要的proto了，首先我们必然不想自动生成在我们的项目目录中，因为这些代码不应该作为提交的部分（作为一个项目不应把grpc的版本限定死，毕竟grpc仅仅拿来通信版本其实不重要），选择生成到build文件夹中，只要保证每次build的时候都能生成自然也都能找到。</p><pre class="line-numbers language-cmake"><code class="language-cmake"># generate protobuf filesset(PROTO_PATH "${CMAKE_SOURCE_DIR}/protos")set(HREDIS_PROTO "${PROTO_PATH}/hredis.proto")set(GENERATED_PROTOBUF_PATH "${CMAKE_BINARY_DIR}/generated")file(MAKE_DIRECTORY ${GENERATED_PROTOBUF_PATH})set(HREDIS_PB_CPP_FILE "${GENERATED_PROTOBUF_PATH}/hredis.pb.cc")set(HREDIS_PB_H_FILE "${GENERATED_PROTOBUF_PATH}/hredis.pb.h")set(HREDIS_GRPC_PB_CPP_FILE "${GENERATED_PROTOBUF_PATH}/hredis.grpc.pb.cc")set(HREDIS_GRPC_PB_H_FILE "${GENERATED_PROTOBUF_PATH}/hredis.grpc.pb.h")set(HREDIS_GRPC_PB_PY_FILE "${GENERATED_PROTOBUF_PATH}/hredis_pb2.py")set(_GRPC_CPP_PLUGIN_EXECUTABLE $<TARGET_FILE:gRPC::grpc_cpp_plugin>)set(_GRPC_PYTHON_PLUGIN_EXECUTABLE $<TARGET_FILE:gRPC::grpc_python_plugin>)add_custom_command(     OUTPUT "${HREDIS_PB_H_FILE}"     "${HREDIS_PB_CPP_FILE}"     "${HREDIS_GRPC_PB_H_FILE}"     "${HREDIS_GRPC_PB_CPP_FILE}"     "${HREDIS_GRPC_PB_PY_FILE}"     COMMAND ${PROTOBUF_PROTOC_EXECUTABLE}     ARGS "--proto_path=${PROTO_PATH}"     "--cpp_out=${GENERATED_PROTOBUF_PATH}"     "${HREDIS_PROTO}"     COMMAND ${PROTOBUF_PROTOC_EXECUTABLE}     ARGS "--proto_path=${PROTO_PATH}"     "--grpc_out=${GENERATED_PROTOBUF_PATH}"     "--plugin=protoc-gen-grpc=${_GRPC_CPP_PLUGIN_EXECUTABLE}"     "${HREDIS_PROTO}"     COMMAND ${PROTOBUF_PROTOC_EXECUTABLE}     ARGS "--proto_path=${PROTO_PATH}"     "--python_out=${GENERATED_PROTOBUF_PATH}"     "--grpc_out=${GENERATED_PROTOBUF_PATH}"     "--plugin=protoc-gen-grpc=${_GRPC_PYTHON_PLUGIN_EXECUTABLE}"     "${HREDIS_PROTO}")set(GENERATED_PROTOBUF_FILES     ${HREDIS_PB_H_FILE}     ${HREDIS_PB_CPP_FILE}     ${HREDIS_GRPC_PB_H_FILE}     ${HREDIS_GRPC_PB_CPP_FILE}     ${HREDIS_GRPC_PB_PY_FILE})include_directories(${GENERATED_PROTOBUF_PATH})link_libraries(gRPC::grpc++ ${PROTOBUF_LIBRARY} ${hiredis_LIBRARIES})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="add-custom-command命令的基本语法"><a href="#add-custom-command命令的基本语法" class="headerlink" title="add_custom_command命令的基本语法"></a>add_custom_command命令的基本语法</h3><p>在CMake中，<code>add_custom_command</code>命令的基本语法如下：</p><pre class="line-numbers language-cmake"><code class="language-cmake">add_custom_command(    OUTPUT output1 [output2 ...]    COMMAND command1 [ARGS] [args1...]    [COMMAND command2 [ARGS] [args2...] ...]    [MAIN_DEPENDENCY depend]    [DEPENDS [depends...]]    [BYPRODUCTS [files...]]    [WORKING_DIRECTORY dir]    [COMMENT comment]    [VERBATIM])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个命令的主要作用是定义一条自定义的构建规则，这条规则可以在构建过程中执行一系列的命令。下面我们来详细解析这个命令的各个参数。</p><ul><li><code>OUTPUT output1 [output2 ...]</code>：这个参数用于指定自定义命令的输出文件。这些文件在构建过程中会被生成，如果这些文件不存在，那么CMake就会执行这条自定义命令。</li><li><code>COMMAND command1 [ARGS] [args1...]</code>：这个参数用于指定要执行的命令。你可以提供任何有效的命令，包括系统命令、脚本，或者其他的构建工具。<code>ARGS</code>关键字后面可以跟随一系列的参数，这些参数会被传递给命令。</li><li><code>MAIN_DEPENDENCY depend</code>：这个参数用于指定自定义命令的主要依赖。如果这个依赖的文件被修改，那么自定义命令就会被执行。</li><li><code>DEPENDS [depends...]</code>：这个参数用于指定自定义命令的其他依赖。如果这些依赖的文件被修改，那么自定义命令也会被执行。</li><li><code>BYPRODUCTS [files...]</code>：这个参数用于指定自定义命令的副产品。如果你指定了一个或多个文件作为副产品，那么这些文件将会被添加到构建系统的清理列表中。</li><li><code>WORKING_DIRECTORY dir</code>：这个参数用于指定自定义命令的工作目录。如果你没有指定这个参数，那么自定义命令将会在当前的源码目录中执行。</li><li><code>COMMENT comment</code>：这个参数用于指定一个注释，这个注释将会在执行自定义命令时被打印出来。</li><li><code>VERBATIM</code>：这个参数用于控制命令参数的处理方式。如果你指定了<code>VERBATIM</code>，那么命令参数将会被按照字面意义处理，而不会被解析为变量或表达式。</li></ul><h3 id="仍然有问题"><a href="#仍然有问题" class="headerlink" title="仍然有问题"></a>仍然有问题</h3><p>这样就能在build目录下自动生成所需要的pb文件了。至于为什么又说是妥协，上面的cmake代码在仅生成一个目录下的可执行程序是没有问题的，在下面这种目录中，example和src中都依赖我们需要生成的pb文件，那么这个时候该怎么办。</p><p><img src="/posts/59761/image-20240530215447441.png" alt></p><p>我们的主CMAKE结构是这样的：</p><p><img src="/posts/59761/image-20240530215541536.png" alt></p><p>是不是以为在<code>src</code>中生成就好了，因为代码是按顺序执行的，在<code>src</code>中生成后才会去<code>examples</code>里面执行，但现实并不是这样。你会发现ninja会略过src直接前往examples。因为<code>add_custom_command</code>是懒加载的，直到需要的时候才会正常去执行，这也就导致我们缺少头文件<strong>预处理</strong>的时候就会报错，但是当你继续运行的时候cmake就会发现真的需要它了，此时又能够build了（多点几次）。</p><p><img src="/posts/59761/image-20240530215735876.png" alt="suprise"></p><p>这种烦人的依赖问题该怎么解决呢？</p><h3 id="怎么解决的"><a href="#怎么解决的" class="headerlink" title="怎么解决的"></a>怎么解决的</h3><p>本质上是依赖问题，因为<code>add_custom_command</code>是懒加载的，那么需要创建一个依赖去告诉CMake我们什么时候就需要这个PB文件，这时候我们就需要使用<code>add_custom_target</code>,<code>add_custom_target</code> 用于添加自定义构建目标，这个目标通常不与实际的构建文件关联。它主要用于将一组自定义构建步骤组织成一个逻辑组，并在构建时执行这些步骤。这个命令通常与 <code>add_custom_command</code> 配合使用，以实现更复杂的构建过程。</p><pre class="line-numbers language-cmake"><code class="language-cmake">add_custom_target(Name [ALL] [command1 [args1...]]                  [COMMAND command2 [args2...] ...]                  [DEPENDS depend depend depend ... ]                  [BYPRODUCTS [files...]]                  [WORKING_DIRECTORY dir]                  [COMMENT comment]                  [JOB_POOL job_pool]                  [VERBATIM] [USES_TERMINAL]                  [COMMAND_EXPAND_LISTS]                  [SOURCES src1 [src2...]])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例：</strong></p><pre class="line-numbers language-cmake"><code class="language-cmake">add_custom_command(    OUTPUT generated_file.txt    COMMAND echo "Generated content" > generated_file.txt    DEPENDS some_input_file.txt    COMMENT "Generating a file")add_custom_target(    my_custom_target    COMMAND echo "Hello from custom target"    DEPENDS generated_file.txt    COMMENT "Executing a custom target")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，<code>add_custom_target</code> 创建了一个名为 <code>my_custom_target</code> 的自定义构建目标，它执行一个命令，输出 “Hello from custom target”。这个目标依赖于前面 <code>add_custom_command</code> 中生成的 <code>generated_file.txt</code>。</p><ul><li><code>add_custom_command</code> 主要用于定义在构建时执行的具体命令，通常与文件的生成或转换有关。</li><li><code>add_custom_target</code> 主要用于组织一组自定义构建步骤，并为它们创建一个逻辑目标。这个目标本身不与实际文件相关。</li></ul><p>在实际使用中，这两个命令通常结合使用，以创建复杂的构建过程。例如，<code>add_custom_command</code> 生成文件，然后 <code>add_custom_target</code> 创建一个目标，该目标依赖于生成的文件，并可能执行一些其他操作。</p><h2 id="问题三：加入到多目录CMake项目"><a href="#问题三：加入到多目录CMake项目" class="headerlink" title="问题三：加入到多目录CMake项目"></a>问题三：加入到多目录CMake项目</h2><p>既然有了生成的操作和添加依赖的方法，那么我们在src目录以及examples目录里面添加依赖即可：</p><pre class="line-numbers language-cmake"><code class="language-cmake"># 执行需要的依赖add_custom_target(  SRC_GEN_PROTO  DEPENDS ${GENERATED_PROTOBUF_FILES})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在就建立了正常的依赖关系了，可喜可贺。</p><p><img src="/posts/59761/image-20240530225432946.png" alt="可喜可贺"></p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>发现有时候管用有时候不管用，非常奇怪，后面查阅很多资料以及试了很多后，发现跟<code>dependencies</code>有关系，<code>add_custom_target</code>在有些情况下是等价于<code>add_dependencies</code>的，但是对于多目录结构下存在的依赖关系，这种<code>add_custom_target</code>似乎就不能够正确判别了，所以我们应该像链接库一样，手动添加我们的依赖：<code>add_dependencies(TAGETNAME DEPNAME)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;不讲具体的protobuf使用，主要介绍怎么引入到工程中并且怎么方便作为工程的一部分使用。因为当时去搜索引擎上查了一下并没有特别满意的答案，
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="CMake" scheme="https://JoyTsing.github.io/tags/CMake/"/>
    
      <category term="Tool" scheme="https://JoyTsing.github.io/tags/Tool/"/>
    
  </entry>
  
  <entry>
    <title>GitFlow与CMake项目CI集成</title>
    <link href="https://joytsing.github.io/posts/52642/"/>
    <id>https://joytsing.github.io/posts/52642/</id>
    <published>2024-05-21T15:46:36.000Z</published>
    <updated>2024-05-27T13:02:34.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先先把github action的文档放在<a href="https://docs.github.com/zh/actions">这里</a>，总结一下本质上和去一台新机器里构建没有别的区别。</p><h2 id="action"><a href="#action" class="headerlink" title="action"></a>action</h2><p>实现过程可以说非常简单，脚本也很轻松易懂，可以理解为我们要去一个新的容器里面去构建我们的环境并运行我们的测试。也就是说不仅需要构建所需的编译器，还需要去下载所需的包。</p><p><img src="/posts/52642/2aa6305e6b9b082ff9a8405236ee364f.png" alt></p><h3 id="多平台构建"><a href="#多平台构建" class="headerlink" title="多平台构建"></a>多平台构建</h3><p>可以看starter-workflows的<a href="https://github.com/actions/starter-workflows/issues/586">issue586</a>，里面有一个多编译器多平台的暴力<a href="https://github.com/dlang/dmd/blob/86c4cd1819fd26a822e0b1daf09f460dd5a3043e/.github/workflows/runnable_cxx.yml">构建脚本</a>。</p><h3 id="gcc13构建"><a href="#gcc13构建" class="headerlink" title="gcc13构建"></a>gcc13构建</h3><p>首先头疼的是<code>gcc-13</code>的选择，因为需要支持新的std标准，必须使用<code>gcc-13</code>，而<code>gcc-13</code>在ubuntu的apt标准源里面是没有的，从源码构建当然可以，但是这个太麻烦了，后面发现有简单的方法。</p><ol><li>先安装工具源</li></ol><pre><code>sudo add-apt-repository ppa:ubuntu-toolchain-r/test</code></pre><ol start="2"><li>更新源</li></ol><pre><code>sudo apt update</code></pre><ol start="3"><li>安装gcc和g+</li></ol><pre><code>apt install gcc-13 g++-13</code></pre><p>随后记得gcc-13 g++-13为高优先级（优先使用版本13）</p><pre><code> sudo update-alternatives --install `which gcc` gcc `which gcc-13` 99 sudo update-alternatives --install `which g++` g++ `which g++-13` 99</code></pre><p>在workflow脚本中可以这么写：</p><pre class="line-numbers language-yml"><code class="language-yml">    - name: install GCC13      shell:  bash      run:  |        sudo add-apt-repository ppa:ubuntu-toolchain-r/test        sudo apt update && sudo apt-get install gcc-13 g++-13        sudo update-alternatives --install `which gcc` gcc `which gcc-13` 99        sudo update-alternatives --install `which g++` g++ `which g++-13` 99<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/52642/11d93d21317627ab91cfd4a825fe9832.png" alt></p><h2 id="jobs流控制"><a href="#jobs流控制" class="headerlink" title="jobs流控制"></a>jobs流控制</h2><h3 id="job之间相互依赖"><a href="#job之间相互依赖" class="headerlink" title="job之间相互依赖"></a>job之间相互依赖</h3><p>之前配置可以发现是串行的，实际上在test的时候完全可以并行测试，同时对于配置来说，我们很难知道在哪一个环节出了问题，因此将整个大的jobs拆分成小的job就成了要解决的问题。后面查阅官方文档还有搜索资料发现了<a href="https://zhuanlan.zhihu.com/p/348712087">配置技巧</a>，</p><p>如何让Job 编排控制执行顺序，只需要一个tag即可。</p><pre class="line-numbers language-yml"><code class="language-yml">on: pushjobs:  job1:    runs-on: ubuntu-latest    steps:      - run: echo "job1"  job2:    runs-on: ubuntu-latest    steps:      - run: sleep 5    needs: job1  job3:    runs-on: ubuntu-latest    steps:      - run: sleep 10    needs: job1  job4:    runs-on: ubuntu-latest    steps:      - run: echo "job4"    needs: [job2, job3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的 workflows 执行时，job2 和 job3 会等 job1 执行成功时才执行，job4 会等 job2 和 job3 执行成功时才执行。</p><p><img src="/posts/52642/6feef617e30039021cc62190252b63b2.png" alt></p><h3 id="actions-artifact"><a href="#actions-artifact" class="headerlink" title="actions-artifact"></a>actions-artifact</h3><p>后面发现每个任务之前的环境是不互通的，也就是environment这个job配置好后，后续的job是使用不了的，这下难办了，该怎么办呢？因为我们只需要使用对应build的产物进行test，那么我们可以使用Github actions Artifact 可以用来存储action生产出来的产物。<a href="https://docs.github.com/en/actions/using-workflows/storing-workflow-data-as-artifacts">官方文档</a>上有比较详细的说明,同时也有别的<a href="https://cloud.tencent.com/developer/article/1983976">学习资料</a>以及<a href="https://www.cnblogs.com/kklldog/p/github-actions-artifact.html">优质博文</a>。</p><pre class="line-numbers language-yml"><code class="language-yml">  - name: Archive production artifacts    uses: actions/upload-artifact@v4    with:      name: dist-without-markdown      path: |        dist        !dist/**/*.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，你upload后是不能直接用的，还得配合download下载使用(注意也要指定path，官方实例里面没给)，然后指定需要的path，<a href="https://github.com/actions/download-artifact">download的官方文档</a>在这里。</p><pre class="line-numbers language-yml"><code class="language-yml">- name: Download a single artifact  uses: actions/download-artifact@v4  with:    name: dist-without-markdown<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>需要强烈注意的是，<code>这个path是相对repository的路径</code>，所以不要觉得这个上传的path是相对working-directory的。也就是不需要再去加<code>$</code>前缀，否则就会像我一样疯狂报错不知道哪出了问题。</p><p><img src="/posts/52642/image-20240522204936524.png" alt="仔细看下载的路径thread-pool重复了两次"></p><p>所以修改路径后就能正常下载了</p><pre class="line-numbers language-yml"><code class="language-yml">    - name: Download artifacts      uses: actions/download-artifact@v4      with:        name: packing-tests        path: build/test/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/52642/image-20240522210126442.png" alt="修改后"></p><h3 id="path和actions-checkout-v4"><a href="#path和actions-checkout-v4" class="headerlink" title="path和actions/checkout@v4"></a>path和actions/checkout@v4</h3><p>首先又把checkout的<a href="https://github.com/actions/checkout/tree/v4/">文档</a>放在这里，为什么我每次都找不到对应的路径，原来是复制的时候多复制了actions/checkout@v4，作用于checkout，相当于又切回去了最原始的提交，相当于变回去了，一开始不知道在调用test的时候把这个uses上了，于是每次最后调用测试的时候都切回原始状态(难蚌)。</p><p><img src="/posts/52642/image-20240522210822399.png" alt="报错"></p><p>同时下载下来的文件是没有运行权限的，记得修改一下权限：</p><p><img src="/posts/52642/53781919a4de454935e853c0c7163914.png" alt></p><p>试错了很多次终于搞定了，期间改了不少次架构，最后CI集成了还是舒服的。</p><p><img src="/posts/52642/1bf728cbcfa59126a6dbf6645ff3dc7b.png" alt></p><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>每次都要等gcc和boost安装比较耗费时间，不知道有没有方法能够生成一个环境(除了自己搞个docker image)，每次actions直接去环境里面进行即可就好了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;首先先把github action的文档放在&lt;a href=&quot;https://docs.github.com/zh/actions&quot;&gt;这里&lt;
      
    
    </summary>
    
    
      <category term="生产环境" scheme="https://JoyTsing.github.io/categories/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="生产环境" scheme="https://JoyTsing.github.io/tags/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
  <entry>
    <title>如何让clangd支持makefile工程</title>
    <link href="https://joytsing.github.io/posts/26828/"/>
    <id>https://joytsing.github.io/posts/26828/</id>
    <published>2024-05-20T08:59:52.000Z</published>
    <updated>2024-05-20T09:31:06.111Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>使用cmake的时候用vscode带的ninja进行build的时候会自动生成<code>compile_commands.json</code>，一切都是自动化的，此时clangd就能通过<code>compile_commands.json</code>知道我们工程自定义的头文件和源文件位置在哪，同时也就没有烦人的红波浪线，但是如果我们使用的是make呢？</p><h2 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h2><p>CMake维护的工程生成json文件非常简单。</p><pre><code>cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON .</code></pre><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p>很多工程并不会使用CMake维护，同时它们的Makefile可读性比较差，但是目前我们关键是让clangd不会再报错，问题就转化成了如何生成<code>compile_commands.json</code>。这里可以使用Bear工具生成json文件：</p><h2 id="bear"><a href="#bear" class="headerlink" title="bear"></a>bear</h2><p>ubuntu下可以这样操作</p><pre><code>sudo apt install bearbear bear -- make -j8(或者其他参数)</code></pre><p>这样就会bear就会拦截make命令，自动在所有目录生成<code>compile_commands.json</code>，同时我们的clangd也不会再报错了，可喜可贺。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;使用cmake的时候用vscode带的ninja进行build的时候会自动生成&lt;code&gt;compile_commands.json&lt;/co
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>浅析协程与线程与进程的区别和联系</title>
    <link href="https://joytsing.github.io/posts/37357/"/>
    <id>https://joytsing.github.io/posts/37357/</id>
    <published>2024-05-19T15:39:41.000Z</published>
    <updated>2024-05-19T15:50:07.253Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h2><p>内核线程只运行在内核态，不受用户态上下文的拖累。</p><ul><li>处理器竞争：可以在全系统范围内竞争处理器资源；</li><li>使用资源：唯一使用的资源是内核栈和上下文切换时保持寄存器的空间</li><li>调度：调度的开销可能和进程自身差不多昂贵</li><li>同步效率：资源的同步和数据共享比整个进程的数据同步和共享要低一些。</li></ul><h2 id="轻量级进程"><a href="#轻量级进程" class="headerlink" title="轻量级进程"></a>轻量级进程</h2><p>轻量级进程(LWP)是建立在内核之上并由内核支持的用户线程，它是内核线程的高度抽象，每一个轻量级进程都与一个特定的内核线程关联。内核线程只能由内核管理并像普通进程一样被调度。</p><p>轻量级进程由clone()系统调用创建，参数是CLONE_VM，即与父进程是共享进程地址空间和系统资源。</p><p>与普通进程区别：LWP只有一个最小的执行上下文和调度程序所需的统计信息。</p><ul><li>处理器竞争：因与特定内核线程关联，因此可以在全系统范围内竞争处理器资源</li><li>使用资源：与父进程共享进程地址空间</li><li>调度：像普通进程一样调度</li></ul><h3 id="Linux使用的线程库"><a href="#Linux使用的线程库" class="headerlink" title="Linux使用的线程库"></a>Linux使用的线程库</h3><p>LinuxThreads是用户空间的线程库，所采用的是线程-进程1对1模型(即一个用户线程对应一个轻量级进程，而一个轻量级进程对应一个特定 的内核线程)，将线程的调度等同于进程的调度，调度交由内核完成，而线程的创建、同步、销毁由核外线程库完成（LinuxThtreads已绑定到 GLIBC中发行）。</p><p>在LinuxThreads中，由专门的一个管理线程处理所有的线程管理工作。当进程第一次调用pthread_create()创建线程时就会先 创建(clone())并启动管理线程。后续进程pthread_create()创建线程时，都是管理线程作为pthread_create()的调用 者的子线程，通过调用clone()来创建用户线程，并记录轻量级进程号和线程id的映射关系，因此，用户线程其实是管理线程的子线程。</p><p>LinuxThreads只支持调度范围为PTHREAD_SCOPE_SYSTEM的调度，默认的调度策略是SCHED_OTHER。</p><p>用户线程调度策略也可修改成SCHED_FIFO或SCHED_RR方式，这两种方式支持优先级为0-99,而SCHED_OTHER只支持0。</p><ul><li>SCHED_OTHER 分时调度策略，</li><li>SCHED_FIFO  实时调度策略，先到先服务</li><li>SCHED_RR   实时调度策略，时间片轮转</li></ul><p>SCHED_OTHER是普通进程的，后两个是实时进程的（一般的进程都是普通进程，系统中出现实时进程的机会很少）。SCHED_FIFO、 SCHED_RR优先级高于所有SCHED_OTHER的进程，所以只要他们能够运行，在他们运行完之前，所有SCHED_OTHER的进程的都没有得到 执行的机会。</p><h2 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h2><p>用户线程是完全建立在用户空间的线程库，用户线程的创建、调度、同步和销毁全又库函数在用户空间完成，不需要内核的帮助。因此这种线程是极其低消耗和高效的。</p><ul><li>处理器竞争：单纯的用户线程是建立在用户空间，其对内核是透明的，因此其所属进程单独参与处理器的竞争，而进程的所有线程参与竞争该进程的资源。</li><li>使用资源：与所属进程共享进程地址空间和系统资源。</li><li>调度：由在用户空间实现的线程库，在所属进程内进行调度</li></ul><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p><a href="https://joytsing.cn/posts/21849/">什么是协程</a>，协程，又称微线程，是一种用户态的轻量级线程，一个线程可以有多个协程。协程的调度完全由用户控制（也就是在用户态执行）。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到线程的堆区，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以协程的上下文切换非常快。</p><p>协程抽象于线程之上，线程是被分割的CPU资源, 协程是组织好的代码流程, 协程需要线程来承载运行。与线程相比，协程占用资源小，由用户调度，切换开销小，同一个线程中的协程不需要使用锁，执行效率更高。</p><h2 id="进程、线程和协程的区别是什么？"><a href="#进程、线程和协程的区别是什么？" class="headerlink" title="进程、线程和协程的区别是什么？"></a>进程、线程和协程的区别是什么？</h2><p>进程是资源分配的最小单位，每个进程都有自己的独立内存空间，进程由进程控制块、程序段和数据段组成。</p><ul><li>进程控制块（PCB）保存进程运行期间相关的数据，是进程存在的唯一标志。</li><li>程序段是能被进程调度程序调度到CPU 运行的程序的代码段。</li><li>数据段用来存储程序运行期间的相关数据。</li></ul><p>进程是应用程序运行的载体，可看做是正在执行的程序。程序本身是没有生命周期的，只是存在于磁盘上的一些指令集合，但程序一旦被运行起来就是进程。启动后的进程，会依赖操作系统的调度完成生命周期的转换。由于每个进程都有独立的代码和数据空间，所以进程间的切换会有较大的开销。</p><p>线程是CPU任务调度和执行的最小单位，一个进程中可以包含多个线程，这些线程可以并发运行，且共享进程提供的相同的代码和数据空间，每个线程都有自己独立的运行栈和程序计数器，线程间切换的开销小。</p><p>协程，又称微线程，是一种用户态的轻量级线程，一个线程可以有多个协程。协程的调度完全由用户控制（也就是在用户态执行）。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到线程的堆区，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以协程的上下文切换非常快。</p><p>线程在进程的内部，它不能独立执行，必须依存于进程中，由进程提供多个线程的执行控制，进程和线程都可以并发的执行。</p><p>协程抽象于线程之上，线程是被分割的CPU资源, 协程是组织好的代码流程, 协程需要线程来承载运行。与线程相比，协程占用资源小，由用户调度，切换开销小，同一个线程中的协程不需要使用锁，执行效率更高。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;内核线程&quot;&gt;&lt;a href=&quot;#内核线程&quot; class=&quot;headerlink&quot; title=&quot;内核线程&quot;&gt;&lt;/a&gt;内核线程&lt;/h2&gt;&lt;p&gt;内核线程只运行在内核态，不受用户态上下文的拖累。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处理器竞争：可以在全系统范围内竞争处理器资源；&lt;
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://JoyTsing.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
      <category term="C" scheme="https://JoyTsing.github.io/tags/C/"/>
    
      <category term="操作系统" scheme="https://JoyTsing.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Cpp中的ABI探究</title>
    <link href="https://joytsing.github.io/posts/27828/"/>
    <id>https://joytsing.github.io/posts/27828/</id>
    <published>2024-05-18T08:07:59.000Z</published>
    <updated>2024-05-18T08:24:56.597Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Application Binary Interface 也就是我们常说的 ABI，是个让人感觉到既熟悉又陌生的概念。熟悉在哪里？讨论问题的时候经常会讨论到它，看文章的时候经常会提到它，有时候又要处理它导致的兼容性。陌生在哪里？如果有人问你什么是 ABI，你会发现你知道它是怎么一回事，但是要用严谨的语言去描述它有些困难。最后只好照着 WIKI 说：ABI 就是两个二进制程序模块之间的接口。有问题吗？没有问题，但是回答了跟没有回答一样。</p><p>软件工程讲究分层，对于一个 C++ 程序的 ABI 来说，我们也可以从下面这五个层次来看待。</p><h2 id="CPU-amp-OS"><a href="#CPU-amp-OS" class="headerlink" title="CPU &amp; OS"></a>CPU &amp; OS</h2><p>最终的可执行文件最后都是要运行在特定 CPU 上的特定操作系统的。如果 CPU 的指令集不同，那肯定会导致二进制不兼容，比如 ARM 上的程序没法<strong>直接</strong>运行在 x64 处理器上（除非借助一些虚拟化技术）。如果指令集兼容呢？比如 x64 处理器就兼容 x86 的指令集，那 x86 程序一定能运行在 x64 操作系统上吗？这时候就要看操作系统了，具体来说，要考虑到 <strong>Object File Format</strong>（目标文件格式），<strong>Data Representation</strong>（数据表示）， <strong>Function Calling Convention</strong>（函数调用约定）和 <strong>Runtime Library</strong>（运行时库）等因素。这几点就可以看做是操作系统层面的 ABI 规定。第四点我们后面有专门的一节来讨论，下面以 x64 平台为例，就前三点进行讨论。</p><blockquote><p>x64, x86-64, x86_64, AMD64 和 Intel 64 是一个意思，都是指 x86 指令集的 64 位版本。</p></blockquote><p><strong>x64 平台上主要有两套常用的 ABI</strong>：</p><ul><li>用于 64 位 Windows 操作系统上的 Windows x64 ABI</li><li>用于 64 位 Linux 以及一众 UNIX-like 的操作系统上的 x86-64 System V ABI</li></ul><p>而从一个动态库里面调用某个函数可以简单的看成下面这个三个步骤：</p><ul><li>按照某种格式解析动态库</li><li>根据符号名从解析结果中查找函数地址</li><li>函数参数传递，调用函数</li></ul><h3 id="Object-File-Format"><a href="#Object-File-Format" class="headerlink" title="Object File Format"></a>Object File Format</h3><p>以何种格式解析动态库？这就是 ABI 中对 Object File Format 的规定起作用的地方了。如果你希望自己写一个链接器，那么最后生成的可执行文件就需要满足对应平台的格式要求。Windows x64 使用的可执行文件格式是 <a href="https://learn.microsoft.com/en-us/windows/win32/debug/pe-format">PE32+</a> ，也就是 PE32（Portable Executable 32-bit）格式的<code>64</code>位版本。System V ABI 使用的则是 <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">ELF（Executable Linkable Format）</a> 格式的可执行文件。通过使用一些 parse 库（当然感兴趣的话也可以自己写），例如 pe-parse 和 elfio，对实际的可执行文件进行解析，得到其中的符号表，我们便能拿到函数名与函数地址的映射关系了。</p><h3 id="Data-Representation"><a href="#Data-Representation" class="headerlink" title="Data Representation"></a>Data Representation</h3><p>拿到函数地址之后，接下来就是怎么进行调用了。在调用之前，首先得传参对吧。那传参的时候就特别要注意 Data Representation（数据表示）表示的一致性，什么意思呢？</p><p>假设我把下面这个文件编译成动态库</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> X<span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">int</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span>X x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> x<span class="token punctuation">.</span>a <span class="token operator">+</span> x<span class="token punctuation">.</span>b<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果后续版本升级导致结构体内容发生变动了，用户代码里面看到的结构体定义变成了</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> X<span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">int</span> b<span class="token punctuation">;</span>    <span class="token keyword">int</span> c<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后仍然去尝试链接旧版本代码编译出的动态库，并调用里面的函数</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>能成功吗？当然会失败了，这种错误可以看成所谓的 ODR（One Definition Rule）违反。</p><p>上面的情况属于用户主动变更代码导致的 ODR 违反，那如果我不主动变更代码，能确保结构体布局的稳定性吗？那这就由 ABI 中 Data Representation 来进行相关保证了。例如：规定一些基础类型的大小和对齐， Windows x64 规定<code>long</code>是<code>32</code>位，而 System V 则规定<code>long</code>是<code>64</code>位。规定<code>struct</code>和<code>union</code>的大小和对齐等等。</p><blockquote><p>注意 C 语言标准仍然是不规定 ABI 的，对于 System V ABI 来说，其主要使用 C 语言的术语和概念编写，所以可以认为提供了针对 C 语言的 ABI。而 Windows x64 ABI 在 C 和 C++ 之间并没有太过明显的界限。</p></blockquote><h3 id="Function-Calling-Convention"><a href="#Function-Calling-Convention" class="headerlink" title="Function Calling Convention"></a>Function Calling Convention</h3><p>接下来就到函数传参这一步了。我们知道，函数不过就是一段二进制数据，执行函数其实就是跳转到函数的入口地址，然后执行那一段代码，最后执行完了再跳转回来就行了。而传参无非就是找一块地方，存放数据，<strong>使得调用前后都能访问到这个地方来取数据</strong>。有哪些位置可以选择呢？主要有下面四个选项：</p><ul><li>global（全局变量）</li><li>heap（堆）</li><li>register（寄存器）</li><li>stack（栈）</li></ul><p>使用全局变量进行传参，听起来很魔幻，实际上平常写代码的时候经常把一些需要反复传递的参数改成全局变量，例如<code>config</code>这种的。但是，显然不是所有参数都适合使用全局变量传参，如果考虑到线程安全就要更加注意了。</p><p>使用堆进行传参，似乎也很不可思议，但其实 C++20 加入的无栈协程就把协程的状态（函数参数，局部变量）保存在堆上。不过对于普通的函数调用来说，如果每次传参都要动态内存分配，确实有些奢侈了。</p><p>所以我们主要还是考虑使用寄存器和栈进行传参。多一种选择总是好的，但是在这里并不好。如果调用方觉得应该使用寄存器传参，于是把参数存到寄存器里面去了。而被调用方觉得应该使用栈传参，所以取数据的时候是从栈里面取的。不一致就出现了，很可能从栈里面独到的就是垃圾值，导致代码逻辑错误，程序直接崩溃。</p><p>如何保证调用方和被调用方传参的位置一致呢？相信你已经猜到了，这就是 Function Calling Convention（函数调用约定）发挥作用的地方。</p><p>具体来说，调用约定规定下面这些内容：</p><ul><li>函数参数传递顺序，从左到右还是从右到左？</li><li>函数参数和返回值传递的方式，通过栈还是寄存器？</li><li>哪些寄存器在调用者调用前后是保持不变的？</li><li>谁负责清理栈帧，调用者还是被调用者？</li><li><code>...</code></li></ul><p>在<code>32</code>位程序中，有很多调用约定，像什么<code>__cdecl</code>，<code>__stdcall</code>，<code>__fastcall</code>，<code>__thiscall</code>等等，当时的程序可谓是饱受兼容性之苦。而在<code>64</code>位程序中，已经基本完成统一。主要有两种调用约定，也就是 Windows x64 ABI 和 x86-64 System V ABI 分别规定的调用约定（不过并没有个正式的名字）。<strong>需要强调的是函数传参方式只和调用约定有关，和代码优化等级无关。你也不想不同优化等级编译出来的代码，链接到一起之后跑不起来吧。</strong></p><p>介绍具体的规定是有些无聊的，感兴趣的读者可以自行查阅对应文档的相关小节，下面主要讨论一些比较有意思的话题。</p><blockquote><p>注意：下面这些讨论只适用于函数调用实际发生的情况，如果函数被完全内联，函数传参这一行为并不会发生。目前 C++ 代码的内联优化主要发生在同一编译单元内（单个文件），对于跨编译单元的代码，必须要打开 LTO（Link Time Optimization）才行，跨动态库的代码目前还不能内联。</p></blockquote><ul><li><strong>小于<code>16</code>字节大小的结构体值传递效率比引用效率更高</strong></li></ul><p>这个说法由来已久，但是我始终没有找到依据。终于，最近在研究调用约定的时候，让我找到原因了。首先如果结构体大小小于等于<code>8</code>字节，那么可以直接塞进一个<code>64</code>位寄存器里面传参，<strong>通过寄存器传参比通过引用传参要少几次访存</strong>，效率要高一些，没什么问题。那对于<code>16</code>字节呢？System V ABI 允许将一个<code>16</code>字节大小的结构体拆两个<code>8</code>个字节的部分，然后分别使用寄存器传递。那么在这种情况下传值确实比传引用要高一些，观察下面的 <a href="https://godbolt.org/z/5Ph34x1cK">代码</a></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span><span class="token keyword">struct</span> X <span class="token punctuation">{</span>    size_t x<span class="token punctuation">;</span>    size_t y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token keyword">const</span> X<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// pass by value</span>    <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// pass by reference</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后生成的代码如下所示</p><pre class="line-numbers language-nasm"><code class="language-nasm"><span class="token label function">main:</span>        sub     <span class="token register variable">rsp</span>, <span class="token number">24</span>        mov     <span class="token register variable">edi</span>, <span class="token number">1</span>        mov     <span class="token register variable">esi</span>, <span class="token number">2</span>         call    f(X)        movdqa  <span class="token register variable">xmm0</span>, XMMWORD PTR .LC0<span class="token operator">[</span>rip<span class="token operator">]</span>        mov     <span class="token register variable">rdi</span>, <span class="token register variable">rsp</span>        movaps  XMMWORD PTR <span class="token operator">[</span><span class="token register variable">rsp</span><span class="token operator">]</span>, <span class="token register variable">xmm0</span>        call    g(X const<span class="token operator">&amp;</span>)        xor     <span class="token register variable">eax</span>, <span class="token register variable">eax</span>        add     <span class="token register variable">rsp</span>, <span class="token number">24</span>        ret<span class="token label function">.LC0:</span>        .quad   <span class="token number">1</span>        .quad   <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>System V ABI 规定了前六个整形参数，依次可以使用<code>rdi</code>，<code>rsi</code>，<code>rdx</code>，<code>rcx</code>，<code>r8</code>，<code>r9</code>寄存器传递，而 Windows x64 ABI 规定了前四个整形参数，依次可以使用<code>rcx</code>，<code>rdx</code>，<code>r8</code>，<code>r9</code>寄存器传递。如果过寄存器用完了，就通过栈传递。整形参数即<code>char</code>，<code>short</code>，<code>int</code>，<code>long</code>，<code>long long</code>等基础整数类型外加指针类型。浮点参数和 SIMD 类型的参数则有专门的寄存器负责，这里不过多涉及了。</p></blockquote><p>可以发现<code>1</code>,<code>2</code>分别通过寄存器<code>edi</code>和<code>esi</code>传递给了<code>f</code>函数，而<code>g</code>则是把临时变量的地址传递给了<code>g</code>函数。但是这只是 System V ABI，对于 Windows x64 ABI 来说，<strong>只要结构体的大小大于<code>8</code>字节，只能通过引用传递。</strong>同样的代码，在 Windows 上编译的结果如下</p><pre class="line-numbers language-nasm"><code class="language-nasm"><span class="token label function">main:</span>        sub     <span class="token register variable">rsp</span>, <span class="token number">56</span>                                     lea     <span class="token register variable">rcx</span>, QWORD PTR <span class="token operator">[</span><span class="token register variable">rsp</span><span class="token operator">+</span><span class="token number">32</span><span class="token operator">]</span>        mov     QWORD PTR <span class="token operator">[</span><span class="token register variable">rsp</span><span class="token operator">+</span><span class="token number">32</span><span class="token operator">]</span>, <span class="token number">1</span>        mov     QWORD PTR <span class="token operator">[</span><span class="token register variable">rsp</span><span class="token operator">+</span><span class="token number">40</span><span class="token operator">]</span>, <span class="token number">2</span>        call    void f(X)                           lea     <span class="token register variable">rcx</span>, QWORD PTR <span class="token operator">[</span><span class="token register variable">rsp</span><span class="token operator">+</span><span class="token number">32</span><span class="token operator">]</span>        mov     QWORD PTR <span class="token operator">[</span><span class="token register variable">rsp</span><span class="token operator">+</span><span class="token number">32</span><span class="token operator">]</span>, <span class="token number">1</span>        mov     QWORD PTR <span class="token operator">[</span><span class="token register variable">rsp</span><span class="token operator">+</span><span class="token number">40</span><span class="token operator">]</span>, <span class="token number">2</span>        call    void g(X const <span class="token operator">&amp;</span>)        xor     <span class="token register variable">eax</span>, <span class="token register variable">eax</span>        add     <span class="token register variable">rsp</span>, <span class="token number">56</span>                                ret     <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到两次函数调用产生的代码完全相同，也就是说对于 Windows x64 ABI 来说，大于<code>8</code>字节的结构体无论是通过引用传递还是值传递，生成的代码都是一样的。</p><ul><li><strong>unique_ptr 和 raw_ptr 的效率</strong></li></ul><p><code>unique_ptr</code>只是对裸指针简单包装一层嘛，所以他们效率应该一致？ CPPCON 上 <a href="https://www.bilibili.com/video/BV1qp421y75W/?spm_id_from=333.999.0.0">There are no zero-cost abstractions</a> 就讨论这个问题。这里不谈异常导致的额外开销（析构函数导致编译器必须额外生成清理栈帧的代码），仅仅讨论一个 C++ 对象（小于<code>8</code>字节）能使用寄存器传参吗？对于一个完全 <a href="https://en.cppreference.com/w/cpp/language/classes#Trivial_class">trivial</a> 的类型来说，是没问题的，它表现得和一个 C 语言的结构体几乎完全一样。但是如果不满足呢？</p><p>比如自定义了拷贝构造函数，还能放寄存器里面吗？其实从逻辑上就不能，为什么呢？C++ 是允许我们对函数参数取地址的，那如果参数是整形，那么它通过寄存器传参，那取地址的结果哪里来的呢？实验一下，就知道了</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>生成的对应汇编如下</p><pre class="line-numbers language-nasm"><code class="language-nasm">g(int):        sub     <span class="token register variable">rsp</span>, <span class="token number">24</span>        mov     DWORD PTR <span class="token operator">[</span><span class="token register variable">rsp</span><span class="token operator">+</span><span class="token number">12</span><span class="token operator">]</span>, <span class="token register variable">edi</span>        lea     <span class="token register variable">rdi</span>, <span class="token operator">[</span><span class="token register variable">rsp</span><span class="token operator">+</span><span class="token number">12</span><span class="token operator">]</span>        call    f(int<span class="token operator">&amp;</span>)        mov     <span class="token register variable">eax</span>, DWORD PTR <span class="token operator">[</span><span class="token register variable">rsp</span><span class="token operator">+</span><span class="token number">12</span><span class="token operator">]</span>        add     <span class="token register variable">rsp</span>, <span class="token number">24</span>        ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现，这里把<code>edi</code>（用于传递第一个整形参数）里面的值拷贝到了 <code>rsp+12</code> 这个地址，也就是栈上，之后把这个地址传递给了<code>f</code>。也就是说，如果一个函数参数通过寄存器传递，如果在某些情况下需要它的地址，编译器会把这个参数拷贝到栈上。<strong>但是无论如何，用户是观察不到这些拷贝过程的，因为它们的拷贝构造函数是<code>trivial</code>的。不影响最终代码执行结果的任何优化都是符合 as if 原则的。</strong></p><p>那么如果这个对象有用户定义的拷贝构造函数，假设参数通过寄存器传递，就可能会导致额外的拷贝构造函数调用，并且用户可以观察到这个副作用。显然这是不合理的，所以不允许拥有自定义拷贝构造函数的对象通过寄存器传参，那通过栈传递呢？实际上也会遇到类似的拷贝困境。于是最终这类对象只能通过引用传递了。<strong>注意，给拷贝构造显式标记为<code>delete</code>也算是自定义拷贝构造函数。</strong></p><p>所以对于<code>unique_ptr</code>来说，只能通过引用传递，无论你函数签名写成<code>void f(unique_ptr&lt;int&gt;)</code>还是<code>void f(unique_ptr&lt;int&gt;&amp;)</code>，最后在传参处生成的二进制代码都是一样的。但是裸指针却可以通过寄存器安全的传递。综上所述，<code>unique_ptr</code>和裸指针的效率并不是完全一致的。</p><blockquote><p>实际上对于一个非 trivial 的 C++ 对象，究竟能否使用寄存器传参的实际情况更复杂一些，相关的内容参考对应 ABI 中的相关小节，这里不过多描述。另外 C++ 对象如何传递这部分规定，究竟属于操作系统的 ABI 还是 C++ 编译器 ABI 这个问题也并不是很明确。</p></blockquote><h2 id="C-Standard"><a href="#C-Standard" class="headerlink" title="C++ Standard"></a>C++ Standard</h2><p>终于说完了操作系统层面的保证，由于偏向底层，涉及到较多汇编，对于不那么熟悉汇编的读者，读起来可能有些困难。不过接下来的内容基本就和汇编没什么关系了，可以放心阅读。</p><p>我们都知道 C++ 标准没有明确规定 ABI，但并不是完全没有规定，它对于编译器的实现是有一些要求的，例如：</p><ul><li>结构体成员地址按照声明顺序 <a href="https://en.cppreference.com/w/c/language/struct#Explanation">递增</a>，这保证了编译器不会对结构体成员进行重新排序</li><li>满足 <a href="https://en.cppreference.com/w/cpp/language/data_members#Standard-layout">Standard Layout</a> 约束的结构体需要与相应的 C 结构体布局兼容</li><li>满足 <a href="https://en.cppreference.com/w/cpp/types/is_trivially_copyable">Trivially Copyable</a> 约束的结构体可以使用<code>memmove</code>或者<code>memcpy</code>进行拷贝得到一个完全相同的全新对象</li><li><code>...</code></li></ul><p>另外，由于 C++ 一直在推出新的版本。同一份代码，我使用新标准和旧标准分别进行编译，得到的结果相同吗（不考虑使用宏控制 C++ 版本进行条件编译的影响）？这就要看 C++ 标准层面对 ABI 兼容性的保证了，事实上，C++ 标准尽可能的保证<strong>向后兼容性</strong>。也就是说，两段代码，使用旧标准和新标准编译出来的代码是完全一样的。</p><p>然而，也有极少数的例外，例如（我只找得到这些，欢迎评论区补充）：</p><ul><li>C++17 把<code>noexcept</code>作为函数类型的一部分，这会影响函数最后生成的 mangling name</li><li>C++20 引入的<code>no_unique_address</code>，MSVC 目前仍然没直接支持，因为会导致 ABI Broken</li></ul><p>更多时候，C++ 新版本会在加入新的语言特性的同时带来新的 ABI，而不会影响旧的代码，例如 C++23 加入的两个新特性：</p><h3 id="Explicit-Object-Parameter"><a href="#Explicit-Object-Parameter" class="headerlink" title="Explicit Object Parameter"></a><a href="https://en.cppreference.com/w/cpp/language/member_functions#Explicit_object_parameter">Explicit Object Parameter</a></h3><p>在 C++23 之前，事实上没有<strong>合法</strong>的手段获取一个成员函数的地址，我们唯一能做的就是获取成员指针（关于成员指针是什么，可以参考这篇 <a href="https://zhuanlan.zhihu.com/p/659510753">文章</a> 的内容）</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> X <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">auto</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>X<span class="token operator">::</span>f<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// p is a pointer to member function of X</span><span class="token comment" spellcheck="true">// type of p is void (X::*)(int)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>想要获取使用成员函数作为回调函数，只能使用 lambda 表达式包装一层</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> X <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">using</span> Fn <span class="token operator">=</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>X<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Fn p <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>A<span class="token operator">*</span> self<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> self<span class="token operator">-</span><span class="token operator">></span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这其实很麻烦，没有任何必要，而且这层包装可能会导致额外的函数调用开销。某种程度上这算是个历史遗留问题，<code>32</code>位系统上对成员函数的调用约定有些特殊（广为人知的<code>thiscall</code>），而 C++ 中并没有调用约定相关的内容，所以搞了个成员函数指针这么个东西。旧的代码为了 ABI 兼容性已经无法改变，但是新的可以，C++23 加入了显式对象参数，我们现在可以明确<code>this</code>的传入方式了，甚至可以使用值传递</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> X <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 这里的 this 只是个标记作用，为了和旧语法区分开来</span>    <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">this</span> X self<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// pass by value</span>    <span class="token keyword">void</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token keyword">this</span> X<span class="token operator">&amp;</span> self<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// pass by reference</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>被显式<code>this</code>标记的函数也可以直接获取函数地址了，就和普通的函数一样</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token operator">&amp;</span>X<span class="token operator">::</span>f<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// type of f is void(*)(X, int)</span><span class="token keyword">auto</span> g <span class="token operator">=</span> <span class="token operator">&amp;</span>X<span class="token operator">::</span>g<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// type of g is void(*)(X*, int)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>所以新代码可以都采用这种写法，只有好处，没有坏处。</p><h3 id="Static-Operator"><a href="#Static-Operator" class="headerlink" title="Static Operator()"></a><a href="https://en.cppreference.com/w/cpp/feature_test#cpp_static_call_operator">Static Operator()</a></h3><p>标准库中有一些仿函数，里面什么成员都没有，只有一个<code>operator()</code>，例如<code>std::hash</code></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">struct</span> hash <span class="token punctuation">{</span>    std<span class="token operator">::</span>size_t <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>T <span class="token keyword">const</span><span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>尽管这是个空的结构体，但是由于<code>operator()</code>是成员函数，所以有一个隐式<code>this</code>参数。在非内联调用的情况下仍然需要传递一个无用的空指针。这个问题在 C++23 中得到了解决，可以直接定义<code>static operator()</code>，从而避免这个问题</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">struct</span> hash <span class="token punctuation">{</span>    <span class="token keyword">static</span> std<span class="token operator">::</span>size_t <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>T <span class="token keyword">const</span><span class="token operator">&amp;</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>static</code>也就意味着这是个静态函数了，使用上还是和原来一样</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>hash<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> h<span class="token punctuation">;</span>std<span class="token operator">::</span>size_t n <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>但这里只是拿<code>hash</code>举个例子，实际上标准库的代码为了 ABI 兼容性已经不会改动了。新代码可以使用这个特性，来避免不必要的<code>this</code>传递。</p><h2 id="Compiler-Specific"><a href="#Compiler-Specific" class="headerlink" title="Compiler Specific"></a>Compiler Specific</h2><p>接下来就到了重头戏了，实现定义的部分，这部分似乎是被人诟病最多的内容了。然而事实真的如此吗？让我们一点点往下看。</p><h3 id="De-Facto-Standard"><a href="#De-Facto-Standard" class="headerlink" title="De Facto Standard"></a>De Facto Standard</h3><p>C++ 中的一些抽象最终是要落实到实现上的，而标准有没有规定如何实现，那这部分内容就由编译器自由发挥，例如：</p><ul><li>name mangling 的规则（为了实现函数重载和模板函数）</li><li>复杂类型的布局（例如含有虚继承）</li><li>虚函数表的布局</li><li>RTTI 的实现</li><li>异常处理</li><li><code>...</code></li></ul><p>如果编译器对这些部分的实现不同，那么最后不同编译器编译出的二进制产物自然是互不兼容，不能混用的。</p><blockquote><p>在上世纪<code>90</code>年代，那时候还是 C++ 发展的黄金时期，各个厂商都致力于实现自己的编译器并扩大基本盘，争夺用户。出于竞争关系，不同编译器之间使用不同的 ABI 是很常见的行为。随着时代的发展，它们中的大多数已经退出了历史舞台，要么停止更新，要么仅做维护，不再跟进 C++ 的新标准。浪潮过后，留下的只有 GCC，Clang 和 MSVC 这三大编译器。</p></blockquote><p>在今天，C++ 编译器的 ABI 已经基本得到统一，主流的 ABI 只有两套：</p><ul><li>Itanium C++ ABI，具有公开透明的文档</li><li>MSVC C++ ABI，并没有官方的文档</li></ul><blockquote><p>尽管名为 Itanium C++ ABI，但它实际上是用于 C++ 的跨架构 ABI，除了 MSVC 之外，几乎所有的 C++ 编译器都在使用它，尽管在异常处理方面的细节略有不同。历史上，C++ 编译器都以各自的方式处理 C++ ABI。当英特尔大力推广 Itanium 时，他们希望避免不兼容问题，因此，他们为 Itanium 上的所有 C++ 供应商创建了一个标准化的 ABI。后来，由于各种原因，GCC 需要修改其内部 ABI，而且鉴于它已经支持了 Itanium ABI（为 Itanium 处理器），他们选择将 ABI 定义扩展到所有架构，而不是创建自己的 ABI。从那时起，所有主要的编译器除了 MSVC 都采用了跨架构的 Itanium ABI，并且即使 Itanium 处理器本身不再接收维护，该 ABI 仍然得到了维护。</p></blockquote><p>在 Linux 平台上，GCC 和 Clang 都使用 Itanium ABI，所以两个编译器编译出来的代码就具有互操作性，可以链接到一起并运行。而在 Windows 平台上，情况则稍微复杂些，默认的 MSVC 工具链使用自己的 ABI。但是除了 MSVC 工具链以外，还有人把 GCC 移植到 Windows 上了，也就是我们熟知的 <a href="https://www.mingw-w64.org//">MinGW</a> 工具链，它使用的仍然是 Itanium ABI。这两套 ABI 互不兼容，编译出来的代码不能直接链接到一起。而 Windows 平台上的 Clang 可以通过编译选项控制使用这两种 ABI 的其中的一种。</p><blockquote><p>注意：MinGW 既然在 Windows 上运行，那它生成的代码的调用约定自然是尽量遵守 Windows x64 ABI 的，最终生成的可执行文件格式也是 PE32+。但是它的使用的 C++ ABI 仍然是 Itanium ABI，这两者并没有必然关联。</p></blockquote><p>考虑到 C++ 巨大的 codebase，这两套 C++ ABI 已经基本稳定，不会再改动了，<strong>所以我们现在其实可以说 C++ 编译器具有稳定的 ABI</strong>。怎么样，是不是和网上主流的说法不同？但是事实的确就摆在这里。</p><blockquote><p>MSVC 从 <a href="https://learn.microsoft.com/en-us/cpp/porting/binary-compat-2015-2017?view=msvc-170">2015</a> 的版本往后开始保证 ABI 稳定。GCC 从 3.4 开始使用 Itanium ABI 并保证 ABI 稳定。</p></blockquote><h3 id="Workaround"><a href="#Workaround" class="headerlink" title="Workaround"></a>Workaround</h3><p>尽管基础的 ABI 不再改变，但是升级编译器版本仍然可能会导致编译出来的库发生 ABI Broken，为什么呢？</p><p>这其实不难理解，首先编译器也是软件，只要是软件就可能有 BUG。有时候为了修复 BUG，会被迫做出一些 ABI Broken（一般会在新版本的发行介绍中详细说明）。例如 GCC 有一个编译选项 <code>-fabi-version</code> 用于专门控制这些不同的版本，其中一些内容如下：</p><ul><li>版本<code>7</code>首次出现在 G++ 4.8 中，它将<code>nullptr_t</code>视为内建类型，并修正了默认参数作用域中 Lambda 表达式的名称编码</li><li>版本<code>8</code>首次出现在 G++ 4.9 中，修正了带有函数 CV 限定符的函数类型的替换行为</li><li>版本<code>9</code>首次出现在 G++ 5.2 中，修正了<code>nullptr_t</code>的对齐方式</li></ul><p>另外对于用户来说，也可能之前为了绕过编译器的 BUG，编写了一些特殊的代码，我们一般把这个叫做 workaround。当 BUG 被修复之后，这些 workaround 很可能起到反作用。从而导致 ABI 出现不兼容</p><h3 id="Important-Options"><a href="#Important-Options" class="headerlink" title="Important Options"></a>Important Options</h3><p>除此之外，编译器还提供了一些列选项用来控制编译器的行为，这些选项可能会影响 ABI，比如：</p><ul><li><code>-fno-strict-aliasing</code>：关闭严格别名</li><li><code>-fno-exceptions</code>：关闭异常</li><li><code>-fno-rtti</code>：关闭 RTTI</li><li><code>...</code></li></ul><p>给不同选项编译出来的库链接到一起的时候，尤其要兼容性问题。例如你的代码关闭了严格别名，但是依赖的外部库开启了严格别名，很可能指针错误的传播，从而导致程序出错。</p><p>我最近就遇到了这种情况，我在给 LLVM 的一些函数编写 Python Wrapper，通过 <a href="https://github.com/pybind/pybind11">pybind11</a>。而 pybind11 要求必须打开 RTTI，但是 LLVM 默认构建是关闭异常和 RTTI 的，所以最后代码就链接不到一块去了。一开始我是自己编译了一份开 RTTI 的 LLVM，这会导致二进制膨胀，后来发现没必要这样做。我其实没有用到 LLVM 里面类型的 RTTI 信息，只是由于写在同一个文件里面，编译器认为我用到了。于是把使用到 LLVM 部分的代码单独编译成一个动态库，再和使用 pybind11 部分的代码一起链接就解决了。</p><h2 id="Runtime-amp-Library"><a href="#Runtime-amp-Library" class="headerlink" title="Runtime &amp; Library"></a>Runtime &amp; Library</h2><p>这一小节主要讨论的就是，一个 C++ 程序依赖的库的 ABI 稳定性。<strong>理想情况下是，对于一个可执行程序，使用新版本的动态库替换旧版本的动态库，仍然不影响它运行。</strong></p><p>三大 C++ 编译器都有自己的标准库</p><ul><li>MSVC 对应的是 msvc stl</li><li>GCC 对应的是 libstdc++</li><li>Clang 对应的是 libc++</li></ul><p>我们在前面提到过，C++ 标准尽量保证 ABI 向后兼容。即使是从 C++98 到 C++11 这样的大更新，旧代码的 ABI 也没有受到太大影响，导致 ABI Break Change 的措辞改变更是完全找不到。</p><p>但是对于 C++ 标准库来说情况就有些不一样了，从 C++98 到 C++11，标准库经历了一次大的 ABI Break Change。标准库中修改了对一些容器实现的要求，例如<code>std::string</code>。这导致原来广泛使用的 COW 实现不符合新标准，于是在 C++11 中不得不采用新实现。这也就导致了 C++98 和 C++11 之间的标准库 ABI Broken。不过在这之后，标准库的 ABI 一般相对稳定，各家实现也尽量保证。</p><p>另外由于 RTTI 和 Exception 一般可以关掉，所以这两项功能可能由单独的运行时库来负责，比如 MSVC 的 vcruntime和 libc++ 的 libcxxabi。</p><blockquote><p>值得一提的是，libcxxabi 中还包含了对静态局部变量初始化的支持，涉及到的主要函数是 <strong>cxa_guard_acquire,</strong> cxa_guard_release。使用它们来保证静态局部变量只在运行时初始化一次，如果对具体的实现感到好奇，可以查阅相关源码。</p></blockquote><p>还有就是负责一些底层功能的运行时库，除了标准库以外，C++ 程序一般还需要链接 C 运行时：</p><ul><li>在 Windows 上，必须链接 CRT</li><li>在 Linux 上 取决于所使用的发行版和编译环境，可能会链接 glibc或者 musl</li></ul><p>C 运行时除了提供 C 标准库的实现外，还负责程序的初始化和清理。它负责调用<code>main</code>函数，并管理程序的启动和终止过程，包括执行一些必要的初始化和清理工作。对于大多数在操作系统上的软件来说，链接它是必须的。</p><p>最理想的状态自然是，升级编译器的时候把这些对应的运行时库版本也升级，避免不必要的麻烦。但是在实际项目中，依赖关系可能十分复杂，可能会引发连锁反应。</p><h2 id="User-Code"><a href="#User-Code" class="headerlink" title="User Code"></a>User Code</h2><p>最后我们来谈谈用户代码自身的改变导致的 ABI 问题，如果希望将你的库以二进制形式进行分发，那么当用户量达到一定程度之后，ABI 兼容性就很重要了。</p><p>在第一小节讨论调用约定的时候，就提到过变更结构体定义导致的 ABI 不兼容问题。那如果既想要保证 ABI 兼容，又想要为以后得扩展留下空间怎么办呢？答案就是在运行时处理了</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> X<span class="token punctuation">{</span>    size_t x<span class="token punctuation">;</span>    size_t y<span class="token punctuation">;</span>    <span class="token keyword">void</span><span class="token operator">*</span> reserved<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过一个<code>void*</code>指针为以后的扩展预留空间。可以根据它来判断不同的版本，比如</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>X<span class="token operator">*</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Reserved<span class="token operator">*</span> r <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Reserved<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token operator">></span>reserved<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token operator">-</span><span class="token operator">></span>version <span class="token operator">==</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// do something</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token operator">-</span><span class="token operator">></span>version <span class="token operator">==</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// do something else</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就能在添加新的功能的同时而不影响原有的代码。</p><p>在对外暴露接口的时候，对于函数参数中有自定义析构函数的类型，也要格外注意。假设我们要暴露<code>std::vector</code>作为返回值，例如把下面这个简单的代码编译成动态库，并且使用<code>\MT</code>选项来静态链接 Windows CRT。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">__declspec</span><span class="token punctuation">(</span>dllexport<span class="token punctuation">)</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后我们写一个源文件，链接到刚才编译的这个动态库，调用这个函数</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> vec <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译运行，发现直接崩溃了。如果关闭<code>\MT</code>重新编译一遍动态库，然后运行，发现一切正常。很奇怪，为什么依赖的动态库静态链接 CRT 会导致代码崩溃？</p><p>思考一下上面的代码不难发现，<code>vec</code>的构造实际上发生在动态库里面，而析构则是发生在<code>main</code>函数里面。更进一步，其实就是内存是在动态库里面分配的，释放是在<code>main</code>函数里面。但是每一份 CRT 都有自己的<code>malloc</code>，<code>free</code>（类似于不同进程间的内存）。<strong>你不能把 CRT A 分配的内存交给 CRT B 释放</strong>，这就是问题的根源。所以之后不静态链接到 CRT 就没事了，它们用的都是同一个<code>malloc</code>，<code>free</code>。不仅仅是 WIndows CRT，对于 Linux 上的 glibc 或者 musl 也是一样的。</p><h3 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h3><p>对于任何带有自定义析构函数的 C++ 类型都可能出现上面那种情况，<strong>由于种种原因，构造函数和析构函数的调用跨越动态库边界，RAII 的约定被打破，导致严重的错误。</strong></p><p>如何解决呢？那自然是函数参数和返回值都不使用带有析构函数的类型了，只使用 POD 类型。例如上面那个例子需要改成</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> Vec <span class="token operator">=</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token function">__declspec</span><span class="token punctuation">(</span>dllexport<span class="token punctuation">)</span> Vec <span class="token function">create_Vec</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">__declspec</span><span class="token punctuation">(</span>dllexport<span class="token punctuation">)</span> <span class="token keyword">void</span> <span class="token function">destroy_Vec</span><span class="token punctuation">(</span>Vec vec<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">delete</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>vec<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后使用就得这样</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> Vec <span class="token operator">=</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">;</span>Vec <span class="token function">create_Vec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">destroy_Vec</span><span class="token punctuation">(</span>Vec vec<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Vec vec <span class="token operator">=</span> <span class="token function">create_Vec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">destroy_Vec</span><span class="token punctuation">(</span>vec<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实我们就是在按照 C 风格的 RAII 来进行封装。更进一步，如果想要解决 C 和 C++ 由于 mangling 不同而导致的链接问题，可以使用<code>extern &quot;C&quot;</code>来修饰函数</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">extern</span> <span class="token string">"C"</span> <span class="token punctuation">{</span>    Vec <span class="token function">create_Vec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">destroy_Vec</span><span class="token punctuation">(</span>Vec vec<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样的话 C 语言也可以使用上述的导出函数了，但是如果代码量很大的话，把全部的函数都封装成这样的 API 显然不太现实，那就只能把 C++ 的类型暴露在导出接口中，然后小心地管理依赖项（比如所有依赖库全都静态链接）。具体选择哪一种方式，还是要看项目大小和复杂度，然后再做定夺。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>到这里，我们终于讨论完了影响 C++ 程序 ABI 的主要因素。可以清楚地看到，C++ 标准、编译器厂商和运行时库都在尽力维护 ABI 的稳定性，C++ ABI 并没有很多人说的那么不堪，那么不稳定。对于小型项目而言，带源码静态链接，几乎不会有任何的兼容性问题。对于那些历史悠久的大型项目来说，由于复杂的依赖关系，升级某些库的版本可能会导致程序崩溃。<strong>但这并不是 C++ 的错，对于大型项目的管理，早已超出了单纯的语言层面，不能指望通过更换编程语言来解决这些问题</strong>。实际上，学习软件工程就是在学习如何应对巨大的复杂度，如何保证复杂系统的稳定性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Application Binary Interface 也就是我们常说的 ABI，是个让人感觉到既熟悉又陌生的概念。熟悉在哪里？讨论问题的
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="读书笔记" scheme="https://JoyTsing.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>grpc与CMake中find_package()命令神奇的寻址</title>
    <link href="https://joytsing.github.io/posts/48298/"/>
    <id>https://joytsing.github.io/posts/48298/</id>
    <published>2024-05-17T12:33:13.000Z</published>
    <updated>2024-05-17T13:36:21.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>问题总是在你意想不到的地方出现。</p><h2 id="重启了个电脑怎么就报错了呢"><a href="#重启了个电脑怎么就报错了呢" class="headerlink" title="重启了个电脑怎么就报错了呢"></a>重启了个电脑怎么就报错了呢</h2><p>昨天还在用，更新了一下写了个</p><p><img src="/posts/48298/faf973679d56abb145795bcf0223f26d.png" alt="有毛病"></p><h2 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2><p>长话短说，我一开始以为是谷歌的锅，看了一圈issue还去Stack Overflow上差了发现没人遇到我这个问题，当时我就怀疑是不是版本的问题，然后我把版本号打出来一看20230802（没意识到用的是最新的absl）</p><p>在这之后去还去看了absl的abslTargets.cmake，确实是有的，那么其实可以知道不是谷歌的锅，肯定又是和之前protobuf一样的全局变量的问题，但是这次问题就诡异在我没有显示或者隐式的引入过任何absl的库，那么为什么会报错。</p><p><img src="/posts/48298/f1fbd7ec93ad84e5608ffe2dfdc16c1e.png" alt="确实有"></p><p>后面还下了最新的absl加入到全局环境变量里面也不行（太神奇了），到后面想到可以看它引用的库地址在哪，一看发现非常神秘的找到了我曾经make过的库，但是这个库和grpc库是同级的。</p><p><img src="/posts/48298/1e41604d21dcc682b4c454b5b2bcf652.png" alt="要不是我版本名字取错了我还真没意识到"></p><p>直接删掉一试，发现就好了。</p><p><img src="/posts/48298/06da1d76fb8edc247c1b6e2cf8229da7.png" alt="尝试修改"></p><p>通过编译。</p><p><img src="/posts/48298/8a5d98be8540f8c41a082bb8510cd364.png" alt="终于解决了"></p><p>那么为什么grpc库会找到同级目录下的其他absl？</p><p><img src="/posts/48298/5f8f7c535e66dbc0c3ca6aedb553afea.png" alt="原来是你"></p><h2 id="find-package-查找逻辑"><a href="#find-package-查找逻辑" class="headerlink" title="find_package()查找逻辑"></a>find_package()查找逻辑</h2><p>CMAKE<strong>先在CMAKE_MODULE_PATH变量对应的路径中查找。如果路径为空，或者路径中查找失败，则在cmake module directory（cmake安装时的Modules目录，比如/usr/local/share/cmake/Modules）查找。</strong></p><p>搜索标准的系统环境变量PATH，其中如果是以/bin或者/sbin结尾的，会自动转化为其父目录，发现没有，makeInstall下面有一个bin文件夹，所以会自动转换，在同级文件夹下去找，而不是去子文件夹中寻找（优先级低）。</p><p>CMake为该软件包构造了一组可能的安装前缀。在每个前缀下的几个目录中搜索配置文件。下表显示了搜索的目录。每个条目均用于遵循Windows（<code>W</code>），UNIX（<code>U</code>）或Apple（<code>A</code>）约定的安装树：</p><pre class="line-numbers language-css"><code class="language-css">&lt;prefix>/                                                       <span class="token punctuation">(</span>W<span class="token punctuation">)</span>&lt;prefix>/<span class="token punctuation">(</span>cmake|CMake<span class="token punctuation">)</span>/                                         <span class="token punctuation">(</span>W<span class="token punctuation">)</span>&lt;prefix>/&lt;name>*/                                               <span class="token punctuation">(</span>W<span class="token punctuation">)</span>&lt;prefix>/&lt;name>*/<span class="token punctuation">(</span>cmake|CMake<span class="token punctuation">)</span>/                                 <span class="token punctuation">(</span>W<span class="token punctuation">)</span>&lt;prefix>/<span class="token punctuation">(</span>lib/&lt;arch>|lib*|share<span class="token punctuation">)</span>/cmake/&lt;name>*/                 <span class="token punctuation">(</span>U<span class="token punctuation">)</span>&lt;prefix>/<span class="token punctuation">(</span>lib/&lt;arch>|lib*|share<span class="token punctuation">)</span>/&lt;name>*/                       <span class="token punctuation">(</span>U<span class="token punctuation">)</span>&lt;prefix>/<span class="token punctuation">(</span>lib/&lt;arch>|lib*|share<span class="token punctuation">)</span>/&lt;name>*/<span class="token punctuation">(</span>cmake|CMake<span class="token punctuation">)</span>/         <span class="token punctuation">(</span>U<span class="token punctuation">)</span>&lt;prefix>/&lt;name>*/<span class="token punctuation">(</span>lib/&lt;arch>|lib*|share<span class="token punctuation">)</span>/cmake/&lt;name>*/         <span class="token punctuation">(</span>W/U<span class="token punctuation">)</span>&lt;prefix>/&lt;name>*/<span class="token punctuation">(</span>lib/&lt;arch>|lib*|share<span class="token punctuation">)</span>/&lt;name>*/               <span class="token punctuation">(</span>W/U<span class="token punctuation">)</span>&lt;prefix>/&lt;name>*/<span class="token punctuation">(</span>lib/&lt;arch>|lib*|share<span class="token punctuation">)</span>/&lt;name>*/<span class="token punctuation">(</span>cmake|CMake<span class="token punctuation">)</span>/ <span class="token punctuation">(</span>W/U<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以会去搜索标准的系统环境变量，在bin的同级目录中就找到了老版本的absl，所以编译就失败了。说实话我没想到影响今天编译的会是昨晚上添加的可执行bin路径，令人感叹。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;问题总是在你意想不到的地方出现。&lt;/p&gt;
&lt;h2 id=&quot;重启了个电脑怎么就报错了呢&quot;&gt;&lt;a href=&quot;#重启了个电脑怎么就报错了呢&quot; c
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>RPC的基本原理和层次架构</title>
    <link href="https://joytsing.github.io/posts/17654/"/>
    <id>https://joytsing.github.io/posts/17654/</id>
    <published>2024-05-14T13:02:16.000Z</published>
    <updated>2024-05-14T13:26:20.350Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>本文来自srpc作者李颖欣。</strong></p><p>只要涉及到网络通信，必然涉及到网络协议，应用层也是一样。在应用层最标准和常用的就是HTTP协议。但在很多性能要求较高的场景各大企业内部也会自定义的 RPC 协议。举个例子，就是相当于各个省不但用官方普通话，还都有自己的方言，RPC就相当于是一个方言。</p><p><strong>RPC</strong> 的全称是 <strong>Remote Procedure Call</strong>，翻译过来就是远程过程调用，其实这个名称过分强调了和LPC（本地过程调用）的对比。没有突出出来 RPC 本身涉及到的一些技术特点。现在从三个角度聊聊 RPC</p><ul><li>RPC是什么：通过和HTTP的对比来帮大家了解RPC</li><li>RPC有什么：介绍了RPC用到的用户桩代码、IDL序列化、压缩、协议、通信等技术点</li><li>RPC生命周期：详细探讨RPC从请求发出到收到返回的全过程</li></ul><h2 id="RPC是什么"><a href="#RPC是什么" class="headerlink" title="RPC是什么"></a>RPC是什么</h2><p>RPC可以分为两部分：<strong>用户调用接口</strong> + <strong>具体网络协议</strong>。前者为开发者需要关心的，后者由框架来实现。</p><h3 id="1-用户调用接口"><a href="#1-用户调用接口" class="headerlink" title="1. 用户调用接口"></a>1. 用户调用接口</h3><p>举个例子，定义一个函数希望函数如果输入为“Hello World”的话，输出给一个“OK”，那么这个函数是个本地调用。如果一个远程服务收到“Hello World”可以给我们返回一个“OK”，那么这是一个远程调用。我们会和服务约定好远程调用的函数名。因此，我们的用户接口就是：<strong>输入</strong>、<strong>输出</strong>、<strong>远程函数名</strong>。</p><h3 id="2-具体网络协议"><a href="#2-具体网络协议" class="headerlink" title="2. 具体网络协议"></a>2. 具体网络协议</h3><p>这是框架来实现的，把开发者要发出和接收的内容以某种应用层协议打包进行网络收发。这里可以和HTTP进行一个明显的对比：</p><ul><li><p>RPC是一种自定义网络协议，由具体框架来定，比如SRPC里支持的RPC协议有：SRPC / thrift / BRPC / tRPC，并且也是<strong>tRPC</strong>协议目前唯一的开源实现，拿其中的SogouRPC-std protocol为例给大家看看RPC协议的大概样子：</p><p><img src="/posts/17654/640-1715693046838-12.webp" alt></p></li><li><p>HTTP也是一种网络协议，但包的内容是固定的，必须是：请求行 + 请求头 + 请求体；</p><p><img src="/posts/17654/640.webp" alt></p></li></ul><h3 id="3-进一步思考"><a href="#3-进一步思考" class="headerlink" title="3. 进一步思考"></a>3. 进一步思考</h3><p>上图对应的颜色，所实现的功能是类似的。为什么大家都长差不多呢？</p><p>这里就需要搞清楚，我们想要实现用户接口，需要怎么做？最重要需要支持以下三个功能：</p><ul><li>定位要调用的服务；</li><li>把完整的消息切下来；</li><li>让我们的消息向前/向后兼容；</li></ul><p>这样既可以让消息内保证一定的灵活性，又可以方便拿下一块数据，去调用用户想要的服务。</p><p>我们用一个表格来看一下HTTP和RPC分别是怎么解决的：</p><table><thead><tr><th align="left"></th><th align="left">定位要调用的服务</th><th align="left">消息长度</th><th align="left">消息前后兼容</th></tr></thead><tbody><tr><td align="left">HTTP</td><td align="left">URL</td><td align="left">header里Content-Length</td><td align="left">body里自己解决</td></tr><tr><td align="left">RPC</td><td align="left">指定Service和Method名</td><td align="left">协议header里自行约定</td><td align="left">交给具体IDL</td></tr></tbody></table><p>因此，大家都会需要类似的结构去组装一条完整的用户请求，而第三部分的body只要框架支持，RPC协议和HTTP是可以互通的！因此开发者完全可以根据自己的业务需求进行选型，接下来我们看一下RPC的层次架构，就可以明白为什么不同RPC框架之间的互通、以及RPC和HTTP协议又是如何做到互通的。</p><h2 id="RPC有什么"><a href="#RPC有什么" class="headerlink" title="RPC有什么"></a>RPC有什么</h2><p>我们可以借SRPC的架构，看一下RPC框架从用户到系统都有哪些层次，以及SRPC目前所横向支持的功能是什么：</p><ul><li><strong>用户代码</strong>（client的发送函数/server的函数实现）</li><li><strong>IDL序列化</strong>（protobuf/thrift serialization）</li><li><strong>数据组织</strong> （protobuf/thrift/json）</li><li><strong>压缩</strong>（none/gzip/zlib/snappy/lz4）</li><li><strong>协议</strong> （Sogou-std/Baidu-std/Thrift-framed/TRPC）</li><li><strong>通信</strong> （TCP/HTTP）</li></ul><p>我们先关注以下三个层级：</p><p><img src="/posts/17654/640-1715692787329-3.webp" alt></p><p>如图从左到右，是用户接触的最多到最少的层次。IDL层会根据开发者定义的请求/回复结构进行代码生成，目前用得比较多的是protobuf和thrift，而刚才说到的用户接口和前后兼容问题，都是IDL层来解决的。SRPC对于这两个IDL的用户接口实现方式是：</p><ul><li>thrift：IDL纯手工解析，用户使用srpc是不需要链thrift的库的</li><li>protobuf：service的定义部分纯手工解析</li></ul><p>中间那列是具体的网络协议，而各RPC能互通，就是因为大家实现了对方的“语言”，因此可以协议互通。</p><p>而RPC作为和HTTP并列的层次，第二列和第三列理论上是可以两两结合的，只需要第二列的具体RPC协议在发送时，把HTTP相关的内容进行特化，不要按照自己的协议去发，而按照HTTP需要的形式去发，就可以实现RPC与HTTP互通。</p><h2 id="RPC的生命周期"><a href="#RPC的生命周期" class="headerlink" title="RPC的生命周期"></a>RPC的生命周期</h2><p>到此我们可以通过SRPC看一下，把request通过method发送出去并处理response再回来的整件事情是怎么做的：</p><p><img src="/posts/17654/640-1715692932973-6.webp" alt></p><p>根据上图，可以更清楚地看到刚才提及的各个层级，其中压缩层、序列化层、协议层其实是互相解耦打通的，在SRPC代码上实现得非常统一，横向增加任何一种压缩算法或IDL或协议都不需要也不应该改动现有的代码。</p><p><img src="/posts/17654/640-1715692973908-9.webp" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本文来自srpc作者李颖欣。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只要涉及到网络通信，必然涉及到网络协议，应用层也是一样。在应用
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Redis单线程高性能解密</title>
    <link href="https://joytsing.github.io/posts/55825/"/>
    <id>https://joytsing.github.io/posts/55825/</id>
    <published>2024-05-12T13:48:11.000Z</published>
    <updated>2024-05-15T09:04:00.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>仅仅靠单线程就可以支撑起每秒数万 QPS 的高处理能力，今天重点来看一下Redis 核心网络模块，很多时候网络是限制性能的重要因素。</p><h2 id="一、多路复用原理"><a href="#一、多路复用原理" class="headerlink" title="一、多路复用原理"></a>一、多路复用原理</h2><p>epoll可以说是老生常谈了，这里就放一张图吧。</p><p>性能提升思路很简单，就是让很多的用户连接来复用同一个进(线)程，这就是<strong>多路复用</strong>。<strong>多路</strong>指的是许许多多个用户的网络连接。<strong>复用</strong>指的是对进(线)程的复用。换到牧羊人的例子里，就是一群羊只要一个牧羊人来处理就行了。</p><p>不过复用实现起来是需要特殊的 socket 事件管理机制的，最典型和高效的方案就是 epoll。放到牧羊人的例子来，epoll 就相当于一只牧羊犬。</p><p>在 epoll 的系列函数里， epoll_create 用于创建一个 epoll 对象，epoll_ctl 用来给 epoll 对象添加或者删除一个 socket。epoll_wait 就是查看它当前管理的这些 socket 上有没有可读可写事件发生。</p><p><img src="/posts/55825/640-1715754558858-5.webp" alt></p><p>当网卡上收到数据包后，Linux 内核进行一系列的处理后把数据放到 socket 的接收队列。然后会检查是否有 epoll 在管理它，如果是则在 epoll 的就绪队列中插入一个元素。epoll_wait 的操作就非常的简单了，就是到 epoll 的就绪队列上来查询有没有事件发生就行了。关于 epoll 这只“牧羊犬”的工作原理参见：<a href="https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&mid=2247484905&idx=1&sn=a74ed5d7551c4fb80a8abe057405ea5e&scene=21#wechat_redirect">深入揭秘 epoll 是如何实现 IO 多路复用的</a> （或者深入理解Linux网络内核这本书）。</p><p>在基于 epoll 的编程中，和传统的函数调用思路不同的是，我们并不能主动调用某个 API 来处理。因为无法知道我们想要处理的事件啥时候发生。所以只好提前把想要处理的事件的处理函数注册到一个<strong>事件分发器</strong>上去。当事件发生的时候，由这个事件分发器调用回调函数进行处理。这类基于实现注册事件分发器的开发模式也叫 Reactor 模型。</p><h2 id="二、Redis-服务启动初始化"><a href="#二、Redis-服务启动初始化" class="headerlink" title="二、Redis 服务启动初始化"></a>二、Redis 服务启动初始化</h2><p>其中整个 Redis 服务的代码总入口在 src/server.c 文件中，如下。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: src/server.c</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 启动初始化</span>    <span class="token function">initServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 运行事件处理循环，一直到服务器关闭为止</span>    <span class="token function">aeMain</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>整个 Redis 的工作过程，就只需要理解清楚 main 函数中调用的 initServer 和 aeMain 这两个函数就足够了。在 initServer 这个函数内，Redis 做了这么三件重要的事情。</p><p><img src="/posts/55825/640.webp" alt></p><ul><li>创建一个 epoll 对象</li><li>对配置的监听端口进行 listen</li><li>把 listen socket 让 epoll 给管理起来</li></ul><h3 id="2-1-创建-epoll-对象"><a href="#2-1-创建-epoll-对象" class="headerlink" title="2.1 创建 epoll 对象"></a>2.1 创建 epoll 对象</h3><p>Redis 在操作系统提供的 epoll 对象基础上又封装了一个 eventLoop 出来，所以创建的时候是先申请和创建 eventLoop。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/ae.c</span>aeEventLoop <span class="token operator">*</span><span class="token function">aeCreateEventLoop</span><span class="token punctuation">(</span><span class="token keyword">int</span> setsize<span class="token punctuation">)</span> <span class="token punctuation">{</span>    aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">;</span>    eventLoop <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//将来的各种回调事件就都会存在这里</span>    eventLoop<span class="token operator">-></span>events <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>aeFileEvent<span class="token punctuation">)</span><span class="token operator">*</span>setsize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">aeApiCreate</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> eventLoop<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-绑定监听服务端口"><a href="#2-2-绑定监听服务端口" class="headerlink" title="2.2 绑定监听服务端口"></a>2.2 绑定监听服务端口</h3><p> Redis 中的 listen 过程，它在 listenToPort 函数中。虽然调用链条很长，但其实主要就是执行了个简单 listen 而已。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: src/redis.c</span><span class="token keyword">int</span> <span class="token function">listenToPort</span><span class="token punctuation">(</span><span class="token keyword">int</span> port<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>fds<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>count<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>bindaddr_count <span class="token operator">||</span> j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        fds<span class="token punctuation">[</span><span class="token operator">*</span>count<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">anetTcpServer</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>neterr<span class="token punctuation">,</span>port<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>                server<span class="token punctuation">.</span>tcp_backlog<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Redis 是支持开启多个端口的，所以在 listenToPort 中我们看到是启用一个循环来调用 anetTcpServer。在 anetTcpServer 中，逐步会展开调用，直到执行到 bind 和 listen 系统调用。</p><h3 id="2-3-注册事件回调函数"><a href="#2-3-注册事件回调函数" class="headerlink" title="2.3 注册事件回调函数"></a>2.3 注册事件回调函数</h3><p> initServer里面调用 aeCreateEventLoop 创建了 epoll，调用 listenToPort 进行了服务端口的 bind 和 listen。接着就开始调用 aeCreateFileEvent 来注册一个 accept 事件处理器。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: src/server.c</span><span class="token keyword">void</span> <span class="token function">initServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 2.1.1 创建 epoll</span>    server<span class="token punctuation">.</span>el <span class="token operator">=</span> <span class="token function">aeCreateEventLoop</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxclients<span class="token operator">+</span>CONFIG_FDSET_INCR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2.1.2 监听服务端口</span>    <span class="token function">listenToPort</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>port<span class="token punctuation">,</span>server<span class="token punctuation">.</span>ipfd<span class="token punctuation">,</span><span class="token operator">&amp;</span>server<span class="token punctuation">.</span>ipfd_count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2.1.3 注册 accept 事件处理器</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>ipfd_count<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span> server<span class="token punctuation">.</span>ipfd<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> AE_READABLE<span class="token punctuation">,</span>            acceptTcpHandler<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用 aeCreateFileEvent 时传的重要参数是 acceptTcpHandler，它表示将来在 listen socket 上有新用户连接到达的时候，该函数将被调用执行。我们来看 aeCreateFileEvent 具体代码。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: src/ae.c</span><span class="token keyword">int</span> <span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">,</span>        aeFileProc <span class="token operator">*</span>proc<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 取出一个文件事件结构</span>    aeFileEvent <span class="token operator">*</span>fe <span class="token operator">=</span> <span class="token operator">&amp;</span>eventLoop<span class="token operator">-></span>events<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 监听指定 fd 的指定事件</span>    <span class="token function">aeApiAddEvent</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> mask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 设置文件事件类型，以及事件的处理器</span>    fe<span class="token operator">-></span>mask <span class="token operator">|</span><span class="token operator">=</span> mask<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mask <span class="token operator">&amp;</span> AE_READABLE<span class="token punctuation">)</span> fe<span class="token operator">-></span>rfileProc <span class="token operator">=</span> proc<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mask <span class="token operator">&amp;</span> AE_WRITABLE<span class="token punctuation">)</span> fe<span class="token operator">-></span>wfileProc <span class="token operator">=</span> proc<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 私有数据</span>    fe<span class="token operator">-></span>clientData <span class="token operator">=</span> clientData<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数 aeCreateFileEvent 一开始，从 eventLoop-&gt;events 获取了一个 aeFileEvent 对象， eventLoop-&gt;events 数组，注册的各种事件处理器会保存在这个地方。接下来调用 aeApiAddEvent。这个函数其实就是对 epoll_ctl 的一个封装。主要就是实际执行 epoll_ctl EPOLL_CTL_ADD。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/ae_epoll.c</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">aeApiAddEvent</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// add or mod</span>    <span class="token keyword">int</span> op <span class="token operator">=</span> eventLoop<span class="token operator">-></span>events<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">.</span>mask <span class="token operator">==</span> AE_NONE <span class="token operator">?</span>            EPOLL_CTL_ADD <span class="token punctuation">:</span> EPOLL_CTL_MOD<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// epoll_ctl 添加事件</span>    <span class="token function">epoll_ctl</span><span class="token punctuation">(</span>state<span class="token operator">-></span>epfd<span class="token punctuation">,</span>op<span class="token punctuation">,</span>fd<span class="token punctuation">,</span><span class="token operator">&amp;</span>ee<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每一个 eventLoop-&gt;events 元素都指向一个 aeFileEvent 对象。在这个对象上，设置了三个关键东西</p><ul><li>rfileProc：读事件回调</li><li>wfileProc：写事件回调</li><li>clientData：一些额外的扩展数据</li></ul><p>当 epoll_wait 发现某个 fd 上有事件发生的时候，这样 redis 首先根据 fd 到 eventLoop-&gt;events 中查找 aeFileEvent 对象，然后再看 rfileProc、wfileProc 就可以找到读、写回调处理函数。回头看 initServer 调用 aeCreateFileEvent 时传参来看。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: src/server.c</span><span class="token keyword">void</span> <span class="token function">initServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 2.1.3 注册 accept 事件处理器</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>ipfd_count<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span> server<span class="token punctuation">.</span>ipfd<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> AE_READABLE<span class="token punctuation">,</span>            acceptTcpHandler<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>listen fd 对应的读回调函数 rfileProc 事实上就被设置成了 acceptTcpHandler，写回调没有设置，私有数据 client_data 也为 null。</p><h2 id="三、Redis-事件处理循环"><a href="#三、Redis-事件处理循环" class="headerlink" title="三、Redis 事件处理循环"></a>三、Redis 事件处理循环</h2><p>接下来，Redis 就会进入 aeMain 开始进行真正的用户请求处理了。在 aeMain 函数中，是一个无休止的循环。在每一次的循环中，要做如下几件事情。</p><p><img src="/posts/55825/640-1715755732174-8.webp" alt></p><ul><li>通过 epoll_wait 发现 listen socket 以及其它连接上的可读、可写事件</li><li>若发现 listen socket 上有新连接到达，则接收新连接，并追加到 epoll 中进行管理</li><li>若发现其它 socket 上有命令请求到达，则读取和处理命令，把命令结果写到缓存中，加入写任务队列</li><li>每一次进入 epoll_wait 前都调用 beforesleep 来将写任务队列中的数据实际进行发送</li><li>如若有首次未发送完毕的，当写事件发生时继续发送</li></ul><p>以上就是 aeMain 函数的核心逻辑所在，接下来我们分别对如上提到的四件事情进行详细的阐述。</p><h3 id="3-1-epoll-wait-发现事件"><a href="#3-1-epoll-wait-发现事件" class="headerlink" title="3.1  epoll_wait 发现事件"></a>3.1  epoll_wait 发现事件</h3><p>Redis 不管有多少个用户连接，都是通过 epoll_wait 来统一发现和管理其上的可读（包括 liisten socket 上的 accept事件）、可写事件的。甚至连 timer，也都是交给 epoll_wait 来统一管理的。</p><p><img src="/posts/55825/640-1715756405877-11.webp" alt></p><p>每当 epoll_wait 发现特定的事件发生的时候，就会调用相应的事先注册好的事件处理函数进行处理。aeProcessEvents 就是调用 epoll_wait 来发现事件。当发现有某个 fd 上事件发生以后，则调为其事先注册的事件处理器函数 rfileProc 和 wfileProc。</p><h3 id="3-2-处理新连接请求"><a href="#3-2-处理新连接请求" class="headerlink" title="3.2 处理新连接请求"></a>3.2 处理新连接请求</h3><p>我们假设现在有新用户连接到达了。前面在我们看到 listen socket 上的 rfileProc 注册的是 acceptTcpHandler。也就是说，如果有连接到达的时候，会回调到 acceptTcpHandler。</p><p>在 acceptTcpHandler 中，主要做了几件事情</p><p><img src="/posts/55825/640-1715756436233-14.webp" alt></p><ul><li>调用 accept 系统调用把用户连接给接收回来</li><li>为这个新连接创建一个唯一 redisClient 对象</li><li>将这个新连接添加到 epoll，并注册一个读事件处理函数</li></ul><h3 id="3-3-处理客户连接上的可读事件"><a href="#3-3-处理客户连接上的可读事件" class="headerlink" title="3.3 处理客户连接上的可读事件"></a>3.3 处理客户连接上的可读事件</h3><p>现在假设该用户连接有命令到达了，就假设用户发送了<code>GET XXXXXX_KEY</code> 命令。那么在 Redis 的时间循环中调用 epoll_wait 发现该连接上有读时间后，会调用在上一节中讨论的为其注册的读处理函数 readQueryFromClient。</p><p><img src="/posts/55825/640-1715760737074-17.webp" alt></p><p>在读处理函数 readQueryFromClient 中主要做了这么几件事情。</p><ul><li>解析并查找命令</li><li>调用命令处理</li><li>添加写任务到队列</li><li>将输出写到缓存等待发送</li></ul><h3 id="3-4-beforesleep-处理写任务队列"><a href="#3-4-beforesleep-处理写任务队列" class="headerlink" title="3.4 beforesleep 处理写任务队列"></a>3.4 beforesleep 处理写任务队列</h3><p>次在进入 aeProcessEvents 前都需要先进行 beforesleep 处理。这个函数名字起的怪怪的，但实际上大有用处。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/ae.c</span><span class="token keyword">void</span> <span class="token function">aeMain</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">{</span>    eventLoop<span class="token operator">-></span>stop <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>eventLoop<span class="token operator">-></span>stop<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// beforesleep 处理写任务队列并实际发送之</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>eventLoop<span class="token operator">-></span>beforesleep <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            eventLoop<span class="token operator">-></span><span class="token function">beforesleep</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">aeProcessEvents</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> AE_ALL_EVENTS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该函数处理了许多工作，其中一项便是遍历发送任务队列，并将 client 发送缓存区中的处理结果通过 write 发送到客户端手中。</p><p><img src="/posts/55825/640-1715761315329-20.webp" alt></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/server.c</span><span class="token keyword">void</span> <span class="token function">beforeSleep</span><span class="token punctuation">(</span><span class="token keyword">struct</span> aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">handleClientsWithPendingWrites</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//file:src/networking.c</span><span class="token keyword">int</span> <span class="token function">handleClientsWithPendingWrites</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    listIter li<span class="token punctuation">;</span>    listNode <span class="token operator">*</span>ln<span class="token punctuation">;</span>    <span class="token keyword">int</span> processed <span class="token operator">=</span> <span class="token function">listLength</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_write<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//遍历写任务队列 server.clients_pending_write</span>    <span class="token function">listRewind</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_write<span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>        c<span class="token operator">-></span>flags <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token operator">~</span>CLIENT_PENDING_WRITE<span class="token punctuation">;</span>        <span class="token function">listDelNode</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_write<span class="token punctuation">,</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//实际将 client 中的结果数据发送出去</span>        <span class="token function">writeToClient</span><span class="token punctuation">(</span>c<span class="token operator">-></span>fd<span class="token punctuation">,</span>c<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//如果一次发送不完则准备下一次发送</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">clientHasPendingReplies</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//注册一个写事件处理器，等待 epoll_wait 发现可写后再处理 </span>            <span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span> c<span class="token operator">-></span>fd<span class="token punctuation">,</span> ae_flags<span class="token punctuation">,</span>                sendReplyToClient<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>handleClientsWithPendingWrites</code> 中，遍历了发送任务队列 <code>server.clients_pending_write</code>，并调用 writeToClient 进行实际的发送处理。值得注意的是，发送 write 并不总是能一次性发送完的。假如要发送的结果太大，而系统为每个 socket 设置的发送缓存区又是有限的。</p><p>在这种情况下，<code>clientHasPendingReplies</code> 判断仍然有未发送完的数据的话，就需要注册一个写事件处理函数到 epoll 上。等待 epoll 发现该 socket 可写的时候再次调用 <code>sendReplyToClient</code>进行发送。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/networking.c</span><span class="token keyword">int</span> <span class="token function">writeToClient</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> client <span class="token operator">*</span>c<span class="token punctuation">,</span> <span class="token keyword">int</span> handler_installed<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">clientHasPendingReplies</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 先发送固定缓冲区</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>bufpos <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            nwritten <span class="token operator">=</span> <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>c<span class="token operator">-></span>buf<span class="token operator">+</span>c<span class="token operator">-></span>sentlen<span class="token punctuation">,</span>c<span class="token operator">-></span>bufpos<span class="token operator">-</span>c<span class="token operator">-></span>sentlen<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nwritten <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true">// 再发送回复链表中数据</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            o <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span><span class="token function">listFirst</span><span class="token punctuation">(</span>c<span class="token operator">-></span>reply<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            nwritten <span class="token operator">=</span> <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> o<span class="token operator">-></span>buf <span class="token operator">+</span> c<span class="token operator">-></span>sentlen<span class="token punctuation">,</span> objlen <span class="token operator">-</span> c<span class="token operator">-></span>sentlen<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>writeToClient 中的主要逻辑就是调用 write 系统调用让内核帮其把数据发送出去即可。由于每个命令的处理结果大小是不固定的。所以 Redis 采用的做法用固定的 buf + 可变链表来储存结果字符串。这里自然发送的时候就需要分别对固定缓存区和链表来进行发送了。</p><h2 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h2><p>到了喜闻乐见的小结时间，Redis 服务器端只需要单线程可以达到非常高的处理能力，每秒可以达到数万 QPS 的高处理能力。如此高性能的程序其实就是对 Linux 提供的多路复用机制 epoll 的一个较为完美的运用。</p><p>在 Redis 源码中，核心逻辑其实就是两个，一个是 initServer 启动服务，另外一个就是 aeMain 事件循环。在 initServer 这个函数内，Redis 做了这么三件重要的事情。</p><ul><li>创建一个 epoll 对象</li><li>对配置的监听端口进行 listen</li><li>把 listen socket 让 epoll 给管理起来</li></ul><p>在 aeMain 函数中，是一个无休止的循环，它是 Redis 中最重要的部分。在每一次的循环中，要做的事情可以总结为如下图。</p><p><img src="/posts/55825/640-1715761585179-23.webp" alt></p><ul><li>通过 epoll_wait 发现 listen socket 以及其它连接上的可读、可写事件</li><li>若发现 listen socket 上有新连接到达，则接收新连接，并追加到 epoll 中进行管理</li><li>若发现其它 socket 上有命令请求到达，则读取和处理命令，把命令结果写到缓存中，加入写任务队列</li><li>每一次进入 epoll_wait 前都调用 beforesleep 来将写任务队列中的数据实际进行发送</li></ul><p>其实事件分发器还处理了一个不明显的逻辑，那就是如果 beforesleep 在将结果写回给客户端的时候，如果由于内核 socket 发送缓存区过小而导致不能一次发送完毕的时候，也会注册一个写事件处理器。等到 epoll_wait 发现对应的 socket 可写的时候，再执行 write 写处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;仅仅靠单线程就可以支撑起每秒数万 QPS 的高处理能力，今天重点来看一下Redis 核心网络模块，很多时候网络是限制性能的重要因素。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://JoyTsing.github.io/categories/Redis/"/>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
      <category term="Redis" scheme="https://JoyTsing.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>重新认识端口重用</title>
    <link href="https://joytsing.github.io/posts/48/"/>
    <id>https://joytsing.github.io/posts/48/</id>
    <published>2024-05-12T12:08:25.000Z</published>
    <updated>2024-05-14T13:55:49.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>如果服务器上已经有个进程在 listen 6000 这个端口号了。那么该服务器上其它进程是否还能 bind 和 listen 该端口呢？相信学过一些的一定会答说是不能的。因为很多人都遇到过“Address already in use”这个错误。而这个错误产生的原因就是端口已经被占用。</p><p>但其实在 Linux 3.9 以上的内核版本里，是允许多个进程绑定到同一个端口号上(其实在使用<code>boost asio</code>的时候你就会发现我们并没有显式调用bind)。这就是今天要说的 REUSEPORT 新特性。那么REUSEPORT 是为了解决什么问题而产生的。如果有多个进程复用同一个端口，当用户请求到达时内核是如何选一个进程进行响应的。</p><h2 id="REUSEPORT-要解决的问题"><a href="#REUSEPORT-要解决的问题" class="headerlink" title="REUSEPORT 要解决的问题"></a>REUSEPORT 要解决的问题</h2><p>关于 REUSEPORT 特性产生的背景其实在 linux 的 <a href="https://github.com/torvalds/linux/commit/da5e36308d9f7151845018369148201a5d28b46d">commit</a> 中提供的足够详细了，本质上与PV4向IPV6转变的理由是相同的，都是端口(IP)不够满足现在的发展。如今互联网澎湃发展，应对海量流量的主要措施就是应用多进程模型。在端口不可被重复 bind 和 listen 的年代里，提供海量服务的多进程 Server 提供一般是采用如下两种进程模型来工作。</p><p>第一种是专门搞一个或多个进程服务 accept 新连接，接收请求，然后将请求转给其它的 worker 进程来处理。</p><p><img src="/posts/48/640.webp" alt></p><p>这种多进程模型有两个问题，首先第一个是 dispatcher 进程并不处理任务，需要转交给 worker 进程来处理和响应。这会导致一次额外的进程上下文切换的开销。第二个问题是如果流量特别大的时候 dispatcher 进程很容易成为制约整个服务 qps 提升的瓶颈。</p><p>还有另一种多进程模型是多个进程复用一个 listen 状态的 socket，多个进程同时从一个 socket 中 accept 请求来处理。Nginx 就采用的是这种模型。</p><p><img src="/posts/48/640-1715688988548-1.webp" alt></p><p>这种进程模型解决了第一个模型的问题。但是又带来了新的问题。当 socket 收到一条连接的时候，不能把所有的 worker 进程都招呼起来。需要用锁来保证唯一性，这样就会有锁竞争的问题。</p><h2 id="REUSEPORT-的诞生"><a href="#REUSEPORT-的诞生" class="headerlink" title="REUSEPORT 的诞生"></a>REUSEPORT 的诞生</h2><p>为了更高效地让多个用户态的进程接收和响应客户端的请求。Linux 在 2013 年的 3.9 版本中提供了 REUSEPORT 新特性。</p><p><img src="/posts/48/640-1715689168184-6.webp" alt></p><p>该特性允许同一机器上的多个进程同时创建<strong>不同的 socket 来 bind 和 listen 在相同的端口上</strong>。然后在<strong>内核层面实现多个用户进程的负载均衡</strong>。</p><h3 id="SO-REUSEPORT-设置"><a href="#SO-REUSEPORT-设置" class="headerlink" title="SO_REUSEPORT 设置"></a>SO_REUSEPORT 设置</h3><p>想给自己的服务开启 REUSEPORT 很简单，就是给自己 server 里 listen 用的 socket 上加这么一句。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">setsockopt</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> SOL_SOCKET<span class="token punctuation">,</span> SO_REUSEPORT<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这行代码在内核中对应的处理步骤就是把内核 socket 的 sk_reuseport 字段设置为相应的值，开启的话是 1。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: net/core/sock.c</span><span class="token keyword">int</span> <span class="token function">sock_setsockopt</span><span class="token punctuation">(</span><span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">int</span> level<span class="token punctuation">,</span> <span class="token keyword">int</span> optname<span class="token punctuation">,</span>      <span class="token keyword">char</span> __user <span class="token operator">*</span>optval<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> optlen<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">switch</span> <span class="token punctuation">(</span>optname<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token keyword">case</span> SO_REUSEPORT<span class="token punctuation">:</span>   sk<span class="token operator">-></span>sk_reuseport <span class="token operator">=</span> valbool<span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="bind-时的处理"><a href="#bind-时的处理" class="headerlink" title="bind 时的处理"></a>bind 时的处理</h3><p>内核在 inet_bind 时会调用到 inet_csk_get_port 函数。bind 时对 reuseport 的处理过程。来看源码：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: net/ipv4/inet_connection_sock.c</span><span class="token keyword">int</span> <span class="token function">inet_csk_get_port</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">short</span> snum<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true">//在绑定表（bhash）中查找，</span> head <span class="token operator">=</span> <span class="token operator">&amp;</span>hashinfo<span class="token operator">-></span>bhash<span class="token punctuation">[</span><span class="token function">inet_bhashfn</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> snum<span class="token punctuation">,</span>   hashinfo<span class="token operator">-></span>bhash_size<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token function">inet_bind_bucket_for_each</span><span class="token punctuation">(</span>tb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>head<span class="token operator">-></span>chain<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//找到了，在一个命名空间下而且端口号一致，表示该端口已经绑定</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">net_eq</span><span class="token punctuation">(</span><span class="token function">ib_net</span><span class="token punctuation">(</span>tb<span class="token punctuation">)</span><span class="token punctuation">,</span> net<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> tb<span class="token operator">-></span>port <span class="token operator">==</span> snum<span class="token punctuation">)</span>   <span class="token keyword">goto</span> tb_found<span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>内核通过拉链哈希表的方式来管理所有的 bind 的 socket。其中 inet_bhashfn 是计算哈希值的函数。</p><p><img src="/posts/48/640-1715689472912-9.webp" alt></p><p>当计算找到哈希槽位以后，通过<code>inet_bind_bucket_for_each</code> 来遍历所有的 bind 状态的 socket，目的是为了判断是否冲突。</p><p><code>net_eq(ib_net(tb), net)</code> 这个条件表示网络命名空间匹配，tb-&gt;port == snum 表示端口号匹配。这两个条件加起来，就是说在同一个命名空间下，该端口已经被绑定过了。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: net/ipv4/inet_connection_sock.c</span><span class="token keyword">int</span> <span class="token function">inet_csk_get_port</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">short</span> snum<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>tb<span class="token operator">-></span>fastreuse <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>       sk<span class="token operator">-></span>sk_reuse <span class="token operator">&amp;&amp;</span> sk<span class="token operator">-></span>sk_state <span class="token operator">!=</span> TCP_LISTEN<span class="token punctuation">)</span> <span class="token operator">||</span>      <span class="token punctuation">(</span>tb<span class="token operator">-></span>fastreuseport <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>       sk<span class="token operator">-></span>sk_reuseport <span class="token operator">&amp;&amp;</span> <span class="token function">uid_eq</span><span class="token punctuation">(</span>tb<span class="token operator">-></span>fastuid<span class="token punctuation">,</span> uid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>     smallest_size <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">goto</span> success<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//绑定冲突</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看<code>tb-&gt;fastreuseport &gt; 0</code>和 <code>sk-&gt;sk_reuseport</code> 这两个条件。</p><p>这两个条件的意思是已经 bind 的 socket 和正在 bind 的 socket 都开启了 SO_REUSEPORT 特性。符合条件的话，将会跳转到 success 进行绑定成功的处理。<strong>也就是说，这个端口可以重复绑定使用！</strong></p><p><code>uid_eq(tb-&gt;fastuid, uid)</code>这个条件目的是安全性，必须要求相同的用户进程下的 socket 才可以复用端口。<strong>避免跨用户启动相同端口来窃取另外用户服务上的流量。</strong></p><h3 id="accept-响应新连接"><a href="#accept-响应新连接" class="headerlink" title="accept 响应新连接"></a>accept 响应新连接</h3><p>当有多个进程都 bind 和 listen 了同一个端口的时候。有客户端连接请求到来的时候就涉及到选择哪个 socket（进程）进行处理的问题。我们再简单看一下，响应连接时的处理过程。</p><p>内核仍然是通过 hash + 拉链的方式来保存所有的 listen 状态的 socket。</p><p><img src="/posts/48/640-1715689472912-10.webp" alt></p><p>查找 listen 状态的 socket 的时候需要查找该哈希表。进入响应握手请求的时候进入的一个关键函数<code>__inet_lookup_listener</code> 。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: net/ipv4/inet_hashtables.c</span><span class="token keyword">struct</span> sock <span class="token operator">*</span><span class="token function">__inet_lookup_listener</span><span class="token punctuation">(</span><span class="token keyword">struct</span> net <span class="token operator">*</span>net<span class="token punctuation">,</span>        <span class="token keyword">struct</span> inet_hashinfo <span class="token operator">*</span>hashinfo<span class="token punctuation">,</span>        <span class="token keyword">const</span> __be32 saddr<span class="token punctuation">,</span> __be16 sport<span class="token punctuation">,</span>        <span class="token keyword">const</span> __be32 daddr<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">short</span> hnum<span class="token punctuation">,</span>        <span class="token keyword">const</span> <span class="token keyword">int</span> dif<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//所有 listen socket 都在这个 listening_hash 中</span> <span class="token keyword">struct</span> inet_listen_hashbucket <span class="token operator">*</span>ilb <span class="token operator">=</span> <span class="token operator">&amp;</span>hashinfo<span class="token operator">-></span>listening_hash<span class="token punctuation">[</span>hash<span class="token punctuation">]</span><span class="token punctuation">;</span>begin<span class="token punctuation">:</span> result <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> hiscore <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token function">sk_nulls_for_each_rcu</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> node<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ilb<span class="token operator">-></span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>  score <span class="token operator">=</span> <span class="token function">compute_score</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> net<span class="token punctuation">,</span> hnum<span class="token punctuation">,</span> daddr<span class="token punctuation">,</span> dif<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>score <span class="token operator">></span> hiscore<span class="token punctuation">)</span> <span class="token punctuation">{</span>   result <span class="token operator">=</span> sk<span class="token punctuation">;</span>   hiscore <span class="token operator">=</span> score<span class="token punctuation">;</span>   reuseport <span class="token operator">=</span> sk<span class="token operator">-></span>sk_reuseport<span class="token punctuation">;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>reuseport<span class="token punctuation">)</span> <span class="token punctuation">{</span>    phash <span class="token operator">=</span> <span class="token function">inet_ehashfn</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> daddr<span class="token punctuation">,</span> hnum<span class="token punctuation">,</span>           saddr<span class="token punctuation">,</span> sport<span class="token punctuation">)</span><span class="token punctuation">;</span>    matches <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>score <span class="token operator">==</span> hiscore <span class="token operator">&amp;&amp;</span> reuseport<span class="token punctuation">)</span> <span class="token punctuation">{</span>   matches<span class="token operator">++</span><span class="token punctuation">;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>u64<span class="token punctuation">)</span>phash <span class="token operator">*</span> matches<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">32</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    result <span class="token operator">=</span> sk<span class="token punctuation">;</span>   phash <span class="token operator">=</span> <span class="token function">next_pseudo_random32</span><span class="token punctuation">(</span>phash<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 sk_nulls_for_each_rcu 是在遍历所有 hash 值相同的 listen 状态的 socket。注意看 compute_score 这个函数，这里是计算匹配分。当有多个 socket 都命中的时候，匹配分高的优先命中。我们来看一下这个函数里的一个细节。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: net/ipv4/inet_hashtables.c</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">compute_score</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">int</span> score <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">struct</span> inet_sock <span class="token operator">*</span>inet <span class="token operator">=</span> <span class="token function">inet_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">net_eq</span><span class="token punctuation">(</span><span class="token function">sock_net</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> net<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> inet<span class="token operator">-></span>inet_num <span class="token operator">==</span> hnum <span class="token operator">&amp;&amp;</span>   <span class="token operator">!</span><span class="token function">ipv6_only_sock</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//如果服务绑定的是 0.0.0.0，那么 rcv_saddr 为假</span>  __be32 rcv_saddr <span class="token operator">=</span> inet<span class="token operator">-></span>inet_rcv_saddr<span class="token punctuation">;</span>  score <span class="token operator">=</span> sk<span class="token operator">-></span>sk_family <span class="token operator">==</span> PF_INET <span class="token operator">?</span> <span class="token number">2</span> <span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>rcv_saddr<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>rcv_saddr <span class="token operator">!=</span> daddr<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>   score <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">}</span> <span class="token keyword">return</span> score<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么匹配分解决的是什么问题呢？为了描述的更清楚，我们假设某台服务器有两个 ip 地址，分别是 10.0.0.2 和 10.0.0.3。我们启动了如下三个服务器进程。</p><pre><code>A 进程：./test-server 10.0.0.2 6000B 进程：./test-server 0.0.0.0 6000C 进程：./test-server 127.0.0.1 6000</code></pre><p>那么你的客户端如果指定是连接 10.0.0.2:6000，那么 A 进程会优先执行。因为当匹配到 A 进程的 socket 的时候，需要看一下握手包中的目的 ip 和这个地址是否匹配，确实匹配那得分就是 4 分，最高分。</p><p>如果你指定连接的是 10.0.0.3，那么 A 进程就无法被匹配到。这个时候 B 进程监听时指定的是 0.0.0.0（rcv_saddr 为 false），则不需要进行目的地址的比对，得分为 2。由于没有更高分，所以这次命中的是 B 进程。</p><p>C 进程只有你在本机访问，且指定 ip 使用 127.0.0.1 才能命中，得分也是为 4 分。外部服务器或者是在本机使用其它 ip 都无法访问的到。</p><p>如果当多个 socket 的匹配分一致，通过调用 next_pseudo_random32 进行随机的选择。<strong>在内核态做了负载均衡的事情，选定一个具体的 socket，避免了多个进程在同一个 socket 上的锁竞争。</strong></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在 Linux 3.9 以前的版本中，一个端口只能被一个 socket 绑定。在多进程的场景下，无论是使用一个进程来在这个 socket 上 accept，还是说用多个 worker 来 accept 同一个 socket，在高并发的场景下性能都显得有那么一些低下。</p><p>在 2013 年发布的 3.9 中添加了 reuseport 的特性。该特定允许多个进程分别用不同的 socket 绑定到同一个端口。当有流量到达的时候，在内核态以随机的方式进行负载均衡。避免了锁的开销。</p><p>如果使用的是nginx，只需要一行简单的配置就可以体验这个特性。</p><pre class="line-numbers language-cpp"><code class="language-cpp">server <span class="token punctuation">{</span>  listen <span class="token number">80</span> reuseport<span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;如果服务器上已经有个进程在 listen 6000 这个端口号了。那么该服务器上其它进程是否还能 bind 和 listen 该端口呢？相信
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>std::enable_shared_from_this():诞生和作用</title>
    <link href="https://joytsing.github.io/posts/5981/"/>
    <id>https://joytsing.github.io/posts/5981/</id>
    <published>2024-05-11T07:35:50.000Z</published>
    <updated>2024-06-29T13:48:57.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>std::shared_from_this()</code>是 C++11 标准引入的功能，但之前一直都没用到过，直到在boost中使用asio需要异步保存回调函数时为了保存io_context，防止提前析构才了解到这个。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>简单地说就是帮助你怎么在class内部拿到this的shared_ptr版本。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">></span> <span class="token function">local_sp_a</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// do something with local_sp_a</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  A<span class="token operator">*</span> a<span class="token punctuation">;</span>  std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">></span> <span class="token function">sp_a</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  a<span class="token operator">-</span><span class="token operator">></span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// sp_a becomes dangling.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上述方式拿的话，表面上看起来你是拿到了一个this的shared_ptr版本，但是由于<strong>计数器和被管理的对象是分离</strong>的，因此相当于2个计数器（reference count都=1），同时只有一个被管理的对象。函数内部的那个计数器，在函数调用完成之后，认为reference count变成0了，于是释放掉了对应的object。main里构造的计数器当然不知道对应的object已经被释放了，于是就会二重释放宕掉,换句话说：<strong>智能共享指针不能够直接从this对象进行构造。</strong></p><p>C++解决方案是通过继承一个类（该方法是侵入式的，也可以手动保证只有构造第一个指向被持有对象的shared_ptr实例是由原始指针构造的），这个类本质上会给被管理的object上加一个指向计数器的weak ptr，于是就可以正确地增加引用计数而不是搞出2个独立的计数器。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="/posts/5981/v2-e9eefb114e3e371ac246ee8d9714b681_720w.webp" alt></p><p>该类是一个类模版，通过模版参数TP将被持有对象的类型传递进来，然后在类的内部构件一个weak_ptr<T>类型的成员变量。该成员变量用来保存指向自身的指针以及控制块相关信息，外部使用的时候如前一章节示例代码一样，为方便讨论代码重复贴出代码如下，采用继承的方式来扩展派生类的功能。</T></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token operator">:</span> <span class="token keyword">public</span> std<span class="token operator">::</span>enable_shared_from_this<span class="token operator">&lt;</span>Test<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面这种继承自一个类模版，将自身类型以模版参数的形式传入派生类的方式有一个专有名词对应，那就是CRTP，英文全称curious recurring template pattern，中文译名是奇异递归模版模式。可以通过该模式将派生类的类型信息通过模版参数的方式传入enable_shared_from_this类模版中，在enable_shared_from_this类模版中，将用该类型信息声明内部的用于管理派生类对象的成员变量__weak_this，并且声明相关成员方法，从而扩展派生类的功能。</p><p>该类的方法可以通过调用基类提供的成员函数shared_from_this来获取一个指向自身的shared_ptr对象，通过weak_from_this方法来获取一个指向自身的weak_ptr对象，其中weak_ptr对象也是指向被管理对象的智能指针，只不过该智能指针是弱引用关系，不管理“被持有”对象的声明周期（这里被持有是带有引号的，用来表示区别于shared_ptr，这里是弱引用，不具有被管理对象的所有权），只提供访问对象数据的功能，但是和裸指针(raw pointer)功能类似，但是可以通过该指针的成员方法expire来判断被指向对象是否还有效（是否已经被销毁）。</p><p>核心逻辑在shared_from_this函数内部,该函数的内部逻辑不复杂，仅仅是通过成员变量__weak_this_来构建一个shared_ptr对象，然后将该对象返回:</p><pre class="line-numbers language-cpp"><code class="language-cpp">shared_ptr<span class="token operator">&lt;</span>_Tp<span class="token operator">></span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> shared_ptr<span class="token operator">&lt;</span>_Tp<span class="token operator">></span><span class="token punctuation">(</span>__weak_this_<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="enable-shared-from-this在异步求值中的应用"><a href="#enable-shared-from-this在异步求值中的应用" class="headerlink" title="enable_shared_from_this在异步求值中的应用"></a>enable_shared_from_this在异步求值中的应用</h2><p>enable_shared_from_this真实的应用场景是什么？如果只是需要正常让shared_ptr计数的话完全有其他更简单的方法（工厂方法），之前提到的应用场景大部分是在类的外部，可以通过对已有的shared_ptr进行复制，来共享所有权。在类的内部如果想安全的实现所有权的共享，并且和外部的shared_ptr来共同的管理对象，这个时候就需要使用enable_shared_from_this模版类了。</p><p>看一下下面的例子，定义了一个Process类，该类通过SetContext设置了一些上下文信息，然后保存在类的内部，然后在内部通过lambda函数捕捉自身this指针，并且封装一个求值的操作，然后将该lambda函数交给一个线程池来进行异步的执行：</p><p><img src="/posts/5981/v2-60007984ac84fd2552268f4c2742c317_720w.webp" alt></p><p>在异步执行的时候，调用它</p><p><img src="/posts/5981/v2-2d99285ca4ade1f1fd5ba7bd1a224157_720w.webp" alt></p><p>运行上述代码，会发现运行异常，异常结果如下图所示</p><p><img src="/posts/5981/v2-70077f07c846bf45cf47b0c3a0f31060_720w.webp" alt></p><p>之所以会产生异常，是因为当异步调用开始执行的时候，Process对象实例_process已经被释放了，此时加入线程池的lambda函数对象内捕捉的this指针指向的对象已经被释放了，此时异步执行的时候，会导致未定义行为。</p><p><img src="/posts/5981/v2-2e956c602a3784b3ac47da321b308467_720w.webp" alt="解决"></p><p>如上图中间红框部分，在进行异步调用函数封装的时候，不直接去捕捉this指针，而通过shared_from_this函数来构造一个shared_ptr对象，来捕捉这个shared_ptr对象，从而达到异步调用中使用的shared_ptr对象和外部的（通过Create创建以及后续从已有shared_ptr对象拷贝复制的）shared_ptr对象共享所有权，共同管理被指向对象的生命周期。从而避免异步执行时，捕捉的对象被释放的问题。</p><h2 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h2><p>像下面这样的写法是不正确的，</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyCar</span><span class="token operator">:</span><span class="token keyword">public</span> std<span class="token operator">::</span>enable_shared_from_this<span class="token operator">&lt;</span>MyCar<span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  shared_ptr<span class="token operator">&lt;</span>MyCar<span class="token operator">></span> <span class="token function">get_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token operator">~</span><span class="token function">MyCar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"free ~Mycar()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  MyCar<span class="token operator">*</span> _myCar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">MyCar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  shared_ptr<span class="token operator">&lt;</span>MyCar<span class="token operator">></span> _myCar1 <span class="token operator">=</span> _myCar<span class="token operator">-</span><span class="token operator">></span><span class="token function">get_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  shared_ptr<span class="token operator">&lt;</span>MyCar<span class="token operator">></span> _myCar2 <span class="token operator">=</span> _myCar<span class="token operator">-</span><span class="token operator">></span><span class="token function">get_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> _myCar1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> _myCar2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>区别在于在调用时候没有对智能指针进行构造，而是想通过get直接得到（符合直觉），但是这样的写法是会报错的：</p><p><img src="/posts/5981/13a914c223ade96d1a1dbdc2b97c3528.png" alt="报错内容"></p><p>如上图所示，异常位置是在弱指针处，弱指针实际上是智能共享指针的伴随指针，它主要负责监控智能指针的声明周期，弱指针本身的构造和析构都不会对引用计数进行修改，纯粹是作为一个助手监视shared_ptr管理的资源是否存在。因此弱指针的初始化是通过智能指针的构造函数来实现的，在上面的代码中对智能指针初始化时并没有使用构造函数的方式，因为弱指针是没有正常进行初始化的，所以抛出了异常。</p><p>这也是为什么推荐和工程模式一起使用，避免了这种问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;code&gt;std::shared_from_this()&lt;/code&gt;是 C++11 标准引入的功能，但之前一直都没用到过，直到在boos
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
  </entry>
  
</feed>
