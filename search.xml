<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>好久不见</title>
      <link href="posts/62537/"/>
      <url>posts/62537/</url>
      
        <content type="html"><![CDATA[<h2 id="首先，日安"><a href="#首先，日安" class="headerlink" title="首先，日安"></a>首先，日安</h2><p>好久不见，距离上次更新竟然已经过了两年之久，很惭愧一直都没有更新，这两年发生了很多东西，一件一件来说吧。</p><h3 id="关于未来"><a href="#关于未来" class="headerlink" title="关于未来"></a>关于未来</h3><p>怎么说呢，我从小一直对研究生有个渴望，但我上本科四年期间我一直没有想过能够通过这么曲折的方式拿到一个保研名额，相信愿意进来这的人都知道我本人是谁（我也不喜欢隐藏自己），这个故事我也讲过太多次了，也就不再这累述了，在这大学四年我感受到了许多也体会到了许多，特别是从18年开始混迹老乡群，给各位无偿解答了四年，认识了很多很棒的人，也认识了很多优秀的学弟学妹。</p><p>其实我也不知道为什么，各位学弟学妹都挺相信我的，不胜荣幸，其实说实话我感觉我读了四年书，其实除了最后摸了个保研名额（还去西电了）也没什么特别出众的。大学四年基本上是徘徊迷茫的四年，但感谢在我最迷茫的时光遇到了张，关，杨三位学长，也遇到了后面一直跟我联系的舍友和刘，感谢你们在我人生最重要的阶段能够彼此相识。</p><h2 id="其次，晚安"><a href="#其次，晚安" class="headerlink" title="其次，晚安"></a>其次，晚安</h2><p>往事涌上心头，也不多说了，后面会经常更新，给各位推荐<strong>obsidian</strong>这个软件来管理自己的学习笔记。</p><p>另外，给老乡群们答应的<code>UESTCer生存指南lite</code>后面也会更新,虽然可能会有点慢，但希望能对各位大学生生活能有微薄的帮助。</p><p>大学四年，有快乐又不快乐，在那时候总是抱怨，但真回头，心中还是怀念那段时间，那么就这样了，晚安。</p><p><img src="/posts/62537/1.png" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Scheme入门教程</title>
      <link href="posts/56075/"/>
      <url>posts/56075/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>虽然目前因为scheme过时，最新的SICP已经采用python作为系列语言，但是通过前两章的学习，可以说，Scheme（lisp方言）是一门充满魅力的语言，而且在之前有过关于用C设计lisp语言的学习，都用C写出来了lisp结果不熟悉lisp未免来说过于尴尬，因此决定恶补一下scheme。</p><h2 id="四种基本算术操作"><a href="#四种基本算术操作" class="headerlink" title="四种基本算术操作"></a>四种基本算术操作</h2><p>Scheme（以及大多数Lisp方言）都可以处理分数。</p><p>函数<code>exact-&gt;inexact</code> 用于把分数转换为浮点数。Scheme也可以处理复数。复数是形如<code>a+bi</code>的数，此处<code>a</code>称为实部，<code>b</code>称为虚部。<code>+</code>、<code>-</code>、<code>*</code>和<code>/</code>分别代表加、减、乘、除。这些函数都接受任意多的参数。</p><p>例：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token operator">-</span> <span class="token number">10</span> <span class="token number">3</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">;→ 7</span><span class="token punctuation">(</span><span class="token operator">-</span> <span class="token number">10</span> <span class="token number">3</span> <span class="token number">5</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">;→ 2</span><span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">;→ 6</span><span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">;→ 24</span><span class="token punctuation">(</span><span class="token operator">/</span> <span class="token number">29</span> <span class="token number">3</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">;→ 29/3</span><span class="token punctuation">(</span><span class="token operator">/</span> <span class="token number">29</span> <span class="token number">3</span> <span class="token number">7</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">;→ 29/21</span><span class="token punctuation">(</span><span class="token operator">/</span> <span class="token number">9</span> <span class="token number">6</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">;→ 3/2</span><span class="token punctuation">(</span><span class="token function">exact->inexact</span> <span class="token punctuation">(</span><span class="token operator">/</span> <span class="token number">29</span> <span class="token number">3</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;→ 1.380952380952381</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>括号可以像下面这样嵌套：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">-</span> <span class="token number">5</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;→ 10</span><span class="token punctuation">(</span><span class="token operator">/</span> <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">9</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;→ 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>形如这些由<strong>括号</strong>、<strong>标记（token）</strong>以及<strong>分隔符</strong>组成的式子，被称为<strong>S-表达式</strong>。</p><h3 id="其它算术操作"><a href="#其它算术操作" class="headerlink" title="其它算术操作"></a>其它算术操作</h3><h3 id="quotient，remainder，modulo和sqrt"><a href="#quotient，remainder，modulo和sqrt" class="headerlink" title="quotient，remainder，modulo和sqrt"></a>quotient，remainder，modulo和sqrt</h3><ul><li>函数<code>quotient</code>用于求<strong>商数（quotient）</strong>。</li><li>函数<code>remainder</code>和<code>modulo</code>用于求<strong>余数（remainder）</strong>。</li><li>函数<code>sqrt</code>用于求参数的<strong>平方根（square root）</strong>。</li></ul><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">quotient</span> <span class="token number">7</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;→ 2</span><span class="token punctuation">(</span><span class="token function">modulo</span> <span class="token number">7</span> <span class="token number">3</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">;→ 1</span><span class="token punctuation">(</span><span class="token function">sqrt</span> <span class="token number">8</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true">;→ 2.8284271247461903</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><p>数学上的三角函数，诸如<code>sin</code>，<code>cos</code>，<code>tan</code>，<code>asin</code>，<code>acos</code>和<code>atan</code>都可以在Scheme中使用。<code>atan</code>接受1个或2个参数。如果<code>atan</code>的参数为<code>1/2 π</code>，那么就要使用两个参数来计算。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">atan</span> <span class="token number">1</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">;→ 0.7853981633974483</span><span class="token punctuation">(</span><span class="token function">atan</span> <span class="token number">1</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;→ 1.5707963267948966</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="指数和对数"><a href="#指数和对数" class="headerlink" title="指数和对数"></a>指数和对数</h3><p>指数通过<code>exp</code>函数运算，对数通过<code>log</code>函数运算。<code>a</code>的<code>b</code>次幂可以通过<code>(expt a b)</code>来计算。</p><h2 id="生成表"><a href="#生成表" class="headerlink" title="生成表"></a>生成表</h2><p>作为Lisp语言大家族的一员，Scheme同样擅长于处理表。表在在后面章节中的递归函数和高阶函数中扮演重要角色。在本章中会讲解基本的表操作，例如<code>cons</code>，<code>car</code>，<code>cdr</code>，<code>list</code>和<code>quote</code>。</p><h3 id="Cons单元和表"><a href="#Cons单元和表" class="headerlink" title="Cons单元和表"></a>Cons单元和表</h3><h4 id="Cons单元"><a href="#Cons单元" class="headerlink" title="Cons单元"></a>Cons单元</h4><p>首先，让我解释一下表的元素：<strong>Cons单元（Cons cells）</strong>。Cons单元是一个存放了两个地址的内存空间。Cons单元可用函数<code>cons</code>生成。</p><p>在前端输入<code>(cons 1 2)</code></p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>系统返回<code>(1 . 2)</code>。如图一所示，函数<code>cons</code>给两个地址分配了内存空间，并把存放指向<code>1</code>的地址放在一个空间，把存放指向<code>2</code>的地址放在另一个空间。存放指向<code>1</code>的地址的内存空间被称作<code>car</code>部分，对应的，存放指向<code>2</code>的地址的内存空间被称作<code>cdr</code>部分。<code>car</code>和<code>cdr</code>分别是<strong>寄存器地址部分（Contents of the Address part of the Register）</strong>和<strong>寄存器减量部分（Contents of the Decrement part of the Register）</strong>的简称。这些名字最初来源于Lisp首次被实现所使用的硬件环境中内存空间的名字。这些名字同时也表明Cons单元的本质就是一个内存空间。<code>cons</code>这个名字是术语<strong>构造（construction）</strong>的简称。</p><p><img src="http://deathking.github.io/yast-cn/contents/figures/cons2.png" alt></p><p>Cons单元也可以被串起来。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这种情况的内存空间如图2所示。</p><p><img src="http://deathking.github.io/yast-cn/contents/figures/conss2.png" alt></p><p>Cons单元可以存放不同类型的数据也可以嵌套。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token builtin">cons</span> #\a <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token number">3</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 17: (#\a 3 . "hello")</span><span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token number">0</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 23: ((0 . 1) 2 . 3)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是因为Scheme可以通过地址操作所有的数据。（<code>#\c</code>代表了一个字符<code>c</code>。例如，<code>#\a</code>就代表字符<code>a</code>）</p><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><p>表是Cons单元通过用<code>cdr</code>部分连接到下一个<code>Cons</code>单元的开头实现的。表中包含的<code>’()</code>被称作空表。就算数据仅由一个Cons单元组成，只要它的<code>cdr</code>单元是<code>’()</code>，那它就是一个表。图3展示了表<code>(1 2 3)</code>的内存结构。</p><p><img src="http://deathking.github.io/yast-cn/contents/figures/list2.png" alt></p><p>事实上，表可以像下面这样递归地定义：</p><ol><li><code>‘()</code>是一个表</li><li>如果<code>ls</code>是一个表且<code>obj</code>是某种类型的数据，那么<code>(cons obj ls)</code>也是一个表 正因为表是一种被递归定义的数据结构，将它用在递归的函数中显然是合理的。</li></ol><p>###原子</p><p>不使用Cons单元的数据结构称为<strong>原子（atom）</strong>。数字，字符，字符串，向量和空表<code>’()</code>都是原子。<code>’()</code>既是原子，又是表。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>所有的记号都会依据Scheme的求值规则求值：所有记号都会从最内层的括号依次向外层括号求值，且最外层括号返回的值将作为S-表达式的值。一个被称为<strong>引用（quote）</strong>的形式可以用来阻止记号被求值。它是用来将符号或者表原封不动地传递给程序，而不是求值后变成其它的东西。</p><p>例如，<code>(+ 2 3)</code>会被求值为<code>5</code>，然而<code>(quote (+ 2 3))</code>则向程序返回<code>(+ 2 3)</code>本身。因为<code>quote</code>的使用频率很高，他被简写为<code>’</code>。</p><p>比如：</p><ul><li><code>’(+ 2 3)</code>代表列表<code>(+ 2 3)</code>本身；</li><li><code>’+</code>代表符号<code>+</code>本身；</li></ul><p>实际上，<code>’()</code>是对空表的引用，也就是说，尽管解释器返回<code>()</code>代表空表，你也应该用<code>’()</code>来表示空表。</p><h3 id="特殊形式"><a href="#特殊形式" class="headerlink" title="特殊形式"></a>特殊形式</h3><p>Scheme有两种不同类型的操作符：其一是函数。函数会对所有的参数求值并返回值。另一种操作符则是特殊形式。特殊形式不会对所有的参数求值。除了<code>quote</code>，<code>lambda</code>，<code>define</code>，<code>if</code>，<code>set!</code>，等都是特殊形式。</p><h3 id="car函数和cdr函数"><a href="#car函数和cdr函数" class="headerlink" title="car函数和cdr函数"></a>car函数和cdr函数</h3><p>返回一个Cons单元的<code>car</code>部分和<code>cdr</code>部分的函数分别是<code>car</code>和<code>cdr</code>函数。如果<code>cdr</code>部分串连着Cons单元，解释器会打印出整个<code>cdr</code>部分。如果Cons单元的<code>cdr</code>部分不是<code>’()</code>，那么其值稍后亦会被展示。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token builtin">car</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 1</span><span class="token punctuation">(</span><span class="token builtin">cdr</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 18: (2 3 4)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="list函数"><a href="#list函数" class="headerlink" title="list函数"></a>list函数</h3><p><code>list</code>函数使得我们可以构建包含数个元素的表。函数<code>list</code>有任意个数的参数，且返回由这些参数构成的表。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: ()</span><span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 24: (1)</span><span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">3</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 25: ((1 2) (3 4))</span><span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 26: (0)</span><span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 27: (1 2)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p>由于Sheme是函数式编程语言，你需要通过编写小型函数来构造程序。因此，明白如何构造并组合这些函数对掌握Scheme尤为关键。</p><p>你可以使用<code>define</code>来将一个符号与一个值绑定。你可以通过这个操作符定义例如数、字符、表、函数等任何类型的全局参数。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token comment" spellcheck="true">; Hello world as a variable</span><span class="token punctuation">(</span><span class="token keyword">define</span> vhello <span class="token string">"Hello world"</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">;1</span><span class="token comment" spellcheck="true">; Hello world as a function</span><span class="token punctuation">(</span><span class="token keyword">define</span> fhello <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token comment" spellcheck="true">;2</span>         <span class="token string">"Hello world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>操作符<code>define</code>用于声明变量，它接受两个参数。<code>define</code>运算符会使用第一个参数作为全局参数，并将其与第二个参数绑定起来。因此，代码片段1的第1行中，我们声明了一个全局参数<code>vhello</code>，并将其与<code>&quot;Hello，World&quot;</code>绑定起来。</p><p>紧接着，在第2行声明了一个返回<code>“Hello World”</code>的过程。</p><p>特殊形式<code>lambda</code>用于定义过程。<code>lambda</code>需要至少一个的参数，第一个参数是由定义的过程所需的参数组成的表。因为本例<code>fhello</code>没有参数，所以参数表是空表。</p><p>在解释器中输入<code>vhello</code>，解释器返回“Hello，World”。如果你在解释器中输入<code>fhello</code>，它也会返回像下面这样的值：<code>#[compound-procedure 16 fhello]</code>，这说明了Scheme解释器把过程和常规数据类型用同样的方式对待。正如我们在前面章节中讲解的那样，Scheme解释器通过内存空间中的数据地址操作所有的数据，因此，所有存在于内存空间中的对象都以同样的方式处理。</p><p>如果把<code>fhello</code>当过程对待，你应该用括号括住这些符号，比如<code>(fhello)</code>。</p><p>然后解释器会按照第二章讲述的规则那样对它求值，并返回“Hello World”。</p><h3 id="定义有参数的函数"><a href="#定义有参数的函数" class="headerlink" title="定义有参数的函数"></a>定义有参数的函数</h3><p>可以通过在<code>lambda</code>后放一个参数表来定义有参数的函数。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token comment" spellcheck="true">; hello with name</span><span class="token punctuation">(</span><span class="token keyword">define</span> hello  <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token function">string-append</span> <span class="token string">"Hello "</span> name <span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">; sum of three numbers</span><span class="token punctuation">(</span><span class="token keyword">define</span> sum3  <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token function">a</span> b c<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token operator">+</span> a b c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数<code>hello</code>有一个参数<code>(name)</code>，并会把<code>“Hello”</code>、<code>name的值</code>、和<code>&quot;!&quot;</code>连结在一起并返回。</p><p>预定义函数<code>string-append</code>可以接受任意多个数的参数，并返回将这些参数连结在一起后的字符串。</p><p><code>sum3</code>：此函数有三个参数并返回这三个参数的和。</p><h3 id="一种函数定义的短形式"><a href="#一种函数定义的短形式" class="headerlink" title="一种函数定义的短形式"></a>一种函数定义的短形式</h3><p>用<code>lambda</code>定义函数是一种规范的方法，但你也可以使用类似于代码片段3中展示的短形式。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token comment" spellcheck="true">; hello with name</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">hello</span> name<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">string-append</span> <span class="token string">"Hello "</span> name <span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">; sum of three numbers</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">sum3</span> a b c<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token operator">+</span> a b c<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这种形式中，函数按照它们被调用的形式被定义。代码片段2和代码片段3都是相同的。有些人不喜欢这种短形式的函数定义，但是在教程中使用这种形式，因为它可以使代码更短小。</p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>本章会讲解如何通过条件编写过程。这个是编写使用程序很重要的一步。</p><h3 id="if表达式"><a href="#if表达式" class="headerlink" title="if表达式"></a>if表达式</h3><p><code>if</code>表达式将过程分为两个部分。<code>if</code>的格式如下：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">if</span> predicate then_value else_value<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果<code>predicate</code>部分为真，那么<code>then_value</code>部分被求值，否则<code>else_value</code>部分被求值，并且求得的值会返回给<code>if</code>语句的括号外。<code>true</code>是除<code>false</code>以外的任意值，<code>true</code>使用<code>#t</code>表示，<code>false</code>用<code>#f</code>表示。</p><p>在R5RS中，<code>false</code>（<code>#f</code>）和空表<code>（’()）</code>是两个不同的对象。然而，在MIT-Scheme中，这两个为同一对象。这个不同可能是历史遗留问题，在以前的标准——R4RS中，<code>#f</code>和<code>’()</code>被定义为同一对象。</p><p>因此，从兼容性角度考虑，你不应该使用表目录作为谓词。使用函数<code>null?</code>来判断表是否为空。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token builtin">null?</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token builtin">null?</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">a</span> b c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: ()   ;#f</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数<code>not</code>可用于对谓词取反。此函数只有一个参数且如果参数值为<code>#f</code>则返回<code>#t</code>，反之，参数值为<code>#t</code>则返回<code>#f</code>。<code>if</code>表达式是一个特殊形式，因为它不对所有的参数求值。因为如果<code>predicate</code>为真，则只有<code>then_value</code>部分被求值。另一方面，如果<code>predicate</code>为假，只有<code>else_value</code>部分被求值。</p><p>例：首项为<code>a0</code>，增长率<code>r</code>，项数为<code>n</code>的几何增长（geometric progression）数列之和</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">sum-gp</span> a0 r n<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token operator">*</span> a0     <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> r <span class="token number">1</span><span class="token punctuation">)</span>         n         <span class="token punctuation">(</span><span class="token operator">/</span> <span class="token punctuation">(</span><span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">(</span><span class="token function">expt</span> r n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">-</span> <span class="token number">1</span> r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">; !!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通常来说，几何增长数列的求和公式如下：</p><pre><code>a0 * (1 - r^n) / (1 - r)                      (r ≠ 1)a0 * n                                        (r = 1)</code></pre><p>如果<code>if</code>表达式对所有参数求值的话，那么有<code>;!!</code>注释的那行就算在<code>r=1</code>时也会被求值，这将导致产生一个“除数为0”的错误。</p><p>你也可以省去<code>else_value</code>项。这样的话，当<code>predicate</code>为假时，返回值就没有被指定。如果你希望当<code>predicate</code>为假时返回<code>#f</code>，那么就要明确地将它写出来。</p><p><code>then_value</code>和<code>else_value</code>都应该是S-表达式。如果你需要副作用，那么就应该使用<code>begin</code>表达式。我们将在下一章讨论<code>begin</code>表达式。</p><h3 id="and和or"><a href="#and和or" class="headerlink" title="and和or"></a>and和or</h3><p><code>and</code>和<code>or</code>是用于组合条件的两个特殊形式。Scheme中的<code>and</code>和<code>or</code>不同于C语言中的约定。它们不返回一个布尔值（<code>#t</code>或<code>#f</code>），而是返回给定的参数之一。<code>and</code>和<code>or</code>可以使你的代码更加短小。</p><h4 id="and"><a href="#and" class="headerlink" title="and"></a>and</h4><p><code>and</code>具有任意个数的参数，并从左到右对它们求值。如果某一参数为<code>#f</code>，那么它就返回<code>#f</code>，而不对剩余参数求值。反过来说，如果所有的参数都不是<code>#f</code>，那么就返回最后一个参数的值。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">and</span> <span class="token boolean">#f</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: ()</span><span class="token punctuation">(</span><span class="token function">and</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 3</span><span class="token punctuation">(</span><span class="token function">and</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token boolean">#f</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: ()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="or"><a href="#or" class="headerlink" title="or"></a>or</h4><p><code>or</code>具有可变个数的参数，并从左到右对它们求值。它返回第一个不是值<code>#f</code>的参数，而余下的参数不会被求值。如果所有的参数的值都是<code>#f</code>的话，则返回最后一个参数的值。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">or</span> <span class="token boolean">#f</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 0</span><span class="token punctuation">(</span><span class="token function">or</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 1</span><span class="token punctuation">(</span><span class="token function">or</span> <span class="token boolean">#f</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 1</span><span class="token punctuation">(</span><span class="token function">or</span> <span class="token boolean">#f</span> <span class="token boolean">#f</span> <span class="token boolean">#f</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: ()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="cond表达式"><a href="#cond表达式" class="headerlink" title="cond表达式"></a>cond表达式</h3><p>尽管所有的分支都可以用<code>if</code>表达式表达，但当条件有更多的可能性时，你就需要使用嵌套的<code>if</code>表达式了，这将使代码变得复杂。处理这种情况可以使用<code>cond</code>表达式。<code>cond</code>表达式的格式如下：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">cond</span>  <span class="token punctuation">(</span><span class="token function">predicate_1</span> clauses_1<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">predicate_2</span> clauses_2<span class="token punctuation">)</span>    ......  <span class="token punctuation">(</span><span class="token function">predicate_n</span> clauses_n<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">else</span>        clauses_else<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>cond</code>表达式中，<code>predicates_i</code>是按照从上到下的顺序求值，而当<code>predicates_i</code>为真时，<code>clause_i</code>会被求值并返回。<code>i</code>之后的<code>predicates</code>和<code>clauses</code>不会被求值。如果所有的<code>predicates_i</code>都是假的话，则返回<code>cluase_else</code>。在一个子句中，你可以写数条S-表达式，而<code>clause</code>的值是最后一条S-表达式。</p><blockquote><p>例：城市游泳池的收费。</p><p>Foo市的城市游泳池按照顾客的年龄收费：</p><p>如果 age ≤ 3 或者 age ≥ 65 则 免费；<br>如果 介于 4 ≤ age ≤ 6 则 0.5美元；<br>如果 介于 7 ≤ age ≤ 12 则 1.0美元；<br>如果 介于 13 ≤ age ≤ 15 则 1.5美元；<br>如果 介于 16 ≤ age ≤ 18 则 1.8美元；<br>其它 则 2.0美元；</p><p>那么，一个返回城市游泳池收费的函数如下：</p></blockquote><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">fee</span> age<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">cond</span>   <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">or</span> <span class="token punctuation">(</span><span class="token operator">&lt;=</span> age <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">>=</span> age <span class="token number">65</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">0</span><span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&lt;=</span> <span class="token number">4</span> age <span class="token number">6</span><span class="token punctuation">)</span> <span class="token number">0.5</span><span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&lt;=</span> <span class="token number">7</span> age <span class="token number">12</span><span class="token punctuation">)</span> <span class="token number">1.0</span><span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&lt;=</span> <span class="token number">13</span> age <span class="token number">15</span><span class="token punctuation">)</span> <span class="token number">1.5</span><span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&lt;=</span> <span class="token number">16</span> age <span class="token number">18</span><span class="token punctuation">)</span> <span class="token number">1.8</span><span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token keyword">else</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="做出判断的函数"><a href="#做出判断的函数" class="headerlink" title="做出判断的函数"></a>做出判断的函数</h3><p>将介绍一些用于做判断的函数。这些函数的名字都以<code>&#39;?&#39;</code>结尾。</p><h3 id="eq-、eqv-和equal"><a href="#eq-、eqv-和equal" class="headerlink" title="eq?、eqv?和equal?"></a>eq?、eqv?和equal?</h3><p>基本函数<code>eq?</code>、<code>eqv?</code>、<code>equal?</code>具有两个参数，用于检查这两个参数是否“一致”。这三个函数之间略微有些区别。</p><blockquote><p><code>eq?</code><br>该函数比较两个对象的地址，如果相同的话就返回<code>#t</code>。例如，<code>(eq? str str)</code>返回<code>#t</code>，因为<code>str</code>本身的地址是一致的。与此相对的，因为字符串<code>”hello”</code>和<code>”hello”</code>被储存在了不同的地址中，函数将返回<code>#f</code>。不要使用<code>eq?</code>来比较数字，因为不仅在R5RS中，甚至在MIT-Scheme实现中，它都没有指定返回值。使用<code>eqv?</code>或者<code>=</code>替代。</p></blockquote><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> str <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: str</span><span class="token punctuation">(</span><span class="token function">eq?</span> str str<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token function">eq?</span> <span class="token string">"hello"</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: ()             ← It should be #f in R5RS </span><span class="token comment" spellcheck="true">;;; comparing numbers depends on implementations</span><span class="token punctuation">(</span><span class="token function">eq?</span> <span class="token number">1</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token function">eq?</span> <span class="token number">1.0</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: ()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>eqv?</code><br>该函数比较两个存储在内存中的对象的类型和值。如果类型和值都一致的话就返回<code>#t</code>。对于过程（<code>lambda</code>表达式）的比较依赖于具体的实现。这个函数不能用于类似于表和字符串一类的序列比较，因为尽管这些序列看起来是一致的，但它们的值是存储在不同的地址中。</p></blockquote><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">eqv?</span> <span class="token number">1.0</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token function">eqv?</span> <span class="token number">1</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: ()</span><span class="token comment" spellcheck="true">;;; don't use it to compare sequences</span><span class="token punctuation">(</span><span class="token function">eqv?</span> <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: ()</span><span class="token punctuation">(</span><span class="token function">eqv?</span> <span class="token string">"hello"</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: ()</span><span class="token comment" spellcheck="true">;;; the following depends on implementations</span><span class="token punctuation">(</span><span class="token function">eqv?</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: ()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>equal?</code><br>该函数用于比较类似于表或者字符串一类的序列。</p></blockquote><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">equal?</span> <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token function">equal?</span> <span class="token string">"hello"</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="用于检查数据类型的函数"><a href="#用于检查数据类型的函数" class="headerlink" title="用于检查数据类型的函数"></a>用于检查数据类型的函数</h3><p>下面列举了几个用于检查类型的函数。这些函数都只有一个参数。</p><ul><li><code>pair?</code> 如果对象为序对则返回<code>#t</code>；</li><li><code>list?</code> 如果对象是一个表则返回<code>#t</code>。要小心的是空表<code>’()</code>是一个表但是不是一个序对。</li><li><code>null?</code> 如果对象是空表’()的话就返回#t。</li><li><code>symbol?</code> 如果对象是一个符号则返回#t。</li><li><code>char?</code> 如果对象是一个字符则返回#t。</li><li><code>string?</code> 如果对象是一个字符串则返回#t。</li><li><code>number?</code> 如果对象是一个数字则返回#t。</li><li><code>complex?</code> 如果对象是一个复数则返回#t。</li><li><code>real?</code> 如果对象是一个实数则返回#t。</li><li><code>rational?</code> 如果对象是一个有理数则返回#t。</li><li><code>integer?</code> 如果对象是一个整数则返回#t。</li><li><code>exact?</code> 如果对象不是一个浮点数的话则返回#t。</li><li><code>inexact?</code> 如果对象是一个浮点数的话则返回#t。</li></ul><h3 id="用于比较数的函数"><a href="#用于比较数的函数" class="headerlink" title="用于比较数的函数"></a>用于比较数的函数</h3><blockquote><p><code>=</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;=</code><br>这些函数都有任意个数的参数。如果参数是按照这些函数的名字排序的话，函数就返回<code>#t</code>。</p></blockquote><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token operator">=</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token operator">=</span> <span class="token number">2</span> <span class="token number">2</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">3.1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token operator">></span> <span class="token number">4</span> <span class="token number">1</span> <span class="token number">-0.2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">1.1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token operator">>=</span> <span class="token number">2</span> <span class="token number">1</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token operator">&lt;</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">3.9</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: ()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>odd?</code>、<code>even?</code>、<code>positive?</code>、<code>negative?</code>、<code>zero?</code><br>这些函数仅有一个参数，如果这些参数满足函数名所指示的条件话就返回<code>#t</code>。</p></blockquote><h3 id="用于比较符号的函数"><a href="#用于比较符号的函数" class="headerlink" title="用于比较符号的函数"></a>用于比较符号的函数</h3><p>在比较字符的时候可以使用<code>char=?</code>、<code>char&lt;?</code>、<code>char&gt;?</code>、<code>char&lt;=?</code>以及<code>char&gt;=?</code>函数。具体的细节请参见R5RS。</p><h3 id="用于比较字符串的函数"><a href="#用于比较字符串的函数" class="headerlink" title="用于比较字符串的函数"></a>用于比较字符串的函数</h3><p>比较字符串时，可以使用<code>string=?</code>和<code>string-ci=?</code>等函数。具体细节请参见R5RS。</p><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><h3 id="let表达式"><a href="#let表达式" class="headerlink" title="let表达式"></a>let表达式</h3><p>使用<code>let</code>表达式可以定义局部变量。格式如下：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">let</span> binds body<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>变量在<code>binds</code>定义的形式中被声明并初始化。<code>body</code>由任意多个S-表达式构成。<code>binds</code>的格式如下：</p><pre><code>[binds] → ((p1 v1) (p2 v2) ...)</code></pre><p>声明了变量<code>p1</code>、<code>p2</code>，并分别为它们赋初值<code>v1</code>、<code>v2</code>。变量的<strong>作用域（Scope）</strong>为<code>body</code>体，也就是说变量只在<code>body</code>中有效。</p><blockquote><p>例1：声明局部变量<code>i</code>和<code>j</code>，将它们与<code>1</code>、<code>2</code>绑定，然后求二者的和。</p></blockquote><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">j</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token operator">+</span> i j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>let</code>表达式可以嵌套使用。</p><blockquote><p>例2：声明局部变量<code>i</code>和<code>j</code>，并将分别将它们与<code>1</code>和<code>i+2</code>绑定，然后求它们的乘积。</p></blockquote><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">j</span> <span class="token punctuation">(</span><span class="token operator">+</span> i <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token operator">*</span> i j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>由于变量的作用域仅在<code>body</code>中，下列代码会产生错误，因为在变量<code>j</code>的作用域中没有变量<code>i</code>的定义。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">j</span> <span class="token punctuation">(</span><span class="token operator">+</span> i <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token operator">*</span> i j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Error</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>let*</code>表达式可以用于引用定义在同一个绑定中的变量。实际上，<code>let*</code>只是嵌套的<code>let</code>表达式的语法糖而已。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">let*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">j</span> <span class="token punctuation">(</span><span class="token operator">+</span> i <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token operator">*</span> i j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>例3：函数<code>quadric-equation</code>用于计算二次方程。它需要三个代表系数的参数：<code>a</code>、<code>b</code>、<code>c</code> （<code>ax^2 + bx + c = 0</code>），返回一个存放答案的实数表。通过逐步地使用<code>let</code>表达式，可以避免不必要的计算。</p></blockquote><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token comment" spellcheck="true">;;;The scopes of variables d,e, and f are the regions with the same background colors.</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">quadric-equation</span> a b c<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">zero?</span> a<span class="token punctuation">)</span>            <span class="token string">'error</span>                                      <span class="token comment" spellcheck="true">; 1</span>      <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">d</span> <span class="token punctuation">(</span><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token operator">*</span> b b<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">4</span> a c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">; 2</span>        <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">negative?</span> d<span class="token punctuation">)</span>            <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                                      <span class="token comment" spellcheck="true">; 3</span>            <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">e</span> <span class="token punctuation">(</span><span class="token operator">/</span> b a <span class="token number">-2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">; 4</span>              <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">zero?</span> d<span class="token punctuation">)</span>              <span class="token punctuation">(</span><span class="token builtin">list</span> e<span class="token punctuation">)</span>              <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">f</span> <span class="token punctuation">(</span><span class="token operator">/</span> <span class="token punctuation">(</span><span class="token function">sqrt</span> d<span class="token punctuation">)</span> a <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">; 5</span>                <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token punctuation">(</span><span class="token operator">+</span> e f<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">-</span> e f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">quadric-equation</span> <span class="token number">3</span> <span class="token number">5</span> <span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">; solution of 3x^2+5x+2=0</span><span class="token comment" spellcheck="true">;Value 12: (-2/3 -1)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上，<code>let</code>表达式只是<code>lambda</code>表达式的一个语法糖：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">p1</span> v1<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">p2</span> v2<span class="token punctuation">)</span> ...<span class="token punctuation">)</span> exp1 exp2 ...<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token function">p1</span> p2 ...<span class="token punctuation">)</span>    exp1 exp2 ...<span class="token punctuation">)</span> v1 v2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这是因为<code>lambda</code>表达式用于定义函数，它为变量建立了一个作用域。也就是闭包的概念</p><h2 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Scheme中通常通过递归实现重复，而不是循环。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>在自己的定义中调用自己的函数叫做<strong>递归函数（Recursive Function）</strong>。虽然这听起来很奇怪，但是循环的常见方法。如果你把函数类比为机器的话，递归似乎毫无道理。然而，正因为函数是过程，函数调用自己是有意义的。比如说，让我们来考察一下文献调研吧。你可能需要去阅读你正在阅读的文献所引用的文献（cited-1）。进一步，你可能还需要去阅读文件（cite-1）所引用的其它文献。这样，文献调研就是一个递归的过程，你也可以重复这个调研过程直到满足了特定条件（比如说，你累了）。这样，将程序设计语言中的函数类比为人类活动（比如文献调研）将有助于理解递归函数。</p><p>我们通常使用计算阶乘来解释递归。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">fact</span> n<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> n <span class="token number">1</span><span class="token punctuation">)</span>      <span class="token number">1</span>      <span class="token punctuation">(</span><span class="token operator">*</span> n <span class="token punctuation">(</span><span class="token function">fact</span> <span class="token punctuation">(</span><span class="token operator">-</span> n <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>(fact 5)</code>的计算过程如下：</p><pre><code>(fact 5)⇒ 5 * (fact 4)⇒ 5 * 4 * (fact 3)⇒ 5 * 4 * 3 * (fact 2)⇒ 5 * 4 * 3 * 2 * (fact 1)⇒ 5 * 4 * 3 * 2 * 1⇒ 5 * 4 * 3 * 2⇒ 5 * 4 * 6⇒ 5 * 24⇒ 120</code></pre><p><code>(fact 5)</code>调用<code>(fact 4)</code>，<code>(fact 4)</code>调用<code>(fact 3)</code>，最后<code>(fact 1)</code>被调用。<code>(fact 5)</code>，<code>(fact 4)</code>……以及<code>(fact 1)</code>都被分配了不同的存储空间，直到<code>(fact (- i 1))</code>返回一个值之前，<code>(fact i)</code>都会保留在内存中，由于存在函数调用的开销，这通常会占用更多地内存空间和计算时间。</p><p>然而，递归函数可以以一种简单的方式表达重复。表是被递归定义的，进而表和递归函数可以很好地配合。例如，一个让表中所有元素翻倍的函数可以像下面这样写。如果参数是空表，那么函数应该停止计算并返回一个空表。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token builtin">list</span>*2 ls<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">null?</span> ls<span class="token punctuation">)</span>      <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">2</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token punctuation">(</span><span class="token builtin">list</span>*2 <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><p>普通的递归调用并不高效因为它既浪费存储空间又具有函数调用开销。与之相反，尾递归函数包含了计算结果，当计算结束时直接将其返回。特别地，由于Scheme规范要求尾递归调用转化为循环，因此尾递归调用就不存在函数调用开销。</p><p>[代码片段2]展示了[代码片段1]中函数<code>fact</code>的尾递归版本。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">fact-tail</span> n<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">fact-rec</span> n n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">fact-rec</span> n p<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> n <span class="token number">1</span><span class="token punctuation">)</span>      p      <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">m</span> <span class="token punctuation">(</span><span class="token operator">-</span> n <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token function">fact-rec</span> m <span class="token punctuation">(</span><span class="token operator">*</span> p m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>fact-tail</code>计算阶乘的过程像这样：</p><pre><code>(fact-tail 5)⇒ (fact-rec 5 5)⇒ (fact-rec 4 20)⇒ (fact-rec 3 60)⇒ (fact-rec 2 120)⇒ (fact-rec 1 120)⇒ 120</code></pre><p>因为<code>fact-rec</code>并不等待其它函数的计算结果，因此当它计算结束时即从内存中释放。计算通过修改<code>fact-rec</code>的参数来演进，这基本上等同于循环。如上文所述，Scheme将尾递归转化为循环，Scheme就无需提供循环的语法来实现重复。</p><h3 id="命名let"><a href="#命名let" class="headerlink" title="命名let"></a>命名let</h3><p>命名<code>let</code>（<strong>named let</strong>）可以用来表达循环。[代码片段3]中的函数<code>fact-let</code>展示了如何使用命名<code>let</code>来计算阶乘。<code>fact-let</code>函数使用了一个<strong>命名<code>let</code>表达式</strong><code>(loop)</code>，这与在[代码片段2]中展示的<code>fact-rec</code>函数是不同的。在被注释为<code>;1</code>的那行，代码将参数<code>n1</code>和<code>p</code>都初始化为<code>n</code>。再每次循环后，参数在被注释为<code>;2</code>的那行更新：将<code>n1</code>减1，而将<code>p</code>乘以<code>(n1 - 1)</code>。</p><p>在Scheme中，用命名<code>let</code>来表达循环是俗成的方法。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">fact-let</span> n<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">let</span> loop<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">n1</span> n<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">p</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span>           <span class="token comment" spellcheck="true">; 1</span>    <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> n1 <span class="token number">1</span><span class="token punctuation">)</span>                        p    <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">m</span> <span class="token punctuation">(</span><span class="token operator">-</span> n1 <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token function">loop</span> m <span class="token punctuation">(</span><span class="token operator">*</span> p m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">; 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="letrec"><a href="#letrec" class="headerlink" title="letrec"></a>letrec</h3><p><code>letrec</code>类似于<code>let</code>，但它允许一个名字递归地调用它自己。语法<code>letrec</code>通常用于定义复杂的递归函数。[代码片段4]展示了<code>fact</code>函数的<code>letrec</code>版本。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">fact-letrec</span> n<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">letrec</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">iter</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token function">n1</span> p<span class="token punctuation">)</span>           <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> n1 <span class="token number">1</span><span class="token punctuation">)</span>               p               <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">m</span> <span class="token punctuation">(</span><span class="token operator">-</span> n1 <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token punctuation">(</span><span class="token function">iter</span> m <span class="token punctuation">(</span><span class="token operator">*</span> p m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">; *</span>    <span class="token punctuation">(</span><span class="token function">iter</span> n n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正如被注释为<code>;*</code>的那行代码所示，局部变量<code>iter</code>可以在它的定义里面引用它自己。语法<code>letrec</code>是定义局部变量的俗成方式。</p><h3 id="do表达式"><a href="#do表达式" class="headerlink" title="do表达式"></a>do表达式</h3><p>虽然并不常见，但语法<code>do</code>也可用于表达重复。它的格式如下：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">do</span> binds <span class="token punctuation">(</span><span class="token function">predicate</span> value<span class="token punctuation">)</span>    body<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>变量在<code>binds</code>部分被绑定，而如果<code>predicate</code>被求值为真，则函数从循环中<strong>逃逸（escape）</strong>出来，并返回值<code>value</code>，否则循环继续进行。</p><p><code>binds</code>部分的格式如下所示：</p><pre><code>[binds] → ((p1 i1 u1) (p2 i2 u2) ... )</code></pre><p>变量<code>p1</code>，<code>p2</code>，…被分别初始化为<code>i1</code>，<code>i2</code>，…并在循环后分别被更新为<code>u1</code>，<code>u2</code>，…。</p><p>[代码片段5]演示了<code>fact</code>的<code>do</code>表达式版本。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">fact-do</span> n<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">do</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">n1</span> n <span class="token punctuation">(</span><span class="token operator">-</span> n1 <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">p</span> n <span class="token punctuation">(</span><span class="token operator">*</span> p <span class="token punctuation">(</span><span class="token operator">-</span> n1 <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">=</span> n1 <span class="token number">1</span><span class="token punctuation">)</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>变量<code>n1</code>和<code>p</code>分别被初始化为<code>n</code>和<code>n</code>，在每次循环后分别被减去1和乘以<code>(n1 - 1)</code>。当<code>n1</code>变为<code>1</code>时，函数返回<code>p</code>。</p><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p><strong>高阶函数（Higher Order Function）</strong>是一种以函数为参数的函数。它们都被用于<strong>映射（mapping）</strong>、<strong>过滤（filtering）</strong>、<strong>归档（folding）</strong>和<strong>排序（sorting）</strong>表。高阶函数提高了程序的模块性。编写对各种情况都适用的高阶函数与为单一情况编写递归函数相比，可以使程序更具可读性。比如说，使用一个高阶函数来实现排序可以使得我们使用不同的条件来排序，这就将排序条件和排序过程清楚地划分开来。函数<code>sort</code>具有两个参数，其一是一个待排序的表，其二是<strong>定序（Ordering）</strong>函数。下面展示了按照大小将一个整数表正序排序。<code>&lt;</code>函数就是（本例中的）两数的定序函数。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">sort</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">7883</span> <span class="token number">9099</span> <span class="token number">6729</span> <span class="token number">2828</span> <span class="token number">7754</span> <span class="token number">4179</span> <span class="token number">5340</span> <span class="token number">2644</span> <span class="token number">2958</span> <span class="token number">2239</span><span class="token punctuation">)</span> &lt;<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒  (2239 2644 2828 2958 4179 5340 6729 7754 7883 9099)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>另一方面，按照每个数末两位的大小排序可以按下面的方式实现：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">sort</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">7883</span> <span class="token number">9099</span> <span class="token number">6729</span> <span class="token number">2828</span> <span class="token number">7754</span> <span class="token number">4179</span> <span class="token number">5340</span> <span class="token number">2644</span> <span class="token number">2958</span> <span class="token number">2239</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token function">x</span> y<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token function">modulo</span> x <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">modulo</span> y <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒  (2828 6729 2239 5340 2644 7754 2958 4179 7883 9099)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>正如这里所演示的，像<strong>快速排序（Quick Sort）</strong>、<strong>归并排序（Merge Sort）</strong>等排序过程，将定序函数完全分离开来提高了代码的复用性。</p><p>在本节中，将讲解预定义的高阶函数，然后介绍如何定义高阶函数。由于Scheme并不区别过程和其它的数据结构，因此你可以通过将函数当作参数传递轻松的定义自己的高阶函数。</p><p>实际上，Scheme中预定义函数的本质就是高阶函数，因为Scheme并没有定义块结构的语法，因此使用<code>lambda</code>表达式作为一个块。</p><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>映射是将同样的行为应用于表所有元素的过程。R5RS定义了两个映射过程：其一为返回转化后的表的<code>map</code>过程，另一为注重副作用的<code>for-each</code>过程。</p><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p><code>map</code>过程的格式如下：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">map</span> procedure list1 list2 ...<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>procedure</code>是个与某个过程或<code>lambda</code>表达式相绑定的符号。作为参数的表的个数视<code>procedure</code>需要的参数而定。</p><p>例：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token comment" spellcheck="true">; Adding each item of '(1 2 3) and '(4 5 6).</span><span class="token punctuation">(</span><span class="token function">map</span> + <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">4</span> <span class="token number">5</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒  (5 7 9)</span><span class="token comment" spellcheck="true">; Squaring each item of '(1 2 3)</span><span class="token punctuation">(</span><span class="token function">map</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span> x x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒  (1 4 9)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="for-each"><a href="#for-each" class="headerlink" title="for-each"></a>for-each</h3><p><code>for-each</code>的格式与<code>map</code>一致。但<code>for-each</code>并不返回一个具体的值，只是用于副作用。</p><p>例：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> sum <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">for-each</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">set!</span> sum <span class="token punctuation">(</span><span class="token operator">+</span> sum x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>sum<span class="token comment" spellcheck="true">;⇒  10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><p>尽管过滤函数并没有在R5RS中定义，但MIT-Scheme实现提供了<code>keep-matching-items</code>和<code>delete-matching-item</code>两个函数。其它实现中应该有类似的函数。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">keep-matching-items</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">-3</span> <span class="token number">-4</span> <span class="token number">5</span><span class="token punctuation">)</span> positive?<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒  (1 2 5)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="归档"><a href="#归档" class="headerlink" title="归档"></a>归档</h3><p>尽管在R5RS中没有定义归档函数，但MIT-Scheme提供了<code>reduce</code>等函数。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">reduce</span> + <span class="token number">0</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                 <span class="token comment" spellcheck="true">;⇒  10</span><span class="token punctuation">(</span><span class="token function">reduce</span> + <span class="token number">0</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                     <span class="token comment" spellcheck="true">;⇒  3</span><span class="token punctuation">(</span><span class="token function">reduce</span> + <span class="token number">0</span> <span class="token string">'</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">)</span>                       <span class="token comment" spellcheck="true">;⇒  1</span><span class="token punctuation">(</span><span class="token function">reduce</span> + <span class="token number">0</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                        <span class="token comment" spellcheck="true">;⇒  0</span><span class="token punctuation">(</span><span class="token function">reduce</span> + <span class="token number">0</span> <span class="token string">'</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">)</span>                     <span class="token comment" spellcheck="true">;⇒  foo</span><span class="token punctuation">(</span><span class="token function">reduce</span> list <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">;⇒  (((1 2) 3) 4)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>尽管R5RS中没有定义排序函数，但MIT-Scheme提供了<code>sort</code>（实为<code>merge-sort</code>实现）和<code>quick-sort</code>函数。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">sort</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">3</span> <span class="token number">5</span> <span class="token number">1</span> <span class="token number">4</span> <span class="token number">-1</span><span class="token punctuation">)</span> &lt;<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒  (-1 1 3 4 5)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="apply函数"><a href="#apply函数" class="headerlink" title="apply函数"></a>apply函数</h3><p><code>apply</code>函数是将一个过程应用于一个表（译注：将表展开，作为过程的参数）。此函数具有任意多个参数，但首参数和末参数分别应该是一个过程和一个表。虽然乍看之下不然，但这个函数的确非常方便。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token builtin">apply</span> max <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">3</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">;⇒   3</span><span class="token punctuation">(</span><span class="token builtin">apply</span> + <span class="token number">1</span> <span class="token number">2</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">3</span> <span class="token number">4</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">;⇒  15</span><span class="token punctuation">(</span><span class="token builtin">apply</span> - <span class="token number">100</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">5</span> <span class="token number">12</span> <span class="token number">17</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">;⇒  66</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="编写高阶函数"><a href="#编写高阶函数" class="headerlink" title="编写高阶函数"></a>编写高阶函数</h3><p>自己编写高阶函数非常容易。这里用<code>member-if</code>、<code>member</code>演示。</p><h3 id="member-if和member"><a href="#member-if和member" class="headerlink" title="member-if和member"></a>member-if和member</h3><p><code>member-if</code>函数使用一个谓词和一个表作为参数，返回一个子表，该子表的<code>car</code>部分即是原列表中首个满足该谓词的元素。<code>member-if</code>函数可以像下面这样定义：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">member-if</span> proc ls<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">cond</span>   <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">null?</span> ls<span class="token punctuation">)</span> <span class="token boolean">#f</span><span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">proc</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span> ls<span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token keyword">else</span> <span class="token punctuation">(</span><span class="token function">member-if</span> proc <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">member-if</span> positive? <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">0</span> <span class="token number">-1</span> <span class="token number">-2</span> <span class="token number">3</span> <span class="token number">5</span> <span class="token number">-7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒  (3 5 -7)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，<code>member</code>函数检查特定元素是否在表中，该函数编写如下。函数需要三个参数，其一为用于比较的函数，其二为特定项，其三为待查找表。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">member</span> proc obj ls<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">cond</span>   <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">null?</span> ls<span class="token punctuation">)</span> <span class="token boolean">#f</span><span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">proc</span> obj <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span> ls<span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token keyword">else</span> <span class="token punctuation">(</span><span class="token function">member</span> proc obj <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">member</span> string=? <span class="token string">"hello"</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token string">"hi"</span> <span class="token string">"guys"</span> <span class="token string">"bye"</span> <span class="token string">"hello"</span> <span class="token string">"see you"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒  ("hello" "see you")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="输入-输出"><a href="#输入-输出" class="headerlink" title="输入/输出"></a>输入/输出</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>通过前面章节的学习，你已经可以在Scheme的交互式前端中编写并执行程序了。在本章中，我讲介绍如何输入和输出。使用这个特性，你可以从文件中读取数据或向文件中写入数据。</p><h2 id="从文件输入"><a href="#从文件输入" class="headerlink" title="从文件输入"></a>从文件输入</h2><h3 id="open-input-file，read-char和eof-object"><a href="#open-input-file，read-char和eof-object" class="headerlink" title="open-input-file，read-char和eof-object?"></a>open-input-file，read-char和eof-object?</h3><p>函数<code>(open-input-file filename)</code>可以用于打开一个文件。此函数返回一个用于输入的端口。函数<code>(read-char port)</code>用于从端口中读取一个字符。当读取到<strong>文件结尾（EOF）</strong>时，此函数返回<code>eof-object</code>，你可以使用<code>eof-object?</code>来检查。函数<code>(close-input-port port)</code>用于关闭输入端口。[代码片段1]展示了一个函数，该函数以字符串形式返回了文件内容。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">read-file</span> file-name<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">p</span> <span class="token punctuation">(</span><span class="token function">open-input-file</span> file-name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">let</span> loop<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">ls1</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">c</span> <span class="token punctuation">(</span><span class="token function">read-char</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">eof-object?</span> c<span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token keyword">begin</span>        <span class="token punctuation">(</span><span class="token function">close-input-port</span> p<span class="token punctuation">)</span>        <span class="token punctuation">(</span><span class="token builtin">list</span>->string <span class="token punctuation">(</span><span class="token function">reverse</span> ls1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> c ls1<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">read-char</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比如，在[范例1]中展示的结果就是将[代码片段1]应用于文件hello.txt。由于换行符是由<code>&#39;\n&#39;</code>表示的，这就很容易阅读。然而，像格式化输出[范例2]，我们也可使用<code>display</code>函数。</p><pre><code>Hello world!Scheme is an elegant programming language.</code></pre><h3 id="语法call-with-input-file和with-input-from-file"><a href="#语法call-with-input-file和with-input-from-file" class="headerlink" title="语法call-with-input-file和with-input-from-file"></a>语法call-with-input-file和with-input-from-file</h3><p>你通过使用语法<code>call-with-input-file</code>和<code>with-input-from-file</code>来打开文件以供读取输入。这些语法是非常方便的，因为它们要处理错误。</p><blockquote><pre><code>(call-with-input-file filename procedure)</code></pre><p>该函数将名为<code>filename</code>的文件打开以供读取输入。函数<code>procedure</code>接受一个输入端口作为参数。文件有可能再次使用，因此当<code>procedure</code>结束时文件不会自动关闭，文件应该显式地关闭。[代码片段1]可以按照[代码片段2]那样用<code>call-with-input-file</code>编写。</p></blockquote><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">read-file</span> file-name<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">call-with-input-file</span> file-name    <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token keyword">let</span> loop<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">ls1</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">c</span> <span class="token punctuation">(</span><span class="token function">read-char</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">eof-object?</span> c<span class="token punctuation">)</span>        <span class="token punctuation">(</span><span class="token keyword">begin</span>          <span class="token punctuation">(</span><span class="token function">close-input-port</span> p<span class="token punctuation">)</span>          <span class="token punctuation">(</span><span class="token builtin">list</span>->string <span class="token punctuation">(</span><span class="token function">reverse</span> ls1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> c ls1<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">read-char</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>(with-input-from-file filename procedure)</code> 该函数将名为<code>filename</code>的文件作为标准输入打开。函数<code>procedure</code>不接受任何参数。当<code>procedure</code>退出时，文件自动被关闭。[代码片段3]展示了如何用<code>with-input-from-file</code>来重写[代码片段1]。</p></blockquote><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">read-file</span> file-name<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">with-input-from-file</span> file-name    <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token keyword">let</span> loop<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">ls1</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">c</span> <span class="token punctuation">(</span>read-char<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">eof-object?</span> c<span class="token punctuation">)</span>        <span class="token punctuation">(</span><span class="token builtin">list</span>->string <span class="token punctuation">(</span><span class="token function">reverse</span> ls1<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> c ls1<span class="token punctuation">)</span> <span class="token punctuation">(</span>read-char<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3><p>函数<code>(read port)</code>从端口<code>port</code>中读入一个S-表达式。用它来读诸如”paren.txt”中带括号的内容就很方便。</p><pre><code>&#39;(Hello world!Scheme is an elegant programming language.)&#39;(Lisp is a programming language ready to evolve.)(define (s-read file-name)  (with-input-from-file file-name    (lambda ()      (let loop ((ls1 &#39;()) (s (read)))    (if (eof-object? s)        (reverse ls1)        (loop (cons s ls1) (read)))))))</code></pre><p>下面展示了用<code>s-read</code>读取”paren.txt”的结果。</p><pre><code>(s-read &quot;paren.txt&quot;)⇒ ((quote (hello world! scheme is an elegant programming language.))(quote (lisp is a programming language ready to evolve.)))</code></pre><h3 id="输出至文件"><a href="#输出至文件" class="headerlink" title="输出至文件"></a>输出至文件</h3><h4 id="打开一个用于输出的port"><a href="#打开一个用于输出的port" class="headerlink" title="打开一个用于输出的port"></a>打开一个用于输出的port</h4><p>输出有和输入类似的函数，比如：</p><p><strong>(open-output-file filename)</strong></p><p>该函数打开一个文件用作输出，放回该输出端口。</p><p><strong>(close-output-port port)</strong></p><p>关闭用于输出的端口。</p><p><strong>(call-with-output-file filename procedure)</strong></p><p>打开文件<code>filename</code>用于输出，并调用过程<code>procedure</code>。该函数以输出端口为参数。</p><p><strong>(with-output-to-file filename procedure)</strong></p><p>打开文件<code>filename</code>作为标准输出，并调用过程<code>procedure</code>。该过程没有参数。当控制权从过程<code>procedure</code>中返回时，文件被关闭。</p><h3 id="用于输出的函数"><a href="#用于输出的函数" class="headerlink" title="用于输出的函数"></a>用于输出的函数</h3><p>下面的函数可用于输出。如果参数<code>port</code>被省略的话，则输出至标准输出。</p><p><strong>(write obj port)</strong></p><p>该函数将<code>obj</code>输出至<code>port</code>。字符串被双引号括起而字符具有前缀<code>#\</code>。</p><p><strong>(display obj port)</strong></p><p>该函数将<code>obj</code>输出至<code>port</code>。字符串<em>不被</em>双引号括起而字符<em>不</em>具有前缀<code>#\</code>。</p><p><strong>(newline port)</strong></p><p>向 <code>port</code> 输出一个换行符。</p><p><strong>(write-char char port)</strong></p><p>该函数向<code>port</code>写入一个字符。</p><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p>因为Scheme是函数式语言，通常来说，你可以编写不使用赋值的语句。然而，如果使用赋值的话，有些算法就可以轻易实现了。尤其是内部状态和<strong>继续（continuations ）</strong>需要赋值。</p><p>尽管赋值非常习见并且易于理解，但它有一些本质上的缺陷。参见《计算机程序的构造和解释》的第三章第一节“赋值和局部状态”以及《为什么函数式编程如此重要》。</p><p>R5RS中规定的用于赋值的特殊形式是<code>set!</code>、<code>set-car!</code>、<code>set-cdr!</code>、<code>string-set!</code>、<code>vector-set!</code>等。除此之外，有些实现也依赖于赋值。由于赋值改变了参数的值，因此它具有<strong>破坏性（destructive）</strong>。Scheme中，具有破坏性的方法都以<code>!</code>结尾，以警示程序员。</p><h3 id="set"><a href="#set" class="headerlink" title="set!"></a>set!</h3><p><code>set!</code>可以为一个参数赋值。与Common Lisp不同，<code>set!</code>无法给一个S-表达式赋值。</p><p>赋值前参数应被定义。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> var <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">set!</span> var <span class="token punctuation">(</span><span class="token operator">*</span> var <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>var ⇒ <span class="token number">10</span><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">set!</span> i <span class="token punctuation">(</span><span class="token operator">+</span> i <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    i<span class="token punctuation">)</span>⇒ <span class="token number">4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="赋值和内部状态"><a href="#赋值和内部状态" class="headerlink" title="赋值和内部状态"></a>赋值和内部状态</h3><h4 id="静态作用域（词法闭包）"><a href="#静态作用域（词法闭包）" class="headerlink" title="静态作用域（词法闭包）"></a>静态作用域（词法闭包）</h4><p>Scheme中变量的作用域被限定在了源码中定义其的那个括号里。作用域与源代码书写方式一致的作用域称为<strong>“词法闭包（Lexical closure）”</strong>或<strong>“静态作用域（Static scope）”</strong>。采用静态作用域减轻了程序员的负担，因为它已经在代码中体现了，因此你可以很容易理解。另一方面，还有一种被称为<strong>“动态作用域（Dynamic scope）”</strong>的作用域。这种作用域仅在程序运行时确定。由于会在调试时带来种种问题，这种作用域现在已经不再使用。</p><p>特殊形式<code>let</code>、<code>lambda</code>、<code>letrec</code>生成闭包。lambda表达式的参数仅在函数定义内部有效。<code>let</code>只是<code>lambda</code>的语法糖，因此二者无异。</p><h4 id="使用赋值和词法闭包来实现内部状态"><a href="#使用赋值和词法闭包来实现内部状态" class="headerlink" title="使用赋值和词法闭包来实现内部状态"></a>使用赋值和词法闭包来实现内部状态</h4><p>你可以使用词法闭包来实现带有内部状态的过程。例如，用于模拟银行账户的过程可以按如下的方式编写：初始资金是10美元。函数接收一个整形参数。正数表示存入，负数表示取出。为了简单起见，这里允许存款为负数。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> bank-account  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">balance</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token keyword">set!</span> balance <span class="token punctuation">(</span><span class="token operator">+</span> balance n<span class="token punctuation">)</span><span class="token punctuation">)</span>      balance<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该过程将存款赋值为<code>(+ balance n)</code>。下面是调用这个过程的结果。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">bank-account</span> <span class="token number">20</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">; donating 20 dollars </span><span class="token comment" spellcheck="true">;Value: 30</span><span class="token punctuation">(</span><span class="token function">bank-account</span> <span class="token number">-25</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">; withdrawing 25 dollars</span><span class="token comment" spellcheck="true">;Value: 5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为在Scheme中，你可以编写返回过程的过程，因此你可以编写一个创建银行账户的函数。这个例子喻示着使用函数式程序设计语言可以很容易实现面向对象程序设计语言。实际上，只需要在这个基础上再加一点东西就可以实现一门面向对象程序设计语言了。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">make-bank-account</span> balance<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">set!</span> balance <span class="token punctuation">(</span><span class="token operator">+</span> balance n<span class="token punctuation">)</span><span class="token punctuation">)</span>    balance<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> gates-bank-account <span class="token punctuation">(</span><span class="token function">make-bank-account</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">; Gates makes a bank account by donating  10 dollars</span><span class="token comment" spellcheck="true">;Value: gates-bank-account</span><span class="token punctuation">(</span><span class="token function">gates-bank-account</span> <span class="token number">50</span><span class="token punctuation">)</span>                              <span class="token comment" spellcheck="true">; donating 50 dollars</span><span class="token comment" spellcheck="true">;Value: 60</span><span class="token punctuation">(</span><span class="token function">gates-bank-account</span> <span class="token number">-55</span><span class="token punctuation">)</span>                             <span class="token comment" spellcheck="true">; withdrawing 55 dollars</span><span class="token comment" spellcheck="true">;Value: 5</span><span class="token punctuation">(</span><span class="token keyword">define</span> torvalds-bank-account <span class="token punctuation">(</span><span class="token function">make-bank-account</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">; Torvalds makes a bank account by donating 100 dollars</span><span class="token comment" spellcheck="true">;Value: torvalds-bank-account</span><span class="token punctuation">(</span><span class="token function">torvalds-bank-account</span> <span class="token number">-70</span><span class="token punctuation">)</span>                             <span class="token comment" spellcheck="true">; withdrawing 70 dollars</span><span class="token comment" spellcheck="true">;Value: 30</span><span class="token punctuation">(</span><span class="token function">torvalds-bank-account</span> <span class="token number">300</span><span class="token punctuation">)</span>                             <span class="token comment" spellcheck="true">; donating 300 dollars</span><span class="token comment" spellcheck="true">;Value: 330</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h3><p>Scheme过程的主要目的是返回一个值，而另一个目的则称为<strong>副作用（Side Effect）</strong>。赋值和IO操作就是副作用。</p><h3 id="表的破坏性操作（set-car-，set-cdr-）"><a href="#表的破坏性操作（set-car-，set-cdr-）" class="headerlink" title="表的破坏性操作（set-car!，set-cdr!）"></a>表的破坏性操作（set-car!，set-cdr!）</h3><p>函数<code>set-car!</code>和<code>set-cdr!</code>分别为一个cons单元的car部分和cdr部分赋新值。和<code>set!</code>不同，这两个操作可以为S-表达式赋值。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> tree <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">3</span> <span class="token number">4</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">set-car!</span> <span class="token punctuation">(</span><span class="token builtin">car</span> tree<span class="token punctuation">)</span> <span class="token number">100</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">; changing 1 to 100 </span>tree <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">100</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">3</span> <span class="token number">4</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">set-cdr!</span> <span class="token punctuation">(</span><span class="token function">third</span> tree<span class="token punctuation">)</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">a</span> b c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">; changing  '(7 8 9) to '(a b c) </span>tree⇒ <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">100</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">3</span> <span class="token number">4</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">6</span> a b c<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列可以用<code>set-car!</code>和<code>set-cdr!</code>实现。队列是一种<strong>先进先出(First in first out, FIFO)</strong>的数据结构，表则是<strong>先进后出(First in last out，FILO)</strong>。图表1展示了队列的结构。<code>cons-cell-top</code>的car部分指向表（头），而（<code>cons-cell-top</code>的）cdr部分指向表末的cons单元（表尾）。</p><p>入队操作按如下步骤进行：</p><ol><li>将当前最末的cons单元（可以通过<code>cons-cell-top</code>取得）的cdr部分重定向到新的元素。</li><li>将<code>cons-cell-top</code>的cdr部分重定向到新的元素</li></ol><p>出队操作按如下步骤进行:</p><ol><li>将队首元素存放在一个局部变量里。</li><li>将<code>cons-cell-top</code>的car部分重定向到表的第二个元素</li></ol><p>[代码片段1]展示了如何实现队列。函数<code>enqueue!</code>返回将元素<code>obj</code>添加进队列<code>queue</code>后的队列。函数<code>dequeue!</code>将队列的首元素移出队列并将该元素的值作为返回值。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>make-queue<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">enqueue!</span> queue obj<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">lobj</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> obj <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">null?</span> <span class="token punctuation">(</span><span class="token builtin">car</span> queue<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">begin</span>      <span class="token punctuation">(</span><span class="token function">set-car!</span> queue lobj<span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token function">set-cdr!</span> queue lobj<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">begin</span>      <span class="token punctuation">(</span><span class="token function">set-cdr!</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> queue<span class="token punctuation">)</span> lobj<span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token function">set-cdr!</span> queue lobj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token builtin">car</span> queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">dequeue!</span> queue<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">obj</span> <span class="token punctuation">(</span><span class="token builtin">car</span> <span class="token punctuation">(</span><span class="token builtin">car</span> queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token function">set-car!</span> queue <span class="token punctuation">(</span><span class="token builtin">cdr</span> <span class="token punctuation">(</span><span class="token builtin">car</span> queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> q <span class="token punctuation">(</span>make-queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: q</span><span class="token punctuation">(</span><span class="token function">enqueue!</span> q <span class="token string">'a)</span><span class="token comment" spellcheck="true">;Value 12: (a)</span><span class="token punctuation">(</span><span class="token function">enqueue!</span> q <span class="token string">'b)</span><span class="token comment" spellcheck="true">;Value 12: (a b)</span><span class="token punctuation">(</span><span class="token function">enqueue!</span> q <span class="token string">'c)</span><span class="token comment" spellcheck="true">;Value 12: (a b c)</span><span class="token punctuation">(</span><span class="token function">dequeue!</span> q<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: a</span>q<span class="token comment" spellcheck="true">;Value 13: ((b c) c)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="字符与字符串"><a href="#字符与字符串" class="headerlink" title="字符与字符串"></a>字符与字符串</h2><h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h3><p>Scheme也有像<strong>字符（Character）</strong>、<strong>字符串（String）</strong>、<strong>符号（Symbol）</strong>、<strong>向量（Vector）</strong>等的其它数据类型。</p><h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><p>在某个字符前添加<code>#\</code>来表明该物是一个字符。例如，<code>#\a</code>表示字符a。字符<code>#\Space</code>、<code>#\Tab</code>、<code>#\Linefeed</code>和<code>#\Return</code>分别代表空格（Space）、制表符（Tab），Linefeed和返回（Return）。R5RS中定义了下面的与字符相关的函数。</p><p><strong>(char? obj)</strong></p><p>如果<code>obj</code>是一个字符则返回<code>#t</code>。</p><p><strong>(char=? c1 c2)</strong></p><p>如果<code>c1</code>和<code>c2</code>是同一个字符的话则返回<code>#t</code>。</p><p><strong>(char-&gt;integer c)</strong></p><p>将<code>c</code>转化为对应的整数（字符代码，character code）。</p><p>示例：<code>(char-&gt;integer #\a) =&gt; 97</code></p><p><strong>(integer-&gt;char n)</strong></p><p>该函数将一个整数转化为对应的字符。</p><p><strong>(char&lt;? c1 c2)</strong>，</p><p><strong>(char&lt;= c1 c2)</strong>，</p><p><strong>(char&gt; c1 c2)</strong>，</p><p><strong>(char&gt;= c1 c2)</strong></p><p>这些函数用于比较字符。实际上，这些函数比较的是字符代码的大小。</p><p>例如，<code>(char&lt;? c1 c2)</code>等同于<code>(&lt; (char-&gt;integer c1) (char-&gt;integer c2))</code></p><p><strong>(char-ci=? c1 c2)</strong>，</p><p><strong>(char-ci&lt;? c1 c2)</strong>，</p><p><strong>(char-ci&lt;=? c1 c2)</strong>，</p><p><strong>(char-ci&gt;? c1 c2)</strong>，</p><p><strong>(char-ci&gt;=? c1 c2)</strong></p><p>这些比较函数对大小写不敏感。</p><p><strong>(char-alphabetic? c)</strong>，</p><p><strong>(char-numeric? c)</strong>，</p><p><strong>(char-whitespace? c)</strong>，</p><p><strong>(char-upper-case? c)</strong>，</p><p><strong>(char-lower-case? c)</strong></p><p>这些函数分别用于检测字符<code>c</code>是否为字母、数字、空白符、大写字母或小写字母。</p><p><strong>(char-upcase c)</strong>，</p><p><strong>(char-downcase c)</strong></p><p>这些函数分别返回字符C对应的大写或小写。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串通过两个闭合的双引号表示。例如，<code>&quot;abc&quot;</code>表示字符串<code>abc</code>。R5RS定义了下面的函数。</p><p><strong>(string? s)</strong></p><p>如果<code>s</code>是一个字符则返回<code>#t</code>。</p><p><strong>(make-string n c)</strong></p><p>返回由<code>n</code>个字符<code>c</code>组成的字符串。参数<code>c</code>可选。</p><p><strong>(string-length s)</strong></p><p>返回字符串<code>s</code>的长度。</p><p><strong>(string=? s1 s2)</strong></p><p>如果字符串<code>s1</code>和<code>s2</code>相同的话则返回<code>#t</code>。</p><p><strong>(string-ref s idx)</strong></p><p>返回字符串<code>s</code>中索引为<code>idx</code>的字符（索引从0开始计数）。</p><p><strong>(string-set! s idx c)</strong></p><p>将字符串<code>s</code>中索引为<code>idx</code>的字符设置为<code>c</code>。</p><p><strong>(substring s start end)</strong></p><p>返回字符串<code>s</code>从<code>start</code>开始到<code>end-1</code>处的子串。例如<code>(substring &quot;abcdefg&quot; 1 4) =&gt; &quot;b c d&quot;</code></p><p><strong>(string-append s1 s2 …)</strong></p><p>连接两个字符串<code>s1</code>和<code>s2</code></p><p><strong>(string-&gt;list s)</strong></p><p>将字符串<code>s</code>转换为由字符构成的表。</p><p><strong>(list-&gt;string ls)</strong></p><p>将一个由字符构成的表转换为字符串。</p><p><strong>(string-copy s)</strong></p><p>复制字符串<code>s</code>。</p><h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><h3 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h3><p>我会在本章讲解在Lisp/Scheme程序设计语言中极具特色的数据类型——符号。符号是一种通过地址管理字符串的数据。符号可以被如<code>eq?</code>这样运行迅速地函数处理，而纯字符串需要被更慢的<code>equal?</code>处理。由于符号可以被快速比较，它们被用于做关联表和哈希表的键。</p><h3 id="有关符号的基本函数"><a href="#有关符号的基本函数" class="headerlink" title="有关符号的基本函数"></a>有关符号的基本函数</h3><p>下列都是有关符号的基本函数。</p><p><strong>(symbol? x)</strong></p><p>如果<code>x</code>是一个符号则返回#t。</p><p><strong>(string-&gt;symbol str)</strong></p><p>将<code>str</code>转换为符号。<code>str</code>应该都是小写的，否则地址系统可能无法正常工作。在MIT-Scheme中，<code>(string-&gt;symbol &quot;Hello&quot;)</code>和<code>&#39;Hello</code>是不同的。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">eq?</span> <span class="token punctuation">(</span><span class="token function">string->symbol</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span> <span class="token string">'Hello)</span><span class="token comment" spellcheck="true">;Value: ()</span><span class="token punctuation">(</span><span class="token function">eq?</span> <span class="token punctuation">(</span><span class="token function">string->symbol</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">string->symbol</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token function">symbol->string</span>  <span class="token punctuation">(</span><span class="token function">string->symbol</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 15: "Hello"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(symbol-&gt;string sym)</strong></p><p>将<code>sym</code>转换为字符。</p><h3 id="统计文本中的单词"><a href="#统计文本中的单词" class="headerlink" title="统计文本中的单词"></a>统计文本中的单词</h3><p>下面的代码是一段统计文本中单词个数的程序，这也是被经常用作演示如何使用符号的例子。该程序使用了<strong>哈希表（Hash table）</strong>和<strong>关联表（Association list）</strong>，这些都将在下一章中讲解。</p><pre class="line-numbers language-scheme"><code class="language-scheme">    <span class="token comment" spellcheck="true">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>     <span class="token comment" spellcheck="true">;;;   wc.scm</span>     <span class="token comment" spellcheck="true">;;;   a scheme word-count program</span>     <span class="token comment" spellcheck="true">;;;</span>     <span class="token comment" spellcheck="true">;;;    by T.Shido</span>     <span class="token comment" spellcheck="true">;;;    on August 19, 2005</span>     <span class="token comment" spellcheck="true">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token builtin">list</span>->symbol ls0<span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token function">string->symbol</span> <span class="token punctuation">(</span><span class="token builtin">list</span>->string <span class="token punctuation">(</span><span class="token function">reverse!</span> ls0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">char-in</span> c . ls<span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token keyword">let</span> loop<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">ls0</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">null?</span> ls0<span class="token punctuation">)</span>             <span class="token boolean">#f</span>           <span class="token punctuation">(</span><span class="token function">or</span> <span class="token punctuation">(</span><span class="token function">char=?</span> c <span class="token punctuation">(</span><span class="token builtin">car</span> ls0<span class="token punctuation">)</span><span class="token punctuation">)</span>               <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">read-words</span> fname<span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token function">with-input-from-file</span> fname         <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>           <span class="token punctuation">(</span><span class="token keyword">let</span> loop<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">w</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">wls</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">c</span> <span class="token punctuation">(</span>read-char<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>           <span class="token punctuation">(</span><span class="token keyword">cond</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">eof-object?</span> c<span class="token punctuation">)</span>                 <span class="token punctuation">(</span><span class="token function">reverse!</span> <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">pair?</span> w<span class="token punctuation">)</span>                               <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token punctuation">(</span><span class="token builtin">list</span>->symbol w<span class="token punctuation">)</span> wls<span class="token punctuation">)</span>                             wls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">char-in</span> c #\Space #\Linefeed #\Tab #\, #\.  #\ #\<span class="token punctuation">(</span><span class="token function"></span> #\<span class="token punctuation">)</span> #\= #\? #\! #\<span class="token comment" spellcheck="true">; #\:)</span>                 <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">pair?</span> w<span class="token punctuation">)</span>                               <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token punctuation">(</span><span class="token builtin">list</span>->symbol w<span class="token punctuation">)</span> wls<span class="token punctuation">)</span>                             wls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">(</span><span class="token keyword">else</span>             <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token punctuation">(</span><span class="token function">char-downcase</span> c<span class="token punctuation">)</span> w<span class="token punctuation">)</span> wls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">sort-by-frequency</span> al<span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token function">sort</span> al <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token function">x</span> y<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">wc</span> fname<span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">wh</span> <span class="token punctuation">(</span>make-eq-hash-table<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token punctuation">(</span><span class="token keyword">let</span> loop<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">ls</span> <span class="token punctuation">(</span><span class="token function">read-words</span> fname<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>           <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">null?</span> ls<span class="token punctuation">)</span>               <span class="token punctuation">(</span><span class="token function">sort-by-frequency</span> <span class="token punctuation">(</span><span class="token function">hash-table->alist</span> wh<span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token punctuation">(</span><span class="token keyword">begin</span>             <span class="token punctuation">(</span><span class="token function">hash-table/put!</span> wh <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">1+</span> <span class="token punctuation">(</span><span class="token function">hash-table/get</span> wh <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>              <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">wc</span> <span class="token string">"opensource.txt"</span><span class="token punctuation">)</span>⇒<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">the</span> . <span class="token number">208</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">to</span> . <span class="token number">142</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">a</span> . <span class="token number">104</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">of</span> . <span class="token number">103</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">and</span> . <span class="token number">83</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">that</span> . <span class="token number">75</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">is</span> . <span class="token number">73</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">in</span> . <span class="token number">65</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">i</span> . <span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">you</span> . <span class="token number">55</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">it</span> . <span class="token number">54</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">they</span> . <span class="token number">48</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">for</span> . <span class="token number">46</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">what</span> . <span class="token number">38</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">work</span> . <span class="token number">37</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">but</span> . <span class="token number">35</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">have</span> . <span class="token number">32</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">on</span> . <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">people</span> . <span class="token number">32</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">are</span> . <span class="token number">30</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">be</span> . <span class="token number">29</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">do</span> . <span class="token number">29</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">from</span> . <span class="token number">27</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">so</span> . <span class="token number">26</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">like</span> . <span class="token number">25</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">as</span> . <span class="token number">25</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">by</span> . <span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">source</span> . <span class="token number">24</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">not</span> . <span class="token number">23</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">open</span> . <span class="token number">23</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">can</span> . <span class="token number">23</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">we</span> . <span class="token number">22</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">was</span> . <span class="token number">22</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">one</span> . <span class="token number">22</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>it<span class="token string">'s</span> . <span class="token number">22</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">an</span> . <span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">this</span> . <span class="token number">20</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">about</span> . <span class="token number">20</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">business</span> . <span class="token number">18</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">working</span> . <span class="token number">18</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">most</span> . <span class="token number">17</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">there</span> . <span class="token number">17</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">at</span> . <span class="token number">17</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">with</span> . <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">(</span>don<span class="token string">'t</span> . <span class="token number">16</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">just</span> . <span class="token number">16</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">their</span> . <span class="token number">16</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">something</span> . <span class="token number">15</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">than</span> . <span class="token number">15</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">has</span> . <span class="token number">15</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">if</span> . <span class="token number">15</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">when</span> . <span class="token number">14</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">because</span> . <span class="token number">14</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">more</span> . <span class="token number">14</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">were</span> . <span class="token number">13</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">office</span> . <span class="token number">13</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">own</span> . <span class="token number">13</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">or</span> . <span class="token number">12</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">online</span> . <span class="token number">12</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">now</span> . <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">blogging</span> . <span class="token number">12</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">how</span> . <span class="token number">12</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">employees</span> . <span class="token number">11</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">them</span> . <span class="token number">11</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">think</span> . <span class="token number">11</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">time</span> . <span class="token number">11</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">company</span> . <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">lot</span> . <span class="token number">11</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">want</span> . <span class="token number">11</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">companies</span> . <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">could</span> . <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">know</span> . <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">get</span> . <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">learn</span> . <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">better</span> . <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">some</span> . <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">who</span> . <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">even</span> . <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">thing</span> . <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">much</span> . <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">no</span> . <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">make</span> . <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">up</span> . <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">being</span> . <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">money</span> . <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">relationship</span> . <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>that<span class="token string">'s</span> . <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">us</span> . <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">anyone</span> . <span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">average</span> . <span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">bad</span> . <span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">same</span> . <span class="token number">8</span><span class="token punctuation">)</span>..........<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><p><strong>(list-&gt;symbo <code>ls0</code>)</strong></p><p>将一个由字符构成的列表（<code>ls0</code>）转换为一个符号。</p><p><strong>(char-in <code>c</code> . <code>ls</code>)</strong></p><p>检查字符（<code>c</code>）是否存在表（<code>ls</code>）。如果存在返回#t，不存在返回#f。</p><p><strong>(read-words <code>fname</code>)</strong></p><p>读取一个名为<code>fname</code>的文件，并返回一个符号列表。函数将大写转换为小写，将字符表（<code>w</code>）转换为一个字符，将<code>it</code>添加到符号表（<code>wls</code>）中。</p><p><strong>(sort-by-frequency <code>al</code>)</strong></p><p>以出现频率降序排序关联表（<code>al</code>）。</p><p><strong>(wc <code>fname</code>)</strong></p><p>读取名为<code>fname</code>的文件，并返回一个以出现频率降序排序关联表。因为函数使用了符号，<code>eq-hash-table</code>是适用的，它使用执行速度很快地<code>eq?</code>比较键（第40行）。函数统计由<code>read-words</code>创建的单词表里各单词的数量，并将其存储在一个哈希表（第44-46行）。在统计完成时（第43行），将哈希表转换为关联表。</p><h2 id="关联表和哈希表"><a href="#关联表和哈希表" class="headerlink" title="关联表和哈希表"></a>关联表和哈希表</h2><h3 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h3><p>本章中，我会讲解用于表示数据关联的关联表和哈希表。关联的数据是由键和值组成的序对，值由键唯一确定的。表1显示了书和作者构成的配对。书籍可以确定作者，反之由作者确定书籍则不可，这是因为一个作者可能会写很多本书。表1中，由于P. Graham和L.Carroll分别写了两本书，因此他们的书无法被作者的名字唯一确定。</p><p>表1：作者和书</p><table><thead><tr><th align="left">Author</th><th align="left">Book</th></tr></thead><tbody><tr><td align="left">P. Graham</td><td align="left">On Lisp</td></tr><tr><td align="left">P. Graham</td><td align="left">ANSI Common Lisp</td></tr><tr><td align="left">E. S. Raymond</td><td align="left">The Cathedral and the Bazaar</td></tr><tr><td align="left">K. Dybvig</td><td align="left">The Scheme Programming Language</td></tr><tr><td align="left">F. P. Brooks, Jr.</td><td align="left">The Mythical Man-Month</td></tr><tr><td align="left">L. Carroll</td><td align="left">Alice’s Adventures in Wonderland</td></tr><tr><td align="left">L. Carroll</td><td align="left">Through the Looking-Glass, and What Alice Found There</td></tr></tbody></table><p>R5RS定义了关联表，因此它在所有Scheme实现中都可用。但是使用关联表搜索速度较慢（O(n)的时间复杂度）。使用哈希表在速度方面更好一些（O(1)的时间复杂度），但是哈希表并未在R5RS中定义而是依赖于相关实现。MIT-Scheme实现了哈希表。如果你喜欢的Scheme实现没有哈希表，你可以自己实现一个（见 <a href="http://www.math.grin.edu/~stone/events/scheme-workshop/hash-tables.html）。">http://www.math.grin.edu/~stone/events/scheme-workshop/hash-tables.html）。</a></p><h3 id="关联表"><a href="#关联表" class="headerlink" title="关联表"></a>关联表</h3><p>关联表是一个由序对组成的表，它是一个用于表达关联的基本数据类型。符号，字符，和数字常被作为键使用，因为它们可以使用诸如<code>eq?</code>或者<code>eqv?</code>的快速比较函数被比较。在作为键被使用前，字符串应该被转换为符号，从而获得更好的性能。</p><p>下面是一个关联表的例子。关联表应该要么由点序对要么由普通表组成。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">hi</span> . <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">everybody</span> . <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">nice</span> . <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">to</span> . <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">meet</span> . <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">you</span> . <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">4</span> <span class="token number">5</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">7</span> <span class="token number">8</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>函数<code>assq</code>，<code>assv</code>，和<code>assoc</code>从关联表中搜寻一个项。这些函数从开始一步步搜索关联表。如果它们找到序对的<code>car</code>等于给定的<code>key</code>，就返回该序对。如果找不到函数返回<code>#f</code>。这些函数分别使用<code>eq?</code>，<code>eqv?</code>，和<code>equal?</code>比较键，这意味着<code>assq</code>最快，<code>assoc</code>最慢。这表示作为键的话，字符串，向量和表应该转化为符号或者数字（如果可能的话）以提高性能。</p><p>一般来说，<a href="http://www.shido.info/lisp/scheme_ah_e.html#hash">哈希表</a>在大量数据中搜索表现得更好一些。</p><p>下面展示在关联表中进行搜索的例子。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> wc <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">hi</span> . <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">everybody</span> . <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">nice</span> . <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">to</span> . <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">meet</span> . <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">you</span> . <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>⇒ wc<span class="token punctuation">(</span><span class="token function">assq</span> <span class="token string">'hi</span> wc<span class="token punctuation">)</span>⇒  <span class="token punctuation">(</span><span class="token function">hi</span> . <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">assq</span> <span class="token string">'you</span> wc<span class="token punctuation">)</span>⇒  <span class="token punctuation">(</span><span class="token function">you</span> . <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">assq</span> <span class="token string">'i</span> wc<span class="token punctuation">)</span>⇒  <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> n <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">4</span> <span class="token number">5</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">7</span> <span class="token number">8</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>⇒  n<span class="token punctuation">(</span><span class="token function">assv</span> <span class="token number">1</span> n<span class="token punctuation">)</span>⇒  <span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">assv</span> <span class="token number">8</span> n<span class="token punctuation">)</span>⇒  <span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p><a href="http://en.wikipedia.org/wiki/Hash-table">哈希表</a>是一种数据类型，它使用哈希函数将键转化为整数，并将值存储在由该整数所指示的位置。当表足够稀疏时，搜索，插入，更新都能以O(1)完成。下面展示了MIT-Scheme里哈希表的一些基本函数。查询<a href="http://www.swiss.ai.mit.edu/projects/scheme/documentation/scheme_12.html#SEC119">MIT-Scheme Manul</a>获取更详细的信息。</p><p><strong>(make-eq-hash-table size),</strong></p><p><strong>(make-eqv-hash-table size),</strong></p><p><strong>(make-equal-hash-table size),</strong></p><p><strong>(make-string-hash-table size)</strong></p><p>这些函数创建哈希表。这些函数分别使用<code>eq?</code>，<code>eqv?</code>，<code>equal?</code>，和<code>string=?</code>比较键的值。哈希表的初始大小（<code>size</code>）可以选择性指定（optional）。由于只比较键的地址，所以<code>eq-hash-table</code>是最快的。由于键是序列，所以<code>equal-hash-table</code>和<code>string-hash-table</code>比较慢。</p><p><strong>(hash-table/put! hash-table key datum)</strong></p><p>将<code>hash-table</code>中<code>key</code>对应的值设为<code>datum</code>。</p><p><strong>(hash-table/get hash-table key default)</strong></p><p>返回<code>hash-table</code>中的<code>key</code>对应的值。如果<code>key</code>不存在于<code>hash-table</code>中，返回<code>default</code>。</p><p><strong>(hash-table-&gt;alist hash-table)</strong></p><p>将<code>hash-table</code>转换为关联表。</p><h3 id="生成密码"><a href="#生成密码" class="headerlink" title="生成密码"></a>生成密码</h3><p>让我们写一个密码创建程序作为关联表和哈希表的例子。</p><p>从字典里得到的密码很容易被破解，但另一方面，完全随机的密码又很难记忆和输入。程序使用无规则的拼写创建10个密码。密码应该尽可能频繁更改，但是我懒于自己创建密码。使用这个程序，我可以简单地改变密码。</p><p>程序由两部分构成。一部分用于创建连续字符出现频率的数据（stat-spell.scm），另一个用于基于这个数据创建密码（make-pw.scm）。</p><h3 id="stat-spell-scm"><a href="#stat-spell-scm" class="headerlink" title="stat-spell.scm"></a>stat-spell.scm</h3><p>这个程序可以阅读英语句子，数据存在哈希表里，并转换为关联表输出到一个文件（stat-spell.data）。[代码1]显示了源代码。</p><p>[代码1]</p><pre class="line-numbers language-scheme"><code class="language-scheme">01:     <span class="token comment" spellcheck="true">;;; make an alist of probable spelling from a given English text</span><span class="token number">02</span>:     <span class="token number">03</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">skip-char?</span> c<span class="token punctuation">)</span><span class="token number">04</span>:       <span class="token punctuation">(</span><span class="token function">or</span> <span class="token punctuation">(</span><span class="token function">not</span> <span class="token punctuation">(</span><span class="token function">char-graphic?</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">memv</span> c <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">#\:</span> #\<span class="token comment" spellcheck="true">; #\' #\" #\`))))</span><span class="token number">05</span>:     <span class="token number">06</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">ss-make-alist</span> c alist<span class="token punctuation">)</span><span class="token number">07</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">p</span> <span class="token punctuation">(</span><span class="token function">assv</span> c alist<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">08</span>:         <span class="token punctuation">(</span><span class="token keyword">if</span> p<span class="token number">09</span>:             <span class="token punctuation">(</span><span class="token keyword">begin</span><span class="token number">10</span>:              <span class="token punctuation">(</span><span class="token function">set-cdr!</span> p <span class="token punctuation">(</span><span class="token function">1+</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">11</span>:              alist<span class="token punctuation">)</span><span class="token number">12</span>:           <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> c <span class="token number">1</span><span class="token punctuation">)</span> alist<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">13</span>:     <span class="token number">14</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">ss-make-dat</span> filename<span class="token punctuation">)</span><span class="token number">15</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">char-hash</span> <span class="token punctuation">(</span>make-eqv-hash-table<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">16</span>:         <span class="token punctuation">(</span><span class="token function">with-input-from-file</span> filename<span class="token number">17</span>:           <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">18</span>:         <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">c</span> #\Space<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">19</span>:           <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">c1</span> <span class="token punctuation">(</span>read-char<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">20</span>:                      <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">not</span> <span class="token punctuation">(</span><span class="token builtin">eof-object?</span> c1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">21</span>:                          <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">skip-char?</span> c1<span class="token punctuation">)</span><span class="token number">22</span>:                              <span class="token punctuation">(</span><span class="token function">loop</span> c<span class="token punctuation">)</span><span class="token number">23</span>:                              <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">c1</span> <span class="token punctuation">(</span><span class="token function">char-downcase</span> c1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">24</span>:                    <span class="token punctuation">(</span><span class="token function">hash-table/put!</span> char-hash c<span class="token number">25</span>:                             <span class="token punctuation">(</span><span class="token function">ss-make-alist</span> c1 <span class="token punctuation">(</span><span class="token function">hash-table/get</span> char-hash c <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">26</span>:                    <span class="token punctuation">(</span><span class="token function">loop</span> c1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">27</span>:         <span class="token punctuation">(</span><span class="token function">with-output-to-file</span> <span class="token string">"stat-spell.dat"</span><span class="token number">28</span>:           <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">29</span>:         <span class="token punctuation">(</span><span class="token function">display</span> <span class="token string">"(define *stat-spell* \'("</span><span class="token punctuation">)</span><span class="token number">30</span>:         <span class="token punctuation">(</span>newline<span class="token punctuation">)</span><span class="token number">31</span>:         <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">alst</span> <span class="token punctuation">(</span><span class="token function">sort</span> <span class="token punctuation">(</span><span class="token function">hash-table->alist</span> char-hash<span class="token punctuation">)</span> <span class="token number">32</span>:                        <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token function">x</span> y<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">char33:</span>           <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">pair?</span> alst<span class="token punctuation">)</span><span class="token number">34</span>:               <span class="token punctuation">(</span><span class="token keyword">begin</span><span class="token number">35</span>:             <span class="token punctuation">(</span><span class="token function">write</span> <span class="token punctuation">(</span><span class="token builtin">car</span> alst<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">36</span>:             <span class="token punctuation">(</span>newline<span class="token punctuation">)</span><span class="token number">37</span>:             <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> alst<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">38</span>:             <span class="token punctuation">(</span><span class="token function">display</span> <span class="token string">"))"</span><span class="token punctuation">)</span><span class="token number">39</span>:             <span class="token punctuation">(</span>newline<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(skip-char? c)</strong></p><p>如果<code>c</code>不是图像字符或者<code>c</code>是 #:, #;, #&#39;, or #&quot;，就返回#t。读取文本时，这些字符会被跳过。</p><p><strong>(ss-make-alist c alist)</strong></p><p>有两个参数；字符的频率的关联表（<code>alist</code>）和字符（<code>c</code>）。如果<code>c</code>在<code>alist</code>中，在序对的cdr部分增加一。如果不在，返回 (cons (cons c 1) alist)。这个函数使用了set-cdr!。</p><p><strong>(ss-make-dat filename)</strong></p><p>从名为<code>filename</code>的文件中读取字符，并使用跟随字符的频率的关联表来关联这些读出的字符。结果以关联表形式存储在文件<a href="http://www.shido.info/lisp/stat-spell.dat">stat-spell.dat</a>。在34和35行，它在哈希表中更新了频率的关联表。存储在stat-spell.dat的最终数据是一个关联表的关联表。例如：</p><p>(#\v (#\y . 1) (#\a . 3) (#\o . 7) (#\e . 51) (#\i . 15))</p><p>表示 #\y, #\a, #\o, #\e, 和 #\i 跟随 #\v 之后出现的次数分别是1, 3, 7, 51, 和15次。</p><h3 id="make-pw-scm"><a href="#make-pw-scm" class="headerlink" title="make-pw.scm"></a>make-pw.scm</h3><p>基于 stat-spell.dat 创建十个密码。过程如下：</p><ol><li>基于频率数据创建由9到13个随机字符组成字符串表。字符 #\Space 被添加在表结尾。</li><li>添加一个00到99之间的随机数在随机选取的字符串表的结尾。</li><li>随机地将 #\Space 转换为 #-, #_, #/, #\Space, #., 或者 #,。</li><li>随机地将30%的字母字符变为大写。</li></ol><pre class="line-numbers language-scheme"><code class="language-scheme">01:     <span class="token comment" spellcheck="true">;;; make password from the alist of probable spelling</span><span class="token number">02</span>:     <span class="token number">03</span>:     <span class="token punctuation">(</span><span class="token function">load</span> <span class="token string">"stat-spell.dat"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">; *stat-spell* (alist for following characters) is in.</span><span class="token number">04</span>:     <span class="token number">05</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">alist->hash</span> al mode<span class="token punctuation">)</span><span class="token number">06</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">h</span> <span class="token punctuation">(</span><span class="token function">case</span> mode<span class="token number">07</span>:                  <span class="token punctuation">(</span><span class="token punctuation">(</span>eq<span class="token punctuation">)</span> <span class="token punctuation">(</span>make-eq-hash-table<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">08</span>:                  <span class="token punctuation">(</span><span class="token punctuation">(</span>eqv<span class="token punctuation">)</span> <span class="token punctuation">(</span>make-eqv-hash-table<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">09</span>:                  <span class="token punctuation">(</span><span class="token punctuation">(</span>equal<span class="token punctuation">)</span> <span class="token punctuation">(</span>make-equal-hash-table<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">10</span>:                  <span class="token punctuation">(</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span> <span class="token punctuation">(</span>make-string-hash-table<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">11</span>:         <span class="token punctuation">(</span><span class="token function">for-each</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token number">12</span>:                     <span class="token punctuation">(</span><span class="token function">hash-table/put!</span> h <span class="token punctuation">(</span><span class="token builtin">car</span> p<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">13</span>:                   al<span class="token punctuation">)</span><span class="token number">14</span>:         h<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">15</span>:     <span class="token number">16</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> *stat-spell-hash* <span class="token punctuation">(</span><span class="token function">alist->hash</span> *stat-spell* <span class="token string">'eqv))</span><span class="token number">17</span>:     <span class="token number">18</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">pw-random-select</span> vec<span class="token punctuation">)</span><span class="token number">19</span>:       <span class="token punctuation">(</span><span class="token function">vector-ref</span> vec <span class="token punctuation">(</span><span class="token function">random</span> <span class="token punctuation">(</span><span class="token function">vector-length</span> vec<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">20</span>:     <span class="token number">21</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>random00<span class="token punctuation">)</span><span class="token number">22</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">acc</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">23</span>:         <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> i <span class="token number">2</span><span class="token punctuation">)</span><span class="token number">24</span>:             <span class="token punctuation">(</span><span class="token builtin">list</span>->string acc<span class="token punctuation">)</span><span class="token number">25</span>:           <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token function">1+</span> i<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token punctuation">(</span><span class="token function">pw-random-select</span> <span class="token string">'#</span><span class="token punctuation">(</span><span class="token function">#\0</span> #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9<span class="token punctuation">)</span><span class="token punctuation">)</span> acc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">26</span>:     <span class="token number">27</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">occasional-upcase</span> c<span class="token punctuation">)</span><span class="token number">28</span>:       <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token function">random</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token number">29</span>:           <span class="token punctuation">(</span><span class="token function">char-upcase</span> c<span class="token punctuation">)</span><span class="token number">30</span>:         c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">31</span>:     <span class="token number">32</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">pw-enhance</span> ls<span class="token punctuation">)</span><span class="token number">33</span>:       <span class="token punctuation">(</span><span class="token builtin">list</span>->string<span class="token number">34</span>:        <span class="token punctuation">(</span><span class="token function">map</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token number">35</span>:               <span class="token punctuation">(</span><span class="token keyword">cond</span><span class="token number">36</span>:                <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">char=?</span> c #\Space<span class="token punctuation">)</span><span class="token number">37</span>:                 <span class="token punctuation">(</span><span class="token function">pw-random-select</span>  <span class="token string">'#</span><span class="token punctuation">(</span><span class="token function">#\-</span> #\_ #\/  #\Space  #\. #\, #\@ #\? #\<span class="token punctuation">(</span><span class="token function"></span> #\<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">38</span>:                <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">char-alphabetic?</span> c<span class="token punctuation">)</span><span class="token number">39</span>:                 <span class="token punctuation">(</span><span class="token function">occasional-upcase</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">40</span>:                <span class="token punctuation">(</span><span class="token keyword">else</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">41</span>:             <span class="token punctuation">(</span><span class="token builtin">cdr</span> <span class="token punctuation">(</span><span class="token function">reverse!</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">42</span>:         <span class="token number">43</span>:     <span class="token number">44</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">random-following</span> alist<span class="token punctuation">)</span><span class="token number">45</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">n</span> <span class="token punctuation">(</span><span class="token function">random</span> <span class="token punctuation">(</span><span class="token builtin">apply</span> + <span class="token punctuation">(</span><span class="token function">map</span> cdr alist<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">46</span>:         <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">j</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">alist</span> alist<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">47</span>:           <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">pair?</span> alist<span class="token punctuation">)</span><span class="token number">48</span>:           <span class="token punctuation">(</span><span class="token keyword">let*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">pair</span> <span class="token punctuation">(</span><span class="token builtin">car</span> alist<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">49</span>:              <span class="token punctuation">(</span><span class="token function">k</span> <span class="token punctuation">(</span><span class="token operator">+</span> j <span class="token punctuation">(</span><span class="token builtin">cdr</span> pair<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">50</span>:             <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">></span> k n<span class="token punctuation">)</span><span class="token number">51</span>:             <span class="token punctuation">(</span><span class="token builtin">car</span> pair<span class="token punctuation">)</span><span class="token number">52</span>:             <span class="token punctuation">(</span><span class="token function">loop</span> k <span class="token punctuation">(</span><span class="token builtin">cdr</span> alist<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">53</span>:     <span class="token number">54</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">make-pw</span> h n<span class="token punctuation">)</span><span class="token number">55</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">c</span> #\Space<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">acc</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">56</span>:         <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> i n<span class="token punctuation">)</span><span class="token number">57</span>:             <span class="token punctuation">(</span><span class="token function">string-append</span><span class="token number">58</span>:              <span class="token punctuation">(</span><span class="token function">pw-enhance</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> #\Space <span class="token punctuation">(</span><span class="token builtin">cons</span> c acc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">59</span>:              <span class="token punctuation">(</span>random00<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">60</span>:           <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token function">1+</span> i<span class="token punctuation">)</span><span class="token number">61</span>:             <span class="token punctuation">(</span><span class="token function">random-following</span> <span class="token punctuation">(</span><span class="token function">hash-table/get</span> h c <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">#\Space</span> . <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">62</span>:             <span class="token punctuation">(</span><span class="token builtin">cons</span> c acc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">63</span>:         <span class="token number">64</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>pw-candidates<span class="token punctuation">)</span><span class="token number">65</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">66</span>:         <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> i <span class="token number">10</span><span class="token punctuation">)</span><span class="token number">67</span>:             <span class="token punctuation">(</span><span class="token keyword">begin</span><span class="token number">68</span>:              <span class="token punctuation">(</span><span class="token function">display</span> i<span class="token punctuation">)</span><span class="token number">69</span>:              <span class="token punctuation">(</span><span class="token function">display</span> <span class="token string">": "</span><span class="token punctuation">)</span><span class="token number">70</span>:              <span class="token punctuation">(</span><span class="token function">write</span> <span class="token punctuation">(</span><span class="token function">make-pw</span> *stat-spell-hash* <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">9</span> <span class="token punctuation">(</span><span class="token function">random</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">71</span>:              <span class="token punctuation">(</span>newline<span class="token punctuation">)</span><span class="token number">72</span>:              <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token function">1+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">73</span>:           <span class="token string">'done)))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="向量和结构体"><a href="#向量和结构体" class="headerlink" title="向量和结构体"></a>向量和结构体</h2><h3 id="简介-8"><a href="#简介-8" class="headerlink" title="简介"></a>简介</h3><p>本章中，我将讲解向量和结构体。</p><p>向量是一组通过整数索引的数据。与C语言中的数组不同，一个向量可以储存不同类型的数据。与表相比，向量更加紧凑且存取时间更短。但从另外一方面来说，向量是通过副作用来操作的，这样会造成负担。</p><p>Scheme中的结构体与C语言中的结构体类似。但Scheme中的结构体比C语言中的更容易使用，因为Scheme为结构体自动创建了读取函数和写入函数，这受益于Lisp/Scheme中的宏。</p><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><h4 id="字面值"><a href="#字面值" class="headerlink" title="字面值"></a>字面值</h4><p>向量通过闭合的<code>#(</code>和<code>)</code>表示，例如<code>#(1 2 3)</code>。作为字面值（literals）时，它们应该被引用（be quoted），例如：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token string">'#</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span>             <span class="token comment" spellcheck="true">; 整数向量</span><span class="token string">'#</span><span class="token punctuation">(</span><span class="token function">a</span> <span class="token number">0</span> #\a<span class="token punctuation">)</span>           <span class="token comment" spellcheck="true">; 由符号、整数和字符构成的向量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="向量函数"><a href="#向量函数" class="headerlink" title="向量函数"></a>向量函数</h4><p>下面的函数都是R5RS规定的函数：</p><p><strong>(vector? obj)</strong></p><p>如果obj是一个向量则返回#t。</p><p><strong>(make-vector k)</strong></p><p><strong>(make-vector k fill)</strong></p><p>返回有<code>k</code>个元素的向量。如果指定了第二个参数(<code>fill</code>)，那么所有的元素都会被初始化为<code>fill</code>。</p><p><strong>(vector obj …)</strong></p><p>返回由参数列表构成的向量。</p><p><strong>(vector-length vector)</strong></p><p>返回向量<code>vector</code>的长度。</p><p><strong>(vector-ref vector k)</strong></p><p>返回向量<code>vector</code>的索引为<code>k</code>的元素。（译注：和C语言类似，向量从0开始索引。）</p><p><strong>(vector-set! vector k obj)</strong></p><p>将向量<code>vector</code>的索引为<code>k</code>的元素修改为<code>obj</code>。</p><p><strong>(vector-&gt;list vector)</strong></p><p>将<code>vector</code>转换为表。</p><p><strong>(list-&gt;vector list)</strong></p><p>将<code>list</code>转换为向量。</p><p><strong>(vector-fill! vector fill)</strong></p><p>将向量<code>vector</code>的所有元素设置为<code>fill</code>。</p><p>例：一个对向量中元素求和的函数。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">vector-add</span> v1 v2<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">lenv1</span> <span class="token punctuation">(</span><span class="token function">vector-length</span> v1<span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token punctuation">(</span><span class="token function">lenv2</span> <span class="token punctuation">(</span><span class="token function">vector-length</span> v2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> lenv1 lenv2<span class="token punctuation">)</span>          <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">v</span> <span class="token punctuation">(</span><span class="token function">make-vector</span> lenv1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>              <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> i lenv1<span class="token punctuation">)</span>                    v                    <span class="token punctuation">(</span><span class="token keyword">begin</span>                      <span class="token punctuation">(</span><span class="token function">vector-set!</span> v i <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token punctuation">(</span><span class="token function">vector-ref</span> v1 i<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">vector-ref</span> v2 i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                      <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">1</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">(</span><span class="token function">error</span> <span class="token string">"different dimensions."</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>练习1</p><p>编写一个用于计算两向量内积的函数。</p></blockquote><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="大体功能"><a href="#大体功能" class="headerlink" title="大体功能"></a>大体功能</h3><p>虽然R5RS中没有定义结构体，但是在很多Scheme实现中，都实现了类似于Common Lisp中的结构体。</p><p>这些结构体本质上来说都是向量。每一个槽（slot）都通过使用一个宏来命名，我将会在下一章（十五章）中讲解这个问题。结构体通过不同的属性清楚地表示数据。定义结构体的宏自动为结构体创建<strong>取值器（accessor）</strong>和<strong>赋值器（setter）</strong>。你可以通过“程序”来写程序，这被认为是Lisp/Scheme最好之处之一。通过这个功能，你可以很快写出漂亮的程序。</p><h3 id="MIT-Scheme中的结构体"><a href="#MIT-Scheme中的结构体" class="headerlink" title="MIT-Scheme中的结构体"></a>MIT-Scheme中的结构体</h3><p>在MIT-Scheme中，结构体通过函数<code>define-structure</code>来定义。为了使你更加容易理解，我会用一个实例来讲解。请考虑书籍。书籍都有下列属性：</p><ul><li>标题</li><li>作者</li><li>出版商</li><li>出版年份</li><li>ISBN号</li></ul><p>因此结构体book就可以像下面这样定义：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span>-structure book title authors publisher year isbn<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面演示了如何注册<a href="http://www.oreilly.com/catalog/cathbazpaper/">“大教堂与市集（The Cathedral and Bazaar）”</a>。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> bazaar   <span class="token punctuation">(</span><span class="token function">make-book</span>    <span class="token string">"The Cathedral and the Bazaar"</span>   <span class="token string">"Eric S. Raymond"</span>   <span class="token string">"O'Reilly"</span>   <span class="token number">1999</span>   <span class="token number">0596001088</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然而，这样做多少有点不便，因为属性与值的关联并不清楚。参量<code>keyword-constructor</code>可以用于解决这个问题。下面的代码就是使用这个参量的重写版，这个版本中，属性与值的关联就非常清楚了。此外，制定这个参量后，参数的顺序就不重要了。参量<code>copier</code>可用于为结构体创建一个拷贝（copier）函数。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span>-structure <span class="token punctuation">(</span><span class="token function">book</span> keyword-constructor copier<span class="token punctuation">)</span>   title authors publisher year isbn<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> bazaar   <span class="token punctuation">(</span><span class="token function">make-book</span>    <span class="token string">'title</span> <span class="token string">"The Cathedral and the Bazaar"</span>   <span class="token string">'authors</span> <span class="token string">"Eric S. Raymond"</span>   <span class="token string">'publisher</span> <span class="token string">"O'Reilly"</span>   <span class="token string">'year</span> <span class="token number">1999</span>       <span class="token string">'isbn</span> <span class="token number">0596001088</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>一个名字形如<code>[the name of structure]?</code>的函数用于检查某对象是否为特定结构体。例如，可使用函数<code>book?</code>来检查<code>bazaar</code>是否为<code>book</code>结构体的一个实例。</li></ul><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">book?</span> bazaar<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>一个名字形如<code>copy-[structure name]</code>的函数用于拷贝结构体。例如，下面的代码演示了将<code>bazaar</code>拷贝到<code>cathedral</code>。</li></ul><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> cathedral <span class="token punctuation">(</span><span class="token function">copy-book</span> bazaar<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>一个名字形如<code>[structure name]-[attribute name]</code>的函数用于读取结构体某属性的值。例如，下面的代码演示了如何读取<code>bazaar</code>的<code>title</code>属性。</li></ul><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">book-title</span> bazaar<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 18: "The Cathedral and the Bazaar"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>一个名字形如<code>set-[结构体名称]-[属性名称]!</code>用于将某属性设定为特定值。下面的代码演示了如何将<code>bazaar</code>的<code>year</code>字段更新到2001（《大教堂与市集》2001年再版）。</li></ul><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">set-book-year!</span> bazaar <span class="token number">2001</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Unspecified return value</span><span class="token punctuation">(</span><span class="token function">book-year</span> bazaar<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 2001</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请参阅<a href="http://deathking.github.io/yast-cn/contents/www.gnu.org/software/mit-scheme/documentation/scheme_3.html#SEC41">MIT/GNU Scheme Reference: 2.10 Structure Definitions</a>以获得关于结构体的跟多信息。</p><h3 id="The-Mastermind-—-一个简单的密码破解游戏"><a href="#The-Mastermind-—-一个简单的密码破解游戏" class="headerlink" title="The Mastermind — 一个简单的密码破解游戏"></a>The Mastermind — 一个简单的密码破解游戏</h3><p>作为向量的示例，我会演示一个简单的密码破解游戏。这是一个猜对手密码的游戏。密码是由0到9中四个不同的数组成的四位数。对手要通过使用<code>bulls</code>和<code>cows</code>的数量告知猜谜者猜测的准确程度。</p><ol><li>bull的数量（Nbull）是指值和位置都正确的数字的数量。</li><li>cow的数量（Ncow）是指值正确但位置错误的数字的数量。</li></ol><p>例如，密码是5601，猜测是1685，那么<code>bull</code>和<code>cow</code>和数分别是1和2。</p><p>计算机和用户相互猜测对方的密码。更少尝试次数的选手为胜利者。如果用户和电脑在相同的尝试次数中破解了密码就是平局。</p><h3 id="表示四个数字"><a href="#表示四个数字" class="headerlink" title="表示四个数字"></a>表示四个数字</h3><p>四位数字可以通过向量和计算<code>bull</code>以及<code>cow</code>的数量高效地表示。这种表达方法需要构成密码的数字都不相同。</p><p>创建长度为10的向量，每个索引（<code>k</code>）的值被设为<code>k</code>在密码中的数位。四个数位从低到高被计为1，2，3和4。如果数字没有出现，索引的值为0。例如，5601和1685可以表示如下：</p><pre><code>5601 → #(2 1 0 0 0 4 3 0 0 0)1685 → #(0 4 0 0 0 1 3 0 2 0)</code></pre><p>5601这个例子中，数字0，1，5，和6分别出现在第2，第1，第4和第3位，那么在这个密码的向量表达式里索引0，1，5，6的值分别2是2，1，4和3，其他索引位都是0。</p><p>这种表达可以快速比较两个数字。如果两个向量的相同索引位的值都是正数情况下，如果值相等，就计为<code>bull</code>，如果值不相等，就计为<code>cow</code>。5601和1685这个例子的情况下，索引位6的值都为3，索引位1和索引位5的值都是正数，<code>bull</code>和<code>cow</code>的值为1和2。</p><h3 id="程序的设计"><a href="#程序的设计" class="headerlink" title="程序的设计"></a>程序的设计</h3><p>程序的设计如下：</p><ol><li>程序生成一个表，该表包含了所有不同四位数的向量表示。</li><li>程序从表中随机选取一个数字。</li><li>重洗步骤（1）产生的表。</li><li>程序首次猜用户的密码，用户给出bull和cow的数量。然后用户猜程序的密码，程序给出Nnull和Ncow。</li><li>重复步骤（3）直到电脑或者程序的bull数量变为4为止。如果在同一次双方的数量都变为4，就是平局。</li></ol><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><p>[代码1]展示了源代码。代码很长但并不十分复杂。游戏由一个递归函数<code>mastermind-rec</code>执行。</p><p>[代码1]</p><pre class="line-numbers language-scheme"><code class="language-scheme"> <span class="token number">01</span>:     <span class="token comment" spellcheck="true">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span> <span class="token number">02</span>:     <span class="token comment" spellcheck="true">;;;</span> <span class="token number">03</span>:     <span class="token comment" spellcheck="true">;;; mastermind.scm</span> <span class="token number">04</span>:     <span class="token comment" spellcheck="true">;;; by T.Shido</span> <span class="token number">05</span>:     <span class="token comment" spellcheck="true">;;;</span> <span class="token number">06</span>:     <span class="token comment" spellcheck="true">;;; User and computer try to locate the four-digit integer set by the opponents each other.</span> <span class="token number">07</span>:     <span class="token comment" spellcheck="true">;;; One who locates the integer with fewer question is the winner.</span> <span class="token number">08</span>:     <span class="token comment" spellcheck="true">;;; The four-digit integer contains four of numerals 0--9, like 0123, 3749 etc.</span> <span class="token number">09</span>:     <span class="token comment" spellcheck="true">;;; The opponents should tell the guesser</span> <span class="token number">10</span>:     <span class="token comment" spellcheck="true">;;; (1) number of numerals that are shared by the guessed and set numbers</span> <span class="token number">11</span>:     <span class="token comment" spellcheck="true">;;; at wrong position (cows)</span> <span class="token number">12</span>:     <span class="token comment" spellcheck="true">;;; and (2) number of numerals at collect position (bulls).</span> <span class="token number">13</span>:     <span class="token comment" spellcheck="true">;;; </span> <span class="token number">14</span>:     <span class="token comment" spellcheck="true">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span> <span class="token number">15</span>:     <span class="token comment" spellcheck="true">;;;</span> <span class="token number">16</span>:     <span class="token comment" spellcheck="true">;;; The four-digit integers are represented by 10-cell vectors in the program</span> <span class="token number">17</span>:     <span class="token comment" spellcheck="true">;;; The value of n-th cell is the number of column that n appears in the integer.</span> <span class="token number">18</span>:     <span class="token comment" spellcheck="true">;;; in n is not appears the value is 0.</span> <span class="token number">19</span>:     <span class="token comment" spellcheck="true">;;; for example, 1234 is represented as #(0 4 3 2 1 0 0 0 0 0) and</span> <span class="token number">20</span>:     <span class="token comment" spellcheck="true">;;; 3916 as #(0 2 0 4 0 0 1 0 0 3).</span> <span class="token number">21</span>:     <span class="token comment" spellcheck="true">;;; With this inner representation, the score of the guess can be calculated faster.</span> <span class="token number">22</span>:     <span class="token comment" spellcheck="true">;;;</span> <span class="token number">23</span>:     <span class="token comment" spellcheck="true">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span> <span class="token number">24</span>:      <span class="token number">25</span>:      <span class="token number">26</span>:     <span class="token comment" spellcheck="true">;;;</span> <span class="token number">27</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">1-</span> x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">-</span> x <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">28</span>:      <span class="token number">29</span>:     <span class="token comment" spellcheck="true">;;;</span> <span class="token number">30</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">char2int</span> c<span class="token punctuation">)</span> <span class="token number">31</span>:       <span class="token punctuation">(</span><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token function">char->integer</span> c<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">char->integer</span> #\0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">32</span>:      <span class="token number">33</span>:     <span class="token comment" spellcheck="true">;;; converting a list of 4 numbers to the vector notation</span> <span class="token number">34</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">ls2nvec</span> ls<span class="token punctuation">)</span> <span class="token number">35</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">vec</span> <span class="token punctuation">(</span><span class="token function">make-vector</span> <span class="token number">10</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">36</span>:         <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token punctuation">(</span><span class="token function">length</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">ls</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">37</span>:           <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">></span> i <span class="token number">0</span><span class="token punctuation">)</span> <span class="token number">38</span>:           <span class="token punctuation">(</span><span class="token keyword">begin</span> <span class="token number">39</span>:                <span class="token punctuation">(</span><span class="token function">vector-set!</span> vec <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span> i<span class="token punctuation">)</span> <span class="token number">40</span>:                <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token function">1-</span> i<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">41</span>:             vec<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">42</span>:      <span class="token number">43</span>:     <span class="token comment" spellcheck="true">;;; converting the vector notation to string</span> <span class="token number">44</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">nvec2int</span> vec<span class="token punctuation">)</span> <span class="token number">45</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">n</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">46</span>:         <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> i <span class="token number">10</span><span class="token punctuation">)</span> <span class="token number">47</span>:             n <span class="token number">48</span>:         <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">j</span> <span class="token punctuation">(</span><span class="token function">vector-ref</span> vec i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">49</span>:           <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token function">1+</span> i<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">+</span> n <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">></span> j <span class="token number">0</span><span class="token punctuation">)</span> <span class="token number">50</span>:                                     <span class="token punctuation">(</span><span class="token operator">*</span> i <span class="token punctuation">(</span><span class="token function">expt</span> <span class="token number">10</span> <span class="token punctuation">(</span><span class="token function">1-</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">51</span>:                                   <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">52</span>:      <span class="token number">53</span>:     <span class="token comment" spellcheck="true">;;;</span> <span class="token number">54</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">int2str</span> i<span class="token punctuation">)</span> <span class="token number">55</span>:       <span class="token punctuation">(</span><span class="token function">string-append</span> <span class="token number">56</span>:        <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> i <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token string">"0"</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token number">57</span>:        <span class="token punctuation">(</span><span class="token function">number->string</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">58</span>:      <span class="token number">59</span>:     <span class="token comment" spellcheck="true">;;; reading integer from stdin</span> <span class="token number">60</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">read-integer</span> str<span class="token punctuation">)</span> <span class="token number">61</span>:       <span class="token punctuation">(</span><span class="token function">string->number</span> <span class="token punctuation">(</span><span class="token function">read-from-stdin</span> str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">62</span>:      <span class="token number">63</span>:     <span class="token comment" spellcheck="true">;;;</span> <span class="token number">64</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">read-from-stdin</span> str<span class="token punctuation">)</span> <span class="token number">65</span>:       <span class="token punctuation">(</span><span class="token function">display</span> str<span class="token punctuation">)</span> <span class="token number">66</span>:       <span class="token punctuation">(</span>newline<span class="token punctuation">)</span> <span class="token number">67</span>:       <span class="token punctuation">(</span>read-line<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">68</span>:      <span class="token number">69</span>:     <span class="token comment" spellcheck="true">;;;</span> <span class="token number">70</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">write-to-stdout</span> . ls<span class="token punctuation">)</span> <span class="token number">71</span>:       <span class="token punctuation">(</span><span class="token function">for-each</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">display</span> obj<span class="token punctuation">)</span><span class="token punctuation">)</span> ls<span class="token punctuation">)</span> <span class="token number">72</span>:       <span class="token punctuation">(</span>newline<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">73</span>:      <span class="token number">74</span>:     <span class="token comment" spellcheck="true">;;; convert numeral string to the vector representation.</span> <span class="token number">75</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">str2nvec</span> str<span class="token punctuation">)</span> <span class="token number">76</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">vec</span> <span class="token punctuation">(</span><span class="token function">make-vector</span> <span class="token number">10</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">77</span>:         <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token punctuation">(</span><span class="token function">string-length</span> str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">ls</span> <span class="token punctuation">(</span><span class="token function">string->list</span> str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">78</span>:           <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">pair?</span> ls<span class="token punctuation">)</span> <span class="token number">79</span>:           <span class="token punctuation">(</span><span class="token keyword">begin</span> <span class="token number">80</span>:                <span class="token punctuation">(</span><span class="token function">vector-set!</span> vec <span class="token punctuation">(</span><span class="token function">char2int</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span> i<span class="token punctuation">)</span> <span class="token number">81</span>:                <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token function">1-</span> i<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">82</span>:             vec<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">83</span>:      <span class="token number">84</span>:     <span class="token comment" spellcheck="true">;;; calculating the score of guess</span> <span class="token number">85</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">scoring</span> vec0 vec1<span class="token punctuation">)</span> <span class="token number">86</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">n</span> <span class="token punctuation">(</span><span class="token function">vector-length</span> vec0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">87</span>:         <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">score</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">88</span>:           <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> i n<span class="token punctuation">)</span> <span class="token number">89</span>:           <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">d0</span> <span class="token punctuation">(</span><span class="token function">vector-ref</span> vec0 i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">90</span>:                    <span class="token punctuation">(</span><span class="token function">d1</span> <span class="token punctuation">(</span><span class="token function">vector-ref</span> vec1 i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">91</span>:                 <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token function">1+</span> i<span class="token punctuation">)</span> <span class="token number">92</span>:               <span class="token punctuation">(</span><span class="token operator">+</span> score <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">and</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> <span class="token number">0</span> d0<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> <span class="token number">0</span> d1<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">93</span>:                                    <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> d0 d1<span class="token punctuation">)</span> <span class="token number">5</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">94</span>:                                    <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">95</span>:             score<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">96</span>:      <span class="token number">97</span>:     <span class="token comment" spellcheck="true">;;; show bulls and cows calculated from the score of user's guess</span> <span class="token number">98</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">show-user-score</span> score<span class="token punctuation">)</span> <span class="token number">99</span>:       <span class="token punctuation">(</span><span class="token function">write-to-stdout</span> <span class="token string">"Number of bulls and cows in your guess:"</span> <span class="token punctuation">)</span><span class="token number">100</span>:       <span class="token punctuation">(</span><span class="token function">write-to-stdout</span> <span class="token string">"bulls: "</span> <span class="token punctuation">(</span><span class="token function">quotient</span> score <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">101</span>:       <span class="token punctuation">(</span><span class="token function">write-to-stdout</span> <span class="token string">"cows: "</span> <span class="token punctuation">(</span><span class="token function">modulo</span> score <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">102</span>:       <span class="token punctuation">(</span>newline<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">103</span>:     <span class="token number">104</span>:     <span class="token comment" spellcheck="true">;;; calculating the score of computer's guess from bulls and cows</span><span class="token number">105</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">read-my-score</span> gu0<span class="token punctuation">)</span><span class="token number">106</span>:       <span class="token punctuation">(</span><span class="token function">write-to-stdout</span> <span class="token string">"My guess is: "</span> <span class="token punctuation">(</span><span class="token function">int2str</span> <span class="token punctuation">(</span><span class="token function">nvec2int</span> gu0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">107</span>:       <span class="token punctuation">(</span><span class="token function">write-to-stdout</span> <span class="token string">"Give number of bulls and cows in my guess."</span> <span class="token punctuation">)</span><span class="token number">108</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">na5</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">5</span> <span class="token punctuation">(</span><span class="token function">read-integer</span> <span class="token string">"bulls: "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">109</span>:         <span class="token punctuation">(</span><span class="token operator">+</span> na5 <span class="token punctuation">(</span><span class="token function">read-integer</span> <span class="token string">"cows: "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">; the score is calculated by (5 * bull + cow)</span><span class="token number">110</span>:     <span class="token number">111</span>:     <span class="token comment" spellcheck="true">;;; reading the user guess</span><span class="token number">112</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>read-user-guess<span class="token punctuation">)</span><span class="token number">113</span>:       <span class="token punctuation">(</span>newline<span class="token punctuation">)</span><span class="token number">114</span>:       <span class="token punctuation">(</span><span class="token function">str2nvec</span> <span class="token punctuation">(</span><span class="token function">read-from-stdin</span> <span class="token string">"Give your guess."</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">115</span>:     <span class="token number">116</span>:     <span class="token comment" spellcheck="true">;;; shuffling the list of four-digit numbers</span><span class="token number">117</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">shuffle-numbers</span> ls0<span class="token punctuation">)</span><span class="token number">118</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">vec</span> <span class="token punctuation">(</span><span class="token builtin">list</span>->vector ls0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">119</span>:         <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">n</span> <span class="token punctuation">(</span><span class="token function">vector-length</span> vec<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">ls1</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">120</span>:           <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> n <span class="token number">0</span><span class="token punctuation">)</span><span class="token number">121</span>:               ls1<span class="token number">122</span>:           <span class="token punctuation">(</span><span class="token keyword">let*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">r</span> <span class="token punctuation">(</span><span class="token function">random</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">123</span>:              <span class="token punctuation">(</span><span class="token function">v</span> <span class="token punctuation">(</span><span class="token function">vector-ref</span> vec r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">124</span>:             <span class="token punctuation">(</span><span class="token function">vector-set!</span> vec r <span class="token punctuation">(</span><span class="token function">vector-ref</span> vec <span class="token punctuation">(</span><span class="token function">1-</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">125</span>:             <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token function">1-</span> n<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> v ls1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">126</span>:     <span class="token number">127</span>:     <span class="token comment" spellcheck="true">;;; making a list of four-digit numbers in which numeral 0--9 appear once</span><span class="token number">128</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>make-numbers<span class="token punctuation">)</span><span class="token number">129</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">ls1</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">130</span>:         <span class="token punctuation">(</span><span class="token keyword">letrec</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">rec</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token function">i</span> num ls<span class="token punctuation">)</span><span class="token number">131</span>:                 <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> i <span class="token number">4</span><span class="token punctuation">)</span><span class="token number">132</span>:                 <span class="token punctuation">(</span><span class="token keyword">set!</span> ls1 <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token punctuation">(</span><span class="token function">ls2nvec</span> ls<span class="token punctuation">)</span> ls1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">133</span>:                 <span class="token punctuation">(</span><span class="token function">for-each</span> <span class="token number">134</span>:                  <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token number">135</span>:                    <span class="token punctuation">(</span><span class="token function">rec</span> <span class="token punctuation">(</span><span class="token function">1+</span> i<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">delv</span> n num<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> n ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">136</span>:                  num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">137</span>:           <span class="token punctuation">(</span><span class="token function">rec</span> <span class="token number">0</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">138</span>:         ls1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">139</span>:     <span class="token number">140</span>:     <span class="token comment" spellcheck="true">;;;</span><span class="token number">141</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">game-over</span> sc0 sc1<span class="token punctuation">)</span><span class="token number">142</span>:       <span class="token punctuation">(</span><span class="token function">write-to-stdout</span><span class="token number">143</span>:        <span class="token punctuation">(</span><span class="token keyword">cond</span><span class="token number">144</span>:         <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">=</span> sc0 sc1<span class="token punctuation">)</span> <span class="token string">"Draw"</span><span class="token punctuation">)</span><span class="token number">145</span>:         <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">></span> sc0 sc1<span class="token punctuation">)</span> <span class="token string">"I won."</span><span class="token punctuation">)</span><span class="token number">146</span>:         <span class="token punctuation">(</span><span class="token keyword">else</span> <span class="token string">"You won."</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">147</span>:       <span class="token string">'game-over)</span><span class="token number">148</span>:     <span class="token number">149</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">scoring-user-guess</span> an0 gu1<span class="token punctuation">)</span><span class="token number">150</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">sc1</span> <span class="token punctuation">(</span><span class="token function">scoring</span> an0 gu1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">151</span>:         <span class="token punctuation">(</span><span class="token function">show-user-score</span> sc1<span class="token punctuation">)</span><span class="token number">152</span>:         sc1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">153</span>:     <span class="token number">154</span>:     <span class="token comment" spellcheck="true">;;; Practical main function. tail recursive.</span><span class="token number">155</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">mastermind-rec</span> an0 candidates<span class="token punctuation">)</span><span class="token number">156</span>:       <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">null?</span> candidates<span class="token punctuation">)</span><span class="token number">157</span>:           <span class="token punctuation">(</span><span class="token function">error</span> <span class="token string">"Error. You gave wrong score for my guess, probably."</span><span class="token punctuation">)</span><span class="token number">158</span>:           <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">gu0</span> <span class="token punctuation">(</span><span class="token builtin">car</span> candidates<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">159</span>:         <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">sc1</span> <span class="token punctuation">(</span><span class="token function">scoring-user-guess</span> an0 <span class="token punctuation">(</span>read-user-guess<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">160</span>:               <span class="token punctuation">(</span><span class="token function">sc0</span> <span class="token punctuation">(</span><span class="token function">read-my-score</span> gu0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">161</span>:           <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">or</span> <span class="token punctuation">(</span><span class="token operator">=</span> sc0 <span class="token number">20</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">=</span> sc1 <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">162</span>:               <span class="token punctuation">(</span><span class="token function">game-over</span> sc0 sc1<span class="token punctuation">)</span><span class="token number">163</span>:               <span class="token punctuation">(</span><span class="token function">mastermind-rec</span> an0 <span class="token number">164</span>:                    <span class="token punctuation">(</span><span class="token function">keep-matching-items</span> <span class="token number">165</span>:                     <span class="token punctuation">(</span><span class="token builtin">cdr</span> candidates<span class="token punctuation">)</span><span class="token number">166</span>:                     <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">scoring</span> gu0 x<span class="token punctuation">)</span> sc0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">167</span>:     <span class="token number">168</span>:     <span class="token comment" spellcheck="true">;;; The main function called from the top-level</span><span class="token number">169</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>mastermind<span class="token punctuation">)</span><span class="token number">170</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">ls0</span> <span class="token punctuation">(</span>make-numbers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">171</span>:         <span class="token punctuation">(</span><span class="token function">mastermind-rec</span> <span class="token punctuation">(</span><span class="token builtin">list</span>-ref ls0 <span class="token punctuation">(</span><span class="token function">random</span> <span class="token punctuation">(</span><span class="token function">length</span> ls0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">shuffle-numbers</span> ls0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="left">行数</th><th align="left">函数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">27</td><td align="left"><code>(1- x)</code></td><td align="left"><code>x</code>减一</td></tr><tr><td align="left">30</td><td align="left"><code>(char2int c)</code></td><td align="left">将字符<code>c</code>(#\0 – #\9)转换为整数（0 – 9）。</td></tr><tr><td align="left">34</td><td align="left"><code>(ls2nvec ls)</code></td><td align="left">将四个数字的表（<code>ls</code>）转换为向量表达式。<code>&#39;(5 3 6 0)-&gt;#(1 0 0 3 0 4 2 0 0 0)</code></td></tr><tr><td align="left">44</td><td align="left"><code>(nvec2int vec)</code></td><td align="left">将向量表达式<code>vec</code>转换为普通整数。</td></tr><tr><td align="left">54</td><td align="left"><code>(int2str i)</code></td><td align="left">将一个四位数<code>i</code>转换为字符串。如果<code>i</code>小于1000，’0’被置于高位。</td></tr><tr><td align="left">64</td><td align="left"><code>(read-from-stdin str)</code></td><td align="left">将<code>str</code>显示于标准输出，并返回用户从标准输入输入的字符串。</td></tr><tr><td align="left">70</td><td align="left"><code>(write-to-stdout . ls)</code></td><td align="left">将<code>ls</code>的每个元素都输出到标准输出，并在行尾插入行结束符。</td></tr><tr><td align="left">75</td><td align="left"><code>(str2nvec str)</code></td><td align="left">将用户输入的表示四位数的字符串<code>str</code>转换为向量表达式。</td></tr><tr><td align="left">86</td><td align="left"><code>(scoring vec0 vec1)</code></td><td align="left">以（5*Nnull + Ncow）计算两个整数（向量表达式）<code>vec0</code>和<code>vec1</code>的相似程度。</td></tr><tr><td align="left">98</td><td align="left"><code>(show-user-score score)</code></td><td align="left">通过相似度<code>score</code>计算Nbull和Ncow，并将它们显示在标准输出。</td></tr><tr><td align="left">105</td><td align="left"><code>(read-my-score gu0)</code></td><td align="left">显示计算机的猜测（gu0），让用户输入Nnull和Ncow，返回相似度score。</td></tr><tr><td align="left">112</td><td align="left"><code>(read-user-guess)</code></td><td align="left">返回用户猜测的向量表达式。</td></tr><tr><td align="left">116</td><td align="left"><code>(shuffle-numbers ls0)</code></td><td align="left">随机排序<code>ls0</code>。由于有随机读取的需求，将<code>ls0</code>转换为向量，然后随机读取向量的元素，以创建一个重排过的表。</td></tr><tr><td align="left">128</td><td align="left"><code>(make-numbers)</code></td><td align="left">返回由所有不同四位数构成的表。</td></tr><tr><td align="left">141</td><td align="left"><code>(game-over sc0 sc1)</code></td><td align="left">通过比较计算机的得分（sc0）和用户的得分(sc1)确定胜利者。</td></tr><tr><td align="left">149</td><td align="left"><code>(scoring-user-guess an0 gu1)</code></td><td align="left">计算计算机的密码（an0）和用户的猜测（gu1）的相似度，使用show-uuser-score输出Nbull和Ncow。</td></tr><tr><td align="left">155</td><td align="left"><code>(mastermind-rec an0 candidates)</code></td><td align="left">实际的主程序，它有两个参数；计算机密码（an0）和 猜测的表（candidate）。它计算计算机的得分（sc0）和用户的得分（sc1），如果<code>sc0</code>或者<code>sc1</code>为20，调用 (game-over sc0 sc1)。如果没有值为20，它根据<code>sc0</code>过滤猜测的表（candidate），并继续游戏。</td></tr><tr><td align="left">169</td><td align="left"><code>(mastermind)</code></td><td align="left">在控制台调用该函数以开始游戏。</td></tr></tbody></table><h3 id="如何玩"><a href="#如何玩" class="headerlink" title="如何玩"></a>如何玩</h3><p>输入如下代码启动游戏。最好在玩之前编译（你需要编译一次）。即使程序很简单，也很难取胜。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">compile-file</span> <span class="token string">"mastermind.scm"</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">load</span> <span class="token string">"mastermind"</span><span class="token punctuation">)</span><span class="token punctuation">(</span>mastermind<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这一章，我通过玩<code>mastermind</code>游戏讲解了向量和结构体。附上<a href="http://www.shido.info/lisp/scheme_vec.zip"><code>mastermind</code>的源代码</a>。</p><p>我将在下一章讲自定义语法。自定义语法是Lisp/Scheme的一个优点。</p><h2 id="定义语法"><a href="#定义语法" class="headerlink" title="定义语法"></a>定义语法</h2><h3 id="简介-9"><a href="#简介-9" class="headerlink" title="简介"></a>简介</h3><p>本章中，我会讲解如何自定义语法。用户定义语法称作<strong>宏（Macro）</strong>。Lisp/Scheme中的宏比C语言中的宏更加强大。宏可以使你的程序优美而紧凑。</p><p><strong>宏是代码的变换</strong>。代码在被求值或编译前进行变换，程序会继续执行就像变换后的代码一开始就写好了一样。</p><p>你可以在Scheme中通过用符合R5RS规范的<code>syntax-rules</code>轻易地定义简单宏，相比之下，在Common Lisp中自定义语法就复杂多了。使用<code>syntax-rules</code>可以直接定义宏而不用担心<strong>变量捕获（Variable Capture）</strong>。另一方面，Scheme中定义那些无法用<code>syntax-rules</code>定义的复杂的宏就比Common Lisp要困难。</p><h3 id="简单宏的实例"><a href="#简单宏的实例" class="headerlink" title="简单宏的实例"></a>简单宏的实例</h3><p>我将以一个简单的宏作为例子。</p><p>[代码1]一个将变量赋值为<code>&#39;()</code>的宏。</p><p>[代码1]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> nil!  <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> x<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">set!</span> x <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>syntax-reuls</code>的第二个参数是变换前和变化后的表达式的序对所构成的表。<code>_</code>代表宏的名字。简言之，[代码1]表示表达式<code>(nil! x)</code>会变换为<code>(set! x &#39;())</code>.</p><p>这类程序不能通过函数来实现，这是因为由于闭包性，函数不能影响外部变量。让我们来用函数版本来实现[代码1]，并观察效果。</p><p>[代码’1]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">f-nil!</span> x<span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token keyword">set!</span> x <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> a <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: a</span><span class="token punctuation">(</span><span class="token function">f-nil!</span> a<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 1</span>a<span class="token comment" spellcheck="true">;Value: 1           ; the value of a dose not change</span><span class="token punctuation">(</span><span class="token function">nil!</span> a<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 1</span>a<span class="token comment" spellcheck="true">;Value: ()          ; a becomes '()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我会演示另外一个例子。我们编写宏<code>when</code>，其语义为：当谓词求值为真时，求值相应语句。</p><p>[代码2]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> when  <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> pred b1 ...<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">if</span> pred <span class="token punctuation">(</span><span class="token keyword">begin</span> b1 ...<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>[代码2]中的<code>...</code>代表了任意多个数的表达式（包括0个表达式）。[代码2]揭示了表达式<code>(when pred b1 ...)</code>变换为<code>(if pred (begin b1 ...))</code>。</p><p>由于这个宏是将表达式变换为<code>if</code>特殊形式，因此它不能使用函数来实现。下面的例子演示了如何使用<code>when</code>。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">when</span> <span class="token punctuation">(</span><span class="token operator">=</span> i <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token function">display</span> <span class="token string">"i == 0"</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span>newline<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>i == <span class="token number">0</span><span class="token comment" spellcheck="true">;Unspecified return value</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我会演示两个实际的宏：<code>while</code>和<code>for</code>（已在Scheme中实现）。只要谓词部分求值为真，<code>while</code>就会对语句体求值。而数字在指定的范围中，<code>for</code>就会对语句体求值。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> while  <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> pred b1 ...<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">when</span> pred b1 ... <span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> for  <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> <span class="token punctuation">(</span><span class="token function">i</span> from to<span class="token punctuation">)</span> b1 ...<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">let</span> loop<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> from<span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token function">when</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> i to<span class="token punctuation">)</span>      b1 ...      <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token function">1+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面演示了如何使用它们：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">while</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> i <span class="token number">10</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token function">display</span> i<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token function">display</span> #\Space<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">set!</span> i <span class="token punctuation">(</span><span class="token operator">+</span> i <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span> <span class="token comment" spellcheck="true">;Unspecified return value</span><span class="token punctuation">(</span><span class="token function">for</span> <span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">0</span> <span class="token number">10</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">display</span> i<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">display</span> #\Space<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span> <span class="token comment" spellcheck="true">;Unspecified return value</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="syntax-rule的更多细节"><a href="#syntax-rule的更多细节" class="headerlink" title="syntax-rule的更多细节"></a>syntax-rule的更多细节</h3><h4 id="多个定义模式"><a href="#多个定义模式" class="headerlink" title="多个定义模式"></a>多个定义模式</h4><p><code>syntax-rule</code>可以定义一系列模式。比如，一个让变量增加的宏，如果给定了变量名，那么宏<code>incf</code>使该变量增加1。可以通过编写如[代码4]这样的模式转换来实现宏<code>incf</code>。</p><p>[代码4]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> incf  <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">begin</span> <span class="token punctuation">(</span><span class="token keyword">set!</span> x <span class="token punctuation">(</span><span class="token operator">+</span> x <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> x i<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">begin</span> <span class="token punctuation">(</span><span class="token keyword">set!</span> x <span class="token punctuation">(</span><span class="token operator">+</span> x i<span class="token punctuation">)</span><span class="token punctuation">)</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">j</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">incf</span> i<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">incf</span> j <span class="token number">3</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">display</span> <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token string">'i</span> <span class="token string">'=</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span>newline<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">display</span> <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token string">'j</span> <span class="token string">'=</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">i</span> = <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">j</span> = <span class="token number">3</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Unspecified return value</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="宏的递归定义"><a href="#宏的递归定义" class="headerlink" title="宏的递归定义"></a>宏的递归定义</h4><p>代码形式<code>or</code>和<code>and</code>是通过像下面这样递归定义的宏：</p><p>[代码5]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> my-and  <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token boolean">#t</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> e<span class="token punctuation">)</span> e<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> e1 e2 ...<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">if</span> e1     <span class="token punctuation">(</span><span class="token function">my-and</span> e2 ...<span class="token punctuation">)</span>     <span class="token boolean">#f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> my-or  <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token boolean">#f</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> e<span class="token punctuation">)</span> e<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> e1 e2 ...<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">t</span> e1<span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token keyword">if</span> t t <span class="token punctuation">(</span><span class="token function">my-or</span> e2 ...<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以使用递归定义来编写复杂的宏。</p><h4 id="使用保留字"><a href="#使用保留字" class="headerlink" title="使用保留字"></a>使用保留字</h4><p><code>syntax-rule</code>的第一个参数是保留字的表。比如，<code>cond</code>的定义如[代码6]所示，其中，<code>else</code>是保留字。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> my-cond  <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token keyword">else</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> <span class="token punctuation">(</span><span class="token keyword">else</span> e1 ...<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">begin</span> e1 ...<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> <span class="token punctuation">(</span><span class="token function">e1</span> e2 ...<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token function">when</span> e1 e2 ...<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> <span class="token punctuation">(</span><span class="token function">e1</span> e2 ...<span class="token punctuation">)</span> c1 ...<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">if</span> e1      <span class="token punctuation">(</span><span class="token keyword">begin</span> e2 ...<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">cond</span> c1 ...<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="局部语法"><a href="#局部语法" class="headerlink" title="局部语法"></a>局部语法</h3><p>在Scheme中，可以使用<code>let-syntax</code>和<code>letrec-syntax</code>来定义<strong>局部语法（Local Syntax）</strong>。这种形式的用法和<code>define-syntax</code>是相似的。</p><h3 id="取决于宏定义的实现"><a href="#取决于宏定义的实现" class="headerlink" title="取决于宏定义的实现"></a>取决于宏定义的实现</h3><p>有些宏无法使用<code>syntax-rules</code>来定义。定义这些宏的实现方法已经在Scheme实现中准备好了。由于这种行为严重依赖于实现，因此你可以跳过此节。</p><p>在MIT-Scheme中，<code>sc-macro-transformer</code>就可用于这种情况，它允许用户用与Common Lisp中相似的方式来编写宏。关于<code>,</code>、<code>,@</code>的介绍，请参见<a href="http://deathking.github.io/yast-cn/contents/www.lispworks.com/documentation/HyperSpec/Body/02_df.htm">The Common Lisp HyperSpec</a>。关于<code>sc-macro-transformer</code>和<code>make-syntactic-closuer</code>请参见MIT-Scheme手册。[代码7]演示了一个简单的例子。</p><p>[代码 7]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> show-vars  <span class="token punctuation">(</span><span class="token function">sc-macro-transformer</span>    <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token function">exp</span> env<span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">vars</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> exp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>           `<span class="token punctuation">(</span><span class="token keyword">begin</span>              <span class="token punctuation">(</span><span class="token function">display</span>                <span class="token punctuation">(</span><span class="token builtin">list</span>                  ,@<span class="token punctuation">(</span><span class="token function">map</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>v<span class="token punctuation">)</span>                            <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">w</span> <span class="token punctuation">(</span><span class="token function">make-syntactic-closure</span> env <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span> v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                 `<span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token string">',w</span> ,w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                          vars<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span>newline<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> random-choice  <span class="token punctuation">(</span><span class="token function">sc-macro-transformer</span>   <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token function">exp</span> env<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       `<span class="token punctuation">(</span><span class="token function">case</span> <span class="token punctuation">(</span><span class="token function">random</span> ,<span class="token punctuation">(</span><span class="token function">length</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> exp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      ,@<span class="token punctuation">(</span><span class="token function">map</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span>           `<span class="token punctuation">(</span><span class="token punctuation">(</span>,<span class="token punctuation">(</span><span class="token function">incf</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> ,<span class="token punctuation">(</span><span class="token function">make-syntactic-closure</span> env <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token punctuation">(</span><span class="token builtin">cdr</span> exp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> aif  <span class="token punctuation">(</span><span class="token function">sc-macro-transformer</span>   <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token function">exp</span> env<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">test</span> <span class="token punctuation">(</span><span class="token function">make-syntactic-closure</span> env <span class="token string">'</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">second</span> exp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token function">cthen</span> <span class="token punctuation">(</span><span class="token function">make-syntactic-closure</span> env <span class="token string">'</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">third</span> exp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token function">celse</span> <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">pair?</span> <span class="token punctuation">(</span><span class="token function">cdddr</span> exp<span class="token punctuation">)</span><span class="token punctuation">)</span>              <span class="token punctuation">(</span><span class="token function">make-syntactic-closure</span> env <span class="token string">'</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">fourth</span> exp<span class="token punctuation">)</span><span class="token punctuation">)</span>              <span class="token boolean">#f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       `<span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">it</span> ,test<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token keyword">if</span> it ,cthen ,celse<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一个宏<code>show-vars</code>用于显示变量的值。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">j</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">show-vars</span> i j k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">j</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Unspecified return value</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>代码形式<code>(show-vars i j k)</code>被展开成下面这样。因为宏只能返回一个表达式，所以需要用<code>begin</code>返回表达式的集合。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">begin</span>  <span class="token punctuation">(</span><span class="token function">display</span>   <span class="token punctuation">(</span><span class="token builtin">list</span>    <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token string">'i</span> i<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token string">'j</span> j<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token string">'k</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span>newline<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二个宏<code>random-choice</code>被用于从参数中随机选择一个值或者过程。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>turn-right<span class="token punctuation">)</span> <span class="token string">'right)</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>turn-left<span class="token punctuation">)</span> <span class="token string">'left)</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>go-ahead<span class="token punctuation">)</span> <span class="token string">'straight)</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>stop<span class="token punctuation">)</span> <span class="token string">'stop)</span><span class="token punctuation">(</span><span class="token function">random-choice</span> <span class="token punctuation">(</span>turn-right<span class="token punctuation">)</span> <span class="token punctuation">(</span>turn-left<span class="token punctuation">)</span> <span class="token punctuation">(</span>go-ahead<span class="token punctuation">)</span> <span class="token punctuation">(</span>stop<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: right</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码形式被展开如下：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">case</span> <span class="token punctuation">(</span><span class="token function">random</span> <span class="token number">4</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token punctuation">(</span>0<span class="token punctuation">)</span> <span class="token punctuation">(</span>turn-right<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span> <span class="token punctuation">(</span>turn-left<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token punctuation">(</span>2<span class="token punctuation">)</span> <span class="token punctuation">(</span>go-ahead<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token punctuation">(</span>3<span class="token punctuation">)</span> <span class="token punctuation">(</span>stop<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第三个宏<code>aif</code>是一个回指宏（ anaphoric macro）。谓词的结果可以被指为<code>it</code>。变量<code>it</code>被捕获，以使得第二个参数<code>make-syntactic-closure</code>变为<code>&#39;(it)</code>。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">aif</span> <span class="token punctuation">(</span><span class="token function">memv</span> i <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">2</span> <span class="token number">4</span> <span class="token number">6</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token builtin">car</span> it<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>下面显示了扩展结果。</p><p>````scheme<br>(let ((it (memv i ‘(2 4 6 8))))<br>  (if it<br>      (car it)<br>      #f))</p><pre><code>### 结构体的原始实现结构体（structure）可以通过[代码8]中的简单宏实现。这里定义的结构体的本质是一个向量（vector）和由宏自动创建的取值以及赋值函数。如果你喜欢的Scheme版本没有结构体的实现，你可以自己实现它们。[代码8]```scheme01:     ;;; simple structure definition02:     03:     ;;; lists of symbols -&gt; string04:     (define (append-symbol . ls)05:       (let loop ((ls (cdr ls)) (str (symbol-&gt;string (car ls))))06:         (if (null? ls)07:         str08:         (loop (cdr ls) (string-append str &quot;-&quot; (symbol-&gt;string (car ls)))))))09:     10:     ;;; obj -&gt; ls -&gt; integer11:     ;;; returns position of obj in ls12:     (define (position obj ls)13:       (letrec ((iter (lambda (i ls)14:                (cond15:                 ((null? ls) #f)16:                 ((eq? obj (car ls)) i)17:                 (else (iter (1+ i) (cdr ls)))))))18:         (iter 0 ls)))19:                          20:     21:     ;;; list -&gt; integer -&gt; list22:     ;;; enumerate list items23:     (define (slot-enumerate ls i)24:       (if (null? ls)25:           &#39;()26:         (cons `((,(car ls)) ,i) (slot-enumerate (cdr ls) (1+ i)))))27:     28:     ;;; define simple structure 29:     (define-syntax defstruct30:       (sc-macro-transformer31:        (lambda (exp env)32:          (let ((struct (second exp))33:                (slots  (map (lambda (x) (if (pair? x) (car x) x)) (cddr exp)))34:            (veclen (- (length exp) 1)))35:            36:            `(begin   37:           (define ,(string-&gt;symbol (append-symbol &#39;make struct))   ; making instance38:             (lambda ls39:                   (let ((vec (vector &#39;,struct ,@(map (lambda (x) (if (pair? x) (second x) #f)) (cddr exp)))))40:             (let loop ((ls ls))41:               (if (null? ls)42:                   vec43:                   (begin44:                            (vector-set! vec (case (first ls) ,@(slot-enumerate slots 1)) (second ls))45:                 (loop (cddr ls))))))))46:     47:           (define ,(string-&gt;symbol (string-append (symbol-&gt;string struct) &quot;?&quot;))  ; predicate48:             (lambda (obj)49:               (and50:                (vector? obj)51:                (eq? (vector-ref obj 0) &#39;,struct))))52:     53:           ,@(map54:              (lambda (slot)55:                (let ((p (1+ (position slot slots))))56:              `(begin57:                 (define ,(string-&gt;symbol (append-symbol struct slot))    ; accessors58:                   (lambda (vec)59:                 (vector-ref vec ,p)))60:     61:                 (define-syntax ,(string-&gt;symbol                           ; modifier62:                          (string-append63:                           (append-symbol &#39;set struct slot) &quot;!&quot;))64:                   (syntax-rules ()65:                 ((_ s v) (vector-set! s ,p v)))))))66:              slots)67:     68:           (define ,(string-&gt;symbol (append-symbol &#39;copy struct))      ; copier69:             (lambda (vec)70:               (let ((vec1 (make-vector ,veclen)))71:             (let loop ((i 0))72:               (if (= i ,veclen)73:                   vec174:                   (begin75:                 (vector-set! vec1 i (vector-ref vec i))76:                 (loop (1+ i)))))))))))))</code></pre><p>下面演示了如何使用：</p><p>你可以定义一个结构体，要么只给出槽（slot）的名字，要么给出槽（slot）的名字和缺省值。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token comment" spellcheck="true">;;; Defining a structure point having 3 slots whose defaults are 0.0.</span><span class="token punctuation">(</span><span class="token function">defstruct</span> point <span class="token punctuation">(</span><span class="token function">x</span> <span class="token number">0.0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">y</span> <span class="token number">0.0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">z</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Unspecified return value</span><span class="token punctuation">(</span><span class="token keyword">define</span> p1 <span class="token punctuation">(</span><span class="token function">make-point</span> <span class="token string">'x</span> <span class="token number">10</span> <span class="token string">'y</span> <span class="token number">20</span> <span class="token string">'z</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: p1</span><span class="token punctuation">(</span><span class="token function">point?</span> p1<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token function">point-x</span> p1<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 10</span><span class="token comment" spellcheck="true">;;; Default values are used for unspecified values when an instance is made.</span><span class="token punctuation">(</span><span class="token keyword">define</span> p2 <span class="token punctuation">(</span><span class="token function">make-point</span> <span class="token string">'z</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: p2</span><span class="token punctuation">(</span><span class="token function">point-x</span> p2<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 0.</span><span class="token punctuation">(</span><span class="token function">point-z</span> p2<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 20</span><span class="token comment" spellcheck="true">;;; Changing a slot value</span><span class="token punctuation">(</span><span class="token function">set-point-y!</span> p2 <span class="token number">12</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Unspecified return value</span><span class="token comment" spellcheck="true">;;; The reality of the structure definde by [code 8] is a vector</span>p2<span class="token comment" spellcheck="true">;Value 14: #(point 0. 12 20)</span><span class="token comment" spellcheck="true">;;; Defining a structure 'book' with no default values.</span><span class="token punctuation">(</span><span class="token function">defstruct</span> book title authors publisher year isbn<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Unspecified return value</span><span class="token punctuation">(</span><span class="token keyword">define</span> mon-month   <span class="token punctuation">(</span><span class="token function">make-book</span> <span class="token string">'title</span>           <span class="token string">"The Mythical Man-Month: Essays on Software Engineering"</span>         <span class="token string">'authors</span>         <span class="token string">"F.Brooks"</span>         <span class="token string">'publisher</span>         <span class="token string">"Addison-Wesley"</span>         <span class="token string">'year</span>         <span class="token number">1995</span>         <span class="token string">'isbn</span>         <span class="token number">0201835959</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: mon-month</span>mon-month<span class="token comment" spellcheck="true">;Value 15: #(book </span><span class="token string">"The Mythical Man-Month: Essays on Software Engineering"</span> <span class="token string">"F.Brooks"</span> <span class="token string">"Addison-Wesley"</span> <span class="token number">1995</span> <span class="token number">201835959</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">book-title</span> mon-month<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 13: "The Mythical Man-Month: Essays on Software Engineering"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>我简要介绍了Scheme里的宏。宏可以使你的代码更优雅。</p><p><code>syntax-rules</code>使得编写宏很容易。另一方面，编写Common Lisp的宏，则要求特点的技巧。</p><h2 id="继续"><a href="#继续" class="headerlink" title="继续"></a>继续</h2><h3 id="简介-10"><a href="#简介-10" class="headerlink" title="简介"></a>简介</h3><p>本章介绍的是Scheme中特有的数据类型——<strong>继续（Continuation）</strong>。由于其他程序设计语言并没有这种数据类型，因此它难于理解。当下，你并不需要彻底理解清楚，只需要大致了解。</p><p>我会讲解广义的继续和简短地介绍<strong>Continuation-Passing-Style(CPS)</strong>，然后再讲解Scheme中的继续。我认为通过这种方式理解继续会比较容易。</p><h3 id="广义继续"><a href="#广义继续" class="headerlink" title="广义继续"></a>广义继续</h3><p>继续是在返回到<strong>顶层（Top level）</strong>之前所需要执行的计算。实际上，继续存在于计算的每时每刻。以<code>(* 3 (+ 1 2))</code>为例，在求值完<code>(+ 1 2)</code>后，应该计算<code>{ (* 3 []) }</code>乘以3。然而，大多数语言都不显式地这么做，程序员对此并不熟悉。</p><h3 id="Continuation-Passing-Style-CPS"><a href="#Continuation-Passing-Style-CPS" class="headerlink" title="Continuation-Passing-Style(CPS)"></a>Continuation-Passing-Style(CPS)</h3><h4 id="简单的CPS"><a href="#简单的CPS" class="headerlink" title="简单的CPS"></a>简单的CPS</h4><p>CPS是一种编程风格，在这种风格中，把依赖于当前函数结果的后续函数作为参数传递给当前函数。[代码1]展示了以CPS编写的加法和乘法。在<code>k+</code>和<code>k*</code>中，<code>k</code>是后续函数。</p><p>[代码1]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">return</span> x<span class="token punctuation">)</span>  x<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">k+</span> a b k<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">k</span> <span class="token punctuation">(</span><span class="token operator">+</span> a b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">k*</span> a b k<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">k</span> <span class="token punctuation">(</span><span class="token operator">*</span> a b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[例1]演示了如何使用CPS计算<code>(* 3 (+ 1 2))</code>。</p><p>[例1]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">k+</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k*</span> x <span class="token number">3</span> return<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Scheme的普通形式中，值在括号内被计算并向括号外传递。与此相反，CPS中，值向括号内传递。如[例1]中，<code>k+</code>把<code>(+ 1 2)</code>的值传递给<code>(lambda (x) (k* x 3 return))</code>，而<code>k*</code>把<code>(* (+ 1 2) 3)</code>的结果传给<code>return</code>。</p><h4 id="以CPS编写递归函数"><a href="#以CPS编写递归函数" class="headerlink" title="以CPS编写递归函数"></a>以CPS编写递归函数</h4><p>递归函数同样可以以CPS编写。[代码2]展示了计算阶乘的函数如何用普通方式编写（<code>fact</code>）和以CPS编写(<code>kfact</code>)。</p><p>[代码2]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token comment" spellcheck="true">;;; normal factorial</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">fact</span> n<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> n <span class="token number">1</span><span class="token punctuation">)</span>       <span class="token number">1</span>      <span class="token punctuation">(</span><span class="token operator">*</span> n <span class="token punctuation">(</span><span class="token function">fact</span> <span class="token punctuation">(</span><span class="token operator">-</span> n <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;;; CPS factorial</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">kfact</span> n k<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> n <span class="token number">1</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token function">k</span> <span class="token number">1</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token function">kfact</span> <span class="token punctuation">(</span><span class="token operator">-</span> n <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k</span> <span class="token punctuation">(</span><span class="token operator">*</span> n x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[例2]将3与4的阶乘相加。</p><p>[例2]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token comment" spellcheck="true">;;; normal</span><span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token function">fact</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;;; CPS</span><span class="token punctuation">(</span><span class="token function">kfact</span> <span class="token number">4</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k+</span> x <span class="token number">3</span> return<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[代码3]演示了如何分别用普通方式和CPS编写计算表中元素之积的函数。在CPS函数中，后继函数存储在局部变量<code>break</code>中，因此当元素乘以0时，可以立即退出。</p><p>[代码3]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token comment" spellcheck="true">;;; normal</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">product</span> ls<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">ls</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">acc</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">cond</span>     <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">null?</span> ls<span class="token punctuation">)</span> acc<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">zero?</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">0</span><span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">else</span> <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span> acc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;;; CPS</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">kproduct</span> ls k<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">break</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">ls</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token keyword">cond</span>       <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">null?</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">zero?</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">break</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token keyword">else</span> <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[例3]将100与<code>&#39;(2 4 7)</code>的积相加。</p><p>[例3]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token comment" spellcheck="true">;;; normal</span><span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">100</span> <span class="token punctuation">(</span><span class="token function">product</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">2</span> <span class="token number">4</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;;; CPS</span><span class="token punctuation">(</span><span class="token function">kproduct</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">2</span> <span class="token number">4</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k+</span> x <span class="token number">100</span> return<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>尽管CPS在这样简单的情况中并不实用，但在一些像是自然语言解析和逻辑编程等复杂程序中非常有用，因为与通常的编程风格相比，CPS可以更灵活地改变后续过程。</p><p><strong>异常处理（Exception handling）</strong>就是这种情况的简单例子。[代码4]演示了<code>kproduct</code>的错误处理版本，程序中当非数字值出现在输入表中，在其被打印时，计算就会终止。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">non-number-value-error</span> x<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">display</span> <span class="token string">"Value error: "</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">display</span>  x<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">display</span> <span class="token string">" is not number."</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span>newline<span class="token punctuation">)</span>  <span class="token string">'error)</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">kproduct</span> ls k k-value-error<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">break</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">ls</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token keyword">cond</span>       <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">null?</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">not</span> <span class="token punctuation">(</span><span class="token builtin">number?</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k-value-error</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">zero?</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">break</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token keyword">else</span> <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;;; valid</span><span class="token punctuation">(</span><span class="token function">kproduct</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">2</span> <span class="token number">4</span> <span class="token number">7</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k+</span> x <span class="token number">100</span> return<span class="token punctuation">)</span><span class="token punctuation">)</span>       non-number-value-error<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 156</span><span class="token comment" spellcheck="true">;;; invalid</span><span class="token punctuation">(</span><span class="token function">kproduct</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">2</span> <span class="token number">4</span> <span class="token number">7</span> hoge<span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k+</span> x <span class="token number">100</span> return<span class="token punctuation">)</span><span class="token punctuation">)</span>       non-number-value-error<span class="token punctuation">)</span>Value error: hoge is not number.<span class="token comment" spellcheck="true">;Value: error</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Scheme中的继续"><a href="#Scheme中的继续" class="headerlink" title="Scheme中的继续"></a>Scheme中的继续</h3><p>通过上面的讲解，你应该掌握了继续（continuation）。继续有下面的性质：</p><ol><li>存在于整个计算过程中；</li><li>函数式程序设计语言和CPS可以显式地处理它。</li></ol><p>另外，上面例子展示的是<strong>闭包链（Chain of closure）</strong>。</p><p>然而，阅读和编写CPS程序是痛苦的，以常规方式来处理继续会更方便一点。</p><p>因此，Scheme中将继续实现为<strong>一级对象（first class object）</strong>（这意味这Scheme中的继续是个普通数据类型），任何时候都可以通过名为<code>call-with-current-continuation</code>来调用。由于继续是普通数据类型，你可以随心所欲地重用。考虑到<code>call-with-current-continuation</code>名字过长，通常使用其缩略名<code>call/cc</code>。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> call/cc call-with-current-continuation<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>函数<code>call-with-current-continuation (call/cc)</code>接受一个参数。该参数是一个函数，函数的参数接收当前继续。</p><p>下面是例子：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token builtin">call/cc</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">;⇒ 9      ; [1]</span><span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token builtin">call/cc</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">(</span><span class="token function">k</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;⇒ 6      ; [2]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在<strong>情况[1]</strong>中，继续并没有被调用，语句的行为与普通S-表达式相同。另一方面，在<strong>情况[2]</strong>中，继续以2作为参数被调用。在这种情况中，继续的参数跳过了<code>call/cc</code>的处理，并逃逸至<code>call/cc</code>的外部。这种情况中，<code>k</code>是一个一元函数，等价于<code>(lambda (x) (* 3 x))</code>。</p><p>大体来说，当前继续存储了从<code>call/cc</code>调用点到顶层的处理过程。当前继续可以像其它数据类型那样被存储起来，并随心所欲地重用。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> cc<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token builtin">call/cc</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>k<span class="token punctuation">)</span>                  <span class="token punctuation">(</span><span class="token keyword">set!</span> cc k<span class="token punctuation">)</span>                  <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>由于当前继续是回到顶层的处理过程，它的返回会忽略周围的S-表达式。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">100</span> <span class="token punctuation">(</span><span class="token function">cc</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">;⇒ 9 </span><span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">100</span> <span class="token punctuation">(</span><span class="token function">cc</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;⇒ 30</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="使用call-cc抛出值"><a href="#使用call-cc抛出值" class="headerlink" title="使用call/cc抛出值"></a>使用<code>call/cc</code>抛出值</h4><p>从一个计算过程中逃逸出来，是使用当前继续的最容易的方法。[代码5]演示了搜索树（嵌套表）的函数。如果函数在树中找到<code>obj</code>，那么它返回该对象，否则返回<code>#f</code>。一旦找到<code>obj</code>，函数直接将其抛出至最外部。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">find-leaf</span> obj tree<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token builtin">call/cc</span>    <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>cc<span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token keyword">letrec</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">iter</span>                   <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>tree<span class="token punctuation">)</span>                      <span class="token punctuation">(</span><span class="token keyword">cond</span>                        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">null?</span>  tree<span class="token punctuation">)</span> <span class="token boolean">#f</span><span class="token punctuation">)</span>                        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">pair?</span> tree<span class="token punctuation">)</span>                           <span class="token punctuation">(</span><span class="token function">iter</span> <span class="token punctuation">(</span><span class="token builtin">car</span> tree<span class="token punctuation">)</span><span class="token punctuation">)</span>                           <span class="token punctuation">(</span><span class="token function">iter</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> tree<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                        <span class="token punctuation">(</span><span class="token keyword">else</span>                          <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">eqv?</span> obj tree<span class="token punctuation">)</span>                            <span class="token punctuation">(</span><span class="token function">cc</span> obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token punctuation">(</span><span class="token function">iter</span> tree<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">find-leaf</span> <span class="token number">7</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token punctuation">(</span><span class="token function">2</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token number">4</span> <span class="token punctuation">(</span><span class="token function">5</span> <span class="token punctuation">(</span><span class="token function">6</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒ 7</span><span class="token punctuation">(</span><span class="token function">find-leaf</span> <span class="token number">8</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token punctuation">(</span><span class="token function">2</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token number">4</span> <span class="token punctuation">(</span><span class="token function">5</span> <span class="token punctuation">(</span><span class="token function">6</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒ ()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[例6]演示了一个支持抛出的语法<code>block</code>。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> block  <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> tag e1 ...<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token builtin">call-with-current-continuation</span>       <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>tag<span class="token punctuation">)</span>          e1 ...<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[例7]演示了如何使用它。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">block</span> break   <span class="token punctuation">(</span><span class="token function">map</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span>           <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">positive?</span> x<span class="token punctuation">)</span>           <span class="token punctuation">(</span><span class="token function">sqrt</span> x<span class="token punctuation">)</span>           <span class="token punctuation">(</span><span class="token function">break</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒ (1 1.4142135623730951 1.7320508075688772)</span><span class="token punctuation">(</span><span class="token function">block</span> break   <span class="token punctuation">(</span><span class="token function">map</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span>           <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">positive?</span> x<span class="token punctuation">)</span>           <span class="token punctuation">(</span><span class="token function">sqrt</span> x<span class="token punctuation">)</span>           <span class="token punctuation">(</span><span class="token function">break</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">-2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒ -2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>我会讲解如何用<code>call/cc</code>实现一个树匹配的生成器。生成器以一个树为参数返回一个函数，每次调用这个返回的函数时，它会返回后续的叶子。你可以在<a href="http://ds26gte.github.io/tyscheme/index-Z-H-15.html#node_sec_13.3">Teach Yourself Scheme in Fixnum Days的第13.3节</a>中找到这个函数的原始版本。生成器的使用方法如下：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> tr <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">3</span> <span class="token punctuation">(</span><span class="token function">4</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> p <span class="token punctuation">(</span><span class="token function">leaf-generator</span> tr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;=> 1</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;=> 2</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;=> 3</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;=> 4</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;=> 5</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;=> ()  ; finally it returns '()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[代码6]给出了生成器的定义。这个和原始版本基本上相同，但有略微的修改。</p><p>[代码6]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">leaf-generator</span> tree<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">return</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                               <span class="token comment" spellcheck="true">; 1</span>    <span class="token punctuation">(</span><span class="token keyword">letrec</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">continue</span>                                              <span class="token comment" spellcheck="true">; 2</span>      <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">(</span><span class="token keyword">let</span> rec <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">tree</span> tree<span class="token punctuation">)</span><span class="token punctuation">)</span>                                      <span class="token comment" spellcheck="true">; 3</span>          <span class="token punctuation">(</span><span class="token keyword">cond</span>                                                     <span class="token comment" spellcheck="true">; 4</span>           <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">null?</span> tree<span class="token punctuation">)</span> <span class="token string">'skip)</span>                                     <span class="token comment" spellcheck="true">; 5</span>           <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">pair?</span> tree<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">rec</span> <span class="token punctuation">(</span><span class="token builtin">car</span> tree<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">rec</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> tree<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token comment" spellcheck="true">; 6</span>           <span class="token punctuation">(</span><span class="token keyword">else</span>                                                    <span class="token comment" spellcheck="true">; 7</span>            <span class="token punctuation">(</span><span class="token builtin">call/cc</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>lap-to-go<span class="token punctuation">)</span>                            <span class="token comment" spellcheck="true">; 8</span>                   <span class="token punctuation">(</span><span class="token keyword">set!</span> continue <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">lap-to-go</span> <span class="token string">'restart)))</span> <span class="token comment" spellcheck="true">; 9</span>                   <span class="token punctuation">(</span><span class="token function">return</span> tree<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                               <span class="token comment" spellcheck="true">;10</span>        <span class="token punctuation">(</span><span class="token function">return</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                             <span class="token comment" spellcheck="true">;11</span>    <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>                                                  <span class="token comment" spellcheck="true">;12</span>      <span class="token punctuation">(</span><span class="token builtin">call/cc</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>where-to-go<span class="token punctuation">)</span>                            <span class="token comment" spellcheck="true">;13</span>                 <span class="token punctuation">(</span><span class="token keyword">set!</span> return where-to-go<span class="token punctuation">)</span>                      <span class="token comment" spellcheck="true">;14</span>                 <span class="token punctuation">(</span>continue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(译者注：原文中05，08行中命名let中的<code>rec</code>被写为<code>loop</code>，结合上下文，改为<code>rec</code>)</p><p>注释解释</p><p>编号 解释</p><ul><li>1.定义本地变量<code>return</code>。</li><li>2.使用<code>letrec</code>定义<code>continue</code>。<code>continue</code>将当前叶子返回到前面，将当前继续赋给<code>continue</code>，并停止。</li><li>3.用<code>rec</code>定义命名let。</li><li>4.使用<code>cond</code>实现分支</li><li>5.如果是空表，什么也不做</li><li>6.如果是序对，递归地将序对的car和cdr应用于rec。</li><li>7.如果是叶子，</li><li>8.调用<code>call/cc</code>以获取当前状态(lap-to-go)</li><li>9.接着将当前状态赋给<code>continue</code>。所以除了原有的<code>continue</code>，<code>lap-to-go</code>也包含了当前状态。简而言之，它可以被如下的S-表达式中的<strong>[ ]</strong>表示。</li></ul><pre class="line-numbers language-Scheme"><code class="language-Scheme">(lambda ()   (let rec ((tree tree0))        (cond                          ((null? tree) '())             ((pair? tree) (rec (car tree)) (rec (cdr tree)))          (else                                                       [ ]    (return '()))))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用<code>lap-to-go</code>意味着<code>(car tree)</code>是叶子，且过程结束了，<code>(rec (cdr tree))</code>在下一次函数调用时开始运行。如果过程在<strong>[ ]</strong>之后结束，继续的参数将不起作用。</p><ul><li>10.接着函数将找到的叶子返回到函数的调用处。<code>(return tree)</code>应该在<code>call/cc</code>中以重启过程。</li><li>11.在搜索了全部叶子之后返回空表。</li><li>12.这是一个返回叶子生成器的生成器。</li><li>13.首次调用<code>call/cc</code></li><li>14.将表示返回值的当前状态赋给<code>return</code>。</li><li>15.然后调用<code>continue</code>。</li></ul><p>由<code>leaf-generator</code>生成的函数的行为可以通过函数<code>tree-traverse</code>的行为来估计。过程停止在轨迹的’*’的注释处，并使得过程存储在<code>continue</code>。</p><p>一个常规的遍历函数：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> tree-traverse  <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>tree<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">cond</span>     <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">null?</span> tree<span class="token punctuation">)</span> <span class="token string">'_)</span>     <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">pair?</span> tree<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">tree-traverse</span> <span class="token punctuation">(</span><span class="token builtin">car</span> tree<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">tree-traverse</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> tree<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">else</span>      <span class="token punctuation">(</span><span class="token function">write</span> tree<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当树为<code>&#39;((1 2) 3)</code>时，<code>tree-traverse</code>的轨迹。</p><pre><code>&gt; (tree-traverse &#39;((1 2) 3))|(tree-traverse ((1 2) 3))| (tree-traverse (1 2))| |(tree-traverse 1)           1| |#&lt; void&gt;               ; *| (tree-traverse (2))| |(tree-traverse 2)           2| |&lt; void&gt;                ; *| (tree-traverse &#39;())| _|(tree-traverse (3))| (tree-traverse 3)            3| #&lt; void&gt;                ; *|(tree-traverse &#39;())|__</code></pre><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>因为继续记录了后续计算过程，因此，用于多任务同时执行的<strong>协程（Coroutine）</strong>可以使用继续来实现。</p><p><strong>代码片段7</strong>展示了一段交替打印数字和字母的程序。5 - 22行是队列的实现。<code>(enqueue! queue obj)</code>将一个<code>obj</code>添加在队列的末尾。<code>(dequeue! queue)</code>返回队列第一个元素并将它删除。</p><p>26 - 38行是协程的实现。</p><p><strong>process-queue</strong></p><p>过程的队列。</p><p><strong>(coroutine thunk)</strong></p><p>在<code>process-queue</code>末尾添加<code>thunk</code>。</p><p><strong>(start)</strong></p><p>取得<code>process-queue</code>的第一个过程并执行它。</p><p><strong>(pause)</strong></p><p>将当前继续添加到<code>process-queue</code>的末尾并执行队列里的第一个过程。这个函数将控制权交给另外一个协程。</p><p>42 - 61行显示如何使用它。一个显示数字例程和一个显示字母例程相互调用对方，结果显示在<strong>例7</strong></p><pre class="line-numbers language-scheme"><code class="language-scheme">01:     <span class="token comment" spellcheck="true">;;; abbreviation</span><span class="token number">02</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> call/cc call-with-current-continuation<span class="token punctuation">)</span><span class="token number">03</span>:     <span class="token number">04</span>:     <span class="token comment" spellcheck="true">;;; queue</span><span class="token number">05</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>make-queue<span class="token punctuation">)</span><span class="token number">06</span>:       <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">07</span>:     <span class="token number">08</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">enqueue!</span> queue obj<span class="token punctuation">)</span><span class="token number">09</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">lobj</span> <span class="token punctuation">(</span><span class="token builtin">list</span> obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">10</span>:         <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">null?</span> <span class="token punctuation">(</span><span class="token builtin">car</span> queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">11</span>:         <span class="token punctuation">(</span><span class="token keyword">begin</span><span class="token number">12</span>:           <span class="token punctuation">(</span><span class="token function">set-car!</span> queue lobj<span class="token punctuation">)</span><span class="token number">13</span>:           <span class="token punctuation">(</span><span class="token function">set-cdr!</span> queue lobj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">14</span>:         <span class="token punctuation">(</span><span class="token keyword">begin</span><span class="token number">15</span>:           <span class="token punctuation">(</span><span class="token function">set-cdr!</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> queue<span class="token punctuation">)</span> lobj<span class="token punctuation">)</span><span class="token number">16</span>:           <span class="token punctuation">(</span><span class="token function">set-cdr!</span> queue lobj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">17</span>:         <span class="token punctuation">(</span><span class="token builtin">car</span> queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">18</span>:     <span class="token number">19</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">dequeue!</span> queue<span class="token punctuation">)</span><span class="token number">20</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">obj</span> <span class="token punctuation">(</span><span class="token builtin">car</span> <span class="token punctuation">(</span><span class="token builtin">car</span> queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">21</span>:         <span class="token punctuation">(</span><span class="token function">set-car!</span> queue <span class="token punctuation">(</span><span class="token builtin">cdr</span> <span class="token punctuation">(</span><span class="token builtin">car</span> queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">22</span>:         obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">23</span>:     <span class="token number">24</span>:     <span class="token number">25</span>:     <span class="token comment" spellcheck="true">;;; coroutine   </span><span class="token number">26</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> process-queue <span class="token punctuation">(</span>make-queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">27</span>:     <span class="token number">28</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">coroutine</span> thunk<span class="token punctuation">)</span><span class="token number">29</span>:       <span class="token punctuation">(</span><span class="token function">enqueue!</span> process-queue thunk<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">30</span>:     <span class="token number">31</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token number">32</span>:        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">dequeue!</span> process-queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">33</span>:        <span class="token number">34</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>pause<span class="token punctuation">)</span><span class="token number">35</span>:       <span class="token punctuation">(</span><span class="token builtin">call/cc</span><span class="token number">36</span>:        <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token number">37</span>:          <span class="token punctuation">(</span><span class="token function">coroutine</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k</span> <span class="token boolean">#f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">38</span>:          <span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">39</span>:     <span class="token number">40</span>:     <span class="token number">41</span>:     <span class="token comment" spellcheck="true">;;; example</span><span class="token number">42</span>:     <span class="token punctuation">(</span><span class="token function">coroutine</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">43</span>:              <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">44</span>:                <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> i <span class="token number">10</span><span class="token punctuation">)</span><span class="token number">45</span>:                <span class="token punctuation">(</span><span class="token keyword">begin</span><span class="token number">46</span>:                  <span class="token punctuation">(</span><span class="token function">display</span> <span class="token punctuation">(</span><span class="token function">1+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">47</span>:                  <span class="token punctuation">(</span><span class="token function">display</span> <span class="token string">" "</span><span class="token punctuation">)</span> <span class="token number">48</span>:                  <span class="token punctuation">(</span>pause<span class="token punctuation">)</span> <span class="token number">49</span>:                  <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token function">1+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">50</span>:                <span class="token number">51</span>:     <span class="token punctuation">(</span><span class="token function">coroutine</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">52</span>:              <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">53</span>:                <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> i <span class="token number">10</span><span class="token punctuation">)</span><span class="token number">54</span>:                <span class="token punctuation">(</span><span class="token keyword">begin</span><span class="token number">55</span>:                  <span class="token punctuation">(</span><span class="token function">display</span> <span class="token punctuation">(</span><span class="token function">integer->char</span> <span class="token punctuation">(</span><span class="token operator">+</span> i <span class="token number">97</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">56</span>:                  <span class="token punctuation">(</span><span class="token function">display</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token number">57</span>:                  <span class="token punctuation">(</span>pause<span class="token punctuation">)</span> <span class="token number">58</span>:                  <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token function">1+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">59</span>:     <span class="token number">60</span>:     <span class="token punctuation">(</span>newline<span class="token punctuation">)</span><span class="token number">61</span>:     <span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">load</span> <span class="token string">"cor2.scm"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Loading "cor2.scm"</span><span class="token number">1</span> a <span class="token number">2</span> b <span class="token number">3</span> c <span class="token number">4</span> d <span class="token number">5</span> e <span class="token number">6</span> f <span class="token number">7</span> g <span class="token number">8</span> h <span class="token number">9</span> i <span class="token number">10</span> j  -- done<span class="token comment" spellcheck="true">;Unspecified return value</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>本章中，我讲解了继续。</p><p>理解这些概念可能比较困难。但不要担心，有朝一日你终会明白。</p><p>下一章中，我将介绍惰性求值。</p><h2 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h2><h3 id="简介-11"><a href="#简介-11" class="headerlink" title="简介"></a>简介</h3><p>惰性求值（Lazy evaluation）是在需要时才进行求值的计算方式。惰性求值自然地在数据结构中包含递归，可以以简单的方式表示无限的概念，这种方式有利于程序的模块化。</p><p>你可以从<a href="http://deathking.github.io/yast-cn/contents/www.md.chalmers.se/~rjmh/Papers/whyfp.html">《Why Functional Programming Matters》</a>中知晓惰性计算可以带来哪些好处。</p><p><a href="http://deathking.github.io/yast-cn/contents/www.haskell.org">Haskell</a>语言以采用惰性求值而广为人熟知。Scheme也部分采用了惰性求值。</p><h3 id="用于惰性求值的函数"><a href="#用于惰性求值的函数" class="headerlink" title="用于惰性求值的函数"></a>用于惰性求值的函数</h3><p>下面这些用于处理惰性求值的函数是在R5RS中定义的。中间状态被称为延时对象（<code>promise</code>），它表示求值方法已经定义好了，但求值还未执行。最终的值通过对延时对象（<code>promise</code>）调用force被计算出来。</p><p><strong>(delay <code>proc</code>)</strong></p><p>以<code>proc</code>创建一个延时对象（<code>promise</code>）。</p><p><strong>(promise? <code>obj</code>)</strong></p><p>如果<code>obj</code>是一个延时对象就返回 #t。</p><p><strong>(force <code>promise</code>)</strong></p><p>对延时对象求值，执行求值操作。</p><h3 id="惰性求值的简单例子"><a href="#惰性求值的简单例子" class="headerlink" title="惰性求值的简单例子"></a>惰性求值的简单例子</h3><p>[例1]展示一个惰性求值的简单例子。在这个例子中，延时对象（<code>promise</code>）通过对(1 + 2)调用<code>delay</code>产生，然后通过函数<code>force</code>对延时对象求值。</p><p>[例1]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> laz <span class="token punctuation">(</span><span class="token keyword">delay</span> <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: laz</span>laz<span class="token comment" spellcheck="true">;Value 11: #[promise 11]</span><span class="token punctuation">(</span><span class="token function">promise?</span> laz<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token function">force</span> laz<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 3</span><span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">10</span> <span class="token punctuation">(</span><span class="token function">force</span> laz<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 30</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意延时对象并没有被<code>force</code>消费掉，这意味着函数<code>force</code>没有副作用。因此，你可以重复使用延时对象。</p><h3 id="使用惰性求值表示无限序列"><a href="#使用惰性求值表示无限序列" class="headerlink" title="使用惰性求值表示无限序列"></a>使用惰性求值表示无限序列</h3><p>现在，让我们使用惰性求值创建无限序列。首先，我将定义一些用于处理无限序列的基本函数。然后，我会使用这些函数创建无限序列，并将无限序列用于数值计算。</p><p>无限序列可以用如表达式（1）的cons单元（cons cell）的嵌套结构表示。cons单元的<code>car</code>和<code>cdr</code>分别是最终值和延时对象（promise）。另一个表达式（1）结构的cons单元通过强制求值<code>cdr</code>部分产生，你可以无限重复这个过程，就像图 1。这个和cons单元的嵌套结构和普通表类似，只是使用延时对象作为<code>cdr</code>部分使其可以表示无限序列。</p><pre><code>    (&lt;val&gt; . &lt;promise&gt;)    (1)</code></pre><p><img src="http://deathking.github.io/yast-cn/contents/figures/lazy_fig_1.png" alt="infiity sequence"></p><p>图 1. 无限序列的实现，使用了<code>car</code>和<code>cdr</code>分别为最终值和延时对象的cons单元。</p><h3 id="无限序列的基本函数和宏"><a href="#无限序列的基本函数和宏" class="headerlink" title="无限序列的基本函数和宏"></a>无限序列的基本函数和宏</h3><p>[代码 1]展示了无限序列的基本函数和宏。其中最重要的是<code>lazy-map</code>，被用于操作无限序列。</p><p>由于<code>lazy-map</code>包含一个特殊delay构造用于延迟求值，所以它需要被定义为宏。</p><p>[代码 1]</p><pre class="line-numbers language-scheme"><code class="language-scheme">01:     <span class="token comment" spellcheck="true">;;;;; basic functions and a macro</span><span class="token number">02</span>:     <span class="token number">03</span>:     <span class="token comment" spellcheck="true">;;; car for lazy evaluation</span><span class="token number">04</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> lazy-car car<span class="token punctuation">)</span><span class="token number">05</span>:     <span class="token number">06</span>:     <span class="token comment" spellcheck="true">;;; cdr for lazy evaluation</span><span class="token number">07</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">lazy-cdr</span> ls<span class="token punctuation">)</span><span class="token number">08</span>:       <span class="token punctuation">(</span><span class="token function">force</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">09</span>:     <span class="token number">10</span>:     <span class="token comment" spellcheck="true">;;; lazy cons</span><span class="token number">11</span>:     <span class="token punctuation">(</span><span class="token keyword">define-syntax</span> lazy-cons<span class="token number">12</span>:        <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">13</span>:           <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> a b<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> a <span class="token punctuation">(</span><span class="token keyword">delay</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">14</span>:     <span class="token number">15</span>:     <span class="token comment" spellcheck="true">;;; lazy map</span><span class="token number">16</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">lazy-map</span> fn . lss<span class="token punctuation">)</span><span class="token number">17</span>:       <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">memq</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span> lss<span class="token punctuation">)</span><span class="token number">18</span>:           <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">19</span>:         <span class="token punctuation">(</span><span class="token function">lazy-cons</span> <span class="token punctuation">(</span><span class="token builtin">apply</span> fn <span class="token punctuation">(</span><span class="token function">map</span> lazy-car lss<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">20</span>:                    <span class="token punctuation">(</span><span class="token builtin">apply</span> lazy-map fn <span class="token punctuation">(</span><span class="token function">map</span> lazy-cdr lss<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">21</span>:     <span class="token number">22</span>:     <span class="token comment" spellcheck="true">;;; lazy filter</span><span class="token number">23</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">lazy-filter</span> pred ls<span class="token punctuation">)</span><span class="token number">24</span>:       <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">null?</span> ls<span class="token punctuation">)</span><span class="token number">25</span>:           <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">26</span>:         <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">obj</span> <span class="token punctuation">(</span><span class="token function">lazy-car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">27</span>:           <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pred</span> obj<span class="token punctuation">)</span><span class="token number">28</span>:               <span class="token punctuation">(</span><span class="token function">lazy-cons</span> obj  <span class="token punctuation">(</span><span class="token function">lazy-filter</span> pred <span class="token punctuation">(</span><span class="token function">lazy-cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">29</span>:             <span class="token punctuation">(</span><span class="token function">lazy-filter</span> pred <span class="token punctuation">(</span><span class="token function">lazy-cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">30</span>:     <span class="token number">31</span>:     <span class="token comment" spellcheck="true">;;; returns n-th item of the lazy list</span><span class="token number">32</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">lazy-ref</span> ls n<span class="token punctuation">)</span><span class="token number">33</span>:       <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> n <span class="token number">0</span><span class="token punctuation">)</span><span class="token number">34</span>:           <span class="token punctuation">(</span><span class="token function">lazy-car</span> ls<span class="token punctuation">)</span><span class="token number">35</span>:         <span class="token punctuation">(</span><span class="token function">lazy-ref</span> <span class="token punctuation">(</span><span class="token function">lazy-cdr</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">-</span> n <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">36</span>:     <span class="token number">37</span>:     <span class="token comment" spellcheck="true">;;; returns first n items of the ls</span><span class="token number">38</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">head</span> ls n<span class="token punctuation">)</span><span class="token number">39</span>:       <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> n <span class="token number">0</span><span class="token punctuation">)</span><span class="token number">40</span>:           <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">41</span>:          <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token punctuation">(</span><span class="token function">lazy-car</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">head</span> <span class="token punctuation">(</span><span class="token function">lazy-cdr</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">-</span> n <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(lazy-car ls)</strong></p><p>和<code>(car ls)</code>一样，因为<code>car</code>部分是最终值。</p><p><strong>(lazy-cdr ls)</strong></p><p>计算<code>ls</code>的<code>cdr</code>部分（延时对象）的‘最终’值。</p><p><strong>(lazy-cons a b)</strong></p><p>这是一个扩展了<code>(cons a (delay b))</code>的宏。如果这个操作被定义为一个函数，<code>b</code>将立刻求值，这样delay就没有任何意义了。</p><p><strong>(lazy-map fn . lss)</strong></p><p>这是一个惰性求值的<code>map</code>函数，是在[代码 1]中最重要的函数。注意它返回一个包含最终值（<code>car</code>部分）和延时对象（<code>cdr</code>部分）的cons单元。</p><p><strong>(lazy-filter pred ls)</strong></p><p>这是一个惰性求值的<code>filter</code>函数。它过滤<code>ls</code>并返回一个由包含满足<code>pred</code>条件的元素组成的‘无限序列’。</p><p><strong>(lazy-ref ls n)</strong></p><p>返回‘无限序列’<code>ls</code>的第n个元素。</p><p><strong>(head ls n)</strong></p><p>返回<code>ls</code>（惰性求值表）的前n个元素。</p><h3 id="无限序列"><a href="#无限序列" class="headerlink" title="无限序列"></a>无限序列</h3><p>无限序列可以简洁地用<code>lazy-cons</code>和<code>lazy-map</code>表示。我会展示两个例子：</p><ul><li>下一项由前一项定义的序列，如等差数列和等比数列。</li><li>菲波那契数列。</li></ul><h4 id="下一个项由前一项定义的序列"><a href="#下一个项由前一项定义的序列" class="headerlink" title="下一个项由前一项定义的序列"></a>下一个项由前一项定义的序列</h4><p>下一个项由前一项定义的序列可以有如下形式的函数（f）定义：</p><p>[{a}_{i+1} = f({a}_i) ]</p><p>可以表示为[代码2]里的<code>(inf-seq a0 f)</code>，<code>a0</code>和<code>f</code>分别是初始项和用于计算随后项的函数。</p><p><code>(inf-seq a0 f)</code>是递归定义的，它的定义清晰表明初始项是a0，第二项是<code>(f a0)</code>，<code>(n+1)</code>项由<code>(f an)</code>表示。</p><p>等差和等比数列分别被定义为<code>(ari a0 d)</code>和<code>(geo a0 r)</code>，其中<code>a0</code>，<code>d</code>和<code>r</code>分别是初始值，公差，公比。这些函数使用函数<code>inf-seq</code>定义。</p><p>[代码2]</p><pre class="line-numbers language-scheme"><code class="language-scheme">01:     <span class="token comment" spellcheck="true">;;;;  sequences</span><span class="token number">02</span>:     <span class="token number">03</span>:     <span class="token comment" spellcheck="true">;;; infinite sequences represented by a_(n+1) = f(a_n)</span><span class="token number">04</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">inf-seq</span> a0 f<span class="token punctuation">)</span><span class="token number">05</span>:       <span class="token punctuation">(</span><span class="token function">lazy-cons</span> a0 <span class="token punctuation">(</span><span class="token function">inf-seq</span> <span class="token punctuation">(</span><span class="token function">f</span> a0<span class="token punctuation">)</span> f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">06</span>:     <span class="token number">07</span>:     <span class="token comment" spellcheck="true">;;; arithmetic sequence</span><span class="token number">08</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">ari</span> a0 d<span class="token punctuation">)</span><span class="token number">09</span>:       <span class="token punctuation">(</span><span class="token function">inf-seq</span> a0 <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">+</span> x d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">10</span>:     <span class="token number">11</span>:     <span class="token comment" spellcheck="true">;;; geometric sequence</span><span class="token number">12</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">geo</span> a0 r<span class="token punctuation">)</span><span class="token number">13</span>:       <span class="token punctuation">(</span><span class="token function">inf-seq</span> a0 <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span> x r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>让我们检查一下<code>inf-seq</code>所产生的无限序列（例2）。创建两个等比数列：</p><ol><li><code>g1</code>，初始值1，公比为2。</li><li><code>g2</code>，初始值1，公比为1/2。</li></ol><p>然后使用<code>head</code>求值前10项。你将看到正确产生了两个等比数列。</p><p>接下来，使用<code>lazy-map</code>计算<code>g1</code>和<code>g2</code>的乘积，并使用<code>head</code>求值前10项。你将看到一个全是1的序列，这表明计算被正确地执行了。</p><p>现在，让我们用等差数列和<code>lazy-filter</code>娱乐一番。首先，用<code>(ari 1 1)</code>创建一个等比数列<code>ar1</code>。<code>(head ar1 10)</code>的结果显示等比数列 <code>(1 2 3 ....)</code> 是由 <code>(ari 1 1)</code> 产生的。然后使用<code>lazy-filter</code>取出<code>ar1</code>里的偶数，并使用<code>head</code>求值前10项。你将看到<code>(2 4 6 8 10 12 14 16 18 20)</code>，这表明<code>lazy-filter</code>正常工作。</p><p>[例2]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> g1 <span class="token punctuation">(</span><span class="token function">geo</span> <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: g1</span><span class="token punctuation">(</span><span class="token keyword">define</span> g2 <span class="token punctuation">(</span><span class="token function">geo</span> <span class="token number">1</span> <span class="token punctuation">(</span><span class="token operator">/</span> <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: g2</span><span class="token punctuation">(</span><span class="token function">head</span> g1 <span class="token number">10</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 12: (1 2 4 8 16 32 64 128 256 512)</span><span class="token punctuation">(</span><span class="token function">head</span> g2 <span class="token number">10</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 13: (1 1/2 1/4 1/8 1/16 1/32 1/64 1/128 1/256 1/512)</span><span class="token punctuation">(</span><span class="token function">head</span> <span class="token punctuation">(</span><span class="token function">lazy-map</span> * g1 g2<span class="token punctuation">)</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 14: (1 1 1 1 1 1 1 1 1 1)</span><span class="token punctuation">(</span><span class="token keyword">define</span> ar1 <span class="token punctuation">(</span><span class="token function">ari</span> <span class="token number">1</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;;Value: ar1</span><span class="token punctuation">(</span><span class="token function">head</span> ar1 <span class="token number">10</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;;Value 15: (1 2 3 4 5 6 7 8 9 10)</span><span class="token punctuation">(</span><span class="token function">head</span> <span class="token punctuation">(</span><span class="token function">lazy-filter</span> even? ar1<span class="token punctuation">)</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;;Value 16: (2 4 6 8 10 12 14 16 18 20)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="菲波那切数列"><a href="#菲波那切数列" class="headerlink" title="菲波那切数列"></a>菲波那切数列</h4><p>菲波那切数列定义如下：</p><pre><code>fib(1) = 1fib(2) = 1fib(n+1) = fib(n) + fib(n-1)</code></pre><p>代码3展示了Scheme实现的菲波那切数列，用到了<code>lazy-cons</code>和<code>lazy-map</code>。如代码所示，Scheme里的定义和数学上的定义很相似。此外，各个项的计算的复杂度为<em>O(n)</em>。</p><p>[例3]中，值被立刻计算出来了。</p><p>[代码 3]</p><pre class="line-numbers language-scheme"><code class="language-scheme">01:     <span class="token punctuation">(</span><span class="token keyword">define</span> fib<span class="token number">02</span>:       <span class="token punctuation">(</span><span class="token function">lazy-cons</span> <span class="token number">1</span><span class="token number">03</span>:                  <span class="token punctuation">(</span><span class="token function">lazy-cons</span> <span class="token number">1</span><span class="token number">04</span>:                             <span class="token punctuation">(</span><span class="token function">lazy-map</span> + fib <span class="token punctuation">(</span><span class="token function">lazy-cdr</span> fib<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>[例 3]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">head</span> fib <span class="token number">20</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 12: (1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765)</span><span class="token punctuation">(</span><span class="token function">lazy-ref</span> fib <span class="token number">100</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 573147844013817084101</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="将惰性求值用于数值计算"><a href="#将惰性求值用于数值计算" class="headerlink" title="将惰性求值用于数值计算"></a>将惰性求值用于数值计算</h3><p>下面是<a href="http://deathking.github.io/yast-cn/contents/www.md.chalmers.se/~rjmh/Papers/whyfp.html">《Why Functional Programming Matters》</a>里相关代码的Schme版本。也可以查看<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%_sec_3.5">SICP 3.5. Stream</a>惰性计算在数值计算中的应用。</p><h4 id="牛顿-拉夫逊法求平方根"><a href="#牛顿-拉夫逊法求平方根" class="headerlink" title="牛顿-拉夫逊法求平方根"></a>牛顿-拉夫逊法求平方根</h4><p>牛顿-拉夫逊法可以使用初始值a0和等式（2）计算N的平方根。</p><pre><code>     a(n+1) =  (a(n) + N/a(n)) / 2                   (2)</code></pre><p>如果等式（2）收敛到最终值 a，</p><pre><code>      a =  (a +  N/a) / 2⇒      2a = a +  N/a      a =  N/a      a*a = N      a =  √N</code></pre><p>，这表明最终值a是N的平方根。序列的下一项是前一项的函数（如等式（2）所示），这些序列可用<code>inf-seq</code>表示。</p><p>代码4展示了一个计算平方根的程序。在代码4中，初始值被定为1，由于序列收敛很快，所以这没问题。</p><p>[代码4]</p><pre class="line-numbers language-scheme"><code class="language-scheme">01:     <span class="token comment" spellcheck="true">;;; Newton-Raphson method</span><span class="token number">02</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">newton-raphson</span> n<span class="token punctuation">)</span><span class="token number">03</span>:       <span class="token punctuation">(</span><span class="token function">inf-seq</span> <span class="token number">1</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">/</span> <span class="token punctuation">(</span><span class="token operator">+</span> x <span class="token punctuation">(</span><span class="token operator">/</span> n x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">04</span>:     <span class="token number">05</span>:     <span class="token comment" spellcheck="true">;;; returning a reasonable answer.</span><span class="token number">06</span>:     <span class="token comment" spellcheck="true">;;; If the ratio of successive terms is in (1 - eps) and (1 + eps),</span><span class="token number">07</span>:     <span class="token comment" spellcheck="true">;;; or the following term is zero,</span><span class="token number">08</span>:     <span class="token comment" spellcheck="true">;;; the function returns it.</span><span class="token number">09</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">lazylist->answer</span> ls eps<span class="token punctuation">)</span><span class="token number">10</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">e1</span> <span class="token punctuation">(</span><span class="token operator">-</span> <span class="token number">1.0</span> eps<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">11</span>:             <span class="token punctuation">(</span><span class="token function">e2</span> <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">1.0</span> eps<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">12</span>:         <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">val</span> <span class="token punctuation">(</span><span class="token function">lazy-car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">13</span>:                    <span class="token punctuation">(</span><span class="token function">ls1</span> <span class="token punctuation">(</span><span class="token function">lazy-cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">14</span>:           <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">val2</span> <span class="token punctuation">(</span><span class="token function">lazy-car</span> ls1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">15</span>:             <span class="token punctuation">(</span><span class="token keyword">if</span>  <span class="token punctuation">(</span><span class="token function">or</span> <span class="token punctuation">(</span><span class="token function">zero?</span> val2<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> e1 <span class="token punctuation">(</span><span class="token operator">/</span> val val2<span class="token punctuation">)</span> e2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">16</span>:                 <span class="token punctuation">(</span><span class="token function">exact->inexact</span> val2<span class="token punctuation">)</span><span class="token number">17</span>:               <span class="token punctuation">(</span><span class="token function">loop</span> val2 <span class="token punctuation">(</span><span class="token function">lazy-cdr</span> ls1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">18</span>:     <span class="token number">19</span>:     <span class="token comment" spellcheck="true">;;;</span><span class="token number">20</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">my-sqrt</span> n eps<span class="token punctuation">)</span><span class="token number">21</span>:       <span class="token punctuation">(</span><span class="token function">lazylist->answer</span> <span class="token punctuation">(</span><span class="token function">newton-raphson</span> n<span class="token punctuation">)</span> eps<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(newton-raphson n)</strong></p><p>一个函数，创建平方根近似值的表。</p><p><strong>(lazylist-&gt;answer ls eps)</strong></p><p>检查收敛是否满足条件了。如果是的，返回数值计算的结果。</p><p>如果<code>(1 - eps) &lt; t2/t1 &lt; (1 + eps)</code> 或者 <code>t2 = 0</code>，函数返回 <code>ls</code> 的后续项（即 <code>t1</code> 和 <code>t2</code>）的第二项。</p><p><strong>(my-sqrt n eps)</strong></p><p>在相对误差eps下，计算n的平方根。</p><pre><code>(my-sqrt 9 0.0000001);Value: 3.</code></pre><h4 id="数值微分"><a href="#数值微分" class="headerlink" title="数值微分"></a>数值微分</h4><p>[代码5]中的<code>easydiff</code>是一种计算数字积分的简单方式，其中<code>f</code>，<code>x</code>，和<code>h</code>分别是被积分的函数，x值，和Δx。理论上，如果<code>h</code>越趋于0，获得的近似值越好。但在实践中，由于数值在计算机里的精度是有限的，微小的<code>h</code>值会导致错误。</p><p>为了解决这个问题，我们用<code>lazylist-diff</code>创建<code>h</code>的惰性表。这个惰性表是初始值为<code>h0</code>，公比为0.5的等比数列。然后我们创建一个对应于<code>h</code>的惰性表的近似值的惰性表。</p><p>可以通过如下代码加快收敛速度，更快得到答案：</p><pre><code>(lazylist-&gt;answer (lazylist-diff h0 f x) eps)</code></pre><p>函数<code>super</code>是收敛加速函数。可以查看<a href="http://deathking.github.io/yast-cn/contents/www.md.chalmers.se/~rjmh/Papers/whyfp.html">《Why Functional Programming Matters》</a>的关于加速技术部分。如果你使用了传统编程语言，加速计算会相当复杂。相反，使用惰性求值可以以简单的方式实现。此外，因为高度的模块化，你可以在其他问题中复用代码，例如数值积分（4.3.3节）。代码6复用了代码5中的加速函数。</p><p>[代码5]</p><pre class="line-numbers language-scheme"><code class="language-scheme">01:     <span class="token comment" spellcheck="true">;;; differentiation</span><span class="token number">02</span>:     <span class="token number">03</span>:     <span class="token comment" spellcheck="true">;;; primitive function for differentiation</span><span class="token number">04</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">easydiff</span> f x h<span class="token punctuation">)</span><span class="token number">05</span>:       <span class="token punctuation">(</span><span class="token operator">/</span> <span class="token punctuation">(</span><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token function">f</span> <span class="token punctuation">(</span><span class="token operator">+</span> x h<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">f</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span> h<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">06</span>:     <span class="token number">07</span>:     <span class="token comment" spellcheck="true">;;; create a lazy list of approximation for differentiation</span><span class="token number">08</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">lazylist-diff</span> h0 f x<span class="token punctuation">)</span><span class="token number">09</span>:       <span class="token punctuation">(</span><span class="token function">lazy-map</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">easydiff</span> f x h<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">geo</span> h0 <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">10</span>:     <span class="token number">11</span>:     <span class="token comment" spellcheck="true">;;; eliminate error from the approximation</span><span class="token number">12</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">elimerror</span> n ls<span class="token punctuation">)</span><span class="token number">13</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">a</span> <span class="token punctuation">(</span><span class="token function">lazy-car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">14</span>:             <span class="token punctuation">(</span><span class="token function">b</span> <span class="token punctuation">(</span><span class="token function">lazy-second</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">15</span>:             <span class="token punctuation">(</span><span class="token function">c</span> <span class="token punctuation">(</span><span class="token function">fix:lsh</span> <span class="token number">1</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">; (expt 2 n)</span><span class="token number">16</span>:         <span class="token punctuation">(</span><span class="token function">lazy-cons</span><span class="token number">17</span>:          <span class="token punctuation">(</span><span class="token operator">/</span> <span class="token punctuation">(</span><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token operator">*</span> b c<span class="token punctuation">)</span> a<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">-</span> c <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">18</span>:          <span class="token punctuation">(</span><span class="token function">elimerror</span> n <span class="token punctuation">(</span><span class="token function">lazy-cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">19</span>:     <span class="token number">20</span>:     <span class="token comment" spellcheck="true">;;; estimate `n' in elimerror</span><span class="token number">21</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">order</span> ls<span class="token punctuation">)</span><span class="token number">22</span>:       <span class="token punctuation">(</span><span class="token keyword">let*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">a</span> <span class="token punctuation">(</span><span class="token function">lazy-car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">23</span>:              <span class="token punctuation">(</span><span class="token function">b</span> <span class="token punctuation">(</span><span class="token function">lazy-second</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">24</span>:              <span class="token punctuation">(</span><span class="token function">c</span> <span class="token punctuation">(</span><span class="token function">lazy-ref</span> ls <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">25</span>:              <span class="token punctuation">(</span><span class="token function">d</span> <span class="token punctuation">(</span><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token operator">/</span> <span class="token punctuation">(</span><span class="token operator">-</span> a c<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">-</span> b c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">26</span>:         <span class="token punctuation">(</span><span class="token keyword">cond</span><span class="token number">27</span>:          <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&lt;</span> d <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token number">28</span>:          <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&lt;=</span> <span class="token number">2</span> d <span class="token number">16</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">inexact->exact</span> <span class="token punctuation">(</span><span class="token function">round</span> <span class="token punctuation">(</span><span class="token function">log2</span> d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">29</span>:          <span class="token punctuation">(</span><span class="token keyword">else</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">30</span>:     <span class="token number">31</span>:     <span class="token comment" spellcheck="true">;;;</span><span class="token number">32</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">log2</span> x<span class="token punctuation">)</span><span class="token number">33</span>:       <span class="token punctuation">(</span><span class="token operator">/</span> <span class="token punctuation">(</span><span class="token function">log</span> x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">log</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">34</span>:     <span class="token number">35</span>:     <span class="token comment" spellcheck="true">;;; improve convergence of the lazy list of the approximation</span><span class="token number">36</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">improve</span> ls<span class="token punctuation">)</span><span class="token number">37</span>:       <span class="token punctuation">(</span><span class="token function">elimerror</span> <span class="token punctuation">(</span><span class="token function">order</span> ls<span class="token punctuation">)</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">38</span>:     <span class="token number">39</span>:     <span class="token comment" spellcheck="true">;;; return the second value of the lazy list</span><span class="token number">40</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">lazy-second</span> ls<span class="token punctuation">)</span><span class="token number">41</span>:       <span class="token punctuation">(</span><span class="token function">lazy-car</span> <span class="token punctuation">(</span><span class="token function">lazy-cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">42</span>:     <span class="token number">43</span>:     <span class="token comment" spellcheck="true">;;; further improve the convergence of the list</span><span class="token number">44</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">super</span> ls<span class="token punctuation">)</span><span class="token number">45</span>:       <span class="token punctuation">(</span><span class="token function">lazy-map</span> lazy-second <span class="token punctuation">(</span><span class="token function">inf-seq</span> ls improve<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">46</span>:                 <span class="token number">47</span>:     <span class="token number">48</span>:     <span class="token comment" spellcheck="true">;;; calculate the differentiation of function `f' at x within error eps</span><span class="token number">49</span>:     <span class="token comment" spellcheck="true">;;; h0 is initial window width</span><span class="token number">50</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">diff</span> f x h0 eps<span class="token punctuation">)</span><span class="token number">51</span>:       <span class="token punctuation">(</span><span class="token function">lazylist->answer</span> <span class="token punctuation">(</span><span class="token function">super</span> <span class="token punctuation">(</span><span class="token function">lazylist-diff</span> h0 f x<span class="token punctuation">)</span><span class="token punctuation">)</span> eps<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">diff</span> sin <span class="token number">0.0</span> <span class="token number">0.1</span> <span class="token number">0.0000001</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: .9999999999999516</span><span class="token punctuation">(</span><span class="token function">diff</span> exp <span class="token number">0.0</span> <span class="token number">0.1</span> <span class="token number">0.000001</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: .9999999991733471</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数值积分"><a href="#数值积分" class="headerlink" title="数值积分"></a>数值积分</h4><p>收敛加速函数无需任何修改即可被用于数值积分。最开始，我们使用<code>easyintegrate</code>创建一个粗略的近似。函数<code>lazylist-integrate</code>使用惰性表，通过递归地调用<code>easyintegrate</code>在中间点切分区间，来改进近似值。函数可以用lazy-map以简单的方式定义。最终，收敛被加速，收敛值由函数<code>integrate</code>返回。</p><p>[代码6]</p><pre class="line-numbers language-scheme"><code class="language-scheme">01:     <span class="token comment" spellcheck="true">;;; integration</span><span class="token number">02</span>:     <span class="token number">03</span>:     <span class="token comment" spellcheck="true">;;; primitive integration</span><span class="token number">04</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">easyintegrate</span> f a b<span class="token punctuation">)</span><span class="token number">05</span>:       <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">/</span> <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token punctuation">(</span><span class="token function">f</span> a<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">f</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">-</span> b a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">06</span>:     <span class="token number">07</span>:     <span class="token comment" spellcheck="true">;;; create the lazy list of approximation for integration</span><span class="token number">08</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">lazylist-integrate</span> f a b<span class="token punctuation">)</span><span class="token number">09</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">mid</span> <span class="token punctuation">(</span><span class="token operator">/</span> <span class="token punctuation">(</span><span class="token operator">+</span> a b<span class="token punctuation">)</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">10</span>:         <span class="token punctuation">(</span><span class="token function">lazy-cons</span> <span class="token punctuation">(</span><span class="token function">easyintegrate</span> f a b<span class="token punctuation">)</span><span class="token number">11</span>:                    <span class="token punctuation">(</span><span class="token function">lazy-map</span> + <span class="token punctuation">(</span><span class="token function">lazylist-integrate</span> f a mid<span class="token punctuation">)</span><span class="token number">12</span>:                                <span class="token punctuation">(</span><span class="token function">lazylist-integrate</span> f mid b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">13</span>:     <span class="token number">14</span>:     <span class="token comment" spellcheck="true">;;; integrate function `f' in a range of `a' and `b' within error `eps'</span><span class="token number">15</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">integrate</span> f a b eps<span class="token punctuation">)</span><span class="token number">16</span>:       <span class="token punctuation">(</span><span class="token function">lazylist->answer</span> <span class="token punctuation">(</span><span class="token function">super</span> <span class="token punctuation">(</span><span class="token function">lazylist-integrate</span> f a b<span class="token punctuation">)</span><span class="token punctuation">)</span> eps<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> pi <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">4</span> <span class="token punctuation">(</span><span class="token function">atan</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: pi</span><span class="token punctuation">(</span><span class="token function">integrate</span> sin <span class="token number">0</span> pi <span class="token number">0.0000001</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 2.000000002272428</span><span class="token punctuation">(</span><span class="token function">integrate</span> exp <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0.0000001</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 1.7182818277724858</span><span class="token punctuation">(</span><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token function">exp</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 1.718281828459045</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>惰性求值允许我们以简洁的方式将重复包含在数据结构中。这个功能有利于程序的模块化，可使代码更为紧凑。</p><p>查看网页<a href="http://www.haskell.org/haskellwiki/Haskell">Haskell</a>可以了解更多关于惰性求值的内容。</p><p>你可以在<a href="http://www.shido.info/lisp/scheme_lazy.zip">这儿</a>下载本页中出现代码。</p><h2 id="非确定性"><a href="#非确定性" class="headerlink" title="非确定性"></a>非确定性</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>非确定性是一种通过仅定义问题来解决问题的算法。非确定性程序自动选择符合条件的选项。这项技术很适合逻辑编程。</p><p>例如，以下代码返回一对数，其和是一个质数。其中一个数从<code>&#39;(4 6 7)</code>选取，另一个从<code>&#39;(5 8 11)</code>选取。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token punctuation">(</span><span class="token function">amb</span> <span class="token number">4</span> <span class="token number">6</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token function">j</span> <span class="token punctuation">(</span><span class="token function">amb</span> <span class="token number">5</span> <span class="token number">8</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">prime?</span> <span class="token punctuation">(</span><span class="token operator">+</span> i j<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token builtin">list</span> i j<span class="token punctuation">)</span>      <span class="token punctuation">(</span>amb<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 23: (6 5)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>(amb 4 6 7)</code> 从4，6和7中返回一个合适的数，<code>(amb 5 8 11)</code>从5，8和11中返回一个合适的数。如果没有选出合适的值，(amb)返回假。</p><p>实际上，amb做了深度优先搜索。<code>(amb c1 c2 c3 ...)</code>创建了搜索路径依次检查<code>c1</code>，<code>c2</code>，<code>c3</code>，…并回溯。因此，非确定性是一种帮程序隐藏搜索的抽象。一旦我们有了amb，我们可以很容易地编写程序而无需思考计算机做了什么。</p><h3 id="非确定性的实现"><a href="#非确定性的实现" class="headerlink" title="非确定性的实现"></a>非确定性的实现</h3><p>使用在非确定性中的回溯被实现为连接到继续（continuation）的闭包链。这个链被一个全局参数<code>fail</code>表示，该参数是一个复写自己的函数。</p><h4 id="函数实现"><a href="#函数实现" class="headerlink" title="函数实现"></a>函数实现</h4><p>第一步，我使用函数（名为<code>choose</code>）实现非确定性，演示于[代码1]。我首先定义一个全局参数<code>fail</code>，它的初始值是一个将返回<code>no-choice</code>到顶层的函数（22-26行）。然后通过在函数choose中重新定义<code>fail</code>实现闭包链。回溯通过调用之前的<code>fail</code>实现。</p><p>函数<code>choose</code>有如下行为：</p><ol><li>如果没有选项，调用(fail)。</li><li>如果有任何选项，<ol><li>将fail储存为fail0，并调用当前继续（continuation）。</li><li>在继续（continuation）中重新定义fail。fail重新被赋值回存在fail0里的原值，并对余下的选项应用（apply）choose。</li><li>返回第一个选项到继续（continuation）外面。</li></ol></li></ol><p>[代码1]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token comment" spellcheck="true">;;; abbreviation for call-with-current-continuation</span><span class="token punctuation">(</span><span class="token keyword">define</span> call/cc call-with-current-continuation<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;;; This function is re-assigned in `choose` and `fail` itself.</span><span class="token punctuation">(</span><span class="token keyword">define</span> fail <span class="token boolean">#f</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;;; function for nondeterminism</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">choose</span> . ls<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">null?</span> ls<span class="token punctuation">)</span>     <span class="token punctuation">(</span>fail<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">fail0</span> fail<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token builtin">call/cc</span>        <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>cc<span class="token punctuation">)</span>          <span class="token punctuation">(</span><span class="token keyword">set!</span> fail <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>                       <span class="token punctuation">(</span><span class="token keyword">set!</span> fail fail0<span class="token punctuation">)</span>                       <span class="token punctuation">(</span><span class="token function">cc</span> <span class="token punctuation">(</span><span class="token builtin">apply</span> choose <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token punctuation">(</span><span class="token function">cc</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;;; write following at the end of file</span><span class="token comment" spellcheck="true">;;; initial value for fail</span><span class="token punctuation">(</span><span class="token builtin">call/cc</span>   <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>cc<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">set!</span> fail <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>                 <span class="token punctuation">(</span><span class="token function">cc</span> <span class="token string">'no-choice)))))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>让我们看看<code>choose</code>是否可以找到毕达哥拉斯三元组。函数<code>pythag</code>用于寻找三元组。如果找到了，它返回一个表。如果没有找到，调用无参数的<code>choose</code>，以回溯。</p><p>[例1]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">sq</span> x<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token operator">*</span> x x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: sq</span><span class="token comment" spellcheck="true">;;; Pythagorean triples</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">pythag</span> a b c<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token punctuation">(</span><span class="token function">sq</span> a<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">sq</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">sq</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token builtin">list</span> a b c<span class="token punctuation">)</span>      <span class="token punctuation">(</span>choose<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: pythag</span><span class="token punctuation">(</span><span class="token function">pythag</span> <span class="token punctuation">(</span><span class="token function">choose</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">choose</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">choose</span>  <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 16: (3 4 5)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="宏实现"><a href="#宏实现" class="headerlink" title="宏实现"></a>宏实现</h4><p>为了对S-表达式使用非确定性操作，必须把操作定义为宏。例如，[例2]中所示函数<code>an-integer-starting-from</code>应该返回一个大于或等于<code>n</code>的整数，但是如果<code>choose</code>被以函数形式定义，它将不能正常工作，因为参数会立即求值。</p><p>[例2]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">an-integer-starting-from</span> n<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">choose</span> n <span class="token punctuation">(</span><span class="token function">an-integer-starting-from</span> <span class="token punctuation">(</span><span class="token function">1+</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: an-integer-starting-from</span><span class="token punctuation">(</span><span class="token function">an-integer-starting-from</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Aborting!: maximum recursion depth exceeded</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了解决这一点，我们定义了一个和[代码1]中定义一致但使用非确定性宏<code>amb</code>实现的<code>choose</code>。这个宏<code>amb</code>有和<code>choose</code>一样的递归调用自己的结构。</p><p>[代码1]中的1-5行和20-26行在下面的代码中得以重用。</p><p>[代码2]使用MIT-Scheme编译时，编译器给出如下警告：</p><pre><code>;Warning: Possible inapplicable operator ()</code></pre><p>但是代码可以正常工作。这些代码在<a href="http://www.scheme.com/petitechezscheme.html">Petite Chez Scheme</a>下也可以运行。即使我没有试过其他Scheme实现，我认为<code>amb</code>的定义可以工作，只要它们遵守R5RS。你可以在<a href="http://www.shido.info/lisp/scheme_amb.zip">这里</a>下载一个为MIT-Scheme做的专门实现。MIT-Scheme编译器不会对这个专门实现提出警告。</p><p>[代码2]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token comment" spellcheck="true">;;; nondeterminism macro operator</span><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> amb  <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token punctuation">(</span>fail<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> a<span class="token punctuation">)</span> a<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> a b ...<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">fail0</span> fail<span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token builtin">call/cc</span>    <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>cc<span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token keyword">set!</span> fail        <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token punctuation">(</span><span class="token keyword">set!</span> fail fail0<span class="token punctuation">)</span>          <span class="token punctuation">(</span><span class="token function">cc</span> <span class="token punctuation">(</span><span class="token function">amb</span> b ...<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token function">cc</span> a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>宏定义，<code>amb</code>，在参数为S-表达式时也和其他值一样正常工作。</p><p>[例3]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">an-integer-starting-from</span> n<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">amb</span> n <span class="token punctuation">(</span><span class="token function">an-integer-starting-from</span> <span class="token punctuation">(</span><span class="token function">1+</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: an-integer-starting-from</span><span class="token punctuation">(</span><span class="token function">an-integer-starting-from</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 1</span><span class="token punctuation">(</span>amb<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 2</span><span class="token punctuation">(</span>amb<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<a href="http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme-Z-H-16.html#node_sec_14.2">Teach Yourself Scheme in Fixnum Days</a> 和<a href="http://www.ccs.neu.edu/home/dherman/code/amb.ss">Dave Hername Code</a>中的amb实现使用<code>&#39;,@(map ...)&#39;</code>展开参数。即使它们是直截了当的定义，但由于使用了两次<code>call/cc</code>，它们某种程度上仍很复杂。[代码2]所示的递归定义更简单，即使展开的S-表达式会很复杂。</p><h4 id="应用于逻辑编程，使程序更简洁"><a href="#应用于逻辑编程，使程序更简洁" class="headerlink" title="应用于逻辑编程，使程序更简洁"></a>应用于逻辑编程，使程序更简洁</h4><p>[代码3]演示了非确定性应用逻辑编程，使得程序更简洁</p><p>[代码3]</p><pre class="line-numbers language-scheme"><code class="language-scheme">01:     <span class="token comment" spellcheck="true">;;; returning all possibilities</span><span class="token number">02</span>:     <span class="token punctuation">(</span><span class="token keyword">define-syntax</span> set-of<span class="token number">03</span>:       <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token number">04</span>:         <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> s<span class="token punctuation">)</span> <span class="token number">05</span>:           <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">acc</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">06</span>:             <span class="token punctuation">(</span><span class="token function">amb</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">v</span> s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">07</span>:                    <span class="token punctuation">(</span><span class="token keyword">set!</span> acc <span class="token punctuation">(</span><span class="token builtin">cons</span> v acc<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">08</span>:                    <span class="token punctuation">(</span>fail<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">09</span>:                  <span class="token punctuation">(</span><span class="token function">reverse!</span> acc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">10</span>:     <span class="token number">11</span>:     <span class="token comment" spellcheck="true">;;; if not pred backtrack</span><span class="token number">12</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">assert</span> pred<span class="token punctuation">)</span><span class="token number">13</span>:       <span class="token punctuation">(</span><span class="token function">or</span> pred <span class="token punctuation">(</span>amb<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">14</span>:     <span class="token number">15</span>:     <span class="token comment" spellcheck="true">;;; returns arbitrary number larger or equal to n</span><span class="token number">16</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">an-integer-starting-from</span> n<span class="token punctuation">)</span><span class="token number">17</span>:       <span class="token punctuation">(</span><span class="token function">amb</span> n <span class="token punctuation">(</span><span class="token function">an-integer-starting-from</span> <span class="token punctuation">(</span><span class="token function">1+</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">18</span>:     <span class="token number">19</span>:     <span class="token comment" spellcheck="true">;;; returns arbitrary number between a and b</span><span class="token number">20</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">number-between</span> a b<span class="token punctuation">)</span><span class="token number">21</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">22</span>:         <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">></span> i b<span class="token punctuation">)</span><span class="token number">23</span>:             <span class="token punctuation">(</span>amb<span class="token punctuation">)</span><span class="token number">24</span>:           <span class="token punctuation">(</span><span class="token function">amb</span> i <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token function">1+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(set-of <code>s</code>)</strong></p><p>返回满足<code>s</code>的所有可能性。宏的行为如下：</p><ol><li>（第5行）一个表（acc）被定义，它有所欲哦满足<code>s</code>的结果。</li><li>（第6行）<code>s</code>的结果被赋给<code>v</code>，并加入到<code>acc</code>。如果结果没有带上<code>v</code>而直接被加入（如 (set! acc (cons s acc))），则会因为<code>s</code>使用了继续（continuation）而只在acc中存储了最后一个值。<code>s</code>改了了fail的值。</li><li>（第7，8行）在这之后，调用fail回溯。因为使用了继续（continuation），函数fail行为就像在第6行被调用。</li><li>（第9行）当所有可能的选项被找到时，调用<code>(reverse! acc)</code>并返回所有的可能选项。</li></ol><p>定义假设amb从最左边参数开始搜索。</p><p><strong>(assert <code>pred</code>)</strong></p><p>如果谓词为假,就回溯。</p><p><strong>(an-integer-starting-from <code>n</code>)</strong></p><p>非确定性地返回从<code>n</code>开始的整数。</p><p><strong>(number-between <code>a</code> <code>b</code>)</strong></p><p>非确定性地返回<code>a</code>和<code>b</code>之间的整数</p><p>[例4]演示了如何使用<code>set-of</code>。得到了所有小于20的质数。</p><p>[例4]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">prime?</span> n<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">m</span> <span class="token punctuation">(</span><span class="token function">sqrt</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token function">or</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> m i<span class="token punctuation">)</span>          <span class="token punctuation">(</span><span class="token function">and</span> <span class="token punctuation">(</span><span class="token function">not</span> <span class="token punctuation">(</span><span class="token function">zero?</span> <span class="token punctuation">(</span><span class="token function">modulo</span> n i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>               <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token operator">+</span> i <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> i <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">gen-prime</span> n<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token punctuation">(</span><span class="token function">number-between</span>  <span class="token number">2</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">prime?</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span>    i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">set-of</span> <span class="token punctuation">(</span><span class="token function">gen-prime</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 12: (2 3 5 7 11 13 17 19)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="逻辑编程的例子"><a href="#逻辑编程的例子" class="headerlink" title="逻辑编程的例子"></a>逻辑编程的例子</h3><p>让我们来解决<a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_sec_4.3.2">SICP中的习题4.42</a>作为例子。问题如下：</p><p>五位女同学参加一场考试。她们的家长对考试结果过分关心。为此她们约定，在给家里写信谈到考试时，每个姑娘都要写一句真话和一句假话。下面是从她们的信中摘出的句子：</p><p>贝蒂：“凯迪考第二，我只考了第三。” 艾赛尔：“你们应该高兴地听到我考了第一，琼第二。” 琼：“我考第三，可怜的艾赛尔考得最差。” 凯蒂：“我第二，玛丽只考了第四。” 玛丽：“我是第四，贝蒂的成绩最高。”</p><p>这五位姑娘的实际排名是什么？</p><p>[代码4]给出了这个问题的解法。</p><p>[代码4]</p><pre class="line-numbers language-scheme"><code class="language-scheme">01:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">xor</span> a b<span class="token punctuation">)</span><span class="token number">02</span>:       <span class="token punctuation">(</span><span class="token keyword">if</span> a <span class="token punctuation">(</span><span class="token function">not</span> b<span class="token punctuation">)</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">03</span>:     <span class="token number">04</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">all-different?</span> . ls<span class="token punctuation">)</span><span class="token number">05</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">obj</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">ls</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">06</span>:         <span class="token punctuation">(</span><span class="token function">or</span> <span class="token punctuation">(</span><span class="token builtin">null?</span> ls<span class="token punctuation">)</span><span class="token number">07</span>:             <span class="token punctuation">(</span><span class="token function">and</span> <span class="token punctuation">(</span><span class="token function">not</span> <span class="token punctuation">(</span><span class="token function">memv</span> obj ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">08</span>:                  <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">09</span>:     <span class="token number">10</span>:     <span class="token comment" spellcheck="true">;;; SICP Exercise 4.42</span><span class="token number">11</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>girls-exam<span class="token punctuation">)</span><span class="token number">12</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">kitty</span> <span class="token punctuation">(</span><span class="token function">number-between</span> <span class="token number">1</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">13</span>:             <span class="token punctuation">(</span><span class="token function">betty</span> <span class="token punctuation">(</span><span class="token function">number-between</span> <span class="token number">1</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">14</span>:         <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">xor</span> <span class="token punctuation">(</span><span class="token operator">=</span> kitty <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">=</span> betty <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">15</span>:         <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">mary</span> <span class="token punctuation">(</span><span class="token function">number-between</span> <span class="token number">1</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">16</span>:           <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">xor</span> <span class="token punctuation">(</span><span class="token operator">=</span> kitty <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">=</span> mary <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">17</span>:           <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">xor</span> <span class="token punctuation">(</span><span class="token operator">=</span> mary <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">=</span> betty <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">18</span>:           <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">ethel</span> <span class="token punctuation">(</span><span class="token function">number-between</span> <span class="token number">1</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">19</span>:                 <span class="token punctuation">(</span><span class="token function">joan</span> <span class="token punctuation">(</span><span class="token function">number-between</span> <span class="token number">1</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">20</span>:             <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">xor</span> <span class="token punctuation">(</span><span class="token operator">=</span> ethel <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">=</span> joan <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">21</span>:             <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">xor</span> <span class="token punctuation">(</span><span class="token operator">=</span> joan <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">=</span> ethel <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">22</span>:             <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">all-different?</span> kitty betty ethel joan mary<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">23</span>:             <span class="token punctuation">(</span><span class="token function">map</span> list <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">kitty</span> betty ethel joan mary<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">list</span> kitty betty ethel joan mary<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">24</span>:     <span class="token number">25</span>:     <span class="token comment" spellcheck="true">;;; Bad answer for ex 4.42</span><span class="token number">26</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>girls-exam-x<span class="token punctuation">)</span><span class="token number">27</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">kitty</span> <span class="token punctuation">(</span><span class="token function">number-between</span> <span class="token number">1</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">28</span>:             <span class="token punctuation">(</span><span class="token function">betty</span> <span class="token punctuation">(</span><span class="token function">number-between</span> <span class="token number">1</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">29</span>:             <span class="token punctuation">(</span><span class="token function">mary</span> <span class="token punctuation">(</span><span class="token function">number-between</span> <span class="token number">1</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">30</span>:             <span class="token punctuation">(</span><span class="token function">ethel</span> <span class="token punctuation">(</span><span class="token function">number-between</span> <span class="token number">1</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">31</span>:             <span class="token punctuation">(</span><span class="token function">joan</span> <span class="token punctuation">(</span><span class="token function">number-between</span> <span class="token number">1</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">32</span>:         <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">xor</span> <span class="token punctuation">(</span><span class="token operator">=</span> kitty <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">=</span> betty <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">33</span>:         <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">xor</span> <span class="token punctuation">(</span><span class="token operator">=</span> kitty <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">=</span> mary <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">34</span>:         <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">xor</span> <span class="token punctuation">(</span><span class="token operator">=</span> mary <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">=</span> betty <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">35</span>:         <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">xor</span> <span class="token punctuation">(</span><span class="token operator">=</span> ethel <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">=</span> joan <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">36</span>:         <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">xor</span> <span class="token punctuation">(</span><span class="token operator">=</span> joan <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">=</span> ethel <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">37</span>:         <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">all-different?</span> kitty betty ethel joan mary<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">38</span>:         <span class="token punctuation">(</span><span class="token function">map</span> list <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">kitty</span> betty ethel joan mary<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">list</span> kitty betty ethel joan mary<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(xor a b)</strong>以下条件满足，返回#t:</p><ul><li>a是#t，b是#f，或者</li><li>a是#f，b是#t。</li></ul><p><strong>(all-different? , ls)</strong></p><p>当<code>ls</code>的所有元素都不相同时，返回#t。</p><p><strong>(girls-exam)</strong></p><p>是解决谜题的主要函数。它返回名字和排名的表。每次参数赋值后都调用了<code>assert</code>是为了有效地减少死分支的运行时间。<code>(girls-exam-x)</code>则是一个坏例子。它在为所有参数赋值之后调用<code>assert</code>。这种情况下，无谓地搜索了大量的死分支。[例5]显示<code>(girl-exam-x)</code>的运行时间是<code>(girl-exam)</code>的10倍。</p><p>[例5]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> cpu-time/sec  <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> s<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token function">with-timings</span>     <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> s<span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token function">run-time</span> gc-time real-time<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token function">write</span> <span class="token punctuation">(</span><span class="token function">internal-time/ticks->seconds</span> run-time<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token function">write-char</span> #\space<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token function">write</span> <span class="token punctuation">(</span><span class="token function">internal-time/ticks->seconds</span> gc-time<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token function">write-char</span> #\space<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token function">write</span> <span class="token punctuation">(</span><span class="token function">internal-time/ticks->seconds</span> real-time<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">(</span>newline<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: cpu-time/sec</span><span class="token punctuation">(</span><span class="token function">cpu-time/sec</span> <span class="token punctuation">(</span>girls-exam<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">.03</span> <span class="token number">0</span>. <span class="token number">.03</span><span class="token comment" spellcheck="true">;Value 14: ((kitty 1) (betty 3) (ethel 5) (joan 2) (mary 4))</span><span class="token punctuation">(</span><span class="token function">cpu-time/sec</span> <span class="token punctuation">(</span>girls-exam-x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">.341</span> <span class="token number">.29</span> <span class="token number">.631</span><span class="token comment" spellcheck="true">;Value 15: ((kitty 1) (betty 3) (ethel 5) (joan 2) (mary 4))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>当你使用了非确定性和用于逻辑编程分析技术时，你就可以写出看起来具有先见之明的程序。注意如果搜索路径里有循环我们就不能使用本章的代码。关于这一点，查看<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_sec_4.3">SICP 4.3</a>以获取更多信息。</p><p>写这一章时，我参考了<a href="http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme-Z-H-16.html">Teach Yourself Scheme in Fixnum Days</a>。</p><p>你可以在<a href="http://www.shido.info/lisp/scheme_amb.zip">这儿</a>下载本章代码。</p>]]></content>
      
      
      <categories>
          
          <category> SICP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UESTC </tag>
            
            <tag> Scheme </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-ast入门</title>
      <link href="posts/14266/"/>
      <url>posts/14266/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>进入大三下，由于学校课程的安排，本学期安排了编译原理的内容，说是编译原理，其实从实验安排上看更像是教你做一个语法树和词法分析器. 本文就记录一下相关的学习过程，也算是一个督促学习的手段. 本篇文章为阅读go-ast-book过程中一起做的笔记(<del>虽然更像复制粘贴就是了</del> .</p><h2 id="第一章-Token"><a href="#第一章-Token" class="headerlink" title="第一章 Token"></a>第一章 Token</h2><p>词法分析一般是编译器的第一部分,而且词法分析很简单,就是一个有限状态机. 开始词法分析的过程就是把源文件转换成一组预先定义好的Token的过程.</p><p><strong>Token是编程语言中最小的具有独立含义的词法单元。</strong> Token不仅包括了核心的关键字，还包括了标识符，运算符，分隔符（如果有的话），以及注释等等，也就是说Token就是我们能操作的最小单元，其中每个Token又称为词法单元，对应的有三个重要的属性.</p><ul><li>Token本身的值表示词法单元的类型</li><li>Token在源代码中的源代码文本形式</li><li>Token出现的位置</li></ul><p>在所有Token中，注释和分号是两种比较特殊的Token，前一种不影响程序的语义（大部分情况下，像JAVA的标签除外），而后一种一般作为分隔符，在GO中分号是可加可不加的，因为GO语言会在行尾自动添加分号的Token，分号的最大作用是分割语句的词法单元，因此自动添加分号导致GO语言做优化括弧不能单独成一行。下来咱们学习如何进行Token的分析.</p><h3 id="1-1-Token语法"><a href="#1-1-Token语法" class="headerlink" title="1.1 Token语法"></a>1.1 Token语法</h3><p>GO语法中主要有<code>标识符</code>，<code>关键字</code>，<code>运算符</code>,<code>分隔符</code>等Token组成. 其中标识符的语法定义如下:</p><pre><code>identifier = letter { letter | unicode_digit } .letter     = unicode_letter | &quot;_&quot; .</code></pre><p><code>identifier</code> 由字母和数字组成, 其中开头第一个字符必须是字母而不是数字, 注意在我们定义的<code>letter</code> 中, <code>__</code> 也作为字母的一员. 在<code>标识符</code> 中, 有一类特殊的标识符被提出来单独定义, 他们就是<code>关键字</code> , <code>关键字</code>用来引导特殊的语法结构, 因此关键字是作为独立的<code>标识符</code>.GO中有25个<code>关键字</code>. </p><pre class="line-numbers language-go"><code class="language-go"><span class="token operator">></span> <span class="token keyword">break</span>        <span class="token keyword">default</span>      <span class="token keyword">func</span>         <span class="token keyword">interface</span>    <span class="token keyword">select</span><span class="token operator">></span> <span class="token keyword">case</span>         <span class="token keyword">defer</span>        <span class="token keyword">go</span>           <span class="token keyword">map</span>          <span class="token keyword">struct</span><span class="token operator">></span> <span class="token keyword">chan</span>         <span class="token keyword">else</span>         <span class="token keyword">goto</span>         <span class="token keyword">package</span>      <span class="token keyword">switch</span><span class="token operator">></span> <span class="token keyword">const</span>        <span class="token keyword">fallthrough</span>  <span class="token keyword">if</span>           <span class="token keyword">range</span>        <span class="token keyword">type</span><span class="token operator">></span> <span class="token keyword">continue</span>     <span class="token keyword">for</span>          <span class="token keyword">import</span>       <span class="token keyword">return</span>       <span class="token keyword">var</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后是GO定义的47个符号:</p><pre class="line-numbers language-go"><code class="language-go"><span class="token operator">+</span>    <span class="token operator">&amp;</span>     <span class="token operator">+=</span>    <span class="token operator">&amp;=</span>     <span class="token operator">&amp;&amp;</span>    <span class="token operator">==</span>    <span class="token operator">!=</span>    <span class="token punctuation">(</span>    <span class="token punctuation">)</span><span class="token operator">-</span>    <span class="token operator">|</span>     <span class="token operator">-=</span>    <span class="token operator">|=</span>     <span class="token operator">||</span>    <span class="token operator">&lt;</span>     <span class="token operator">&lt;=</span>    <span class="token punctuation">[</span>    <span class="token punctuation">]</span><span class="token operator">*</span>    <span class="token operator">^</span>     <span class="token operator">*=</span>    <span class="token operator">^=</span>     <span class="token operator">&lt;-</span>    <span class="token operator">></span>     <span class="token operator">>=</span>    <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token operator">/</span>    <span class="token operator">&lt;&lt;</span>    <span class="token operator">/=</span>    <span class="token operator">&lt;&lt;=</span>    <span class="token operator">++</span>    <span class="token operator">=</span>     <span class="token operator">:=</span>    <span class="token punctuation">,</span>    <span class="token punctuation">;</span><span class="token operator">%</span>    <span class="token operator">>></span>    <span class="token operator">%=</span>    <span class="token operator">>>=</span>    <span class="token operator">--</span>    <span class="token operator">!</span>     <span class="token operator">...</span>   <span class="token punctuation">.</span>    <span class="token punctuation">:</span>     <span class="token operator">&amp;^</span>          <span class="token operator">&amp;^=</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了以上提到的, 程序中还有一些注释, 和空白符, 想要解析一个GO语言程序,第一步就需要解析这些Token.</p><h3 id="1-2-Token的定义"><a href="#1-2-Token的定义" class="headerlink" title="1.2 Token的定义"></a>1.2 Token的定义</h3><p><code>go/token</code>包中,Token被定义为一种枚举值,不同值的Token表示不同类型的词法记号:</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// Token is the set of lexical tokens of the Go programming language.</span><span class="token keyword">type</span> Token <span class="token builtin">int</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>所有的Token可以被分为四类:</p><ul><li>特殊类型的Token</li><li>基础面值对应的Token</li><li>运算符Token</li><li>关键字</li></ul><p><img src="/posts/14266/ch1-token-01.png" alt></p><p>而特殊类型的Token平时最常接触到的为注释,剩余两种为错误、文件注释:</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// The list of tokens.</span><span class="token keyword">const</span> <span class="token punctuation">(</span>    <span class="token comment" spellcheck="true">// Special tokens</span>    ILLEGAL Token <span class="token operator">=</span> <span class="token boolean">iota</span>    EOF    COMMENT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>遇到不能识别的Token统一返回ILLEGAL，这样可以简化词法分析时的错误处理。</p><p>基础面值对应的Token类型有: Go语言规范定义的基础面值主要有整数、浮点数和复数面值类型，此外还有字符和字符串面值类型。需要注意的是，在Go语言规范中布尔类型的true和false并不在基础面值之类。但是为了方便词法解析，<code>go/token</code>包将true和false等对应的标识符也作为面值Token一类。</p><p>Go语言的关键字刚好对应25个关键字类型的Token：</p><pre class="line-numbers language-go"><code class="language-go">    keyword_beg    <span class="token comment" spellcheck="true">// Keywords</span>    BREAK    CASE    CHAN    CONST    CONTINUE    DEFAULT    DEFER    ELSE    FALLTHROUGH    FOR    FUNC    GO    GOTO    IF    IMPORT    INTERFACE    MAP    PACKAGE    RANGE    RETURN    SELECT    STRUCT    SWITCH    TYPE    VAR    keyword_end<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从词法分析角度看，关键字和普通的标识符并无差别。但是25个关键字一般都是不同语法结构的开头Token，通过将这些特殊的Token定义为关键字可以简化语法解析的工作。</p><p>Token对于编程语言而言就像26个字母对于英文一样重要，它是组成更复杂的逻辑代码的基础单元，因此我们需要熟悉Token的特性和分类。</p><h3 id="1-3-FileSet和File"><a href="#1-3-FileSet和File" class="headerlink" title="1.3 FileSet和File"></a>1.3 FileSet和File</h3><p>了解完Token后，就可以最原始的词法分析了。需要注意的是，词法分析是一个很基础的内容，需要耐心设计接口的部分。参考Go语言本身，它是由多个文件组成包，然后多个包链接为一个可执行文件，所以单个包对应的多个文件可以看作是Go语言的基本编译单元。因此<code>go/token</code>包还定义了FileSet和File对象，用于描述文件集和文件。</p><p>FileSet和File对象的对应关系如图所示：</p><p><img src="/posts/14266/ch1-file-set-01.ditaa.png" alt></p><p>每个FileSet表示一个文件集合，底层抽象为一个一维数组，而Pos类型表示数组的下标位置。FileSet中的每个File元素对应底层数组的一个区间，不同的File之间没有交集，相邻的File之间可能存在填充空间。</p><p>而每个File主要由文件名、base和size三个信息组成。其中base对应File在FileSet中的Pos索引位置，因此base和base+size定义了File在FileSet数组中的开始和结束位置。在每个File内部可以通过offset定位下标索引，通过offset+File.base可以将File内部的offset转换为Pos位置。因为Pos是FileSet的全局偏移量，反之也可以通过Pos查询对应的File，以及对应File内部的offset。</p><p>而词法分析的每个Token位置信息就是由Pos定义，通过Pos和对应的FileSet可以轻松查询到对应的File。然后在通过File对应的源文件和offset计算出对应的行号和列号（实现中File只是保存了每行的开始位置，并没有包含原始的源代码数据）。Pos底层是int类型，它和指针的语义类似，因此0也类似空指针被定义为NoPos，表示无效的Pos。</p><h3 id="1-4-解析Token"><a href="#1-4-解析Token" class="headerlink" title="1.4 解析Token"></a>1.4 解析Token</h3><p>Go语言标准库<code>go/scanner</code>包提供了Scanner实现Token扫描，它是在FileSet和File抽象文件集合基础上进行词法分析。</p><p>scanner.Scanner的公开接口定义如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Scanner <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// public state - ok to modify</span>    ErrorCount <span class="token builtin">int</span> <span class="token comment" spellcheck="true">// number of errors encountered</span>    <span class="token comment" spellcheck="true">// Has unexported fields.</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>Scanner<span class="token punctuation">)</span> <span class="token function">Init</span><span class="token punctuation">(</span>    file <span class="token operator">*</span>token<span class="token punctuation">.</span>File<span class="token punctuation">,</span> src <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span>    err ErrorHandler<span class="token punctuation">,</span> mode Mode<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>Scanner<span class="token punctuation">)</span> <span class="token function">Scan</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>    pos token<span class="token punctuation">.</span>Pos<span class="token punctuation">,</span> tok token<span class="token punctuation">.</span>Token<span class="token punctuation">,</span> lit <span class="token builtin">string</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Init方法用于初始化扫描器，其中file参数表示当前的文件（不包含代码数据），src参数表示要分析的代码，err是用户自定义的错误处理函数，mode可以控制是否扫描注释部分。</p><p>Scan方法扫描一个Token，三个返回值分别表示Token的位置 、Token值和Token的源代码文本表示。</p><p>要构造一个最简单的词法扫描器测试程序，首先要构造Init方法第一参数需要的File对象。但是File对象没有公开的构造函数，只能通过FileSet的AddFile方法间接构造File对象。</p><p>下面是一个简单的词法分析程序：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"go/scanner"</span>    <span class="token string">"go/token"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> src <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">`println("你好，世界")`</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> fset <span class="token operator">=</span> token<span class="token punctuation">.</span><span class="token function">NewFileSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> file <span class="token operator">=</span> fset<span class="token punctuation">.</span><span class="token function">AddFile</span><span class="token punctuation">(</span><span class="token string">"hello.go"</span><span class="token punctuation">,</span> fset<span class="token punctuation">.</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> s scanner<span class="token punctuation">.</span>Scanner    s<span class="token punctuation">.</span><span class="token function">Init</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> src<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> scanner<span class="token punctuation">.</span>ScanComments<span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token punctuation">{</span>        pos<span class="token punctuation">,</span> tok<span class="token punctuation">,</span> lit <span class="token operator">:=</span> s<span class="token punctuation">.</span><span class="token function">Scan</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> tok <span class="token operator">==</span> token<span class="token punctuation">.</span>EOF <span class="token punctuation">{</span>            <span class="token keyword">break</span>        <span class="token punctuation">}</span>        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s\t%s\t%q\n"</span><span class="token punctuation">,</span> fset<span class="token punctuation">.</span><span class="token function">Position</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">,</span> tok<span class="token punctuation">,</span> lit<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>是不是发现非常简单，GO语言的接口一直以简洁和高效出名。回到代码分析上，src是要分析的代码，通过<code>token.NewFileSet()</code>创建一个文件集，Token的位置信息必须通过文件集定位，并且需要通过文件集创建扫描器的Init方法需要的File参数。</p><p><code>fset.AddFile</code>方法调用向fset文件集添加一个新的文件，文件名为“hello.go”，文件的长度就是src要分析代码的长度。</p><p>然后创建scanner.Scanner对象，并且调用Init方法初始化扫描器。Init的第一个参数就是刚刚添加到fset的文件对象，第二个参数是要分析的代码，第三个nil参数表示没有自定义的错误处理函数，最后的scanner.ScanComments参数表示不用忽略注释Token。</p><p>因为要解析的代码中有多个Token，因此我们在一个for循环调用<code>s.Scan()</code>依次解析新的Token。如果返回的是token.EOF表示扫描到了文件末尾，否则打印扫描返回的结果。打印前，我们需要将扫描器返回的pos参数转换为更详细的带文件名和行列号的位置信息，可以通过<code>fset.Position(pos)</code>方法完成。</p><p>以上程序运行的输出如下：</p><pre><code>hello.go:1:1    IDENT   &quot;println&quot;hello.go:1:8    (       &quot;&quot;hello.go:1:9    STRING  &quot;\&quot;你好，世界\&quot;&quot;hello.go:1:26   )       &quot;&quot;hello.go:1:27   ;       &quot;\n&quot;</code></pre><p>输出结果的第一列表示Token所在的文件和行列号，中间一列表示Token的值，最后一列表示Token对应的面值。</p><h3 id="1-5-Position位置信息"><a href="#1-5-Position位置信息" class="headerlink" title="1.5 Position位置信息"></a>1.5 Position位置信息</h3><p><code>go/token</code>包的Position表示更详细的位置信息，被定义为一个结构体：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Position <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Filename <span class="token builtin">string</span> <span class="token comment" spellcheck="true">// filename, if any</span>    Offset   <span class="token builtin">int</span>    <span class="token comment" spellcheck="true">// offset, starting at 0</span>    Line     <span class="token builtin">int</span>    <span class="token comment" spellcheck="true">// line number, starting at 1</span>    Column   <span class="token builtin">int</span>    <span class="token comment" spellcheck="true">// column number, starting at 1 (byte count)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Filename表示文件名，Offset对应文件内的字节偏移量（从0开始），Line和Column对应行列号（从1开始）。比较特殊的是Offset成员，它用于从文件数据定位代码，但是输出时会将偏移量转换为行列号输出。</p><p>打印位置信息时，根据文件名、行号和列号有6种组合：</p><pre><code>func main() {    a := token.Position{Filename: &quot;hello.go&quot;, Line: 1, Column: 2}    b := token.Position{Filename: &quot;hello.go&quot;, Line: 1}    c := token.Position{Filename: &quot;hello.go&quot;}    d := token.Position{Line: 1, Column: 2}    e := token.Position{Line: 1}    f := token.Position{Column: 2}    fmt.Println(a.String())    fmt.Println(b.String())    fmt.Println(c.String())    fmt.Println(d.String())    fmt.Println(e.String())    fmt.Println(f.String())}</code></pre><p>输出的格式如下：</p><pre><code>hello.go:1:2hello.go:1hello.go1:21-</code></pre><p>行号从1开始，是必须的信息，如果缺少行号则输出“-”表示无效的位置。</p><h2 id="第二章-基础面值"><a href="#第二章-基础面值" class="headerlink" title="第二章 基础面值"></a>第二章 基础面值</h2><p>面值是在程序代码中直接表示的值。比如表达式<code>x+2*y</code>的<code>2</code>就是面值，而<code>x</code>和<code>y</code>则不是面值而是标识符。Go语言规范明确定义了基础面值只有整数、浮点数、复数、符文和字符串几种类型。布尔类型的true和false并不是普通的面值，而是内置的布尔类型标识符（可能被重新定义为其它变量）。</p><h2 id="2-1-基础面值定义"><a href="#2-1-基础面值定义" class="headerlink" title="2.1 基础面值定义"></a>2.1 基础面值定义</h2><p>基础面值有整数、浮点数、复数、字符和字符串几种类型，同时标识符也作为面值类型。在<code>go/token</code>包中，基础面值也被定义为独立的Token：</p><p><img src="/posts/14266/ch2-lit-01.png" alt></p><p>其中整数型面值定义如下：</p><pre><code>int_lit        = decimal_lit | binary_lit | octal_lit | hex_lit .decimal_lit    = &quot;0&quot; | ( &quot;1&quot; … &quot;9&quot; ) [ [ &quot;_&quot; ] decimal_digits ] .binary_lit     = &quot;0&quot; ( &quot;b&quot; | &quot;B&quot; ) [ &quot;_&quot; ] binary_digits .octal_lit      = &quot;0&quot; [ &quot;o&quot; | &quot;O&quot; ] [ &quot;_&quot; ] octal_digits .hex_lit        = &quot;0&quot; ( &quot;x&quot; | &quot;X&quot; ) [ &quot;_&quot; ] hex_digits .</code></pre><p>整数型面值分为十进制面值、二进制面值、八进制面值和十六进制面值四种形式。需要注意的是整数型面值并不支持科学计数法形式，同时数字中间可以添加下划线分隔数字。</p><p>数值类型的面值中除了整数之外就是浮点数面值。浮点数面值又分为十进制浮点数和十六进制浮点数，它们的语法定义如下：</p><pre><code>float_lit         = decimal_float_lit | hex_float_lit .decimal_float_lit = decimal_digits &quot;.&quot; [ decimal_digits ] [ decimal_exponent ] |                    decimal_digits decimal_exponent |                    &quot;.&quot; decimal_digits [ decimal_exponent ] .decimal_exponent  = ( &quot;e&quot; | &quot;E&quot; ) [ &quot;+&quot; | &quot;-&quot; ] decimal_digits .hex_float_lit     = &quot;0&quot; ( &quot;x&quot; | &quot;X&quot; ) hex_mantissa hex_exponent .hex_mantissa      = [ &quot;_&quot; ] hex_digits &quot;.&quot; [ hex_digits ] |                    [ &quot;_&quot; ] hex_digits |                    &quot;.&quot; hex_digits .hex_exponent      = ( &quot;p&quot; | &quot;P&quot; ) [ &quot;+&quot; | &quot;-&quot; ] decimal_digits .</code></pre><p>其中decimal_float_lit表示十进制浮点数，又有普通十进制和科学计数法两种表示形式。而科学计数法形式的面值中不仅仅有十进制形式，还有十六进制科学计数法形式。</p><p>除了整数和浮点数之外，数值型面值还包含复数类型：</p><pre><code>imaginary_lit = (decimal_digits | int_lit | float_lit) &quot;i&quot; .</code></pre><p>复数面值的定义比较简单，它是在整数或浮点数面值增加一个<code>i</code>后缀。比如<code>0i</code>和<code>123i</code>就分别将0和123转为复数形式。</p><p>除了数值型面值之外，还有字符面值和字符串面值，它们的定义如下：</p><pre><code>rune_lit         = &quot;&#39;&quot; ( unicode_value | byte_value ) &quot;&#39;&quot; .unicode_value    = unicode_char | little_u_value | big_u_value | escaped_char .byte_value       = octal_byte_value | hex_byte_value .string_lit             = raw_string_lit | interpreted_string_lit .raw_string_lit         = &quot;`&quot; { unicode_char | newline } &quot;`&quot; .interpreted_string_lit = `&quot;` { unicode_value | byte_value } `&quot;`</code></pre><h2 id="2-2-基础面值语法树结构"><a href="#2-2-基础面值语法树结构" class="headerlink" title="2.2 基础面值语法树结构"></a>2.2 基础面值语法树结构</h2><p>Go语言的抽象语法树由<code>go/ast</code>包定义。其中<code>ast.BasicLit</code>表示一个基础类型的面值常量结构，它的定义如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> BasicLit <span class="token keyword">struct</span> <span class="token punctuation">{</span>    ValuePos token<span class="token punctuation">.</span>Pos   <span class="token comment" spellcheck="true">// literal position</span>    Kind     token<span class="token punctuation">.</span>Token <span class="token comment" spellcheck="true">// token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING</span>    Value    <span class="token builtin">string</span>      <span class="token comment" spellcheck="true">// literal string; e.g. 42, 0x7f, 3.14, 1e-9, 2.4i, 'a', '\x7f', "foo" or `\m\n\o`</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中ValuePos成员表示该词法元素开始的字节偏移量（并不包含文件名、行号和列号等信息），Kind表示面值的类型（只有数值类型、字符和字符串三类），最后的Value是表示面值的原始代码。</p><h2 id="2-3-构造面值"><a href="#2-3-构造面值" class="headerlink" title="2.3 构造面值"></a>2.3 构造面值</h2><p>在了解了基础面值的语法树结构之后，我们可以手工构造简单的基础面值。比如下面的代码构造一个整数9527的面值：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"go/ast"</span>    <span class="token string">"go/token"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> lit9527 <span class="token operator">=</span> <span class="token operator">&amp;</span>ast<span class="token punctuation">.</span>BasicLit<span class="token punctuation">{</span>        Kind<span class="token punctuation">:</span>  token<span class="token punctuation">.</span>INT<span class="token punctuation">,</span>        Value<span class="token punctuation">:</span> <span class="token string">"9527"</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>    ast<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">,</span> lit9527<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中<code>token.INT</code>表示基础面值的类型是整数，值是整数的十进制字符串表示。如果把<code>token.INT</code>改为<code>token.FLOAT</code>则变成浮点数的9527，如果改成<code>token.STRING</code>则会变成“9527”字符串面值。</p><h2 id="2-4-解析基础面值"><a href="#2-4-解析基础面值" class="headerlink" title="2.4 解析基础面值"></a>2.4 解析基础面值</h2><p>在前面的例子中，我们通过<code>ast.BasicLit</code>结构直接构造了面值。通过手工的方式直接构造<code>ast.BasicLit</code>甚至是完整的语法树都是可以的，从理论上说可以为任何Go语言程序手工构造等价的语法树结构。但是纯手工方式构造语法树毕竟太繁琐，还好Go语言的<code>go/parser</code>可以帮我们解析Go语言代码并自动构造语法树。</p><p>下面的例子是通过<code>parser.ParseExpr</code>函数从十进制的9527生成<code>ast.BasicLit</code>结构：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    expr<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> parser<span class="token punctuation">.</span><span class="token function">ParseExpr</span><span class="token punctuation">(</span><span class="token string">`9527`</span><span class="token punctuation">)</span>    ast<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">,</span> expr<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>go/parser</code>包提供了<code>parser.ParseExpr</code>函数用于简化表达式的解析。返回<code>ast.Expr</code>类型的<code>expr</code>和一个错误，<code>expr</code>表示表达式的语法树。然后通过<code>go/ast</code>包提供的<code>ast.Print</code>函数打印语法树。</p><p>输出结果如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token number">0</span>  <span class="token operator">*</span>ast<span class="token punctuation">.</span>BasicLit <span class="token punctuation">{</span><span class="token number">1</span>  <span class="token punctuation">.</span>  ValuePos<span class="token punctuation">:</span> <span class="token number">1</span><span class="token number">2</span>  <span class="token punctuation">.</span>  Kind<span class="token punctuation">:</span> INT<span class="token number">3</span>  <span class="token punctuation">.</span>  Value<span class="token punctuation">:</span> <span class="token string">"9527"</span><span class="token number">4</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以解析“9527”字符串面值：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    expr<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> parser<span class="token punctuation">.</span><span class="token function">ParseExpr</span><span class="token punctuation">(</span><span class="token string">`"9527"`</span><span class="token punctuation">)</span>    ast<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">,</span> expr<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>输出的字符串面值的原始表达文本：</p><pre><code>0  *ast.BasicLit {1  .  ValuePos: 12  .  Kind: STRING3  .  Value: &quot;\&quot;9527\&quot;&quot;4  }</code></pre><p>基础面值在语法树中是属于叶子结点的存在，在递归遍历语法树时遇到基础面值结点递归就会返回。同时，通过基础面值、指针、结构体、数组和map等其它语法结构的相互嵌套和组合就可以构造出无穷无尽的复杂类型来。</p><h2 id="2-5-标识符面值"><a href="#2-5-标识符面值" class="headerlink" title="2.5 标识符面值"></a>2.5 标识符面值</h2><p><code>go/ast</code>包同样定义了Ident结构体，表示标识符类型：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Ident <span class="token keyword">struct</span> <span class="token punctuation">{</span>    NamePos token<span class="token punctuation">.</span>Pos <span class="token comment" spellcheck="true">// identifier position</span>    Name    <span class="token builtin">string</span>    <span class="token comment" spellcheck="true">// identifier name</span>    Obj     <span class="token operator">*</span>Object   <span class="token comment" spellcheck="true">// denoted object; or nil</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>NamePos表示标识符的位置，Name是标识符的名字，Obj则表示标识符的类型获取其它的扩展信息。作为内置的标识符面值来说，我们主要关注标识符的名字即可。</p><p><code>go/ast</code>包同时提供了<code>NewIdent</code>函数用于创建简单的标识符：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ast<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">,</span> ast<span class="token punctuation">.</span><span class="token function">NewIdent</span><span class="token punctuation">(</span><span class="token string">`x`</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>输出的结果如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token number">0</span>  <span class="token operator">*</span>ast<span class="token punctuation">.</span>Ident <span class="token punctuation">{</span><span class="token number">1</span>  <span class="token punctuation">.</span>  NamePos<span class="token punctuation">:</span> <span class="token number">0</span><span class="token number">2</span>  <span class="token punctuation">.</span>  Name<span class="token punctuation">:</span> <span class="token string">"x"</span><span class="token number">3</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果是从表达式解析标识符，则会通过Obj成员描述标识符额外的信息：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    expr<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> parser<span class="token punctuation">.</span><span class="token function">ParseExpr</span><span class="token punctuation">(</span><span class="token string">`x`</span><span class="token punctuation">)</span>    ast<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">,</span> expr<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>输出表达式中x标识符信息如下：</p><pre><code>0  *ast.Ident {1  .  NamePos: 12  .  Name: &quot;x&quot;3  .  Obj: *ast.Object {4  .  .  Kind: bad5  .  .  Name: &quot;&quot;6  .  }7  }</code></pre><p><code>ast.Object</code>是一个相对复杂的结构，其中Kind用于描述标识符的类型：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">const</span> <span class="token punctuation">(</span>    Bad ObjKind <span class="token operator">=</span> <span class="token boolean">iota</span> <span class="token comment" spellcheck="true">// for error handling</span>    Pkg                <span class="token comment" spellcheck="true">// package</span>    Con                <span class="token comment" spellcheck="true">// constant</span>    Typ                <span class="token comment" spellcheck="true">// type</span>    Var                <span class="token comment" spellcheck="true">// variable</span>    Fun                <span class="token comment" spellcheck="true">// function or method</span>    Lbl                <span class="token comment" spellcheck="true">// label</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Bad表示未知的类型，其它的分别对应Go语言中包、常量、类型、变量、函数和标号等语法结构。而对于标识符中更具体的类型（比如是整数还是布尔类型）则是由<code>ast.Object</code>的其它成员描述。</p>]]></content>
      
      
      <categories>
          
          <category> UESTC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UESTC </tag>
            
            <tag> GO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机病毒原理与防范</title>
      <link href="posts/41006/"/>
      <url>posts/41006/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章-概述"></a>第一章-概述</h2><h3 id="计算机病毒的定义"><a href="#计算机病毒的定义" class="headerlink" title="计算机病毒的定义"></a>计算机病毒的定义</h3><p>编制或者在计算机程序中<strong>插入</strong>的破坏计算机功能或者毁坏数据，影响计算机使用，并能自我复制的一组计算机指令或者程序代码。</p><h3 id="计算机病毒的本质属性"><a href="#计算机病毒的本质属性" class="headerlink" title="计算机病毒的本质属性"></a>计算机病毒的本质属性</h3><p><strong>人为</strong>的特制<strong>程序</strong>是<strong>任何</strong>计算机病毒的<strong>固有本质属性</strong></p><p><strong>程序性</strong>的<strong>客观性</strong>决定了计算机病毒的可防治性和可清除性</p><p><strong>人为性</strong>的<strong>主观性</strong>导致计算机病毒各异多变</p><h4 id="基本特征-传染性"><a href="#基本特征-传染性" class="headerlink" title="基本特征-传染性"></a>基本特征-传染性</h4><p>传染性是判别一个程序是否为计算机病毒的<code>首要条件</code>,传染性也即指计算机病毒把自身复制到其他程序的能力，把自身的代码强行传染到一切符合其传染条件的程序之上</p><h4 id="基本特征-隐蔽性"><a href="#基本特征-隐蔽性" class="headerlink" title="基本特征-隐蔽性"></a>基本特征-隐蔽性</h4><p>传染过程与存在的隐蔽性，用户不知道病毒的存在</p><h4 id="基本特征-可触发性"><a href="#基本特征-可触发性" class="headerlink" title="基本特征-可触发性"></a>基本特征-可触发性</h4><p>因某个事件或数值的出现，触发病毒实施感染或攻击破坏即隐藏又保持破坏力</p><h4 id="其他特征"><a href="#其他特征" class="headerlink" title="其他特征"></a>其他特征</h4><ul><li>欺骗性：欺骗用户触发、激活病毒</li><li>非授权性：窃取系统控制权</li><li>寄生性：依附于宿主程序</li><li>衍生性：病毒变种</li><li>持久性：数据恢复困难、病毒清除困难</li><li><strong>破坏性</strong>：数据破坏、计算机功能破坏、经济损失</li><li><strong>针对性</strong>：特定软件、操作系统、硬件平台（也反映了其程序性的客观事实）</li><li><strong>不可预见性</strong>：对未知病毒的预测难度（反病毒软件预防措施和技术手段往往滞后于病毒产生速度）</li></ul><h3 id="病毒的分类"><a href="#病毒的分类" class="headerlink" title="病毒的分类"></a>病毒的分类</h3><p><img src="/posts/41006/1_1.png" alt></p><p><img src="/posts/41006/1_2.png" alt></p><h3 id="恶意程序"><a href="#恶意程序" class="headerlink" title="恶意程序"></a>恶意程序</h3><p>未经授权便干扰或破坏计算机系统/网络的程序或代码，早期恶意代码的主要形式是计算机病毒</p><h4 id="蠕虫"><a href="#蠕虫" class="headerlink" title="蠕虫"></a>蠕虫</h4><p>独立的可执行程序，不需要寄生在宿主程序中，通过网络分发自己的副本</p><p>病毒与蠕虫的区别：</p><table><thead><tr><th></th><th><strong>病    毒</strong></th><th><strong>蠕    虫</strong></th></tr></thead><tbody><tr><td><strong>存在形式</strong></td><td><strong>寄生</strong></td><td><strong>独立个体</strong></td></tr><tr><td><strong>复制机制</strong></td><td><strong>插入到宿主程序</strong>(文件)中</td><td><strong>自身的拷贝</strong></td></tr><tr><td><strong>传染机制</strong></td><td><strong>宿主程序运行</strong></td><td><strong>系统存在漏洞</strong>(Vulnerability)</td></tr><tr><td><strong>搜索机制</strong>(传染目标)</td><td>主要是针对<strong>本地文件</strong></td><td><strong>主要针对网络上的其它计算机</strong></td></tr><tr><td><strong>触发传染</strong></td><td>计算机使用者</td><td><strong>程序自身</strong></td></tr><tr><td><strong>影响重点</strong></td><td><strong>文件系统</strong></td><td><strong>网络性能、系统性能</strong></td></tr><tr><td><strong>计算机使用者角色</strong></td><td>病毒传播中的关键环节</td><td><strong>无关</strong></td></tr><tr><td><strong>防治措施</strong></td><td>从宿主程序中摘除</td><td>为系统打补丁(Patch)</td></tr></tbody></table><h3 id="特洛伊木马"><a href="#特洛伊木马" class="headerlink" title="特洛伊木马"></a>特洛伊木马</h3><p>在远程计算机之间建立连接，使得远程计算机能通过网络控制本地计算机的非法程序。</p><p>木马系统软件一般由木马配置程序、控制程序和<strong>木马程序(服务端)</strong>三部分组成，其入侵的方式与一般病毒存在区别，而且，自身一般没有传染性。</p><h3 id="计算机病毒的危害"><a href="#计算机病毒的危害" class="headerlink" title="计算机病毒的危害"></a>计算机病毒的危害</h3><ul><li><p>计算机病毒的蓄意破坏：来自于病毒制造者<strong>目的</strong>，对数据信息的<strong>直接破坏</strong></p></li><li><p>计算机病毒的偶然性破坏：<strong>自身错误</strong>与不可预见性、<strong>兼容性</strong></p></li><li><p>计算机病毒的附带性破坏：抢占资源、影响计算机运行</p></li><li><p>计算机病毒造成的心理及社会的危害：<strong>声誉损失</strong> 、商业风险、心理反应 </p></li></ul><h3 id="计算机病毒的传播途径"><a href="#计算机病毒的传播途径" class="headerlink" title="计算机病毒的传播途径"></a>计算机病毒的传播途径</h3><ul><li><p>通过不可移动的计算机<strong>硬件设备</strong>进行传播</p></li><li><p>通过<strong>移动存储设备</strong>来传播</p></li><li><p>通过<strong>有线网络系统进行传播</strong></p></li><li><p>通过<strong>无线通讯系统</strong>传播</p></li></ul><h3 id="计算机病毒的生命周期"><a href="#计算机病毒的生命周期" class="headerlink" title="计算机病毒的生命周期"></a>计算机病毒的生命周期</h3><p>计算机病毒的<strong>产生过程</strong>可分为：</p><p>程序设计→传播→潜伏→触发、运行→实施攻击</p><p>计算机病毒的<strong>生命周期</strong>：生成开始到完全根治</p><ul><li>开发期：较短、没有经过严格的测试</li><li>传染期：感染流行程序，网络共享，被动到主动</li><li>潜伏期：静态潜伏（文件拷贝）和动态潜伏（占据内存）</li><li>发作期：触发，实施破坏，取决于编写者意图和编程技术</li><li>发现期：被检测隔离，反病毒厂家，病毒通报和描述</li><li>消化期：反病毒软件，检测和发现病毒</li><li>消亡期：升级杀毒软件，杀毒</li></ul><p>计算机病毒的产生是必然的，<strong>软硬件脆弱性</strong>是根本原因，<strong>计算机普及</strong> 是必要环境。</p><h2 id="第二章-代码初始"><a href="#第二章-代码初始" class="headerlink" title="第二章-代码初始"></a>第二章-代码初始</h2><p>小端机：最低字节放在内存的最低地址，次低字节放内存的次低地址，依次存放。比如，0x12345678放在内存中就是78 56 34 12（最左边为内存低位）</p><p>大端机：0x12345678放在内存中就是12 34 56 78</p><h3 id="病毒的基本能力和执行特点"><a href="#病毒的基本能力和执行特点" class="headerlink" title="病毒的基本能力和执行特点"></a>病毒的基本能力和执行特点</h3><ul><li>执行（最为重要）</li><li>潜伏</li><li>破坏</li><li>传染</li></ul><p>执行的特点：</p><blockquote><p>病毒执行并非简单执行自己的指令，它还需要执行被感染对象正常的指令，否则无法潜伏。简单说，在正常指令执行时，需要修改执行流程获得一个执行病毒指令的能力</p></blockquote><h3 id="JMP指令解析"><a href="#JMP指令解析" class="headerlink" title="JMP指令解析"></a>JMP指令解析</h3><pre><code>地址1        Jmp offset -&gt; Offset=地址3-地址2地址2        Push eas    ...地址3        Mov xxx</code></pre><p>JMP跳转的偏移量是：<strong>目的地址-JMP的下一条指令地址</strong>，同时JMP跳转指令占1个字节，偏移量4个字节，一共5个字节</p><h2 id="第三章-文件系统"><a href="#第三章-文件系统" class="headerlink" title="第三章-文件系统"></a>第三章-文件系统</h2><h3 id="硬盘的物理结构"><a href="#硬盘的物理结构" class="headerlink" title="硬盘的物理结构"></a>硬盘的物理结构</h3><p>初级格式化的主要目的：划分成<strong>磁道、扇区和柱面</strong></p><p><strong>CHS参数</strong>：磁道/盘片/扇区</p><p><strong>INT 13H</strong>：寻址范围为8GB</p><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>文件系统就是组织文件的一种方式，文件管理包括文件生成，删除，目录查询等。下面介绍的FAT12主要用来管理软盘</p><p><img src="/posts/41006/1.png" alt></p><p>1个FAT有9个扇区，引导扇区1个扇区，根目录区有224条记录（一个记录32字节）</p><ul><li>数据区中存放用户数据,是文件和子目录数据真正存放的区域</li><li>根目录区中存放的是文件目录表,为记录根目录文件项的表，文件项包括文件，目录。通过它可以查找到根目录下的文件和目录信息，比名称，大小，日期等</li><li>FAT12为<strong>文件分配表</strong>（FAT（File Allocation Table））：记录已分配的扇区和可用扇区，并通过链表依序记录一个文件占用的扇区,另外一个FAT12为备用的FAT表</li><li><strong>引导扇区</strong>（DBR （DOS Boot Record））：记录磁盘和文件系统相关的各种参数，比如扇区大小，一簇的扇区数等</li></ul><p><strong>引导记录格式</strong></p><table><thead><tr><th>名称</th><th>偏移</th><th>长度</th><th>内容</th><th>软盘参考值</th></tr></thead><tbody><tr><td>BS_jmpBoot</td><td>0</td><td>3</td><td></td><td>jmp LABEL_START  nop</td></tr><tr><td>BS_OEMName</td><td>3</td><td>8</td><td>厂商名</td><td>‘ForrestY’</td></tr><tr><td>BPB_BytsPerSec</td><td>11</td><td>2</td><td>每扇区字节数</td><td>0x200（即十进制512）</td></tr><tr><td>BPB_SecPerClus</td><td>13</td><td>1</td><td>每<a href="http://baike.baidu.com/subview/241650/12503090.htm">簇</a>扇区数</td><td>0x01</td></tr><tr><td>BPB_RsvdSecCnt</td><td>14</td><td>2</td><td>Boot记录占用多少扇区</td><td>0x01</td></tr><tr><td>BPB_NumFATs</td><td>16</td><td>1</td><td>共有多少FAT表</td><td>0x02</td></tr><tr><td>BPB_RootEntCnt</td><td>17</td><td>2</td><td><strong>根目录文件数最大值</strong></td><td>0xE0 （224）</td></tr><tr><td>BPB_TotSec16</td><td>19</td><td>2</td><td>扇区总数</td><td>0xB40（2880）</td></tr><tr><td>BPB_Media</td><td>21</td><td>1</td><td>介质描述符</td><td>0xF0</td></tr><tr><td>BPB_FATSz16</td><td>22</td><td>2</td><td>每FAT扇区数</td><td>0x09</td></tr><tr><td>BPB_SecPerTrk</td><td>24</td><td>2</td><td>每磁道扇区数</td><td>0x12</td></tr></tbody></table><table><thead><tr><th>BPB_NumHeads</th><th>26</th><th>2</th><th>磁头数</th><th>0x02</th></tr></thead><tbody><tr><td>BPB_HiddSec</td><td>28</td><td>4</td><td>隐藏扇区数</td><td>0</td></tr><tr><td>BPB_TotSec32</td><td>32</td><td>4</td><td>如果BPB_TotSec16是0，由这个值记录扇区数</td><td>0xB40（2880）</td></tr><tr><td>BS_DrvNum</td><td>36</td><td>1</td><td>中断13的驱动器号</td><td>0</td></tr><tr><td>BS_Reserved1</td><td>37</td><td>1</td><td>未使用</td><td>0</td></tr><tr><td>BS_BootSig</td><td>38</td><td>1</td><td>扩展引导标记</td><td>0x29</td></tr><tr><td>BS_VolD</td><td>39</td><td>4</td><td>卷序列号</td><td>0</td></tr><tr><td>BS_VolLab</td><td>43</td><td>11</td><td>卷标</td><td>‘OrangeS0.02’</td></tr><tr><td>BS_FileSysType</td><td>54</td><td>8</td><td>文件系统类型</td><td>‘FAT12’</td></tr><tr><td>引导代码</td><td>62</td><td>448</td><td>引导代码、数据及其他填充字符等</td><td></td></tr><tr><td><strong>结束标志</strong></td><td>510</td><td>2</td><td></td><td><strong>0xAA55</strong></td></tr></tbody></table><p>从开始偏移510个字节处有两个字节55 AA代表是引导区，小端机整数表示是0xAA 55</p><p>注意到有BS_jmpBoot这个引导记录最开始的JMP指令，反汇编后的机械码为<strong>EB 3C 90</strong>，机器码EB表示JMP，后面1个字节是偏移量，偏移是指从JMP的后条指令开始，到转跳到的指令的差。这里EB 3C表示偏移为60字节（3CH），例如：JMP指令写入内存的地址是0x4011F0，验证一下：0x4011F0 + 2(JMP长2) + 3C= 0x40122E</p><h3 id="如何定位一个文件"><a href="#如何定位一个文件" class="headerlink" title="如何定位一个文件"></a>如何定位一个文件</h3><p>文件分配的最小单位是簇，哪怕只有一个字节也会分配一簇，簇由几个扇区组成在引导扇区的引导记录中定义。在FAT12文件系统中，FAT表以3个<strong>半字节</strong>（3*0.5 Byte = 1.5 Byte = 12 bit）来记录一个簇的相关情况，这也是“FAT12“文件系统中命名12的原因。</p><p>FAT表的本质是磁盘簇分配情况的数据表示，FAT表中每3个半字节为一个元素，这个元素就代表一个簇，簇号从0开始，这个元素中存放的整数值表示其链接的下一簇的簇号</p><h3 id="查找和遍历"><a href="#查找和遍历" class="headerlink" title="查找和遍历"></a>查找和遍历</h3><p>类似于链表的查找，以FFF为结尾，FAT12默认设置引导区占一个扇区，FAT1于其后，同时FAT表开始的3个字节没用于用户文件分配，3字节有2组12bits所以，占用了0,1两个簇号，用户的数据从簇2开始分配。</p><p>随后FAT表从头开始按3字节分成一组，但是有一点需要特别注意：</p><p><strong>在这3个字节中，用第2字节的低半字节和第1字节形成整数表示一个簇号，用第2字节的高半字节和第3字节形成的整数来表示另一个簇号</strong></p><p>由上面学习的内容知道，在FAT表中想要开始遍历就必须知道首簇号，而首簇号位于根目录区域中。</p><h3 id="根目录表中的记录格式"><a href="#根目录表中的记录格式" class="headerlink" title="根目录表中的记录格式"></a>根目录表中的记录格式</h3><p>根目录表包含多条记录，每条记录占32字节，其结构如下表所示。目前我们关注<strong>文件名</strong>（查找需要）和<strong>首簇</strong>（遍历需要）</p><table><thead><tr><th>名称</th><th>偏移</th><th>长度</th><th>描述</th></tr></thead><tbody><tr><td><strong>DIR_Name</strong></td><td><strong>0</strong></td><td><strong>0xB　(11)</strong></td><td><strong>文件名8字节，扩展名3字节</strong></td></tr><tr><td>DIR_Attr</td><td>0xB</td><td>1</td><td>文件属性</td></tr><tr><td>保留</td><td>0xC</td><td>10</td><td></td></tr><tr><td>DIR_WrtTime</td><td>0x16</td><td>2</td><td>最后修改时间</td></tr><tr><td>DIR_WrtDate</td><td>0x18</td><td>2</td><td>最后修改日期</td></tr><tr><td><strong>DIR_FstClus</strong></td><td><strong>0x1A　(26)</strong></td><td><strong>2</strong></td><td><strong>此条目对应的开始簇号</strong></td></tr><tr><td>DIR_FileSize</td><td>0x1C　(28)</td><td>4</td><td>文件大小</td></tr></tbody></table><ul><li><p>文件名字段，在该记录首部偏移0开始，共11字节，其中8个给<strong>文件名</strong>，3个给<strong>扩展名</strong>（不需要记录点号 “.”）</p></li><li><p><strong>名字</strong>的结束以<strong>空格</strong>表示，即0x20</p></li></ul><h3 id="查找根目录表的算法"><a href="#查找根目录表的算法" class="headerlink" title="查找根目录表的算法"></a>查找根目录表的算法</h3><p>从磁盘0头0道1扇区读出引导区（Boot）512字节，从其中引导记录获取相关信息：<strong>Boot区占用扇区数，FAT表数目，每个FAT表的扇区数，1个扇区的字节数</strong>。</p><p>计算根目录区的起始位置为：</p><p><strong>[ 1（Boot区扇区数）+2（FAT数目）*9（FAT扇区数）] * 512 = 0x2600</strong></p><p>即2600h为根目录区起始位置，从引导记录获取根区记录数，缺省224条，按每条记录32字节读出所有记录。每条记录开始11个字节为文件名，比较文件名匹配则找到记录，从首簇字段（从该记录开始偏移1Ah处）获得首簇号。</p><h3 id="系统如何区分卷标项和文件项"><a href="#系统如何区分卷标项和文件项" class="headerlink" title="系统如何区分卷标项和文件项"></a>系统如何区分卷标项和文件项</h3><table><thead><tr><th>名称</th><th>偏移</th><th>长度</th><th>描述</th></tr></thead><tbody><tr><td>DIR_Attr</td><td>0xB</td><td>1</td><td>文件属性</td></tr><tr><td><strong>DIR_FstClus</strong></td><td>0x1A　(26)</td><td>2</td><td>此条目对应的开始簇号</td></tr></tbody></table><p>每一条记录，从该记录开始偏移0xB处有个字节指示出文件的类型，对于多级目录来说，则是存放在数据区内，原理和根目录查找目录类似，只不过是多层嵌套，查找到的是另一个目录表。</p><p>查找<strong>a:\tem\tem.txt</strong></p><p><img src="/posts/41006/2.png" alt></p><h3 id="总结文件查找算法"><a href="#总结文件查找算法" class="headerlink" title="总结文件查找算法"></a><strong>总结文件查找算法</strong></h3><ul><li><p>STEP1. 根据文件路径的第一项（1），先查看<strong>根目录表</strong> ，是否有匹配的项，如果有，通过对应项的<strong>首簇段（0x1A）</strong> 获取该<strong>子目录表（1）</strong> 的首簇号</p></li><li><p>STEP2. 通过首簇号和FAT表获得<strong>子目录表（1）</strong> 的全部内容，根据文件路径的第二项（2），遍历子目录表（1），一次偏移32字节用<strong>名字匹配</strong> 的方法查找记录项（2）, 如果找到，则类似STEP1和STEP2继续查找<strong>文件路径中的下一项</strong> ，否则说明找不到，结束</p></li><li><p>如果在最后一层目录表（路径的倒数第二项，最后一项是文件名）中找到了被查文件的项，从中获取首簇号，即可通过FAT表访问该文件整个相关簇</p></li></ul><h2 id="第四章-硬盘数据结构"><a href="#第四章-硬盘数据结构" class="headerlink" title="第四章-硬盘数据结构"></a>第四章-硬盘数据结构</h2><p>学习完之前有关文件的管理之后，学习有关硬盘的分区信息。</p><h3 id="主引导扇区"><a href="#主引导扇区" class="headerlink" title="主引导扇区"></a>主引导扇区</h3><ul><li>主引导记录（Master Boot Record, MBR）446字节为<strong>主引导记录</strong></li><li>分区表（ Disk Partition Table, DPT）后面存放了一个<strong>分区表</strong></li></ul><p><strong>相对</strong>扇区数，是相对于引导记录头部的偏移扇区数</p><p>主引导扇区中有主引导记录（其中存放了启动时的引导代码）,分区表项, 如何根据分区表项定位到分区入口, 对于放在硬盘头部的MBR和拓展分区与EBR中的计算有所不同.</p><p>分区表项的第一个字节表示是否被激活。</p><p><img src="/posts/41006/3.png" alt></p><h3 id="扩展分区"><a href="#扩展分区" class="headerlink" title="扩展分区"></a>扩展分区</h3><p><strong>虚拟扩展分区</strong>（Extended MBR，即EBR）的目的是为了增加更多的分区,核心想法是形成一个分区链，如图所示的分区中，MBR定义的主分区表本来有4条分区记录，用第一条描述自己分区的信息，用第2条指向下一个分区。下一分区也如此处理，形成链。</p><p><img src="/posts/41006/4.png" alt></p><p>扩展分区的引导记录没有内容,而主分区开始之前有MBR和保留扇区，主分区的相对扇区相对于MBR，通过MBR和相对扇区就可以定位每一个主分区</p><p>注意：</p><blockquote><p>为了完全兼容MBR的格式，EBR完全复用了引导扇区的格式，即起始446字节给引导记录EBR，但在EBR中，这些内容全为0。同样的，从446偏移开始为分区表，16字节为一项，共4项，后两条无效（但占空间），EBR定义的扇区最后两字节也是结束标识55 AA。主分区表中最后一个有效主分区记录指向的磁盘空间（也叫主扩展分区）将用EBR进行划分，分成N个逻辑盘，形成EBR链。</p></blockquote><p><img src="/posts/41006/5.png" alt></p><p><img src="/posts/41006/6.png" alt></p><p>在实际中，则像下图一样：</p><p><img src="/posts/41006/7.png" alt></p><p>主分区表项的偏移量，就是相对物理盘开始（MBR）的偏移，且这些主分区前面没有EBR，根据偏移得到的直接就是盘区（开始就是该分区的引导扇区和文件系统），除了主分区表项中的最后一项偏移指向的是扩展分区的开始处</p><p>扩展分区表项的偏移量，是相对于包含该分区表的扩展区开始处而言（扩展分区开始处为其EBR）</p><p>在扩展分区的分区表中，第一项的偏移指向的是盘区，第二项的偏移指向的是下一个扩展分区开始处（也就是下一个扩展分区的EBR）</p><h3 id="硬盘的引导过程"><a href="#硬盘的引导过程" class="headerlink" title="硬盘的引导过程"></a>硬盘的引导过程</h3><ul><li><p>开机加电自检：开机，CPU跳到内存FFFF:0000处，由该处的一条JMP指令跳到BIOS的自检程序（POST），自检通过后，加载引导程序（与操作系统无关的MBR，按用户在BIOS中的指定顺序，硬盘、软盘、光驱或U盘等</p></li><li><p>读主引导扇区：将主引导扇区MBR读入到内存的0000:7C00，扫描主分区表，搜索激活分区，分区表项第一个字节为0x80表示激活分区</p></li><li><p>读激活分区引导扇区 ：如果有多个激活分区或没有，报错结束。否则读取激活分区引导扇区到0000:7c00</p></li><li><p>操作系统引导代码引导系统并读取操作系统初始化文件</p></li></ul><p>注意的是MBR中硬盘数据结构是与操作系统无关，操作系统相关的引导代码在激活分区的引导扇区，而MBR的引导程序选择激活分区。</p><h2 id="第五章-Dos下的病毒寄生"><a href="#第五章-Dos下的病毒寄生" class="headerlink" title="第五章-Dos下的病毒寄生"></a>第五章-Dos下的病毒寄生</h2><h3 id="病毒的关键问题"><a href="#病毒的关键问题" class="headerlink" title="病毒的关键问题"></a>病毒的关键问题</h3><ul><li>寄生，没有寄生就没有执行和传播的可能</li><li>执行，如果只是文件，没有得以执行的机会，则永远都无法去破坏和感染</li><li>反检查，包括隐藏病毒等</li></ul><h3 id="寄生机制与执行机制"><a href="#寄生机制与执行机制" class="headerlink" title="寄生机制与执行机制"></a>寄生机制与执行机制</h3><ul><li><p>文件型病毒</p><ul><li>头插入</li><li>尾插入</li><li>逆插入</li></ul></li><li><p>直接面向文件系统的病毒</p><ul><li>引导型病毒</li></ul></li><li><p>执行机制</p><ul><li>对于com文件，头、尾和逆插入寄生都相当于入口点修改，病毒可以执行，就不做另行说明</li><li>中断替换</li></ul></li></ul><h3 id="DOS下的内存"><a href="#DOS下的内存" class="headerlink" title="DOS下的内存"></a>DOS下的内存</h3><p>保护模式带来的最大优点不是单纯的扩大了内存寻址范围，而是对内存寻址从机制上提供了保护，将系统的执行空间按权限进行了划分，防止应用程序非法访问其他应用程序的地址空间(任务间保护)，防止应用程序非法访问操作系统地址空间(系统保护)。</p><h3 id="DOS下四种基本可执行文件"><a href="#DOS下四种基本可执行文件" class="headerlink" title="DOS下四种基本可执行文件"></a>DOS下四种基本可执行文件</h3><ul><li>批处理文件，以.BAT结尾的文件</li><li>设备驱动文件，是以.SYS结尾的文件，如CONFIG.SYS</li><li>COM文件，是以.COM结尾的纯代码文件。没有文件头部分，缺省情况下总是从0x100H处开始执行，没有重定位项，所有代码和数据必须控制在64K以内</li><li>EXE文件，是以.EXE结尾的文件。文件以英文字母“MZ”开头，有一个文件头，用来指出每个段的定义等信息，EXE文件摆脱了代码大小最多不能超过64K的限制</li></ul><h3 id="COM文件"><a href="#COM文件" class="headerlink" title="COM文件"></a>COM文件</h3><p>COM文件不存在文件头，由机器码和数据的集合组成，COM文件就是直接读到内存，文件会被加载器加载到段内位置。</p><h3 id="头插入"><a href="#头插入" class="headerlink" title="头插入"></a>头插入</h3><p>头插入病毒是三种病毒之中比较直接的方式</p><p>选择直接插入的话需要注意的是一般函数调用完成后会有ret指令，将执行权交还给DOS，因此后续的代码没有执行就返回了。需要通过JMP指令跳转，不能够直接将RET指令去除，去除的话就将程序段和数据段混合，同时需要注意跳转指令的地址。</p><blockquote><p>源码中的地址信息在编译后会直接被预加载地址代替，从而形成可执行文件的机器码。但因为病毒感染占据了原先com文件的头部，所以原来的机器码后移了这个改动加载器是完全不知道的，它只会把文件加载到预先处，从而导致原先部分的机器码在加载后的实际内存位置后移了，后移长度就是病毒程序的机器码长度</p></blockquote><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>纠正这个问题一般依靠重定位，但COM文件只是简单地被加载到段内原先位置处，本身是没有重定位需要的相关机制，且我们想通过编程来更正错误的地址也是不太可能的。解决方法其实很简单，将原先挤占的程序挪回去原先的位置，</p><p>要拷贝原来的正常程序需要知道它的大小，采取手动的方法，在病毒程序的最后加上两字节的数据存储正常程序的大小，生成感染文件后再在该两字节的位置填入正常程序的大小。</p><p>需要注意的是，如果被拷贝文件过大，会存在覆盖的问题：拷贝指令本身所在的内存部分就是被覆盖的部分。当某次拷贝覆盖了拷贝指令所占的那个字节时，拷贝指令本身就被破坏了，当然它就不能再完成拷贝。那么如何解决这个问题？</p><p>必须让病毒的执行指令本身不会在原文件的拷贝过程中被自我覆盖，最好的方法就是把这些指令放到一个肯定不会被覆盖的安全区域哪里是安全的区域，这里，我们可以选择感染程序最后面的内存区域,也就是原先程序段之外的位置。</p><h3 id="尾部寄生"><a href="#尾部寄生" class="headerlink" title="尾部寄生"></a>尾部寄生</h3><p>在正常代码头部，将原先正常的头部代码修改为jmp覆盖的字节，然后将病毒代码放到正常代码之后，同时注意将被覆盖的正常代码放在病毒代码的后面，确保先执行病毒代码再执行jmp覆盖的字节。但同样具有加载偏差的问题，因此需要使用<code>重定位技术</code>。</p><p>只需要获得任意一条指令的加载偏差就可以知道整个程序的实际偏差地址，也就是将运行时的地址值和编译时的地址值相减就行了，因此关键在于获得IP指向指令的地址值。获取IP寄存器的地址有一个技巧：</p><blockquote><p>Call指令会将下一条指令的IP压栈！然后再跳转执行</p><pre class="line-numbers language-asm"><code class="language-asm">call here <-Call指令的下一条指令是pop ax，call执行时，首先会把pop ax指令的IP（即pop ax这条指令的实际地址）压栈，然后根据相对偏移跳到标号here处here:pop ax <-标号here处就是pop ax指令，执行这条出栈指令会把栈中数据放入ax中，也就是pop ax指令的IP，我们巧妙地利用栈获得了IP的值sub ax, here <-Sub语句中的标号here在编译时就生成了地址，但是是预期地址，实际地址-预期地址，ax中放的就是加载偏差了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>计算出pop的实际地址和预期地址here的差。这样只要将编译期要用的的地址，比如字串的首址加上ax就是字串实际地址了。</p><h4 id="JMP指令长度和格式"><a href="#JMP指令长度和格式" class="headerlink" title="JMP指令长度和格式"></a>JMP指令长度和格式</h4><p>因为JMP要覆盖头部，所以必须分配对应长度的空间在病毒的数据区，用以保存覆盖的内容，在DOS中<code>JMP 地址</code>指令只有两个字节，如果偏移量过长的话则有多个字节，DOS下一般为小端机顺序。</p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ul><li>构造一个打印的正常程序normal.com</li><li>构造一个将粘贴到normal尾部的病毒程序endvirus.com</li><li>用DOS的拷贝命令:用<code>copy /b normal.com + virus.com infected.com完成手动感染</code>, 将两个编译好的程序粘起来，手动完成寄生</li><li>将normal开始的3字节保存到virus.com的数据部分，用UE将normal开始的3字节手动修改为跳转指令，该JMP的机器码格式是E9 XX XX，其中XX XX是2字节，代表偏移这条手动插入的JMP将跳到virus.com处。偏移量如何计算？就是normal.com的size – 3，其中3是因为偏移量从JMP下一条指令开始算，JMP是3字节，所以减3</li><li>virus.com部分指令执行后，将恢复程序开始被覆盖的3字节，还原现场，并JMP到程序开始，将执行权限交给normal.com部分</li></ul><h4 id="手动完成的工作"><a href="#手动完成的工作" class="headerlink" title="手动完成的工作"></a>手动完成的工作</h4><ol><li>寄生感染</li></ol><p>用copy /b normal.com + virus.com infected.com完成手动感染</p><ol start="2"><li>填写OverridedCode字段，保存将被覆盖的头3字节</li></ol><p>用UE打开Infected.com</p><p> 将文件头3个字节内容填入文件<strong>倒数第5个字节开始处</strong></p><ol start="3"><li>填写InfectedFileSize字段，保存被感染文件本身的大小</li></ol><p>查看normal.com文件大小为26字节，即0x001A，该值应该保存到最后两字节，根据小端机原理，我们将倒数第2个字节(InfectedFileSize)修改为0x1A</p><ol start="4"><li>修改第一条JMP指令</li></ol><p>normal.com有26字节，第一条JMP指令自身占3字节，那么跳到virus部分的偏移量是26-3=23，即0x17，那么第一条JMP指令为E9 17 00，修改程序头部3字节为E9 17 00</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>自定位是针对病毒本身出现了加载偏差，而解决原文件加载偏差时，我们是将原文件通过拷贝回预加载地址来解决的。</p><h3 id="逆插入感染"><a href="#逆插入感染" class="headerlink" title="逆插入感染"></a>逆插入感染</h3><p>逆插入感染，实际就是一部分病毒代码在原程序的头部，一部分在尾部，将整个原来的程序给包裹起来。因为即在病毒头部也在病毒尾部，因此需要将程序后移，头粘贴尾粘贴都要使用到。</p><p><img src="/posts/41006/8.png" alt></p><p>与之前手工设计不同的是，需要将感染寄生的代码放在病毒代码中，这段完成感染寄生的代码需要完成：</p><ul><li>把正常程序向后拷贝头病毒的长度</li><li>把头病毒部分拷贝到前面</li><li>把尾病毒部分拷贝到后面</li></ul><p><img src="/posts/41006/9.png" alt></p><h4 id="感染代码部分"><a href="#感染代码部分" class="headerlink" title="感染代码部分"></a>感染代码部分</h4><p>(1)获取原文件大小供后面写入使用 </p><p>(2)原文件扩容,增加头病毒部分长度的字节,在原文件的尾部写字节完成</p><p>(3)原文件向后拷贝头病毒长度部分长度,腾出头部的空间给头病毒,同时要从尾部到头部拷贝,不然会有数据覆盖。</p><p>(4)将头病毒部分写入头部</p><p>(5)将尾病毒部分写入尾部,直接写即可</p><h4 id="头病毒部分"><a href="#头病毒部分" class="headerlink" title="头病毒部分"></a>头病毒部分</h4><p>头病毒部分因为存在加载偏差,需要重定位,并且需要为尾病毒拷贝设置参数.</p><h4 id="尾病毒部分"><a href="#尾病毒部分" class="headerlink" title="尾病毒部分"></a>尾病毒部分</h4><p>重定位有关的代码在头病毒部分已经设置完成,因此不需要额外设置.</p><h2 id="第六章-函数调用"><a href="#第六章-函数调用" class="headerlink" title="第六章-函数调用"></a>第六章-函数调用</h2><p>栈（Stack）是一种用来存储函数调用时的临时信息的结构，如函数调用所传递的参数、函数的返回地址、函数的局部变量等。在程序运行时由编译器在需要的时候分配，在不需要的时候自动清除。</p><h3 id="函数调用对栈的影响"><a href="#函数调用对栈的影响" class="headerlink" title="函数调用对栈的影响"></a>函数调用对栈的影响</h3><ul><li><p>首先把指令寄存器EIP（它指向当前CPU将要运行的下一条指令的地址）中的内容压入栈，作为程序的返回地址（一般用RET表示）；</p></li><li><p>之后放入栈的是基址寄存器EBP（保持之前的值，调用后恢复）；</p></li><li><p>然后把EBP设为栈顶指针ESP，作为新的基地址；</p></li><li><p>最后为动态存储分配留出一定空间，即把ESP减去一个适当的数值</p></li></ul><p>调用函数时,CALL指令干了两件事情,一件事情是将返回地址入栈,另外一件事情是JMP跳转至调用被函数.  在使用call指令前,需要将实参入栈。</p><p><img src="/posts/41006/10.png" alt></p><p>栈的顶部地址存放在ESP寄存器中，而栈的大小变化是以4字节为单位（32位机），因此我们只需要做如下计算就可以访问存储参数2的栈单元，例如 mov eax, [esp + cell*4]。但是之后的函数体如果使用了局部变量进行压栈，那么就无法正确访问参数。因此才需要在call之后先把EBP中的内容压栈，ESP放入到EBP中，此时EBP和ESP同样都是指向原EBP的位置。</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>只要在一个函数的开始部分执行:</p><pre class="line-numbers language-asm"><code class="language-asm"> push ebp; mov ebp, esp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>之后相对ebp 进行正向偏移就可以访问它的主调函数传入的参数了</p><h3 id="局部变量的访问"><a href="#局部变量的访问" class="headerlink" title="局部变量的访问"></a>局部变量的访问</h3><p>栈布局如之前图所示，因此局部变量分配在哪，如何访问？因为栈是由高地址向低地址增长，因此如何低地址部分就为局部变量的存储位置，与访问实参相同，都是通过ebp偏移访问。</p><p>可以简单记作：在使用了EBP寻址的函数中，EBP+偏移量就是参数的地址，EBP-偏移量就是局部变量的地址</p><h3 id="函数返回"><a href="#函数返回" class="headerlink" title="函数返回"></a>函数返回</h3><p>通过调用ret指令，将当前栈顶存放的内容作为返回的地址，而call的时候，就将返回地址存入栈了。</p><p>而被调函数的ret语句进行了如下操作：</p><p>将返回地址从栈中弹出，并放入EIP寄存器。所以每个被调函数的结尾处都是一句ret，这是函数的返回地址，那么函数返回值如何传递？首先调用ret后，EBP已经还原，对于局部变量来说无法通过EBP-偏移量来访问。</p><p>对于被调函数来说，则是将局部变量放入eax或者edx这种通用寄存器中，而对于调用者来说，则是把对应通用寄存器中的值放入到其对应的局部变量中。</p><p>对于返回值过多或者过大（如结构体）寄存器无法存储怎么办？解决办法即传地址即可。但是需要注意的是，如果EAX存了返回值，那么调用结束后进行请栈，EAX中存储的地址在逻辑上已经无效了。因此需要分配一段内存来存储这个返回值。这段空间就是在主调函数call背调函数之前完成。</p><p><img src="/posts/41006/11.png" alt></p><p>然后，当被调函数传递返回值时：</p><p>（1）通过[EBP+偏移]获得这个返回值的存放位置</p><p>（2）把返回值写入到这个内存</p><p>（3）把返回值的地址写入到EAX，mov eax, [ebp+偏移]</p><p><img src="/posts/41006/12.png" alt></p><h3 id="栈清除"><a href="#栈清除" class="headerlink" title="栈清除"></a>栈清除</h3><p>平衡栈，函数返回需要清除参数传递消耗的栈空间，参数传递使用了栈空间，那么函数完成了工作就不需要这些空间了，必须清除。清除栈上的空间很简单，只需要将ESP寄存器向反方向移动就可以了。清栈的工作可以由被调函数完成，也可以由主调函数清除。</p><h4 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h4><p>即分配的临时变量空间不足以容下临时变量，导致覆盖了堆栈的高位元素，EBP，RET这些指令和数据被覆盖，将溢出的数据视为了指令，出现了错误。</p><h2 id="第七章-DOS下的引导-中断"><a href="#第七章-DOS下的引导-中断" class="headerlink" title="第七章-DOS下的引导+中断"></a>第七章-DOS下的引导+中断</h2><p>接下来学习面向文件系统的病毒：</p><h3 id="引导型病毒"><a href="#引导型病毒" class="headerlink" title="引导型病毒"></a>引导型病毒</h3><p>引导型病毒感染引导区，替换引导区原始的引导代码，从而获得执行。之后还原被修改的引导区，并将执行权限交给原来的引导代码，从而保持正常的工作。</p><p>接下来学习的引导型病毒是面向软盘上引导区的，软盘和硬盘所不同的是，硬盘分区（激活分区）的起始位置需要访问所对应的分区表项，找到分区表项，才能知道自己分区从哪里开始等信息，随后才能找到引导扇区的引导代码</p><h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><p>病毒感染时替换0头0道1扇区（512个字节），并将原引导扇区内容保存到用户数据区第一个扇区，也即簇2。病毒执行完打印字串的动作后，从簇2对应扇区读出原引导扇区内容，将其恢复到内存7c00h处，并跳到7c00h将执行权限交给原来的引导程序</p><p>插入被感染软盘，启动虚拟机设置为软盘引导，将先打印病毒的消息，然后进入原来的引导程序（原引导程序将打印非系统盘）</p><h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><p><strong>执行过程：</strong>病毒先把自己加载到7C00h，然后又把原引导程序拷贝到7C00h，这个过程会出现什么问题？就是前面遇见的<strong>自我覆盖</strong>问题，所以需要将病毒中执行拷贝的指令段移出被覆盖的区域。我们可以将它后移一个扇区7e00h处</p><p><strong>感染过程：</strong>感染会将原引导扇区的内容一直放到簇2，如何避免后续使用占用簇2，破坏了病毒的逻辑？可以修改FAT1和FAT2表，将簇2的项改成不可使用，如果改为已占用FFF，但却没有对应的目录项，是可疑的，因此，可以改为坏簇FF7，从而防止别人使用它。这些感染，为了简单，没有采用汇编访问硬盘的方式，而是采用C语言来直接修改软盘文件。</p><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul><li>复位磁盘系统</li></ul><pre><code>Xor ah, ah        ;ah=0为磁盘复位int 13h            ;13h为磁盘中断</code></pre><p>读指定从磁头，道，扇区起始，n个扇区到内存缓冲</p><p>AH = 02h是读扇区功能号</p><p>AL = 将读入多少个扇区</p><p>CL = 起始扇区号</p><p>CH = 磁道</p><p>DH = 磁头</p><p>DL = 磁盘，0代表a盘</p><p><strong>ES:BX = 读缓冲的地址，一般只填写BX</strong></p><pre><code>Mov ah, 02Mov al, 5        ;读5个扇区Mov cl, 1        ;从1扇区开始Mov ch, 0    ;读0道Mov dh，0    ;读0头Mov dl, 0        ;读a盘Mov bx,7c00h    ;读到7c00h处int 13h</code></pre><p>Int 13h采用的是CHS的硬盘寻址方式，而我们习惯上采用绝对扇区号为0,1,2,3,…的线性方式。</p><h4 id="绝对扇区号如何转换为磁头-道-扇区号"><a href="#绝对扇区号如何转换为磁头-道-扇区号" class="headerlink" title="绝对扇区号如何转换为磁头/道/扇区号"></a>绝对扇区号如何转换为磁头/道/扇区号</h4><p>软盘的扇区磁头道一个道18个扇区。</p><ul><li>道内扇区号（从1开始计数）：给定绝对扇区号，除以18（软盘一道有18个扇区），则<strong>余数+1是道内扇区号</strong> （道内扇区从1开始），<strong>商为N则N+1为绝对道</strong>（比如，绝对扇区19，商1，余数1，道内扇区2，绝对道2）</li><li><strong>磁道</strong>(从0开始计数)：不同头的相同道是连续存放的，假定磁头数目为m（m=2），则<strong>N/m去掉小数为磁道，也即对应的磁道号</strong>。软盘m=2，即N右移一位是磁道号（<strong>N &gt;&gt;1</strong>）</li><li><strong>磁头</strong>：对于软盘，有两个头，因为绝对道=N+1。当绝对道为奇，N为偶，对应头0当绝对道为偶，N为奇，对应头1。绝对道6（N=5）对应头1因此，采用运算<strong>N &amp; 1</strong>获得磁头号。N为奇数 and 1 = 1，N为偶数 and 1 = 0。</li></ul><blockquote><p>绝对扇区号/18 得到余数和商N</p><p>扇区号：余数+1，磁道：N&gt;&gt;1，磁头：N &amp; 1</p></blockquote><p><img src="/posts/41006/13.png" alt></p><h3 id="执行部分程序设计"><a href="#执行部分程序设计" class="headerlink" title="执行部分程序设计"></a>执行部分程序设计</h3><p><img src="/posts/41006/14.png" alt></p><p>执行的时候发现存在引导原先系统盘失败的问题。病毒把引导区全部覆盖了，导致DOS无法识别a盘。在引导扇区，其实还有很多重要的引导记录（包括FAT有多少扇区，磁盘的介质类型等），因为病毒只是简单地覆盖了整个扇区，从而破坏了这些引导记录，导致DOS无法识别盘。</p><p>因此只要保留引导记录即可，引导扇区的头3个字节吗？是一条JMP指令和一个NOP，它会跳过引导记录，跳到引导程序处，因此，我们的病毒指令可以只覆盖引导记录后面的部分。</p><p>同样的，在加载时它实际加载的地址是引导记录，不是指定的地址，因此加载的位置与实际有偏差，需要使用到重定位。</p><ul><li><p>解决1：写自定位代码</p></li><li><p>解决2：让病毒代码前面加入偏移</p></li></ul><p>为了真正执行的病毒代码不发生加载偏差，在病毒指令之前加入了填充字节（字节数为引导记录占用的字节数），需要定位到引导记录后才拷贝，并且从写入时从引导记录后开始复制，复制长度减少了引导记录的长度（即仅仅复制病毒执行部分的长度）。修改后结果，在非引导下，可以正常识别被感染的软盘了。</p><h3 id="中断替换"><a href="#中断替换" class="headerlink" title="中断替换"></a>中断替换</h3><h4 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h4><p>中断引发后，就会去调用一段处理程序，叫<strong>中断处理程序</strong>（<strong>例程</strong>），系统找到中断处理程序的<strong>入口地址</strong>，从而执行中断，系统通过<code>中断向量表</code>找到中断处理程序的入口地址，中断向量表存放在内存的最低处，即00:00处，每4个字节为1个项，这个作为索引的项就是<code>中断向量号</code>， 其中存放一个中断处理程序的入口地址，高2字节是段地址，低2字节是段内偏移。</p><p>一个中断触发指令<code>int xxh</code>，其中的xx就是中断向量号，4 * xx就是中断xx的入口地址在中断向量表中存放的位置。比如int 10h其入口地址就存放在中断向量表中的4*10h = 40h的位置。</p><h4 id="非驻留式中断向量修改"><a href="#非驻留式中断向量修改" class="headerlink" title="非驻留式中断向量修改"></a>非驻留式中断向量修改</h4><p>驻留程序就是一直在内存中不退出，系统的<code>中断处理程序</code>要为所有程序服务，所以它的特点就是不退出一直驻留在内存中。</p><p>病毒为了获得执行，会修改<code>中断处理程序的入口地址</code>（即修改中断向量表）指向病毒提供的一段程序，这样，只要调用相应的中断，就会去执行这段程序。但是，这段病毒程序必须也是驻留程序，否则病毒结束后，内存回收，这段程序也不在了，导致中断向量表指向无效。因此，在非驻留式的中断替换中，我们还需要在病毒程序调用后恢复中断向量表。</p><p><img src="/posts/41006/15.png" alt></p><p>结合之前，段寄存器和中断向量表是在不同的段的。段寄存器需要根据实际访问情况变化，先从低2字节处取出中断程序的<strong>段内偏移</strong> ，约定放在AX寄存器中，再放到数据区的Offset处，再从高2字节处取出中断程序的<strong>段地址</strong>，约定放在CX寄存器中，再放到数据区Seg处。</p><p>病毒需要由自己段跳到原中断向量程序所在的段。要跨段跳转，就要采用JMP XX:YY的形式，但是JMP CX:AX的语法是不支持的，即JMP XX:YY的指令不支持两个间接性，XXYY总有一个是立即数，而程序里面Seg和Offset都不是立即数，怎么解决？我们可以先采用两个立即数来确定JMP指令的形式（比如JMP 00:00），然后我们再来定位到JMP指令的机器码，进行按字节的细粒度修改。</p><p><img src="/posts/41006/16.png" alt></p><h2 id="第八章-链式病毒"><a href="#第八章-链式病毒" class="headerlink" title="第八章-链式病毒"></a>第八章-链式病毒</h2><p>链式病毒只保留一份病毒拷贝，利用文件目录项，将受感染文件的头簇指向病毒。</p><p>复习之前获取文件的内容知识</p><p><img src="/posts/41006/17.png" alt></p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><strong>感染过程：</strong></p><ol><li><p>如首次感染，将病毒保存在某个空闲扇区</p></li><li><p>将被感染文件（COM文件）首簇存目录项保留段</p></li><li><p>修改首簇号指向病毒的首簇</p></li></ol><p><strong>执行过程：</strong></p><ol><li><p>执行被感染文件则启动病毒，加载的是病毒的首簇，并执行</p></li><li><p>病毒获取当前执行程序的名字，获取对应目录项。从其中保留字段获取原文件首簇号，并遍历FAT簇链加载它们。</p></li><li><p>跳到加载的原文件内存中执行</p></li></ol><h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><p><strong>一、感染部分</strong></p><ul><li>被感染文件的真实起始扇区号写到<code>目录表项的保留区</code>（目录项的保留区从目录项头第13个字节即偏移0ch开始，共10字节）</li><li>修改被感染文件的目录项的<code>起始扇区字段</code>指向病毒文件的首簇</li><li>目录项中的<code>文件大小字段</code>也要修改成病毒的真实大小，这样才能保证病毒能被完整加载</li><li>将原来病毒文件的目录项全部32字节改为0，这样从外部看就不存在这个病毒文件，也没有对应的目录项了</li></ul><p><strong>二、执行部分</strong></p><ul><li><p>病毒运行后，先获取被<code>感染程序的名字</code></p></li><li><p>然后从根目录寻找<code>被感染程序的目录项</code></p></li><li><p>找到后从该目录项的保留区获取<code>被感染程序的首簇号</code></p></li><li><p>找到被感染程序所在簇（即扇区），加载该扇区到内存</p><blockquote><p>因为被感染文件是COM文件，将其加载到内存100h处，并将执行权交还给被感染文件</p><p>注意的细节：当把原文件加载到100h时，会产生<code>自我覆盖</code>的问题，和头感染相似，因此，病毒代码需要把执行拷贝功能的代码段移到一个安全区域（即不会被覆盖的区域）。因为本病毒是针对被感染文件大小 &lt; 1扇区的文件，因此，只需要移动到100h（加载地址） + 200h（1个扇区大小）的位置即可（即300h）</p></blockquote></li></ul><p><img src="/posts/41006/18.png" alt></p><h3 id="如何获取执行文件名"><a href="#如何获取执行文件名" class="headerlink" title="如何获取执行文件名"></a>如何获取执行文件名</h3><p>原理：</p><p>从COM文件的DS:2c处获得<strong>环境块首址的段地址</strong>，环境块就在<strong>段地址：0000</strong> 处。</p><p>环境块内容：PATH=……COMSPEC=C:\COMMAND.COM\0….0 0 xxxx。环境块开始是PATH等0字符结尾的串，最后是两个00字符。然后有两个字节，可能是数目，之后就是执行程序的名字。</p><h2 id="第九章-Win病毒-虚拟地址"><a href="#第九章-Win病毒-虚拟地址" class="headerlink" title="第九章-Win病毒-虚拟地址"></a>第九章-Win病毒-虚拟地址</h2><h3 id="动态链接库DLL"><a href="#动态链接库DLL" class="headerlink" title="动态链接库DLL"></a>动态链接库DLL</h3><p>动态链接库（Dynamic Link Libraries）为模块化应用程序提供了一种方式，使得<strong>更新和重用</strong>程序更加方便。</p><p>1）动态链接库是应用程序的一部分，作为<strong>模块</strong>被进程加载到<strong>自己的空间地址</strong></p><p>2）动态链接库在程序编译时并不会被插入到可执行文件中，在程序运行时整个库的代码才会调入内存，这就是所谓的“动态链接”</p><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><blockquote><p>Windows系统下程序是如何被加载执行的？</p></blockquote><p>而执行首先需要加载到内存，这又涉及到<strong>保护模式下内存管理</strong>的问题。下面我们将先学习<strong>内存管理和程序加载的相关机制</strong></p><h4 id="Windows内存管理和程序加载"><a href="#Windows内存管理和程序加载" class="headerlink" title="Windows内存管理和程序加载"></a>Windows内存管理和程序加载</h4><ul><li><p>DOS的内存管理，是实模式，我们可以随意改动甚至系统的内存（比如修改中断向量表）</p></li><li><p>Windows是工作在x86的保护模式。每个进程都有自己<strong>独立的线性地址空间</strong>（0-4GB，32位CPU的寻址能力为2^32=4GB），互不干扰，这4GB空间会按某个固定的大小（如4KB）分成N个页</p></li><li><p>同时，内存又分为<strong>用户空间</strong>和<strong>内核空间</strong>，用户空间的代码（我们编写的exe）无法直接访问内核空间内存的。这些限制让我们无法像DOS那样随便涂改内存了</p></li><li><p>保护模式最大优点是对内存寻址从机制上提供了保护，将系统的执行空间按权限进行了划分，防止应用程序非法访问其他应用程序的地址空间(<strong>任务间保护</strong>)，防止应用程序非法访问操作系统地址空间(<strong>系统保护</strong>)。</p></li></ul><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><ul><li><p>在Windows系统下，现在是保护模式，我们看见的内存地址，是逻辑地址，并非真正的物理地址。实模式下，看见的内存地址就是真实的物理地址。</p></li><li><p>同一逻辑地址的值对应不同物理上的内存地址正是保护模式的能力。</p></li><li><p>虽然逻辑地址相同，但具有不同的映射对应，从而使得大家的物理地址各不相同，但是却隐藏了真正的物理地址，起到保护作用。</p></li></ul><h3 id="虚拟地址转换过程"><a href="#虚拟地址转换过程" class="headerlink" title="虚拟地址转换过程"></a>虚拟地址转换过程</h3><p>32位虚拟地址分成3部分(详情请见操作系统)：</p><blockquote><p>CR3寄存器给出<strong>页目录地址</strong></p><p>CR3寄存器: </p><ul><li><p>PDE 页表目录：每一项4个字节，保存了页表的地址</p></li><li><p>PTE 页表，里面包含每一页的物理地址和页属性</p></li></ul><p>在分页系统中，为每个进程配置了一张页表)</p><p>前面10位用于在页目录中查找<strong>页表地址</strong></p><p>中间10位用于在页表中查找<strong>页表项</strong></p><p>后面12位给出相对页表项地址的<strong>偏移</strong></p></blockquote><h3 id="PE如何解决COM加载的缺点"><a href="#PE如何解决COM加载的缺点" class="headerlink" title="PE如何解决COM加载的缺点"></a>PE如何解决COM加载的缺点</h3><ul><li>DLL模块加载的真实内存地址不可能是相同的，相同则产生覆盖。这和COM死板的约定加载到100h不同，既然这个加载地址不是固定的了，那么可执行程序应该有地方存储了<strong>约定的加载地址</strong></li><li>COM约定了加载的地方就是程序开始执行的地方（100h必然是第一条指令），但这个也太死板（想像一下我们将子函数写在main函数之前），所以我们可能需要在执行程序中存储<strong>真正代码开始的地方</strong>（即存储第一条指令到头部的偏移即可）</li><li>如果确实加载不到约定地址，而代码自身又不具有自定位代码（很不方便），那么我们可以需要一种重定位机制，这又可能需要借助一种新的数据结构，比如<strong>重定位表</strong></li><li>这些都导致了执行程序需要一种格式来描述信息，除了指令和数据外，还应该有相应的格式或结构来存储上面这些东西</li></ul><h2 id="第十章-PE结构和末节寄生"><a href="#第十章-PE结构和末节寄生" class="headerlink" title="第十章-PE结构和末节寄生"></a>第十章-PE结构和末节寄生</h2><p>在Win32位平台可执行文件命名为可移植的可执行文件(Portable Executable File)，该文件的格式就是PE格式</p><p><img src="/posts/41006/19.png" alt></p><h3 id="映像"><a href="#映像" class="headerlink" title="映像"></a>映像</h3><blockquote><p>PE文件的加载要完成<code>虚拟地址（内存）</code>和<code>PE文件（硬盘）</code>之间的映射关系，所以又被称为映像文件。当真正执行某个内存页中的指令或访问某一个页的数据时，这个页面才会真正读入内存。</p></blockquote><p>在学习PE文件的时候，一定要区分<code>文件位置</code>和<code>虚拟地址</code>的概念，而在内存定位时，除了虚拟地址（Virtual Address，VA）的概念，还有<code>相对虚拟地址（RVA）</code>的重要概念</p><h3 id="RVA-相对虚拟地址（Relative-Virtual-Addresses）"><a href="#RVA-相对虚拟地址（Relative-Virtual-Addresses）" class="headerlink" title="RVA-相对虚拟地址（Relative Virtual Addresses）"></a>RVA-相对虚拟地址（Relative Virtual Addresses）</h3><ul><li><p>第一，<strong>虚拟</strong>，说明它不是一个真实地址，因此，它应该就是前面我们提到的逻辑地址，既然是逻辑地址，应该就是指的就是内存了（注意和硬盘上文件中的位置相区分）</p></li><li><p>第二，<strong>相对</strong>，相对说明这个地址很有可能是对某一个逻辑地址的偏移，而这个逻辑地址很有可能就是我们PE文件加载到内存时，所占用的最开始的那个内存单元的逻辑地址（或称之为基地址）</p></li></ul><h3 id="RVA和FOA的联系与区别"><a href="#RVA和FOA的联系与区别" class="headerlink" title="RVA和FOA的联系与区别"></a>RVA和FOA的联系与区别</h3><ul><li>RVA是内存的相对位置，相对的是加载到内存的基地地址</li><li>FOA是文件中的相对位置，相对的是文件开始位置（即0）</li></ul><p><img src="/posts/41006/20.png" alt></p><p><strong>文件在硬盘存储时的对齐方式和在内存加载时的对齐方式是不同的</strong>，在文件中，每一个<strong>节</strong>往往按512B（200H）的粒度对齐。而在内存中，通常以4096B（1000H）的粒度对齐，由于对齐的方式不同，有些节，它在内存的RVA就和它在文件的FOA就不一致。</p><p><img src="/posts/41006/21.png" alt></p><h3 id="如何让病毒被加载、执行？"><a href="#如何让病毒被加载、执行？" class="headerlink" title="如何让病毒被加载、执行？"></a>如何让病毒被加载、执行？</h3><p>PE文件格式字段：</p><p>e_magic：两个字符MZ代表DOS文件</p><p>e_lfanew：偏移量，就是从文件开始到PE文件头（NT头）的偏移量</p><p>通过“MZ”和后面的“PE”标志，来初步判断文件是否为PE文件，从而确定是否进行感染寄生</p><h3 id="PE头（NT头）"><a href="#PE头（NT头）" class="headerlink" title="PE头（NT头）"></a>PE头（NT头）</h3><p>nPE文件头的结构是IMAGE_NT_HEADERS，又称之为NT头，它是存放了整个PE文件的相关重要信息</p><pre><code>IMAGE_NT_HEADERS STRUCT        Signature  dd ?         FileHeader IMAGE_FILE_HEADER &lt;&gt;         OptionalHeader IMAGE_OPTIONAL_HEADER32 &lt;&gt;IMAGE_NT_HEADERS ENDS</code></pre><p>它包含3部分：</p><ul><li>PE文件标志（Signature）:字段头两个字节是“PE”，表明该文件是PE格式的文件。</li><li>映像文件头（IMAGE_FILE_HEADER）:NumberOfSections字段存储文件中节的个数</li><li>可选映像文件头（IMAGE_OPTIONAL_HEADER32）：<ul><li>AddressOfEntryPoint表示代码入口RVA，第一条指令的RAV</li><li>ImageBase: Cardinal; //载入程序的首选RAV</li><li>SectionAlignment: Cardinal; //节在内存中对齐方式</li><li>FileAlignment: Cardinal; //节在文件中对齐方式</li><li>SizeOfImage: Cardinal;     //内存中整个PE文件的总大小，按内存对齐</li><li>DataDirectory: array[0..IMAGE_NUMBEROF_DIRECTORY_ENTRIES - 1] of  TImage_Data_Directory; //数据目录表</li></ul></li></ul><p>病毒判断一个文件是否是PE格式往往可以通过：</p><ol><li><p>先判断文件头2字节是否为“MZ”</p></li><li><p>判断NT头的Signature是否为“PE”</p></li></ol><h3 id="利用入口RVA实现病毒执行的问题"><a href="#利用入口RVA实现病毒执行的问题" class="headerlink" title="利用入口RVA实现病毒执行的问题"></a>利用入口RVA实现病毒执行的问题</h3><p>知道执行程序的入口代码地址如何确定的，如果找到了，将它指向病毒代码，找到了<strong>AddressOfEntryPoint</strong>，它表示入口RAV，也是第一条指令的RAV，程序从这里开始执行。</p><p>我们需要通过RAV来找到该指令在文件中的FOA以便修改开始的机器码，利用RVA找到所属的节,如果该节的起始RVA和该节的起始文件偏移相等，那么就直接用作文件偏移。如果有差别：</p><blockquote><p>入口点的RVA（AddressOfEntryPoint）- 节的RVA =入口点的FOA - 节的起始文件位置（PointerToRawData）</p></blockquote><h3 id="PE描述文件大小的字段"><a href="#PE描述文件大小的字段" class="headerlink" title="PE描述文件大小的字段"></a>PE描述文件大小的字段</h3><p>1）节表紧跟在PE文件头后，节表中的每一个结构ImageSectionHeader （28H）都对应一个节，其中，有两个字段描述了对应节的文件大小（SizeOfRawData）和加载到内存的大小（VirtualSize）（两者可能不同，文件大小可以大于内存也可以小于内存。小于内存时，将在内存补0）</p><p>2）在PE头的可选映像头ImageOptionalHeader中，SizeOfImage给出了整个程序包括所有头部加载到内存后的大小其大小应该是SectionAlignment的整数倍</p><p>简单说，就是PE文件总大小和每个节的大小都有参数：</p><ul><li>每一个节都有一个对应的节表项SectionHeader结构</li><li>VirtualSize表明本节加载到内存后的大小即加载到内存的实际字节数（未对齐）</li><li>SizeOfRawData字段表明本节在文件中的大小（对齐后）因此，必须是FileAlignment（在可选映像头中）的整数倍</li></ul><p>回到可选映像头ImageOptionalHeader中观察：</p><ul><li><p>SizeOfImage给出了整个文件在内存中对齐后的大小</p></li><li><p>SectionAlignment是内存对齐的粒度</p></li><li><p>FileAlignment是文件对齐的粒度</p></li></ul><h3 id="用程序完成末段大小不变的寄生"><a href="#用程序完成末段大小不变的寄生" class="headerlink" title="用程序完成末段大小不变的寄生"></a>用程序完成末段大小不变的寄生</h3><ol><li><p>生成需要寄生的病毒代码</p></li><li><p>获得被感染文件的NT头</p><ol><li>利用DOS头的e_lfanew字段（文件定位）</li><li>定位NT头，读到ntHrds（文件定位读）</li></ol></li><li><p>找到最后一个节判断是否具有空洞</p><ol><li><p>如何判断节是否有空洞？</p><p><strong>virtualSize &lt; SizeofRawData</strong></p></li><li><p>这些信息在哪里？</p><p><strong>最后一个节的节表项中</strong></p></li><li><p>当前的文件指针在什么地方？</p><p><strong>之前读了NT头，现在在NT头的后面也就是节表的起始文件位置</strong></p></li></ol></li><li><p>修改最后一个节VirtualSize写入病毒</p></li><li><p>修改SizeofImage和EntryPoint</p></li></ol><h2 id="第十一章-EPO入口点不在代码节的问题"><a href="#第十一章-EPO入口点不在代码节的问题" class="headerlink" title="第十一章-EPO入口点不在代码节的问题"></a>第十一章-EPO入口点不在代码节的问题</h2><h3 id="入口点模糊技术-Entry-Point-Obscuring"><a href="#入口点模糊技术-Entry-Point-Obscuring" class="headerlink" title="入口点模糊技术(Entry Point Obscuring)"></a>入口点模糊技术(Entry Point Obscuring)</h3><p>每个节的节表项有一个characteristics属性,说明了该节是干什么的,当IMAGE_SCN_CNT_CODE为20时说明是代码节. EPO技术能够让病毒代码隐藏自己入口点，避免被查杀,使得被病毒修改后的入口点看起来依然就像是正常的入口点.</p><p>解决入口点不在代码段的问题，我们可以采用下2种解决方法：</p><blockquote><p>1）不感染最后一节，直接感染代码节，病毒代码附着在代码节的尾部，再修改入口点。这样虽然修改了入口点，但让入口点处于代码节</p><p>2）不修改入口点，但将入口点所在的指令替换成一条JMP指令，跳往到寄生的病毒代码</p></blockquote><h3 id="EPO1-感染在代码节的空洞"><a href="#EPO1-感染在代码节的空洞" class="headerlink" title="EPO1 感染在代码节的空洞"></a>EPO1 感染在代码节的空洞</h3><p>本方法有个缺陷，真正的入口一般都在代码节的前部，而我们感染的是尾部，这样修改后的入口点太靠代码节的后部，这也会使得入口点看起来异常，从而被一些杀毒软件查杀</p><p>比如，我们正常软件入口是1690h，代码节.text的起始RVA是1000h，正常入口在节内偏移只有690h，如果感染到本节尾，则修改后的入口点在节内偏移将是212B0-1000=202B0h，远远大于690。基本就是节尾了，这就会引起怀疑。</p><p>此外，感染代码节时，代码节往往不是最后节，如果代码节空洞不够，就必须增加代码节的节长，则后续节都要修改RVA，文件偏移等字段，非常麻烦</p><h4 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h4><ol><li><p>生成需要寄生的病毒代码</p></li><li><p>获得被感染文件的NT头</p></li><li><p>找到代码节并判断是否具有空洞</p><p>如何找到代码节？遍历所有节表项并判断节表项的属性是否有20属性</p></li><li><p>修改VirtualSize写入病毒</p></li><li><p>修改SizeofImage和EntryPoint</p></li></ol><h3 id="EPO2感染最后节并替换入口指令"><a href="#EPO2感染最后节并替换入口指令" class="headerlink" title="EPO2感染最后节并替换入口指令"></a>EPO2感染最后节并替换入口指令</h3><p>感染时，先将原入口5字节保存，替换成JMP跳到寄生代码。病毒执行后，将入口5字节还原，然后跳回到原入口</p><h4 id="如何生成寄生的病毒代码"><a href="#如何生成寄生的病毒代码" class="headerlink" title="如何生成寄生的病毒代码"></a>如何生成寄生的病毒代码</h4><p>病毒代码需要进行恢复跳转等细致的操作，所以我们把病毒代码采用C中内嵌汇编的方式编写，生成病毒代码code后，然后利用C语言来完成病毒代码的寄生拷贝</p><p>思考：病毒要做的事有哪些</p><ol><li><p>修改原入口点的数据为JMP指令</p></li><li><p>保存被覆盖的5个字节</p></li><li><p>执行逻辑</p></li><li><p>恢复这5个字节</p><ul><li><p>源地址就是被覆盖的5个字节，放在数据区，所以我们把可以把<strong>数据区的起始地址</strong>也作为数据放入数据区</p></li><li><p>目的地址是原程序的<strong>入口点地址</strong>，寄生后，病毒的main函数就结束了，所以这个<strong>入口点地址</strong>也需要写入数据区时</p></li></ul></li><li><p>最后一条JMP跳回原入口点</p></li></ol><blockquote><p>因此，寄生代码的数据区应该有5+4+4=13个字节</p></blockquote><p>寄生代码生成的时候，这些重要的地址信息是根据PE文件的预期加载地址ImageBase来生成的，所以说是预期地址。然后寄生代码会放到原文件中，如果原文件加载到预期的ImageBase，寄生代码中的地址信息就是正确的。但是！ImageBase是程序<strong>预期</strong>加载的基地址，win7系统和vs编译器往往都采用了随机地址空间技术，使得程序即每次加载的<strong>实际</strong>地址并不是ImageBase，原文件有重定位表这样的机制帮助重定位，但病毒只能利用前面我们学到的<strong>自定位</strong>技术原理。</p><p><img src="/posts/41006/22.png" alt></p><p><strong>关键在于：</strong></p><ul><li>找到入口点所在的节</li><li>然后将入口点（内存位置）转变为文件位置</li></ul><p>实际中会遇到内存区只可读不可改的情况，因此我们把characteristics的值改为我们想要的可写即可，80000000h代表写，为避免类似情况，我们选择在循环搜索入口点所在的节时，一旦找到该节，就将该节的索引（后面写入时需要利用这个索引值找到该节）和属性字段保存，然后，在文件中定位到该节的节头，计算新的属性值并写入到节头的属性字段。</p><h2 id="第十二章-DDL-导出表"><a href="#第十二章-DDL-导出表" class="headerlink" title="第十二章-DDL+导出表"></a>第十二章-DDL+导出表</h2><h3 id="如何让病毒调用函数"><a href="#如何让病毒调用函数" class="headerlink" title="如何让病毒调用函数"></a>如何让病毒调用函数</h3><p>我们需要在病毒数据区存放调用函数所需的参数。如何访问这些参数呢？用我们已经熟悉的自定位代码即可，call后再pop到eax，eax就指向了参数的地址。</p><p><strong>操作系统通过动态链接库（DLL）来对外提供API</strong> </p><p>   1）动态链接库是应用程序的一部分，动态链接库在本质上是作为模块被进程加载到自己的空间地址的。</p><p>   2）动态链接库在程序运行时整个库的代码才会调入内存，这就是所谓的“动态链接”</p><h4 id="如何获取API的入口地址"><a href="#如何获取API的入口地址" class="headerlink" title="如何获取API的入口地址"></a>如何获取API的入口地址</h4><p>只有获取了API函数入口地址（模块DLL – &gt; 函数），我们才能跳过去调用它，没有操作系统和编译器的帮忙，就只有自力更生：</p><p>  （1）找到提供这个API函数的<strong>DLL的加载基址</strong> </p><p>  （2）从DLL的导出表中拿到<strong>API函数地址</strong> ，理解DLL的导出表机制，可简单想象成一张表，然后在这个表中根据函数名找到函数入口地址。我们的操作系统通过kernel32中的GetProcAddress来实现的，但是我们病毒，还是只能自力更生</p><p>想要快速拿到一个API的入口地址，有一个简陋但快速的办法，它基于如下事实：一个系统中，所有进程加载的同一个DLL的加载基址是相同的。在Windows的设计中，因为某种原因（可能是共享代码段，避免重定位等），每个进程中，系统DLL都被加载在一个地址。</p><h4 id="如何利用DLL基址相同让病毒获取API首址？"><a href="#如何利用DLL基址相同让病毒获取API首址？" class="headerlink" title="如何利用DLL基址相同让病毒获取API首址？"></a>如何利用DLL基址相同让病毒获取API首址？</h4><p>只需要在C写的病毒代码中获取MessageBox的首址，然后把这个首址写入到我们病毒的数据区，这样病毒代码寄生到了原文件上时，就可以在自己的数据区获得MessageBox的首址。</p><p><img src="/posts/41006/23.png" alt></p><h3 id="如何判断是否是控制台程序"><a href="#如何判断是否是控制台程序" class="headerlink" title="如何判断是否是控制台程序"></a>如何判断是否是控制台程序</h3><p>在PE文件的可选映像头中，有一个字段可能能够用于识别PE文件是否为控制台程序，就是subsystem，对于大多数Win32程序，只有Windows GUI和Windows CUI两类值。G - Graphic的头字母，C - Console的头字母，因此，我们只需要判断subsystem字段的值，当其为2时才感染即可。</p><h3 id="病毒真正获取API函数地址的方法"><a href="#病毒真正获取API函数地址的方法" class="headerlink" title="病毒真正获取API函数地址的方法"></a>病毒真正获取API函数地址的方法</h3><h5 id="一、获取DLL基址"><a href="#一、获取DLL基址" class="headerlink" title="一、获取DLL基址"></a>一、获取DLL基址</h5><p>只有找到DLL基地址，我们才能找到它的导出表，才能找到所要调用函数的地址。以获取kernel32.dll的基址为例，其他dll模块的方法类似，这里介绍一个简单的获取kernel32.dll基址的方法，主要利用PEB结构（Process Environment Block，进程环境块）查找，每个进程都对应一个PEB。</p><p>首先，FS寄存器在偏移0x30处保存一个指针，指向PEB结构，<strong>FS:[0x30]</strong> -&gt; PEB。</p><p>然后，在PEB结构的偏移0x0C处保存着另外一个指针，该指针指向一个叫PEB_LDR_DATA的结构</p><p>这个PEB_LDR_DATA 偏移0C处是<strong>加载模块链表</strong>的头指针，由8个字节组成，前4个字节指向一个LDR_MODULE结构体（LDR_MDOULE代表一个模块，每一个模块（exe,dll）都对应一个这样的结构体），在该LDR_MODULE中，头4字节又指向下一个加载的LDR_MODULE结构体，由此组成链表。</p><p>在win7下，第一个加载的模块是是执行程序本身，第2个是NTDll，第3个就是kernel32，在结构体偏移0x18处就是所对应模块的基址。</p><p><strong>那如何在遍历的过程中识别模块呢？</strong> </p><p>在LDR_MODULE结构体偏移0x2C的地方，有一个成员BaseDllName，它有8个字节，其中后4字节为地址，指向一个unicode串（每个字符占2个字节），这个unicode串就是不包含路径的纯模块名。</p><p>遍历的结束条件是什么？Next指针为0或者ffffffff么？都不是，过调试我们可以发现，在win7下，加载模块链形成了一个循环链表，因此只要发现next块的头4字节是头块地址就停止遍历。</p><h5 id="二、获取DLL中的函数地址"><a href="#二、获取DLL中的函数地址" class="headerlink" title="二、获取DLL中的函数地址"></a>二、获取DLL中的函数地址</h5><p>找到基址后，我们必须手动完成由函数名获取其所在DLL中地址的过程，我们需要从DLL的实际基址入手，解析DLL的导出表，获取相关函数的入口地址。</p><h3 id="导出表—DLL对外暴露函数地址的机制"><a href="#导出表—DLL对外暴露函数地址的机制" class="headerlink" title="导出表—DLL对外暴露函数地址的机制"></a>导出表—DLL对外暴露函数地址的机制</h3><p>DLL对外暴露自己的函数有两种方式：</p><ul><li>函数名</li><li>序号</li></ul><p>可以通过函数名查找某函数入口，也可通过序号查找，但是，需要注意的是，函数名和序号并非一 一对应！</p><h4 id="序号查找"><a href="#序号查找" class="headerlink" title="序号查找"></a>序号查找</h4><p>序号查找的好处：快！高效！</p><p>我们可以用一个简单的hash完成，而不需要遍历，如果我们用一个数组（funcEntryTb）存储函数的入口地址。第0号函数的入口地址就存入数组的第一个元素funcEntryTb[0]，第1号函数的就存入数组的第2个元素funcEntryTb[1]。这样获取入口地址非常简单 ，即funcEntryTb[n]，n是函数的序号，也就是拿到数组首址funcEntryTb加偏移n*4（每个地址4个字节）即可。类似DOS下的中断向量表。</p><p>如果序号不是从0开始，而是从n开始，我们依然是将n对应函数的入口地址存入第一个元素，依次类推。获取第M（M肯定大于n，因为n最小）号函数的地址如下： funcEntryTb[m - n]。依然非常快速，计算次数固定，即拿到首址funcEntryTb，做一次减法m-n，再做一次乘法(m - n)*4就获取到元素的地址，取出其值保存值即可。这其实也是c语言switch语句出来case中序号和case分支入口地址的方法，所以一般switch比if else嵌套快</p><p>但是序号查找不够直观，同时也不够稳定</p><h4 id="用函数名查找"><a href="#用函数名查找" class="headerlink" title="用函数名查找"></a>用函数名查找</h4><p>用函数名查找：直观！具体！</p><p>最简单的办法就是一个一个函数名字串比较，找到相同的串。下面给出一个简单实现：函数名表的索引和函数地址表的索引是一一对应的。如果查找func2函数地址，我们先遍历函数名表，每遇到\0就是一个串，自然，在第2串处找到了字串func2，fun2是函数名表第2项，索引为1，然后我们用索引1在函数地址表中获得了address2，函数地址表4字节一个元素<strong>通过两个表相同的索引建立关联</strong>。</p><h4 id="两种机制结合"><a href="#两种机制结合" class="headerlink" title="两种机制结合"></a>两种机制结合</h4><p>如果用序号导出对应一个函数地址表，用名字导出也对应一个函数地址表，两个函数地址表显然会造成存储浪费，能否合成在一个函数地址表？</p><p>要实现合并需要满足：</p><ul><li>所有函数都有即有函数名又有序号</li><li>函数名表的索引和序号都是按1递增的</li><li>函数名表的排序还必须按照序号值排序，也就是说，如果一个函数的序号是x，它的函数名就必须排在函数名表的第x-1项</li></ul><p>限制太多，而且最重要的是，<strong>并不是每一个函数都向外暴露函数名！有的函数是没有暴露函数名的！</strong>实际上，DLL中有些函数是只有序号暴露，而没有函数名暴露的。而函数地址表是和序号对应的！这样，就导致函数名表索引是无法和函数地址表索引形成一一对应的关系。</p><p>若要解决类似的问题，就只能通过增加一个表描述对应关系。增加一个函数地址索引表，用它来记录函数名表索引到函数地址表索引的对应关系。</p><p>而按序号查找时，直接根据序号计算其在函数地址表的索引：<code>i=函数序号-最小的序号（n）</code>，然后在函数地址表中找到索引为i的项，取出地址即可。</p><p>导出表有表头（IMAGE_EXPORT_DIRECTORY）描述了导出表相关重要信息：</p><ol><li>Address Table RVA就是函数地址表的RVA</li><li>Ordinal Table RVA就是函数地址索引表的RVA，PE格式叫它序号表</li><li>Ordinal Base就是最小的序号，Number of names就是函数名表的条数</li></ol><p>PE格式将函数名表做了些变化，用了一个函数名指针表，Name Pointer Table RVA，它每项4个字节，存放了一个RVA，指向一个函数名的字符串</p><p><img src="/posts/41006/24.png" alt></p><h4 id="如何获取导出表的表头"><a href="#如何获取导出表的表头" class="headerlink" title="如何获取导出表的表头"></a>如何获取导出表的表头</h4><p>在模块的可选头中，最后有一个数据目录表<code>EXPORT Table</code>：数据目录表中的每一项都是一个重要的元素，包括导出表、导入表、重定位表等…每一个项都给出了相应元素的入口RVA和大小，其中，第一项就是重要的导出表。根据这个就能找到导出表的表头。</p><h4 id="导出函数查找算法"><a href="#导出函数查找算法" class="headerlink" title="导出函数查找算法"></a>导出函数查找算法</h4><ol><li><p>从DLL加载的<strong>实际基址</strong>获取可选头，从其中<strong>数据目录表</strong>的第一项找到导出表入口RVA</p></li><li><p>从导出表的表头获取Number of names，即查找的最大循环次数</p></li><li><p>循环遍历<strong>函数名指针表</strong>，比对每项RVA指向的字串是否为要找的函数名</p><p><code>函数名指针表1项4字节 à 对应的字符串地址</code></p></li><li><p>如果找到，记下此时函数名指针表项的索引，设为 i</p></li><li><p>根据索引 i，在<strong>序号表</strong>中找到对应项，获取其内容为n</p><p><code>序号表1项2字节</code></p></li><li><p>以n为索引在<strong>函数地址表</strong>中找到函数入口的RVA，加上DLL的实际基址即为函数的实际入口地址</p><p><code>地址表1项4字节</code></p></li></ol><p>注：以上算法中，所有访问实际地址的地方，就用<code>DLL的实际加载基址+RVA</code>即可</p><h2 id="第十三章-EPO技术指令Patch和导入表机制"><a href="#第十三章-EPO技术指令Patch和导入表机制" class="headerlink" title="第十三章-EPO技术指令Patch和导入表机制"></a>第十三章-EPO技术指令Patch和导入表机制</h2><h3 id="利用Patch指令的方式实现EPO"><a href="#利用Patch指令的方式实现EPO" class="headerlink" title="利用Patch指令的方式实现EPO"></a>利用Patch指令的方式实现EPO</h3><p><strong>核心问题：</strong></p><ol><li>找到一条指令，并知道其起始边界</li><li>最好这条指令必然执行，否则patch了，病毒代码也不会必然执行。</li></ol><p><strong>解决思路：</strong></p><ol><li>对一些常见特殊指令识别，比如PUSH EBP；MOV EBP, ESP等，这是很多函数的开始设定基址寄存器的组合。简单，方便。缺点：由于指令长度过短，可能和数据相同，因此不见得一定是指令；同时，不见得该代码一定会被执行</li><li>对导入函数的调用指令进行Patch，这些指令的可靠度很高，可以选择某些必然被调用的函数指令去Patch</li><li>病毒自带反汇编器（如一些开源反汇编器），静态分析宿主程序，随机找一条指令Patch，隐蔽度极高，复杂，但Patch的指令不一定会必然执行</li><li>自带调试功能（相当一个调试器），将宿主程序隐藏启动，单步调试运行，自然得到每条指令的边界</li></ol><h4 id="为什么Call要用相对偏移"><a href="#为什么Call要用相对偏移" class="headerlink" title="为什么Call要用相对偏移"></a>为什么Call要用相对偏移</h4><p>在前面，我们已经知道了加载可能出现与约定地址不吻合的问题（回想下PE头中的ImageBase字段），如果Call指令采用了绝对地址, 那么这条Call指令就会失效。</p><p>因此采用相对偏移Call就不会出问题，虽然加载基址变化，但整个模块是整体搬迁，call和被call之间的偏移却不变！所以无影响。</p><p>相对偏移的优点只能运用到同一个模块中（DLL，EXE），如果跨越了模块，调用DLL中的函数时，并不知道该模块会加载到哪里，因此，是不可能事先算出转跳偏移的，那怎么办？</p><p>这是在编译器和系统协助下，利用导入表机制完成了这个工作。简单说，就像为每个被调用的DLL函数都设定一个邮箱，系统加载了DLL后，利用导出表机制获得函数的地址（这个我们前面已经学习过了），然后将函数地址放到各自的邮箱中，这样，需要调某函数时，就从邮箱里拿到这个地址。</p><h3 id="理解导入表机制"><a href="#理解导入表机制" class="headerlink" title="理解导入表机制"></a>理解导入表机制</h3><p>在可选头的数据目录的第2项就是是导入表的描述，其中有导入表的RVA</p><p>RVA指向导入表（IMPORT DICTORY TABLE）起始，在这个地方，每一项是一个IMAGE_IMPORT_DESCRIPTOR结构，代表一个导入的DLL的相关信息。在这个结构中，又有：</p><blockquote><p> INT表（Import Name Table）和IAT表（Import Address Table）的RVA</p></blockquote><p><img src="/posts/41006/25.png" alt></p><p><img src="/posts/41006/26.png" alt></p><p>在一般情况下，INT（OriginalFirstThunk）和IAT（FirstThunk）的内容确实是相同的，因此，是冗余的。正是这个原因，为了节约空间，一些编译器（如Borland）不会生成INT，其RVA值为0。但是，这是在没有使用预先绑定导入地址的情况下，如果有预先绑定，则必须要有INT表，此时RVA不等于0。</p><p>由于程序在加载时，需要在IAT表中填入函数的加载地址入口，因此，往往会比较耗时，为了减少加载时间，于是有了预先绑定技术。</p><p>预先绑定技术是在编译时就向IAT表中填入导入地址（即函数的入口地址，而不是指向IMAGE_IMPORT_BY_NAME表项的RVA），它是直接根据系统DLL的预期基址（ImageBase）计算出来的。</p><p>通过预先绑定，在实际加载时，只要系统DLL的基址没有发生改变，那么IAT表的内容就不需要再次填充，因此，加载时速度更块。</p><p>所以，采用预先绑定，在实际加载时，需要验证DLL是否被加载到预期地址。如果，引用的DLL没加载到预期地址，那就必须再次填充IAT表为实际的函数地址。</p><p>这时，已经不能使用IAT表来指向IMAGE_IMPORT_BY_NAME表项了（编译时RVA已经被覆盖为函数预期入口地址），但INT表可以，通过INT表再次执行导入机制，从而使得IAT表内容更新。</p><p>这也就是为什么预先绑定时必须要有INT表的原因！</p><h2 id="第十四章-指令Patch实现与重定位表"><a href="#第十四章-指令Patch实现与重定位表" class="headerlink" title="第十四章-指令Patch实现与重定位表"></a>第十四章-指令Patch实现与重定位表</h2><h3 id="如何找到需要Patch的指令"><a href="#如何找到需要Patch的指令" class="headerlink" title="如何找到需要Patch的指令"></a>如何找到需要Patch的指令</h3><p>整体思路：</p><p>  为了找到需要Patch的指令，病毒可以采取以下的动作：</p><ol><li>首先指定一个会被大概率调用的函数名（也包括函数所在DLL的名字），如Kernel32中的GetCommandLineX，X=A/W</li><li>然后通过被寄生文件（exe）的导入表找到该函数的导入表项（即IAT中的对应项地址）的地址XXXX</li><li>最后去exe文件的代码中搜索所有可能的Call [XXXX] 或 JMP [XXXX]后，即 FF 15 XXXX 或 FF 25 XXXX </li></ol><p>详细来说：</p><ol><li>在文件中找到导入表的位置：先找到导入表的RVA，将RVA转换为导入表的文件位置</li><li>找到指定API函数在IAT表中的表项地址。先要找到API所在DLL对应的项，然后才能找到这个DLL所对应的INT和IAT表，比较dll的名字，判断是否是API函数所在DLL的导出表目录项，然后根据预先绑定，如果有INT就用INT表来找函数名，没有就用IAT表找函数名，获得INT表（或IAT表）的RVA，并将其转换为文件位置，遍历INT表（或IAT表）的每一项，查找指定的API函数名。</li><li>找到符合的指令进行Patch，先找到代码所在的节，判断节的属性是否有0x20，找到后开始循环遍历每个字节进行替换，并写入patch指令。</li></ol><h3 id="病毒执行部分的设计"><a href="#病毒执行部分的设计" class="headerlink" title="病毒执行部分的设计"></a>病毒执行部分的设计</h3><ol><li>我们准备patch调用GetCommandLineA或GetCommandLineW的函数，因为它们基本在入口处会被调用，这样可以保证病毒一开始就执行</li><li>为了防止函数再次调用时病毒再次执行，我们增加了一个标记</li><li>另外，感染时到底patch的是W还是A版的GetCommandLine，也有一个标记来告诉寄生的病毒代码，从而寄生病毒执行时才知道去找哪个函数的实际入口地址</li><li>寄生病毒执行时，找到函数地址后需要存储一下，因此，并分配了4字节存储GetCommandLineX（W/A）的入口地址。为了不修改老代码，数据区开始的原来13个字节没有删减，用于存放这3个信息。</li><li>在数据段增加了“GetCommandLineA”和” GetCommandLineW”串，因为要用getproc动态查找到其首址跳过去</li><li>增加了获取kernel32基址和获取GetCommandLineW/A的代码</li><li>最后用JMP指令跳到GetCommandLineW/A去</li></ol><p>关于最后跳转的问题，因为JMP跳转包含的地址是绝对地址（这是函数所对应的IAT表项的地址），如果在exe可重定位的情况下，这个xxxx地址是需要重定位的。然而，病毒尾部的这条Jmp [xxxx]是病毒添加的，因此，在重定位表中没有重定位项的，所以会出错。</p><blockquote><p> 解决的方法：添加重定位项或让exe不会重定位</p></blockquote><h3 id="利用IAT表项查找函数入口"><a href="#利用IAT表项查找函数入口" class="headerlink" title="利用IAT表项查找函数入口"></a>利用IAT表项查找函数入口</h3><p>除了修改节头的相关信息数据外，还要填充节直到长度达到要求</p><p>感染时填充数据区的预期加载地址，数据区的预期加载地址是：imagebase + 被感染节的起始RVA+virtualSize+5（自定位的call指令长度），数据区在call指令后</p><p>被调函数的IAT项的地址,Patch函数调用时，将获得IAT项地址返回，并将其作为参数传递给getCode函数，getCode函数将IAT项地址填入此处.</p><p>因为exe可能被重定位，所以IAT的地址可能变化，需利用病毒数据区的信息来定位IAT的实际地址。算法如下：</p><ol><li>call..pop自定位代码获取了数据区的地址A</li><li>数据区的预期加载地址=B= [A+1] </li><li>IAT表项的预期地址是[A+5]</li><li>IAT表项重定位后的实际地址是 IAT_addr – [A+5] = A – B</li><li>通过[IAT_addr]获得函数入口地址</li></ol><p>如此，则不需用再去调getproc查询函数入口地址</p><h3 id="PE文件的重定位机制"><a href="#PE文件的重定位机制" class="headerlink" title="PE文件的重定位机制"></a>PE文件的重定位机制</h3><p>程序因加载到非编译期约定地址时，就必需修改那些包含了绝对地址的指令（因为这些绝对地址已经不是原来的地址了），这称为程序重定位，由加载器（loader）完成</p><p>本来，exe是不需要重定位的，它是用户模块第一个进入进程空间的，它的约定加载基址，只要不过分（和系统DLL抢），都可以被满足</p><p>但因为为了对抗攻击和安全考虑，从VS2003开始，微软编译器缺省会将exe编译成可重定位模式</p><p>理解PE文件重定位的关键在于要解决两个问题：</p><ol><li>如何进行重定位呢？</li><li>加载器如何知晓哪些地方需要被重定位呢？</li></ol><h4 id="如何进行重定位"><a href="#如何进行重定位" class="headerlink" title="如何进行重定位"></a>如何进行重定位</h4><p>算法：</p><ol><li>实际和预期加载地址的差x = A – B。</li><li>找到需要修改的位置y</li><li>读出y开始4字节的值 + x = 新地址值z</li><li>将z写入y开始的4字节</li></ol><h4 id="如何知道哪些地方需要重定位"><a href="#如何知道哪些地方需要重定位" class="headerlink" title="如何知道哪些地方需要重定位"></a>如何知道哪些地方需要重定位</h4><ul><li>在可选头的数据目录中，有一项（第6项）就是重定位表，而重定位表中就记录了所有需要进行重定位修改的位置</li><li>因为被修改的都是地址值（32位机上4字节），所以在重定位表中，我们不需要记录每个修改位置要改多少字节，只需要记录被修改的位置即可，那么Loader每次就根据这个位置定位4字节进行修改（加上加载偏差）</li><li>需要重定位的区域以4096（2^12）字节（即16进制0x1000h）进行划分，在每个区域（Page）里面，每个需要重定位的位置都有相应的重定位项纪录了该位置离这个区域起始位置的偏移</li><li>针对每个区域，在重定位表中都有8字节的头部，其中前4个字节的值是这个<strong>重定位内存页的起始RVA</strong>，后4个字节是<strong>重定位块的长度</strong>（包括头和所有表项在内的字节数）</li><li>划分为区域后，重定位表中的每一项就只需要12位（1.5个字节）来表示地址，另外有0.5字节为属性（通常我们只能看见属性3，表示所指向的32位地址都需要修正）,即如300F，则00F为偏移。</li></ul><p>在我们Patch指令的过程中，我们将该指令修改为了不包含绝对地址的指令形式(即：Call 偏移，Jmp 偏移)，但并没有删除针对该指令的重定向项，那么重定位后，就会对这个重定位项指向的位置（即指向了我们Patch后的指令）进行修改，那么我们Patch后的指令就会被篡改！</p><blockquote><p>解决方法，让exe重定位项失效，或删除这些被Patch指令的重定位项</p></blockquote><h2 id="第十五章-反病毒技术简介"><a href="#第十五章-反病毒技术简介" class="headerlink" title="第十五章-反病毒技术简介"></a>第十五章-反病毒技术简介</h2><h3 id="反病毒技术的发展历程"><a href="#反病毒技术的发展历程" class="headerlink" title="反病毒技术的发展历程"></a>反病毒技术的发展历程</h3><p> <strong>第一代反病毒技术</strong></p><ul><li>采用单纯的病毒特征代码分析，清除染毒文件中的病毒</li></ul><p><strong>第二代反病毒技术</strong></p><ul><li>采用静态广谱特征扫描技术检测病毒，可以检测变形病毒，但是误报率高</li></ul><p><strong>第三代反病毒技术</strong></p><ul><li>将静态扫描技术和动态仿真跟踪技术结合起来，将查找病毒和清除病毒合二为一</li></ul><p><strong>第四代反病毒技术</strong></p><ul><li>基于病毒家族体系的命名规则、基于多位校验和扫描机理、启发式智能代码分析模块、动态数据还原模块、内存解毒模块、自身免疫模块等先进的解毒技术，较好的解决了以前防毒技术顾此失彼、此消彼长的状态，能够较好地完成查毒、解毒的任务</li></ul><h4 id="计算机病毒防治技术的划分"><a href="#计算机病毒防治技术的划分" class="headerlink" title="计算机病毒防治技术的划分"></a>计算机病毒防治技术的划分</h4><ul><li>病毒预防，防止病毒进入内存或阻止病毒对磁盘的操作</li><li>病毒检测，计算机病毒的判定</li><li>病毒消除，计算机病毒感染的逆过程，恢复被感染程序原有的结构信息</li><li>病毒免疫，可能并不存在通用的病毒免疫方法</li></ul><h4 id="病毒防治技术从被动到主动"><a href="#病毒防治技术从被动到主动" class="headerlink" title="病毒防治技术从被动到主动"></a>病毒防治技术从被动到主动</h4><ul><li>主动内核(Active K)技术，是在操作系统和网络的内核中嵌入反病毒功能，使反病毒成为系统本身的底层模块，实现各种反毒模块与操作系统和网络无缝连接，而不是一个系统外部的应用软件</li><li>主动内核技术能够实时监控整个系统的运行，并在病毒突破计算机系统软、硬件的瞬间发生作用</li></ul><h4 id="计算机病毒防范的概念"><a href="#计算机病毒防范的概念" class="headerlink" title="计算机病毒防范的概念"></a>计算机病毒防范的概念</h4><ul><li>计算机病毒的防范，就是要在<strong>病毒执行之前</strong>进行阻断，需要监视、跟踪系统内类似的操作，提供对系统的保护，最大限度地避免各种计算机病毒的传染破坏，往往需要基于全系统的<strong>内核级行为监控</strong></li></ul><h4 id="计算机病毒的预防措施"><a href="#计算机病毒的预防措施" class="headerlink" title="计算机病毒的预防措施"></a>计算机病毒的预防措施</h4><p>计算机病毒的预防措施可概括为两点</p><ul><li>勤备份</li><li>严防守</li></ul><h4 id="计算机检测技术分类"><a href="#计算机检测技术分类" class="headerlink" title="计算机检测技术分类"></a>计算机检测技术分类</h4><p>检测计算机病毒的方法通常有两种：</p><ol><li><p>手工检测</p><p>优点：可以剖析病毒、可以检测一些自动检测工具不能识别的新病毒</p><p>缺点：费时费力，复杂</p></li><li><p>自动检测</p><p>优点：可方便地检测大量的病毒</p><p>缺点：自动检测工具的发展总是滞后于病毒的发展</p></li></ol><h3 id="常见计算机病毒的诊断方法及原理"><a href="#常见计算机病毒的诊断方法及原理" class="headerlink" title="常见计算机病毒的诊断方法及原理"></a>常见计算机病毒的诊断方法及原理</h3><p><strong>一、比较诊断法</strong></p><p>用原始的正常备份与被检测的内容进行比较</p><p><strong>优点</strong>：比较法不需要专用的反病毒软件，且可以检测未知病毒</p><p><strong>缺点：</strong></p><p>- 该方法依赖与未染病毒时的原始系统的备份</p><p>- 且无法知道病毒的种类名称</p><p>- 易于误报</p><p><strong>二、校验和诊断法</strong></p><p>根据正常文件的信息计算其校验和（checksum），计算新的校验和与原来保存的校验和是否一致</p><p>运用校验和法查病毒一般采用三种方式：</p><ol><li>对被查的对象文件计算其正常状态的校验和，将校验和值写入被查文件中或检测工具中，而后进行比较</li><li>在应用程序中，放入校验和法自我检查功能，实现应用程序的自检测</li><li>将校验和检查程序常驻内存，每当应用程序开始运行时，自动比较检查应用程序内部或其他文件中预先保存的校验和</li></ol><p><strong>优点：</strong>校验和法既能发现已知病毒，也能发现未知病毒</p><p><strong>缺点</strong>：不能识别病毒种类与名称，对某些对文件信息影响不大的病毒效果较差，如链式病毒；同比较法一样，病毒感染并不是文件改变的唯一原因，所以此法会产生误报</p><p><strong>三、扫描诊断法</strong></p><p><strong>原理</strong>：扫描法是用每一种病毒体含有的特定病毒码(Virus Pattern)对被检测的对象进行扫描。如果在被检测对象内部发现了某一种特定病毒码，就表明发现了该病毒码所代表的病毒</p><p> - 特征代码扫描法</p><p> - 特征字扫描法</p><p>特定病毒码：当杀毒软件公司收集到新病毒中，就会从病毒程序中截取一小段独一无二且足以标记该病毒的二进制程序码（就好比犯人的指纹）</p><p>扫描法的软件通常由两部分组成：</p><p> - 病毒代码库，库中特征码的数量决定了扫描程序的识别能力</p><p> - 扫描程序（Scanner）</p><p>扫描法是当前最普遍的病毒检测方法，扫描法的核心——病毒特征码的选择</p><p>特征码选择的原则：</p><p>1.具有代表性：小的病毒一百多字节，长的10KB</p><p>2.不应包含数据区，数据区是可变的</p><p>3.特征码的长度：过长带来扫码时间和空间的开销过大，过短则不易具有代表性（两个相互矛盾的目标）</p><p>4.具有区分性：能区别该病毒和其他病毒，更重要的是要能区分病毒和正常程序，避免误报！</p><p><strong>优点</strong>：</p><p>使用方便；特征码选择好则误报率低、选择不好则误报率高</p><p>不用专门查毒软件；可识别病毒名称和类别；可做扫毒处理</p><p><strong>缺点</strong>：</p><p>特征码的生成难度很大；扫描需要开销；需要不断更新病毒特征码库</p><p>不易识别多态变形病毒、不能检测未知病毒等</p><p><strong>四、行为监测诊断法</strong></p><p><strong>原理</strong>：利用病毒的特有行为特性监测病毒的方法，称为行为监测法</p><p><strong>优点</strong>：即能发现已知病毒，也能发现未知病毒</p><p><strong>缺点</strong>：误报，不能识别病毒名称和种类，需要病毒运行以后才能进行分析</p><p><strong>五、感染实验诊断法</strong></p><p><strong>原理</strong>：利用病毒最基本的特征——感染特征，所有病毒都会进行感染，如果不感染，就不称其为病毒</p><p>当系统中出现了异常行为，最新版的检测工具也查不出病毒时，就可以做感染实验，其方法是：</p><p>将正常的文件放入异常的系统中去运行，看这些正常文件是否会被感染，如果被感染，则文件内容会发生变化（通过校验和等检测），则断言系统中存在病毒</p><p><strong>优点</strong>：可以发现未知的病毒</p><p><strong>缺点</strong>：实验开销大，实用性较差</p><p><strong>六、软件模拟诊断法</strong></p><p>多态病毒每次感染都变化其病毒代码，对付这种病毒，特征码扫描法失效。我们把使用通常特征码扫描法无法检测（或几乎很难检测）的病毒称之为多态病毒。但是，每一个多态病毒在执行时都需要还原，如先执行一段解密代码进行解密，再执行解密后的病毒代码。</p><p>通过在一个模拟的虚拟环境下运行计算机病毒，等待计算机病毒自身进行解密完成后，再对解密后的病毒代码实施特征码的识别，识别病毒种类后再进行有相关的清除和查杀工作。</p><p><strong>七、分析诊断法</strong></p><p>分析法一般只被专业反病毒技术人员使用，使用分析法的目的在于：</p><p> - 确认被观察的引导扇区和程序中是否含有病毒 </p><p> - 确认病毒的类型和种类，判定其是否是一种新病毒</p><p> - 搞清楚病毒体的大致结构，提取特征识别用的字符串或特征字，并增添到病毒代码库供病毒扫描和识别程序使</p><p> - 详细分析病毒代码，为制定相应的反病毒措施制定方案</p><p>分析法是任何一个性能优良的反病毒系统研发所必须的，它是对病毒进行详尽认真的分析，专业人员需要了解PE文件格式、病毒的核心技术原理、汇编语言、Windows程序设计、软件调试方法等相关知识，还需要进行病毒样本收集、系统漏洞分析等工作。</p><p>分析法通常包括静态分析和动态调试两个步骤，Windows上一般的调试工具主要有OD、WinDBG、X64DBG等，对复杂的病毒程序，必须采用动、静结合的分析方法。</p><h3 id="启发式代码扫描技术"><a href="#启发式代码扫描技术" class="headerlink" title="启发式代码扫描技术"></a>启发式代码扫描技术</h3><p>启发式代码扫描技术是对传统的特征码扫描技术的改进，来源于人工智能技术</p><p><strong>原理</strong>：启发式代码扫描技术基于给定的判断规则和定义的扫描技术，若发现被扫描程序中存在可疑的程序功能指令，则作出存在病毒的预警或判断。</p><ol><li>可疑程序功能的权值定义</li><li>可疑程序的报警标准</li><li>可疑功能的标志</li></ol><h3 id="虚拟机查毒技术"><a href="#虚拟机查毒技术" class="headerlink" title="虚拟机查毒技术"></a>虚拟机查毒技术</h3><p>全虚拟化技术：虚拟的操作系统，与底层的硬件完全隔离，完全由中间的Hypervisor层（VMM）完成指令转换和资源映射，典型的代表有Vmware，WorkStation，Microsoft Virtual Server等</p><p>半虚拟化技术：需要在虚拟机的操作系统中加入特定的虚拟化指令（Hypercalls），通过这些加入的指令来调用硬件资源，免除了一部分Hypervisor层转换指令的开销。典型的代表有Xen等。</p><p>查毒的虚拟机是一个软件模拟的CPU，它可以象真正CPU一样取指令、译码、执行，可以模拟一段代码在真正CPU上运行得到的结果</p><p><strong>原理</strong>：虚拟机查毒实际上是自动跟踪病毒入口的解密代码，当其将加密的病毒体按其解密算法进行解密后，就可以得到解密后的病毒明文，虚拟执行技术使用范围远不止脱壳解密，它还可以应用在跨平台高级语言解释器、恶意代码分析、调试器等</p><p>目前有两种方法可以跟踪控制病毒的每一步执行，并能够在病毒循环解密结束后从内存中读出病毒体明文</p><ol><li>单步和断点跟踪法，和目前一些程序调试器相类似：易于被病毒发觉</li><li>虚拟执行法：  控制权永远掌握在虚拟机手中，但完全模拟CPU的运行并非易事，虚拟执行法的意味必须在虚拟机内部处理所有指令的执行，这就需要具有大量的特定指令处理函数来模拟每种指令的执行效果，因此，虚拟机必须要保证模拟结果的正确性，但同时不可能被病毒察觉，且做到了完全虚拟执行</li></ol><p>虚拟机模拟指令执行的设计方案：</p><ol><li>自含代码虚拟机(SCCE)：类似真正的CPU</li><li>缓冲代码虚拟机(BCE)：进行了特殊指令和非特殊指令的区分</li><li>有限代码虚拟机(LCE)：只简单地跟踪一段代码的寄存器内容</li></ol><h4 id="反虚拟执行技术"><a href="#反虚拟执行技术" class="headerlink" title="反虚拟执行技术"></a>反虚拟执行技术</h4><p>1.<strong>插入特殊指令技术</strong></p><p><strong>原理</strong>：虚拟机是模拟CPU的执行，并不是真正的CPU，所以不可以能对整个Intel的指令集进行支持，遇到不认识的指令就会停止工作</p><p><strong>应对</strong>：不需要针对每个特殊指令写专门的模拟函数，只需要构建特殊指令的指令长度表，当EIP指向特殊指令时，就跳过特殊指令长度，或者发现这些特殊指令时，交由CPU去真正执行</p><p>2.<strong>结构化异常处理技术</strong></p><p><strong>原理</strong>：虚拟机仅仅模拟了CPU的工作过程，而对于异常处理等系统机制没有进行处理，虚拟机会在遇到非法指令、进入异常处理函数前停止工作</p><p><strong>应对</strong>：为虚拟机赋予发现和记录异常的功能，并在引发异常时将控制转向异常处理函数</p><p><strong>3.</strong> <strong>入口点模糊技术（EPO）</strong></p><p><strong>原理</strong>：即便是虚拟执行，也不可能查找文件的所有代码，虚拟执行通常会在规定步数内，检查待查文件是否具有解密循环，如果没有，就会判定该文件没有携带加密变形病毒，产生漏报</p><p><strong>应对</strong>：合理的增加检查的规定步数，如果规定步数较小，极易产生漏报，但规定步数也不能盲目增加，否则会无谓增加检测时间，如何确定规定步数的大小实在是件难事</p><p><strong>4.</strong> <strong>多线程技术</strong></p><p><strong>原理</strong>：虚拟对于模拟启动多线程的工作很难与真实效果一致，多线程切换需要交由下层操作系统负责管理，虚拟机只能在被执行线程独占CPU时间</p><p><strong>应对</strong>：改进虚拟机，支持这些特定的操作系统机制</p><h3 id="病毒实时监控技术"><a href="#病毒实时监控技术" class="headerlink" title="病毒实时监控技术"></a><strong>病毒实时监控技术</strong></h3><p>病毒实时监控本质上是一个文件监视器：</p><p><strong>原理</strong>：在文件打开、关闭、清除、写入等操作时检查文件是否是病毒携带者，如果是则根据用户的决定选择不同的处理方案，如清除病毒、禁止访问该文件、删除该文件或简单地忽略，从而有效地避免病毒在本地计算机上的感染传播</p><p>可执行文件装入器在装入一个文件执行时首先会要求打开该文件，而这个请求又一定会被实时监控在第一时间截获到，它确保了每次执行的都是干净的不带毒的文件从而不给病毒以任何执行和发作的机会</p><h3 id="计算机病毒的清除"><a href="#计算机病毒的清除" class="headerlink" title="计算机病毒的清除"></a>计算机病毒的清除</h3><p>引导型病毒感染时常攻击计算机的如下部位：</p><ol><li><p>硬盘主引导扇区</p></li><li><p>硬盘或软盘的BOOT扇区</p><p>为保存原主引导扇区、BOOT扇区，病毒可能随意地将它们写入其他扇区，而彻底毁坏这些扇区中的信息</p><p>引导型病毒发作时，执行破坏行为造成种种损失</p><p>由于引导型病毒一般是常驻内存的，因此，清除病毒之前必须先清除内存中的病毒(或采用修复中断向量表等方法将其灭活)，否则难以清除干净</p></li></ol><h3 id="计算机病毒免疫技术"><a href="#计算机病毒免疫技术" class="headerlink" title="计算机病毒免疫技术"></a>计算机病毒免疫技术</h3><p><strong>重入检测和病毒免疫</strong></p><p>  大部分驻留内存的病毒会在加载病毒代码之前，检查系统的内存状态，判断内存中是否有病毒，若存在(自身已被加载)，则不再加载病毒代码</p><p>  感染文件之前，查看文件的状态(一般是查看感染标志)，检查该文件是否已被感染，如果被感染了则不再重复感染</p><p>   病毒的这种重入检测机制导致了一种反病毒技术的出现，也就是形形色色的免疫程序：利用免疫程序设置内存的状态、设置CPU的状态或者设置文件的一些特征，从而防止某种特定的病毒进入系统</p><p>目前常用的免疫方法有两种：</p><ol><li><p>针对某一种病毒进行的计算机病毒免疫</p></li><li><p>基于自我完整性检查的计算机病毒免疫</p></li></ol><h2 id="不负责猜题"><a href="#不负责猜题" class="headerlink" title="不负责猜题"></a>不负责猜题</h2><p>计算机病毒的定义?</p><blockquote><p>编制或者在计算机程序中<strong>插入</strong>的破坏计算机功能或者毁坏数据，影响计算机使用，并能自我复制的一组计算机指令或者程序代码。</p></blockquote><p>病毒的基本特征？</p><ul><li>传染性</li><li>隐蔽性</li><li>可触发性</li><li>其他一些基本特性<ul><li>破坏性</li><li>针对性</li><li>不可预见性</li><li>寄生性</li><li>衍生性</li><li>持久性</li></ul></li></ul><p>计算机病毒的本质属性?</p><blockquote><p>人为的<strong>特制程序</strong>是任何计算机病毒的<strong>固有本质属性</strong></p><p>程序性的<strong>客观性</strong>决定了计算机病毒的可防治性和可清除性</p><p><strong>人为性</strong>的<strong>主观性</strong>导致计算机病毒各异多变</p></blockquote><p>木马和蠕虫的概念：</p><blockquote><p>蠕虫:独立的可执行程序, 不需要寄生在宿主程序中，通过网络分发自己的副本，工作方式为：漏洞扫描、远程攻击、迁移传染、现场处理</p><p>木马：在远程计算机之间建立连接，使得远程计算机能通过网络控制本地计算机的非法程序。木马系统软件一般由木马配置程序、控制程序和木马程序(服务端)三部分组成。</p></blockquote><p>小端机和大端机？</p><blockquote><p>整数逻辑上的最低字节放在内存的最低地址，次低字节放内存的次低地址，依次存放。比如，0x12345678（12为高位）放在内存中就是78 56 34 12(最左边为低字节)。大端机则相反</p></blockquote><p>JMP指令计算偏移量？</p><blockquote><p>从JMP指令的开始计算，直接加5。或者说是从JMP的下一条开始的指令算起被减数。</p></blockquote><p>文件系统（重点）</p><blockquote><p>一个FAT9个扇区，引导扇区1个，根目录区有224条记录，一个记录32字节，一个表项1.5字节</p><ul><li>数据区中存放用户数据,是文件和子目录数据真正存放的区域</li><li>根目录区中存放的是文件目录表,为记录根目录文件项的表，文件项包括文件，目录。通过它可以查找到根目录下的文件和目录信息，比名称，大小，日期等</li><li>FAT12为<strong>文件分配表</strong>（FAT（File Allocation Table））：记录已分配的扇区和可用扇区，并通过链表依序记录一个文件占用的扇区,另外一个FAT12为备用的FAT表</li><li><strong>引导扇区</strong>（DBR （DOS Boot Record））：记录磁盘和文件系统相关的各种参数，比如扇区大小，一簇的扇区数等</li></ul></blockquote><p><strong>如何定位一个文件？</strong></p><blockquote><p>FAT12文件系统中，FAT表以3个<strong>半字节</strong>（3*0.5 Byte = 1.5 Byte = 12 bit）来记录一个簇的相关情况，这也是“FAT12“文件系统中命名12的原因。</p><p>FAT表的本质是磁盘簇分配情况的数据表示，FAT表中每3个半字节为一个元素，这个元素就代表一个簇，簇号从0开始，这个元素中存放的整数值表示其链接的下一簇的簇号</p></blockquote><ul><li>查找和遍历</li></ul><blockquote><p>类似于链表的查找，以FFF为结尾，FAT12默认设置引导区占一个扇区，FAT1于其后，同时FAT表开始的3个字节没用于用户文件分配，3字节有2组12bits所以，占用了0,1两个簇号，用户的数据从簇2开始分配。</p><p>随后FAT表从头开始按3字节分成一组，但是有一点需要特别注意：</p><p>在这3个字节中，用第2字节的低半字节和第1字节形成整数表示一个簇号，用第2字节的高半字节和第3字节形成的整数来表示另一个簇号</p><p>由上面学习的内容知道，在FAT表中想要开始遍历就必须知道首簇号，而首簇号位于根目录区域中。</p></blockquote><blockquote><p>计算根目录区的起始位置为：<strong>[ 1（Boot区扇区数）+2（FAT数目）*9（FAT扇区数）] * 512 = 0x2600</strong></p><p>每一条记录，从该记录开始偏移0xB处有个字节指示出文件的类型，对于多级目录来说，则是存放在数据区内，原理和根目录查找目录类似，只不过是多层嵌套，查找到的是另一个目录表。</p></blockquote><p>查找<strong>a:\tem\tem.txt</strong>为例：</p><p><img src="/posts/41006/2.png" alt></p><p>如何恢复只有一个簇的文件？</p><blockquote><p>文件内容不会因删除而改动。而对应文件的项只是将第一个字节改成E5，其首簇段的值也不会该动</p><p>在目录表中找到E5开始的相关文件名，从该项的首簇字段（0x1A）获得首簇，然后，在FAT表中对应的簇项改成FFF即可</p></blockquote><p><strong>FAT12和FAT32的区别</strong></p><blockquote><ul><li>FAT32的一个重要不同在于<strong>取消了根目录区</strong>，根目录在用户区，且FAT32引导记录中有一个指向根目录区的首簇字段</li><li>fat32支持长文件名而fat12不支持(FAT12文件名固定11字节，其中3字节用于后缀)</li><li>fat12一个表项占1.5个字节而fat32一个表项占4个字节</li><li>fat32有保留区而fat12没有</li><li>FAT32的记录项中的首簇号，由两个字段构成，分别代表高位两字节和低位两字节</li></ul></blockquote><p>硬盘数据结构</p><p>MBR和EBR</p><blockquote><p><strong>扩展分区</strong>核心思想是：形成一个分区链，MBR定义的主分区表本来有4条分区记录，用一条描述自己分区的信息，用剩余的指向下一个分区。</p><p>为了完全兼容MBR的格式，EBR完全复用了引导扇区的格式，即起始446字节给引导记录EBR，但在EBR中，这些内容全为0。</p><p>主分区的相对扇区相对于MBR，通过MBR和相对扇区就可以定位每一个主分区</p></blockquote><p><img src="/posts/41006/7.png" alt></p><blockquote><p>首先找到C盘，找到主引导扇区的分区表，找到分区的相对偏移扇区数，扩展分区1是MBR的主扩展分区，它的EBR放在主扩展分区的开始处</p><p>找到扩展分区1的EBR。</p><p>随后查找扩展分区1上的基本分区E盘，</p><p>同理查找扩展分区2的EBR和分区表</p><p>最后利用相对偏移字段和首部偏移查找F盘的起始位置</p><p>注意EBR是相对于包含该分区表的扩展区开始处而言（扩展分区开始处为其EBR），在扩展分区的分区表中，第一项的偏移指向的是盘区，第二项的偏移指向的是下一个扩展分区开始处（也就是下一个扩展分区的EBR）</p></blockquote><p>硬盘的引导过程</p><p>分区表项的第一个字节0x80表示激活</p><blockquote><ul><li>开机加电自检：开机，CPU跳到内存FFFF:0000处，由该处的一条JMP指令跳到BIOS的自检程序（POST），自检通过后，加载引导程序（与操作系统无关的MBR，按用户在BIOS中的指定顺序，硬盘、软盘、光驱或U盘等</li><li>读主引导扇区：将主引导扇区MBR读入到内存的0000:7C00，扫描主分区表，搜索激活分区，分区表项第一个字节为0x80表示激活分区</li><li>读激活分区引导扇区 ：如果有多个激活分区或没有，报错结束。否则读取激活分区引导扇区到0000:7c00</li><li>操作系统引导代码引导系统并读取操作系统初始化文件</li></ul></blockquote><p>MBR代码拷贝的问题</p><blockquote><p>MBR的这段代码会被加载到7C00处，这段代码的主要任务是什么呢？是找到激活分区（如C盘）并将真正C盘的引导扇区加载到7C00处（也就是拷贝），这必然覆盖已经在内存7C00处的MBR自己，当自己正在拷贝的另外的指令覆盖自己时，必然破坏了自己的指令执行逻辑。</p><p> 所以，要错开<strong>MBR引导程序</strong>和<strong>激活分区引导程序</strong>占用的内存空间范围，让MBR的引导程序在600h执行，而它拷贝的激活分区引导程序将在7C00h执行</p></blockquote><p>头插入病毒遇到的问题</p><blockquote><p>需要去掉病毒代码最后的RET指令，否则原本的COM文件得不到执行机会</p><p>病毒代码执行结束后需用一条JMP指令跳过病毒数据区</p><p>加载后的实际内存位置后移, 后移长度就是virus.com的机器码长度</p><p>将源程序复制到原先的位置时候需要避免自我覆盖</p></blockquote><p>尾插入中的思路</p><blockquote><p>1） 构造一个打印的正常代码normal.com</p><p>2）构造一个寄生在normal.com尾部的病毒代码virus.com</p><p>3）用DOS的拷贝命令将两个编译好的程序粘起来</p><p>4）将normal.com开始的3字节作为数据保存到virus.com的代码某部分，然后将normal.com开始的3字节修改（先用UE手动修改）为JMP XXXX（跳到virus.com指令处）。</p><p>5）virus.com打印“I am virus”后，将normal.com开始的3字节进行还原，并JMP到normal.com开始，将执行权限交给normal.com</p></blockquote><p>为什么计算机病毒往往需要重定位技术？病毒重定位技术的关键技术原理是什么？以下重定位代码中，语句（1）-（4）在变量Message重定位过程中发挥的作用分别是什么？</p><pre><code>（1） call base base:（2） pop bp（3） sub bp, base​     mov ax, bp（4） add ax, Message</code></pre><blockquote><p>病毒的寄生会导致指令所在位置发生变化，从而导致预期加载地址和实际地址不一致的情况；知道一条指令<strong>运行时的地址值</strong>和<strong>编译时的地址值</strong>，相减即可；</p><p>Call指令的下一条指令是pop ax，call执行时，首先会把pop ax指令的IP（即pop ax这条指令的实际地址）<strong>压栈</strong>，然后根据<strong>相对偏移</strong>跳到标号here处；</p><p>标号base处就是pop bp指令，执行这条<strong>出栈</strong>指令会把栈中数据放入bp中，也就是pop bp指令的IP，利用栈获得了IP的值</p><p>Sub语句中的标号base在编译时就生成了地址，但是是<strong>预期地址</strong>,现在，实际地址-预期地址，ax中放的就是加载偏差了</p><p>将编译期要用的的地址，比如字串的首址加上ax就是字串实际地址了</p></blockquote><p>逆插入病毒</p><blockquote><p>与前面不同，我们需要添加一段完成感染寄生的代码，但这段代码自身不寄生在原文件上，它只需要完成以下功能：</p><p>1.把正常程序向后拷贝HdrVirus长度</p><p>2.把HdrVirus部分拷贝到前面</p><p>3.把EndVirus部分拷贝到后面</p></blockquote><p><img src="/posts/41006/9.png" alt></p><blockquote><p>头病毒部分因为存在加载偏差,需要重定位,并且需要为尾病毒拷贝设置参数.</p><p>重定位有关的代码在头病毒部分已经设置完成,因此不需要额外设置.</p></blockquote><p>感染部分思路</p><blockquote><p>1 ）获取原文件大小，后续写入需要</p><p>-———————————————</p><p>2 ）将原文件扩容，增加hdrvirusSize（头病毒部分长度）个字节，通过在原文件的尾部写字节完成</p><p>-———————————————</p><p>3 ）原文件向后拷贝hdrvirusSize长度，腾出空间给头病毒部分。注意：原文件应从尾至头完成拷贝，如果采取从头至尾的拷贝，则当原文件大小&gt;移动长度时，就会产生覆盖</p><p>-———————————————</p><p>4）将HdrVirus部分写入头部</p><p>-———————————————</p><p>5）将EndVirus部分写入尾部</p><p>不用事先扩容，写直接完成扩容</p></blockquote><p>引导型病毒</p><blockquote><p><strong>执行过程：</strong>病毒先把自己加载到7C00h，然后又把原引导程序拷贝到7C00h，这个过程会出现什么问题？就是前面遇见的<strong>自我覆盖</strong>问题，所以需要将病毒中执行拷贝的指令段移出被覆盖的区域。我们可以将它后移一个扇区7e00h处</p><p><strong>感染过程：</strong>感染会将原引导扇区的内容一直放到簇2，如何避免后续使用占用簇2，破坏了病毒的逻辑？可以修改FAT1和FAT2表，将簇2的项改成不可使用，如果改为已占用FFF，但却没有对应的目录项，是可疑的，因此，可以改为坏簇FF7，从而防止别人使用它。这些感染，为了简单，没有采用汇编访问硬盘的方式，而是采用C语言来直接修改软盘文件。</p></blockquote><p>中断替换</p><blockquote><p>病毒篡改中断向量表内容指向Hook，Hook函数执行完自己的逻辑后在正常跳回到中断处理程序处，并将原地址协会中断向量表中，当病毒和中断向量表在<strong>不同的段</strong>时，约定AX放段内偏移，CX放段地址。若需要内存驻留则直接调用DOS提供的驻留退出中断int 27h</p></blockquote><p>链式病毒思路</p><blockquote><p>病毒在感染时，完全不改变宿主程序本体，而是改动或利用与宿主程序相关的信息，将病毒程序与宿主程序连成一体。</p><p><strong>一、感染部分</strong></p><ul><li>被感染文件的真实起始扇区号写到<code>目录表项的保留区</code>（目录项的保留区从目录项头第13个字节即偏移0ch开始，共10字节）</li><li>修改被感染文件的目录项的<code>起始扇区字段</code>指向病毒文件的首簇</li><li>目录项中的<code>文件大小字段</code>也要修改成病毒的真实大小，这样才能保证病毒能被完整加载</li><li>将原来病毒文件的目录项全部32字节改为0，这样从外部看就不存在这个病毒文件，也没有对应的目录项了</li></ul><p><strong>二、执行部分</strong></p><ul><li>病毒运行后，先获取被<code>感染程序的名字</code></li><li>然后从根目录寻找<code>被感染程序的目录项</code></li><li>找到后从该目录项的保留区获取<code>被感染程序的首簇号</code></li><li>找到被感染程序所在簇（即扇区），加载该扇区到内存</li></ul></blockquote><p>PE结构，如何从一个PE文件中找到程序入口的文件地址的方法</p><p><img src="/posts/41006/19.png" alt></p><blockquote><p>寻找可选头中的 AddressOfEntryPoint，利用RVA找到该值所属的节，如果该节的起始RVA和该节的起始文件偏移相等则直接作为偏移，否则利用偏移量计算出新的值</p><p>（入口点的RVA（AddressOfEntryPoint）- 节的RVA = 入口点的FOA - 节的起始文件位置（PointerToRawData） )</p><p>随后寻找可选头中另外一个字段<strong>ImageBase</strong>，即程序约定加载地址，该地址加上入口点偏移</p><p>程序入口地址VA：ImageBase+AddressOfEntryPoint</p></blockquote><p>RVA和FOA的联系与区别</p><blockquote><ul><li>RVA是内存的相对位置，相对的是加载到内存的基地地址</li><li>FOA是文件中的相对位置，相对的是文件开始位置（即0）</li></ul></blockquote><p>用程序完成末段大小不变的寄生</p><blockquote><ol><li><p>生成需要寄生的病毒代码</p></li><li><p>获得被感染文件的NT头</p><ol><li>利用DOS头的e_lfanew字段（文件定位）</li><li>定位NT头，读到ntHrds（文件定位读）</li></ol></li><li><p>找到最后一个节判断是否具有空洞</p><ol><li><p>如何判断节是否有空洞？</p><p><strong>virtualSize &lt; SizeofRawData</strong></p></li><li><p>这些信息在哪里？</p><p><strong>最后一个节的节表项中</strong></p></li><li><p>当前的文件指针在什么地方？</p><p><strong>之前读了NT头，现在在NT头的后面也就是节表的起始文件位置</strong></p></li></ol></li><li><p>修改最后一个节VirtualSize写入病毒</p></li><li><p>修改SizeofImage和EntryPoint</p></li></ol></blockquote><p>入口点模糊技术(Entry Point Obscuring)</p><blockquote><p>每个节的节表项有一个characteristics属性,说明了该节是干什么的,当IMAGE_SCN_CNT_CODE为20时说明是代码节. EPO技术能够让病毒代码隐藏自己入口点，避免被查杀,使得被病毒修改后的入口点看起来依然就像是正常的入口点.</p><p>解决入口点不在代码段的问题，我们可以采用下2种解决方法：</p><p>1）不感染最后一节，直接感染代码节，病毒代码附着在代码节的尾部，再修改入口点。这样虽然修改了入口点，但让入口点处于代码节</p><p>2）不修改入口点，但将入口点所在的指令替换成一条JMP指令，跳往到寄生的病毒代码</p></blockquote><p>感染在代码节的空洞</p><blockquote><ol><li><p>生成需要寄生的病毒代码</p></li><li><p>获得被感染文件的NT头</p></li><li><p>找到代码节并判断是否具有空洞</p><p>如何找到代码节？遍历所有节表项并判断节表项的属性是否有20属性</p></li><li><p>修改VirtualSize写入病毒</p></li><li><p>修改SizeofImage和EntryPoint</p></li></ol></blockquote><p>感染最后节并替换入口指令</p><blockquote><ol><li>修改原入口点的数据为JMP指令</li><li>保存被覆盖的5个字节</li><li>执行逻辑</li><li>恢复这5个字节<ul><li>源地址就是被覆盖的5个字节，放在数据区，所以我们把可以把<strong>数据区的起始地址</strong>也作为数据放入数据区</li><li>目的地址是原程序的<strong>入口点地址</strong>，寄生后，病毒的main函数就结束了，所以这个<strong>入口点地址</strong>也需要写入数据区时</li></ul></li><li>最后一条JMP跳回原入口点</li></ol></blockquote><p>ImageBase是程序<strong>预期</strong>加载的基地址，win7系统和vs编译器往往都采用了随机地址空间技术，使得程序即每次加载的<strong>实际</strong>地址并不是ImageBase，原文件有重定位表这样的机制帮助重定位，但病毒只能利用前面我们学到的<strong>自定位</strong>技术原理。</p><p>病毒真正获取API函数地址的方法</p><blockquote><p>一、获取DLL基址</p><p>只有找到DLL基地址，我们才能找到它的导出表，才能找到所要调用函数的地址,利用PEB结构（Process Environment Block，进程环境块）查找，每个进程都对应一个PEB。然后，PEB结构保存着另外一个指针，该指针指向一个叫PEB_LDR_DATA的结构</p><p>这个PEB_LDR_DATA 偏移0C处是<strong>加载模块链表</strong>的头指针，由8个字节组成，前4个字节指向一个LDR_MODULE结构体（LDR_MDOULE代表一个模块，每一个模块（exe,dll）都对应一个这样的结构体），在该LDR_MODULE中，头4字节又指向下一个加载的LDR_MODULE结构体，由此组成链表。</p><p>在win7下，第一个加载的模块是是执行程序本身，第2个是NTDll，第3个就是kernel32，在结构体偏移0x18处就是所对应模块的基址。</p><p><strong>那如何在遍历的过程中识别模块呢？</strong></p><p>在LDR_MODULE结构体偏移0x2C的地方，有一个成员BaseDllName，它有8个字节，其中后4字节为地址，指向一个unicode串（每个字符占2个字节），这个unicode串就是不包含路径的纯模块名。</p><p>遍历的结束条件是什么？Next指针为0或者ffffffff么？都不是，过调试我们可以发现，在win7下，加载模块链形成了一个循环链表，因此只要发现next块的头4字节是头块地址就停止遍历。</p><p> 二、获取DLL中的函数地址</p><p>找到基址后，我们必须手动完成由函数名获取其所在DLL中地址的过程，我们需要从DLL的实际基址入手，解析DLL的导出表，获取相关函数的入口地址。</p></blockquote><p>导出表—DLL对外暴露函数地址的机制</p><blockquote><p>序号查找</p><p>序号查找的好处：快！高效！</p><p>我们可以用一个简单的hash完成，而不需要遍历，如果我们用一个数组（funcEntryTb）存储函数的入口地址。第0号函数的入口地址就存入数组的第一个元素funcEntryTb[0]，第1号函数的就存入数组的第2个元素funcEntryTb[1]。这样获取入口地址非常简单 ，即funcEntryTb[n]，n是函数的序号，也就是拿到数组首址funcEntryTb加偏移n*4（每个地址4个字节）即可。类似DOS下的中断向量表。</p><p>如果序号不是从0开始，而是从n开始，我们依然是将n对应函数的入口地址存入第一个元素，依次类推。获取第M（M肯定大于n，因为n最小）号函数的地址如下： funcEntryTb[m - n]。依然非常快速，计算次数固定，即拿到首址funcEntryTb，做一次减法m-n，再做一次乘法(m - n)*4就获取到元素的地址，取出其值保存值即可。这其实也是c语言switch语句出来case中序号和case分支入口地址的方法，所以一般switch比if else嵌套快</p><p>但是序号查找不够直观，同时也不够稳定</p><p>用函数名查找</p><p>用函数名查找：直观！具体！</p><p>最简单的办法就是一个一个函数名字串比较，找到相同的串。下面给出一个简单实现：函数名表的索引和函数地址表的索引是一一对应的。如果查找func2函数地址，我们先遍历函数名表，每遇到\0就是一个串，自然，在第2串处找到了字串func2，fun2是函数名表第2项，索引为1，然后我们用索引1在函数地址表中获得了address2，函数地址表4字节一个元素<strong>通过两个表相同的索引建立关联</strong>。</p></blockquote><p>导出函数查找算法</p><blockquote><ol><li><p>从DLL加载的<strong>实际基址</strong>获取可选头，从其中<strong>数据目录表</strong>的第一项找到导出表入口RVA</p></li><li><p>从导出表的表头获取Number of names，即查找的最大循环次数</p></li><li><p>循环遍历<strong>函数名指针表</strong>，比对每项RVA指向的字串是否为要找的函数名</p><p><code>函数名指针表1项4字节 à 对应的字符串地址</code></p></li><li><p>如果找到，记下此时函数名指针表项的索引，设为 i</p></li><li><p>根据索引 i，在<strong>序号表</strong>中找到对应项，获取其内容为n</p><p><code>序号表1项2字节</code></p></li><li><p>以n为索引在<strong>函数地址表</strong>中找到函数入口的RVA，加上DLL的实际基址即为函数的实际入口地址</p><p><code>地址表1项4字节</code></p></li></ol><p>注：以上算法中，所有访问实际地址的地方，就用<code>DLL的实际加载基址+RVA</code>即可</p></blockquote><p>导入表机制</p><p>RVA指向导入表（IMPORT DICTORY TABLE）起始，在这个地方，每一项是一个IMAGE_IMPORT_DESCRIPTOR结构，代表一个导入的DLL的相关信息。在这个结构中，又有：</p><blockquote><p>INT表（Import Name Table）和IAT表（Import Address Table）的RVA</p></blockquote><p><img src="/posts/41006/25.png" alt></p><p><img src="/posts/41006/26.png" alt></p><p>如何找到需要Patch的指令</p><blockquote><ol><li>在文件中找到导入表的位置：先找到导入表的RVA，将RVA转换为导入表的文件位置</li><li>找到指定API函数在IAT表中的表项地址。先要找到API所在DLL对应的项，然后才能找到这个DLL所对应的INT和IAT表，比较dll的名字，判断是否是API函数所在DLL的导出表目录项，然后根据预先绑定，如果有INT就用INT表来找函数名，没有就用IAT表找函数名，获得INT表（或IAT表）的RVA，并将其转换为文件位置，遍历INT表（或IAT表）的每一项，查找指定的API函数名。</li><li>找到符合的指令进行Patch，先找到代码所在的节，判断节的属性是否有0x20，找到后开始循环遍历每个字节进行替换，并写入patch指令。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> UESTC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UESTC </tag>
            
            <tag> 计算机病毒原理与防范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[漫语]葬送的芙莉莲</title>
      <link href="posts/52979/"/>
      <url>posts/52979/</url>
      
        <content type="html"><![CDATA[<h2 id="葬送的芙莉莲"><a href="#葬送的芙莉莲" class="headerlink" title="葬送的芙莉莲"></a>葬送的芙莉莲</h2><p>整个故事是建立在寿命论上的，表面上是披着“剑与魔法”外皮的日常故事，但是开头却讲的是勇者队伍在打倒魔王后迎来的长久和平中，衰老致死。</p><p>唯独芙莉莲是拥有漫长生命的精灵，勇者离世后，她继续着她的旅行，从故事的开头就知道，主线就是一个再简单不过的异世界日常，但是这份日常中却透露着一股忧伤，勇者在整个漫画的开始之时就已经离世，但是他却时刻活在芙莉莲的记忆之中，芙莉莲与勇者共度的时光不过20余载，这段漫长的时间不过是芙莉莲千年岁月中的五十分之一。</p><p> 在盛大的庆贺典礼中，打败了魔王的勇者向国王提出了一个要求——想让国家建造勇者一行人的雕像，当晚恰好是五十年一遇的流星划过之时，仿佛象征着和平时代的到来，而四个人一起约定，下一个五十年也要相聚，找个更好的地方观赏观赏流星。讨伐魔王的冒险结束后，卸下了拯救世界职责的他们，该干什么？</p><p><img src="https://pic2.zhimg.com/v2-646af59450a4efbdade04649a9bd3519_r.jpg" alt></p><p>他们开心地享受着他们亲手赢来的和平，一直幸福平静地活到了晚年。</p><p>——除了芙莉莲之外。</p><p><img src="https://pic2.zhimg.com/v2-2a2494c577b69cd31c7b8ca7ed1d4ab1_r.jpg" alt></p><p>她打算先随便旅游个一百年。</p><p>没过多久，冬去秋来，人来人往，仅仅两页纸不到——</p><p>五十年就过去了。</p><p>芙莉莲偶然想到，好像正好差不多是时候回来和大家一起看看流星了。</p><p>她回到勇者居住的城镇，四处寻找曾经的伙伴——</p><p>勇者四人，时隔五十年再度重聚。</p><p>五十年过去了，只有芙莉莲依然保持着当年的样子，丝毫未变。</p><p>他们闲聊着当年冒险的往事，为了前往最佳的流星观景点跋山涉水，仿佛找回了当年一起冒险的兴奋劲。</p><p>目前为止，如你所见，并没有什么称得上是剧情的剧情。四人仅仅是平淡幸福地度过了这段人生，老朋友们时隔五十年叙叙旧，仅此而已。没有波澜壮阔的变动，也没有暗流蠢动的阴谋——<strong>但漫画仅仅用十来页的篇幅，就将这番时隔五十年的两次流星之间、物是人非的变化与怀念刻画得淋漓尽致。</strong></p><p><img src="https://pic4.zhimg.com/v2-52d3534f24ed43966d82e02a7462ad83_r.jpg?source=1940ef5c" alt></p><p>我们以芙莉莲的视角，静静地，用一分钟体验完了长达五十年、又仅有短短五十年的沧桑与转瞬。</p><p>不久后，勇者辛美尔寿终正寝。</p><p>他抱着他的爱剑，静静躺在灵柩中。这个男人的一生伟大而平凡，无数受过他帮助的人前来参加他的送别仪式。牧师说，辛美尔的这一生大概是幸福的。</p><p>但芙莉莲却无法理解。</p><p><strong>因为，对她而言，她认识勇者的时间实在太短暂了。</strong></p><p>对常人而言，十年的相处可能会让彼此连屁股上有几根毛都清清楚楚。但对寿命数千数万年的精灵族来说，仅仅十年的相识，根本短到远远不足够让她了解一个人的为人。</p><p>因此，她一滴眼泪都掉不出来。</p><p><strong>“……因为我、对那个人简直是一无所知……”</strong></p><p><img src="https://pic2.zhimg.com/v2-48ab535f02a32da514134291f99bed21_r.jpg" alt></p><p>不是因为勇者的死而悲伤，也不是因为自己的冷血而自责。</p><p>芙莉莲在这瞬间会落泪，仅仅是因为——明明和他一起旅行了这么多年年，自己却对他一点也不了解。</p><p>明明她十分清楚人类就是短命的生物，但自己为什么没有趁他还在世时去多了解他一些呢。</p><p><strong>于是，本漫画的故事终于正式开始。</strong></p><p>没有刻意去渲染五十年社会变迁沧海桑田，也没有夸张形容勇者们的功绩与影响。所有的画面都仅仅是简单、冷静地展现了时间观念钝感的芙莉莲眼中的见闻，却深刻让人体会到了人类五十年的分量。</p><p>明明芙莉莲才是那个五十年间毫无变化的人，她这些一个一个离去的伙伴们却仿佛比她更豁达，更无变化。这些人类远胜于精灵的冷静与一如既往的态度，并未让时间溜走得像假的一样，反而让这段五十年的短暂光阴逝去得更为真实、残酷。</p><p>勇者为什么在一开始要求国家建造的雕像吗？</p><p>他们的雕像不仅仅建在了首都广场。全世界各地城镇和村落，都有他们的雕像。</p><p>而芙莉莲直到很久以后，才终于猜到了勇者辛美尔建立这些雕像的意图。</p><p>这是因为，勇者早就知道人类生命短暂，也比任何人都了解芙莉莲。对于人类来说，十年的相处足以把一个人彻头彻尾了解干净了——因此，他建立雕像，希望民众能庆祝勇者解放人类——这一切仅仅是因为——</p><p><img src="https://pic2.zhimg.com/v2-fb20a564bb898b65c274773391f65e79_r.jpg" alt></p><p><strong>他希望，他和伙伴们死去的百年后、千年后——芙莉莲看到大家的雕像时，能稍微减轻一些寂寞。因为这个世界还记得他们，他们确实存在过。</strong></p><p><strong>那么，芙莉莲就能够活在这个充满他们存在痕迹的世界中。</strong></p><p><strong>仅此而已。</strong></p><p>这些仅仅是漫画的开头，但已经足够表现漫画的张力，类似的作品还有很多，之后会慢慢更新</p>]]></content>
      
      
      <categories>
          
          <category> 漫语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漫语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可执行ELF文件的编写</title>
      <link href="posts/58644/"/>
      <url>posts/58644/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文从减少可执行文件大小的角度分析了 <code>ELF</code> 文件，期间通过经典的 <code>Hello World</code> 实例逐步演示如何通过各种常用工具来分析 <code>ELF</code> 文件，并逐步精简代码。</p><p>为了能够尽量减少可执行文件的大小，我们必须了解可执行文件的格式，以及链接生成可执行文件时的后台细节（即最终到底有哪些内容被链接到了目标代码中）。通过选择合适的可执行文件格式并剔除对可执行文件的最终运行没有影响的内容，就可以实现目标代码的裁减。因此，通过探索减少可执行文件大小的方法，就相当于实践性地去探索了可执行文件的格式以及链接过程的细节。</p><p>当然，算法的优化和编程语言的选择可能对目标文件的大小有很大的影响，在本文最后我们会去探求一个打印 <code>Hello World</code> 的可执行文件能够小到什么样的地步。</p><h2 id="可执行文件格式的选取"><a href="#可执行文件格式的选取" class="headerlink" title="可执行文件格式的选取"></a>可执行文件格式的选取</h2><p>可执行文件格式的选择要满足的一个基本条件是：目标系统支持该可执行文件格式， <code>UNIX</code> 平台下的三种可执行文件格式实际上代表着可执行文件的一个发展过程：</p><ul><li>a.out 文件格式非常紧凑，只包含了程序运行所必须的信息（文本、数据、 <code>BSS</code>），而且每个 <code>section</code> 的顺序是固定的。</li><li>coff 文件格式虽然引入了一个节区表以支持更多节区信息，从而提高了可扩展性，但是这种文件格式的重定位在链接时就已经完成，因此不支持动态链接（不过扩展的 <code>coff</code> 支持）。</li><li>elf 文件格式不仅支持动态链接，而且有很好的扩展性。它可以描述可重定位文件、可执行文件和可共享文件（动态链接库）三类文件。</li></ul><p>下面来看看 <code>ELF</code> 文件的结构图：</p><pre><code>文件头部(ELF Header)程序头部表(Program Header Table)节区1(Section1)节区2(Section2)节区3(Section3)...节区头部表(Section Header Table)</code></pre><p>无论是文件头部、程序头部表、节区头部表还是各个节区，都是通过特定的结构体 <code>(struct)</code> 描述的，这些结构在 <code>elf.h</code> 文件中定义。文件头部用于描述整个文件的类型、大小、运行平台、程序入口、程序头部表和节区头部表等信息。例如，我们可以通过文件头部查看该 <code>ELF</code> 文件的类型。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> hello.c   <span class="token comment" spellcheck="true">#典型的hello, world程序</span><span class="token comment" spellcheck="true">#include &lt;stdio.h></span>int main<span class="token punctuation">(</span>void<span class="token punctuation">)</span><span class="token punctuation">{</span>    printf<span class="token punctuation">(</span><span class="token string">"hello, world!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> 0<span class="token punctuation">;</span><span class="token punctuation">}</span>$ gcc -c hello.c   <span class="token comment" spellcheck="true">#编译，产生可重定向的目标代码</span>$ readelf -h hello.o <span class="token operator">|</span> <span class="token function">grep</span> Type   <span class="token comment" spellcheck="true">#通过readelf查看文件头部找出该类型</span>  Type:                              REL <span class="token punctuation">(</span>Relocatable file<span class="token punctuation">)</span>$ gcc -o hello hello.o   <span class="token comment" spellcheck="true">#生成可执行文件</span>$ readelf -h hello <span class="token operator">|</span> <span class="token function">grep</span> Type  Type:                              EXEC <span class="token punctuation">(</span>Executable file<span class="token punctuation">)</span>$ gcc -fpic -shared -Wl,-soname,libhello.so.0 -o libhello.so.0.0 hello.o  <span class="token comment" spellcheck="true">#生成共享库</span>$ readelf -h libhello.so.0.0 <span class="token operator">|</span> <span class="token function">grep</span> Type  Type:                              DYN <span class="token punctuation">(</span>Shared object file<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那节区头部表（将简称节区表）和程序头部表有什么用呢？实际上前者只对可重定向文件有用，而后者只对可执行文件和可共享文件有用。</p><p>节区表是用来描述各节区的，包括各节区的名字、大小、类型、虚拟内存中的位置、相对文件头的位置等，这样所有节区都通过节区表给描述了，这样连接器就可以根据文件头部表和节区表的描述信息对各种输入的可重定位文件进行合适的链接，包括节区的合并与重组、符号的重定位（确认符号在虚拟内存中的地址）等，把各个可重定向输入文件链接成一个可执行文件（或者是可共享文件）。如果可执行文件中使用了动态连接库，那么将包含一些用于动态符号链接的节区。我们可以通过 <code>readelf -S</code> （或 <code>objdump -h</code>）查看节区表信息。</p><pre class="line-numbers language-bash"><code class="language-bash">$ readelf -S hello  <span class="token comment" spellcheck="true">#可执行文件、可共享库、可重定位文件默认都生成有节区表</span><span class="token punctuation">..</span>.Section Headers:  <span class="token punctuation">[</span>Nr<span class="token punctuation">]</span> Name              Type            Addr     Off    Size   ES Flg Lk Inf Al  <span class="token punctuation">[</span> 0<span class="token punctuation">]</span>                   NULL            00000000 000000 000000 00      0   0  0  <span class="token punctuation">[</span> 1<span class="token punctuation">]</span> .interp           PROGBITS        08048114 000114 000013 00   A  0   0  1  <span class="token punctuation">[</span> 2<span class="token punctuation">]</span> .note.ABI-tag     NOTE            08048128 000128 000020 00   A  0   0  4  <span class="token punctuation">[</span> 3<span class="token punctuation">]</span> .hash             HASH            08048148 000148 000028 04   A  5   0  4<span class="token punctuation">..</span>.    <span class="token punctuation">[</span> 7<span class="token punctuation">]</span> .gnu.version      VERSYM          0804822a 00022a 00000a 02   A  5   0  2<span class="token punctuation">..</span>.  <span class="token punctuation">[</span>11<span class="token punctuation">]</span> .init             PROGBITS        08048274 000274 000030 00  AX  0   0  4<span class="token punctuation">..</span>.  <span class="token punctuation">[</span>13<span class="token punctuation">]</span> .text             PROGBITS        080482f0 0002f0 000148 00  AX  0   0 16  <span class="token punctuation">[</span>14<span class="token punctuation">]</span> .fini             PROGBITS        08048438 000438 00001c 00  AX  0   0  4<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>三种类型文件的节区可能不一样，但是有几个节区，例如 <code>.text</code>，<code>.data</code>，<code>.bss</code> 是必须的，特别是 <code>.text</code>，因为这个节区包含了代码。如果一个程序使用了动态链接库（引用了动态连接库中的某个函数），那么需要 <code>.interp</code> 节区以便告知系统使用什么动态连接器程序来进行动态符号链接，进行某些符号地址的重定位。通常，<code>.rel.text</code> 节区只有可重定向文件有，用于链接时对代码区进行重定向，而 <code>.hash</code>，<code>.plt</code>，<code>.got</code> 等节区则只有可执行文件（或可共享库）有，这些节区对程序的运行特别重要。还有一些节区，可能仅仅是用于注释，比如 <code>.comment</code>，这些对程序的运行似乎没有影响，是可有可无的，不过有些节区虽然对程序的运行没有用处，但是却可以用来辅助对程序进行调试或者对程序运行效率有影响。</p><p>虽然三类文件都必须包含某些节区，但是节区表对可重定位文件来说才是必须的，而程序的执行却不需要节区表，只需要程序头部表以便知道如何加载和执行文件。不过如果需要对可执行文件或者动态连接库进行调试，那么节区表却是必要的，否则调试器将不知道如何工作。下面来介绍程序头部表，它可通过 <code>readelf -l</code>（或 <code>objdump -p</code>）查看。</p><pre class="line-numbers language-bash"><code class="language-bash">$ readelf -l hello.o <span class="token comment" spellcheck="true">#对于可重定向文件，gcc没有产生程序头部，因为它对可重定向文件没用</span>There are no program headers <span class="token keyword">in</span> this file.$  readelf -l hello  <span class="token comment" spellcheck="true">#而可执行文件和可共享文件都有程序头部</span><span class="token punctuation">..</span>.Program Headers:  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align  PHDR           0x000034 0x08048034 0x08048034 0x000e0 0x000e0 R E 0x4  INTERP         0x000114 0x08048114 0x08048114 0x00013 0x00013 R   0x1      <span class="token punctuation">[</span>Requesting program interpreter: /lib/ld-linux.so.2<span class="token punctuation">]</span>  LOAD           0x000000 0x08048000 0x08048000 0x00470 0x00470 R E 0x1000  LOAD           0x000470 0x08049470 0x08049470 0x0010c 0x00110 RW  0x1000  DYNAMIC        0x000484 0x08049484 0x08049484 0x000d0 0x000d0 RW  0x4  NOTE           0x000128 0x08048128 0x08048128 0x00020 0x00020 R   0x4  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4 Section to Segment mapping:  Segment Sections<span class="token punctuation">..</span>.   00   01     .interp   02     .interp .note.ABI-tag .hash .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini .rodata .eh_frame   03     .ctors .dtors .jcr .dynamic .got .got.plt .data .bss   04     .dynamic   05     .note.ABI-tag   06$ readelf -l libhello.so.0.0  <span class="token comment" spellcheck="true">#节区和上面类似，这里省略</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面可看出程序头部表描述了一些段（<code>Segment</code>），这些段对应着一个或者多个节区，上面的 <code>readelf -l</code> 很好地显示了各个段与节区的映射。这些段描述了段的名字、类型、大小、第一个字节在文件中的位置、将占用的虚拟内存大小、在虚拟内存中的位置等。这样系统程序解释器将知道如何把可执行文件加载到内存中以及进行动态链接等动作。</p><p>该可执行文件包含 7 个段，<code>PHDR</code> 指程序头部，<code>INTERP</code> 正好对应 <code>.interp</code> 节区，两个 <code>LOAD</code> 段包含程序的代码和数据部分，分别包含有 <code>.text</code> 和 <code>.data</code>，<code>.bss</code> 节区，<code>DYNAMIC</code> 段包含 <code>.daynamic</code>，这个节区可能包含动态连接库的搜索路径、可重定位表的地址等信息，它们用于动态连接器。 <code>NOTE</code> 和 <code>GNU_STACK</code> 段貌似作用不大，只是保存了一些辅助信息。因此，对于一个不使用动态连接库的程序来说，可能只包含 <code>LOAD</code> 段，如果一个程序没有数据，那么只有一个 <code>LOAD</code> 段就可以了。</p><p>总结一下，Linux 虽然支持很多种可执行文件格式，但是目前 <code>ELF</code> 较通用，所以选择 <code>ELF</code> 作为我们的讨论对象。通过上面对 <code>ELF</code> 文件分析发现一个可执行的文件可能包含一些对它的运行没用的信息，比如节区表、一些用于调试、注释的节区。如果能够删除这些信息就可以减少可执行文件的大小，而且不会影响可执行文件的正常运行。</p><h2 id="链接优化"><a href="#链接优化" class="headerlink" title="链接优化"></a>链接优化</h2><p>从上面的讨论中已经接触了动态连接库。 <code>ELF</code> 中引入动态连接库后极大地方便了公共函数的共享，节约了磁盘和内存空间，因为不再需要把那些公共函数的代码链接到可执行文件，这将减少了可执行文件的大小。</p><p>与此同时，静态链接可能会引入一些对代码的运行可能并非必须的内容。从那篇 Blog 中似乎可以得出这样的结论：仅仅从是否影响一个 C 语言程序运行的角度上说，<code>GCC</code> 默认链接到可执行文件的几个可重定位文件 （<code>crt1.o</code>，<code>rti.o</code>，<code>crtbegin.o</code>，<code>crtend.o</code>，<code>crtn.o</code>）并不是必须的，不过值得注意的是，如果没有链接那些文件但在程序末尾使用了 <code>return</code> 语句，<code>main</code> 函数将无法返回，因此需要替换为 <code>_exit</code> 调用；另外，既然程序在进入 <code>main</code> 之前有一个入口，那么 <code>main</code> 入口就不是必须的。因此，如果不采用默认链接也可以减少可执行文件的大小。</p><h2 id="可执行文件“减肥”实例（从6442到708字节）"><a href="#可执行文件“减肥”实例（从6442到708字节）" class="headerlink" title="可执行文件“减肥”实例（从6442到708字节）"></a>可执行文件“减肥”实例（从6442到708字节）</h2><p>这里主要是根据上面两点来介绍如何减少一个可执行文件的大小。以 <code>Hello World</code> 为例。</p><p>首先来看看默认编译产生的 <code>Hello World</code> 的可执行文件大小。</p><h3 id="系统默认编译"><a href="#系统默认编译" class="headerlink" title="系统默认编译"></a>系统默认编译</h3><p>代码同上，下面是一组演示，</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">uname</span> -r   <span class="token comment" spellcheck="true">#先查看内核版本和gcc版本，以便和你的结果比较</span>2.6.22-14-generic$ gcc --versiongcc <span class="token punctuation">(</span>GCC<span class="token punctuation">)</span> 4.1.3 20070929 <span class="token punctuation">(</span>prerelease<span class="token punctuation">)</span> <span class="token punctuation">(</span>Ubuntu 4.1.2-16ubuntu2<span class="token punctuation">)</span><span class="token punctuation">..</span>.$ gcc -o hello hello.c   <span class="token comment" spellcheck="true">#默认编译</span>$ <span class="token function">wc</span> -c hello   <span class="token comment" spellcheck="true">#产生一个大小为6442字节的可执行文件</span>6442 hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="不采用默认编译"><a href="#不采用默认编译" class="headerlink" title="不采用默认编译"></a>不采用默认编译</h3><p>可以考虑编辑时就把 <code>return 0</code> 替换成 <code>_exit(0)</code> 并包含定义该函数的 <code>unistd.h</code> 头文件。下面是之前博客中总结出的 <code>Makefile</code> 文件。</p><pre class="line-numbers language-makefile"><code class="language-makefile"><span class="token comment" spellcheck="true">#file: Makefile</span><span class="token comment" spellcheck="true">#functin: for not linking a program as the gcc do by default</span>MAIN <span class="token operator">=</span> helloSOURCE <span class="token operator">=</span>OBJS <span class="token operator">=</span> hello.oTARGET <span class="token operator">=</span> helloCC <span class="token operator">=</span> gcc-3.4 -m32LD <span class="token operator">=</span> ld -m elf_i386CFLAGSs <span class="token operator">+=</span> -SCFLAGSc <span class="token operator">+=</span> -cLDFLAGS <span class="token operator">+=</span> -dynamic-linker /lib/ld-linux.so.2 -L /usr/lib/ -L /lib -lcRM <span class="token operator">=</span> rm -fSEDc <span class="token operator">=</span> sed -i -e <span class="token string">'/\#include[ "&lt;]*unistd.h[ ">]*/d;'</span> \    -i -e <span class="token string">'1i \#include &lt;unistd.h>'</span> \    -i -e <span class="token string">'s/return 0;/_exit(0);/'</span>SEDs <span class="token operator">=</span> sed -i -e <span class="token string">'s/main/_start/g'</span><span class="token symbol">all</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span><span class="token symbol"><span class="token variable">$</span>(TARGET)</span><span class="token punctuation">:</span>    <span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>SEDc<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>MAIN<span class="token punctuation">)</span>.c    <span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGSs<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>MAIN<span class="token punctuation">)</span>.c    <span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>SEDs<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>MAIN<span class="token punctuation">)</span>.s    <span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGSc<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>MAIN<span class="token punctuation">)</span>.s <span class="token variable">$</span><span class="token punctuation">(</span>SOURCE<span class="token punctuation">)</span>    <span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>LD<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>LDFLAGS<span class="token punctuation">)</span> -o <span class="token variable">$@</span> <span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span><span class="token symbol">clean</span><span class="token punctuation">:</span>    <span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>RM<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>MAIN<span class="token punctuation">)</span>.s <span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把上面的代码复制到一个Makefile文件中，并利用它来编译hello.c。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">make</span>   <span class="token comment" spellcheck="true">#编译</span>$ ./hello   <span class="token comment" spellcheck="true">#这个也是可以正常工作的</span>Hello World$ <span class="token function">wc</span> -c hello   <span class="token comment" spellcheck="true">#但是大小减少了4382个字节，减少了将近 70%</span>2060 hello$ <span class="token keyword">echo</span> <span class="token string">"6442-2060"</span> <span class="token operator">|</span> <span class="token function">bc</span>4382$ <span class="token keyword">echo</span> <span class="token string">"(6442-2060)/6442"</span> <span class="token operator">|</span> <span class="token function">bc</span> -l.68022353306426575597<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于一个比较小的程序，能够减少将近 70% “没用的”代码。</p><h3 id="删除对程序运行没有影响的节区"><a href="#删除对程序运行没有影响的节区" class="headerlink" title="删除对程序运行没有影响的节区"></a>删除对程序运行没有影响的节区</h3><p>使用上述 <code>Makefile</code> 来编译程序，不链接那些对程序运行没有多大影响的文件，实际上也相当于删除了一些“没用”的节区，可以通过下列演示看出这个实质。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">make</span> clean$ <span class="token function">make</span>$ readelf -l hello <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"0[0-9]\ \ "</span>   00   01     .interp   02     .interp .hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.plt .plt .text .rodata   03     .dynamic .got.plt   04     .dynamic   05$ <span class="token function">make</span> clean$ gcc -o hello hello.c$ readelf -l hello <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"0[0-9]\ \ "</span>   00   01     .interp   02     .interp .note.ABI-tag .hash .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r      .rel.dyn .rel.plt .init .plt .text .fini .rodata .eh_frame   03     .ctors .dtors .jcr .dynamic .got .got.plt .data .bss   04     .dynamic   05     .note.ABI-tag   06<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过比较发现使用自定义的 <code>Makefile</code> 文件，少了这么多节区： <code>.bss .ctors .data .dtors .eh_frame .fini .gnu.hash .got .init .jcr .note.ABI-tag .rel.dyn</code> 。 再看看还有哪些节区可以删除呢？通过之前的分析发现有些节区是必须的，那 <code>.hash?.gnu.version?</code> 呢，通过 <code>strip -R</code>（或 <code>objcop -R</code>）删除这些节区试试。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">wc</span> -c hello   <span class="token comment" spellcheck="true">#查看大小，以便比较</span>2060$ <span class="token function">time</span> ./hello    <span class="token comment" spellcheck="true">#我们比较一下一些节区对执行时间可能存在的影响</span>Hello Worldreal    0m0.001suser    0m0.000ssys     0m0.000s$ strip -R .hash hello   <span class="token comment" spellcheck="true">#删除.hash节区</span>$ <span class="token function">wc</span> -c hello1448 hello$ <span class="token keyword">echo</span> <span class="token string">"2060-1448"</span> <span class="token operator">|</span> <span class="token function">bc</span>   <span class="token comment" spellcheck="true">#减少了612字节</span>612$ <span class="token function">time</span> ./hello           <span class="token comment" spellcheck="true">#发现执行时间长了一些（实际上也可能是进程调度的问题）</span>Hello Worldreal    0m0.006suser    0m0.000ssys     0m0.000s$ strip -R .gnu.version hello   <span class="token comment" spellcheck="true">#删除.gnu.version还是可以工作</span>$ <span class="token function">wc</span> -c hello1396 hello$ <span class="token keyword">echo</span> <span class="token string">"1448-1396"</span> <span class="token operator">|</span> <span class="token function">bc</span>      <span class="token comment" spellcheck="true">#又减少了52字节</span>52$ <span class="token function">time</span> ./helloHello Worldreal    0m0.130suser    0m0.004ssys     0m0.000s$ strip -R .gnu.version_r hello   <span class="token comment" spellcheck="true">#删除.gnu.version_r就不工作了</span>$ <span class="token function">time</span> ./hello./hello: error <span class="token keyword">while</span> loading shared libraries: ./hello: unsupported version 0 of Verneed record<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过删除各个节区可以查看哪些节区对程序来说是必须的，不过有些节区虽然并不影响程序的运行却可能会影响程序的执行效率，这个可以上面的运行时间看出个大概。 通过删除两个“没用”的节区，我们又减少了 <code>52+612</code>，即 664 字节。</p><h3 id="删除可执行文件的节区表"><a href="#删除可执行文件的节区表" class="headerlink" title="删除可执行文件的节区表"></a>删除可执行文件的节区表</h3><p>用普通的工具没有办法删除节区表，但你可以从<a href="http://www.muppetlabs.com/~breadbox/software/elfkickers.html">这里</a>下载到那个工具，它是一序列工具 <code>ELFkickers</code> 中的一个。</p><p>下载并编译（<strong>注</strong>：1.0 之前的版本才支持 32 位和正常编译，新版本在代码中明确限定了数据结构为 <code>Elf64</code>）：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> clone https://github.com/BR903/ELFkickers$ <span class="token function">cd</span> ELFkickers/sstrip/$ <span class="token function">git</span> checkout f0622afa    <span class="token comment" spellcheck="true"># 检出 1.0 版</span>$ <span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后复制到 <code>/usr/bin</code> 下，下面用它来删除节区表。</p><pre class="line-numbers language-bash"><code class="language-bash">$ sstrip hello      <span class="token comment" spellcheck="true">#删除ELF可执行文件的节区表</span>$ ./hello           <span class="token comment" spellcheck="true">#还是可以正常运行，说明节区表对可执行文件的运行没有任何影响</span>Hello World$ <span class="token function">wc</span> -c hello       <span class="token comment" spellcheck="true">#大小只剩下708个字节了</span>708 hello$ <span class="token keyword">echo</span> <span class="token string">"1396-708"</span> <span class="token operator">|</span> <span class="token function">bc</span>  <span class="token comment" spellcheck="true">#又减少了688个字节。</span>688<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过删除节区表又把可执行文件减少了 688 字节。现在回头看看相对于 <code>gcc</code> 默认产生的可执行文件，通过删除一些节区和节区表到底减少了多少字节？减幅达到了多少？</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token string">"6442-708"</span> <span class="token operator">|</span> <span class="token function">bc</span>   <span class="token comment" spellcheck="true">#</span>5734$ <span class="token keyword">echo</span> <span class="token string">"(6442-708)/6442"</span> <span class="token operator">|</span> <span class="token function">bc</span> -l.89009624340266997826<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>减少了 5734 多字节，减幅将近 <code>90%</code>，这说明：对于一个简短的 <code>hello.c</code> 程序而言，<code>gcc</code> 引入了将近 <code>90%</code> 的对程序运行没有影响的数据。虽然通过删除节区和节区表，使得最终的文件只有 708 字节，但是打印一个 <code>Hello World</code> 真的需要这么多字节么？事实上未必，因为：</p><ul><li>打印一段 <code>Hello World</code> 字符串，我们无须调用 <code>printf</code>，也就无须包含动态连接库，因此 <code>.interp</code>，<code>.dynamic</code> 等节区又可以去掉。为什么？我们可以直接使用系统调用 `(sys_write)来打印字符串。</li><li>另外，我们无须把 <code>Hello World</code> 字符串存放到可执行文件中？而是让用户把它当作参数输入。</li></ul><p>下面，继续进行可执行文件的“减肥”。</p><h2 id="用汇编语言来重写”Hello-World”（76字节）"><a href="#用汇编语言来重写”Hello-World”（76字节）" class="headerlink" title="用汇编语言来重写”Hello World”（76字节）"></a>用汇编语言来重写”Hello World”（76字节）</h2><h3 id="采用默认编译"><a href="#采用默认编译" class="headerlink" title="采用默认编译"></a>采用默认编译</h3><p>先来看看 <code>gcc</code> 默认产生的汇编代码情况。通过 <code>gcc</code> 的 <code>-S</code> 选项可得到汇编代码。</p><pre class="line-numbers language-c"><code class="language-c">$ cat hello<span class="token punctuation">.</span>c  #这个是使用_exit和printf函数的版本<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span>      </span><span class="token comment" spellcheck="true">/* printf */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span>     </span><span class="token comment" spellcheck="true">/* _exit */</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>$ gcc <span class="token operator">-</span>S hello<span class="token punctuation">.</span>c    #生成汇编$ cat hello<span class="token punctuation">.</span>s       #这里是汇编代码    <span class="token punctuation">.</span>file   <span class="token string">"hello.c"</span>    <span class="token punctuation">.</span>section        <span class="token punctuation">.</span>rodata<span class="token punctuation">.</span>LC0<span class="token punctuation">:</span>    <span class="token punctuation">.</span>string <span class="token string">"Hello World"</span>    <span class="token punctuation">.</span>text<span class="token punctuation">.</span>globl main    <span class="token punctuation">.</span>type   main<span class="token punctuation">,</span> @functionmain<span class="token punctuation">:</span>    leal    <span class="token function">4</span><span class="token punctuation">(</span><span class="token operator">%</span>esp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>ecx    andl    $<span class="token operator">-</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token operator">%</span>esp    pushl   <span class="token operator">-</span><span class="token function">4</span><span class="token punctuation">(</span><span class="token operator">%</span>ecx<span class="token punctuation">)</span>    pushl   <span class="token operator">%</span>ebp    movl    <span class="token operator">%</span>esp<span class="token punctuation">,</span> <span class="token operator">%</span>ebp    pushl   <span class="token operator">%</span>ecx    subl    $<span class="token number">4</span><span class="token punctuation">,</span> <span class="token operator">%</span>esp    movl    $<span class="token punctuation">.</span>LC0<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">%</span>esp<span class="token punctuation">)</span>    call    puts    movl    $<span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">%</span>esp<span class="token punctuation">)</span>    call    _exit    <span class="token punctuation">.</span>size   main<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token operator">-</span>main    <span class="token punctuation">.</span>ident  <span class="token string">"GCC: (GNU) 4.1.3 20070929 (prerelease) (Ubuntu 4.1.2-16ubuntu2)"</span>    <span class="token punctuation">.</span>section        <span class="token punctuation">.</span>note<span class="token punctuation">.</span>GNU<span class="token operator">-</span>stack<span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span>@progbits$ gcc <span class="token operator">-</span>o hello hello<span class="token punctuation">.</span>s   #看看默认产生的代码大小$ wc <span class="token operator">-</span>c hello<span class="token number">6523</span> hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除掉汇编代码中无关紧要内容"><a href="#删除掉汇编代码中无关紧要内容" class="headerlink" title="删除掉汇编代码中无关紧要内容"></a>删除掉汇编代码中无关紧要内容</h3><p>现在对汇编代码 <code>hello.s</code> 进行简单的处理得到，</p><pre class="line-numbers language-assembly"><code class="language-assembly">.LC0:    .string "Hello World"    .text.globl main    .type   main, @functionmain:    leal    4(%esp), %ecx    andl    $-16, %esp    pushl   -4(%ecx)    pushl   %ebp    movl    %esp, %ebp    pushl   %ecx    subl    $4, %esp    movl    $.LC0, (%esp)    call    puts    movl    $0, (%esp)    call    _exit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再编译看看，</p><pre class="line-numbers language-bash"><code class="language-bash">$ gcc -o hello.o hello.s$ <span class="token function">wc</span> -c hello6443 hello$ <span class="token keyword">echo</span> <span class="token string">"6523-6443"</span> <span class="token operator">|</span> <span class="token function">bc</span>   <span class="token comment" spellcheck="true">#仅仅减少了80个字节</span>80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="不默认编译并删除掉无关节区和节区表"><a href="#不默认编译并删除掉无关节区和节区表" class="headerlink" title="不默认编译并删除掉无关节区和节区表"></a>不默认编译并删除掉无关节区和节区表</h3><p>如果不采用默认编译呢并且删除掉对程序运行没有影响的节区和节区表呢？</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sed</span> -i -e <span class="token string">"s/main/_start/g"</span> hello.s   <span class="token comment" spellcheck="true">#因为没有初始化，所以得直接进入代码，替换main为_start</span>$ as --32 -o  hello.o hello.s$ ld -melf_i386 -o hello hello.o --dynamic-linker /lib/ld-linux.so.2 -L /usr/lib -lc$ ./hellohello world<span class="token operator">!</span>$ <span class="token function">wc</span> -c hello1812 hello$ <span class="token keyword">echo</span> <span class="token string">"6443-1812"</span> <span class="token operator">|</span> <span class="token function">bc</span> -l   <span class="token comment" spellcheck="true">#和之前的实验类似，也减少了4k左右</span>4631$ readelf -l hello <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"\ [0-9][0-9]\ "</span>   00   01     .interp   02     .interp .hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.plt .plt .text   03     .dynamic .got.plt   04     .dynamic$ strip -R .hash hello$ strip -R .gnu.version hello$ <span class="token function">wc</span> -c hello1200 hello$ sstrip hello$ <span class="token function">wc</span> -c hello  <span class="token comment" spellcheck="true">#这个结果比之前的708（在删除所有垃圾信息以后）个字节少了708-676，即32个字节</span>676 hello$ ./helloHello World<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>容易发现这 32 字节可能跟节区 <code>.rodata</code> 有关系，因为刚才在链接完以后查看节区信息时，并没有 <code>.rodata</code> 节区。</p><h3 id="用系统调用取代库函数"><a href="#用系统调用取代库函数" class="headerlink" title="用系统调用取代库函数"></a>用系统调用取代库函数</h3><p>前面提到，实际上还可以不用动态连接库中的 <code>printf</code> 函数，也不用直接调用 <code>_exit</code>，而是在汇编里头使用系统调用，这样就可以去掉和动态连接库关联的内容。使用系统调用重写以后得到如下代码，</p><pre class="line-numbers language-assembly"><code class="language-assembly">.LC0:    .string "Hello World\xa\x0"    .text.global _start_start:    xorl   %eax, %eax    movb   $4, %al                  #eax = 4, sys_write(fd, addr, len)    xorl   %ebx, %ebx    incl   %ebx                     #ebx = 1, standard output    movl   $.LC0, %ecx              #ecx = $.LC0, the address of string    xorl   %edx, %edx    movb   $13, %dl                 #edx = 13, the length of .string    int    $0x80    xorl   %eax, %eax    movl   %eax, %ebx               #ebx = 0    incl   %eax                     #eax = 1, sys_exit    int    $0x80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在编译就不再需要动态链接器 <code>ld-linux.so</code> 了，也不再需要链接任何库。</p><pre class="line-numbers language-bash"><code class="language-bash">$ as --32 -o hello.o hello.s$ ld -melf_i386 -o hello hello.o$ readelf -l helloElf <span class="token function">file</span> <span class="token function">type</span> is EXEC <span class="token punctuation">(</span>Executable file<span class="token punctuation">)</span>Entry point 0x8048062There are 1 program headers, starting at offset 52Program Headers:  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align  LOAD           0x000000 0x08048000 0x08048000 0x0007b 0x0007b R E 0x1000 Section to Segment mapping:  Segment Sections<span class="token punctuation">..</span>.   00     .text$ sstrip hello$ ./hello           <span class="token comment" spellcheck="true">#完全可以正常工作</span>Hello World$ <span class="token function">wc</span> -c hello123 hello$ <span class="token keyword">echo</span> <span class="token string">"676-123"</span> <span class="token operator">|</span> <span class="token function">bc</span>   <span class="token comment" spellcheck="true">#相对于之前，已经只需要123个字节了，又减少了553个字节</span>553<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到效果很明显，只剩下一个 <code>LOAD</code> 段，它对应 <code>.text</code> 节区。</p><h3 id="把字符串作为参数输入"><a href="#把字符串作为参数输入" class="headerlink" title="把字符串作为参数输入"></a>把字符串作为参数输入</h3><p>不过是否还有办法呢？把 <code>Hello World</code> 作为参数输入，而不是硬编码在文件中。所以如果处理参数的代码少于 <code>Hello World</code> 字符串的长度，那么就可以达到减少目标文件大小的目的。</p><p>先来看一个能够打印程序参数的汇编语言程序：</p><pre class="line-numbers language-assembly"><code class="language-assembly">.text.globl _start_start:    popl    %ecx            # argcvnext:    popl    %ecx            # argv    test    %ecx, %ecx      # 空指针表明结束    jz      exit    movl    %ecx, %ebx    xorl    %edx, %edxstrlen:    movb    (%ebx), %al    inc     %edx    inc     %ebx    test    %al, %al    jnz     strlen    movb    $10, -1(%ebx)    movl    $4, %eax        # 系统调用号(sys_write)    movl    $1, %ebx        # 文件描述符(stdout)    int     $0x80    jmp     vnextexit:    movl    $1,%eax         # 系统调用号(sys_exit)    xorl    %ebx, %ebx      # 退出代码    int     $0x80    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译看看效果，</p><pre class="line-numbers language-bash"><code class="language-bash">$ as --32 -o args.o args.s$ ld -melf_i386 -o args args.o$ ./args <span class="token string">"Hello World"</span>  <span class="token comment" spellcheck="true">#能够打印输入的字符串，不错</span>./argsHello World$ sstrip args$ <span class="token function">wc</span> -c args           <span class="token comment" spellcheck="true">#处理以后只剩下130字节</span>130 args<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，这个程序可以接收用户输入的参数并打印出来，不过得到的可执行文件为 130 字节，比之前的 123 个字节还多了 7 个字节，看看还有改进么？分析上面的代码后，发现，原来的代码有些地方可能进行优化，优化后得到如下代码。</p><pre class="line-numbers language-assembly"><code class="language-assembly">.global _start_start:    popl %ecx        #弹出argcvnext:    popl %ecx        #弹出argv[0]的地址    test %ecx, %ecx  #空指针表明结束    jz exit    movl %ecx, %ebx  #复制字符串地址到ebx寄存器    xorl %edx, %edx  #把字符串长度清零strlen:                         #求输入字符串的长度    movb (%ebx), %al        #复制字符到al，以便判断是否为字符串结束符\0    inc %edx                #edx存放每个当前字符串的长度    inc %ebx                #ebx存放每个当前字符的地址    test %al, %al           #判断字符串是否结束，即是否遇到\0    jnz strlen    movb $10, -1(%ebx)      #在字符串末尾插入一个换行符\0xa    xorl %eax, %eax    movb $4, %al            #eax = 4, sys_write(fd, addr, len)    xorl %ebx, %ebx    incl %ebx               #ebx = 1, standard output    int $0x80    jmp vnextexit:    xorl %eax, %eax    movl %eax, %ebx                 #ebx = 0    incl %eax               #eax = 1, sys_exit    int $0x80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再测试（记得先重新汇编、链接并删除没用的节区和节区表）。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">wc</span> -c hello124 hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在只有 124 个字节，不过还是比 123 个字节多一个，还有什么优化的办法么？</p><p>先来看看目前 <code>hello</code> 的功能，感觉不太符合要求，因为只需要打印 <code>Hello World</code>，所以不必处理所有的参数，仅仅需要接收并打印一个参数就可以。这样的话，把 <code>jmp vnext</code>（2 字节）这个循环去掉，然后在第一个 <code>pop %ecx</code> 语句之前加一个 <code>pop %ecx</code>（1 字节）语句就可以。</p><pre class="line-numbers language-assembly"><code class="language-assembly">.global _start_start:    popl %ecx    popl %ecx        #弹出argc[0]的地址    popl %ecx        #弹出argv[1]的地址    test %ecx, %ecx    jz exit    movl %ecx, %ebx    xorl %edx, %edxstrlen:    movb (%ebx), %al    inc %edx    inc %ebx    test %al, %al    jnz strlen    movb $10, -1(%ebx)    xorl %eax, %eax    movb $4, %al    xorl %ebx, %ebx    incl %ebx    int $0x80exit:    xorl %eax, %eax    movl %eax, %ebx    incl %eax    int $0x80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在刚好 123 字节，和原来那个代码大小一样，不过仔细分析，还是有减少代码的余地：因为在这个代码中，用了一段额外的代码计算字符串的长度，实际上如果仅仅需要打印 <code>Hello World</code>，那么字符串的长度是固定的，即 12 。所以这段代码可去掉，与此同时测试字符串是否为空也就没有必要（不过可能影响代码健壮性！），当然，为了能够在打印字符串后就换行，在串的末尾需要加一个回车（<code>$10</code>）并且设置字符串的长度为 <code>12+1</code>，即 13，</p><pre class="line-numbers language-assembly"><code class="language-assembly">.global _start_start:    popl %ecx    popl %ecx    popl %ecx    movb $10,12(%ecx) #在Hello World的结尾加一个换行符    xorl %edx, %edx    movb $13, %dl    xorl %eax, %eax    movb $4, %al    xorl %ebx, %ebx    incl %ebx    int $0x80    xorl %eax, %eax    movl %eax, %ebx    incl %eax    int $0x80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再看看效果，</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">wc</span> -c hello111 hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="寄存器赋值重用"><a href="#寄存器赋值重用" class="headerlink" title="寄存器赋值重用"></a>寄存器赋值重用</h3><p>现在只剩下 111 字节，比刚才少了 12 字节。貌似到了极限？还有措施么？</p><p>还有，仔细分析发现：系统调用 <code>sys_exit</code> 和 <code>sys_write</code> 都用到了 <code>eax</code> 和 <code>ebx</code> 寄存器，它们之间刚好有那么一点巧合：</p><ul><li>sys_exit 调用时，<code>eax</code> 需要设置为 1，<code>ebx</code> 需要设置为 0 。</li><li>sys_write 调用时，<code>ebx</code> 刚好是 1 。</li></ul><p>因此，如果在 <code>sys_exit</code> 调用之前，先把 <code>ebx</code> 复制到 <code>eax</code> 中，再对 <code>ebx</code> 减一，则可减少两个字节。</p><p>不过，因为标准输入、标准输出和标准错误都指向终端，如果往标准输入写入一些东西，它还是会输出到标准输出上，所以在上述代码中如果在 <code>sys_write</code> 之前 <code>ebx</code> 设置为 0，那么也可正常往屏幕上打印 <code>Hello World</code>，这样的话，<code>sys_exit</code> 调用前就没必要修改 <code>ebx</code>，而仅需把 <code>eax</code> 设置为 1，这样就可减少 3 个字节。</p><pre class="line-numbers language-assembly"><code class="language-assembly">.global _start_start:    popl %ecx    popl %ecx    popl %ecx    movb $10,12(%ecx)    xorl %edx, %edx    movb $13, %dl    xorl %eax, %eax    movb $4, %al    xorl %ebx, %ebx    int $0x80    xorl %eax, %eax    incl %eax    int $0x80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看看效果，</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">wc</span> -c hello108 hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在看一下纯粹的指令还有多少？</p><pre class="line-numbers language-assembly"><code class="language-assembly">$ readelf -h hello | grep Size  Size of this header:               52 (bytes)  Size of program headers:           32 (bytes)  Size of section headers:           0 (bytes)$  echo "108-52-32" | bc24<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="通过文件名传递参数"><a href="#通过文件名传递参数" class="headerlink" title="通过文件名传递参数"></a>通过文件名传递参数</h3><p>对于标准的 <code>main</code> 函数的两个参数，文件名实际上作为第二个参数（数组）的第一个元素传入，如果仅仅是为了打印一个字符串，那么可以打印文件名本身。例如，要打印 <code>Hello World</code>，可以把文件名命名为 <code>Hello World</code> 即可。</p><p>这样地话，代码中就可以删除掉一条 <code>popl</code> 指令，减少 1 个字节，变成 107 个字节。</p><pre class="line-numbers language-assembly"><code class="language-assembly">.global _start_start:    popl %ecx    popl %ecx    movb $10,12(%ecx)    xorl %edx, %edx    movb $13, %dl    xorl %eax, %eax    movb $4, %al    xorl %ebx, %ebx    int $0x80    xorl %eax, %eax    incl %eax    int $0x80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看看效果，</p><pre class="line-numbers language-assembly"><code class="language-assembly">$ as --32 -o hello.o hello.s$ ld -melf_i386 -o hello hello.o$ sstrip hello$ wc -c hello107$ mv hello "Hello World"$ export PATH=./:$PATH$ Hello\ WorldHello World<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除非必要指令"><a href="#删除非必要指令" class="headerlink" title="删除非必要指令"></a>删除非必要指令</h3><p>在测试中发现，<code>edx</code>，<code>eax</code>，<code>ebx</code> 的高位即使不初始化，也常为 0，如果不考虑健壮性（仅这里实验用，实际使用中必须考虑健壮性），几条 <code>xorl</code> 指令可以移除掉。</p><p>另外，如果只是为了演示打印字符串，完全可以不用打印换行符，这样下来，代码可以综合优化成如下几条指令：</p><pre class="line-numbers language-assembly"><code class="language-assembly">.global _start_start:    popl %ecx    # argc    popl %ecx    # argv[0]    movb $5, %dl    # 设置字符串长度    movb $4, %al    # eax = 4, 设置系统调用号, sys_write(fd, addr, len) : ebx, ecx, edx    int $0x80    movb $1, %al    int $0x80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看看效果：</p><pre class="line-numbers language-bash"><code class="language-bash">$ as --32 -o hello.o hello.s$ ld -melf_i386 -o hello hello.o$ sstrip hello$ <span class="token function">wc</span> -c hello96<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="合并代码段、程序头和文件头（52字节）"><a href="#合并代码段、程序头和文件头（52字节）" class="headerlink" title="合并代码段、程序头和文件头（52字节）"></a>合并代码段、程序头和文件头（52字节）</h2><h3 id="把代码段移入文件头"><a href="#把代码段移入文件头" class="headerlink" title="把代码段移入文件头"></a>把代码段移入文件头</h3><p>纯粹的指令只有 <code>96-84=12</code> 个字节了，还有办法再减少目标文件的大小么？这 12 个字节是否可以插入到文件头部或程序头部？如果可以那是否意味着还可减少可执行文件的大小呢？现在来比较一下这三部分的十六进制内容。</p><pre class="line-numbers language-bash"><code class="language-bash">$ hexdump -C hello -n 52     <span class="token comment" spellcheck="true">#文件头(52bytes)</span>00000000  7f 45 4c 46 01 01 01 00  00 00 00 00 00 00 00 00  <span class="token operator">|</span>.ELF<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000010  02 00 03 00 01 00 00 00  54 80 04 08 34 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>T<span class="token punctuation">..</span>.4<span class="token punctuation">..</span>.<span class="token operator">|</span>00000020  00 00 00 00 00 00 00 00  34 00 20 00 01 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>4. <span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000030  00 00 00 00                                       <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000034$ hexdump -C hello -s 52 -n 32    <span class="token comment" spellcheck="true">#程序头(32bytes)</span>00000034  01 00 00 00 00 00 00 00  00 80 04 08 00 80 04 08  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000044  6c 00 00 00 6c 00 00 00  05 00 00 00 00 10 00 00  <span class="token operator">|</span>l<span class="token punctuation">..</span>.l<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000054$ hexdump -C hello -s 84          <span class="token comment" spellcheck="true">#实际代码部分(12bytes)</span>00000054  59 59 b2 05 b0 04 <span class="token function">cd</span> 80  b0 01 <span class="token function">cd</span> 80              <span class="token operator">|</span>YY<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000060<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面结果发现 <code>ELF</code> 文件头部和程序头部还有好些空洞（0），是否可以把指令字节分散放入到那些空洞里或者是直接覆盖掉那些系统并不关心的内容？抑或是把代码压缩以后放入可执行文件中，并在其中实现一个解压缩算法？还可以是通过一些代码覆盖率测试工具（<code>gcov</code>，<code>prof</code>）对你的代码进行优化？</p><p>在继续介绍之前，先来看一个 <code>dd</code> 工具，可以用来直接“编辑” <code>ELF</code> 文件，例如，</p><p>直接往指定位置写入 <code>0xff</code> ：</p><pre class="line-numbers language-bash"><code class="language-bash">$ hexdump -C hello -n 16    <span class="token comment" spellcheck="true"># 写入前，elf文件前16个字节</span>00000000  7f 45 4c 46 01 01 01 00  00 00 00 00 00 00 00 00  <span class="token operator">|</span>.ELF<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000010$ <span class="token keyword">echo</span> -ne <span class="token string">"\xff"</span> <span class="token operator">|</span> <span class="token function">dd</span> of<span class="token operator">=</span>hello bs<span class="token operator">=</span>1 count<span class="token operator">=</span>1 seek<span class="token operator">=</span>15 conv<span class="token operator">=</span>notrunc    <span class="token comment" spellcheck="true"># 把最后一个字节0覆盖掉</span>1+0 records <span class="token keyword">in</span>1+0 records out1 byte <span class="token punctuation">(</span>1 B<span class="token punctuation">)</span> copied, 3.7349e-05 s, 26.8 kB/s$ hexdump -C hello -n 16    <span class="token comment" spellcheck="true"># 写入后果然被覆盖</span>00000000  7f 45 4c 46 01 01 01 00  00 00 00 00 00 00 00 ff  <span class="token operator">|</span>.ELF<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000010<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>seek=15</code> 表示指定写入位置为第 15 个（从第 0 个开始）</li><li><code>conv=notrunc</code> 选项表示要保留写入位置之后的内容，默认情况下会截断。</li><li><code>bs=1</code> 表示一次读/写 1 个</li><li><code>count=1</code> 表示总共写 1 次</li></ul><p>覆盖多个连续的值：</p><p>把第 12，13，14，15 连续 4 个字节全部赋值为 <code>0xff</code> 。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> -ne <span class="token string">"\xff\xff\xff\xff"</span> <span class="token operator">|</span> <span class="token function">dd</span> of<span class="token operator">=</span>hello bs<span class="token operator">=</span>1 count<span class="token operator">=</span>4 seek<span class="token operator">=</span>12 conv<span class="token operator">=</span>notrunc$ hexdump -C hello -n 1600000000  7f 45 4c 46 01 01 01 00  00 00 00 00 ff ff ff ff  <span class="token operator">|</span>.ELF<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000010<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>下面，通过往文件头指定位置写入 <code>0xff</code> 确认哪些部分对于可执行文件的执行是否有影响？这里是逐步测试后发现依然能够执行的情况：</p><pre class="line-numbers language-bash"><code class="language-bash">$ hexdump -C hello00000000  7f 45 4c 46 ff ff ff ff  ff ff ff ff ff ff ff ff  <span class="token operator">|</span>.ELF<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000010  02 00 03 00 ff ff ff ff  54 80 04 08 34 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>T<span class="token punctuation">..</span>.4<span class="token punctuation">..</span>.<span class="token operator">|</span>00000020  ff ff ff ff ff ff ff ff  34 00 20 00 01 00 ff ff  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>4. <span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000030  ff ff ff ff 01 00 00 00  00 00 00 00 00 80 04 08  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000040  00 80 04 08 60 00 00 00  60 00 00 00 05 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token variable"><span class="token variable">`</span><span class="token punctuation">..</span>.<span class="token variable">`</span></span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000050  00 10 00 00 59 59 b2 05  b0 04 <span class="token function">cd</span> 80 b0 01 <span class="token function">cd</span> 80  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span>YY<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000060<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现，文件头部分，有 30 个字节即使被篡改后，该可执行文件依然可以正常执行。这意味着，这 30 字节是可以写入其他代码指令字节的。而我们的实际代码指令只剩下 12 个，完全可以直接移到前 12 个 <code>0xff</code> 的位置，即从第 4 个到第 15 个。</p><p>而代码部分的起始位置，通过 <code>readelf -h</code> 命令可以看到：</p><pre><code>$ readelf -h hello | grep &quot;Entry&quot;  Entry point address:               0x8048054</code></pre><p>上面地址的最后两位 <code>0x54=84</code> 就是代码在文件中的偏移，也就是刚好从程序头之后开始的，也就是用文件头（52）+程序头（32）个字节开始的 12 字节覆盖到第 4 个字节开始的 12 字节内容即可。</p><p>上面的 <code>dd</code> 命令从 <code>echo</code> 命令获得输入，下面需要通过可执行文件本身获得输入，先把代码部分移过去：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">dd</span> if<span class="token operator">=</span>hello of<span class="token operator">=</span>hello bs<span class="token operator">=</span>1 skip<span class="token operator">=</span>84 count<span class="token operator">=</span>12 seek<span class="token operator">=</span>4 conv<span class="token operator">=</span>notrunc12+0 records <span class="token keyword">in</span>12+0 records out12 bytes <span class="token punctuation">(</span>12 B<span class="token punctuation">)</span> copied, 4.9552e-05 s, 242 kB/s$ hexdump -C hello00000000  7f 45 4c 46 59 59 b2 05  b0 04 <span class="token function">cd</span> 80 b0 01 <span class="token function">cd</span> 80  <span class="token operator">|</span>.ELFYY<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000010  02 00 03 00 01 00 00 00  54 80 04 08 34 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>T<span class="token punctuation">..</span>.4<span class="token punctuation">..</span>.<span class="token operator">|</span>00000020  00 00 00 00 00 00 00 00  34 00 20 00 01 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>4. <span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000030  00 00 00 00 01 00 00 00  00 00 00 00 00 80 04 08  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000040  00 80 04 08 60 00 00 00  60 00 00 00 05 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token variable"><span class="token variable">`</span><span class="token punctuation">..</span>.<span class="token variable">`</span></span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000050  00 10 00 00 59 59 b2 05  b0 04 <span class="token function">cd</span> 80 b0 01 <span class="token function">cd</span> 80  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span>YY<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000060<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着把代码部分截掉：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">dd</span> if<span class="token operator">=</span>hello of<span class="token operator">=</span>hello bs<span class="token operator">=</span>1 count<span class="token operator">=</span>1 skip<span class="token operator">=</span>84 seek<span class="token operator">=</span>840+0 records <span class="token keyword">in</span>0+0 records out0 bytes <span class="token punctuation">(</span>0 B<span class="token punctuation">)</span> copied, 1.702e-05 s, 0.0 kB/s$ hexdump -C hello00000000  7f 45 4c 46 59 59 b2 05  b0 04 <span class="token function">cd</span> 80 b0 01 <span class="token function">cd</span> 80  <span class="token operator">|</span>.ELFYY<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000010  02 00 03 00 01 00 00 00  54 80 04 08 34 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>T<span class="token punctuation">..</span>.4<span class="token punctuation">..</span>.<span class="token operator">|</span>00000020  00 00 00 00 00 00 00 00  34 00 20 00 01 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>4. <span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000030  00 00 00 00 01 00 00 00  00 00 00 00 00 80 04 08  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000040  00 80 04 08 60 00 00 00  60 00 00 00 05 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token variable"><span class="token variable">`</span><span class="token punctuation">..</span>.<span class="token variable">`</span></span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000050  00 10 00 00                                       <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000054<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个时候还不能执行，因为代码在文件中的位置被移动了，相应地，文件头中的 <code>Entry point address</code>，即文件入口地址也需要被修改为 <code>0x8048004</code> 。</p><p>即需要把 <code>0x54</code> 所在的第 24 个字节修改为 <code>0x04</code> ：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> -ne <span class="token string">"\x04"</span> <span class="token operator">|</span> <span class="token function">dd</span> of<span class="token operator">=</span>hello bs<span class="token operator">=</span>1 count<span class="token operator">=</span>1 seek<span class="token operator">=</span>24 conv<span class="token operator">=</span>notrunc1+0 records <span class="token keyword">in</span>1+0 records out1 byte <span class="token punctuation">(</span>1 B<span class="token punctuation">)</span> copied, 3.7044e-05 s, 27.0 kB/s$ hexdump -C hello00000000  7f 45 4c 46 59 59 b2 05  b0 04 <span class="token function">cd</span> 80 b0 01 <span class="token function">cd</span> 80  <span class="token operator">|</span>.ELFYY<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000010  02 00 03 00 01 00 00 00  04 80 04 08 34 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>4<span class="token punctuation">..</span>.<span class="token operator">|</span>00000020  84 00 00 00 00 00 00 00  34 00 20 00 01 00 28 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>4. <span class="token punctuation">..</span>.<span class="token punctuation">(</span>.<span class="token operator">|</span>00000030  05 00 02 00 01 00 00 00  00 00 00 00 00 80 04 08  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000040  00 80 04 08 60 00 00 00  60 00 00 00 05 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token variable"><span class="token variable">`</span><span class="token punctuation">..</span>.<span class="token variable">`</span></span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000050  00 10 00 00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改后就可以执行了。</p><h3 id="把程序头移入文件头"><a href="#把程序头移入文件头" class="headerlink" title="把程序头移入文件头"></a>把程序头移入文件头</h3><p>程序头部分经过测试发现基本上都不能修改并且需要是连续的，程序头有 32 个字节，而文件头中连续的 <code>0xff</code> 可以被篡改的只有从第 46 个开始的 6 个了，另外，程序头刚好是 <code>01 00</code> 开头，而第 44，45 个刚好为 <code>01 00</code>，这样地话，这两个字节文件头可以跟程序头共享，这样地话，程序头就可以往文件头里头移动 8 个字节了。</p><pre><code>$ dd if=hello of=hello bs=1 skip=52 seek=44 count=32 conv=notrunc</code></pre><p>再把最后 8 个没用的字节删除掉，保留 <code>84-8=76</code> 个字节：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">dd</span> if<span class="token operator">=</span>hello of<span class="token operator">=</span>hello bs<span class="token operator">=</span>1 skip<span class="token operator">=</span>76 seek<span class="token operator">=</span>76$ hexdump -C hello00000000  7f 45 4c 46 59 59 b2 05  b0 04 <span class="token function">cd</span> 80 b0 01 <span class="token function">cd</span> 80  <span class="token operator">|</span>.ELFYY<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000010  02 00 03 00 01 00 00 00  04 80 04 08 34 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>4<span class="token punctuation">..</span>.<span class="token operator">|</span>00000020  84 00 00 00 00 00 00 00  34 00 20 00 01 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>4. <span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000030  00 00 00 00 00 80 04 08  00 80 04 08 60 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token variable"><span class="token variable">`</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000040  60 00 00 00 05 00 00 00  00 10 00 00              <span class="token operator">|</span><span class="token variable">`</span></span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>0000004c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外，还需要把文件头中程序头的位置信息改为 44，即第 28 个字节，原来是 <code>0x34</code>，即 52 的位置。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token string">"obase=16;ibase=10;44"</span> <span class="token operator">|</span> <span class="token function">bc</span>    <span class="token comment" spellcheck="true"># 先把44转换是16进制的0x2C</span>2C$ <span class="token keyword">echo</span> -ne <span class="token string">"\x2C"</span> <span class="token operator">|</span> <span class="token function">dd</span> of<span class="token operator">=</span>hello bs<span class="token operator">=</span>1 count<span class="token operator">=</span>1 seek<span class="token operator">=</span>28 conv<span class="token operator">=</span>notrunc    <span class="token comment" spellcheck="true"># 修改文件头</span>1+0 records <span class="token keyword">in</span>1+0 records out1 byte <span class="token punctuation">(</span>1 B<span class="token punctuation">)</span> copied, 3.871e-05 s, 25.8 kB/s$ hexdump -C hello00000000  7f 45 4c 46 59 59 b2 05  b0 04 <span class="token function">cd</span> 80 b0 01 <span class="token function">cd</span> 80  <span class="token operator">|</span>.ELFYY<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000010  02 00 03 00 01 00 00 00  04 80 04 08 2c 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>,<span class="token punctuation">..</span>.<span class="token operator">|</span>00000020  84 00 00 00 00 00 00 00  34 00 20 00 01 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>4. <span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000030  00 00 00 00 00 80 04 08  00 80 04 08 60 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token variable"><span class="token variable">`</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000040  60 00 00 00 05 00 00 00  00 10 00 00              <span class="token operator">|</span><span class="token variable">`</span></span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>0000004c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改后即可执行了，目前只剩下 76 个字节：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">wc</span> -c hello76<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="在非连续的空间插入代码"><a href="#在非连续的空间插入代码" class="headerlink" title="在非连续的空间插入代码"></a>在非连续的空间插入代码</h3><p>另外，还有 12 个字节可以放代码，见 <code>0xff</code> 的地方：</p><pre class="line-numbers language-bash"><code class="language-bash">$ hexdump -C hello00000000  7f 45 4c 46 59 59 b2 05  b0 04 <span class="token function">cd</span> 80 b0 01 <span class="token function">cd</span> 80  <span class="token operator">|</span>.ELFYY<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000010  02 00 03 00 ff ff ff ff  04 80 04 08 2c 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>,<span class="token punctuation">..</span>.<span class="token operator">|</span>00000020  ff ff ff ff ff ff ff ff  34 00 20 00 01 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>4. <span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000030  00 00 00 00 00 80 04 08  00 80 04 08 60 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token variable"><span class="token variable">`</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000040  60 00 00 00 05 00 00 00  00 10 00 00              <span class="token operator">|</span><span class="token variable">`</span></span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>0000004c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不过因为空间不是连续的，需要用到跳转指令作为跳板利用不同的空间。</p><p>例如，如果要利用后面的 <code>0xff</code> 的空间，可以把第 14，15 位置的 <code>cd 80</code> 指令替换为一条跳转指令，比如跳转到第 20 个字节的位置，从跳转指令之后的 16 到 20 刚好 4 个字节。</p><p>然后可以参考 X86 指令编码表（也可以写成汇编生成可执行文件后用 <code>hexdump</code> 查看），可以把 <code>jmp</code> 指令编码为： <code>0xeb 0x04</code> 。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> -ne <span class="token string">"\xeb\x04"</span> <span class="token operator">|</span> <span class="token function">dd</span> of<span class="token operator">=</span>hello bs<span class="token operator">=</span>1 count<span class="token operator">=</span>2 seek<span class="token operator">=</span>14 conv<span class="token operator">=</span>notrunc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后把原来位置的 <code>cd 80</code> 移动到第 20 个字节开始的位置：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> -ne <span class="token string">"\xcd\x80"</span> <span class="token operator">|</span> <span class="token function">dd</span> of<span class="token operator">=</span>hello bs<span class="token operator">=</span>1 count<span class="token operator">=</span>2 seek<span class="token operator">=</span>20 conv<span class="token operator">=</span>notrunc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>依然可以执行，类似地可以利用更多非连续的空间。</p><h3 id="把程序头完全合入文件头"><a href="#把程序头完全合入文件头" class="headerlink" title="把程序头完全合入文件头"></a>把程序头完全合入文件头</h3><p>通过分析 Linux 系统对 <code>ELF</code> 文件头部和程序头部的解析，可以更进一步合并程序头和文件头。</p><p>把最简的 <code>ELF</code> 文件（简单返回一个数值）压缩到 45 个字节，需要是非常极端的努力。</p><p>首先对 <code>ELF</code> 文件头部和程序头部做更彻底的理解，并具体到每一个字节的含义以及在 Linux 系统下的实际解析情况。</p><p>先来看看 <code>readelf -a</code> 的结果：</p><pre class="line-numbers language-bash"><code class="language-bash">$ as --32 -o hello.o hello.s$ ld -melf_i386 -o hello hello.o$ sstrip hello$ readelf -a helloELF Header:  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00  Class:                             ELF32  Data:                              2's complement, little endian  Version:                           1 <span class="token punctuation">(</span>current<span class="token punctuation">)</span>  OS/ABI:                            UNIX - System V  ABI Version:                       0  Type:                              EXEC <span class="token punctuation">(</span>Executable file<span class="token punctuation">)</span>  Machine:                           Intel 80386  Version:                           0x1  Entry point address:               0x8048054  Start of program headers:          52 <span class="token punctuation">(</span>bytes into file<span class="token punctuation">)</span>  Start of section headers:          0 <span class="token punctuation">(</span>bytes into file<span class="token punctuation">)</span>  Flags:                             0x0  Size of this header:               52 <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>  Size of program headers:           32 <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>  Number of program headers:         1  Size of section headers:           0 <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>  Number of section headers:         0  Section header string table index: 0There are no sections <span class="token keyword">in</span> this file.There are no sections to group <span class="token keyword">in</span> this file.Program Headers:  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align  LOAD           0x000000 0x08048000 0x08048000 0x00060 0x00060 R E 0x1000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后结合 <code>/usr/include/linux/elf.h</code> 分别做详细注解。</p><p>首先是 52 字节的 <code>Elf</code> 文件头的结构体 <code>elf32_hdr</code>：</p><table><thead><tr><th>变量类型</th><th>变量名</th><th>字节</th><th>说明</th><th>类型</th></tr></thead><tbody><tr><td>unsigned char</td><td>e_ident[EI_NIDENT]</td><td>16</td><td>.ELF 前四个标识文件类型</td><td>必须</td></tr><tr><td>Elf32_Half</td><td>e_type</td><td>2</td><td>指定为可执行文件</td><td>必须</td></tr><tr><td>Elf32_Half</td><td>e_machine</td><td>2</td><td>指示目标机类型，例如：Intel 386</td><td>必须</td></tr><tr><td>Elf32_Word</td><td>e_version</td><td>4</td><td>当前只有一个版本存在，被忽略了</td><td><del>可篡改</del></td></tr><tr><td>Elf32_Addr</td><td>e_entry</td><td>4</td><td>代码入口=加载地址(p_vaddr+.text偏移)</td><td><strong>可调整</strong></td></tr><tr><td>Elf32_Off</td><td>e_phoff</td><td>4</td><td>程序头 Phdr 的偏移地址，用于加载代码</td><td>必须</td></tr><tr><td>Elf32_Off</td><td>e_shoff</td><td>4</td><td>所有节区相关信息对文件执行无效</td><td><del>可篡改</del></td></tr><tr><td>Elf32_Word</td><td>e_flags</td><td>4</td><td>Intel 架构未使用</td><td><del>可篡改</del></td></tr><tr><td>Elf32_Half</td><td>e_ehsize</td><td>2</td><td>文件头大小，Linux 没做校验</td><td><del>可篡改</del></td></tr><tr><td>Elf32_Half</td><td>e_phentsize</td><td>2</td><td>程序头入口大小，新内核有用</td><td>必须</td></tr><tr><td>Elf32_Half</td><td>e_phnum</td><td>2</td><td>程序头入口个数</td><td>必须</td></tr><tr><td>Elf32_Half</td><td>e_shentsize</td><td>2</td><td>所有节区相关信息对文件执行无效</td><td><del>可篡改</del></td></tr><tr><td>Elf32_Half</td><td>e_shnum</td><td>2</td><td>所有节区相关信息对文件执行无效</td><td><del>可篡改</del></td></tr><tr><td>Elf32_Half</td><td>e_shstrndx</td><td>2</td><td>所有节区相关信息对文件执行无效</td><td><del>可篡改</del></td></tr></tbody></table><p>其次是 32 字节的程序头（Phdr）的结构体 <code>elf32_phdr</code>：</p><table><thead><tr><th>变量类型</th><th>变量名</th><th>字节</th><th>说明</th><th>类型</th></tr></thead><tbody><tr><td>Elf32_Word</td><td>p_type</td><td>4</td><td>标记为可加载段</td><td>必须</td></tr><tr><td>Elf32_Off</td><td>p_offset</td><td>4</td><td>相对程序头的偏移地址</td><td>必须</td></tr><tr><td>Elf32_Addr</td><td>p_vaddr</td><td>4</td><td>加载地址, 0x0~0x80000000，页对齐</td><td><strong>可调整</strong></td></tr><tr><td>Elf32_Addr</td><td>p_paddr</td><td>4</td><td>物理地址，暂时没用</td><td><del>可篡改</del></td></tr><tr><td>Elf32_Word</td><td>p_filesz</td><td>4</td><td>加载的文件大小，&gt;=real size</td><td><strong>可调整</strong></td></tr><tr><td>Elf32_Word</td><td>p_memsz</td><td>4</td><td>加载所需内存大小，&gt;= p_filesz</td><td><strong>可调整</strong></td></tr><tr><td>Elf32_Word</td><td>p_flags</td><td>4</td><td>权限:read(4),exec(1), 其中一个暗指另外一个</td><td><strong>可调整</strong></td></tr><tr><td>Elf32_Word</td><td>p_align</td><td>4</td><td>PIC(共享库需要)，对执行文件无效</td><td><del>可篡改</del></td></tr></tbody></table><p>接着，咱们把 Elf 中的文件头和程序头部分<strong>可调整</strong>和<del>可篡改</del>的字节（52 + 32 = 84个）全部用特别的字体标记出来。</p><pre><code>$ hexdump -C hello -n 84</code></pre><blockquote><p>00000000 7f 45 4c 46 <del>01 01 01 00 00 00 00 00 00 00 00 00</del></p><p>00000010 02 00 03 00 <del>01 00 00 00</del> <strong>54 80 04 08 34</strong> 00 00 00</p><p>00000020 <del>84 00 00 00 00 00 00 00</del> 34 00 20 00 01 00 <del>28 00</del></p><p>00000030 <del>05 00 02 00</del>|01 00 00 00 00 00 00 00 <strong>00 80 04 08</strong></p><p>00000040 <del>00 80 04 08</del> <strong>60 00 00 00 60 00 00 00 05 00 00 00</strong></p><p>00000050 <del>00 10 00 00</del></p><p>00000054</p></blockquote><p>上述 <code>|</code> 线之前为文件头，之后为程序头，之前的 <code>000000xx</code> 为偏移地址。</p><p>如果要把程序头彻底合并进文件头。从上述信息综合来看，文件头有 4 处必须保留，经过对比发现，如果把第 4 行开始的程序头往上平移 3 行，也就是：</p><blockquote><p>00000000 ========= <del>01 01 01 00 00 00 00 00 00 00 00 00</del></p><p>00000010 02 00 03 00 <del>01 00 00 00</del> <strong>54 80 04 08 34</strong> 00 00 00</p><p>00000020 <del>84 00 00 00</del></p><p>00000030 ========= 01 00 00 00 00 00 00 00 <strong>00 80 04 08</strong></p><p>00000040 <del>00 80 04 08</del> <strong>60 00 00 00 60 00 00 00 05 00 00 00</strong></p><p>00000050 <del>00 10 00 00</del></p><p>00000054</p></blockquote><p>把可直接合并的先合并进去，效果如下：</p><p>（文件头）</p><blockquote><p>00000000 ========= 01 00 00 00 00 00 00 00 <strong>00 80 04 08</strong> (^^ p_vaddr)</p><p>00000010 02 00 03 00 <del>60 00 00 00</del> <strong>54 80 04 08 34</strong> 00 00 00</p><p>00000020 =================== ^^ e_entry ^^ e_phoff</p></blockquote><p>（程序头）</p><blockquote><p>00000030 ========= 01 00 00 00 00 00 00 00 <strong>00 80 04 08</strong> (^^ p_vaddr)</p><p>00000040 02 00 03 00 <strong>60 00 00 00 60 00 00 00 05 00 00 00</strong></p><p>00000050 ========= ^^ p_filesz ^^ p_memsz ^^p_flags</p><p>00000054</p></blockquote><p>接着需要设法处理好可调整的 6 处，可以逐个解决，从易到难。</p><ul><li>首先，合并 <code>e_phoff</code> 与 <code>p_flags</code></li></ul><p>在合并程序头以后，程序头的偏移地址需要修改为 4，即文件的第 4 个字节开始，也就是说 <code>e_phoff</code> 需要修改为 04。</p><p>而恰好，<code>p_flags</code> 的 <code>read(4)</code> 和 <code>exec(1)</code> 可以只选其一，所以，只保留 <code>read(4)</code> 即可，刚好也为 04。</p><p>合并后效果如下：</p><p>（文件头）</p><blockquote><p>00000000 ========= 01 00 00 00 00 00 00 00 <strong>00 80 04 08</strong> (^^ p_vaddr)</p><p>00000010 02 00 03 00 <del>60 00 00 00</del> <strong>54 80 04 08</strong> 04 00 00 00</p><p>00000020 =================== ^^ e_entry</p></blockquote><p>（程序头）</p><blockquote><p>00000030 ========= 01 00 00 00 00 00 00 00 <strong>00 80 04 08</strong> (^^ p_vaddr)</p><p>00000040 02 00 03 00 <strong>60 00 00 00 60 00 00 00</strong> 04 00 00 00</p><p>00000050 ========= ^^ p_filesz ^^ p_memsz</p><p>00000054</p></blockquote><ul><li>接下来，合并 <code>e_entry</code>，<code>p_filesz</code>, <code>p_memsz</code> 和 <code>p_vaddr</code></li></ul><p>从早前的分析情况来看，这 4 个变量基本都依赖 <code>p_vaddr</code>，也就是程序的加载地址，大体的依赖关系如下：</p><pre class="line-numbers language-bash"><code class="language-bash">e_entry <span class="token operator">=</span> p_vaddr + text offset <span class="token operator">=</span> p_vaddr + 84 <span class="token operator">=</span> p_vaddr + 0x54p_memsz <span class="token operator">=</span> e_entryp_memsz <span class="token operator">>=</span> p_filesz，可以简单取 p_filesz <span class="token operator">=</span> p_memszp_vaddr <span class="token operator">=</span> page alignment<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以，首先需要确定 <code>p_vaddr</code>，通过测试，发现<code>p_vaddr</code> 最低必须有 64k，也就是 0x00010000，对应到 <code>hexdump</code> 的 <code>little endian</code> 导出结果，则为 <code>00 00 01 00</code>。</p><p>需要注意的是，为了尽量少了分配内存，我们选择了一个最小的<code>p_vaddr</code>，如果申请的内存太大，系统将无法分配。</p><p>接着，计算出另外 3 个变量：</p><pre><code>e_entry = 0x00010000 + 0x54 = 0x00010054 即 54 00 01 00p_memsz = 54 00 01 00p_filesz = 54 00 01 00</code></pre><p>完全合并后，修改如下：</p><p>（文件头）</p><blockquote><p>00000000 ========= 01 00 00 00 00 00 00 00 00 00 01 00</p><p>00000010 02 00 03 00 54 00 01 00 54 00 01 00 04 00 00 00</p><p>00000020 ========</p></blockquote><p>好了，直接把内容烧入：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> -ne <span class="token string">"\x01\x00\x00\x00\x00\x00\x00\x00"</span> \       <span class="token string">"\x00\x00\x01\x00\x02\x00\x03\x00"</span> \       <span class="token string">"\x54\x00\x01\x00\x54\x00\x01\x00\x04"</span> <span class="token operator">|</span>\       <span class="token function">tr</span> -d <span class="token string">' '</span> <span class="token operator">|</span>\    <span class="token function">dd</span> of<span class="token operator">=</span>hello bs<span class="token operator">=</span>1 count<span class="token operator">=</span>25 seek<span class="token operator">=</span>4 conv<span class="token operator">=</span>notrunc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>截掉代码（52 + 32 + 12 = 96）之后的所有内容，查看效果如下：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">dd</span> if<span class="token operator">=</span>hello of<span class="token operator">=</span>hello bs<span class="token operator">=</span>1 count<span class="token operator">=</span>1 skip<span class="token operator">=</span>96 seek<span class="token operator">=</span>96$ hexdump -C hello -n 9600000000  7f 45 4c 46 01 00 00 00  00 00 00 00 00 00 01 00  <span class="token operator">|</span>.ELF<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000010  02 00 03 00 54 00 01 00  54 00 01 00 04 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span>T<span class="token punctuation">..</span>.T<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000020  84 00 00 00 00 00 00 00  34 00 20 00 01 00 28 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>4. <span class="token punctuation">..</span>.<span class="token punctuation">(</span>.<span class="token operator">|</span>00000030  05 00 02 00 01 00 00 00  00 00 00 00 00 80 04 08  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000040  00 80 04 08 60 00 00 00  60 00 00 00 05 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token variable"><span class="token variable">`</span><span class="token punctuation">..</span>.<span class="token variable">`</span></span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000050  00 10 00 00 59 59 b2 05  b0 04 <span class="token function">cd</span> 80 b0 01 <span class="token function">cd</span> 80  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span>YY<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000060<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后的工作是查看文件头中剩下的<del>可篡改</del>的内容，并把<strong>代码部分</strong>合并进去，程序头已经合入，不再显示。</p><blockquote><p>00000000 7f 45 4c 46 01 00 00 00 00 00 00 00 00 00 01 00</p><p>00000010 02 00 03 00 54 00 01 00 54 00 01 00 04 00 00 00</p><p>00000020 <del>84 00 00 00 00 00 00 00</del> 34 00 20 00 01 00 <del>28 00</del></p><p>00000030 <del>05 00 02 00</del></p><p>00000040</p><p>00000050 ============= <strong>59 59 b2 05 b0 04 cd 80 b0 01 cd 80</strong></p><p>00000060</p></blockquote><p>我们的指令有 12 字节，<del>可篡改</del>的部分有 14 个字节，理论上一定放得下，不过因为把程序头搬进去以后，这 14 个字节并不是连续，刚好可以用上我们之前的跳转指令处理办法来解决。</p><p>并且，加入 2 个字节的跳转指令，刚好是 14 个字节，恰好把代码也完全包含进了文件头。</p><p>在预留好<strong>跳转指令</strong>位置的前提下，我们把代码部分先合并进去：</p><blockquote><p>00000000 7f 45 4c 46 01 00 00 00 00 00 00 00 00 00 01 00</p><p>00000010 02 00 03 00 54 00 01 00 54 00 01 00 04 00 00 00</p><p>00000020 <strong>59 59 b2 05 b0 04</strong> <del>00 00</del> 34 00 20 00 01 00 <strong>cd 80</strong></p><p>00000030 <strong>b0 01 cd 80</strong></p></blockquote><p>接下来设计跳转指令，跳转指令需要从所在位置跳到第一个 <strong>cd 80</strong> 所在的位置，相距 6 个字节，根据 <code>jmp</code> 短跳转的编码规范，可以设计为 <code>0xeb 0x06</code>，填完后效果如下：</p><blockquote><p>00000000 7f 45 4c 46 01 00 00 00 00 00 00 00 00 00 01 00</p><p>00000010 02 00 03 00 54 00 01 00 54 00 01 00 04 00 00 00</p><p>00000020 <strong>59 59 b2 05 b0 04 eb 06</strong> 34 00 20 00 01 00 <strong>cd 80</strong></p><p>00000030 <strong>b0 01 cd 80</strong></p></blockquote><p>用 <code>dd</code> 命令写入，分两段写入：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> -ne <span class="token string">"\x59\x59\xb2\x05\xb0\x04\xeb\x06"</span> <span class="token operator">|</span> \    <span class="token function">dd</span> of<span class="token operator">=</span>hello bs<span class="token operator">=</span>1 count<span class="token operator">=</span>8 seek<span class="token operator">=</span>32 conv<span class="token operator">=</span>notrunc$ <span class="token keyword">echo</span> -ne <span class="token string">"\xcd\x80\xb0\x01\xcd\x80"</span> <span class="token operator">|</span> \    <span class="token function">dd</span> of<span class="token operator">=</span>hello bs<span class="token operator">=</span>1 count<span class="token operator">=</span>6 seek<span class="token operator">=</span>46 conv<span class="token operator">=</span>notrunc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码合入以后，需要修改文件头中的代码的偏移地址，即 <code>e_entry</code>，也就是要把原来的偏移 84 (0x54) 修改为现在的偏移，即 0x20。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> -ne <span class="token string">"\x20"</span> <span class="token operator">|</span> <span class="token function">dd</span> of<span class="token operator">=</span>hello bs<span class="token operator">=</span>1 count<span class="token operator">=</span>1 seek<span class="token operator">=</span>24 conv<span class="token operator">=</span>notrunc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改完以后恰好把合并进的程序头 <code>p_memsz</code>，也就是分配给文件的内存改小了，<code>p_filesz</code>也得相应改小。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> -ne <span class="token string">"\x20"</span> <span class="token operator">|</span> <span class="token function">dd</span> of<span class="token operator">=</span>hello bs<span class="token operator">=</span>1 count<span class="token operator">=</span>1 seek<span class="token operator">=</span>20 conv<span class="token operator">=</span>notrunc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>程序头和代码都已经合入，最后，把 52 字节之后的内容全部删掉：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">dd</span> if<span class="token operator">=</span>hello of<span class="token operator">=</span>hello bs<span class="token operator">=</span>1 count<span class="token operator">=</span>1 skip<span class="token operator">=</span>52 seek<span class="token operator">=</span>52$ hexdump -C hello00000000  7f 45 4c 46 01 00 00 00  00 00 00 00 00 00 01 00  <span class="token operator">|</span>.ELF<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000010  02 00 03 00 20 00 01 00  20 00 01 00 04 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span>T<span class="token punctuation">..</span>.T<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000020  59 59 b2 05 b0 04 eb 06  34 00 20 00 01 00 <span class="token function">cd</span> 80  <span class="token operator">|</span>YY<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>4. <span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000030  b0 01 <span class="token function">cd</span> 80$ <span class="token function">export</span> PATH<span class="token operator">=</span>./:<span class="token variable">$PATH</span>$ hellohello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>代码</strong>和<del>程序头</del>部分合并进文件头的汇总情况：</p><blockquote><p>00000000 7f 45 4c 46 <del>01 00 00 00 00 00 00 00 00 00 01 00</del></p><p>00000010 <del>02 00 03 00 20 00 01 00 20 00 01 00 04 00 00 00</del></p><p>00000020 <strong><del>59 59 b2 05</del> b0 04 eb 06</strong> 34 00 20 00 01 00 <strong>cd 80</strong></p><p>00000030 <strong>b0 01 cd 80</strong></p></blockquote><p>最后，我们的成绩是：</p><pre><code>$ wc -c hello52</code></pre><p>史上最小的可打印 <code>Hello World</code>（注：要完全打印得把代码中的5该为13，并且把文件名该为该字符串） 的 <code>Elf</code> 文件是 52 个字节。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cd</span> ELFkickers/tiny/$ <span class="token function">wc</span> -c hello59 hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>需要特别提到的是，该作者创造的最小可执行 Elf 是 45 个字节。</p><p>但是由于那个程序只能返回一个数值，代码更简短，刚好可以直接嵌入到文件头中间，而文件末尾的 7 个 <code>0</code> 字节由于 Linux 加载时会自动填充，所以可以删掉，所以最终的文件大小是 52 - 7 即 45 个字节。</p><p>其大体可实现如下：</p><pre class="line-numbers language-bash"><code class="language-bash">.global _start_start:    mov <span class="token variable">$42</span>, %bl   <span class="token comment" spellcheck="true"># 设置返回值为 42</span>    xor %eax, %eax <span class="token comment" spellcheck="true"># eax = 0</span>    inc %eax       <span class="token comment" spellcheck="true"># eax = eax+1, 设置系统调用号, sys_exit()</span>    int <span class="token variable">$0x80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>保存为 ret.s，编译和执行效果如下：</p><pre class="line-numbers language-bash"><code class="language-bash">$ as --32 -o ret.o ret.s$ ld -melf_i386 -o ret ret.o$ ./ret42<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>代码字节数可这么查看：</p><pre class="line-numbers language-bash"><code class="language-bash">$ ld -melf_i386 --oformat<span class="token operator">=</span>binary -o ret.bin ret.o$ hexdump -C ret.bin0000000  b3 2a 31 c0 40 <span class="token function">cd</span> 800000007<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里只有 7 条指令，刚好可以嵌入，而最后的 6 个字节因为<del>可篡改</del>为 0，并且内核可自动填充 0，所以干脆可以连续删掉最后 7 个字节的 0：</p><blockquote><p>00000000 7f 45 4c 46 01 00 00 00 00 00 00 00 00 00 01 00</p><p>00000010 02 00 03 00 54 00 01 00 54 00 01 00 04 00 00 00</p><p>00000020 <strong>b3 2a 31 c0 40 cd 80</strong> 00 34 00 20 00 01 00 00 00</p><p>00000030 00 00 00 00</p></blockquote><p>可以直接用已经合并好程序头的 <code>hello</code> 来做实验，这里一并截掉最后的 7 个 0 字节：</p><pre><code>$ cp hello ret$ echo -ne &quot;\xb3\x2a\x31\xc0\x40\xcd\x80&quot; |\    dd of=ret bs=1 count=8 seek=32 conv=notrunc$ dd if=ret of=hello bs=1 count=1 skip=45 seek=45$ hexdump -C hello00000000  7f 45 4c 46 01 00 00 00  00 00 00 00 00 00 01 00  |.ELF............|00000010  02 00 03 00 20 00 01 00  20 00 01 00 04 00 00 00  |.... ... .......|00000020  b3 2a 31 c0 40 cd 80 06  34 00 20 00 01           |.*1.@...4. ..|0000002d$ wc -c ret45 ret$ ./ret$ echo $?42</code></pre><p>如果想快速构建该 <code>Elf</code> 文件，可以直接使用下述 Shell 代码：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># generate_ret_elf.sh -- Generate a 45 bytes Elf file</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># $ bash generate_ret_elf.sh</span><span class="token comment" spellcheck="true"># $ chmod a+x ret.elf</span><span class="token comment" spellcheck="true"># $ ./ret.elf</span><span class="token comment" spellcheck="true"># $ echo $?</span><span class="token comment" spellcheck="true"># 42</span><span class="token comment" spellcheck="true">#</span>ret<span class="token operator">=</span><span class="token string">"\x7f\x45\x4c\x46\x01\x00\x00\x00"</span>ret<span class="token operator">=</span><span class="token variable">${ret}</span><span class="token string">"\x00\x00\x00\x00\x00\x00\x01\x00"</span>ret<span class="token operator">=</span><span class="token variable">${ret}</span><span class="token string">"\x02\x00\x03\x00\x20\x00\x01\x00"</span>ret<span class="token operator">=</span><span class="token variable">${ret}</span><span class="token string">"\x20\x00\x01\x00\x04\x00\x00\x00"</span>ret<span class="token operator">=</span><span class="token variable">${ret}</span><span class="token string">"\xb3\x2a\x31\xc0\x40\xcd\x80\x06"</span>ret<span class="token operator">=</span><span class="token variable">${ret}</span><span class="token string">"\x34\x00\x20\x00\x01"</span><span class="token keyword">echo</span> -ne <span class="token variable">$ret</span> <span class="token operator">></span> ret.elf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>又或者是直接参照<code>tiny.asm</code> ，其代码如下：</p><pre class="line-numbers language-assembly"><code class="language-assembly">; ret.asm  BITS 32            org     0x00010000            db      0x7F, "ELF"             ; e_ident            dd      1                                       ; p_type            dd      0                                       ; p_offset            dd      $$                                      ; p_vaddr            dw      2                       ; e_type        ; p_paddr            dw      3                       ; e_machine            dd      _start                  ; e_version     ; p_filesz            dd      _start                  ; e_entry       ; p_memsz            dd      4                       ; e_phoff       ; p_flags  _start:            mov     bl, 42                  ; e_shoff       ; p_align            xor     eax, eax            inc     eax                     ; e_flags            int     0x80            db      0            dw      0x34                    ; e_ehsize            dw      0x20                    ; e_phentsize            db      1                       ; e_phnum                                            ; e_shentsize                                            ; e_shnum                                            ; e_shstrndx  filesize      equ     $ - $$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译和运行效果如下：</p><pre class="line-numbers language-bash"><code class="language-bash">$ nasm -f bin -o ret ret.asm$ <span class="token function">chmod</span> +x ret$ ./ret <span class="token punctuation">;</span> <span class="token keyword">echo</span> <span class="token variable">$?</span>42$ <span class="token function">wc</span> -c ret45 ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面也给一下本文精简后的 <code>hello</code> 的 <code>nasm</code> 版本：</p><pre class="line-numbers language-assembly"><code class="language-assembly">; hello.asm  BITS 32            org     0x00010000            db      0x7F, "ELF"             ; e_ident            dd      1                                       ; p_type            dd      0                                       ; p_offset            dd      $$                                      ; p_vaddr            dw      2                       ; e_type        ; p_paddr            dw      3                       ; e_machine            dd      _start                  ; e_version     ; p_filesz            dd      _start                  ; e_entry       ; p_memsz            dd      4                       ; e_phoff       ; p_flags  _start:            pop     ecx     ; argc          ; e_shoff       ; p_align            pop     ecx     ; argv[0]            mov     dl, 5   ; str len       ; e_flags            mov     al, 4   ; sys_write(fd, addr, len) : ebx, ecx, edx            jmp     _next   ; jump to next part of the code            dw      0x34                      ; e_ehsize            dw      0x20                      ; e_phentsize            dw      1                         ; e_phnum  _next:        int     0x80    ; syscall         ; e_shentsize            mov     al, 1   ; eax=1,sys_exit  ; e_shnum            int     0x80    ; syscall         ; e_shstrndx  filesize      equ     $ - $$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译和用法如下：</p><pre class="line-numbers language-bash"><code class="language-bash">$ nasm -f bin -o hello hello.asm$ <span class="token function">chmod</span> a+x hello$ <span class="token function">export</span> PATH<span class="token operator">=</span>./:<span class="token variable">$PATH</span>$ hellohello$ <span class="token function">wc</span> -c hello52<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>经过一番努力，<code>AT&amp;T</code> 的完整 binary 版本如下：</p><pre class="line-numbers language-assembly"><code class="language-assembly"># hello.s## as --32 -o hello.o hello.s# ld -melf_i386 --oformat=binary -o hello hello.o#    .file "hello.s"    .global _start, _load    .equ   LOAD_ADDR, 0x00010000   # Page aligned load addr, here 64k    .equ   E_ENTRY, LOAD_ADDR + (_start - _load)    .equ   P_MEM_SZ, E_ENTRY    .equ   P_FILE_SZ, P_MEM_SZ_load:    .byte  0x7F    .ascii "ELF"                  # e_ident, Magic Number    .long  1                                      # p_type, loadable seg    .long  0                                      # p_offset    .long  LOAD_ADDR                              # p_vaddr    .word  2                      # e_type, exec  # p_paddr    .word  3                      # e_machine, Intel 386 target    .long  P_FILE_SZ              # e_version     # p_filesz    .long  E_ENTRY                # e_entry       # p_memsz    .long  4                      # e_phoff       # p_flags, read(exec)    .text_start:    popl   %ecx    # argc         # e_shoff       # p_align    popl   %ecx    # argv[0]    mov    $5, %dl # str len      # e_flags    mov    $4, %al # sys_write(fd, addr, len) : ebx, ecx, edx    jmp    _next    # jump to next part of the code    .word  0x34                   # e_ehsize = 52    .word  0x20                   # e_phentsize = 32    .word  1                      # e_phnum = 1    .text_next:  int    $0x80   # syscall        # e_shentsize    mov    $1, %al # eax=1,sys_exit # e_shnum    int    $0x80   # syscall        # e_shstrndx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译和运行效果如下：</p><pre class="line-numbers language-bash"><code class="language-bash">$ as --32 -o hello.o hello.s$ ld -melf_i386 --oformat<span class="token operator">=</span>binary -o hello hello.o$ <span class="token function">export</span> PATH<span class="token operator">=</span>./:<span class="token variable">$PATH</span>$ hellohello$ <span class="token function">wc</span> -c hello52 hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注</strong>：编译时务必要加 <code>--oformat=binary</code> 参数，以便直接基于源文件构建一个二进制的 <code>Elf</code> 文件，否则会被 <code>ld</code> 默认编译，自动填充其他内容。</p><h2 id="汇编语言极限精简之道（45字节）"><a href="#汇编语言极限精简之道（45字节）" class="headerlink" title="汇编语言极限精简之道（45字节）"></a>汇编语言极限精简之道（45字节）</h2><p>经过上述努力，我们已经完全把程序头和代码都融入了 52 字节的 <code>Elf</code> 文件头，还可以再进一步吗？</p><p>如果再要努力，只能设法把 <code>Elf</code> 末尾的 7 个 0 字节删除，但是由于代码已经把 <code>Elf</code> 末尾的 7 字节 0 字符都填满了，所以要想在这一块努力，只能继续压缩代码。</p><p>继续研究下代码先：</p><pre class="line-numbers language-assembly"><code class="language-assembly">.global _start_start:    popl %ecx    # argc    popl %ecx    # argv[0]    movb $5, %dl    # 设置字符串长度    movb $4, %al    # eax = 4, 设置系统调用号, sys_write(fd, addr, len) : ebx, ecx, edx    int $0x80    movb $1, %al    int $0x80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看对应的编码：</p><pre class="line-numbers language-bash"><code class="language-bash">$ as --32 -o hello.o hello.s$ ld -melf_i386 -o hello hello.o --oformat<span class="token operator">=</span>binary$ hexdump -C hello00000000  59 59 b2 05 b0 04 <span class="token function">cd</span> 80  b0 01 <span class="token function">cd</span> 80              <span class="token operator">|</span>YY<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>0000000c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每条指令对应的编码映射如下：</p><table><thead><tr><th>指令</th><th>编码</th><th>说明</th></tr></thead><tbody><tr><td>popl %ecx</td><td>59</td><td>argc</td></tr><tr><td>popl %ecx</td><td>59</td><td>argv[0]</td></tr><tr><td>movb $5, %dl</td><td>b2 05</td><td>设置字符串长度</td></tr><tr><td>movb $4, %al</td><td>b0 04</td><td>eax = 4, 设置系统调用号, sys_write(fd, addr, len) : ebx, ecx, edx</td></tr><tr><td>int $0x80</td><td>cd 80</td><td>触发系统调用</td></tr><tr><td>movb $1, %al</td><td>b0 01</td><td>eax = 1, sys_exit</td></tr><tr><td>int $0x80</td><td>cd 80</td><td>触发系统调用</td></tr></tbody></table><p>可以观察到：</p><ul><li><code>popl</code> 的指令编码最简洁。</li><li><code>int $0x80</code> 重复了两次，而且每条都占用了 2 字节</li><li><code>movb</code> 每条都占用了 2 字节</li><li><code>eax</code> 有两次赋值，每次占用了 2 字节</li><li><code>popl %ecx</code> 取出的 argc 并未使用</li></ul><p>根据之前通过参数传递字符串的想法，咱们是否可以考虑通过参数来设置变量呢？</p><p>理论上，传入多个参数，通过 <code>pop</code> 弹出来赋予 <code>eax</code>, <code>ecx</code> 即可，但是实际上，由于从参数栈里头 <code>pop</code> 出来的参数是参数的地址，并不是参数本身，所以该方法行不通。</p><p>不过由于第一个参数取出的是数字，并且是参数个数，而且目前的那条 <code>popl %ecx</code> 取出的 <code>argc</code> 并没有使用，那么刚好可以用来设置 <code>eax</code>，替换后如下：</p><pre><code>.global _start_start:    popl %eax    # eax = 4, 设置系统调用号, sys_write(fd, addr, len) : ebx, ecx, edx    popl %ecx    # argv[0], 字符串    movb $5, %dl # 设置字符串长度    int $0x80    movb $1, %al # eax = 1, sys_exit    int $0x80</code></pre><p>这里需要传入 4 个参数，即让栈弹出的第一个值，也就是参数个数赋予 <code>eax</code>，也就是：<code>hello 5 4 1</code>。</p><p>这样，我们就把该代码优化到 10 个字节，刚好可以放到 <code>e_phentsize</code> 之前。</p><p>那最后的结果是，我们产生了一个可以正常打印字符串，大小只有 45 字节的 <code>Elf</code> 文件，最终的结果如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># hello.s</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># $ as --32 -o hello.o hello.s</span><span class="token comment" spellcheck="true"># $ ld -melf_i386 --oformat=binary -o hello hello.o</span><span class="token comment" spellcheck="true"># $ export PATH=./:$PATH</span><span class="token comment" spellcheck="true"># $ hello 0 0 0</span><span class="token comment" spellcheck="true"># hello</span><span class="token comment" spellcheck="true">#</span>    .file <span class="token string">"hello.s"</span>    .global _start, _load    .equ   LOAD_ADDR, 0x00010000   <span class="token comment" spellcheck="true"># Page aligned load addr, here 64k</span>    .equ   E_ENTRY, LOAD_ADDR + <span class="token punctuation">(</span>_start - _load<span class="token punctuation">)</span>    .equ   P_MEM_SZ, E_ENTRY    .equ   P_FILE_SZ, P_MEM_SZ_load:    .byte  0x7F    .ascii <span class="token string">"ELF"</span>              <span class="token comment" spellcheck="true"># e_ident, Magic Number</span>    .long  1                                      <span class="token comment" spellcheck="true"># p_type, loadable seg</span>    .long  0                                      <span class="token comment" spellcheck="true"># p_offset</span>    .long  LOAD_ADDR                              <span class="token comment" spellcheck="true"># p_vaddr</span>    .word  2                  <span class="token comment" spellcheck="true"># e_type, exec  # p_paddr</span>    .word  3                  <span class="token comment" spellcheck="true"># e_machine, Intel 386 target</span>    .long  P_FILE_SZ          <span class="token comment" spellcheck="true"># e_version     # p_filesz</span>    .long  E_ENTRY            <span class="token comment" spellcheck="true"># e_entry       # p_memsz</span>    .long  4                  <span class="token comment" spellcheck="true"># e_phoff       # p_flags, read(exec)</span>    .text_start:    popl   %eax    <span class="token comment" spellcheck="true"># argc     # e_shoff       # p_align</span>                   <span class="token comment" spellcheck="true"># 4 args, eax = 4, sys_write(fd, addr, len) : ebx, ecx, edx</span>                   <span class="token comment" spellcheck="true"># set 2nd eax = random addr to trigger bad syscall for exit</span>    popl   %ecx    <span class="token comment" spellcheck="true"># argv[0]</span>    mov    <span class="token variable">$5</span>, %dl <span class="token comment" spellcheck="true"># str len  # e_flags</span>    int    <span class="token variable">$0x80</span>    mov    <span class="token variable">$1</span>, %al <span class="token comment" spellcheck="true"># eax = 1, sys_exit</span>    int    <span class="token variable">$0x80</span>    .word  0x20               <span class="token comment" spellcheck="true"># e_phentsize = 32</span>    .byte  1                  <span class="token comment" spellcheck="true"># e_phnum = 1, remove trailing 7 bytes with 0 value</span>                              <span class="token comment" spellcheck="true"># e_shentsize</span>                              <span class="token comment" spellcheck="true"># e_shnum</span>                              <span class="token comment" spellcheck="true"># e_shstrndx</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果如下：</p><pre class="line-numbers language-bash"><code class="language-bash">$ as --32 -o hello.o hello.s$ ld -melf_i386 -o hello hello.o --oformat<span class="token operator">=</span>binary$ <span class="token function">export</span> PATH<span class="token operator">=</span>./:<span class="token variable">$PATH</span>$ hello 0 0 0hello$ <span class="token function">wc</span> -c hello45 hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到这里，我们获得了史上最小的可以打印字符串的 <code>Elf</code> 文件，是的，只有 45 个字节。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到这里，关于可执行文件的讨论暂且结束，最后来一段小小的总结，那就是我们设法去减少可执行文件大小的意义？</p><p>实际上，通过这样一个讨论深入到了很多技术的细节，包括可执行文件的格式、目标代码链接的过程、 Linux 下汇编语言开发等。与此同时，可执行文件大小的减少本身对嵌入式系统非常有用，如果删除那些对程序运行没有影响的节区和节区表将减少目标系统的大小，适应嵌入式系统资源受限的需求。除此之外，动态连接库中的很多函数可能不会被使用到，因此也可以通过某种方式剔除。</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> C </tag>
            
            <tag> 编程透视 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程和进程的基本操作</title>
      <link href="posts/41036/"/>
      <url>posts/41036/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>进程作为程序真正发挥作用时的“形态”，我们有必要对它的一些相关操作非常熟悉，这一节主要描述进程相关的概念和操作，将介绍包括程序、进程、作业等基本概念以及进程状态查询、进程通信等相关的操作。</p><h2 id="什么是程序，什么又是进程"><a href="#什么是程序，什么又是进程" class="headerlink" title="什么是程序，什么又是进程"></a>什么是程序，什么又是进程</h2><p>程序是指令的集合，而进程则是程序执行的基本单元。为了让程序完成它的工作，必须让程序运行起来成为进程，进而利用处理器资源、内存资源，进行各种 <code>I/O</code> 操作，从而完成某项特定工作。</p><p>从这个意思上说，程序是静态的，而进程则是动态的。</p><p>进程有区别于程序的地方还有：进程除了包含程序文件中的指令数据以外，还需要在内核中有一个数据结构用以存放特定进程的相关属性，以便内核更好地管理和调度进程，从而完成多进程协作的任务。因此，从这个意义上可以说“高于”程序，超出了程序指令本身。</p><p>如果进行过多进程程序的开发，又会发现，一个程序可能创建多个进程，通过多个进程的交互完成任务。在 Linux 下，多进程的创建通常是通过 <code>fork</code> 系统调用来实现。从这个意义上来说程序则”包含”了进程。</p><p>另外一个需要明确的是，程序可以由多种不同程序语言描述，包括 C 语言程序、汇编语言程序和最后编译产生的机器指令等。</p><p>下面简单讨论 Linux 下面如何通过 Shell 进行进程的相关操作。</p><h2 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h2><p>通常在命令行键入某个程序文件名以后，一个进程就被创建了。例如，</p><h3 id="让程序在后台运行"><a href="#让程序在后台运行" class="headerlink" title="让程序在后台运行"></a>让程序在后台运行</h3><pre><code>$ sleep 100 &amp;[1] 9298</code></pre><h3 id="查看进程-ID"><a href="#查看进程-ID" class="headerlink" title="查看进程 ID"></a>查看进程 ID</h3><p>用<code>pidof</code>可以查看指定程序名的进程ID：</p><pre><code>$ pidof sleep9298</code></pre><h3 id="查看进程的内存映像"><a href="#查看进程的内存映像" class="headerlink" title="查看进程的内存映像"></a>查看进程的内存映像</h3><pre><code>$ cat /proc/9298/maps08048000-0804b000 r-xp 00000000 08:01 977399     /bin/sleep0804b000-0804c000 rw-p 00003000 08:01 977399     /bin/sleep0804c000-0806d000 rw-p 0804c000 00:00 0          [heap]b7c8b000-b7cca000 r--p 00000000 08:01 443354     ...bfbd8000-bfbed000 rw-p bfbd8000 00:00 0          [stack]ffffe000-fffff000 r-xp 00000000 00:00 0          [vdso]</code></pre><p>程序被执行后，就被加载到内存中，成为了一个进程。上面显示了该进程的内存映像（虚拟内存），包括程序指令、数据，以及一些用于存放程序命令行参数、环境变量的栈空间，用于动态内存申请的堆空间都被分配好。</p><p>实际上，创建一个进程，也就是说让程序运行，还有其他的办法，比如，通过一些配置让系统启动时自动启动程序（具体参考 <code>man init</code>），或者是通过配置 <code>crond</code> （或者 <code>at</code>）让它定时启动程序。除此之外，还有一个方式，那就是编写 Shell 脚本，把程序写入一个脚本文件，当执行脚本文件时，文件中的程序将被执行而成为进程。这些方式的细节就不介绍，下面了解如何查看进程的属性。</p><p>需要补充一点的是：在命令行下执行程序，可以通过 <code>ulimit</code> 内置命令来设置进程可以利用的资源，比如进程可以打开的最大文件描述符个数，最大的栈空间，虚拟内存空间等。具体用法见 <code>help ulimit</code> 。</p><h2 id="查看进程的属性和状态"><a href="#查看进程的属性和状态" class="headerlink" title="查看进程的属性和状态"></a>查看进程的属性和状态</h2><p>可以通过 <code>ps</code> 命令查看进程相关属性和状态，这些信息包括进程所属用户，进程对应的程序，进程对 <code>cpu</code> 和内存的使用情况等信息。熟悉如何查看它们有助于进行相关的统计分析等操作。</p><h3 id="通过-ps-命令查看进程属性"><a href="#通过-ps-命令查看进程属性" class="headerlink" title="通过 ps 命令查看进程属性"></a>通过 ps 命令查看进程属性</h3><p>查看系统当前所有进程的属性：</p><pre><code>$ ps -ef</code></pre><p>查看命令中包含某字符的程序对应的进程，进程 <code>ID</code> 是 1 。 <code>TTY</code> 为？表示和终端没有关联：</p><pre><code>$ ps -C init  PID TTY          TIME CMD    1 ?        00:00:01 init</code></pre><p>选择某个特定用户启动的进程：</p><pre><code>$ ps -U falcon</code></pre><p>按照指定格式输出指定内容，下面输出命令名和 <code>cpu</code> 使用率：</p><pre><code>$ ps -e -o &quot;%C %c&quot;</code></pre><p>打印 <code>cpu</code> 使用率最高的前 4 个程序：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ps</span> -e -o <span class="token string">"%C %c"</span> <span class="token operator">|</span> <span class="token function">sort</span> -u -k1 -r <span class="token operator">|</span> <span class="token function">head</span> -5 7.5 firefox-bin 1.1 Xorg 0.8 scim-panel-gtk 0.2 scim-bridge<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>获取使用虚拟内存最大的 5 个进程：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ps</span> -e -o <span class="token string">"%z %c"</span> <span class="token operator">|</span> <span class="token function">sort</span> -n -k1 -r <span class="token operator">|</span> <span class="token function">head</span> -5349588 firefox-bin 96612 xfce4-terminal 88840 xfdesktop 76332 gedit 58920 scim-panel-gtk<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="通过-pstree-查看进程亲缘关系"><a href="#通过-pstree-查看进程亲缘关系" class="headerlink" title="通过 pstree 查看进程亲缘关系"></a>通过 pstree 查看进程亲缘关系</h3><p>系统所有进程之间都有“亲缘”关系，可以通过 <code>pstree</code> 查看这种关系：</p><pre><code>$ pstree</code></pre><p>上面会打印系统进程调用树，可以非常清楚地看到当前系统中所有活动进程之间的调用关系。</p><h3 id="用top动态查看进程信息"><a href="#用top动态查看进程信息" class="headerlink" title="用top动态查看进程信息"></a>用top动态查看进程信息</h3><pre><code>$ top</code></pre><p>该命令最大特点是可以动态地查看进程信息，当然，它还提供了一些其他的参数，比如 <code>-S</code> 可以按照累计执行时间的大小排序查看，也可以通过 <code>-u</code> 查看指定用户启动的进程等。</p><p>补充： <code>top</code> 命令支持交互式，比如它支持 <code>u</code> 命令显示用户的所有进程，支持通过 <code>k</code> 命令杀掉某个进程；如果使用 <code>-n 1</code> 选项可以启用批处理模式，具体用法为：</p><pre><code>$ top -n 1 -b</code></pre><h3 id="确保特定程序只有一个副本在运行"><a href="#确保特定程序只有一个副本在运行" class="headerlink" title="确保特定程序只有一个副本在运行"></a>确保特定程序只有一个副本在运行</h3><p>下面来讨论一个有趣的问题：如何让一个程序在同一时间只有一个在运行。</p><p>这意味着当一个程序正在被执行时，它将不能再被启动。那该怎么做呢？</p><p>假如一份相同的程序被复制成了很多份，并且具有不同的文件名被放在不同的位置，这个将比较糟糕，所以考虑最简单的情况，那就是这份程序在整个系统上是唯一的，而且名字也是唯一的。这样的话，有哪些办法来回答上面的问题呢？</p><p>总的机理是：在程序开头检查自己有没有执行，如果执行了则停止否则继续执行后续代码。</p><p>策略则是多样的，由于前面的假设已经保证程序文件名和代码的唯一性，所以通过 <code>ps</code> 命令找出当前所有进程对应的程序名，逐个与自己的程序名比较，如果已经有，那么说明自己已经运行了。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">ps</span> -e -o <span class="token string">"%c"</span> <span class="token operator">|</span> <span class="token function">tr</span> -d <span class="token string">" "</span> <span class="token operator">|</span> <span class="token function">grep</span> -q ^init$   <span class="token comment" spellcheck="true">#查看当前程序是否执行</span><span class="token punctuation">[</span> <span class="token variable">$?</span> -eq 0 <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">exit</span>   <span class="token comment" spellcheck="true">#如果在，那么退出, $?表示上一条指令是否执行成功</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>每次运行时先在指定位置检查是否存在一个保存自己进程 <code>ID</code> 的文件，如果不存在，那么继续执行，如果存在，那么查看该进程 <code>ID</code> 是否正在运行，如果在，那么退出，否则往该文件重新写入新的进程 <code>ID</code>，并继续。</p><pre class="line-numbers language-bash"><code class="language-bash">pidfile<span class="token operator">=</span>/tmp/<span class="token variable">$0</span><span class="token string">".pid"</span> <span class="token keyword">if</span> <span class="token punctuation">[</span> -f <span class="token variable">$pidfile</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>       OLDPID<span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">cat</span> $pidfile<span class="token variable">)</span></span>    <span class="token function">ps</span> -e -o <span class="token string">"%p"</span> <span class="token operator">|</span> <span class="token function">tr</span> -d <span class="token string">" "</span> <span class="token operator">|</span> <span class="token function">grep</span> -q <span class="token string">"^<span class="token variable">$OLDPID</span>$"</span>    <span class="token punctuation">[</span> <span class="token variable">$?</span> -eq 0 <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">exit</span><span class="token keyword">fi</span><span class="token keyword">echo</span> $$ <span class="token operator">></span> <span class="token variable">$pidfile</span><span class="token comment" spellcheck="true">#... 代码主体</span><span class="token comment" spellcheck="true">#设置信号0的动作，当程序退出时触发该信号从而删除掉临时文件</span><span class="token function">trap</span> <span class="token string">"rm <span class="token variable">$pidfile</span>"</span>      0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="调整进程的优先级"><a href="#调整进程的优先级" class="headerlink" title="调整进程的优先级"></a>调整进程的优先级</h2><p>在保证每个进程都能够顺利执行外，为了让某些任务优先完成，那么系统在进行进程调度时就会采用一定的调度办法，比如常见的有按照优先级的时间片轮转的调度算法。这种情况下，可以通过 <code>renice</code> 调整正在运行的程序的优先级，例如：`</p><h3 id="获取进程优先级"><a href="#获取进程优先级" class="headerlink" title="获取进程优先级"></a>获取进程优先级</h3><pre><code>$ ps -e -o &quot;%p %c %n&quot; | grep xfs 5089 xfs               0</code></pre><h3 id="调整进程的优先级-1"><a href="#调整进程的优先级-1" class="headerlink" title="调整进程的优先级"></a>调整进程的优先级</h3><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">renice</span> 1 -p 5089renice: 5089: setpriority: Operation not permitted$ <span class="token function">sudo</span> <span class="token function">renice</span> 1 -p 5089   <span class="token comment" spellcheck="true">#需要权限才行</span><span class="token punctuation">[</span>sudo<span class="token punctuation">]</span> password <span class="token keyword">for</span> falcon:5089: old priority 0, new priority 1$ <span class="token function">ps</span> -e -o <span class="token string">"%p %c %n"</span> <span class="token operator">|</span> <span class="token function">grep</span> xfs  <span class="token comment" spellcheck="true">#再看看，优先级已经被调整过来了</span> 5089 xfs               1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h2><p>既然可以通过命令行执行程序，创建进程，那么也有办法结束它。可以通过 <code>kill</code> 命令给用户自己启动的进程发送某个信号让进程终止，当然“万能”的 <code>root</code> 几乎可以 <code>kill</code> 所有进程（除了 <code>init</code> 之外）。例如，</p><h3 id="结束进程-1"><a href="#结束进程-1" class="headerlink" title="结束进程"></a>结束进程</h3><pre><code>$ sleep 50 &amp;   #启动一个进程[1] 11347$ kill 11347</code></pre><p><code>kill</code> 命令默认会发送终止信号（ <code>SIGTERM</code> ）给程序，让程序退出，但是 <code>kill</code> 还可以发送其他信号，这些信号的定义可以通过 <code>man 7 signal</code> 查看到，也可以通过 <code>kill -l</code> 列出来。</p><pre><code>$ man 7 signal$ kill -l 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL 5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE 9) SIGKILL     10) SIGUSR1     11) SIGSEGV     12) SIGUSR213) SIGPIPE     14) SIGALRM     15) SIGTERM     16) SIGSTKFLT17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU25) SIGXFSZ     26) SIGVTALRM   27) SIGPROF     28) SIGWINCH29) SIGIO       30) SIGPWR      31) SIGSYS      34) SIGRTMIN35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3  38) SIGRTMIN+439) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+843) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+1247) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-1451) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-1055) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7  58) SIGRTMAX-659) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-263) SIGRTMAX-1  64) SIGRTMAX</code></pre><h3 id="暂停某个进程"><a href="#暂停某个进程" class="headerlink" title="暂停某个进程"></a>暂停某个进程</h3><p>例如，用 <code>kill</code> 命令发送 <code>SIGSTOP</code> 信号给某个程序，让它暂停，然后发送 <code>SIGCONT</code> 信号让它继续运行。</p><pre><code>$ sleep 50 &amp;[1] 11441$ jobs[1]+  Running                 sleep 50 &amp;$ kill -s SIGSTOP 11441   #这个等同于我们对一个前台进程执行CTRL+Z操作$ jobs[1]+  Stopped                 sleep 50$ kill -s SIGCONT 11441   #这个等同于之前我们使用bg %1操作让一个后台进程运行起来$ jobs[1]+  Running                 sleep 50 &amp;$ kill %1                  #在当前会话(session)下，也可以通过作业号控制进程$ jobs[1]+  Terminated              sleep 50</code></pre><p>可见 <code>kill</code> 命令提供了非常好的功能，不过它只能根据进程的 <code>ID</code> 或者作业来控制进程，而 <code>pkill</code> 和 <code>killall</code> 提供了更多选择，它们扩展了通过程序名甚至是进程的用户名来控制进程的方法。更多用法请参考它们的手册。</p><h3 id="查看进程退出状态"><a href="#查看进程退出状态" class="headerlink" title="查看进程退出状态"></a>查看进程退出状态</h3><p>当程序退出后，如何判断这个程序是正常退出还是异常退出呢？还记得 Linux 下，那个经典 <code>hello world</code> 程序吗？在代码的最后总是有条 <code>return 0</code> 语句。这个 <code>return 0</code> 实际上是让程序员来检查进程是否正常退出的。如果进程返回了一个其他的数值，那么可以肯定地说这个进程异常退出了，因为它都没有执行到 <code>return 0</code> 这条语句就退出了。</p><p>那怎么检查进程退出的状态，即那个返回的数值呢？</p><p>在 <code>Shell</code> 中，可以检查这个特殊的变量 <code>$?</code>，它存放了上一条命令执行后的退出状态。</p><pre class="line-numbers language-bash"><code class="language-bash">$ test1bash: test1: <span class="token function">command</span> not found$ <span class="token keyword">echo</span> <span class="token variable">$?</span>127$ <span class="token function">cat</span> ./test.c <span class="token operator">|</span> <span class="token function">grep</span> hello$ <span class="token keyword">echo</span> <span class="token variable">$?</span>1$ <span class="token function">cat</span> ./test.c <span class="token operator">|</span> <span class="token function">grep</span> hi    printf<span class="token punctuation">(</span><span class="token string">"hi, myself!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>$ <span class="token keyword">echo</span> <span class="token variable">$?</span>0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>貌似返回 0 成为了一个潜规则，虽然没有标准明确规定，不过当程序正常返回时，总是可以从 <code>$?</code> 中检测到 0，但是异常时，总是检测到一个非 0 值。这就告诉我们在程序的最后最好是跟上一个 <code>exit 0</code> 以便任何人都可以通过检测 <code>$?</code> 确定程序是否正常结束。如果有一天，有人偶尔用到你的程序，试图检查它的退出状态，而你却在程序的末尾莫名地返回了一个 <code>-1</code> 或者 1，那么他将会很苦恼，会怀疑他自己编写的程序到底哪个地方出了问题，检查半天却不知所措，因为他太信任你了，竟然从头至尾都没有怀疑你的编程习惯可能会与众不同！</p><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>为便于设计和实现，通常一个大型的任务都被划分成较小的模块。不同模块之间启动后成为进程，它们之间如何通信以便交互数据，协同工作呢？在APUE一书中提到很多方法，诸如管道（无名管道和有名管道）、信号（<code>signal</code>）、报文（<code>Message</code>）队列（消息队列）、共享内存（<code>mmap/munmap</code>）、信号量（<code>semaphore</code>，主要是同步用，进程之间，进程的不同线程之间）、套接口（<code>Socket</code>，支持不同机器之间的进程通信）等，而在 Shell 中，通常直接用到的就有管道和信号等。下面主要介绍管道和信号机制在 Shell 编程时的一些用法。</p><h3 id="无名管道（pipe）"><a href="#无名管道（pipe）" class="headerlink" title="无名管道（pipe）"></a>无名管道（pipe）</h3><p>在 Linux 下，可以通过 <code>|</code> 连接两个程序，这样就可以用它来连接后一个程序的输入和前一个程序的输出，因此被形象地叫做个管道。在 C 语言中，创建无名管道非常简单方便，用 <code>pipe</code> 函数，传入一个具有两个元素的 <code>int</code> 型的数组就可以。这个数组实际上保存的是两个文件描述符，父进程往第一个文件描述符里头写入东西后，子进程可以从第一个文件描述符中读出来。</p><p>如果用多了命令行，这个管子 <code>|</code> 应该会经常用。比如上面有个演示把 <code>ps</code> 命令的输出作为 <code>grep</code> 命令的输入：</p><pre><code>$ ps -ef | grep init</code></pre><p>也许会觉得这个“管子”好有魔法，竟然真地能够链接两个程序的输入和输出，它们到底是怎么实现的呢？实际上当输入这样一组命令时，当前 Shell 会进行适当的解析，把前面一个进程的输出关联到管道的输出文件描述符，把后面一个进程的输入关联到管道的输入文件描述符，这个关联过程通过输入输出重定向函数 <code>dup</code> （或者 <code>fcntl</code> ）来实现。</p><h3 id="有名管道（named-pipe）"><a href="#有名管道（named-pipe）" class="headerlink" title="有名管道（named pipe）"></a>有名管道（named pipe）</h3><p>有名管道实际上是一个文件（无名管道也像一个文件，虽然关系到两个文件描述符，不过只能一边读另外一边写），不过这个文件比较特别，操作时要满足先进先出，而且，如果试图读一个没有内容的有名管道，那么就会被阻塞，同样地，如果试图往一个有名管道里写东西，而当前没有程序试图读它，也会被阻塞。下面看看效果。</p><pre><code>$ mkfifo fifo_test    #通过mkfifo命令创建一个有名管道$ echo &quot;fewfefe&quot; &gt; fifo_test#试图往fifo_test文件中写入内容，但是被阻塞，要另开一个终端继续下面的操作$ cat fifo_test        #另开一个终端，记得，另开一个。试图读出fifo_test的内容fewfefe</code></pre><p>这里的 <code>echo</code> 和 <code>cat</code> 是两个不同的程序，在这种情况下，通过 <code>echo</code> 和 <code>cat</code> 启动的两个进程之间并没有父子关系。不过它们依然可以通过有名管道通信。</p><p>这样一种通信方式非常适合某些特定情况：例如有这样一个架构，这个架构由两个应用程序构成，其中一个通过循环不断读取 <code>fifo_test</code> 中的内容，以便判断，它下一步要做什么。如果这个管道没有内容，那么它就会被阻塞在那里，而不会因死循环而耗费资源，另外一个则作为一个控制程序不断地往 <code>fifo_test</code> 中写入一些控制信息，以便告诉之前的那个程序该做什么。下面写一个非常简单的例子。可以设计一些控制码，然后控制程序不断地往 <code>fifo_test</code> 里头写入，然后应用程序根据这些控制码完成不同的动作。当然，也可以往 <code>fifo_test</code> 传入除控制码外的其他数据。</p><ul><li><p>应用程序的代码</p><pre class="line-numbers language-bash"><code class="language-bash">  $ <span class="token function">cat</span> app.sh  <span class="token comment" spellcheck="true">#!/bin/bash</span>  FIFO<span class="token operator">=</span>fifo_test  <span class="token keyword">while</span> <span class="token keyword">:</span><span class="token punctuation">;</span>  <span class="token keyword">do</span>      CI<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">cat</span> $FIFO<span class="token variable">`</span></span>  <span class="token comment" spellcheck="true">#CI --> Control Info</span>      <span class="token keyword">case</span> <span class="token variable">$CI</span> <span class="token keyword">in</span>          0<span class="token punctuation">)</span> <span class="token keyword">echo</span> <span class="token string">"The CONTROL number is ZERO, do something ..."</span>              <span class="token punctuation">;</span><span class="token punctuation">;</span>          1<span class="token punctuation">)</span> <span class="token keyword">echo</span> <span class="token string">"The CONTROL number is ONE, do something ..."</span>              <span class="token punctuation">;</span><span class="token punctuation">;</span>          *<span class="token punctuation">)</span> <span class="token keyword">echo</span> <span class="token string">"The CONTROL number not recognized, do something else..."</span>              <span class="token punctuation">;</span><span class="token punctuation">;</span>      esac  <span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>控制程序的代码</p><pre class="line-numbers language-bash"><code class="language-bash">  $ <span class="token function">cat</span> control.sh  <span class="token comment" spellcheck="true">#!/bin/bash</span>  FIFO<span class="token operator">=</span>fifo_test  CI<span class="token operator">=</span><span class="token variable">$1</span>  <span class="token punctuation">[</span> -z <span class="token string">"<span class="token variable">$CI</span>"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">echo</span> <span class="token string">"the control info should not be empty"</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">exit</span>   <span class="token keyword">echo</span> <span class="token variable">$CI</span> <span class="token operator">></span> <span class="token variable">$FIFO</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>一个程序通过管道控制另外一个程序的工作</p><pre class="line-numbers language-bash"><code class="language-bash">  $ <span class="token function">chmod</span> +x app.sh control.sh    <span class="token comment" spellcheck="true">#修改这两个程序的可执行权限，以便用户可以执行它们</span>  $ ./app.sh  <span class="token comment" spellcheck="true">#在一个终端启动这个应用程序，在通过./control.sh发送控制码以后查看输出</span>  The CONTROL number is ONE, <span class="token keyword">do</span> something <span class="token punctuation">..</span>.    <span class="token comment" spellcheck="true">#发送1以后</span>  The CONTROL number is ZERO, <span class="token keyword">do</span> something <span class="token punctuation">..</span>.    <span class="token comment" spellcheck="true">#发送0以后</span>  The CONTROL number not recognized, <span class="token keyword">do</span> something else<span class="token punctuation">..</span>.  <span class="token comment" spellcheck="true">#发送一个未知的控制码以后</span>  $ ./control.sh 1            <span class="token comment" spellcheck="true">#在另外一个终端，发送控制信息，控制应用程序的工作</span>  $ ./control.sh 0  $ ./control.sh 4343<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>这样一种应用架构非常适合本地的多程序任务设计，如果结合 <code>web cgi</code>，那么也将适合远程控制的要求。引入 <code>web cgi</code> 的唯一改变是，要把控制程序 <code>./control.sh</code> 放到 <code>web</code> 的 <code>cgi</code> 目录下，并对它作一些修改，以使它符合 <code>CGI</code> 的规范，这些规范包括文档输出格式的表示（在文件开头需要输出 <code>content-tpye: text/html</code> 以及一个空白行）和输入参数的获取 <code>(web</code> 输入参数都存放在 <code>QUERY_STRING</code> 环境变量里头）。因此一个非常简单的 <code>CGI</code> 控制程序可以写成这样：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>FIFO<span class="token operator">=</span>./fifo_testCI<span class="token operator">=</span><span class="token variable">$QUERY_STRING</span><span class="token punctuation">[</span> -z <span class="token string">"<span class="token variable">$CI</span>"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">echo</span> <span class="token string">"the control info should not be empty"</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">exit</span> <span class="token keyword">echo</span> -e <span class="token string">"content-type: text/html\n\n"</span><span class="token keyword">echo</span> <span class="token variable">$CI</span> <span class="token operator">></span> <span class="token variable">$FIFO</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在实际使用时，请确保 <code>control.sh</code> 能够访问到 <code>fifo_test</code> 管道，并且有写权限，以便通过浏览器控制 <code>app.sh</code> ：</p><pre><code>http://ipaddress\_or\_dns/cgi-bin/control.sh?0</code></pre><p>问号 <code>?</code> 后面的内容即 <code>QUERY_STRING</code>，类似之前的 <code>$1</code> 。</p><p>这样一种应用对于远程控制，特别是嵌入式系统的远程控制很有实际意义。在去年的暑期课程上，我们就通过这样一种方式来实现马达的远程控制。首先，实现了一个简单的应用程序以便控制马达的转动，包括转速，方向等的控制。为了实现远程控制，我们设计了一些控制码，以便控制马达转动相关的不同属性。</p><p>在 C 语言中，如果要使用有名管道，和 Shell 类似，只不过在读写数据时用 <code>read</code>，<code>write</code> 调用，在创建 <code>fifo</code> 时用 <code>mkfifo</code> 函数调用。</p><h3 id="信号（Signal）"><a href="#信号（Signal）" class="headerlink" title="信号（Signal）"></a>信号（Signal）</h3><p>信号是软件中断，Linux 用户可以通过 <code>kill</code> 命令给某个进程发送一个特定的信号，也可以通过键盘发送一些信号，比如 <code>CTRL+C</code> 可能触发 <code>SGIINT</code> 信号，而 <code>CTRL+\</code> 可能触发 <code>SGIQUIT</code> 信号等，除此之外，内核在某些情况下也会给进程发送信号，比如在访问内存越界时产生 <code>SGISEGV</code> 信号，当然，进程本身也可以通过 <code>kill</code>，<code>raise</code> 等函数给自己发送信号。对于 Linux 下支持的信号类型，大家可以通过 <code>man 7 signal</code> 或者 <code>kill -l</code> 查看到相关列表和说明。</p><p>对于有些信号，进程会有默认的响应动作，而有些信号，进程可能直接会忽略，当然，用户还可以对某些信号设定专门的处理函数。在 Shell 中，可以通过 <code>trap</code> 命令（Shell 内置命令）来设定响应某个信号的动作（某个命令或者定义的某个函数），而在 C 语言中可以通过 <code>signal</code> 调用注册某个信号的处理函数。这里仅仅演示 <code>trap</code> 命令的用法。</p><pre><code>$ function signal_handler { echo &quot;hello, world.&quot;; } #定义signal_handler函数$ trap signal_handler SIGINT  #执行该命令设定：收到SIGINT信号时打印hello, world$ hello, world     #按下CTRL+C，可以看到屏幕上输出了hello, world字符串</code></pre><p>类似地，如果设定信号 0 的响应动作，那么就可以用 <code>trap</code> 来模拟 C 语言程序中的 <code>atexit</code> 程序终止函数的登记，即通过 <code>trap signal_handler SIGQUIT</code> 设定的 <code>signal_handler</code> 函数将在程序退出时执行。信号 0 是一个特别的信号，在 <code>POSIX.1</code> 中把信号编号 0 定义为空信号，这常被用来确定一个特定进程是否仍旧存在。当一个程序退出时会触发该信号。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> sigexit.sh<span class="token comment" spellcheck="true">#!/bin/bash</span><span class="token keyword">function</span> signal_handler <span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">"hello, world"</span><span class="token punctuation">}</span><span class="token function">trap</span> signal_handler 0$ <span class="token function">chmod</span> +x sigexit.sh$ ./sigexit.sh    <span class="token comment" spellcheck="true">#实际Shell编程会用该方式在程序退出时来做一些清理临时文件的收尾工作</span>hello, world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="作业和作业控制"><a href="#作业和作业控制" class="headerlink" title="作业和作业控制"></a>作业和作业控制</h2><p>当我们为完成一些复杂的任务而将多个命令通过 <code>|,\&gt;,&lt;, ;, (,)</code> 等组合在一起时，通常这个命令序列会启动多个进程，它们间通过管道等进行通信。而有时在执行一个任务的同时，还有其他的任务需要处理，那么就经常会在命令序列的最后加上一个&amp;，或者在执行命令后，按下 <code>CTRL+Z</code> 让前一个命令暂停。以便做其他的任务。等做完其他一些任务以后，再通过 <code>fg</code> 命令把后台任务切换到前台。这样一种控制过程通常被成为作业控制，而那些命令序列则被成为作业，这个作业可能涉及一个或者多个程序，一个或者多个进程。下面演示一下几个常用的作业控制操作。</p><h3 id="创建后台进程，获取进程的作业号和进程号"><a href="#创建后台进程，获取进程的作业号和进程号" class="headerlink" title="创建后台进程，获取进程的作业号和进程号"></a>创建后台进程，获取进程的作业号和进程号</h3><pre><code>$ sleep 50 &amp;[1] 11137</code></pre><h3 id="把作业调到前台并暂停"><a href="#把作业调到前台并暂停" class="headerlink" title="把作业调到前台并暂停"></a>把作业调到前台并暂停</h3><p>使用 Shell 内置命令 <code>fg</code> 把作业 1 调到前台运行，然后按下 <code>CTRL+Z</code> 让该进程暂停</p><pre><code>$ fg %1sleep 50^Z[1]+  Stopped                 sleep 50</code></pre><h3 id="查看当前作业情况"><a href="#查看当前作业情况" class="headerlink" title="查看当前作业情况"></a>查看当前作业情况</h3><pre><code>$ jobs            #查看当前作业情况，有一个作业停止[1]+  Stopped                 sleep 50$ sleep 100 &amp;     #让另外一个作业在后台运行[2] 11138         $ jobs            #查看当前作业情况，一个正在运行，一个停止[1]+  Stopped                 sleep 50[2]-  Running                 sleep 100 &amp;</code></pre><h3 id="启动停止的进程并运行在后台"><a href="#启动停止的进程并运行在后台" class="headerlink" title="启动停止的进程并运行在后台"></a>启动停止的进程并运行在后台</h3><pre><code>$ bg %1[2]+ sleep 50 &amp;</code></pre><p>不过，要在命令行下使用作业控制，需要当前 Shell，内核终端驱动等对作业控制支持才行。</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> C </tag>
            
            <tag> 编程透视 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序执行时发生了什么</title>
      <link href="posts/46405/"/>
      <url>posts/46405/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是命令行接口"><a href="#什么是命令行接口" class="headerlink" title="什么是命令行接口"></a>什么是命令行接口</h2><p>用户使用计算机有两种常见的方式，一种是图形化的接口（GUI），另外一种则是命令行接口（CLI）。对于图形化的接口，用户点击某个图标就可启动后台的某个程序；对于命令行的接口，用户键入某个程序的名字就可启动某个程序。这两者的基本过程是类似的，都需要查找程序文件在磁盘上的位置，加载到内存并通过不同的解释器进行解析和运行。下面以命令行为例来介绍程序执行一刹那发生的一些事情。</p><p>首先来介绍什么是命令行？命令行就是 <code>Command Line</code>，很直观的概念就是系统启动后的那个黑屏幕：有一个提示符，并有光标在闪烁的那样一个终端，一般情况下可以用 <code>CTRL+ALT+F1-6</code> 切换到不同的终端；在 GUI 界面下也会有一些伪终端，看上去和系统启动时的那个终端没有什么区别，也会有一个提示符，并有一个光标在闪烁。就提示符和响应用户的键盘输入而言，它们两者在功能上是一样的，实际上它们就是同一个东西，用下面的命令就可以把它们打印出来。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$SHELL</span> <span class="token comment" spellcheck="true"># 打印当前SHELL，当前运行的命令行接口程序</span>/bin/bash$ <span class="token keyword">echo</span> $$     <span class="token comment" spellcheck="true"># 该程序对应进程ID，$$是个特殊的环境变量，它存放了当前进程ID</span>1481$ <span class="token function">ps</span> -C <span class="token function">bash</span>   <span class="token comment" spellcheck="true"># 通过PS命令查看</span>  PID TTY          TIME CMD 1481 pts/0    00:00:00 <span class="token function">bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的操作结果可以看出，当前命令行接口实际上是一个程序，那就是 <code>/bin/bash</code>，它是一个实实在在的程序，它打印提示符，接受用户输入的命令，分析命令序列并执行然后返回结果。不过 <code>/bin/bash</code> 仅仅是当前使用的命令行程序之一，还有很多具有类似功能的程序，比如 <code>/bin/ash</code>, <code>/bin/dash</code> 等。不过这里主要来讨论 <code>bash</code>，讨论它自己是怎么启动的，它怎么样处理用户输入的命令等后台细节？</p><h2 id="bin-bash-是什么时候启动的"><a href="#bin-bash-是什么时候启动的" class="headerlink" title="/bin/bash 是什么时候启动的"></a>/bin/bash 是什么时候启动的</h2><h3 id="bin-login"><a href="#bin-login" class="headerlink" title="/bin/login"></a>/bin/login</h3><p>先通过 <code>CTRL+ALT+F1</code> 切换到一个普通终端下面，一般情况下看到的是 “XXX login: “ 提示输入用户名，接着是提示输入密码，然后呢？就直接登录到了我们的命令行接口。实际上正是你输入正确的密码后，那个程序才把 <code>/bin/bash</code> 给启动了。那是什么东西提示 “XXX login:” 的呢？正是 <code>/bin/login</code> 程序，那 <code>/bin/login</code> 程序怎么知道要启动 <code>/bin/bash</code>，而不是其他的 <code>/bin/dash</code> 呢？</p><p><code>/bin/login</code> 程序实际上会检查我们的 <code>/etc/passwd</code> 文件，在这个文件里头包含了用户名、密码和该用户的登录 Shell。密码和用户名匹配用户的登录，而登录 Shell 则作为用户登录后的命令行程序。看看 <code>/etc/passwd</code> 中典型的这么一行：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> /etc/passwd <span class="token operator">|</span> <span class="token function">grep</span> joytsingjoytsing:x:1000:1000:joytsing,,,:/home/joytsing:/bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个是我用的帐号的相关信息哦，看到最后一行没？<code>/bin/bash</code>，这正是我登录用的命令行解释程序。至于密码呢，看到那个 <strong><code>x</code></strong> 没？这个 <code>x</code> 说明我的密码被保存在另外一个文件里头 <code>/etc/shadow</code>，而且密码是经过加密的。至于这两个文件的更多细节，看手册吧。</p><p>我们怎么知道刚好是 <code>/bin/login</code> 打印了 “XXX login” 呢？现在回顾一下很早以前学习的那个 <code>strace</code> 命令。我们可以用 <code>strace</code> 命令来跟踪 <code>/bin/login</code> 程序的执行。</p><p>跟上面一样，切换到一个普通终端，并切换到 Root 用户，用下面的命令：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">strace</span> -f -o strace.out /bin/login<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>退出以后就可以打开 <code>strace.out</code> 文件，看看到底执行了哪些文件，读取了哪些文件。从中可以看到正是 <code>/bin/login</code> 程序用 <code>execve</code> 调用了 <code>/bin/bash</code> 命令。通过后面的演示，可以发现 <code>/bin/login</code> 只是在子进程里头用 <code>execve</code> 调用了 <code>/bin/bash</code>，因为在启动 <code>/bin/bash</code> 后，可以看到 <code>/bin/login</code> 并没有退出。</p><h3 id="bin-getty"><a href="#bin-getty" class="headerlink" title="/bin/getty"></a>/bin/getty</h3><p>那 <code>/bin/login</code> 又是怎么起来的呢？</p><p>下面再来看一个演示。先在一个可以登陆的终端下执行下面的命令。</p><pre class="line-numbers language-bash"><code class="language-bash">$ getty 38400 tty8 linux<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>getty</code> 命令停留在那里，貌似等待用户的什么操作，现在切回到第 8 个终端，是不是看到有 “XXX login:” 的提示了。输入用户名并登录，之后退出，回到第一个终端，发现 <code>getty</code> 命令已经退出。</p><p>类似地，也可以用 <code>strace</code> 命令来跟踪 <code>getty</code> 的执行过程。在第一个终端下切换到 Root 用户。执行如下命令：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">strace</span> -f -o strace.out getty 38400 tty8 linux<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同样在 <code>strace.out</code> 命令中可以找到该命令的相关启动细节。比如，可以看到正是 <code>getty</code> 程序用 <code>execve</code> 系统调用执行了 <code>/bin/login</code> 程序。这个地方，<code>getty</code> 是在自己的主进程里头直接执行了 <code>/bin/login</code>，这样 <code>/bin/login</code> 将把 <code>getty</code> 的进程空间替换掉。</p><h3 id="sbin-init"><a href="#sbin-init" class="headerlink" title="/sbin/init"></a>/sbin/init</h3><p>这里涉及到一个非常重要的东西：<code>/sbin/init</code>，通过 <code>man init</code> 命令可以查看到该命令的作用，它可是“万物之王”（init is the parent of all processes on the system）。它是 Linux 系统默认启动的第一个程序，负责进行 Linux 系统的一些初始化工作，而这些初始化工作的配置则是通过 <code>/etc/inittab</code> 来做的。那么来看看 <code>/etc/inittab</code> 的一个简单的例子吧，可以通过 <code>man inittab</code> 查看相关帮助。</p><p>需要注意的是，在较新版本的 Ubuntu 和 Fedora 等发行版中，一些新的 <code>init</code> 程序，比如 <code>upstart</code> 和 <code>systemd</code> 被开发出来用于取代 <code>System V init</code>，它们可能放弃了对 <code>/etc/inittab</code> 的使用，例如 <code>upstart</code> 会读取 <code>/etc/init/</code> 下的配置，比如 <code>/etc/init/tty1.conf</code>，但是，基本的配置思路还是类似 <code>/etc/inittab</code>，对于 <code>upstart</code> 的 <code>init</code> 配置，这里不做介绍，请通过 <code>man 5 init</code> 查看帮助。</p><p>配置文件 <code>/etc/inittab</code> 的语法非常简单，就是下面一行的重复，</p><pre class="line-numbers language-bash"><code class="language-bash">id:runlevels:action:process<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p><code>id</code> 就是一个唯一的编号，不用管它，一个名字而言，无关紧要。</p></li><li><p><code>runlevels</code> 是运行级别，这个还是比较重要的，理解运行级别的概念很有必要，它可以有如下的取值：</p><pre><code>0 is halt.1 is single-user.2-5 are multi-user.6 is reboot.</code></pre><p>不过，真正在配置文件里头用的是 <code>1-5</code> 了，而 <code>0</code> 和 <code>6</code> 非常特别，除了用它作为 <code>init</code> 命令的参数关机和重启外，似乎没有哪个“傻瓜”把它写在系统的配置文件里头，让系统启动以后就关机或者重启。<code>1</code> 代表单用户，而 <code>2-5</code> 则代表多用户。对于 <code>2-5</code> 可能有不同的解释，比如在 Slackware 12.0 上，<code>2,3,5</code> 被用来作为多用户模式，但是默认不启动 X windows （GUI接口），而 <code>4</code> 则作为启动 X windows 的运行级别。</p></li><li><p><code>action</code> 是动作，它也有很多选择，我们关心几个常用的</p></li><li><p><code>initdefault</code>：用来指定系统启动后进入的运行级别，通常在 <code>/etc/inittab</code> 的第一条配置，如：</p><pre><code>id:3:initdefault:</code></pre><p>这个说明默认运行级别是 3，即多用户模式，但是不启动 X window 的那种。</p></li><li><p><code>sysinit</code>：指定那些在系统启动时将被执行的程序，例如：</p><pre><code>si:S:sysinit:/etc/rc.d/rc.S</code></pre><p>在 <code>man inittab</code> 中提到，对于 <code>sysinit</code>，<code>boot</code> 等动作，<code>runlevels</code> 选项是不用管的，所以可以很容易解读这条配置：它的意思是系统启动时将默认执行 <code>/etc/rc.d/rc.S</code> 文件，在这个文件里可直接或者间接地执行想让系统启动时执行的任何程序，完成系统的初始化。</p></li><li><p><code>wait</code>：当进入某个特别的运行级别时，指定的程序将被执行一次，<code>init</code> 将等到它执行完成，例如：</p><pre><code>rc:2345:wait:/etc/rc.d/rc.M</code></pre><p>这个说明无论是进入运行级别 2，3，4，5 中哪一个，<code>/etc/rc.d/rc.M</code> 将被执行一次，并且有 <code>init</code> 等待它执行完成。</p></li><li><p><code>ctrlaltdel</code>，当 <code>init</code> 程序接收到 <code>SIGINT</code> 信号时，某个指定的程序将被执行，我们通常通过按下 <code>CTRL+ALT+DEL</code>，这个默认情况下将给 <code>init</code> 发送一个 <code>SIGINT</code> 信号。</p><p>如果我们想在按下这几个键时，系统重启，那么可以在 <code>/etc/inittab</code> 中写入：</p><pre class="line-numbers language-bash"><code class="language-bash">ca::ctrlaltdel:/sbin/shutdown -t5 -r now<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><code>respawn</code>：这个指定的进程将被重启，任何时候当它退出时。这意味着没有办法结束它，除非 <code>init</code> 自己结束了。例如：</p><pre><code>c1:1235:respawn:/sbin/agetty 38400 tty1 linux</code></pre><p>这一行的意思非常简单，就是系统运行在级别 1，2，3，5 时，将默认执行 <code>/sbin/agetty</code> 程序（这个类似于上面提到的 <code>getty</code> 程序），这个程序非常有意思，就是无论什么时候它退出，<code>init</code> 将再次启动它。这个有几个比较有意思的问题：</p></li><li><p>在 Slackware 12.0 下，当默认运行级别为 4 时，只有第 6 个终端可以用。原因是什么呢？因为类似上面的配置，因为那里只有 <code>1235</code>，而没有 <code>4</code>，这意味着当系统运行在第 <code>4</code> 级别时，其他终端下的 <code>/sbin/agetty</code> 没有启动。所以，如果想让其他终端都可以用，把 <code>1235</code> 修改为 <code>12345</code> 即可。</p></li><li><p>另外一个有趣的问题就是：正是 <code>init</code> 程序在读取这个配置行以后启动了 <code>/sbin/agetty</code>，这就是 <code>/sbin/agetty</code> 的秘密。</p></li><li><p>还有一个问题：无论退出哪个终端，那个 “XXX login:” 总是会被打印，原因是 <code>respawn</code> 动作有趣的性质，因为它告诉 <code>init</code>，无论 <code>/sbin/agetty</code> 什么时候退出，重新把它启动起来，那跟 “XXX login:” 有什么关系呢？从前面的内容，我们发现正是 <code>/sbin/getty</code> （同 <code>agetty</code>）启动了 <code>/bin/login</code>，而 <code>/bin/login</code> 又启动了 <code>/bin/bash</code>，即我们的命令行程序。</p></li></ul><h3 id="命令启动过程追本溯源"><a href="#命令启动过程追本溯源" class="headerlink" title="命令启动过程追本溯源"></a>命令启动过程追本溯源</h3><p>而 <code>init</code> 程序作为“万物之王”，它是所有进程的“父”（也可能是祖父……）进程，那意味着其他进程最多只能是它的儿子进程。而这个子进程是怎么创建的，<code>fork</code> 调用，而不是之前提到的 <code>execve</code> 调用。前者创建一个子进程，后者则会覆盖当前进程。因为我们发现 <code>/sbin/getty</code> 运行时，<code>init</code> 并没有退出，因此可以判断是 <code>fork</code> 调用创建一个子进程后，才通过 <code>execve</code> 执行了 <code>/sbin/getty</code>。</p><p>因此，可以总结出这么一个调用过程：</p><pre><code>     fork     execve         execve         fork           execveinit --&gt; init --&gt; /sbin/getty --&gt; /bin/login --&gt; /bin/login --&gt; /bin/bash</code></pre><p>这里的 <code>execve</code> 调用以后，后者将直接替换前者，因此当键入 <code>exit</code> 退出 <code>/bin/bash</code> 以后，也就相当于 <code>/sbin/getty</code> 都已经结束了，因此最前面的 <code>init</code> 程序判断 <code>/sbin/getty</code> 退出了，又会创建一个子进程把 <code>/sbin/getty</code> 启动，进而又启动了 <code>/bin/login</code>，又看到了那个 “XXX login:”。</p><p>通过 <code>ps</code> 和 <code>pstree</code> 命令看看实际情况是不是这样，前者打印出进程的信息，后者则打印出调用关系。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ps</span> -ef <span class="token operator">|</span> <span class="token function">egrep</span> <span class="token string">"/sbin/init|/sbin/getty|bash|/bin/login"</span>root         1     0  0 21:43 ?        00:00:01 /sbin/initroot      3957     1  0 21:43 tty4     00:00:00 /sbin/getty 38400 tty4root      3958     1  0 21:43 tty5     00:00:00 /sbin/getty 38400 tty5root      3963     1  0 21:43 tty3     00:00:00 /sbin/getty 38400 tty3root      3965     1  0 21:43 tty6     00:00:00 /sbin/getty 38400 tty6root      7023     1  0 22:48 tty1     00:00:00 /sbin/getty 38400 tty1root      7081     1  0 22:51 tty2     00:00:00 /bin/login --falcon    7092  7081  0 22:52 tty2     00:00:00 -bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的结果已经过滤了一些不相干的数据。从上面的结果可以看到，除了 <code>tty2</code> 被替换成 <code>/bin/login</code> 外，其他终端都运行着 <code>/sbin/getty</code>，说明终端 2 上的进程是 <code>/bin/login</code>，它已经把 <code>/sbin/getty</code> 替换掉，另外，我们看到 <code>-bash</code> 进程的父进程是 <code>7081</code> 刚好是 <code>/bin/login</code> 程序，这说明 <code>/bin/login</code> 启动了 <code>-bash</code>，但是它并没有替换掉 <code>/bin/login</code>，而是成为了 <code>/bin/login</code> 的子进程，这说明 <code>/bin/login</code> 通过 <code>fork</code> 创建了一个子进程并通过 <code>execve</code> 执行了 <code>-bash</code>（后者通过 <code>strace</code>跟踪到）。而 <code>init</code> 呢，其进程 ID 是 1，是 <code>/sbin/getty</code> 和 <code>/bin/login</code> 的父进程，说明 <code>init</code> 启动或者间接启动了它们。下面通过 <code>pstree</code> 来查看调用树，可以更清晰地看出上述关系。</p><pre><code>$ pstree | egrep &quot;init|getty|\-bash|login&quot;init-+-5*[getty]     |-login---bash     |-xfce4-terminal-+-bash-+-grep</code></pre><p>结果显示 <code>init</code> 是 5 个 <code>getty</code> 程序，<code>login</code> 程序和 <code>xfce4-terminal</code> 的父进程，而后两者则是 <code>bash</code> 的父进程，另外我们执行的 <code>grep</code> 命令则在 <code>bash</code> 上运行，是 <code>bash</code> 的子进程，这个将是我们后面关心的问题。</p><p>从上面的结果发现，<code>init</code> 作为所有进程的父进程，它的父进程 ID 饶有兴趣的是 0，它是怎么被启动的呢？谁才是真正的“造物主”？</p><h3 id="谁启动了-sbin-init"><a href="#谁启动了-sbin-init" class="headerlink" title="谁启动了 /sbin/init"></a>谁启动了 /sbin/init</h3><p>如果用过 <code>Lilo</code> 或者 <code>Grub</code> 这些操作系统引导程序，可能会用到 Linux 内核的一个启动参数 <code>init</code>，当忘记密码时，可能会把这个参数设置成 <code>/bin/bash</code>，让系统直接进入命令行，而无须输入帐号和密码，这样就可以方便地把登录密码修改掉。</p><p>这个 <code>init</code> 参数是个什么东西呢？通过 <code>man bootparam</code> 会发现它的秘密，<code>init</code> 参数正好指定了内核启动后要启动的第一个程序，而如果没有指定该参数，内核将依次查找 <code>/sbin/init</code>，<code>/etc/init</code>，<code>/bin/init</code>，<code>/bin/sh</code>，如果找不到这几个文件中的任何一个，内核就要恐慌（panic）了，并挂（hang）在那里一动不动了（注：如果 <code>panic=timeout</code> 被传递给内核并且 <code>timeout</code> 大于 0，那么就不会挂住而是重启）。</p><p>因此 <code>/sbin/init</code> 就是 Linux 内核启动的。而 Linux 内核呢？是通过 <code>Lilo</code> 或者 <code>Grub</code> 等引导程序启动的，<code>Lilo</code> 和 <code>Grub</code> 都有相应的配置文件，一般对应 <code>/etc/lilo.conf</code> 和 <code>/boot/grub/menu.lst</code>，通过这些配置文件可以指定内核映像文件、系统根目录所在分区、启动选项标签等信息，从而能够让它们顺利把内核启动起来。</p><p>那 <code>Lilo</code> 和 <code>Grub</code> 本身又是怎么被运行起来的呢？有了解 MBR 不？MBR 就是主引导扇区，一般情况下这里存放着 <code>Lilo</code> 和 <code>Grub</code> 的代码，而谁知道正好是这里存放了它们呢？BIOS，如果你用光盘安装过操作系统的话，那么应该修改过 <code>BIOS</code> 的默认启动设置，通过设置可以让系统从光盘、硬盘、U 盘甚至软盘启动。正是这里的设置让 BIOS 知道了 MBR 处的代码需要被执行。</p><p>那 BIOS 又是什么时候被起来的呢？处理器加电后有一个默认的起始地址，一上电就执行到了这里，再之前就是开机键按键后的上电时序。</p><p>更多系统启动的细节，看看 <code>man boot-scripts</code> 吧。</p><p>到这里，<code>/bin/bash</code> 的神秘面纱就被揭开了，它只是系统启动后运行的一个程序而已，只不过这个程序可以响应用户的请求，那它到底是如何响应用户请求的呢？</p><h2 id="bin-bash-如何处理用户键入的命令"><a href="#bin-bash-如何处理用户键入的命令" class="headerlink" title="/bin/bash 如何处理用户键入的命令"></a>/bin/bash 如何处理用户键入的命令</h2><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><p>在执行磁盘上某个程序时，通常不会指定这个程序文件的绝对路径，比如要执行 <code>echo</code> 命令时，一般不会输入 <code>/bin/echo</code>，而仅仅是输入 <code>echo</code>。那为什么这样 <code>bash</code> 也能够找到 <code>/bin/echo</code> 呢？原因是 Linux 操作系统支持这样一种策略：Shell 的一个环境变量 <code>PATH</code> 里头存放了程序的一些路径，当 Shell 执行程序时有可能去这些目录下查找。<code>which</code> 作为 Shell（这里特指 <code>bash</code>）的一个内置命令，如果用户输入的命令是磁盘上的某个程序，它会返回这个文件的全路径。</p><p>有三个东西和终端的关系很大，那就是标准输入、标准输出和标准错误，它们是三个文件描述符，一般对应描述符 0，1，2。在 C 语言程序里，我们可以把它们当作文件描述符一样进行操作。在命令行下，则可以使用重定向字符<code>&gt;，&lt;</code>等对它们进行操作。对于标准输出和标准错误，都默认输出到终端，对于标准输入，也同样默认从终端输入。</p><h3 id="哪种命令先被执行"><a href="#哪种命令先被执行" class="headerlink" title="哪种命令先被执行"></a>哪种命令先被执行</h3><p>在 C 语言里头要写一段输入字符串的命令很简单，调用 <code>scanf</code> 或者 <code>fgets</code> 就可以。这个在 <code>bash</code> 里头应该是类似的。但是它获取用户的命令以后，如何分析命令，如何响应不同的命令呢？</p><p>首先来看看 <code>bash</code> 下所谓的命令，用最常见的 <code>test</code> 来作测试。</p><ul><li><p>字符串被解析成命令</p><p>随便键入一个字符串 <code>test1</code>， <code>bash</code> 发出响应，告知找不到这个程序：</p><pre class="line-numbers language-bash"><code class="language-bash">  $ test1  bash: test1: <span class="token function">command</span> not found<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>内置命令</p><p>而当键入 <code>test</code> 时，看不到任何输出，唯一响应是，新命令提示符被打印了：</p><pre class="line-numbers language-bash"><code class="language-bash">  $ <span class="token function">test</span>  $<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看 <code>test</code> 这个命令的类型，即查看 <code>test</code> 将被如何解释， <code>type</code> 告诉我们 <code>test</code> 是一个内置命令，如果没有理解错， <code>test</code> 应该是利用诸如 <code>case &quot;test&quot;: do something;break;</code> 这样的机制实现的，具体如何实现可以查看 <code>bash</code> 源代码。</p><pre class="line-numbers language-bash"><code class="language-bash">  $ <span class="token function">type</span> <span class="token function">test</span>  <span class="token function">test</span> is a shell <span class="token function">builtin</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>外部命令</p><p>这里通过 <code>which</code> 查到 <code>/usr/bin</code> 下有一个 <code>test</code> 命令文件，在键入 <code>test</code> 时，到底哪一个被执行了呢？</p><pre class="line-numbers language-bash"><code class="language-bash">  $ <span class="token function">which</span> <span class="token function">test</span>  /usr/bin/test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行这个呢？也没什么反应，到底谁先被执行了？</p><pre><code>  $ /usr/bin/test</code></pre><p>从上述演示中发现一个问题？如果输入一个命令，这个命令要么就不存在，要么可能同时是 Shell 的内置命令、也有可能是磁盘上环境变量 <code>PATH</code> 所指定的目录下的某个程序文件。</p><p>考虑到 <code>test</code> 内置命令和 <code>/usr/bin/test</code> 命令的响应结果一样，我们无法知道哪一个先被执行了，怎么办呢？把 <code>/usr/bin/test</code> 替换成一个我们自己的命令，并让它打印一些信息(比如 <code>hello, world!</code> )，这样我们就知道到底谁被执行了。写完程序，编译好，命名为 <code>test</code> 放到 <code>/usr/bin</code> 下（记得备份原来那个）。开始测试：</p><p>键入 <code>test</code> ，还是没有效果：</p><pre><code>  $ test  $</code></pre><p>而键入绝对路径呢，则打印了 <code>hello, world!</code> 诶，那默认情况下肯定是内置命令先被执行了：</p><pre class="line-numbers language-bash"><code class="language-bash">  $ /usr/bin/test  hello, world<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>由上述实验结果可见，内置命令比磁盘文件中的程序优先被 <code>bash</code> 执行。原因应该是内置命令避免了不必要的 <code>fork/execve</code> 调用，对于采用类似算法实现的功能，内置命令理论上有更高运行效率。</p><p>下面看看更多有趣的内容，键盘键入的命令还有可能是什么呢？因为 <code>bash</code> 支持别名（<code>alias</code>）和函数（<code>function</code>），所以还有可能是别名和函数，另外，如果 <code>PATH</code> 环境变量指定的不同目录下有相同名字的程序文件，那到底哪个被优先找到呢？</p><p>下面再作一些实验，</p></li><li><p>别名</p><p>把 <code>test</code> 命名为 <code>ls -l</code> 的别名，再执行 <code>test</code> ，竟然执行了 <code>ls -l</code> ，说明别名（<code>alias</code>）比内置命令（<code>builtin</code>）更优先：</p><pre class="line-numbers language-bash"><code class="language-bash">  $ <span class="token function">alias</span> test<span class="token operator">=</span><span class="token string">"ls -l"</span>  $ <span class="token function">test</span>  total 9488  drwxr-xr-x 12 falcon falcon    4096 2008-02-21 23:43 bash-3.2  -rw-r--r--  1 falcon falcon 2529838 2008-02-21 23:30 bash-3.2.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>函数</p><p>定义一个名叫 <code>test</code> 的函数，执行一下，发现，还是执行了 <code>ls -l</code> ，说明 <code>function</code> 没有 <code>alias</code> 优先级高：</p><pre class="line-numbers language-bash"><code class="language-bash">  $ <span class="token keyword">function</span> <span class="token function">test</span> <span class="token punctuation">{</span> <span class="token keyword">echo</span> <span class="token string">"hi, I'm a function"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  $ <span class="token function">test</span>  total 9488  drwxr-xr-x 12 falcon falcon    4096 2008-02-21 23:43 bash-3.2  -rw-r--r--  1 falcon falcon 2529838 2008-02-21 23:30 bash-3.2.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把别名给去掉（<code>unalias</code>），现在执行的是函数，说明函数的优先级比内置命令也要高：</p><pre class="line-numbers language-bash"><code class="language-bash">  $ <span class="token function">unalias</span> <span class="token function">test</span>  $ <span class="token function">test</span>  hi, I'm a <span class="token keyword">function</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果在命令之前跟上 <code>builtin</code> ，那么将直接执行内置命令：</p><pre class="line-numbers language-bash"><code class="language-bash">  $ <span class="token function">builtin</span> <span class="token function">test</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要去掉某个函数的定义，这样就可以：</p><pre class="line-numbers language-bash"><code class="language-bash">  $ unset <span class="token function">test</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>通过这个实验我们得到一个命令的别名（<code>alias</code>）、函数（<code>function</code>），内置命令（<code>builtin</code>）和程序（<code>program</code>）的执行优先次序：</p><pre class="line-numbers language-bash"><code class="language-bash">    先    <span class="token function">alias</span> --<span class="token operator">></span> <span class="token keyword">function</span> --<span class="token operator">></span> <span class="token function">builtin</span> --<span class="token operator">></span> program   后<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>实际上， <code>type</code> 命令会告诉我们这些细节， <code>type -a</code> 会按照 <code>bash</code> 解析的顺序依次打印该命令的类型，而 <code>type -t</code> 则会给出第一个将被解析的命令的类型，之所以要做上面的实验，是为了让大家加印象。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">type</span> -a <span class="token function">test</span><span class="token function">test</span> is a shell <span class="token function">builtin</span><span class="token function">test</span> is /usr/bin/test$ <span class="token function">alias</span> test<span class="token operator">=</span><span class="token string">"ls -l"</span>$ <span class="token keyword">function</span> <span class="token function">test</span> <span class="token punctuation">{</span> <span class="token keyword">echo</span> <span class="token string">"I'm a function"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>$ <span class="token function">type</span> -a <span class="token function">test</span><span class="token function">test</span> is aliased to `ls -l<span class="token string">'test is a functiontest (){    echo "I'</span>m a function"<span class="token punctuation">}</span><span class="token function">test</span> is a shell <span class="token function">builtin</span><span class="token function">test</span> is /usr/bin/test$ <span class="token function">type</span> -t <span class="token function">test</span><span class="token function">alias</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面再看看 <code>PATH</code> 指定的多个目录下有同名程序的情况。再写一个程序，打印 <code>hi, world!</code>，以示和 <code>hello, world!</code> 的区别，放到 <code>PATH</code> 指定的另外一个目录 <code>/bin</code> 下，为了保证测试的说服力，再写一个放到另外一个叫 <code>/usr/local/sbin</code> 的目录下。</p><p>先看看 <code>PATH</code> 环境变量，确保它有 <code>/usr/bin</code>，<code>/bin</code> 和 <code>/usr/local/sbin</code> 这几个目录，然后通过 <code>type -P</code>（<code>-P</code> 参数强制到 <code>PATH</code> 下查找，而不管是别名还是内置命令等，可以通过 <code>help type</code> 查看该参数的含义）查看，到底哪个先被执行。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$PATH</span>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games$ <span class="token function">type</span> -P <span class="token function">test</span>/usr/local/sbin/test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如上可以看到 <code>/usr/local/sbin</code> 下的先被找到。</p><p>把 <code>/usr/local/sbin/test</code> 下的给删除掉，现在 <code>/usr/bin</code> 下的先被找到：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">rm</span> /usr/local/sbin/test$ <span class="token function">type</span> -P <span class="token function">test</span>/usr/bin/test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>type -a</code> 也显示类似的结果：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">type</span> -a <span class="token function">test</span><span class="token function">test</span> is aliased to `ls -l<span class="token string">'test is a functiontest (){    echo "I'</span>m a function"<span class="token punctuation">}</span><span class="token function">test</span> is a shell <span class="token function">builtin</span><span class="token function">test</span> is /usr/bin/test<span class="token function">test</span> is /bin/test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此，可以找出这么一个规律： Shell 从 <code>PATH</code> 列出的路径中依次查找用户输入的命令。考虑到程序的优先级最低，如果想优先执行磁盘上的程序文件 <code>test</code> 呢？那么就可以用 <code>test -P</code> 找出这个文件并执行就可以了。</p><p>补充：对于 Shell 的内置命令，可以通过 <code>help command</code> 的方式获得帮助，对于程序文件，可以查看用户手册（当然，这个需要安装，一般叫做 <code>xxx-doc</code>）， <code>man command</code> 。</p><h3 id="这些特殊字符是如何解析的：-gt-lt-amp"><a href="#这些特殊字符是如何解析的：-gt-lt-amp" class="headerlink" title="这些特殊字符是如何解析的：|, &gt;, &lt;, &amp;"></a>这些特殊字符是如何解析的：<code>|, &gt;, &lt;, &amp;</code></h3><p>在命令行上，除了输入各种命令以及一些参数外，比如上面 <code>type</code> 命令的各种参数 <code>-a</code>，<code>-P</code> 等，对于这些参数，是传递给程序本身的，非常好处理，比如 <code>if</code> ， <code>else</code> 条件分支或者 <code>switch</code>，<code>case</code> 都可以处理。当然，在 <code>bash</code> 里头可能使用专门的参数处理函数 <code>getopt</code> 和 <code>getopt_long</code> 来处理它们。</p><p>而 <code>|</code> ， <code>&gt;</code> ， <code>&lt;</code> ， <code>&amp;</code> 等字符，则比较特别， Shell 是怎么处理它们的呢？它们也被传递给程序本身吗？可我们的程序内部一般都不处理这些字符的，所以应该是 Shell 程序自己解析了它们。</p><p>先来看看这几个字符在命令行的常见用法，</p><p><code>&lt;</code> 字符表示：把 <code>test.c</code> 文件重定向为标准输入，作为 <code>cat</code> 命令输入，而 <code>cat</code> 默认输出到标准输出：</p><pre class="line-numbers language-c"><code class="language-c">$ cat <span class="token operator">&lt;</span> <span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span>c<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hi, myself!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>&gt;</code> 表示把标准输出重定向为文件 <code>test_new.c</code> ，结果内容输出到 <code>test_new.c</code> ：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> <span class="token operator">&lt;</span> ./test.c <span class="token operator">></span> test_new.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于 <code>&gt;</code> ， <code>&lt;</code> ， <code>&gt;&gt;</code> ， <code>&lt;&lt;</code> ， <code>&lt;&gt;</code> 我们都称之为重定向（<code>redirect</code>）， Shell 到底是怎么进行所谓的“重定向”的呢？</p><p>这主要归功于 <code>dup/fcntl</code> 等函数，它们可以实现：复制文件描述符，让多个文件描述符共享同一个文件表项。比如，当把文件 <code>test.c</code> 重定向为标准输入时。假设之前用以打开 <code>test.c</code> 的文件描述符是 5 ，现在就把 5 复制为了 0 ，这样当 <code>cat</code> 试图从标准输入读出内容时，也就访问了文件描述符 5 指向的文件表项，接着读出了文件内容。输出重定向与此类似。其他的重定向，诸如 <code>&gt;&gt;</code> ， <code>&lt;&lt;</code> ， <code>&lt;&gt;</code> 等虽然和 <code>&gt;</code> ， <code>&lt;</code> 的具体实现功能不太一样，但本质是一样的，都是文件描述符的复制，只不过可能对文件操作有一些附加的限制，比如 <code>&gt;&gt;</code> 在输出时追加到文件末尾，而 <code>&gt;</code> 则会从头开始写入文件，前者意味着文件的大小会增长，而后者则意味文件被重写。</p><p>那么 <code>|</code> 呢？ <code>|</code> 被形象地称为“管道”，实际上它就是通过 C 语言里头的无名管道来实现的。先看一个例子，</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> <span class="token operator">&lt;</span> ./test.c  <span class="token operator">|</span> <span class="token function">grep</span> hi        printf<span class="token punctuation">(</span><span class="token string">"hi, myself!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在这个例子中， <code>cat</code> 读出了 <code>test.c</code> 文件中的内容，并输出到标准输出上，但是实际上输出的内容却只有一行，原因是这个标准输出被“接到”了 <code>grep</code> 命令的标准输入上，而 <code>grep</code> 命令只打印了包含 “hi” 字符串的一行。</p><p>这是怎么被“接”上的。 <code>cat</code> 和 <code>grep</code> 作为两个单独的命令，它们本身没有办法把两者的输入和输出“接”起来。这正是 Shell 自己的“杰作”，它通过 C 语言里头的 <code>pipe</code> 函数创建了一个管道（一个包含两个文件描述符的整形数组，一个描述符用于写入数据，一个描述符用于读入数据），并且通过 <code>dup/fcntl</code> 把 <code>cat</code> 的输出复制到了管道的输入，而把管道的输出则复制到了 <code>grep</code> 的输入。这真是一个奇妙的想法。</p><p>那 <code>&amp;</code> 呢？当你在程序的最后跟上这个奇妙的字符以后就可以接着做其他事情了，看看效果：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sleep</span> 50 <span class="token operator">&amp;</span> <span class="token comment" spellcheck="true">#让程序在后台运行</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span> 8261<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>提示符被打印出来，可以输入东西，让程序到前台运行，无法输入东西了，按下 <code>CTRL+Z</code> ，再让程序到后台运行：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">fg</span> %1<span class="token function">sleep</span> 50<span class="token punctuation">[</span>1<span class="token punctuation">]</span>+  Stopped                 <span class="token function">sleep</span> 50<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>实际上 <code>&amp;</code> 正是 <code>Shell</code> 支持作业控制的表征，通过作业控制，用户在命令行上可以同时作几个事情（把当前不做的放到后台，用 <code>&amp;</code> 或者 <code>CTRL+Z</code> 或者 <code>bg</code>）并且可以自由地选择当前需要执行哪一个（用 <code>fg</code> 调到前台）。这在实现时应该涉及到很多东西，包括终端会话（<code>session</code>）、终端信号、前台进程、后台进程等。而在命令的后面加上 <code>&amp;</code> 后，该命令将被作为后台进程执行，后台进程是什么呢？这类进程无法接收用户发送给终端的信号（如 <code>SIGHUP</code> ，<code>SIGQUIT</code> ，<code>SIGINT</code>），无法响应键盘输入（被前台进程占用着），不过可以通过 <code>fg</code> 切换到前台而享受作为前台进程具有的特权。</p><p>因此，当一个命令被加上 <code>&amp;</code> 执行后，Shell 必须让它具有后台进程的特征，让它无法响应键盘的输入，无法响应终端的信号（意味忽略这些信号），并且比较重要的是新的命令提示符得打印出来，并且让命令行接口可以继续执行其他命令，这些就是 Shell 对 <code>&amp;</code> 的执行动作。</p><p>还有什么神秘的呢？你也可以写自己的 Shell 了，并且可以让内核启动后就执行它 <code>l</code> ，在 <code>lilo</code> 或者 <code>grub</code> 的启动参数上设置 <code>init=/path/to/your/own/shell/program</code> 就可以。当然，也可以把它作为自己的登录 Shell ，只需要放到 <code>/etc/passwd</code> 文件中相应用户名所在行的最后就可以。不过貌似到现在还没介绍 Shell 是怎么执行程序，是怎样让程序变成进程的，所以继续。</p><h3 id="bin-bash-用什么魔法让一个普通程序变成了进程"><a href="#bin-bash-用什么魔法让一个普通程序变成了进程" class="headerlink" title="/bin/bash 用什么魔法让一个普通程序变成了进程"></a>/bin/bash 用什么魔法让一个普通程序变成了进程</h3><p>当我们从键盘键入一串命令，Shell 奇妙地响应了，对于内置命令和函数，Shell 自身就可以解析了（通过 <code>switch</code> ，<code>case</code> 之类的 C 语言语句）。但是，如果这个命令是磁盘上的一个文件呢。它找到该文件以后，怎么执行它的呢？</p><p>还是用 <code>strace</code> 来跟踪一个命令的执行过程看看。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">strace</span> -f -o strace.log /usr/bin/testhello, world<span class="token operator">!</span>$ <span class="token function">cat</span> strace.log <span class="token operator">|</span> <span class="token function">sed</span> -ne <span class="token string">"1p"</span>   <span class="token comment" spellcheck="true">#我们对第一行很感兴趣</span>8445  execve<span class="token punctuation">(</span><span class="token string">"/usr/bin/test"</span>, <span class="token punctuation">[</span><span class="token string">"/usr/bin/test"</span><span class="token punctuation">]</span>, <span class="token punctuation">[</span>/* 33 vars */<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span> 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>从跟踪到的结果的第一行可以看到 <code>bash</code> 通过 <code>execve</code> 调用了 <code>/usr/bin/test</code> ，并且给它传了 33 个参数。这 33 个 <code>vars</code> 是什么呢？看看 <code>declare -x</code> 的结果（这个结果只有 32 个，原因是 <code>vars</code> 的最后一个变量需要是一个结束标志，即 <code>NULL</code>）。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">declare</span> -x <span class="token operator">|</span> <span class="token function">wc</span> -l   <span class="token comment" spellcheck="true">#declare -x声明的环境变量将被导出到子进程中</span>32$ <span class="token function">export</span> TEST<span class="token operator">=</span><span class="token string">"just a test"</span>   <span class="token comment" spellcheck="true">#为了认证declare -x和之前的vars的个数的关系，再加一个</span>$ <span class="token keyword">declare</span> -x <span class="token operator">|</span> <span class="token function">wc</span> -l33$ <span class="token function">strace</span> -f -o strace.log /usr/bin/test   <span class="token comment" spellcheck="true">#再次跟踪，看看这个关系</span>hello, world<span class="token operator">!</span>$ <span class="token function">cat</span> strace.log <span class="token operator">|</span> <span class="token function">sed</span> -ne <span class="token string">"1p"</span>8523  execve<span class="token punctuation">(</span><span class="token string">"/usr/bin/test"</span>, <span class="token punctuation">[</span><span class="token string">"/usr/bin/test"</span><span class="token punctuation">]</span>, <span class="token punctuation">[</span>/* 34 vars */<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span> 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过这个演示发现，当前 Shell 的环境变量中被设置为 <code>export</code> 的变量被复制到了新的程序里头。不过虽然我们认为 Shell 执行新程序时是在一个新的进程里头执行的，但是 <code>strace</code> 并没有跟踪到诸如 <code>fork</code> 的系统调用（可能是 <code>strace</code> 自己设计的时候并没有跟踪 <code>fork</code> ，或者是在 <code>fork</code> 之后才跟踪）。但是有一个事实我们不得不承认：当前 Shell 并没有被新程序的进程替换，所以说 Shell 肯定是先调用 <code>fork</code> （也有可能是 <code>vfork</code>）创建了一个子进程，然后再调用 <code>execve</code> 执行新程序的。如果你还不相信，那么直接通过 <code>exec</code> 执行新程序看看，这个可是直接把当前 Shell 的进程替换掉的。</p><pre><code>exec /usr/bin/test</code></pre><p>该可以看到当前 Shell “哗”（听不到，突然没了而已）的一下就没有了。</p><p>下面来模拟一下 Shell 执行普通程序。 <code>multiprocess</code> 相当于当前 Shell ，而 <code>/usr/bin/test</code> 则相当于通过命令行传递给 Shell 的一个程序。这里是代码：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* multiprocess.c */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span>     </span><span class="token comment" spellcheck="true">/* sleep, fork, _exit */</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> child<span class="token punctuation">;</span>    <span class="token keyword">int</span> status<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>child <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* child */</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child: my pid is %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child: my parent's pid is %d\n"</span><span class="token punctuation">,</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">execlp</span><span class="token punctuation">(</span><span class="token string">"/usr/bin/test"</span><span class="token punctuation">,</span><span class="token string">"/usr/bin/test"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>child <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">/* error */</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"create child process error!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">_exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>                                                   <span class="token comment" spellcheck="true">/* parent */</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"parent: my pid is %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>status<span class="token punctuation">)</span> <span class="token operator">==</span> child <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"parent: wait for my child exit successfully!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行看看，</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">make</span> multiprocess$ ./multiprocesschild: my pid is 2251child: my parent's pid is 2250hello, world<span class="token operator">!</span>parent: my pid is 2250parent: <span class="token function">wait</span> <span class="token keyword">for</span> my child <span class="token keyword">exit</span> successfully<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从执行结果可以看出，<code>/usr/bin/test</code> 在 <code>multiprocess</code> 的子进程中运行并不干扰父进程，因为父进程一直等到了 <code>/usr/bin/test</code> 执行完成。</p><p>再回头看看代码，你会发现 <code>execlp</code> 并没有传递任何环境变量信息给 <code>/usr/bin/test</code> ，到底是怎么把环境变量传送过去的呢？通过 <code>man exec</code> 我们可以看到一组 <code>exec</code> 的调用，在里头并没有发现 <code>execve</code> ，但是通过 <code>man execve</code> 可以看到该系统调用。实际上 <code>exec</code> 的那一组调用都只是 <code>libc</code> 库提供的，而 <code>execve</code> 才是真正的系统调用，也就是说无论使用 <code>exec</code> 调用中的哪一个，最终调用的都是 <code>execve</code> ，如果使用 <code>execlp</code> ，那么 <code>execlp</code> 将通过一定的处理把参数转换为 <code>execve</code> 的参数。因此，虽然我们没有传递任何环境变量给 <code>execlp</code> ，但是默认情况下，<code>execlp</code> 把父进程的环境变量复制给了子进程，而这个动作是在 <code>execlp</code> 函数内部完成的。</p><p>现在，总结一下 <code>execve</code> ，它有有三个参数，</p><p><code>-</code> 第一个是程序本身的绝对路径，对于刚才使用的 <code>execlp</code> ，我们没有指定路径，这意味着它会设法到 <code>PATH</code> 环境变量指定的路径下去寻找程序的全路径。 <code>-</code> 第二个参数是一个将传递给被它执行的程序的参数数组指针。正是这个参数把我们从命令行上输入的那些参数，诸如 <code>grep</code> 命令的 <code>-v</code> 等传递给了新程序，可以通过 <code>main</code> 函数的第二个参数 <code>char</code> <em><code>argv[]</code> 获得这些内容。 <code>-</code> 第三个参数是一个将传递给被它执行的程序的环境变量，这些环境变量也可以通过 <code>main</code> 函数的第三个变量获取，只要定义一个 <code>char</code></em> <code>env[]</code> 就可以了，只是通常不直接用它罢了，而是通过另外的方式，通过 <code>extern char</code> ** <code>environ</code> 全局变量（环境变量表的指针）或者 <code>getenv</code> 函数来获取某个环境变量的值。</p><p>当然，实际上，当程序被 <code>execve</code> 执行后，它被加载到了内存里，包括程序的各种指令、数据以及传递给它的各种参数、环境变量等都被存放在系统分配给该程序的内存空间中。</p><p>我们可以通过 <code>/proc/&lt;pid&gt;/maps</code> 把一个程序对应的进程的内存映象看个大概。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> /proc/self/maps   <span class="token comment" spellcheck="true">#查看cat程序自身加载后对应进程的内存映像</span>08048000-0804c000 r-xp 00000000 03:01 273716     /bin/cat0804c000-0804d000 rw-p 00003000 03:01 273716     /bin/cat0804d000-0806e000 rw-p 0804d000 00:00 0          <span class="token punctuation">[</span>heap<span class="token punctuation">]</span>b7c46000-b7e46000 r--p 00000000 03:01 87528      /usr/lib/locale/locale-archiveb7e46000-b7e47000 rw-p b7e46000 00:00 0b7e47000-b7f83000 r-xp 00000000 03:01 466875     /lib/libc-2.5.sob7f83000-b7f84000 r--p 0013c000 03:01 466875     /lib/libc-2.5.sob7f84000-b7f86000 rw-p 0013d000 03:01 466875     /lib/libc-2.5.sob7f86000-b7f8a000 rw-p b7f86000 00:00 0b7fa1000-b7fbc000 r-xp 00000000 03:01 402817     /lib/ld-2.5.sob7fbc000-b7fbe000 rw-p 0001b000 03:01 402817     /lib/ld-2.5.sobfcdf000-bfcf4000 rw-p bfcdf000 00:00 0          <span class="token punctuation">[</span>stack<span class="token punctuation">]</span>ffffe000-fffff000 r-xp 00000000 00:00 0          <span class="token punctuation">[</span>vdso<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到这里，关于命令行的秘密都被“曝光”了，可以开始写自己的命令行解释程序了。</p><p>补充：上面没有讨论到一个比较重要的内容，那就是即使 <code>execve</code> 找到了某个可执行文件，如果该文件属主没有运行该程序的权限，那么也没有办法运行程序。可通过 <code>ls -l</code> 查看程序的权限，通过 <code>chmod</code> 添加或者去掉可执行权限。</p><p>文件属主具有可执行权限时才可以执行某个程序：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">whoami</span>falcon$ <span class="token function">ls</span> -l hello  <span class="token comment" spellcheck="true">#查看用户权限(第一个x表示属主对该程序具有可执行权限</span>-rwxr-xr-x 1 falcon <span class="token function">users</span> 6383 2000-01-23 07:59 hello*$ ./helloHello World$ <span class="token function">chmod</span> -x hello  <span class="token comment" spellcheck="true">#去掉属主的可执行权限</span>$ <span class="token function">ls</span> -l hello-rw-r--r-- 1 falcon <span class="token function">users</span> 6383 2000-01-23 07:59 hello$ ./hello-bash: ./hello: Permission denied<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>Linux 启动过程：<code>man boot-scripts</code></li><li>Linux 内核启动参数：<code>man bootparam</code></li><li><code>man 5 passwd</code></li><li><code>man shadow</code></li><li>《UNIX 环境高级编程》，进程关系一章</li></ul>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> C </tag>
            
            <tag> 编程透视 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓冲区溢出与注入分析</title>
      <link href="posts/13820/"/>
      <url>posts/13820/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>虽然程序加载以及动态符号链接都已经很理解了，但是这伙却被进程的内存映像给”纠缠”住。看着看着就一发不可收拾——很有趣。</p><p>下面一起来探究“缓冲区溢出和注入”问题（主要是关心程序的内存映像）。</p><h2 id="进程的内存映像"><a href="#进程的内存映像" class="headerlink" title="进程的内存映像"></a>进程的内存映像</h2><p>永远的 <code>Hello World</code>，太熟悉了吧，</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果要用内联汇编（<code>inline assembly</code>）来写呢？</p><pre class="line-numbers language-c"><code class="language-c"> <span class="token number">1</span>  <span class="token comment" spellcheck="true">/* shellcode.c */</span> <span class="token number">2</span>  <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token number">3</span>  <span class="token punctuation">{</span> <span class="token number">4</span>      <span class="token function">__asm____volatile__</span><span class="token punctuation">(</span><span class="token string">"jmp forward;"</span> <span class="token number">5</span>                   <span class="token string">"backward:"</span> <span class="token number">6</span>                           <span class="token string">"popl   %esi;"</span> <span class="token number">7</span>                           <span class="token string">"movl   $4, %eax;"</span> <span class="token number">8</span>                           <span class="token string">"movl   $2, %ebx;"</span> <span class="token number">9</span>                           <span class="token string">"movl   %esi, %ecx;"</span><span class="token number">10</span>                           <span class="token string">"movl   $12, %edx;"</span><span class="token number">11</span>                           <span class="token string">"int    $0x80;"</span>    <span class="token comment" spellcheck="true">/* system call 1 */</span><span class="token number">12</span>                           <span class="token string">"movl   $1, %eax;"</span><span class="token number">13</span>                           <span class="token string">"movl   $0, %ebx;"</span><span class="token number">14</span>                           <span class="token string">"int    $0x80;"</span>    <span class="token comment" spellcheck="true">/* system call 2 */</span><span class="token number">15</span>                   <span class="token string">"forward:"</span><span class="token number">16</span>                           <span class="token string">"call   backward;"</span><span class="token number">17</span>                           <span class="token string">".string \"Hello World\\n\";"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">18</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看起来很复杂，实际上就做了一个事情，往终端上写了个 <code>Hello World</code> 。不过这个非常有意思。先简单分析一下流程：</p><ul><li>第 4 行指令的作用是跳转到第 15 行（即 <code>forward</code> 标记处），接着执行第 16 行。</li><li>第 16 行调用 <code>backward</code>，跳转到第 5 行，接着执行 6 到 14 行。</li><li>第 6 行到第 11 行负责在终端打印出 <code>Hello World</code> 字符串（等一下详细介绍）。</li><li>第 12 行到第 14 行退出程序（等一下详细介绍）。</li></ul><p>为了更好的理解上面的代码和后续的分析，先来介绍几个比较重要的内容。</p><h3 id="常用寄存器初识"><a href="#常用寄存器初识" class="headerlink" title="常用寄存器初识"></a>常用寄存器初识</h3><p><code>X86</code> 处理器平台有三个常用寄存器：程序指令指针、程序堆栈指针与程序基指针：</p><table><thead><tr><th>寄存器</th><th>名称</th><th>注释</th></tr></thead><tbody><tr><td>EIP</td><td>程序指令指针</td><td>通常指向下一条指令的位置</td></tr><tr><td>ESP</td><td>程序堆栈指针</td><td>通常指向当前堆栈的当前位置</td></tr><tr><td>EBP</td><td>程序基指针</td><td>通常指向函数使用的堆栈顶端</td></tr></tbody></table><p>当然，上面都是扩展的寄存器，用于 32 位系统，对应的 16 系统为 <code>ip</code>，<code>sp</code>，<code>bp</code> 。</p><h3 id="call，ret-指令的作用分析"><a href="#call，ret-指令的作用分析" class="headerlink" title="call，ret 指令的作用分析"></a>call，ret 指令的作用分析</h3><ul><li><p><code>call</code> 指令</p><p>跳转到某个位置，并在之前把下一条指令的地址（<code>EIP</code>）入栈（为了方便”程序“返回以后能够接着执行）。这样的话就有：</p><pre><code>  call backward   ==&gt;   push eip                        jmp backward</code></pre></li><li><p><code>ret</code> 指令</p><p>通常 <code>call</code> 指令和 <code>ret</code> 是配合使用的，前者压入跳转前的下一条指令地址，后者弹出 <code>call</code> 指令压入的那条指令，从而可以在函数调用结束以后接着执行后面的指令。</p><pre><code>  ret                    ==&gt;   pop eip</code></pre></li></ul><p>通常在函数调用后，还需要恢复 <code>esp</code> 和 <code>ebp</code>，恢复 <code>esp</code> 即恢复当前栈指针，以便释放调用函数时为存储函数的局部变量而自动分配的空间；恢复 <code>ebp</code> 是从栈中弹出一个数据项（通常函数调用过后的第一条语句就是 <code>push ebp</code>），从而恢复当前的函数指针为函数调用者本身。这两个动作可以通过一条 <code>leave</code> 指令完成。</p><p>这三个指令对我们后续的解释会很有帮助。</p><h3 id="什么是系统调用（以-Linux-2-6-21-版本和-x86-平台为例）"><a href="#什么是系统调用（以-Linux-2-6-21-版本和-x86-平台为例）" class="headerlink" title="什么是系统调用（以 Linux 2.6.21 版本和 x86 平台为例）"></a>什么是系统调用（以 Linux 2.6.21 版本和 x86 平台为例）</h3><p>系统调用是用户和内核之间的接口，用户如果想写程序，很多时候直接调用了 C 库，并没有关心系统调用，而实际上 C 库也是基于系统调用的。这样应用程序和内核之间就可以通过系统调用联系起来。它们分别处于操作系统的用户空间和内核空间（主要是内存地址空间的隔离）。</p><pre><code>用户空间         应用程序(Applications)                        |      |                        |     C库（如glibc）                        |      |                       系统调用(System Calls，如sys_read, sys_write, sys_exit)                            |内核空间              内核(Kernel)</code></pre><p>系统调用实际上也是一些函数，它们被定义在 <code>arch/i386/kernel/sys_i386.c</code> （老的在 <code>arch/i386/kernel/sys.c</code>）文件中，并且通过一张系统调用表组织，该表在内核启动时就已经加载了，这个表的入口在内核源代码的 <code>arch/i386/kernel/syscall_table.S</code> 里头（老的在 <code>arch/i386/kernel/entry.S</code>）。这样，如果想添加一个新的系统调用，修改上面两个内核中的文件，并重新编译内核就可以。当然，如果要在应用程序中使用它们，还得把它写到 <code>include/asm/unistd.h</code> 中。</p><p>如果要在 C 语言中使用某个系统调用，需要包含头文件 <code>/usr/include/asm/unistd.h</code>，里头有各个系统调用的声明以及系统调用号（对应于调用表的入口，即在调用表中的索引，为方便查找调用表而设立的）。如果是自己定义的新系统调用，可能还要在开头用宏 <code>_syscall(type, name, type1, name1...)</code>来声明好参数。</p><p>如果要在汇编语言中使用，需要用到 <code>int 0x80</code> 调用，这个是系统调用的中断入口。涉及到传送参数的寄存器有这么几个，<code>eax</code> 是系统调用号（可以到 <code>/usr/include/asm-i386/unistd.h</code> 或者直接到 <code>arch/i386/kernel/syscall_table.S</code> 查到），其他寄存器如 <code>ebx</code>，<code>ecx</code>，<code>edx</code>，<code>esi</code>，<code>edi</code> 一次存放系统调用的参数。而系统调用的返回值存放在 <code>eax</code> 寄存器中。</p><p>下面我们就很容易解释前面的 <code>Shellcode.c</code> 程序流程的 2，3 两部分了。因为都用了 <code>int 0x80</code> 中断，所以都用到了系统调用。</p><p>第 3 部分很简单，用到的系统调用号是 1，通过查表（查 <code>/usr/include/asm-i386/unistd.h</code> 或 <code>arch/i386/kernel/syscall_table.S</code>）可以发现这里是 <code>sys_exit</code> 调用，再从 <code>/usr/include/unistd.h</code> 文件看这个系统调用的声明，发现参数 <code>ebx</code> 是程序退出状态。</p><p>第 2 部分比较有趣，而且复杂一点。我们依次来看各个寄存器，首先根据 <code>eax</code> 为 4 确定（同样查表）系统调用为 <code>sys_write</code>，而查看它的声明（从 <code>/usr/include/unistd.h</code>），我们找到了参数依次为文件描述符、字符串指针和字符串长度。</p><ul><li>第一个参数是 <code>ebx</code>，正好是 2，即标准错误输出，默认为终端。</li><li>第二个参数是 <code>ecx</code>，而 <code>ecx</code> 的内容来自 <code>esi</code>，<code>esi</code> 来自刚弹出栈的值（见第 6 行 <code>popl %esi;</code>），而之前刚好有 <code>call</code> 指令引起了最近一次压栈操作，入栈的内容刚好是 <code>call</code> 指令的下一条指令的地址，即 <code>.string</code> 所在行的地址，这样 <code>ecx</code> 刚好引用了 <code>Hello World\\n</code> 字符串的地址。</li><li>第三个参数是 <code>edx</code>，刚好是 12，即 <code>Hello World\\n</code> 字符串的长度（包括一个空字符）。这样，<code>Shellcode.c</code> 的执行流程就很清楚了，第 4，5，15，16 行指令的巧妙之处也就容易理解了（把 <code>.string</code> 存放在 <code>call</code> 指令之后，并用 <code>popl</code> 指令把 <code>eip</code> 弹出当作字符串的入口）。</li></ul><h3 id="什么是-ELF-文件"><a href="#什么是-ELF-文件" class="headerlink" title="什么是 ELF 文件"></a>什么是 ELF 文件</h3><p>这里的 ELF 不是“精灵”，而是 Executable and Linking Format 文件，是 Linux 下用来做目标文件、可执行文件和共享库的一种文件格式，它有专门的标准。</p><p>下面简单描述 <code>ELF</code> 的格式。</p><p><code>ELF</code> 文件主要有三种，分别是：</p><ul><li>可重定位的目标文件，在编译时用 <code>gcc</code> 的 <code>-c</code> 参数时产生。</li><li>可执行文件，这类文件就是我们后面要讨论的可以执行的文件。</li><li>共享库，这里主要是动态共享库，而静态共享库则是可重定位的目标文件通过 <code>ar</code> 命令组织的。</li></ul><p><code>ELF</code> 文件的大体结构：</p><pre><code>ELF Header               #程序头，有该文件的Magic number(参考man magic)，类型等Program Header Table     #对可执行文件和共享库有效，它描述下面各个节(section)组成的段Section1Section2Section3.....Program Section Table   #仅对可重定位目标文件和静态库有效，用于描述各个Section的重定位信息等。</code></pre><p>对于可执行文件，文件最后的 <code>Program Section Table</code> （节区表）和一些非重定位的 <code>Section</code>，比如 <code>.comment</code>，<code>.note.XXX.debug</code> 等信息都可以删除掉，不过如果用 <code>strip</code>，<code>objcopy</code> 等工具删除掉以后，就不可恢复了。因为这些信息对程序的运行一般没有任何用处。</p><p><code>ELF</code> 文件的主要节区（<code>section</code>）有 <code>.data</code>，<code>.text</code>，<code>.bss</code>，<code>.interp</code> 等，而主要段（<code>segment</code>）有 <code>LOAD</code>，<code>INTERP</code> 等。它们之间（节区和段）的主要对应关系如下：</p><table><thead><tr><th>Section</th><th>解释</th><th>实例</th></tr></thead><tbody><tr><td>.data</td><td>初始化的数据</td><td>比如 <code>int a=10</code></td></tr><tr><td>.bss</td><td>未初始化的数据</td><td>比如 <code>char sum[100];</code> 这个在程序执行之前，内核将初始化为 0</td></tr><tr><td>.text</td><td>程序代码正文</td><td>即可执行指令集</td></tr><tr><td>.interp</td><td>描述程序需要的解释器（动态连接和装载程序）</td><td>存有解释器的全路径，如 <code>/lib/ld-linux.so</code></td></tr></tbody></table><p>而程序在执行以后，<code>.data</code>，<code>.bss</code>，<code>.text</code> 等一些节区会被 <code>Program header table</code> 映射到 <code>LOAD</code> 段，<code>.interp</code> 则被映射到了 <code>INTERP</code> 段。</p><p>对于 <code>ELF</code> 文件的分析，建议使用 <code>file</code>，<code>size</code>，<code>readelf</code>，<code>objdump</code>，<code>strip</code>，<code>objcopy</code>，<code>gdb</code>，<code>nm</code> 等工具。</p><p>这里简单地演示这几个工具：</p><pre class="line-numbers language-bash"><code class="language-bash">$ gcc -g -o shellcode shellcode.c  <span class="token comment" spellcheck="true">#如果要用gdb调试，编译时加上-g是必须的</span>shellcode.c: In <span class="token keyword">function</span> ‘main’:shellcode.c:3: warning: <span class="token keyword">return</span> <span class="token function">type</span> of ‘main’ is not ‘int’f$ <span class="token function">file</span> shellcode  <span class="token comment" spellcheck="true">#file命令查看文件类型，想了解工作原理，可man magic,man file</span>shellcode: ELF 32-bit LSB executable, Intel 80386, version 1 <span class="token punctuation">(</span>SYSV<span class="token punctuation">)</span>,dynamically linked <span class="token punctuation">(</span>uses shared libs<span class="token punctuation">)</span>, not stripped$ readelf -l shellcode  <span class="token comment" spellcheck="true">#列出ELF文件前面的program head table，后面是它描</span>                       <span class="token comment" spellcheck="true">#述了各个段(segment)和节区(section)的关系,即各个段包含哪些节区。</span>Elf <span class="token function">file</span> <span class="token function">type</span> is EXEC <span class="token punctuation">(</span>Executable file<span class="token punctuation">)</span>Entry point 0x8048280There are 7 program headers, starting at offset 52Program Headers:  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align  PHDR           0x000034 0x08048034 0x08048034 0x000e0 0x000e0 R E 0x4  INTERP         0x000114 0x08048114 0x08048114 0x00013 0x00013 R   0x1      <span class="token punctuation">[</span>Requesting program interpreter: /lib/ld-linux.so.2<span class="token punctuation">]</span>  LOAD           0x000000 0x08048000 0x08048000 0x0044c 0x0044c R E 0x1000  LOAD           0x00044c 0x0804944c 0x0804944c 0x00100 0x00104 RW  0x1000  DYNAMIC        0x000460 0x08049460 0x08049460 0x000c8 0x000c8 RW  0x4  NOTE           0x000128 0x08048128 0x08048128 0x00020 0x00020 R   0x4  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4 Section to Segment mapping:  Segment Sections<span class="token punctuation">..</span>.   00   01     .interp   02     .interp .note.ABI-tag .hash .dynsym .dynstr .gnu.version .gnu.version_r          .rel.dyn .rel.plt .init .plt .text .fini .rodata .eh_frame   03     .ctors .dtors .jcr .dynamic .got .got.plt .data .bss   04     .dynamic   05     .note.ABI-tag   06$ size shellcode   <span class="token comment" spellcheck="true">#可用size命令查看各个段（对应后面将分析的进程内存映像）的大小</span>   text    data     bss     dec     hex filename    815     256       4    1075     433 shellcode$ strip -R .note.ABI-tag shellcode <span class="token comment" spellcheck="true">#可用strip来给可执行文件“减肥”，删除无用信息</span>$ size shellcode               <span class="token comment" spellcheck="true">#“减肥”后效果“明显”，对于嵌入式系统应该有很大的作用</span>   text    data     bss     dec     hex filename    783     256       4    1043     413 shellcode$ objdump -s -j .interp shellcode <span class="token comment" spellcheck="true">#这个主要工作是反编译，不过用来查看各个节区也很厉害</span>shellcode:     <span class="token function">file</span> <span class="token function">format</span> elf32-i386Contents of section .interp: 8048114 2f6c6962 2f6c642d 6c696e75 782e736f  /lib/ld-linux.so 8048124 2e3200                               .2.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>补充：如果要删除可执行文件的 <code>Program Section Table</code>，可以用 <a href="http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html">A Whirlwind Tutorial on Creating Really Teensy ELF Executables for Linux</a> 一文的作者写的 <a href="http://www.muppetlabs.com/~breadbox/software/elfkickers.html">elf kicker</a> 工具链中的 <code>sstrip</code> 工具。</p><h3 id="程序执行基本过程"><a href="#程序执行基本过程" class="headerlink" title="程序执行基本过程"></a>程序执行基本过程</h3><p>在命令行下，敲入程序的名字或者是全路径，然后按下回车就可以启动程序，这个具体是怎么工作的呢？</p><p>首先要再认识一下我们的命令行，命令行是内核和用户之间的接口，它本身也是一个程序。在 Linux 系统启动以后会为每个终端用户建立一个进程执行一个 Shell 解释程序，这个程序解释并执行用户输入的命令，以实现用户和内核之间的接口。这类解释程序有哪些呢？目前 Linux 下比较常用的有 <code>/bin/bash</code> 。那么该程序接收并执行命令的过程是怎么样的呢？</p><p>先简单描述一下这个过程：</p><ul><li>读取用户由键盘输入的命令行。</li><li>分析命令，以命令名作为文件名，并将其它参数改为系统调用 <code>execve</code> 内部处理所要求的形式。</li><li>终端进程调用 <code>fork</code> 建立一个子进程。</li><li>终端进程本身用系统调用 <code>wait4</code> 来等待子进程完成（如果是后台命令，则不等待）。当子进程运行时调用 <code>execve</code>，子进程根据文件名（即命令名）到目录中查找有关文件（这是命令解释程序构成的文件），将它调入内存，执行这个程序（解释这条命令）。</li><li>如果命令末尾有 <code>&amp;</code> 号（后台命令符号），则终端进程不用系统调用 <code>wait4</code> 等待，立即发提示符，让用户输入下一个命令，转 1）。如果命令末尾没有 <code>&amp;</code> 号，则终端进程要一直等待，当子进程（即运行命令的进程）完成处理后终止，向父进程（终端进程）报告，此时终端进程醒来，在做必要的判别等工作后，终端进程发提示符，让用户输入新的命令，重复上述处理过程。</li></ul><p>现在用 <code>strace</code> 来跟踪一下程序执行过程中用到的系统调用。</p><pre><code>$ strace -f -o strace.out test$ cat strace.out | grep \(.*\) | sed -e &quot;s#[0-9]* \([a-zA-Z0-9_]*\)(.*).*#\1#g&quot;execvebrkaccessopenfstat64mmap2closeopenreadfstat64mmap2mmap2mmap2mmap2closemmap2set_thread_areamprotectmunmapbrkbrkopenfstat64mmap2closeclosecloseexit_group</code></pre><p>相关的系统调用基本体现了上面的执行过程，需要注意的是，里头还涉及到内存映射（<code>mmap2</code>）等。</p><p>下面再罗嗦一些比较有意思的内容，参考《深入理解 Linux 内核》的程序的执行（P681）。</p><p>Linux 支持很多不同的可执行文件格式，这些不同的格式是如何解释的呢？平时我们在命令行下敲入一个命令就完了，也没有去管这些细节。实际上 Linux 下有一个 <code>struct linux_binfmt</code> 结构来管理不同的可执行文件类型，这个结构中有对应的可执行文件的处理函数。大概的过程如下：</p><ul><li>在用户态执行了 <code>execve</code> 后，引发 <code>int 0x80</code> 中断，进入内核态，执行内核态的相应函数 <code>do_sys_execve</code>，该函数又调用 <code>do_execve</code> 函数。 <code>do_execve</code> 函数读入可执行文件，检查权限，如果没问题，继续读入可执行文件需要的相关信息（<code>struct linux_binprm</code> 描述的）。</li><li>接着执行 <code>search_binary_handler</code>，根据可执行文件的类型（由上一步的最后确定），在 <code>linux_binfmt</code> 结构链表（<code>formats</code>，这个链表可以通过 <code>register_binfmt</code> 和 <code>unregister_binfmt</code> 注册和删除某些可执行文件的信息，因此注册新的可执行文件成为可能，后面再介绍）上查找，找到相应的结构，然后执行相应的 <code>load_binary</code> 函数开始加载可执行文件。在该链表的最后一个元素总是对解释脚本（<code>interpreted script</code>）的可执行文件格式进行描述的一个对象。这种格式只定义了 <code>load_binary</code> 方法，其相应的 <code>load_script</code> 函数检查这种可执行文件是否以两个 <code>#!</code> 字符开始，如果是，这个函数就以另一个可执行文件的路径名作为参数解释第一行的其余部分，并把脚本文件名作为参数传递以执行这个脚本（实际上脚本程序把自身的内容当作一个参数传递给了解释程序（如 <code>/bin/bash</code>），而这个解释程序通常在脚本文件的开头用 <code>#!</code> 标记，如果没有标记，那么默认解释程序为当前 <code>SHELL</code>）。</li><li>对于 <code>ELF</code> 类型文件，其处理函数是 <code>load_elf_binary</code>，它先读入 <code>ELF</code> 文件的头部，根据头部信息读入各种数据，再次扫描程序段描述表（<code>Program Header Table</code>），找到类型为 <code>PT_LOAD</code> 的段（即 <code>.text</code>，<code>.data</code>，<code>.bss</code> 等节区），将其映射（<code>elf_map</code>）到内存的固定地址上，如果没有动态连接器的描述段，把返回的入口地址设置成应用程序入口。完成这个功能的是 <code>start_thread</code>，它不启动一个线程，而只是用来修改了 <code>pt_regs</code> 中保存的 <code>PC</code> 等寄存器的值，使其指向加载的应用程序的入口。当内核操作结束，返回用户态时接着就执行应用程序本身了。</li><li>如果应用程序使用了动态连接库，内核除了加载指定的可执行文件外，还要把控制权交给动态连接器（<code>ld-linux.so</code>）以便处理动态连接的程序。内核搜寻段表（<code>Program Header Table</code>），找到标记为 <code>PT_INTERP</code> 段中所对应的动态连接器的名称，并使用 <code>load_elf_interp</code> 加载其映像，并把返回的入口地址设置成 <code>load_elf_interp</code> 的返回值，即动态链接器的入口。当 <code>execve</code> 系统调用退出时，动态连接器接着运行，它检查应用程序对共享链接库的依赖性，并在需要时对其加载，对程序的外部引用进行重定位。然后把控制权交给应用程序，从 <code>ELF</code> 文件头部中定义的程序进入点（用 <code>readelf -h</code> 可以出看到，<code>Entry point address</code> 即是）开始执行。（不过对于非 <code>LIB_BIND_NOW</code> 的共享库装载是在有外部引用请求时才执行的）。</li></ul><p>对于内核态的函数调用过程，没有办法通过 <code>strace</code>（它只能跟踪到系统调用层）来做的，因此要想跟踪内核中各个系统调用的执行细节，需要用其他工具。比如可以通过 Ftrace 来跟踪内核具体调用了哪些函数。当然，也可以通过 <code>ctags/cscope/LXR</code> 等工具分析内核的源代码。</p><p>Linux 允许自己注册我们自己定义的可执行格式，主要接口是 <code>/procy/sys/fs/binfmt_misc/register</code>，可以往里头写入特定格式的字符串来实现。该字符串格式如下： <code>:name:type:offset:string:mask:interpreter:</code></p><ul><li><code>name</code> 新格式的标示符</li><li><code>type</code> 识别类型（<code>M</code> 表示魔数，<code>E</code> 表示扩展）</li><li><code>offset</code> 魔数（<code>magic number</code>，请参考 <code>man magic</code> 和 <code>man file</code>）在文件中的启始偏移量</li><li><code>string</code> 以魔数或者以扩展名匹配的字节序列</li><li><code>mask</code> 用来屏蔽掉 <code>string</code> 的一些位</li><li><code>interpreter</code> 程序解释器的完整路径名</li></ul><h3 id="Linux-下程序的内存映像"><a href="#Linux-下程序的内存映像" class="headerlink" title="Linux 下程序的内存映像"></a>Linux 下程序的内存映像</h3><p>Linux 下是如何给进程分配内存（这里仅讨论虚拟内存的分配）的呢？可以从 <code>/proc/&lt;pid&gt;/maps</code> 文件中看到个大概。这里的 <code>pid</code> 是进程号。</p><p><code>/proc</code> 下有一个文件比较特殊，是 <code>self</code>，它链接到当前进程的进程号，例如：</p><pre><code>$ ls /proc/self -llrwxrwxrwx 1 root root 64 2000-01-10 18:26 /proc/self -&gt; 11291/$ ls /proc/self -llrwxrwxrwx 1 root root 64 2000-01-10 18:26 /proc/self -&gt; 11292/</code></pre><p>看到没？每次都不一样，这样我们通过 <code>cat /proc/self/maps</code> 就可以看到 <code>cat</code> 程序执行时的内存映像了。</p><pre><code>$ cat -n /proc/self/maps     1  08048000-0804c000 r-xp 00000000 03:01 273716     /bin/cat     2  0804c000-0804d000 rw-p 00003000 03:01 273716     /bin/cat     3  0804d000-0806e000 rw-p 0804d000 00:00 0          [heap]     4  b7b90000-b7d90000 r--p 00000000 03:01 87528      /usr/lib/locale/locale-archive     5  b7d90000-b7d91000 rw-p b7d90000 00:00 0     6  b7d91000-b7ecd000 r-xp 00000000 03:01 466875     /lib/libc-2.5.so     7  b7ecd000-b7ece000 r--p 0013c000 03:01 466875     /lib/libc-2.5.so     8  b7ece000-b7ed0000 rw-p 0013d000 03:01 466875     /lib/libc-2.5.so     9  b7ed0000-b7ed4000 rw-p b7ed0000 00:00 0    10  b7eeb000-b7f06000 r-xp 00000000 03:01 402817     /lib/ld-2.5.so    11  b7f06000-b7f08000 rw-p 0001b000 03:01 402817     /lib/ld-2.5.so    12  bfbe3000-bfbf8000 rw-p bfbe3000 00:00 0          [stack]    13  ffffe000-fffff000 r-xp 00000000 00:00 0          [vdso]</code></pre><p>编号是原文件里头没有的，为了说明方便，用 <code>-n</code> 参数加上去的。我们从中可以得到如下信息：</p><ul><li>第 1，2 行对应的内存区是我们的程序（包括指令，数据等）</li><li>第 3 到 12 行对应的内存区是堆栈段，里头也映像了程序引用的动态连接库</li><li>第 13 行是内核空间</li></ul><p>总结一下：</p><ul><li>前两部分是用户空间，可以从 <code>0x00000000</code> 到 <code>0xbfffffff</code> （在测试的 <code>2.6.21.5-smp</code> 上只到 <code>bfbf8000</code>），而内核空间从 <code>0xC0000000</code> 到 <code>0xffffffff</code>，分别是 <code>3G</code> 和 <code>1G</code>，所以对于每一个进程来说，共占用 <code>4G</code> 的虚拟内存空间</li><li>从程序本身占用的内存，到堆栈段（动态获取内存或者是函数运行过程中用来存储局部变量、参数的空间，前者是 <code>heap</code>，后者是 <code>stack</code>），再到内核空间，地址是从低到高的</li><li>栈顶并非 <code>0xC0000000</code> 下的一个固定数值</li></ul><p>结合相关资料，可以得到这么一个比较详细的进程内存映像表（以 <code>Linux 2.6.21.5-smp</code> 为例）：</p><table><thead><tr><th>地址</th><th>内核空间</th><th>描述</th></tr></thead><tbody><tr><td>0xC0000000</td><td></td><td></td></tr><tr><td></td><td>(program flie) 程序名</td><td>execve 的第一个参数</td></tr><tr><td></td><td>(environment) 环境变量</td><td>execve 的第三个参数，main 的第三个参数</td></tr><tr><td></td><td>(arguments) 参数</td><td>execve 的第二个参数，main 的形参</td></tr><tr><td></td><td>(stack) 栈</td><td>自动变量以及每次函数调用时所需保存的信息都</td></tr><tr><td></td><td></td><td>存放在此，包括函数返回地址、调用者的</td></tr><tr><td></td><td></td><td>环境信息等，函数的参数，局部变量都存放在此</td></tr><tr><td></td><td>(shared memory) 共享内存</td><td>共享内存的大概位置</td></tr><tr><td></td><td>…</td><td></td></tr><tr><td></td><td>…</td><td></td></tr><tr><td></td><td>(heap) 堆</td><td>主要在这里进行动态存储分配，比如 malloc，new 等。</td></tr><tr><td></td><td>…</td><td></td></tr><tr><td></td><td>.bss (uninitilized data)</td><td>没有初始化的数据（全局变量哦）</td></tr><tr><td></td><td>.data (initilized global data)</td><td>已经初始化的全局数据（全局变量）</td></tr><tr><td></td><td>.text (Executable Instructions)</td><td>通常是可执行指令</td></tr><tr><td>0x08048000</td><td></td><td></td></tr><tr><td>0x00000000</td><td></td><td>…</td></tr></tbody></table><p>光看没有任何概念，我们用 <code>gdb</code> 来看看刚才那个简单的程序。</p><pre class="line-numbers language-c"><code class="language-c">$ gcc <span class="token operator">-</span>g <span class="token operator">-</span>o shellcode shellcode<span class="token punctuation">.</span>c   #要用gdb调试，在编译时需要加<span class="token operator">-</span>g参数$ gdb <span class="token operator">-</span>q <span class="token punctuation">.</span><span class="token operator">/</span><span class="token function">shellcode</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> set args arg1 arg2 arg3 arg4  #为了测试，设置几个参数<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> l                             #浏览代码<span class="token number">1</span> <span class="token comment" spellcheck="true">/* shellcode.c */</span><span class="token number">2</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">3</span> <span class="token punctuation">{</span><span class="token number">4</span>     __asm__ <span class="token function">__volatile__</span><span class="token punctuation">(</span><span class="token string">"jmp forward;"</span><span class="token number">5</span>     <span class="token string">"backward:"</span><span class="token number">6</span>        <span class="token string">"popl   %esi;"</span><span class="token number">7</span>        <span class="token string">"movl   $4, %eax;"</span><span class="token number">8</span>        <span class="token string">"movl   $2, %ebx;"</span><span class="token number">9</span>        <span class="token string">"movl   %esi, %ecx;"</span><span class="token number">10</span>               <span class="token string">"movl   $12, %edx;"</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> <span class="token keyword">break</span> <span class="token number">4</span>               #在汇编入口设置一个断点，让程序运行后停到这里Breakpoint <span class="token number">1</span> at <span class="token number">0x8048332</span><span class="token punctuation">:</span> file shellcode<span class="token punctuation">.</span>c<span class="token punctuation">,</span> line <span class="token number">4</span><span class="token punctuation">.</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> r                     #运行程序Starting program<span class="token punctuation">:</span> <span class="token operator">/</span>mnt<span class="token operator">/</span>hda8<span class="token operator">/</span>Temp<span class="token operator">/</span>c<span class="token operator">/</span>program<span class="token operator">/</span>shellcode arg1 arg2 arg3 arg4Breakpoint <span class="token number">1</span><span class="token punctuation">,</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> at shellcode<span class="token punctuation">.</span>c<span class="token punctuation">:</span><span class="token number">4</span><span class="token number">4</span>     __asm__ <span class="token function">__volatile__</span><span class="token punctuation">(</span><span class="token string">"jmp forward;"</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> print $esp            #打印当前堆栈指针值，用于查找整个栈的栈顶$<span class="token number">1</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">0xbffe1584</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x<span class="token operator">/</span>100s $esp<span class="token operator">+</span><span class="token number">4000</span>      #改变后面的<span class="token number">4000</span>，不断往更大的空间找<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x<span class="token operator">/</span>1s <span class="token number">0xbffe1fd9</span>       #在 <span class="token number">0xbffe1fd9</span> 找到了程序名，这里是该次运行时的栈顶<span class="token number">0xbffe1fd9</span><span class="token punctuation">:</span>      <span class="token string">"/mnt/hda8/Temp/c/program/shellcode"</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x<span class="token operator">/</span>10s <span class="token number">0xbffe17b7</span>      #其他环境变量信息<span class="token number">0xbffe17b7</span><span class="token punctuation">:</span>      <span class="token string">"CPLUS_INCLUDE_PATH=/usr/lib/qt/include"</span><span class="token number">0xbffe17de</span><span class="token punctuation">:</span>      <span class="token string">"MANPATH=/usr/local/man:/usr/man:/usr/X11R6/man:/usr/lib/java/man:/usr/share/texmf/man"</span><span class="token number">0xbffe1834</span><span class="token punctuation">:</span>      <span class="token string">"HOSTNAME=falcon.lzu.edu.cn"</span><span class="token number">0xbffe184f</span><span class="token punctuation">:</span>      <span class="token string">"TERM=xterm"</span><span class="token number">0xbffe185a</span><span class="token punctuation">:</span>      <span class="token string">"SSH_CLIENT=219.246.50.235 3099 22"</span><span class="token number">0xbffe187c</span><span class="token punctuation">:</span>      <span class="token string">"QTDIR=/usr/lib/qt"</span><span class="token number">0xbffe188e</span><span class="token punctuation">:</span>      <span class="token string">"SSH_TTY=/dev/pts/0"</span><span class="token number">0xbffe18a1</span><span class="token punctuation">:</span>      <span class="token string">"USER=falcon"</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x<span class="token operator">/</span>5s <span class="token number">0xbffe1780</span>    #一些传递给main函数的参数，包括文件名和其他参数<span class="token number">0xbffe1780</span><span class="token punctuation">:</span>      <span class="token string">"/mnt/hda8/Temp/c/program/shellcode"</span><span class="token number">0xbffe17a3</span><span class="token punctuation">:</span>      <span class="token string">"arg1"</span><span class="token number">0xbffe17a8</span><span class="token punctuation">:</span>      <span class="token string">"arg2"</span><span class="token number">0xbffe17ad</span><span class="token punctuation">:</span>      <span class="token string">"arg3"</span><span class="token number">0xbffe17b2</span><span class="token punctuation">:</span>      <span class="token string">"arg4"</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> print init  #打印init函数的地址，这个是<span class="token operator">/</span>usr<span class="token operator">/</span>lib<span class="token operator">/</span>crti<span class="token punctuation">.</span>o里头的函数，做一些初始化操作$<span class="token number">2</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">&lt;</span>text variable<span class="token punctuation">,</span> no debug info<span class="token operator">></span><span class="token punctuation">}</span> <span class="token number">0xb7e73d00</span> <span class="token operator">&lt;</span>init<span class="token operator">></span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> print fini   #也在<span class="token operator">/</span>usr<span class="token operator">/</span>lib<span class="token operator">/</span>crti<span class="token punctuation">.</span>o中定义，在程序结束时做一些处理工作$<span class="token number">3</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">&lt;</span>text variable<span class="token punctuation">,</span> no debug info<span class="token operator">></span><span class="token punctuation">}</span> <span class="token number">0xb7f4a380</span> <span class="token operator">&lt;</span>fini<span class="token operator">></span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> print _start #在<span class="token operator">/</span>usr<span class="token operator">/</span>lib<span class="token operator">/</span>crt1<span class="token punctuation">.</span>o，这个才是程序的入口，必须的，ld会检查这个$<span class="token number">4</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">&lt;</span>text variable<span class="token punctuation">,</span> no debug info<span class="token operator">></span><span class="token punctuation">}</span> <span class="token number">0x8048280</span> <span class="token operator">&lt;</span>__libc_start_main@plt<span class="token operator">+</span><span class="token number">20</span><span class="token operator">></span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> print main   #这里是我们的main函数$<span class="token number">5</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token number">0x8048324</span> <span class="token operator">&lt;</span>main<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>补充：在进程的内存映像中可能看到诸如 <code>init</code>，<code>fini</code>，<code>_start</code> 等函数（或者是入口），这些东西并不是我们自己写的啊？为什么会跑到我们的代码里头呢？实际上这些东西是链接的时候 <code>gcc</code> 默认给连接进去的，主要用来做一些进程的初始化和终止的动作。上面的操作对堆栈的操作比较少，下面我们用一个例子来演示栈在内存中的情况。</p><h3 id="栈在内存中的组织"><a href="#栈在内存中的组织" class="headerlink" title="栈在内存中的组织"></a>栈在内存中的组织</h3><p>这一节主要介绍一个函数被调用时，参数是如何传递的，局部变量是如何存储的，它们对应的栈的位置和变化情况，从而加深对栈的理解。在操作时发现和参考资料的结果不太一样（参考资料中没有 <code>edi</code> 和 <code>esi</code> 相关信息，再第二部分的一个小程序里头也没有），可能是 <code>gcc</code> 版本的问题或者是它对不同源代码的处理不同。我的版本是 <code>4.1.2</code> （可以通过 <code>gcc --version</code> 查看）。</p><p>先来一段简单的程序，这个程序除了做一个加法操作外，还复制了一些字符串。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* testshellcode.c */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span>      </span><span class="token comment" spellcheck="true">/* printf */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span>     </span><span class="token comment" spellcheck="true">/* memset, memcpy */</span><span class="token macro property">#<span class="token directive keyword">define</span> BUF_SIZE 8</span><span class="token macro property">#<span class="token directive keyword">ifndef</span> STR_SRC</span><span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAA"</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> buffer<span class="token punctuation">[</span>BUF_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>    sum <span class="token operator">=</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token string">'\0'</span><span class="token punctuation">,</span> BUF_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> STR_SRC<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>STR_SRC<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> sum<span class="token punctuation">;</span>    sum <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sum = %d\n"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面这个代码没有什么问题，编译执行一下：</p><pre><code>$ make testshellcodecc     testshellcode.c   -o testshellcode$ ./testshellcodesum = 6</code></pre><p>下面调试一下，看看在调用 <code>func</code> 后的栈的内容。</p><pre class="line-numbers language-c"><code class="language-c">$ gcc <span class="token operator">-</span>g <span class="token operator">-</span>o testshellcode testshellcode<span class="token punctuation">.</span>c  #为了调试，需要在编译时加<span class="token operator">-</span>g选项$ gdb <span class="token operator">-</span>q <span class="token punctuation">.</span><span class="token operator">/</span>testshellcode   #启动gdb调试<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> set logging on    #如果要记录调试过程中的信息，可以把日志记录功能打开Copying output to gdb<span class="token punctuation">.</span>txt<span class="token punctuation">.</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> l main            #列出源代码<span class="token number">20</span><span class="token number">21</span>              <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token number">22</span>      <span class="token punctuation">}</span><span class="token number">23</span><span class="token number">24</span>      <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">25</span>      <span class="token punctuation">{</span><span class="token number">26</span>              <span class="token keyword">int</span> sum<span class="token punctuation">;</span><span class="token number">27</span><span class="token number">28</span>              sum <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">29</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> <span class="token keyword">break</span> <span class="token number">28</span>   #在调用func函数之前让程序停一下，以便记录当时的<span class="token function">ebp</span><span class="token punctuation">(</span>基指针<span class="token punctuation">)</span>Breakpoint <span class="token number">1</span> at <span class="token number">0x80483ac</span><span class="token punctuation">:</span> file testshellcode<span class="token punctuation">.</span>c<span class="token punctuation">,</span> line <span class="token number">28</span><span class="token punctuation">.</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> <span class="token keyword">break</span> func #设置断点在函数入口，以便逐步记录栈信息Breakpoint <span class="token number">2</span> at <span class="token number">0x804835c</span><span class="token punctuation">:</span> file testshellcode<span class="token punctuation">.</span>c<span class="token punctuation">,</span> line <span class="token number">13</span><span class="token punctuation">.</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> disassemble main   #反编译main函数，以便记录调用func后的下一条指令地址Dump of assembler code <span class="token keyword">for</span> function main<span class="token punctuation">:</span><span class="token number">0x0804839b</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">0</span><span class="token operator">></span><span class="token punctuation">:</span>    lea    <span class="token function">0x4</span><span class="token punctuation">(</span><span class="token operator">%</span>esp<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">%</span>ecx<span class="token number">0x0804839f</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">4</span><span class="token operator">></span><span class="token punctuation">:</span>    and    $<span class="token number">0xfffffff0</span><span class="token punctuation">,</span><span class="token operator">%</span>esp<span class="token number">0x080483a2</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">7</span><span class="token operator">></span><span class="token punctuation">:</span>    pushl  <span class="token function">0xfffffffc</span><span class="token punctuation">(</span><span class="token operator">%</span>ecx<span class="token punctuation">)</span><span class="token number">0x080483a5</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">10</span><span class="token operator">></span><span class="token punctuation">:</span>   push   <span class="token operator">%</span>ebp<span class="token number">0x080483a6</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">11</span><span class="token operator">></span><span class="token punctuation">:</span>   mov    <span class="token operator">%</span>esp<span class="token punctuation">,</span><span class="token operator">%</span>ebp<span class="token number">0x080483a8</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">13</span><span class="token operator">></span><span class="token punctuation">:</span>   push   <span class="token operator">%</span>ecx<span class="token number">0x080483a9</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">14</span><span class="token operator">></span><span class="token punctuation">:</span>   sub    $<span class="token number">0x14</span><span class="token punctuation">,</span><span class="token operator">%</span>esp<span class="token number">0x080483ac</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">17</span><span class="token operator">></span><span class="token punctuation">:</span>   push   $<span class="token number">0x3</span><span class="token number">0x080483ae</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">19</span><span class="token operator">></span><span class="token punctuation">:</span>   push   $<span class="token number">0x2</span><span class="token number">0x080483b0</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">21</span><span class="token operator">></span><span class="token punctuation">:</span>   push   $<span class="token number">0x1</span><span class="token number">0x080483b2</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">23</span><span class="token operator">></span><span class="token punctuation">:</span>   call   <span class="token number">0x8048354</span> <span class="token operator">&lt;</span>func<span class="token operator">></span><span class="token number">0x080483b7</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">28</span><span class="token operator">></span><span class="token punctuation">:</span>   add    $<span class="token number">0xc</span><span class="token punctuation">,</span><span class="token operator">%</span>esp<span class="token number">0x080483ba</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">31</span><span class="token operator">></span><span class="token punctuation">:</span>   mov    <span class="token operator">%</span>eax<span class="token punctuation">,</span><span class="token function">0xfffffff8</span><span class="token punctuation">(</span><span class="token operator">%</span>ebp<span class="token punctuation">)</span><span class="token number">0x080483bd</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">34</span><span class="token operator">></span><span class="token punctuation">:</span>   sub    $<span class="token number">0x8</span><span class="token punctuation">,</span><span class="token operator">%</span>esp<span class="token number">0x080483c0</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">37</span><span class="token operator">></span><span class="token punctuation">:</span>   pushl  <span class="token function">0xfffffff8</span><span class="token punctuation">(</span><span class="token operator">%</span>ebp<span class="token punctuation">)</span><span class="token number">0x080483c3</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">40</span><span class="token operator">></span><span class="token punctuation">:</span>   push   $<span class="token number">0x80484c0</span><span class="token number">0x080483c8</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">45</span><span class="token operator">></span><span class="token punctuation">:</span>   call   <span class="token number">0x80482a0</span> <span class="token operator">&lt;</span>printf@plt<span class="token operator">></span><span class="token number">0x080483cd</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">50</span><span class="token operator">></span><span class="token punctuation">:</span>   add    $<span class="token number">0x10</span><span class="token punctuation">,</span><span class="token operator">%</span>esp<span class="token number">0x080483d0</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">53</span><span class="token operator">></span><span class="token punctuation">:</span>   mov    $<span class="token number">0x0</span><span class="token punctuation">,</span><span class="token operator">%</span>eax<span class="token number">0x080483d5</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">58</span><span class="token operator">></span><span class="token punctuation">:</span>   mov    <span class="token function">0xfffffffc</span><span class="token punctuation">(</span><span class="token operator">%</span>ebp<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">%</span>ecx<span class="token number">0x080483d8</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">61</span><span class="token operator">></span><span class="token punctuation">:</span>   leave<span class="token number">0x080483d9</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">62</span><span class="token operator">></span><span class="token punctuation">:</span>   lea    <span class="token function">0xfffffffc</span><span class="token punctuation">(</span><span class="token operator">%</span>ecx<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">%</span>esp<span class="token number">0x080483dc</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">65</span><span class="token operator">></span><span class="token punctuation">:</span>   retEnd of assembler dump<span class="token punctuation">.</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> r        #运行程序Starting program<span class="token punctuation">:</span> <span class="token operator">/</span>mnt<span class="token operator">/</span>hda8<span class="token operator">/</span>Temp<span class="token operator">/</span>c<span class="token operator">/</span>program<span class="token operator">/</span>testshellcodeBreakpoint <span class="token number">1</span><span class="token punctuation">,</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> at testshellcode<span class="token punctuation">.</span>c<span class="token punctuation">:</span><span class="token number">28</span><span class="token number">28</span>              sum <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> print $ebp  #打印调用func函数之前的基地址，即Previous frame pointer。$<span class="token number">1</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">0xbf84fdd8</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> n           #执行call指令并跳转到func函数的入口Breakpoint <span class="token number">2</span><span class="token punctuation">,</span> <span class="token function">func</span> <span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> c<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span> at testshellcode<span class="token punctuation">.</span>c<span class="token punctuation">:</span><span class="token number">13</span><span class="token number">13</span>              <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> n<span class="token number">16</span>              sum <span class="token operator">=</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x<span class="token operator">/</span>11x $esp  #打印当前栈的内容，可以看出，地址从低到高，注意标记有蓝色和红色的值                 #它们分别是前一个栈基地址<span class="token punctuation">(</span>ebp<span class="token punctuation">)</span>和call调用之后的下一条指令的指针<span class="token punctuation">(</span>eip<span class="token punctuation">)</span><span class="token number">0xbf84fd94</span><span class="token punctuation">:</span>     <span class="token number">0x00000000</span>      <span class="token number">0x00000000</span>      <span class="token number">0x080482e0</span>      <span class="token number">0x00000000</span><span class="token number">0xbf84fda4</span><span class="token punctuation">:</span>     <span class="token number">0xb7f2bce0</span>      <span class="token number">0x00000000</span>      <span class="token number">0xbf84fdd8</span>      <span class="token number">0x080483b7</span><span class="token number">0xbf84fdb4</span><span class="token punctuation">:</span>     <span class="token number">0x00000001</span>      <span class="token number">0x00000002</span>      <span class="token function">0x00000003</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> n       #执行sum <span class="token operator">=</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c，后，比较栈内容第一行，第<span class="token number">4</span>列，由<span class="token number">0</span>变为<span class="token number">6</span><span class="token number">18</span>              <span class="token function">memset</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token string">'\0'</span><span class="token punctuation">,</span> BUF_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x<span class="token operator">/</span>11x $esp<span class="token number">0xbf84fd94</span><span class="token punctuation">:</span>     <span class="token number">0x00000000</span>      <span class="token number">0x00000000</span>      <span class="token number">0x080482e0</span>      <span class="token number">0x00000006</span><span class="token number">0xbf84fda4</span><span class="token punctuation">:</span>     <span class="token number">0xb7f2bce0</span>      <span class="token number">0x00000000</span>      <span class="token number">0xbf84fdd8</span>      <span class="token number">0x080483b7</span><span class="token number">0xbf84fdb4</span><span class="token punctuation">:</span>     <span class="token number">0x00000001</span>      <span class="token number">0x00000002</span>      <span class="token function">0x00000003</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> n<span class="token number">19</span>              <span class="token function">memcpy</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> STR_SRC<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>STR_SRC<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x<span class="token operator">/</span>11x $esp #缓冲区初始化以后变成了<span class="token number">0</span><span class="token number">0xbf84fd94</span><span class="token punctuation">:</span>     <span class="token number">0x00000000</span>      <span class="token number">0x00000000</span>      <span class="token number">0x00000000</span>      <span class="token number">0x00000006</span><span class="token number">0xbf84fda4</span><span class="token punctuation">:</span>     <span class="token number">0xb7f2bce0</span>      <span class="token number">0x00000000</span>      <span class="token number">0xbf84fdd8</span>      <span class="token number">0x080483b7</span><span class="token number">0xbf84fdb4</span><span class="token punctuation">:</span>     <span class="token number">0x00000001</span>      <span class="token number">0x00000002</span>      <span class="token function">0x00000003</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> n<span class="token number">21</span>              <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x<span class="token operator">/</span>11x $esp #进行copy以后，这两列的值变了，大小刚好是<span class="token number">7</span>个字节，最后一个字节为<span class="token string">'\0'</span><span class="token number">0xbf84fd94</span><span class="token punctuation">:</span>     <span class="token number">0x00000000</span>      <span class="token number">0x41414141</span>      <span class="token number">0x00414141</span>      <span class="token number">0x00000006</span><span class="token number">0xbf84fda4</span><span class="token punctuation">:</span>     <span class="token number">0xb7f2bce0</span>      <span class="token number">0x00000000</span>      <span class="token number">0xbf84fdd8</span>      <span class="token number">0x080483b7</span><span class="token number">0xbf84fdb4</span><span class="token punctuation">:</span>     <span class="token number">0x00000001</span>      <span class="token number">0x00000002</span>      <span class="token function">0x00000003</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> cContinuing<span class="token punctuation">.</span>sum <span class="token operator">=</span> <span class="token number">6</span>Program exited normally<span class="token punctuation">.</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> quit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的操作过程，我们可以得出大概的栈分布(<code>func</code> 函数结束之前)如下：</p><table><thead><tr><th>地址</th><th>值(hex)</th><th>符号或者寄存器</th><th>注释</th></tr></thead><tbody><tr><td>低地址</td><td></td><td></td><td>栈顶方向</td></tr><tr><td>0xbf84fd98</td><td>0x41414141</td><td>buf[0]</td><td>可以看出little endian(小端，重要的数据在前面)</td></tr><tr><td>0xbf84fd9c</td><td>0x00414141</td><td>buf[1]</td><td></td></tr><tr><td>0xbf84fda0</td><td>0x00000006</td><td>sum</td><td>可见这上面都是func函数里头的局部变量</td></tr><tr><td>0xbf84fda4</td><td>0xb7f2bce0</td><td>esi</td><td>源索引指针，可以通过产生中间代码查看，貌似没什么作用</td></tr><tr><td>0xbf84fda8</td><td>0x00000000</td><td>edi</td><td>目的索引指针</td></tr><tr><td>0xbf84fdac</td><td>0xbf84fdd8</td><td>ebp</td><td>调用func之前的栈的基地址，以便调用函数结束之后恢复</td></tr><tr><td>0xbf84fdb0</td><td>0x080483b7</td><td>eip</td><td>调用func之前的指令指针，以便调用函数结束之后继续执行</td></tr><tr><td>0xbf84fdb4</td><td>0x00000001</td><td>a</td><td>第一个参数</td></tr><tr><td>0xbf84fdb8</td><td>0x00000002</td><td>b</td><td>第二个参数</td></tr><tr><td>0xbf84fdbc</td><td>0x00000003</td><td>c</td><td>第三个参数，可见参数是从最后一个开始压栈的</td></tr><tr><td>高地址</td><td></td><td></td><td>栈底方向</td></tr></tbody></table><p>先说明一下 <code>edi</code> 和 <code>esi</code> 的由来（在上面的调试过程中我们并没有看到），是通过产生中间汇编代码分析得出的。</p><pre><code>$ gcc -S testshellcode.c</code></pre><p>在产生的 <code>testShellcode.s</code> 代码里头的 <code>func</code> 部分看到 <code>push ebp</code> 之后就 <code>push</code> 了 <code>edi</code> 和 <code>esi</code> 。但是搜索了一下代码，发现就这个函数里头引用了这两个寄存器，所以保存它们没什么用，删除以后编译产生目标代码后证明是没用的。</p><pre class="line-numbers language-assembly"><code class="language-assembly">$ cat testshellcode.s...func:        pushl   %ebp        movl    %esp, %ebp        pushl   %edi        pushl   %esi...        popl    %esi        popl    %edi        popl    %ebp...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面就不管这两部分（<code>edi</code> 和 <code>esi</code>）了，主要来分析和函数相关的这几部分在栈内的分布：</p><ul><li>函数局部变量，在靠近栈顶一端</li><li>调用函数之前的栈的基地址（<code>ebp</code>，<code>Previous Frame Pointer</code>），在中间靠近栈顶方向</li><li>调用函数指令的下一条指令地址 `` （<code>eip</code>），在中间靠近栈底的方向</li><li>函数参数，在靠近栈底的一端，最后一个参数最先入栈</li></ul><p>到这里，函数调用时的相关内容在栈内的分布就比较清楚了，在具体分析缓冲区溢出问题之前，我们再来看一个和函数关系很大的问题，即函数返回值的存储问题：函数的返回值存放在寄存器 <code>eax</code> 中。</p><p>先来看这段代码：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * test_return.c -- the return of a function is stored in register eax */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">__asm__</span> <span class="token punctuation">(</span><span class="token string">"movl $1, %eax"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"the return of func: %d\n"</span><span class="token punctuation">,</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译运行后，可以看到返回值为 1，刚好是我们在 <code>func</code> 函数中 <code>mov</code> 到 <code>eax</code> 中的“立即数” 1，因此很容易理解返回值存储在 <code>eax</code> 中的事实，如果还有疑虑，可以再看看汇编代码。在函数返回之后，<code>eax</code> 中的值当作了 <code>printf</code> 的参数压入了栈中，而在源代码中我们正是把 <code>func</code> 的结果作为 <code>printf</code> 的第二个参数的。</p><pre class="line-numbers language-c"><code class="language-c">$ make test_returncc     test_return<span class="token punctuation">.</span>c   <span class="token operator">-</span>o test_return$ <span class="token punctuation">.</span><span class="token operator">/</span>test_returnthe <span class="token keyword">return</span> of func<span class="token punctuation">:</span> <span class="token number">1</span>$ gcc <span class="token operator">-</span>S test_return<span class="token punctuation">.</span>c$ cat test_return<span class="token punctuation">.</span>s<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        call    func        subl    $<span class="token number">8</span><span class="token punctuation">,</span> <span class="token operator">%</span>esp        pushl   <span class="token operator">%</span>eax      #printf的第二个参数，把func的返回值压入了栈底        pushl   $<span class="token punctuation">.</span>LC0     #printf的第一个参数the <span class="token keyword">return</span> of func<span class="token punctuation">:</span> <span class="token operator">%</span>d\n        call    printf<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于系统调用，返回值也存储在 <code>eax</code> 寄存器中。</p><h2 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h2><h3 id="实例分析：字符串复制"><a href="#实例分析：字符串复制" class="headerlink" title="实例分析：字符串复制"></a>实例分析：字符串复制</h3><p>先来看一段简短的代码。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* testshellcode.c */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span>      </span><span class="token comment" spellcheck="true">/* printf */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span>     </span><span class="token comment" spellcheck="true">/* memset, memcpy */</span><span class="token macro property">#<span class="token directive keyword">define</span> BUF_SIZE 8</span><span class="token macro property">#<span class="token directive keyword">ifdef</span> STR1</span><span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAA\0\1\0\0\0"</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token macro property">#<span class="token directive keyword">ifndef</span> STR_SRC</span><span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAA"</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">char</span> buffer<span class="token punctuation">[</span>BUF_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>        sum <span class="token operator">=</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token string">'\0'</span><span class="token punctuation">,</span> BUF_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> STR_SRC<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>STR_SRC<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> sum<span class="token punctuation">;</span>        sum <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sum = %d\n"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译一下看看结果：</p><pre><code>$ gcc -DSTR1 -o testshellcode testshellcode.c  #通过-D定义宏STR1，从而采用第一个STR_SRC的值$ ./testshellcodesum = 1</code></pre><p>不知道你有没有发现异常呢？上面用红色标记的地方，本来 <code>sum</code> 为 <code>1+2+3</code> 即 6，但是实际返回的竟然是 1 。到底是什么原因呢？大家应该有所了解了，因为我们在复制字符串 <code>AAAAAAA\\0\\1\\0\\0\\0</code> 到 <code>buf</code> 的时候超出 <code>buf</code> 本来的大小。 <code>buf</code> 本来的大小是 <code>BUF_SIZE</code>，8 个字节，而我们要复制的内容是 12 个字节，所以超出了四个字节。根据第一小节的分析，我们用栈的变化情况来表示一下这个复制过程（即执行 <code>memcpy</code> 的过程）。</p><pre><code>memcpy(buffer, STR_SRC, sizeof(STR_SRC)-1);（低地址）复制之前     ====&gt; 复制之后0x00000000       0x41414141      #char buf[8]0x00000000       0x004141410x00000006       0x00000001      #int sum（高地址）</code></pre><p>下面通过 <code>gdb</code> 调试来确认一下(只摘录了一些片断)。</p><pre><code>$ gcc -DSTR1 -g -o testshellcode testshellcode.c$ gdb -q ./testshellcode...(gdb) l2122              memset(buffer, &#39;\0&#39;, BUF_SIZE);23              memcpy(buffer, STR_SRC, sizeof(STR_SRC)-1);2425              return sum;...(gdb) break 23Breakpoint 1 at 0x804837f: file testshellcode.c, line 23.(gdb) break 25Breakpoint 2 at 0x8048393: file testshellcode.c, line 25.(gdb) rStarting program: /mnt/hda8/Temp/c/program/testshellcodeBreakpoint 1, func (a=1, b=2, c=3) at testshellcode.c:2323              memcpy(buffer, STR_SRC, sizeof(STR_SRC)-1);(gdb) x/3x $esp+40xbfec6bd8:     0x00000000      0x00000000      0x00000006(gdb) nBreakpoint 2, func (a=1, b=2, c=3) at testshellcode.c:2525              return sum;(gdb) x/3x $esp+40xbfec6bd8:     0x41414141      0x00414141      0x00000001</code></pre><p>可以看出，因为 C 语言没有对数组的边界进行限制。我们可以往数组中存入预定义长度的字符串，从而导致缓冲区溢出。</p><h3 id="缓冲区溢出后果"><a href="#缓冲区溢出后果" class="headerlink" title="缓冲区溢出后果"></a>缓冲区溢出后果</h3><p>溢出之后的问题是导致覆盖栈的其他内容，从而可能改变程序原来的行为。</p><p>如果这类问题被“黑客”利用那将产生非常可怕的后果，小则让非法用户获取了系统权限，把你的服务器当成“僵尸”，用来对其他机器进行攻击，严重的则可能被人删除数据（所以备份很重要）。</p><h3 id="缓冲区溢出应对策略"><a href="#缓冲区溢出应对策略" class="headerlink" title="缓冲区溢出应对策略"></a>缓冲区溢出应对策略</h3><p>那这个怎么办呢？貌似<a href="http://www.ibm.com/developerworks/cn/linux/l-overflow/index.html">Linux下缓冲区溢出攻击的原理及对策</a>提到有一个 <code>libsafe</code> 库，可以至少用来检测程序中出现的类似超出数组边界的问题。对于上面那个具体问题，为了保护 <code>sum</code> 不被修改，有一个小技巧，可以让求和操作在字符串复制操作之后来做，以便求和操作把溢出的部分给重写。这个呆伙在下面一块看效果吧。继续看看缓冲区的溢出吧。</p><p>先来看看这个代码，还是 <code>testShellcode.c</code> 的改进。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* testshellcode.c */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span>      </span><span class="token comment" spellcheck="true">/* printf */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span> </span><span class="token comment" spellcheck="true">/* memset, memcpy */</span><span class="token macro property">#<span class="token directive keyword">define</span> BUF_SIZE 8</span><span class="token macro property">#<span class="token directive keyword">ifdef</span> STR1</span><span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAAa\1\0\0\0"</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token macro property">#<span class="token directive keyword">ifdef</span> STR2</span><span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAAa\1\0\0\0BBBBBBBB"</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token macro property">#<span class="token directive keyword">ifdef</span> STR3</span><span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAAa\1\0\0\0BBBBBBBBCCCC"</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token macro property">#<span class="token directive keyword">ifdef</span> STR4</span><span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAAa\1\0\0\0BBBBBBBBCCCCDDDD"</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token macro property">#<span class="token directive keyword">ifndef</span> STR_SRC</span><span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAA"</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">char</span> buffer<span class="token punctuation">[</span>BUF_SIZE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token string">'\0'</span><span class="token punctuation">,</span> BUF_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> STR_SRC<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>STR_SRC<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sum <span class="token operator">=</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//把求和操作放在复制操作之后可以在一定情况下“保护”求和结果</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> sum<span class="token punctuation">;</span>        sum <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sum = %d\n"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看看运行情况：</p><pre><code>$ gcc -D STR2 -o testshellcode testshellcode.c   #再多复制8个字节，结果和STR1时一样                        #原因是edi,esi这两个没什么用的，覆盖了也没关系$ ./testshellcode       #看到没？这种情况下，让整数操作在字符串复制之后做可以“保护‘整数结果sum = 6$ gcc -D STR3 -o testshellcode testshellcode.c  #再多复制4个字节，现在就会把ebp给覆盖                                               #了，这样当main函数再要用ebp访问数据                                              #时就会出现访问非法内存而导致段错误。$ ./testshellcodeSegmentation fault</code></pre><p>如果感兴趣，自己还可以用gdb类似之前一样来查看复制字符串以后栈的变化情况。</p><h3 id="如何保护-ebp-不被修改"><a href="#如何保护-ebp-不被修改" class="headerlink" title="如何保护 ebp 不被修改"></a>如何保护 ebp 不被修改</h3><p>下面来做一个比较有趣的事情：如何设法保护我们的 <code>ebp</code> 不被修改。</p><p>首先要明确 <code>ebp</code> 这个寄存器的作用和“行为”，它是栈基地址，并且发现在调用任何一个函数时，这个 <code>ebp</code> 总是在第一条指令被压入栈中，并在最后一条指令（<code>ret</code>）之前被弹出。类似这样：</p><pre><code>func:                        #函数       pushl %ebp            #第一条指令       ...       popl %ebp             #倒数第二条指令       ret</code></pre><p>还记得之前（第一部分）提到的函数的返回值是存储在 <code>eax</code> 寄存器中的么？如果我们在一个函数中仅仅做放这两条指令：</p><pre><code>popl %eaxpushl %eax</code></pre><p>那不就刚好有：</p><pre><code>func:                        #函数       pushl %ebp            #第一条指令       popl %eax             #把刚压入栈中的ebp弹出存放到eax中       pushl %eax            #又把ebp压入栈       popl %ebp             #倒数第二条指令       ret</code></pre><p>这样我们没有改变栈的状态，却获得了 <code>ebp</code> 的值，如果在调用任何一个函数之前，获取这个 <code>ebp</code>，并且在任何一条字符串复制语句（可能导致缓冲区溢出的语句）之后重新设置一下 <code>ebp</code> 的值，那么就可以保护 <code>ebp</code> 啦。具体怎么实现呢？看这个代码。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* testshellcode.c */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span>      </span><span class="token comment" spellcheck="true">/* printf */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span> </span><span class="token comment" spellcheck="true">/* memset, memcpy */</span><span class="token macro property">#<span class="token directive keyword">define</span> BUF_SIZE 8</span><span class="token macro property">#<span class="token directive keyword">ifdef</span> STR1</span><span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAAa\1\0\0\0"</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token macro property">#<span class="token directive keyword">ifdef</span> STR2</span><span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAAa\1\0\0\0BBBBBBBB"</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token macro property">#<span class="token directive keyword">ifdef</span> STR3</span><span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAAa\1\0\0\0BBBBBBBBCCCC"</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token macro property">#<span class="token directive keyword">ifdef</span> STR4</span><span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAAa\1\0\0\0BBBBBBBBCCCCDDDD"</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token macro property">#<span class="token directive keyword">ifndef</span> STR_SRC</span><span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAA"</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">get_ebp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">__asm__</span> <span class="token punctuation">(</span><span class="token string">"popl %eax;"</span>                                <span class="token string">"pushl %eax;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ebp<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">char</span> buffer<span class="token punctuation">[</span>BUF_SIZE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        sum <span class="token operator">=</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token string">'\0'</span><span class="token punctuation">,</span> BUF_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> STR_SRC<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>STR_SRC<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>buffer<span class="token operator">+</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">=</span> ebp<span class="token punctuation">;</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> sum<span class="token punctuation">,</span> ebp<span class="token punctuation">;</span>        ebp <span class="token operator">=</span> <span class="token function">get_ebp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sum <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> ebp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sum = %d\n"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码和之前的代码的不同有：</p><ul><li>给 <code>func</code> 函数增加了一个参数 <code>ebp</code>，（其实可以用全局变量替代的）</li><li>利用了刚介绍的原理定义了一个函数 <code>get_ebp</code> 以便获取老的 <code>ebp</code></li><li>在 <code>main</code> 函数中调用 <code>func</code> 之前调用了 <code>get_ebp</code>，并把它作为 <code>func</code> 的最后一个参数</li><li>在 <code>func</code> 函数中调用 <code>memcpy</code> 函数（可能发生缓冲区溢出的地方）之后添加了一条恢复设置 <code>ebp</code> 的语句，这条语句先把 <code>buffer+20</code> 这个地址（存放 <code>ebp</code> 的地址，你可以类似第一部分提到的用 <code>gdb</code> 来查看）强制转换为指向一个 <code>unsigned long</code> 型的整数（4 个字节），然后把它指向的内容修改为老的 <code>ebp</code> 。</li></ul><p>看看效果：</p><pre><code>$ gcc -D STR3 -o testshellcode testshellcode.c$ ./testshellcode         #现在没有段错误了吧，因为ebp得到了“保护”sum = 6</code></pre><h3 id="如何保护-eip-不被修改？"><a href="#如何保护-eip-不被修改？" class="headerlink" title="如何保护 eip 不被修改？"></a>如何保护 eip 不被修改？</h3><p>如果我们复制更多的字节过去了，比如再多复制四个字节进去，那么 <code>eip</code> 就被覆盖了。</p><pre><code>$ gcc -D STR4 -o testshellcode testshellcode.c$ ./testshellcodeSegmentation fault</code></pre><p>同样会出现段错误，因为下一条指令的位置都被改写了，<code>func</code> 返回后都不知道要访问哪个”非法“地址啦。呵呵，如果是一个合法地址呢？</p><p>如果在缓冲区溢出时，<code>eip</code> 被覆盖了，并且被修改为了一条合法地址，那么问题就非常”有趣“了。如果这个地址刚好是调用func的那个地址，那么整个程序就成了死循环，如果这个地址指向的位置刚好有一段关机代码，那么系统正在运行的所有服务都将被关掉，如果那个地方是一段更恶意的代码，那就？你可以尽情想像哦。如果是黑客故意利用这个，那么那些代码貌似就叫做<a href="http://janxin.bokee.com/4067220.html">shellcode</a>了。</p><p>有没有保护 <code>eip</code> 的办法呢？呵呵，应该是有的吧。不知道 <code>gas</code> 有没有类似 <code>masm</code> 汇编器中 <code>offset</code> 的伪操作指令（查找了一下，貌似没有），如果有的话在函数调用之前设置一个标号，在后面某个位置获取，再加上一个可能的偏移（包括 <code>call</code> 指令的长度和一些 <code>push</code> 指令等），应该可以算出来，不过貌似比较麻烦（或许你灵感大作，找到好办法了！），这里直接通过 <code>gdb</code> 反汇编求得它相对 <code>main</code> 的偏移算出来得了。求出来以后用它来”保护“栈中的值。</p><p>看看这个代码：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* testshellcode.c */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span>      </span><span class="token comment" spellcheck="true">/* printf */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span> </span><span class="token comment" spellcheck="true">/* memset, memcpy */</span><span class="token macro property">#<span class="token directive keyword">define</span> BUF_SIZE 8</span><span class="token macro property">#<span class="token directive keyword">ifdef</span> STR1</span><span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAAa\1\0\0\0"</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token macro property">#<span class="token directive keyword">ifdef</span> STR2</span><span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAAa\1\0\0\0BBBBBBBB"</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token macro property">#<span class="token directive keyword">ifdef</span> STR3</span><span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAAa\1\0\0\0BBBBBBBBCCCC"</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token macro property">#<span class="token directive keyword">ifdef</span> STR4</span><span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAAa\1\0\0\0BBBBBBBBCCCCDDDD"</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token macro property">#<span class="token directive keyword">ifndef</span> STR_SRC</span><span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAA"</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">define</span> OFFSET  40</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">get_ebp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">__asm__</span> <span class="token punctuation">(</span><span class="token string">"popl %eax;"</span>                                <span class="token string">"pushl %eax;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ebp<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">char</span> buffer<span class="token punctuation">[</span>BUF_SIZE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token string">'\0'</span><span class="token punctuation">,</span> BUF_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> STR_SRC<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>STR_SRC<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sum <span class="token operator">=</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>        <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>buffer<span class="token operator">+</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">=</span> ebp<span class="token punctuation">;</span>        <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>buffer<span class="token operator">+</span><span class="token number">24</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span>main<span class="token operator">+</span>OFFSET<span class="token punctuation">;</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> sum<span class="token punctuation">,</span> ebp<span class="token punctuation">;</span>        ebp <span class="token operator">=</span> <span class="token function">get_ebp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sum <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> ebp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sum = %d\n"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看看效果：</p><pre class="line-numbers language-bash"><code class="language-bash">$ gcc -D STR4 -o testshellcode testshellcode.c$ ./testshellcode<span class="token function">sum</span> <span class="token operator">=</span> 6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样，<code>EIP</code> 也得到了“保护”（这个方法很糟糕）。</p><p>类似地，如果再多复制一些内容呢？那么栈后面的内容都将被覆盖，即传递给 <code>func</code> 函数的参数都将被覆盖，因此上面的方法，包括所谓的对 <code>sum</code> 和 <code>ebp</code> 等值的保护都没有任何意义了。在这里，之所以提出类似这样的保护方法，实际上只是为了讨论一些有趣的细节并加深对缓冲区溢出这一问题的理解。</p><h3 id="缓冲区溢出检测"><a href="#缓冲区溢出检测" class="headerlink" title="缓冲区溢出检测"></a>缓冲区溢出检测</h3><p>要确实解决这类问题，从主观上讲，还得程序员来做相关的工作，比如限制将要复制的字符串的长度，保证它不超过当初申请的缓冲区的大小。</p><p>例如，在上面的代码中，我们在 <code>memcpy</code> 之前，可以加入一个判断，并且可以对缓冲区溢出进行很好的检查。如果能够设计一些比较好的测试实例把这些判断覆盖到，那么相关的问题就可以得到比较不错的检查了。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* testshellcode.c */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span>      </span><span class="token comment" spellcheck="true">/* printf */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span> </span><span class="token comment" spellcheck="true">/* memset, memcpy */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span>     </span><span class="token comment" spellcheck="true">/* exit */</span><span class="token macro property">#<span class="token directive keyword">define</span> BUF_SIZE 8</span><span class="token macro property">#<span class="token directive keyword">ifdef</span> STR4</span><span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAAa\1\0\0\0BBBBBBBBCCCCDDDD"</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token macro property">#<span class="token directive keyword">ifndef</span> STR_SRC</span><span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAA"</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">char</span> buffer<span class="token punctuation">[</span>BUF_SIZE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token string">'\0'</span><span class="token punctuation">,</span> BUF_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>STR_SRC<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">></span> BUF_SIZE <span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"buffer overflow!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> STR_SRC<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>STR_SRC<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sum <span class="token operator">=</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> sum<span class="token punctuation">;</span>        sum <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sum = %d\n"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在的效果如下：</p><pre><code>$ gcc -DSTR4 -g -o testshellcode testshellcode.c$ ./testshellcode      #如果存在溢出，那么就会得到阻止并退出，从而阻止可能的破坏buffer overflow!$ gcc -g -o testshellcode testshellcode.c$ ./testshellcodesum = 6</code></pre><p>当然，如果能够在 C 标准里头加入对数组操作的限制可能会更好，或者在编译器中扩展对可能引起缓冲区溢出的语法检查。</p><h2 id="缓冲区注入实例"><a href="#缓冲区注入实例" class="headerlink" title="缓冲区注入实例"></a>缓冲区注入实例</h2><p>最后给出一个利用上述缓冲区溢出来进行缓冲区注入的例子。也就是通过往某个缓冲区注入一些代码，并把eip修改为这些代码的入口从而达到破坏目标程序行为的目的。</p><p>这个例子来自<a href="http://www.ibm.com/developerworks/cn/linux/l-overflow/index.html">Linux 下缓冲区溢出攻击的原理及对策</a>，这里主要利用上面介绍的知识对它进行了比较详细的分析。</p><h3 id="准备：把-C-语言函数转换为字符串序列"><a href="#准备：把-C-语言函数转换为字符串序列" class="headerlink" title="准备：把 C 语言函数转换为字符串序列"></a>准备：把 C 语言函数转换为字符串序列</h3><p>首先回到第一部分，看看那个 <code>Shellcode.c</code> 程序。我们想获取它的汇编代码，并以十六进制字节的形式输出，以便把这些指令当字符串存放起来，从而作为缓冲区注入时的输入字符串。下面通过 <code>gdb</code> 获取这些内容。</p><pre class="line-numbers language-c"><code class="language-c">$ gcc <span class="token operator">-</span>g <span class="token operator">-</span>o shellcode shellcode<span class="token punctuation">.</span>c$ gdb <span class="token operator">-</span>q <span class="token punctuation">.</span><span class="token operator">/</span><span class="token function">shellcode</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> disassemble mainDump of assembler code <span class="token keyword">for</span> function main<span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">0x08048331</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">13</span><span class="token operator">></span><span class="token punctuation">:</span>   push   <span class="token operator">%</span>ecx<span class="token number">0x08048332</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">14</span><span class="token operator">></span><span class="token punctuation">:</span>   jmp    <span class="token number">0x8048354</span> <span class="token operator">&lt;</span>forward<span class="token operator">></span><span class="token number">0x08048334</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">16</span><span class="token operator">></span><span class="token punctuation">:</span>   pop    <span class="token operator">%</span>esi<span class="token number">0x08048335</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">17</span><span class="token operator">></span><span class="token punctuation">:</span>   mov    $<span class="token number">0x4</span><span class="token punctuation">,</span><span class="token operator">%</span>eax<span class="token number">0x0804833a</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">22</span><span class="token operator">></span><span class="token punctuation">:</span>   mov    $<span class="token number">0x2</span><span class="token punctuation">,</span><span class="token operator">%</span>ebx<span class="token number">0x0804833f</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">27</span><span class="token operator">></span><span class="token punctuation">:</span>   mov    <span class="token operator">%</span>esi<span class="token punctuation">,</span><span class="token operator">%</span>ecx<span class="token number">0x08048341</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">29</span><span class="token operator">></span><span class="token punctuation">:</span>   mov    $<span class="token number">0xc</span><span class="token punctuation">,</span><span class="token operator">%</span>edx<span class="token number">0x08048346</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">34</span><span class="token operator">></span><span class="token punctuation">:</span>   <span class="token keyword">int</span>    $<span class="token number">0x80</span><span class="token number">0x08048348</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">36</span><span class="token operator">></span><span class="token punctuation">:</span>   mov    $<span class="token number">0x1</span><span class="token punctuation">,</span><span class="token operator">%</span>eax<span class="token number">0x0804834d</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">41</span><span class="token operator">></span><span class="token punctuation">:</span>   mov    $<span class="token number">0x0</span><span class="token punctuation">,</span><span class="token operator">%</span>ebx<span class="token number">0x08048352</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">46</span><span class="token operator">></span><span class="token punctuation">:</span>   <span class="token keyword">int</span>    $<span class="token number">0x80</span><span class="token number">0x08048354</span> <span class="token operator">&lt;</span>forward<span class="token operator">+</span><span class="token number">0</span><span class="token operator">></span><span class="token punctuation">:</span> call   <span class="token number">0x8048334</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">16</span><span class="token operator">></span><span class="token number">0x08048359</span> <span class="token operator">&lt;</span>forward<span class="token operator">+</span><span class="token number">5</span><span class="token operator">></span><span class="token punctuation">:</span> dec    <span class="token operator">%</span>eax<span class="token number">0x0804835a</span> <span class="token operator">&lt;</span>forward<span class="token operator">+</span><span class="token number">6</span><span class="token operator">></span><span class="token punctuation">:</span> gs<span class="token number">0x0804835b</span> <span class="token operator">&lt;</span>forward<span class="token operator">+</span><span class="token number">7</span><span class="token operator">></span><span class="token punctuation">:</span> <span class="token function">insb</span>   <span class="token punctuation">(</span><span class="token operator">%</span>dx<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">%</span>es<span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token operator">%</span>edi<span class="token punctuation">)</span><span class="token number">0x0804835c</span> <span class="token operator">&lt;</span>forward<span class="token operator">+</span><span class="token number">8</span><span class="token operator">></span><span class="token punctuation">:</span> <span class="token function">insb</span>   <span class="token punctuation">(</span><span class="token operator">%</span>dx<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">%</span>es<span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token operator">%</span>edi<span class="token punctuation">)</span><span class="token number">0x0804835d</span> <span class="token operator">&lt;</span>forward<span class="token operator">+</span><span class="token number">9</span><span class="token operator">></span><span class="token punctuation">:</span> outsl  <span class="token operator">%</span>ds<span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token operator">%</span>esi<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">%</span>dx<span class="token punctuation">)</span><span class="token number">0x0804835e</span> <span class="token operator">&lt;</span>forward<span class="token operator">+</span><span class="token number">10</span><span class="token operator">></span><span class="token punctuation">:</span>        and    <span class="token operator">%</span>dl<span class="token punctuation">,</span><span class="token function">0x6f</span><span class="token punctuation">(</span><span class="token operator">%</span>edi<span class="token punctuation">)</span><span class="token number">0x08048361</span> <span class="token operator">&lt;</span>forward<span class="token operator">+</span><span class="token number">13</span><span class="token operator">></span><span class="token punctuation">:</span>        jb     <span class="token number">0x80483cf</span> <span class="token operator">&lt;</span>__libc_csu_init<span class="token operator">+</span><span class="token number">79</span><span class="token operator">></span><span class="token number">0x08048363</span> <span class="token operator">&lt;</span>forward<span class="token operator">+</span><span class="token number">15</span><span class="token operator">></span><span class="token punctuation">:</span>        or     <span class="token operator">%</span>fs<span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token operator">%</span>eax<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">%</span>al<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>End of assembler dump<span class="token punctuation">.</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> set logging on   #开启日志功能，记录操作结果Copying output to gdb<span class="token punctuation">.</span>txt<span class="token punctuation">.</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x<span class="token operator">/</span>52bx main<span class="token operator">+</span><span class="token number">14</span>  #以十六进制单字节（字符）方式打印出shellcode的核心代码<span class="token number">0x8048332</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">14</span><span class="token operator">></span><span class="token punctuation">:</span>    <span class="token number">0xeb</span>    <span class="token number">0x20</span>    <span class="token number">0x5e</span>    <span class="token number">0xb8</span>    <span class="token number">0x04</span>    <span class="token number">0x00</span>    <span class="token number">0x00</span>   <span class="token number">0x00</span><span class="token number">0x804833a</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">22</span><span class="token operator">></span><span class="token punctuation">:</span>    <span class="token number">0xbb</span>    <span class="token number">0x02</span>    <span class="token number">0x00</span>    <span class="token number">0x00</span>    <span class="token number">0x00</span>    <span class="token number">0x89</span>    <span class="token number">0xf1</span>   <span class="token number">0xba</span><span class="token number">0x8048342</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">30</span><span class="token operator">></span><span class="token punctuation">:</span>    <span class="token number">0x0c</span>    <span class="token number">0x00</span>    <span class="token number">0x00</span>    <span class="token number">0x00</span>    <span class="token number">0xcd</span>    <span class="token number">0x80</span>    <span class="token number">0xb8</span>   <span class="token number">0x01</span><span class="token number">0x804834a</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">38</span><span class="token operator">></span><span class="token punctuation">:</span>    <span class="token number">0x00</span>    <span class="token number">0x00</span>    <span class="token number">0x00</span>    <span class="token number">0xbb</span>    <span class="token number">0x00</span>    <span class="token number">0x00</span>    <span class="token number">0x00</span>   <span class="token number">0x00</span><span class="token number">0x8048352</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">46</span><span class="token operator">></span><span class="token punctuation">:</span>    <span class="token number">0xcd</span>    <span class="token number">0x80</span>    <span class="token number">0xe8</span>    <span class="token number">0xdb</span>    <span class="token number">0xff</span>    <span class="token number">0xff</span>    <span class="token number">0xff</span>   <span class="token number">0x48</span><span class="token number">0x804835a</span> <span class="token operator">&lt;</span>forward<span class="token operator">+</span><span class="token number">6</span><span class="token operator">></span><span class="token punctuation">:</span>  <span class="token number">0x65</span>    <span class="token number">0x6c</span>    <span class="token number">0x6c</span>    <span class="token number">0x6f</span>    <span class="token number">0x20</span>    <span class="token number">0x57</span>    <span class="token number">0x6f</span>   <span class="token number">0x72</span><span class="token number">0x8048362</span> <span class="token operator">&lt;</span>forward<span class="token operator">+</span><span class="token number">14</span><span class="token operator">></span><span class="token punctuation">:</span> <span class="token number">0x6c</span>    <span class="token number">0x64</span>    <span class="token number">0x0a</span>    <span class="token function">0x00</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> quit$ cat gdb<span class="token punctuation">.</span>txt <span class="token operator">|</span> sed <span class="token operator">-</span>e <span class="token string">"s/^.*://g;s/\t/\\\/g;s/^/\"/g;s/\$/\"/g"</span>  #把日志里头的内容处理一下，得到这样一个字符串<span class="token string">"\0xeb\0x20\0x5e\0xb8\0x04\0x00\0x00\0x00"</span><span class="token string">"\0xbb\0x02\0x00\0x00\0x00\0x89\0xf1\0xba"</span><span class="token string">"\0x0c\0x00\0x00\0x00\0xcd\0x80\0xb8\0x01"</span><span class="token string">"\0x00\0x00\0x00\0xbb\0x00\0x00\0x00\0x00"</span><span class="token string">"\0xcd\0x80\0xe8\0xdb\0xff\0xff\0xff\0x48"</span><span class="token string">"\0x65\0x6c\0x6c\0x6f\0x20\0x57\0x6f\0x72"</span><span class="token string">"\0x6c\0x64\0x0a\0x00"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="注入：在-C-语言中执行字符串化的代码"><a href="#注入：在-C-语言中执行字符串化的代码" class="headerlink" title="注入：在 C 语言中执行字符串化的代码"></a>注入：在 C 语言中执行字符串化的代码</h3><p>得到上面的字符串以后我们就可以设计一段下面的代码啦。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* testshellcode.c */</span><span class="token keyword">char</span> shellcode<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"\xeb\x20\x5e\xb8\x04\x00\x00\x00"</span><span class="token string">"\xbb\x02\x00\x00\x00\x89\xf1\xba"</span><span class="token string">"\x0c\x00\x00\x00\xcd\x80\xb8\x01"</span><span class="token string">"\x00\x00\x00\xbb\x00\x00\x00\x00"</span><span class="token string">"\xcd\x80\xe8\xdb\xff\xff\xff\x48"</span><span class="token string">"\x65\x6c\x6c\x6f\x20\x57\x6f\x72"</span><span class="token string">"\x6c\x64\x0a\x00"</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">callshellcode</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">int</span> <span class="token operator">*</span>ret<span class="token punctuation">;</span>   ret <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>ret <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>   <span class="token punctuation">(</span><span class="token operator">*</span>ret<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>shellcode<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">callshellcode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行看看，</p><pre class="line-numbers language-c"><code class="language-c">$ gcc <span class="token operator">-</span>o testshellcode testshellcode<span class="token punctuation">.</span>c$ <span class="token punctuation">.</span><span class="token operator">/</span>testshellcodeHello World<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>竟然打印出了 <code>Hello World</code>，实际上，如果只是为了让 <code>Shellcode</code> 执行，有更简单的办法，直接把 <code>Shellcode</code> 这个字符串入口强制转换为一个函数入口，并调用就可以，具体见这段代码。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">char</span> shellcode<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"\xeb\x20\x5e\xb8\x04\x00\x00\x00"</span><span class="token string">"\xbb\x02\x00\x00\x00\x89\xf1\xba"</span><span class="token string">"\x0c\x00\x00\x00\xcd\x80\xb8\x01"</span><span class="token string">"\x00\x00\x00\xbb\x00\x00\x00\x00"</span><span class="token string">"\xcd\x80\xe8\xdb\xff\xff\xff\x48"</span><span class="token string">"\x65\x6c\x6c\x6f\x20\x57\x6f\x72"</span><span class="token string">"\x6c\x64\x0a\x00"</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span> func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//定义一个指向函数的指针func，而函数的返回值和参数均为void</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token punctuation">(</span>func<span class="token punctuation">)</span>shellcode<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="注入原理分析"><a href="#注入原理分析" class="headerlink" title="注入原理分析"></a>注入原理分析</h3><p>这里不那样做，为什么也能够执行到 <code>Shellcode</code> 呢？仔细分析一下 <code>callShellcode</code> 里头的代码就可以得到原因了。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>ret<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里定义了一个指向整数的指针，<code>ret</code> 占用 4 个字节（可以用 <code>sizeof(int *)</code> 算出）。</p><pre class="line-numbers language-c"><code class="language-c">ret <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>ret <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里把 <code>ret</code> 修改为它本身所在的地址再加上两个单位。 首先需要求出 <code>ret</code> 本身所在的位置，因为 <code>ret</code> 是函数的一个局部变量，它在栈中偏栈顶的地方。 然后呢？再增加两个单位，这个单位是 <code>sizeof(int)</code>，即 4 个字节。这样，新的 <code>ret</code> 就是 <code>ret</code> 所在的位置加上 8 个字节，即往栈底方向偏移 8 个字节的位置。对于我们之前分析的 <code>Shellcode</code>，那里应该是 <code>edi</code>，但实际上这里并不是 <code>edi</code>，可能是 <code>gcc</code> 在编译程序时有不同的处理，这里实际上刚好是 <code>eip</code>，即执行这条语句之后 <code>ret</code> 的值变成了 <code>eip</code> 所在的位置。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token punctuation">(</span><span class="token operator">*</span>ret<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>shellcode<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于之前 <code>ret</code> 已经被修改为了 <code>eip</code> 所在的位置，这样对 <code>(*ret)</code> 赋值就会修改 <code>eip</code> 的值，即下一条指令的地址，这里把 <code>eip</code> 修改为了 <code>Shellcode</code> 的入口。因此，当函数返回时直接去执行 <code>Shellcode</code> 里头的代码，并打印了 <code>Hello World</code> 。</p><p>用 <code>gdb</code> 调试一下看看相关变量的值的情况。这里主要关心 <code>ret</code> 本身。 <code>ret</code> 本身是一个地址，首先它所在的位置变成了 <code>EIP</code> 所在的位置（把它自己所在的位置加上 <code>2*4</code> 以后赋于自己），然后，<code>EIP</code> 又指向了 <code>Shellcode</code> 处的代码。</p><pre class="line-numbers language-c"><code class="language-c">$ gcc <span class="token operator">-</span>g <span class="token operator">-</span>o testshellcode testshellcode<span class="token punctuation">.</span>c$ gdb <span class="token operator">-</span>q <span class="token punctuation">.</span><span class="token operator">/</span><span class="token function">testshellcode</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> l<span class="token number">8</span>       <span class="token keyword">void</span> <span class="token function">callshellcode</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token number">9</span>       <span class="token punctuation">{</span><span class="token number">10</span>         <span class="token keyword">int</span> <span class="token operator">*</span>ret<span class="token punctuation">;</span><span class="token number">11</span>         ret <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>ret <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token function">12</span>         <span class="token punctuation">(</span><span class="token operator">*</span>ret<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>shellcode<span class="token punctuation">;</span><span class="token number">13</span>      <span class="token punctuation">}</span><span class="token number">14</span><span class="token number">15</span>      <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">16</span>      <span class="token punctuation">{</span><span class="token number">17</span>              <span class="token function">callshellcode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> <span class="token keyword">break</span> <span class="token number">17</span>Breakpoint <span class="token number">1</span> at <span class="token number">0x804834d</span><span class="token punctuation">:</span> file testshell<span class="token punctuation">.</span>c<span class="token punctuation">,</span> line <span class="token number">17</span><span class="token punctuation">.</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> <span class="token keyword">break</span> <span class="token number">11</span>Breakpoint <span class="token number">2</span> at <span class="token number">0x804832a</span><span class="token punctuation">:</span> file testshell<span class="token punctuation">.</span>c<span class="token punctuation">,</span> line <span class="token number">11</span><span class="token punctuation">.</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> <span class="token keyword">break</span> <span class="token number">12</span>Breakpoint <span class="token number">3</span> at <span class="token number">0x8048333</span><span class="token punctuation">:</span> file testshell<span class="token punctuation">.</span>c<span class="token punctuation">,</span> line <span class="token number">12</span><span class="token punctuation">.</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> <span class="token keyword">break</span> <span class="token number">13</span>Breakpoint <span class="token number">4</span> at <span class="token number">0x804833d</span><span class="token punctuation">:</span> file testshell<span class="token punctuation">.</span>c<span class="token punctuation">,</span> line <span class="token number">13</span><span class="token punctuation">.</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> rStarting program<span class="token punctuation">:</span> <span class="token operator">/</span>mnt<span class="token operator">/</span>hda8<span class="token operator">/</span>Temp<span class="token operator">/</span>c<span class="token operator">/</span>program<span class="token operator">/</span>testshellBreakpoint <span class="token number">1</span><span class="token punctuation">,</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> at testshell<span class="token punctuation">.</span>c<span class="token punctuation">:</span><span class="token number">17</span><span class="token number">17</span>              <span class="token function">callshellcode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> print $ebp       #打印ebp寄存器里的值$<span class="token number">1</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">0xbfcfd2c8</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> disassemble main<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">0x0804834d</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">14</span><span class="token operator">></span><span class="token punctuation">:</span>   call   <span class="token number">0x8048324</span> <span class="token operator">&lt;</span>callshellcode<span class="token operator">></span><span class="token number">0x08048352</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">19</span><span class="token operator">></span><span class="token punctuation">:</span>   mov    $<span class="token number">0x0</span><span class="token punctuation">,</span><span class="token operator">%</span>eax<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> nBreakpoint <span class="token number">2</span><span class="token punctuation">,</span> <span class="token function">callshellcode</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> at testshell<span class="token punctuation">.</span>c<span class="token punctuation">:</span><span class="token number">11</span><span class="token number">11</span>         ret <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>ret <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x<span class="token operator">/</span>6x $esp<span class="token number">0xbfcfd2ac</span><span class="token punctuation">:</span>     <span class="token number">0x08048389</span>      <span class="token number">0xb7f4eff4</span>      <span class="token number">0xbfcfd36c</span>      <span class="token number">0xbfcfd2d8</span><span class="token number">0xbfcfd2bc</span><span class="token punctuation">:</span>     <span class="token number">0xbfcfd2c8</span>      <span class="token function">0x08048352</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> print <span class="token operator">&amp;</span>ret #分别打印出ret所在的地址和ret的值，刚好在ebp之上，我们发现这里并没有       #之前的testshellcode代码中的edi和esi，可能是gcc在汇编的时候有不同处理。$<span class="token number">2</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">0xbfcfd2b8</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> print ret$<span class="token number">3</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token number">0xbfcfd2d8</span> #这里的ret是个随机值<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> nBreakpoint <span class="token number">3</span><span class="token punctuation">,</span> <span class="token function">callshellcode</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> at testshell<span class="token punctuation">.</span>c<span class="token punctuation">:</span><span class="token number">12</span><span class="token function">12</span>         <span class="token punctuation">(</span><span class="token operator">*</span>ret<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>shellcode<span class="token punctuation">;</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> print ret   #执行完ret <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>ret <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>后，ret变成了自己地址加上<span class="token number">2</span><span class="token operator">*</span><span class="token number">4</span>，                  #刚好是eip所在的位置。$<span class="token number">5</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">0xbfcfd2c0</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x<span class="token operator">/</span>6x $esp<span class="token number">0xbfcfd2ac</span><span class="token punctuation">:</span>     <span class="token number">0x08048389</span>      <span class="token number">0xb7f4eff4</span>      <span class="token number">0xbfcfd36c</span>      <span class="token number">0xbfcfd2c0</span><span class="token number">0xbfcfd2bc</span><span class="token punctuation">:</span>     <span class="token number">0xbfcfd2c8</span>      <span class="token function">0x08048352</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x<span class="token operator">/</span>4x <span class="token operator">*</span>ret  #此时<span class="token operator">*</span>ret刚好为eip，<span class="token number">0x8048352</span><span class="token number">0x8048352</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">19</span><span class="token operator">></span><span class="token punctuation">:</span>    <span class="token number">0x000000b8</span>      <span class="token number">0x8d5d5900</span>      <span class="token number">0x90c3fc61</span>      <span class="token function">0x89559090</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> nBreakpoint <span class="token number">4</span><span class="token punctuation">,</span> <span class="token function">callshellcode</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> at testshell<span class="token punctuation">.</span>c<span class="token punctuation">:</span><span class="token number">13</span><span class="token number">13</span>      <span class="token punctuation">}</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x<span class="token operator">/</span>6x $esp #现在eip被修改为了shellcode的入口<span class="token number">0xbfcfd2ac</span><span class="token punctuation">:</span>     <span class="token number">0x08048389</span>      <span class="token number">0xb7f4eff4</span>      <span class="token number">0xbfcfd36c</span>      <span class="token number">0xbfcfd2c0</span><span class="token number">0xbfcfd2bc</span><span class="token punctuation">:</span>     <span class="token number">0xbfcfd2c8</span>      <span class="token function">0x8049560</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x<span class="token operator">/</span>4x <span class="token operator">*</span>ret  #现在修改了<span class="token punctuation">(</span><span class="token operator">*</span>ret<span class="token punctuation">)</span>的值，即修改了eip的值，使eip指向了shellcode<span class="token number">0x8049560</span> <span class="token operator">&lt;</span>shellcode<span class="token operator">></span><span class="token punctuation">:</span>  <span class="token number">0xb85e20eb</span>      <span class="token number">0x00000004</span>      <span class="token number">0x000002bb</span>      <span class="token number">0xbaf18900</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的过程很难弄，呵呵。主要是指针不大好理解，如果直接把它当地址绘出下面的图可能会容易理解一些。</p><p>callshellcode栈的初始分布：</p><pre class="line-numbers language-c"><code class="language-c">ret<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>ret<span class="token operator">+</span><span class="token number">2</span><span class="token operator">=</span><span class="token number">0xbfcfd2bc</span><span class="token operator">+</span><span class="token number">2</span><span class="token operator">*</span><span class="token number">4</span><span class="token operator">=</span><span class="token number">0xbfcfd2c0</span><span class="token number">0xbfcfd2b8</span>      <span class="token function">ret</span><span class="token punctuation">(</span>随机值<span class="token punctuation">)</span>                     <span class="token number">0xbfcfd2c0</span><span class="token number">0xbfcfd2bc</span>      <span class="token function">ebp</span><span class="token punctuation">(</span>这里不关心<span class="token punctuation">)</span><span class="token number">0xbfcfd2c0</span>      <span class="token function">eip</span><span class="token punctuation">(</span><span class="token number">0x08048352</span><span class="token punctuation">)</span>         <span class="token function">eip</span><span class="token punctuation">(</span><span class="token number">0x8049560</span> <span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span>ret<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>shellcode<span class="token punctuation">;</span>即eip<span class="token operator">=</span><span class="token number">0x8049560</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总之，最后体现为函数调用的下一条指令指针（<code>eip</code>）被修改为一段注入代码的入口，从而使得函数返回时执行了注入代码。</p><h3 id="缓冲区注入与防范"><a href="#缓冲区注入与防范" class="headerlink" title="缓冲区注入与防范"></a>缓冲区注入与防范</h3><p>这个程序里头的注入代码和被注入程序竟然是一个程序，傻瓜才自己攻击自己（不过有些黑客有可能利用程序中一些空闲空间注入代码哦），真正的缓冲区注入程序是分开的，比如作为被注入程序的一个字符串参数。而在被注入程序中刚好没有做字符串长度的限制，从而让这段字符串中的一部分修改了 <code>eip</code>，另外一部分作为注入代码运行了，从而实现了注入的目的。不过这会涉及到一些技巧，即如何刚好用注入代码的入口地址来修改 <code>eip</code> （即新的 <code>eip</code> 能够指向注入代码）？如果 <code>eip</code> 的位置和缓冲区的位置之间的距离是确定，那么就比较好处理了，但从上面的两个例子中我们发现，有一个编译后有 <code>edi</code> 和 <code>esi</code>，而另外一个则没有，另外，缓冲区的位置，以及被注入程序有多少个参数我们都无法预知，因此，如何计算 <code>eip</code> 所在的位置呢？这也会很难确定。还有，为了防止缓冲区溢出带来的注入问题，现在的操作系统采取了一些办法，比如让 <code>esp</code> 随机变化（比如和系统时钟关联起来），所以这些措施将导致注入更加困难。如果有兴趣，你可以接着看看最后的几篇参考资料并进行更深入的研究。</p><p>需要提到的是，因为很多程序可能使用 <code>strcpy</code> 来进行字符串的复制，在实际编写缓冲区注入代码时，会采取一定的办法（指令替换），把代码中可能包含的 <code>\0</code> 字节去掉，从而防止 <code>strcpy</code> 中断对注入代码的复制，进而可以复制完整的注入代码。具体的技巧可以参考 <a href="http://www.ibm.com/developerworks/cn/linux/l-overflow/index.html">Linux下缓冲区溢出攻击的原理及对策</a>，<a href="http://janxin.bokee.com/4067220.html">Shellcode技术杂谈</a>，<a href="http://virus.bartolich.at/virus-writing-HOWTO/_html/">virus-writing-HOWTO</a>。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>实际上缓冲区溢出应该是语法和逻辑方面的双重问题，由于语法上的不严格（对数组边界没有检查）导致逻辑上可能出现严重缺陷（程序执行行为被改变）。另外，这类问题是对程序运行过程中的程序映像的栈区进行注入。实际上除此之外，程序在安全方面还有很多类似的问题。比如，虽然程序映像的正文区受到系统保护（只读），但是如果内存（硬件本身，内存条）出现故障，在程序运行的过程中，程序映像的正文区的某些字节就可能被修改了，也可能发生非常严重的后果，因此程序运行过程的正文区检查等可能的手段需要被引入。</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> C </tag>
            
            <tag> 编程透视 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态符号链接的细节</title>
      <link href="posts/59293/"/>
      <url>posts/59293/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Linux 支持动态链接库，不仅节省了磁盘、内存空间，而且可以提高程序运行效率。不过引入动态链接库也可能会带来很多问题，例如动态链接库的调试、升级更新和潜在的安全威胁。这里主要讨论符号的动态链接过程，即程序在执行过程中，对其中包含的一些未确定地址的符号进行重定位的过程。</p><p>下面先来看看几个基本概念，接着就介绍动态链接库的创建、隐式和显示调用，最后介绍符号的动态链接细节。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="ELF"><a href="#ELF" class="headerlink" title="ELF"></a>ELF</h3><p><code>ELF</code> 是 Linux 支持的一种程序文件格式，本身包含重定位、执行、共享（动态链接库）三种类型（<code>man elf</code>）。</p><p>代码：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* test.c */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span>    </span><span class="token keyword">int</span> global <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">char</span> local <span class="token operator">=</span> <span class="token string">'A'</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"local = %c, global = %d\n"</span><span class="token punctuation">,</span> local<span class="token punctuation">,</span> global<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>演示：</p><p>通过 <code>-c</code> 生成可重定位文件 <code>test.o</code>，这里不会进行链接：</p><pre class="line-numbers language-bash"><code class="language-bash">$ gcc -c test.c$ <span class="token function">file</span> test.otest.o: ELF 32-bit LSB relocatable, Intel 80386, version 1 <span class="token punctuation">(</span>SYSV<span class="token punctuation">)</span>, not stripped<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>链接后才可以执行：</p><pre class="line-numbers language-bash"><code class="language-bash">$ gcc -o <span class="token function">test</span> test.o$ <span class="token function">file</span> <span class="token function">test</span>test: ELF 32-bit LSB executable, Intel 80386, version 1 <span class="token punctuation">(</span>SYSV<span class="token punctuation">)</span>, dynamically linked <span class="token punctuation">(</span>uses shared libs<span class="token punctuation">)</span>, not stripped<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>也可链接成动态链接库，不过一般不会把 <code>main</code> 函数链接成动态链接库，后面再介绍：</p><pre class="line-numbers language-bash"><code class="language-bash">$ gcc -fpic -shared -Wl,-soname,libtest.so.0 -o libtest.so.0.0 test.o$ <span class="token function">file</span> libtest.so.0.0libtest.so.0.0: ELF 32-bit LSB shared object, Intel 80386, version 1 <span class="token punctuation">(</span>SYSV<span class="token punctuation">)</span>, not stripped<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>虽然 <code>ELF</code> 文件本身就支持三种不同的类型，不过它有一个统一的结构。这个结构是：</p><pre><code>文件头部(ELF Header)程序头部表(Program Header Table)节区1(Section1)节区2(Section2)节区3(Section3)...节区头部表(Section Header Table)</code></pre><p>无论是文件头部、程序头部表、节区头部表，还是节区，它们都对应着 C 语言里头的一些结构体（<code>elf.h</code> 中定义）。文件头部主要描述 <code>ELF</code> 文件的类型，大小，运行平台，以及和程序头部表和节区头部表相关的信息。节区头部表则用于可重定位文件，以便描述各个节区的信息，这些信息包括节区的名字、类型、大小等。程序头部表则用于描述可执行文件或者动态链接库，以便系统加载和执行它们。而节区主要存放各种特定类型的信息，比如程序的正文区（代码）、数据区（初始化和未初始化的数据）、调试信息、以及用于动态链接的一些节区，比如解释器（<code>.interp</code>）节区将指定程序动态装载 <code>/</code> 链接器 <code>ld-linux.so</code> 的位置，而过程链接表（<code>plt</code>）、全局偏移表（<code>got</code>）、重定位表则用于辅助动态链接过程。</p><h3 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h3><p>对于可执行文件除了编译器引入的一些符号外，主要就是用户自定义的全局变量，函数等，而对于可重定位文件仅仅包含用户自定义的一些符号。</p><ul><li><p>生成可重定位文件</p><pre><code>  $ gcc -c test.c  $ nm test.o  00000000 B global  00000000 T main           U printf</code></pre><p>上面包含全局变量、自定义函数以及动态链接库中的函数，但不包含局部变量，而且发现这三个符号的地址都没有确定。</p><p>注： <code>nm</code> 命令可用来查看 <code>ELF</code> 文件的符号表信息。</p></li><li><p>生成可执行文件</p></li></ul><pre><code>    $ gcc -o test test.o    $ nm test | egrep &quot;main$| printf|global$&quot;    080495a0 B global    08048354 T main             U printf@@GLIBC_2.0经链接，`global` 和 `main` 的地址都已经确定了，但是 `printf` 却还没，因为它是动态链接库 `glibc` 中定义函数，需要动态链接，而不是这里的“静态”链接。</code></pre><h3 id="重定位：是将符号引用与符号定义进行链接的过程"><a href="#重定位：是将符号引用与符号定义进行链接的过程" class="headerlink" title="重定位：是将符号引用与符号定义进行链接的过程"></a>重定位：是将符号引用与符号定义进行链接的过程</h3><p>从上面的演示可以看出，重定位文件 <code>test.o</code> 中的符号地址都是没有确定的，而经过静态链接（<code>gcc</code> 默认调用 <code>ld</code> 进行链接）以后有两个符号地址已经确定了，这样一个确定符号地址的过程实际上就是链接的实质。链接过后，对符号的引用变成了对地址（定义符号时确定该地址）的引用，这样程序运行时就可通过访问内存地址而访问特定的数据。</p><p>我们也注意到符号 <code>printf</code> 在可重定位文件和可执行文件中的地址都没有确定，这意味着该符号是一个外部符号，可能定义在动态链接库中，在程序运行时需要通过动态链接器（<code>ld-linux.so</code>）进行重定位，即动态链接。</p><p>通过这个演示可以看出 <code>printf</code> 确实在 <code>glibc</code> 中有定义。</p><pre class="line-numbers language-bash"><code class="language-bash">$ nm -D /lib/<span class="token variable"><span class="token variable">`</span><span class="token function">uname</span> -m<span class="token variable">`</span></span>-linux-gnu/libc.so.6 <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"\ printf$"</span>0000000000053840 T <span class="token function">printf</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>除了 <code>nm</code> 以外，还可以用 <code>readelf -s</code> 查看 <code>.dynsym</code> 表或者用 <code>objdump -tT</code> 查看。</p><p>需要提到的是，用 <code>nm</code> 命令不带 <code>-D</code> 参数的话，在较新的系统上已经没有办法查看 <code>libc.so</code> 的符号表了，因为 <code>nm</code> 默认打印常规符号表（在 <code>.symtab</code> 和 <code>.strtab</code> 节区中），但是，在打包时为了减少系统大小，这些符号已经被 <code>strip</code> 掉了，只保留了动态符号（在 <code>.dynsym</code> 和 <code>.dynstr</code> 中）以便动态链接器在执行程序时寻址这些外部用到的符号。而常规符号除了动态符号以外，还包含有一些静态符号，比如说本地函数，这个信息主要是调试器会用，对于正常部署的系统，一般会用 <code>strip</code> 工具删除掉。</p><p>关于 <code>nm</code> 与 <code>readelf -s</code> 的详细比较，可参考：<a href="http://stackoverflow.com/questions/9961473/nm-vs-readelf-s">nm vs “readelf -s”</a>。</p><h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>动态链接就是在程序运行时对符号进行重定位，确定符号对应的内存地址的过程。</p><p>Linux 下符号的动态链接默认采用 Lazy Mode 方式，也就是说在程序运行过程中用到该符号时才去解析它的地址。这样一种符号解析方式有一个好处：只解析那些用到的符号，而对那些不用的符号则永远不用解析，从而提高程序的执行效率。</p><p>不过这种默认是可以通过设置 <code>LD_BIND_NOW</code> 为非空来打破的（下面会通过实例来分析这个变量的作用），也就是说如果设置了这个变量，动态链接器将在程序加载后和符号被使用之前就对这些符号的地址进行解析。’’</p><h3 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h3><p>上面提到重定位的过程就是对符号引用和符号地址进行链接的过程，而动态链接过程涉及到的符号引用和符号定义分别对应可执行文件和动态链接库，在可执行文件中可能引用了某些动态链接库中定义的符号，这类符号通常是函数。</p><p>为了让动态链接器能够进行符号的重定位，必须把动态链接库的相关信息写入到可执行文件当中，这些信息是什么呢？</p><pre class="line-numbers language-bash"><code class="language-bash">$ readelf -d <span class="token function">test</span> <span class="token operator">|</span> <span class="token function">grep</span> NEEDED 0x00000001 <span class="token punctuation">(</span>NEEDED<span class="token punctuation">)</span>                     Shared library: <span class="token punctuation">[</span>libc.so.6<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>ELF</code> 文件有一个特别的节区： <code>.dynamic</code>，它存放了和动态链接相关的很多信息，例如动态链接器通过它找到该文件使用的动态链接库。不过，该信息并未包含动态链接库 <code>libc.so.6</code> 的绝对路径，那动态链接器去哪里查找相应的库呢？</p><p>通过 <code>LD_LIBRARY_PATH</code> 参数，它类似 Shell 解释器中用于查找可执行文件的 <code>PATH</code> 环境变量，也是通过冒号分开指定了各个存放库函数的路径。该变量实际上也可以通过 <code>/etc/ld.so.conf</code> 文件来指定，一行对应一个路径名。为了提高查找和加载动态链接库的效率，系统启动后会通过 <code>ldconfig</code> 工具创建一个库的缓存 <code>/etc/ld.so.cache</code> 。如果用户通过 <code>/etc/ld.so.conf</code> 加入了新的库搜索路径或者是把新库加到某个原有的库目录下，最好是执行一下 <code>ldconfig</code> 以便刷新缓存。</p><p>需要补充的是，因为动态链接库本身还可能引用其他的库，那么一个可执行文件的动态符号链接过程可能涉及到多个库，通过 <code>readelf -d</code> 可以打印出该文件直接依赖的库，而通过 <code>ldd</code> 命令则可以打印出所有依赖或者间接依赖的库。</p><pre><code>$ ldd test        linux-gate.so.1 =&gt;  (0xffffe000)        libc.so.6 =&gt; /lib/libc.so.6 (0xb7da2000)        /lib/ld-linux.so.2 (0xb7efc000)</code></pre><p><code>libc.so.6</code> 通过 <code>readelf -d</code> 就可以看到的，是直接依赖的库；而 <code>linux-gate.so.1</code> 在文件系统中并没有对应的库文件，它是一个虚拟的动态链接库，对应进程内存映像的内核部分; 而 <code>/lib/ld-linux.so.2</code> 正好是动态链接器，系统需要用它来进行符号重定位。那 <code>ldd</code> 是怎么知道 <code>/lib/ld-linux.so</code> 就是该文件的动态链接器呢？</p><p>那是因为 <code>ELF</code> 文件通过专门的节区指定了动态链接器，这个节区就是 <code>.interp</code> 。</p><pre><code>$ readelf -x .interp testHex dump of section &#39;.interp&#39;:  0x08048114 2f6c6962 2f6c642d 6c696e75 782e736f /lib/ld-linux.so  0x08048124 2e3200                              .2.</code></pre><p>可以看到这个节区刚好有字符串 <code>/lib/ld-linux.so.2</code>，即 <code>ld-linux.so</code> 的绝对路径。</p><p>我们发现，与 <code>libc.so</code> 不同的是，<code>ld-linux.so</code> 的路径是绝对路径，而 <code>libc.so</code> 仅仅包含了文件名。原因是：程序被执行时，<code>ld-linux.so</code> 将最先被装载到内存中，没有其他程序知道去哪里查找 <code>ld-linux.so</code>，所以它的路径必须是绝对的；当 <code>ld-linux.so</code> 被装载以后，由它来去装载可执行文件和相关的共享库，它将根据 <code>PATH</code> 变量和 <code>LD_LIBRARY_PATH</code> 变量去磁盘上查找它们，因此可执行文件和共享库都可以不指定绝对路径。</p><p>下面着重介绍动态链接器本身。</p><h3 id="动态链接器（dynamic-linker-loader）"><a href="#动态链接器（dynamic-linker-loader）" class="headerlink" title="动态链接器（dynamic linker/loader）"></a>动态链接器（dynamic linker/loader）</h3><p>Linux 下 <code>elf</code> 文件的动态链接器是 <code>ld-linux.so</code>，即 <code>/lib/ld-linux.so.2</code> 。从名字来看和静态链接器 <code>ld</code>类似。通过 <code>man ld-linux</code> 可以获取与动态链接器相关的资料，包括各种相关的环境变量和文件都有详细的说明。</p><p>对于环境变量，除了上面提到过的 <code>LD_LIBRARY_PATH</code> 和 <code>LD_BIND_NOW</code> 变量外，还有其他几个重要参数，比如 <code>LD_PRELOAD</code> 用于指定预装载一些库，以便替换其他库中的函数，从而做一些安全方面的处理，而环境变量 <code>LD_DEBUG</code> 可以用来进行动态链接的相关调试。</p><p>对于文件，除了上面提到的 <code>ld.so.conf</code> 和 <code>ld.so.cache</code> 外，还有一个文件 <code>/etc/ld.so.preload</code> 用于指定需要预装载的库。</p><p>从上一小节中发现有一个专门的节区 <code>.interp</code> 存放有动态链接器，但是这个节区为什么叫做 <code>.interp</code> （<code>interpeter</code>）呢？因为当 Shell 解释器或者其他父进程通过 <code>exec</code> 启动我们的程序时，系统会先为 <code>ld-linux</code> 创建内存映像，然后把控制权交给 <code>ld-linux</code>，之后 <code>ld-linux</code> 负责为可执行程序提供运行环境，负责解释程序的运行，因此 <code>ld-linux</code> 也叫做 <code>dynamic loader</code> （或 <code>intepreter</code>）</p><p>那么在 <code>exec</code> （）之后和程序指令运行之前的过程是怎样的呢？ <code>ld-linux.so</code> 主要为程序本身创建了内存映像，大体过程如下：</p><ol><li>将可执行文件的内存段添加到进程映像中；</li><li>把共享目标内存段添加到进程映像中；</li><li>为可执行文件和它的共享目标（动态链接库）执行重定位操作；</li><li>关闭用来读入可执行文件的文件描述符，如果动态链接程序收到过这样的文件描述符的话；</li><li>将控制转交给程序，使得程序好像从 <code>exec()</code> 直接得到控制</li></ol><p>关于第 1 步，在 <code>ELF</code> 文件的文件头中就指定了该文件的入口地址，程序的代码和数据部分会相继 <code>map</code> 到对应的内存中。而关于可执行文件本身的路径，如果指定了 <code>PATH</code> 环境变量，<code>ld-linux</code> 会到 <code>PATH</code> 指定的相关目录下查找。</p><pre><code>$ readelf -h test | grep Entry  Entry point address:               0x80482b0</code></pre><p>对于第 2 步，上一节提到的 <code>.dynamic</code> 节区指定了可执行文件依赖的库名，<code>ld-linux</code> （在这里叫做动态装载器或程序解释器比较合适）再从 <code>LD_LIBRARY_PATH</code> 指定的路径中找到相关的库文件或者直接从 <code>/etc/ld.so.cache</code> 库缓冲中加载相关库到内存中。</p><p>对于第 3 步，在前面已提到，如果设置了 <code>LD_BIND_NOW</code> 环境变量，这个动作就会在此时发生，否则将会采用 <code>lazy mode</code> 方式，即当某个符号被使用时才会进行符号的重定位。不过无论在什么时候发生这个动作，重定位的过程大体是一样的（在后面将主要介绍该过程）。</p><p>对于第 4 步，这个主要是释放文件描述符。</p><p>对于第 5 步，动态链接器把程序控制权交还给程序。</p><p>现在关心的主要是第 3 步，即如何进行符号的重定位？下面来探求这个过程。期间会逐步讨论到和动态链接密切相关的三个数据结构，它们分别是 <code>ELF</code> 文件的过程链接表、全局偏移表和重定位表，这三个表都是 <code>ELF</code> 文件的节区。</p><h3 id="过程链接表（plt）"><a href="#过程链接表（plt）" class="headerlink" title="过程链接表（plt）"></a>过程链接表（plt）</h3><p>从上面的演示发现，还有一个 <code>printf</code> 符号的地址没有确定，它应该在动态链接库 <code>libc.so</code> 中定义，需要进行动态链接。这里假设采用 <code>lazy mode</code> 方式，即执行到 <code>printf</code> 所在位置时才去解析该符号的地址。</p><p>假设当前已经执行到了 <code>printf</code> 所在位置，即 <code>call printf</code>，我们通过 <code>objdump</code> 反编译 <code>test</code> 程序的正文段看看。</p><pre><code>$ objdump -d -s -j .text test | grep printf 804837c:       e8 1f ff ff ff          call   80482a0 &lt;printf@plt&gt;</code></pre><p>发现，该地址指向了 <code>plt</code> （即过程链接表）即地址 <code>80482a0</code> 处。下面查看该地址处的内容。</p><pre><code>$ objdump -D test | grep &quot;80482a0&quot; | grep -v call080482a0 &lt;printf@plt&gt;: 80482a0:       ff 25 8c 95 04 08       jmp    *0x804958c</code></pre><p>发现 <code>80482a0</code> 地址对应的是一条跳转指令，跳转到 <code>0x804958c</code> 地址指向的地址。到底 <code>0x804958c</code> 地址本身在什么地方呢？我们能否从 <code>.dynamic</code> 节区（该节区存放了和动态链接相关的数据）获取相关的信息呢？</p><pre><code>$ readelf -d testDynamic section at offset 0x4ac contains 20 entries:  Tag        Type                         Name/Value 0x00000001 (NEEDED)                     Shared library: [libc.so.6] 0x0000000c (INIT)                       0x8048258 0x0000000d (FINI)                       0x8048454 0x00000004 (HASH)                       0x8048148 0x00000005 (STRTAB)                     0x80481c0 0x00000006 (SYMTAB)                     0x8048170 0x0000000a (STRSZ)                      76 (bytes) 0x0000000b (SYMENT)                     16 (bytes) 0x00000015 (DEBUG)                      0x0 0x00000003 (PLTGOT)                     0x8049578 0x00000002 (PLTRELSZ)                   24 (bytes) 0x00000014 (PLTREL)                     REL 0x00000017 (JMPREL)                     0x8048240 0x00000011 (REL)                        0x8048238 0x00000012 (RELSZ)                      8 (bytes) 0x00000013 (RELENT)                     8 (bytes) 0x6ffffffe (VERNEED)                    0x8048218 0x6fffffff (VERNEEDNUM)                 1 0x6ffffff0 (VERSYM)                     0x804820c 0x00000000 (NULL)                       0x0</code></pre><p>发现 <code>0x8049578</code> 地址和 <code>0x804958c</code> 地址比较近，前者正好是 <code>.got.plt</code> （即过程链接表）对应的全局偏移表的入口地址。难道 <code>0x804958c</code> 正好位于 <code>.got.plt</code> 节区中？</p><h3 id="全局偏移表（got）"><a href="#全局偏移表（got）" class="headerlink" title="全局偏移表（got）"></a>全局偏移表（got）</h3><p>现在进入全局偏移表看看，</p><pre><code>$ readelf -x .got.plt testHex dump of section &#39;.got.plt&#39;:  0x08049578 ac940408 00000000 00000000 86820408 ................  0x08049588 96820408 a6820408                   ........</code></pre><p>从上述结果可以看出 <code>0x804958c</code> 地址（即 <code>0x08049588+4</code>）处存放的是 <code>a6820408</code>，考虑到我的实验平台是 <code>i386</code>，字节顺序是 <code>little-endian</code> 的，所以实际数值应该是 <code>080482a6</code>，也就是说 <code>*(0x804958c)</code> 的值是 <code>080482a6</code>，这个地址刚好是过程链接表的最后一项 <code>call 80482a0&lt;printf@plt&gt;</code> 中 <code>80482a0</code> 地址往后偏移 <code>6</code> 个字节，容易猜到该地址应该就是 <code>jmp</code> 指令的后一条地址。</p><pre><code>$ objdump -d -d -s -j .plt test |  grep &quot;080482a0 &lt;printf@plt&gt;:&quot; -A 3080482a0 &lt;printf@plt&gt;: 80482a0:       ff 25 8c 95 04 08       jmp    *0x804958c 80482a6:       68 10 00 00 00          push   $0x10 80482ab:       e9 c0 ff ff ff          jmp    8048270 &lt;_init+0x18&gt;</code></pre><p><code>80482a6</code> 地址恰巧是一条 <code>push</code> 指令，随后是一条 <code>jmp</code> 指令（暂且不管 <code>push</code> 指令入栈的内容有什么意义），执行完 <code>push</code> 指令之后，就会跳转到 <code>8048270</code> 地址处，下面看看 <code>8048270</code> 地址处到底有哪些指令。</p><pre><code>$ objdump -d -d -s -j .plt test | grep -v &quot;jmp    8048270 &lt;_init+0x18&gt;&quot; | grep &quot;08048270&quot; -A 208048270 &lt;__gmon_start__@plt-0x10&gt;: 8048270:       ff 35 7c 95 04 08       pushl  0x804957c 8048276:       ff 25 80 95 04 08       jmp    *0x8049580</code></pre><p>同样是一条入栈指令跟着一条跳转指令。不过这两个地址 <code>0x804957c</code> 和 <code>0x8049580</code> 是连续的，而且都很熟悉，刚好都在 <code>.got.plt</code> 表里头（从上面我们已经知道 <code>.got.plt</code> 的入口是 <code>0x08049578</code>）。这样的话，我们得确认这两个地址到底有什么内容。</p><pre><code>$ readelf -x .got.plt testHex dump of section &#39;.got.plt&#39;:  0x08049578 ac940408 00000000 00000000 86820408 ................  0x08049588 96820408 a6820408                   ........</code></pre><p>不过，遗憾的是通过 <code>readelf</code> 查看到的这两个地址信息都是 0，它们到底是什么呢？</p><ul><li>在程序第一次创建内存映像时，动态链接器为全局偏移表的第二（<code>0x804957c</code>）和第三项（<code>0x8049580</code>）设置特殊值。</li><li>原步骤 5。在跳转到 <code>08048270 &lt;__gmon_start__@plt-0x10&gt;</code>，即过程链接表的第一项之前，有一条压入栈指令，即 <code>push $0x10</code>，<code>0x10</code> 是相对于重定位表起始地址的一个偏移地址，这个偏移地址到底有什么用呢？它应该是提供给动态链接器的什么信息吧？后面再说明。</li><li>原步骤 6。跳转到过程链接表的第一项之后，压入了全局偏移表中的第二项（即 <code>0x804957c</code> 处），“为动态链接器提供了识别信息的机会”（具体是什么呢？后面会简单提到，但这个并不是很重要)，然后跳转到全局偏移表的第三项（<code>0x8049580</code>，这一项比较重要），把控制权交给动态链接器。</li></ul><p>从这三步发现程序运行时地址 <code>0x8049580</code> 处存放的应该是动态链接器的入口地址，而重定位表 <code>0x10</code> 位置处和 <code>0x804957c</code> 处应该为动态链接器提供了解析符号需要的某些信息。</p><p>在继续之前先总结一下过程链接表和全局偏移表。上面的操作过程仅仅从“局部”看过了这两个表，但是并没有宏观地看里头的内容。下面将宏观的分析一下， 对于过程链接表：</p><pre><code>$ objdump -d -d -s -j .plt test08048270 &lt;__gmon_start__@plt-0x10&gt;: 8048270:       ff 35 7c 95 04 08       pushl  0x804957c 8048276:       ff 25 80 95 04 08       jmp    *0x8049580 804827c:       00 00                   add    %al,(%eax)        ...08048280 &lt;__gmon_start__@plt&gt;: 8048280:       ff 25 84 95 04 08       jmp    *0x8049584 8048286:       68 00 00 00 00          push   $0x0 804828b:       e9 e0 ff ff ff          jmp    8048270 &lt;_init+0x18&gt;08048290 &lt;__libc_start_main@plt&gt;: 8048290:       ff 25 88 95 04 08       jmp    *0x8049588 8048296:       68 08 00 00 00          push   $0x8 804829b:       e9 d0 ff ff ff          jmp    8048270 &lt;_init+0x18&gt;080482a0 &lt;printf@plt&gt;: 80482a0:       ff 25 8c 95 04 08       jmp    *0x804958c 80482a6:       68 10 00 00 00          push   $0x10 80482ab:       e9 c0 ff ff ff          jmp    8048270 &lt;_init+0x18&gt;</code></pre><p>除了该表中的第一项外，其他各项实际上是类似的。而最后一项 <code>080482a0 &lt;printf@plt&gt;</code> 和第一项我们都分析过，因此不难理解其他几项的作用。过程链接表没有办法单独工作，因为它和全局偏移表是关联的，所以在说明它的作用之前，先从总体上来看一下全局偏移表。</p><pre><code>$ readelf -x .got.plt testHex dump of section &#39;.got.plt&#39;:  0x08049578 ac940408 00000000 00000000 86820408 ................  0x08049588 96820408 a6820408                   ........</code></pre><p>比较全局偏移表中 <code>0x08049584</code> 处开始的数据和过程链接表第二项开始的连续三项中 <code>push</code> 指定所在的地址，不难发现，它们是对应的。而 <code>0x0804958c</code> 即 <code>push 0x10</code> 对应的地址我们刚才提到过（下一节会进一步分析），其他几项的作用类似，都是跳回到过程链接表的 <code>push</code> 指令处，随后就跳转到过程链接表的第一项，以便解析相应的符号（实际上过程链接表的第一个表项是进入动态链接器，而之前的连续两个指令则传送了需要解析的符号等信息）。另外 <code>0x08049578</code> 和 <code>0x08049580</code> 处分别存放有传递给动态链接库的相关信息和动态链接器本身的入口地址。但是还有一个地址 <code>0x08049578</code>，这个地址刚好是 <code>.dynamic</code> 的入口地址，该节区存放了和动态链接过程相关的信息，这个表项实际上保留给动态链接器自己使用的，以便在不依赖其他程序的情况下对自己进行初始化，所以下面将不再关注该表项。</p><pre><code>$ objdump -D test | grep 080494ac080494ac &lt;_DYNAMIC&gt;:</code></pre><h3 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h3><p>这里主要接着上面的 <code>push 0x10</code> 指令来分析。重定位表包含如何修改其他节区的信息，以便动态链接器对某些节区内的符号地址进行重定位（修改为新的地址）。那到底重定位表项提供了什么样的信息呢？</p><ul><li>每一个重定位项有三部分内容，我们重点关注前两部分。</li><li>第一部分是 <code>r_offset</code>，这里考虑的是可执行文件，因此根据资料发现，它的取值是被重定位影响（可以说改变或修改）到的存储单元的虚拟地址。</li><li>第二部分是 <code>r_info</code>，此成员给出要进行重定位的符号表索引（重定位表项引用到的符号表），以及将实施的重定位类型（如何进行符号的重定位）。(Type)。</li></ul><p>先来看看重定位表的具体内容，</p><pre><code>$ readelf -r testRelocation section &#39;.rel.dyn&#39; at offset 0x238 contains 1 entries: Offset     Info    Type            Sym.Value  Sym. Name08049574  00000106 R_386_GLOB_DAT    00000000   __gmon_start__Relocation section &#39;.rel.plt&#39; at offset 0x240 contains 3 entries: Offset     Info    Type            Sym.Value  Sym. Name08049584  00000107 R_386_JUMP_SLOT   00000000   __gmon_start__08049588  00000207 R_386_JUMP_SLOT   00000000   __libc_start_main0804958c  00000407 R_386_JUMP_SLOT   00000000   printf</code></pre><p>仅仅关注和过程链接表相关的 <code>.rel.plt</code> 部分，<code>0x10</code> 刚好是 <code>1*16+0*1</code>，即 16 字节，作为重定位表的偏移，刚好对应该表的第三行。发现这个结果中竟然包含了和 <code>printf</code> 符号相关的各种信息。不过重定位表中没有直接指定符号 <code>printf</code>，而是根据 <code>r_info</code> 部分从动态符号表中计算出来的，注意观察上述结果中的 <code>Info</code> 一列的 1，2，4 和下面结果的 <code>Num</code> 列的对应关系。</p><pre><code>$ readelf -s test | grep &quot;.dynsym&quot; -A 6Symbol table &#39;.dynsym&#39; contains 5 entries:   Num:    Value  Size Type    Bind   Vis      Ndx Name     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND     1: 00000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__     2: 00000000   410 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.0 (2)     3: 08048474     4 OBJECT  GLOBAL DEFAULT   14 _IO_stdin_used     4: 00000000    57 FUNC    GLOBAL DEFAULT  UND printf@GLIBC_2.0 (2)</code></pre><p>也就是说在执行过程链接表中的第一项的跳转指令（<code>jmp *0x8049580</code>）调用动态链接器以后，动态链接器因为有了 <code>push 0x10</code>，从而可以通过该重定位表项中的 <code>r_info</code> 找到对应符号（<code>printf</code>）在符号表（<code>.dynsym</code>）中的相关信息。</p><p>除此之外，符号表中还有 <code>Offset(r_offset)</code> 以及 <code>Type</code> 这两个重要信息，前者表示该重定位操作后可能影响的地址 <code>0804958c</code>，这个地址刚好是 <code>got</code> 表项的最后一项，原来存放的是 <code>push 0x10</code> 指令的地址。这意味着，该地址处的内容将被修改，而如何修改呢？根据 <code>Type</code> 类型 <code>R_386_JUMP_SLOT</code>，链接编辑器创建这种重定位类型主要是为了支持动态链接。其偏移地址成员给出过程链接表项的位置。动态链接器修改全局偏移表项的内容，把控制传输给指定符号的地址。</p><p>这说明，动态链接器将根据该类型对全局偏移表中的最后一项，即 <code>0804958c</code> 地址处的内容进行修改，修改为符号的实际地址，即 <code>printf</code> 函数在动态链接库的内存映像中的地址。</p><p>到这里，动态链接的宏观过程似乎已经了然于心，不过一些细节还是不太清楚。</p><p>下面先介绍动态链接库的创建，隐式调用和显示调用，接着进一步澄清上面还不太清楚的细节，即全局偏移表中第二项到底传递给了动态链接器什么信息？第三项是否就是动态链接器的地址？并讨论通过设置 <code>LD_BIND_NOW</code> 而不采用默认的 lazy mode 进行动态链接和采用 lazy mode 动态链接的区别？</p><h2 id="动态链接库的创建和调用"><a href="#动态链接库的创建和调用" class="headerlink" title="动态链接库的创建和调用"></a>动态链接库的创建和调用</h2><p>在介绍动态符号链接的更多细节之前，先来了解一下动态链接库的创建和两种使用方法，进而引出符号解析的后台细节。</p><h3 id="创建动态链接库"><a href="#创建动态链接库" class="headerlink" title="创建动态链接库"></a>创建动态链接库</h3><p>首先来创建一个简单动态链接库。</p><p>代码：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* myprintf.c */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">myprintf</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* myprintf.h */</span><span class="token macro property">#<span class="token directive keyword">ifndef</span> _MYPRINTF_H</span><span class="token macro property">#<span class="token directive keyword">define</span> _MYPRINTF_H</span><span class="token keyword">int</span> <span class="token function">myprintf</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>演示：</p><pre class="line-numbers language-bash"><code class="language-bash">$ gcc -c myprintf.c$ gcc -shared -Wl,-soname,libmyprintf.so.0 -o libmyprintf.so.0.0 myprintf.o$ <span class="token function">ln</span> -sf libmyprintf.so.0.0 libmyprintf.so.0$ <span class="token function">ln</span> -fs libmyprintf.so.0 libmyprintf.so$ <span class="token function">ls</span>libmyprintf.so  libmyprintf.so.0  libmyprintf.so.0.0  myprintf.c  myprintf.h  myprintf.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>得到三个文件 <code>libmyprintf.so</code>，<code>libmyprintf.so.0</code>，<code>libmyprintf.so.0.0</code>，这些库暂且存放在当前目录下。这里有一个问题值得关注，那就是为什么要创建两个符号链接呢？答案是为了在不影响兼容性的前提下升级库 。</p><h3 id="隐式使用该库"><a href="#隐式使用该库" class="headerlink" title="隐式使用该库"></a>隐式使用该库</h3><p>现在写一段代码来使用该库，调用其中的 <code>myprintf</code> 函数，这里是隐式使用该库：在代码中并没有直接使用该库，而是通过调用 <code>myprintf</code> 隐式地使用了该库，在编译引用该库的可执行文件时需要通过 <code>-l</code> 参数指定该库的名字。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* test.c */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span>   </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;myprintf.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">myprintf</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译：</p><pre><code>$ gcc -o test test.c -lmyprintf -L./ -I./</code></pre><p>直接运行 <code>test</code>，提示找不到该库，因为库的默认搜索路径里头没有包含当前目录：</p><pre><code>$ ./test./test: error while loading shared libraries: libmyprintf.so: cannot open shared object file: No such file or directory</code></pre><p>如果指定库的搜索路径，则可以运行：</p><pre><code>$ LD_LIBRARY_PATH=$PWD ./testHello World</code></pre><h3 id="显式使用库"><a href="#显式使用库" class="headerlink" title="显式使用库"></a>显式使用库</h3><p><code>LD_LIBRARY_PATH</code> 环境变量使得库可以放到某些指定的路径下面，而无须在调用程序中显式的指定该库的绝对路径，这样避免了把程序限制在某些绝对路径下，方便库的移动。</p><p>虽然显式调用有不便，但是能够避免隐式调用搜索路径的时间消耗，提高效率，除此之外，显式调用为我们提供了一组函数调用，让符号的重定位过程一览无遗。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* test1.c */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;dlfcn.h></span>      </span><span class="token comment" spellcheck="true">/* dlopen, dlsym, dlerror */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span>     </span><span class="token comment" spellcheck="true">/* exit */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span>      </span><span class="token comment" spellcheck="true">/* printf */</span><span class="token macro property">#<span class="token directive keyword">define</span> LIB_SO_NAME     "./libmyprintf.so"</span><span class="token macro property">#<span class="token directive keyword">define</span> FUNC_NAME "myprintf"</span><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">void</span> <span class="token operator">*</span>h<span class="token punctuation">;</span>        <span class="token keyword">char</span> <span class="token operator">*</span>e<span class="token punctuation">;</span>        func f<span class="token punctuation">;</span>        h <span class="token operator">=</span> <span class="token function">dlopen</span><span class="token punctuation">(</span>LIB_SO_NAME<span class="token punctuation">,</span> RTLD_LAZY<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>h <span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"failed load libary: %s\n"</span><span class="token punctuation">,</span> LIB_SO_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        f <span class="token operator">=</span> <span class="token function">dlsym</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> FUNC_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span>        e <span class="token operator">=</span> <span class="token function">dlerror</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"search %s error: %s\n"</span><span class="token punctuation">,</span> FUNC_NAME<span class="token punctuation">,</span> LIB_SO_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">f</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>演示：</p><pre><code>$ gcc -o test1 test1.c -ldl</code></pre><p>这种情况下，无须包含头文件。从这个代码中很容易看出符号重定位的过程：</p><ul><li>首先通过 <code>dlopen</code> 找到依赖库，并加载到内存中，再返回该库的 <code>handle</code>，通过 <code>dlopen</code> 我们可以指定 <code>RTLD_LAZY</code> 采用 <code>lazy mode</code> 动态链接模式，如果采用 <code>RTLD_NOW</code> 则和隐式调用时设置 <code>LD_BIN_NOW</code> 类似。</li><li>找到该库以后就是对某个符号进行重定位，这里是确定 <code>myprintf</code> 函数的地址。</li><li>找到函数地址以后就可以直接调用该函数了。</li></ul><p>隐式调用的动态符号链接过程和上面类似。下面通过一些实例来确定之前没有明确的两个内容：即全局偏移表中的第二项和第三项，并进一步讨论 lazy mode 和非 lazy mode 的区别。</p><h2 id="动态链接过程"><a href="#动态链接过程" class="headerlink" title="动态链接过程"></a>动态链接过程</h2><p>因为通过 <code>ELF</code> 文件，我们就可以确定全局偏移表的位置，因此为了确定全局偏移表位置的第二项和第三项的内容，有两种办法：</p><ul><li><p>通过 <code>gdb</code> 调试。</p></li><li><p>直接在函数内部打印。</p></li></ul><p>这里试着通过第二种方法来确定这两个地址的值。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * got.c -- get the relative content of the got(global offset table) of an elf file */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">define</span> GOT 0x8049614</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">long</span> got2<span class="token punctuation">,</span> got3<span class="token punctuation">;</span>        <span class="token keyword">long</span> old_addr<span class="token punctuation">,</span> new_addr<span class="token punctuation">;</span>        got2<span class="token operator">=</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>GOT<span class="token operator">+</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        got3<span class="token operator">=</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>GOT<span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        old_addr<span class="token operator">=</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>GOT<span class="token operator">+</span><span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        new_addr<span class="token operator">=</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>GOT<span class="token operator">+</span><span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"got2: 0x%0x, got3: 0x%0x, old_addr: 0x%0x, new_addr: 0x%0x\n"</span><span class="token punctuation">,</span>                                        got2<span class="token punctuation">,</span> got3<span class="token punctuation">,</span> old_addr<span class="token punctuation">,</span> new_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在写好上面的代码后就需要确定全局偏移表的地址，然后把该地址设置为代码中的宏 <code>GOT</code> 。</p><pre><code>$ make got$ readelf -d got | grep PLTGOT 0x00000003 (PLTGOT)                     0x8049614</code></pre><p><strong>注</strong>：这里假设大家用的都是 <code>i386</code> 的系统，如果要在 <code>X86_64</code> 位系统上要编译生成 <code>i386</code> 上的可执行文件，需要给 <code>gcc</code> 传递一个 <code>-m32</code> 参数，例如：</p><pre><code>$ gcc -m32 -o got got.c</code></pre><p>把地址 <code>0x8049614</code> 替换到上述代码中，然后重新编译运行，查看结果。</p><pre><code>$ make got$ Hello Worldgot2: 0xb7f376d8, got3: 0xb7f2ef10, old_addr: 0x80482da, new_addr: 0xb7e19a20$ ./gotHello Worldgot2: 0xb7f1e6d8, got3: 0xb7f15f10, old_addr: 0x80482da, new_addr: 0xb7e00a20</code></pre><p>通过两次运行，发现全局偏移表中的这两项是变化的，并且 <code>printf</code> 的地址对应的 <code>new_addr</code> 也是变化的，说明 <code>libc</code> 和 <code>ld-linux</code> 这两个库启动以后对应的虚拟地址并不确定。因此，无法直接跟踪到那个地址处的内容，还得借助调试工具，以便确认它们。</p><p>下面重新编译 <code>got</code>，加上 <code>-g</code> 参数以便调试，并通过调试确认 <code>got2</code>，<code>got3</code>，以及调用 <code>printf</code> 前后 <code>printf</code> 地址的重定位情况。</p><pre class="line-numbers language-c"><code class="language-c">$ gcc <span class="token operator">-</span>g <span class="token operator">-</span>o got got<span class="token punctuation">.</span>c$ gdb <span class="token operator">-</span>q <span class="token punctuation">.</span><span class="token operator">/</span><span class="token function">got</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> l<span class="token number">5</span>       #include <span class="token operator">&lt;</span>stdio<span class="token punctuation">.</span>h<span class="token operator">></span><span class="token number">6</span><span class="token number">7</span>       #define GOT <span class="token number">0x8049614</span><span class="token number">8</span><span class="token number">9</span>       <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token number">10</span>      <span class="token punctuation">{</span><span class="token number">11</span>              <span class="token keyword">long</span> got2<span class="token punctuation">,</span> got3<span class="token punctuation">;</span><span class="token number">12</span>              <span class="token keyword">long</span> old_addr<span class="token punctuation">,</span> new_addr<span class="token punctuation">;</span><span class="token number">13</span><span class="token number">14</span>              got2<span class="token operator">=</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>GOT<span class="token operator">+</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> l<span class="token number">15</span>              got3<span class="token operator">=</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>GOT<span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">16</span>              old_addr<span class="token operator">=</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>GOT<span class="token operator">+</span><span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">17</span><span class="token number">18</span>              <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">19</span><span class="token number">20</span>              new_addr<span class="token operator">=</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>GOT<span class="token operator">+</span><span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">21</span><span class="token number">22</span>              <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"got2: 0x%0x, got3: 0x%0x, old_addr: 0x%0x, new_addr: 0x%0x\n"</span><span class="token punctuation">,</span><span class="token number">23</span>                                              got2<span class="token punctuation">,</span> got3<span class="token punctuation">,</span> old_addr<span class="token punctuation">,</span> new_addr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">24</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在第一个 <code>printf</code> 处设置一个断点：</p><pre><code>(gdb) break 18Breakpoint 1 at 0x80483c3: file got.c, line 18.</code></pre><p>在第二个 <code>printf</code> 处设置一个断点：</p><pre><code>(gdb) break 22Breakpoint 2 at 0x80483dd: file got.c, line 22.</code></pre><p>运行到第一个 <code>printf</code> 之前会停止：</p><pre><code>(gdb) rStarting program: /mnt/hda8/Temp/c/program/gotBreakpoint 1, main () at got.c:1818              printf(&quot;Hello World\n&quot;);</code></pre><p>查看执行 <code>printf</code> 之前的全局偏移表内容：</p><pre><code>(gdb) x/8x 0x80496140x8049614 &lt;_GLOBAL_OFFSET_TABLE_&gt;:      0x08049548      0xb7f3c6d8      0xb7f33f10      0x080482aa0x8049624 &lt;_GLOBAL_OFFSET_TABLE_+16&gt;:   0xb7ddbd20      0x080482ca      0x080482da      0x00000000</code></pre><p>查看 <code>GOT</code> 表项的最后一项，发现刚好是 <code>PLT</code> 表中 <code>push</code> 指令的地址：</p><pre><code>(gdb) disassemble 0x080482daDump of assembler code for function puts@plt:0x080482d4 &lt;puts@plt+0&gt;:        jmp    *0x804962c0x080482da &lt;puts@plt+6&gt;:        push   $0x180x080482df &lt;puts@plt+11&gt;:       jmp    0x8048294 &lt;_init+24&gt;</code></pre><p>说明此时还没有进行进行符号的重定位，不过发现并非 <code>printf</code>，而是 <code>puts(1)</code>。</p><p>接着查看 <code>GOT</code> 第三项的内容，刚好是 <code>dl-linux</code> 对应的代码：</p><pre><code>(gdb) disassemble 0xb7f33f10Dump of assembler code for function _dl_runtime_resolve:0xb7f33f10 &lt;_dl_runtime_resolve+0&gt;:     push   %eax0xb7f33f11 &lt;_dl_runtime_resolve+1&gt;:     push   %ecx0xb7f33f12 &lt;_dl_runtime_resolve+2&gt;:     push   %edx</code></pre><p>可通过 <code>nm /lib/ld-linux.so.2 | grep _dl_runtime_resolve</code> 进行确认。</p><p>然后查看 <code>GOT</code> 表第二项处的内容，看不出什么特别的信息，反编译时提示无法反编译：</p><pre><code>(gdb) x/8x 0xb7f3c6d80xb7f3c6d8:     0x00000000      0xb7f39c3d      0x08049548      0xb7f3c9b80xb7f3c6e8:     0x00000000      0xb7f3c6d8      0x00000000      0xb7f3c9a4</code></pre><p>在 <code>*(0xb7f33f10)</code> 指向的代码处设置一个断点，确认它是否被执行：</p><pre><code>(gdb) break *(0xb7f33f10)break *(0xb7f33f10)Breakpoint 3 at 0xb7f3cf10(gdb) cContinuing.Breakpoint 3, 0xb7f3cf10 in _dl_runtime_resolve () from /lib/ld-linux.so.2</code></pre><p>继续运行，直到第二次调用 <code>printf</code> ：</p><pre><code>(gdb)  cContinuing.Hello WorldBreakpoint 2, main () at got.c:2222              printf(&quot;got2: 0x%0x, got3: 0x%0x, old_addr: 0x%0x, new_addr: 0x%0x\n&quot;,</code></pre><p>再次查看 <code>GOT</code> 表项，发现 <code>GOT</code> 表的最后一项的值应该被修改：</p><pre><code>(gdb) x/8x 0x80496140x8049614 &lt;_GLOBAL_OFFSET_TABLE_&gt;:      0x08049548      0xb7f3c6d8      0xb7f33f10      0x080482aa0x8049624 &lt;_GLOBAL_OFFSET_TABLE_+16&gt;:   0xb7ddbd20      0x080482ca      0xb7e1ea20      0x00000000</code></pre><p>查看 <code>GOT</code> 表最后一项，发现变成了 <code>puts</code> 函数的代码，说明进行了符号 <code>puts</code> 的重定位（2）：</p><pre><code>(gdb) disassemble 0xb7e1ea20Dump of assembler code for function puts:0xb7e1ea20 &lt;puts+0&gt;:    push   %ebp0xb7e1ea21 &lt;puts+1&gt;:    mov    %esp,%ebp0xb7e1ea23 &lt;puts+3&gt;:    sub    $0x1c,%esp</code></pre><p>通过演示发现一个问题（1）（2），即本来调用的是 <code>printf</code>，为什么会进行 <code>puts</code> 的重定位呢？通过 <code>gcc -S</code> 参数编译生成汇编代码后发现，<code>gcc</code> 把 <code>printf</code> 替换成了 <code>puts</code>，因此不难理解程序运行过程为什么对 <code>puts</code> 进行了重定位。</p><p>从演示中不难发现，当符号被使用到时才进行重定位。因为通过调试发现在执行 <code>printf</code> 之后，<code>GOT</code> 表项的最后一项才被修改为 <code>printf</code> （确切的说是 <code>puts</code>）的地址。这就是所谓的 <code>lazy mode</code> 动态符号链接方式。</p><p>除此之外，我们容易发现 <code>GOT</code> 表第三项确实是 <code>ld-linux.so</code> 中的某个函数地址，并且发现在执行 <code>printf</code> 语句之前，先进入了 <code>ld-linux.so</code> 的 <code>_dl_runtime_resolve</code> 函数，而且在它返回之后，<code>GOT</code> 表的最后一项才变为 <code>printf</code> （<code>puts</code>）的地址。</p><p>本来打算通过第一个断点确认第二次调用 <code>printf</code> 时不再需要进行动态符号链接的，不过因为 <code>gcc</code> 把第一个替换成了 <code>puts</code>，所以这里没有办法继续调试。如果想确认这个，你可以通过写两个一样的 <code>printf</code> 语句看看。实际上第一次链接以后，<code>GOT</code> 表的第三项已经修改了，当下次再进入过程链接表，并执行 <code>jmp *(全局偏移表中某一个地址)</code> 指令时，<code>*(全局偏移表中某一个地址)</code> 已经被修改为了对应符号的实际地址，这样 <code>jmp</code> 语句会自动跳转到符号的地址处运行，执行具体的函数代码，因此无须再进行重定位。</p><p>到现在 <code>GOT</code> 表中只剩下第二项还没有被确认，该项指向一个 <code>link_map</code> 类型的数据，是一个鉴别信息，具体作用对我们来说并不是很重要。</p><p>下面通过设置 <code>LD_BIND_NOW</code> 再运行一下 <code>got</code> 程序并查看结果，比较它与默认的动态链接方式（<code>lazy mode</code>）的异同。</p><ul><li><p>设置 <code>LD_BIND_NOW</code> 环境变量的运行结果</p><pre><code>  $ LD_BIND_NOW=1 ./got  Hello World  got2: 0x0, got3: 0x0, old_addr: 0xb7e61a20, new_addr: 0xb7e61a20</code></pre></li><li><p>默认情况下的运行结果</p><pre><code>  $ ./got  Hello World  got2: 0xb7f806d8, got3: 0xb7f77f10, old_addr: 0x80482da, new_addr: 0xb7e62a20</code></pre></li></ul><p>通过比较容易发现，在非 <code>lazy mode</code> （设置 <code>LD_BIND_NOW</code> 后）下，程序运行之前符号的地址就已经被确定，即调用 <code>printf</code> 之前 <code>GOT</code> 表的最后一项已经被确定为了 <code>printf</code> 函数对应的地址，即 <code>0xb7e61a20</code>，因此在程序运行之后，<code>GOT</code> 表的第二项和第三项就保持为 0，因为此时不再需要它们进行符号的重定位了。通过这样一个比较，就更容易理解 <code>lazy mode</code> 的特点了：在用到的时候才解析。</p><p>到这里，符号动态链接的细节基本上就已经清楚了。</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> C </tag>
            
            <tag> 编程透视 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Own Virtual Machine(一)</title>
      <link href="posts/31993/"/>
      <url>posts/31993/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="什么是virtual-machine"><a href="#什么是virtual-machine" class="headerlink" title="什么是virtual machine"></a>什么是virtual machine</h3><p>虚拟机就是一段表现得像一个电脑的程序，这段程序模仿了CPU以及其他的一些硬件，这使得这段程序表现得具有算术性（arithmetic），比如说能够读，写内存，能够和I/O设备交互，就像一台物理意义上的电脑一样。最重要的是，一个VM能够明白你用来编程时用到的机器语言。</p><p>虚拟机尝试模拟的计算机硬件数量取决于一个VM的用途。一些虚拟机被用来设计重现一些计算机的特定功能，比如说常见的游戏模拟器。大部分人并没有一台NES，但是我们仍然可以通过在一个程序中模拟NES的硬件环境来玩NES上的游戏。这种类型的模拟器必须忠实地重建原始设备中的每个细节和主要硬件组件。</p><p>而有其他一些虚拟机则不必表现得像一台真实的计算机，并且可以完全没有实物参考。这样做的首要目的是为了让一些软件的开发更容易一些。考虑一下你想要开发一个能在多个指令集框架下运行的程序，此时虚拟机可以被设计用来提供一个标准平台，为所有平台提供可移植性，而不是不断重写一个程序在不同指令集下的汇编的方言集。此时，只需要用每种指令集下的汇编语言编写小型虚拟机程序。 然后，每个程序只能使用虚拟机的汇编语言编写一次。</p><p><img src="https://justinmeiners.github.io/lc3-vm/img/no_vm.gif" alt="no_nvm"></p><p><img src="https://justinmeiners.github.io/lc3-vm/img/vm.gif" alt="vm"></p><blockquote><p><strong>Note：</strong>编译器通过将标准的高级语言编译为几种CPU架构来解决类似的问题。 虚拟机创建一个标准的CPU体系结构，该体系结构可在各种硬件设备上进行仿真。 编译器的一个优势是不会带来运行时开销，而虚拟机却很难避免。但即使编译器做得很好，但是编写针对多个平台的新程序还是很困难的，因此虚拟机在跨平台时依然有很大的帮助。 实际上，虚拟机和编译器在各个级别上混合在一起。</p></blockquote><p>JAVA虚拟机（JVM）就是一个非常成功的案例，JVM本身是一个中等大小的程序，其大小足以让一个程序员理解。这使得可以为包括电话在内的数千种设备编写内容。 在新设备上实现JVM之后，任何编写的Java，Kotlin或Clojure程序都可以在其上运行，而无需进行任何修改。唯一的成本是虚拟机本身的开销以及从计算机的进一步抽象。 大多数时候，这是一个很好的权衡。</p><p>虚拟机不必很大或无处不在（pervasive）即可提供这样的好处。 旧的视频游戏通常使用小型VM提供简单的<a href="https://sf2platinum.wordpress.com/">脚本系统</a>。</p><p>虚拟机对于以安全或隔离的方式执行代码也很有用。 一种应用是垃圾收集。 由于程序看不到自己的堆栈或变量，因此没有简单的方法可以在C或C ++上实现自动垃圾回收。 但是，虚拟机在其正在运行的程序“外部”，并且可以观察堆栈上的所有内存引用。</p><p>以太坊智能合约证明了这种行为的另一个例子。 智能合约是由区块链网络中每个验证节点执行的小程序。 这要求节点操作员在他们的计算机上运行完全陌生的人编写的程序，而且没有任何机会对其进行事先检查。 为了防止合同执行时的恶意操作，它们在无法访问文件系统，网络，磁盘等的虚拟机内运行。以太坊也是使用虚拟机的可移植性功能的良好应用。 由于以太坊节点可以在多种计算机和操作系统上运行，因此使用虚拟机可以编写智能合约，而无需考虑它们运行的许多平台。</p><h2 id="LC-3-Architecture"><a href="#LC-3-Architecture" class="headerlink" title="LC-3 Architecture"></a>LC-3 Architecture</h2><p>我们要编写的虚拟机将会模拟一个叫做<a href="https://en.wikipedia.org/wiki/Little_Computer_3">LC-3</a>的虚构计算机，LC-3非常适合教大学生如何使用汇编语言进行编程，与x86相比，它具有简化的指令集，但包含了现代CPU中使用的所有主要思想。</p><p>首先，我们需要模拟机器的基本硬件组件。 尝试了解每个组件是什么，但是现在请不要担心以后这些代码会不会适用。 先开始创建一个C文件。 本节中的每个代码段都应放置在此文件的全局范围内。</p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>LC-3虚拟机有65,536的内存地址（可通过16位无符号整数2 ^ 16寻址的最大值），每一个地址都会被用来存一个16位(bit)的值，这就意味着我们的虚拟机一共可以存储仅仅128kb，比之前所习惯使用的虚拟机小得多，在我们编写的程序中，这些内存将会存储在一个简单的数组中：</p><pre class="line-numbers language-C"><code class="language-C">/* 65536 locations */uint16_t memory[UINT16_MAX];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>寄存器是用于在CPU上存储单个值的插槽。 寄存器就像CPU的“工作台”。 为了使CPU处理一条数据，这条数据必须位于一个寄存器中。 但是，由于只有几个寄存器，因此在任何给定时间只能加载最少量的数据。 程序通过将内存中的值加载到寄存器中，计算值并存储到其他寄存器中，然后将最终结果存储回内存中来解决此问题。</p><p>LC-3一共有10个寄存器，每一个寄存器都是16位。它们中的大多数是通用的，但有少数具有特点的功能。</p><ul><li>8个通用寄存器（R0-R7）</li><li>1个程序计数器（PC）寄存器</li><li>1个条件标志寄存器（COND）</li></ul><p>通用寄存器可用于执行任何程序计算。 程序计数器中存储的是一个无符号整数，它是内存中要执行的下一条指令的地址。 条件标志寄存器则告诉我们有关先前计算的信息。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">enum</span><span class="token punctuation">{</span>    R_R0 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>    R_R1<span class="token punctuation">,</span>    R_R2<span class="token punctuation">,</span>    R_R3<span class="token punctuation">,</span>    R_R4<span class="token punctuation">,</span>    R_R5<span class="token punctuation">,</span>    R_R6<span class="token punctuation">,</span>    R_R7<span class="token punctuation">,</span>    R_PC<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">/* program counter */</span>    R_COND<span class="token punctuation">,</span>    R_COUNT<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>就像存储内存一样，我们用同样的方式在一个数组中存储寄存器：</p><pre class="line-numbers language-c"><code class="language-c">uint16_t reg<span class="token punctuation">[</span>R_COUNT<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h3><p>一个指令是一个命令，会让CPU执行一些基本任务，例如将两个数字相加。 指令既具有指示要执行的任务类型的操作码，也提供执行指令时所需要的一系列参数。</p><p>每个操作码代表一个任务，CPU根据操作码将“知道”该怎么做。 LC-3中只有16个操作码。 计算机可以计算的所有内容都是这些简单指令的集合。 每条指令长16位，其中最左边的4位用于存储操作码， 其余的位用于存储参数。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">enum</span><span class="token punctuation">{</span>    OP_BR <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">/* branch */</span>    OP_ADD<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">/* add  */</span>    OP_LD<span class="token punctuation">,</span>     <span class="token comment" spellcheck="true">/* load */</span>    OP_ST<span class="token punctuation">,</span>     <span class="token comment" spellcheck="true">/* store */</span>    OP_JSR<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">/* jump register */</span>    OP_AND<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">/* bitwise and */</span>    OP_LDR<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">/* load register */</span>    OP_STR<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">/* store register */</span>    OP_RTI<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">/* unused */</span>    OP_NOT<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">/* bitwise not */</span>    OP_LDI<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">/* load indirect */</span>    OP_STI<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">/* store indirect */</span>    OP_JMP<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">/* jump */</span>    OP_RES<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">/* reserved (unused) */</span>    OP_LEA<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">/* load effective address */</span>    OP_TRAP    <span class="token comment" spellcheck="true">/* execute trap */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>Note:</strong> 英特尔x86架构具有数百条指令，而其他指令（例如ARM和LC-3）则很少。 小指令集称为RISC(精简指令集)，大指令集称为CISC(复杂指令集)。 较大的指令集通常从根本上来说没有提供新的功能，但是它们通常使编写汇编更为方便。 CISC中的一条指令可能会和RISC中的一系列指令发挥的作用一样。 但是，对于工程师来说，它们的设计和制造往往更为复杂和昂贵。 这些原因和其他的权衡取舍使得CISC变得逐渐过时。</p></blockquote><h3 id="条件标志位"><a href="#条件标志位" class="headerlink" title="条件标志位"></a>条件标志位</h3><p><code>R_COND</code>寄存器存储条件标志位，这些条件标志位提供有关最近执行的计算的信息。 这使程序可以检查逻辑条件，例如 if（x&gt; 0）{…}。</p><p>每个CPU都有各种条件标志位来发出各种情况的信号。 LC-3仅使用3个状态标志来指示先前计算的符号。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">enum</span><span class="token punctuation">{</span>    FL_POS <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">/* P */</span>    FL_ZRO <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">/* Z */</span>    FL_NEG <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">/* N */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在我们完成了虚拟机硬件部分的设置。</p><h2 id="汇编示例"><a href="#汇编示例" class="headerlink" title="汇编示例"></a>汇编示例</h2><p>现在，让我们看一下LC-3的汇编程序，以了解虚拟机的实际运行的情况。 现在还不需要知道如何编写汇编程序或了解正在发生的一切。 只需尝试了解正在发生的事情即可。 这是一个简单的“ Hello World”：</p><pre class="line-numbers language-assembly"><code class="language-assembly">.ORIG x3000                        ; this is the address in memory where the program will be loadedLEA R0, HELLO_STR                  ; load the address of the HELLO_STR string into R0PUTs                               ; output the string pointed to by R0 to the consoleHALT                               ; halt the programHELLO_STR .STRINGZ "Hello World!"  ; store this string here in the program.END                               ; mark the end of the file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>就像在C语言中一样，该程序从顶部开始，一次执行一个语句。 但是，与C不同，没有嵌套的作用域{}或控制结构，例如if或while； 只是陈述的列出要执行的清单，这使得执行起来更加容易。</p><p>请注意，某些语句的名称与我们之前定义的操作码相匹配。 先前，我们了解到每条指令都是16位，但是每一行看起来都是不同数量的字符。 这种不一致是怎么实现的？</p><p>这是因为我们正在读取的代码是以<code>汇编</code>形式编写的，汇编语言是一种助记符的形式，以纯文本编码。 称为<code>汇编程序</code>的工具用于将每一行文本转换为虚拟机可以理解的16位二进制指令。 这种二进制形式本质上是一个16位指令的数组，称为机器代码，是虚拟机实际运行的形式。</p><p><img src="https://justinmeiners.github.io/lc3-vm/img/assembler.gif" alt="assembler"></p><blockquote><p><strong>NOTE:</strong>  尽管编译器和汇编器在开发中扮演相似的角色，但它们并不相同。 汇编器仅将程序员在文本中编写的内容编码为二进制，然后将符号替换为二进制表示形式并将其打包为指令。</p></blockquote><p><code>.ORIG</code>和<code>.STRINGZ</code>看起来像指令，但实际上并非如此， 它们是伪指令（assembler directives），可生成一段代码或数据（像宏一样）。 例如，<code>.STRINGZ</code>在程序二进制文件的写入位置插入一个字符串。</p><pre class="line-numbers language-assembly"><code class="language-assembly">AND R0, R0, 0                      ; clear R0LOOP                               ; label at the top of our loopADD R0, R0, 1                      ; add 1 to R0 and store back in R0ADD R1, R0, -10                    ; subtract 10 from R0 and store back in R1BRn LOOP                           ; go back to LOOP if the result was negative... ; R0 is now 10!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>NOTE:</strong>本教程不需要学习编写汇编。 但是如果有兴趣，可以使用<a href="http://highered.mheducation.com/sites/0072467509/student_view0/lc-3_simulator.html">LC-3工具</a>编写和汇编自己的LC-3程序。</p></blockquote><h2 id="执行程序"><a href="#执行程序" class="headerlink" title="执行程序"></a>执行程序</h2><p>前面的示例只是为了解虚拟机的功能。 编写虚拟机不需要精通汇编程序。 只要遵循正确的步骤来阅读和执行指令，无论它多么复杂，任何LC-3程序都将正确运行。 从理论上讲，它甚至可以运行Web浏览器或Linux之类的操作系统！</p><p>如果深入考虑过这个特性，那么这是一个哲学上非凡的想法。 程序本身可以执行我们从未预料到并且可能无法理解的各种智能操作，但是与此同时，它们可以执行的所有操作仅限于我们将要编写的简单代码！ 我们同时了解每个程序的工作原理，但同时却对它一无所知。 图灵观察到了这个奇妙的想法：</p><blockquote><p>“The view that machines cannot give rise to surprises is due, I believe, to a fallacy to which philosophers and mathematicians are particularly subject. This is the assumption that as soon as a fact is presented to a mind all consequences of that fact spring into the mind simultaneously with it. It is a very useful assumption under many circumstances, but one too easily forgets that it is false.” — <a href="https://academic.oup.com/mind/article-pdf/LIX/236/433/9866119/433.pdf">Alan M. Turing</a></p></blockquote><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>下面是我们需要编写的：</p><ol><li>从PC寄存器地址的存储器中加载一条指令。</li><li>递增PC寄存器。</li><li>查看操作码以确定应执行的指令类型。</li><li>使用指令中的参数执行指令。</li><li>返回步骤1。</li></ol><p>你可能想知道，“如果循环不断增加PC，而我们又没有<code>if</code>或者<code>while</code>，那它不会很快用完指令吗？” 答案是不会，正如我们之前提到的，一些类似于<code>goto</code>的指令通过在PC上跳转来改变执行流程。</p><p>让我们开始在主循环中概述此过程：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">{</span>Load Arguments<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span>    <span class="token punctuation">{</span>Setup<span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* set the PC to starting position */</span>    <span class="token comment" spellcheck="true">/* 0x3000 is the default */</span>    <span class="token keyword">enum</span> <span class="token punctuation">{</span> PC_START <span class="token operator">=</span> <span class="token number">0x3000</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    reg<span class="token punctuation">[</span>R_PC<span class="token punctuation">]</span> <span class="token operator">=</span> PC_START<span class="token punctuation">;</span>    <span class="token keyword">int</span> running <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>running<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* FETCH */</span>        uint16_t instr <span class="token operator">=</span> <span class="token function">mem_read</span><span class="token punctuation">(</span>reg<span class="token punctuation">[</span>R_PC<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        uint16_t op <span class="token operator">=</span> instr <span class="token operator">>></span> <span class="token number">12</span><span class="token punctuation">;</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>op<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">case</span> OP_ADD<span class="token punctuation">:</span>                <span class="token punctuation">{</span>ADD<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> OP_AND<span class="token punctuation">:</span>                <span class="token punctuation">{</span>AND<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> OP_NOT<span class="token punctuation">:</span>                <span class="token punctuation">{</span>NOT<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> OP_BR<span class="token punctuation">:</span>                <span class="token punctuation">{</span>BR<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> OP_JMP<span class="token punctuation">:</span>                <span class="token punctuation">{</span>JMP<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> OP_JSR<span class="token punctuation">:</span>                <span class="token punctuation">{</span>JSR<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> OP_LD<span class="token punctuation">:</span>                <span class="token punctuation">{</span>LD<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> OP_LDI<span class="token punctuation">:</span>                <span class="token punctuation">{</span>LDI<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> OP_LDR<span class="token punctuation">:</span>                <span class="token punctuation">{</span>LDR<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> OP_LEA<span class="token punctuation">:</span>                <span class="token punctuation">{</span>LEA<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> OP_ST<span class="token punctuation">:</span>                <span class="token punctuation">{</span>ST<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> OP_STI<span class="token punctuation">:</span>                <span class="token punctuation">{</span>STI<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> OP_STR<span class="token punctuation">:</span>                <span class="token punctuation">{</span>STR<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> OP_TRAP<span class="token punctuation">:</span>                <span class="token punctuation">{</span>TRAP<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> OP_RES<span class="token punctuation">:</span>            <span class="token keyword">case</span> OP_RTI<span class="token punctuation">:</span>            <span class="token keyword">default</span><span class="token punctuation">:</span>                <span class="token punctuation">{</span>BAD OPCODE<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token punctuation">{</span>Shutdown<span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了使用命令行直接输入命令外，我们也希望能够给出一个或者多个加载的路径给虚拟机直接执行。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* show usage string */</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"lc3 [image-file1] ...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">read_image</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"failed to load image: %s\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="实现指令"><a href="#实现指令" class="headerlink" title="实现指令"></a>实现指令</h2><p>现在的任务是为每个操作码用正确的实现去填充。 这比听起来容易。 每个说明的详细规范都包含在<a href="https://justinmeiners.github.io/lc3-vm/supplies/lc3-isa.pdf">文档</a>中。 每个规范都可以轻松转换为几行代码。 这里演示如何实现其中的两个。 其余代码可在下一部分中找到。</p><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p><code>ADD</code>指令取两个数字，将它们加在一起，然后将结果存储在寄存器中。每个<code>ADD</code>指令如下所示：</p><p><img src="https://justinmeiners.github.io/lc3-vm/img/add_layout.gif" alt="add_layout"></p><p>图中的编码有两行，说明此指令有两种不同的“模式”。 在解释模式之前，让我们尝试找到它们之间的相似之处。 在两行中，我们都可以看到从4位<code>0001</code>开始。这是<code>OP_ADD</code>的操作码值。 接下来的3位标记为<code>DR</code>， 这代表目的地寄存器。 目的地寄存器是将添加的总和存储的位置。 接下来的3位是<code>SR1</code>。 这是包含第一个要添加的数字的寄存器。</p><p>因此，我们知道要在哪里存储结果，并且知道要添加的第一个数字。 我们还需要的最后一点信息是第二个加数。 此时，两行开始看起来有所不同。 请注意，第一行的第5位为0，第二行为1。该位指示是立即模式还是寄存器模式。 在寄存器模式下，第二个数字与第一个数字一样存储在寄存器中。 标记为<code>SR2</code>，包含在位2-0中。 位3和4未使用。 在汇编中，它将写为：</p><blockquote><p>ADD R2 R0 R1 ；将R0的内容添加到R1并存储在R2中。</p></blockquote><p>立即模式提供了一种便利，减少了一些典型程序的长度。 第二个值没有存储在单独寄存器中，而是嵌入了指令本身，在图中标记为<code>imm5</code>。 这消除了编写指令以从存储器加载值的需要。 它在取值的范围内做了一些折衷，指令仅可寻找一个很小的空间，确切的说是<code>2 ^ 5 = 32</code>（无符号），这使得立即模式主要对递增和递减的运算来说很有用。 在汇编中，它可以写为：</p><blockquote><p>ADD R0 R0 1； 将1加到R0并存储回R0</p></blockquote><p>综上：</p><blockquote><p>如果bit[5]为0，则从SR2获得第二个源操作数。 如果bit[5]为1，则通过将imm5字段中符号扩展为16位来获得第二个源操作数。 在两种情况下，都将第二个源操作数添加到SR1的内容中，并将结果存储在DR中。</p></blockquote><p>什么是“符号扩展”？ 立即模式值只有5位，但是需要将其添加到16位数字中。 要进行加法运算，需要将这5位扩展为16位以匹配其他数字。 对于正数，我们可以简单地为其他位填充0。 对于负数，这会引起问题。 例如，五位中的-1为11111。如果我们将其扩展为0，则为0000 0000 0001 1111，等于31。符号扩展通过将0填充为正数，将1填充为负数来纠正此问题， 以便保留原始值。</p><pre class="line-numbers language-c"><code class="language-c">uint16_t <span class="token function">sign_extend</span><span class="token punctuation">(</span>uint16_t x<span class="token punctuation">,</span> <span class="token keyword">int</span> bit_count<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token punctuation">(</span>bit_count <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        x <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0xFFFF</span> <span class="token operator">&lt;&lt;</span> bit_count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>NOTE:</strong> 如果对到底如何用二进制表示负数感兴趣，可以阅读有关二进制的补码。 但是这不是必需的。 可以仅复制上面的代码，并在任何需要时使用它。</p></blockquote><p>此时状态位需要根据结果是负数，零，还是正数来设置。</p><p>之前我们定义了条件标志位的枚举，现在是时候使用它们了。 每当将值写入寄存器时，我们都需要更新标志以指示其符号。 我们将编写一个函数，以便可以复用：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">update_flags</span><span class="token punctuation">(</span>uint16_t r<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>reg<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        reg<span class="token punctuation">[</span>R_COND<span class="token punctuation">]</span> <span class="token operator">=</span> FL_ZRO<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>reg<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">>></span> <span class="token number">15</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">/* a 1 in the left-most bit indicates negative */</span>    <span class="token punctuation">{</span>        reg<span class="token punctuation">[</span>R_COND<span class="token punctuation">]</span> <span class="token operator">=</span> FL_NEG<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span><span class="token punctuation">{</span>        reg<span class="token punctuation">[</span>R_COND<span class="token punctuation">]</span> <span class="token operator">=</span> FL_POS<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在可以编写操作码为ADD时的情况了</p><pre class="line-numbers language-c"><code class="language-c"><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* destination register (DR) */</span>    uint16_t r0 <span class="token operator">=</span> <span class="token punctuation">(</span>instr <span class="token operator">>></span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x7</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* first operand (SR1) */</span>    uint16_t r1 <span class="token operator">=</span> <span class="token punctuation">(</span>instr <span class="token operator">>></span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x7</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* whether we are in immediate mode */</span>    uint16_t imm_flag <span class="token operator">=</span> <span class="token punctuation">(</span>instr <span class="token operator">>></span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>imm_flag<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        uint16_t imm5 <span class="token operator">=</span> <span class="token function">sign_extend</span><span class="token punctuation">(</span>instr <span class="token operator">&amp;</span> <span class="token number">0x1F</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        reg<span class="token punctuation">[</span>r0<span class="token punctuation">]</span> <span class="token operator">=</span> reg<span class="token punctuation">[</span>r1<span class="token punctuation">]</span> <span class="token operator">+</span> imm5<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        uint16_t r2 <span class="token operator">=</span> instr <span class="token operator">&amp;</span> <span class="token number">0x7</span><span class="token punctuation">;</span>        reg<span class="token punctuation">[</span>r0<span class="token punctuation">]</span> <span class="token operator">=</span> reg<span class="token punctuation">[</span>r1<span class="token punctuation">]</span> <span class="token operator">+</span> reg<span class="token punctuation">[</span>r2<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">update_flags</span><span class="token punctuation">(</span>r0<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本节包含很多信息，现在来总结一下。</p><ul><li><p><code>ADD</code>取两个值并将它们存储在寄存器中。</p></li><li><p>在寄存器模式下，要添加的第二个值在寄存器中找到。</p></li><li><p>在立即模式下，第二个值嵌入在指令的最右5位中。</p></li><li><p>小于16位的值需要进行符号扩展。</p></li><li><p>每当指令修改寄存器时，都需要更新条件标志。</p></li></ul><p>你可能对编写15条以上的指令感到不知所措。 但是剩下指令的编写过程中，在这里学到的所有内容都将被重用。 大多数指令使用符号扩展，不同模式和更新标志的某种组合。</p><h3 id="LDI"><a href="#LDI" class="headerlink" title="LDI"></a>LDI</h3><p><code>LDI</code>代表“间接加载”。 该指令用于将值从内存中的位置加载到寄存器中。</p><p>二进制布局如下所示：</p><p><img src="https://justinmeiners.github.io/lc3-vm/img/ldi_layout.gif" alt="ldi_layout"></p><p>与<code>ADD</code>相比，<code>LDI</code>没有多种模式，而且参数更少。 此时操作码是<code>1010</code>，它对应于<code>OP_LDI</code>枚举值。 就像ADD一样，它包含一个3位<code>DR</code>（目标寄存器），用于存储加载的值。 其余位标记为<code>PCoffset9</code>。 这是嵌入在指令中的立即值（类似于<code>imm5</code>）。 由于该指令是从内存中加载的，因此我们可以猜测该数字是某种地址，它告诉我们从何处加载。 </p><blockquote><p>通过将bit<code>[8：0]</code>扩展到16位并将该值与递增的PC相加，就可以计算出地址。 内存中此地址存储的就是要加载到<code>DR</code>中的数据的地址。</p></blockquote><p>像之前一样，我们需要对该9位值进行符号扩展，但这一次将其添加到当前<code>PC</code>中。 （如果回头看执行循环，则在加载该指令后<code>PC</code>会立即增加。）结果总和是内存中某个位置的地址，并且该地址还<code>存储着另一个值</code>，该值是等待加载的值的地址。 </p><p>这似乎是一种从内存中读取值的一种迂回方式，但这是必不可少的。 <code>LD</code>指令限于9位的地址偏移量，而存储器需要16位的地址。 <code>LDI</code>对于加载存储在远离当前PC的位置中的值很有用，但是要使用它，最终位置的地址需要存储在附近能访问到的邻居中。 可以理解为它就像在C中具有一个局部变量，该局部变量是指向某些数据的指针：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// the value of far_data is an address</span><span class="token comment" spellcheck="true">// of course far_data itself (the location in memory containing the address) has an address</span><span class="token keyword">char</span><span class="token operator">*</span> far_data <span class="token operator">=</span> <span class="token string">"apple"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// In memory it may be layed out like this:</span><span class="token comment" spellcheck="true">// Address Label      Value</span><span class="token comment" spellcheck="true">// 0x123:  far_data = 0x456</span><span class="token comment" spellcheck="true">// ...</span><span class="token comment" spellcheck="true">// 0x456:  string   = 'a'</span><span class="token comment" spellcheck="true">// if PC was at 0x100</span><span class="token comment" spellcheck="true">// LDI R0 0x023</span><span class="token comment" spellcheck="true">// would load 'a' into R0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与以前一样，将值存入<code>DR</code>后需要更新标志：</p><p>下面是实现案例：(<code>mem_read</code>将会在后续中讨论)</p><pre class="line-numbers language-c"><code class="language-c"><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* destination register (DR) */</span>    uint16_t r0 <span class="token operator">=</span> <span class="token punctuation">(</span>instr <span class="token operator">>></span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x7</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* PCoffset 9*/</span>    uint16_t pc_offset <span class="token operator">=</span> <span class="token function">sign_extend</span><span class="token punctuation">(</span>instr <span class="token operator">&amp;</span> <span class="token number">0x1FF</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* add pc_offset to the current PC, look at that memory location to get the final address */</span>    reg<span class="token punctuation">[</span>r0<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">mem_read</span><span class="token punctuation">(</span><span class="token function">mem_read</span><span class="token punctuation">(</span>reg<span class="token punctuation">[</span>R_PC<span class="token punctuation">]</span> <span class="token operator">+</span> pc_offset<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">update_flags</span><span class="token punctuation">(</span>r0<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>就像之前说的那样，这条指令使用了许多从<code>ADD</code>学到的代码和知识。 在剩下的几个指令的实现中也是同样道理。</p><p>现在，可以去把switch中的剩余case给实现完整。 请遵循<a href="https://justinmeiners.github.io/lc3-vm/supplies/lc3-isa.pdf">规范</a>来完成其他指令。 之前指定的两个操作码将不使用，它们是<code>OP_RTI</code>和<code>OP_RES</code>。 您可以忽略两个指令的实现或者执行这两个指令时抛出错误。 完成后，您的VM的大部分将完成！</p><h2 id="指令实现"><a href="#指令实现" class="headerlink" title="指令实现"></a>指令实现</h2><p>如果遇到困难，本节包含其余说明的完整实现。</p><h3 id="RTI-amp-RES"><a href="#RTI-amp-RES" class="headerlink" title="RTI &amp; RES"></a>RTI &amp; RES</h3><p>(不会用到)</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Bitwise-and-AND"><a href="#Bitwise-and-AND" class="headerlink" title="Bitwise and(AND)"></a><a href="https://en.wikipedia.org/wiki/Bitwise_operation#AND">Bitwise and</a>(AND)</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token punctuation">{</span>    uint16_t r0 <span class="token operator">=</span> <span class="token punctuation">(</span>instr <span class="token operator">>></span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x7</span><span class="token punctuation">;</span>    uint16_t r1 <span class="token operator">=</span> <span class="token punctuation">(</span>instr <span class="token operator">>></span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x7</span><span class="token punctuation">;</span>    uint16_t imm_flag <span class="token operator">=</span> <span class="token punctuation">(</span>instr <span class="token operator">>></span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>imm_flag<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        uint16_t imm5 <span class="token operator">=</span> <span class="token function">sign_extend</span><span class="token punctuation">(</span>instr <span class="token operator">&amp;</span> <span class="token number">0x1F</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        reg<span class="token punctuation">[</span>r0<span class="token punctuation">]</span> <span class="token operator">=</span> reg<span class="token punctuation">[</span>r1<span class="token punctuation">]</span> <span class="token operator">&amp;</span> imm5<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        uint16_t r2 <span class="token operator">=</span> instr <span class="token operator">&amp;</span> <span class="token number">0x7</span><span class="token punctuation">;</span>        reg<span class="token punctuation">[</span>r0<span class="token punctuation">]</span> <span class="token operator">=</span> reg<span class="token punctuation">[</span>r1<span class="token punctuation">]</span> <span class="token operator">&amp;</span> reg<span class="token punctuation">[</span>r2<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">update_flags</span><span class="token punctuation">(</span>r0<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Bitwise-not-NOT"><a href="#Bitwise-not-NOT" class="headerlink" title="Bitwise not(NOT)"></a><a href="https://en.wikipedia.org/wiki/Bitwise_operation#NOT">Bitwise not</a>(NOT)</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token punctuation">{</span>    uint16_t r0 <span class="token operator">=</span> <span class="token punctuation">(</span>instr <span class="token operator">>></span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x7</span><span class="token punctuation">;</span>    uint16_t r1 <span class="token operator">=</span> <span class="token punctuation">(</span>instr <span class="token operator">>></span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x7</span><span class="token punctuation">;</span>    reg<span class="token punctuation">[</span>r0<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">~</span>reg<span class="token punctuation">[</span>r1<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">update_flags</span><span class="token punctuation">(</span>r0<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Branch-BR"><a href="#Branch-BR" class="headerlink" title="Branch(BR)"></a>Branch(BR)</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token punctuation">{</span>    uint16_t pc_offset <span class="token operator">=</span> <span class="token function">sign_extend</span><span class="token punctuation">(</span>instr <span class="token operator">&amp;</span> <span class="token number">0x1FF</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    uint16_t cond_flag <span class="token operator">=</span> <span class="token punctuation">(</span>instr <span class="token operator">>></span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x7</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cond_flag <span class="token operator">&amp;</span> reg<span class="token punctuation">[</span>R_COND<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        reg<span class="token punctuation">[</span>R_PC<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> pc_offset<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Jump-JMP"><a href="#Jump-JMP" class="headerlink" title="Jump(JMP)"></a>Jump(JMP)</h3><p><code>RET</code>在LC-3中被列为单独的指令，因为它是汇编中的另一个关键字。 但是，实际上这是<code>JMP</code>的特例。 只要<code>R1</code>为7，就会发生<code>RET</code>。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* Also handles RET */</span>    uint16_t r1 <span class="token operator">=</span> <span class="token punctuation">(</span>instr <span class="token operator">>></span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x7</span><span class="token punctuation">;</span>    reg<span class="token punctuation">[</span>R_PC<span class="token punctuation">]</span> <span class="token operator">=</span> reg<span class="token punctuation">[</span>r1<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Jump-Register-JSR"><a href="#Jump-Register-JSR" class="headerlink" title="Jump Register(JSR)"></a>Jump Register(JSR)</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token punctuation">{</span>    uint16_t long_flag <span class="token operator">=</span> <span class="token punctuation">(</span>instr <span class="token operator">>></span> <span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">;</span>    reg<span class="token punctuation">[</span>R_R7<span class="token punctuation">]</span> <span class="token operator">=</span> reg<span class="token punctuation">[</span>R_PC<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>long_flag<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        uint16_t long_pc_offset <span class="token operator">=</span> <span class="token function">sign_extend</span><span class="token punctuation">(</span>instr <span class="token operator">&amp;</span> <span class="token number">0x7FF</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        reg<span class="token punctuation">[</span>R_PC<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> long_pc_offset<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* JSR */</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        uint16_t r1 <span class="token operator">=</span> <span class="token punctuation">(</span>instr <span class="token operator">>></span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x7</span><span class="token punctuation">;</span>        reg<span class="token punctuation">[</span>R_PC<span class="token punctuation">]</span> <span class="token operator">=</span> reg<span class="token punctuation">[</span>r1<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* JSRR */</span>    <span class="token punctuation">}</span>    <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Load-LD"><a href="#Load-LD" class="headerlink" title="Load(LD)"></a>Load(LD)</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token punctuation">{</span>    uint16_t r0 <span class="token operator">=</span> <span class="token punctuation">(</span>instr <span class="token operator">>></span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x7</span><span class="token punctuation">;</span>    uint16_t pc_offset <span class="token operator">=</span> <span class="token function">sign_extend</span><span class="token punctuation">(</span>instr <span class="token operator">&amp;</span> <span class="token number">0x1FF</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    reg<span class="token punctuation">[</span>r0<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">mem_read</span><span class="token punctuation">(</span>reg<span class="token punctuation">[</span>R_PC<span class="token punctuation">]</span> <span class="token operator">+</span> pc_offset<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">update_flags</span><span class="token punctuation">(</span>r0<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Load-Register-LDR"><a href="#Load-Register-LDR" class="headerlink" title="Load Register(LDR)"></a>Load Register(LDR)</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token punctuation">{</span>    uint16_t r0 <span class="token operator">=</span> <span class="token punctuation">(</span>instr <span class="token operator">>></span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x7</span><span class="token punctuation">;</span>    uint16_t r1 <span class="token operator">=</span> <span class="token punctuation">(</span>instr <span class="token operator">>></span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x7</span><span class="token punctuation">;</span>    uint16_t offset <span class="token operator">=</span> <span class="token function">sign_extend</span><span class="token punctuation">(</span>instr <span class="token operator">&amp;</span> <span class="token number">0x3F</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    reg<span class="token punctuation">[</span>r0<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">mem_read</span><span class="token punctuation">(</span>reg<span class="token punctuation">[</span>r1<span class="token punctuation">]</span> <span class="token operator">+</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">update_flags</span><span class="token punctuation">(</span>r0<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Load-Effective-Address-LEA"><a href="#Load-Effective-Address-LEA" class="headerlink" title="Load Effective Address(LEA)"></a>Load Effective Address(LEA)</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token punctuation">{</span>    uint16_t r0 <span class="token operator">=</span> <span class="token punctuation">(</span>instr <span class="token operator">>></span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x7</span><span class="token punctuation">;</span>    uint16_t pc_offset <span class="token operator">=</span> <span class="token function">sign_extend</span><span class="token punctuation">(</span>instr <span class="token operator">&amp;</span> <span class="token number">0x1FF</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    reg<span class="token punctuation">[</span>r0<span class="token punctuation">]</span> <span class="token operator">=</span> reg<span class="token punctuation">[</span>R_PC<span class="token punctuation">]</span> <span class="token operator">+</span> pc_offset<span class="token punctuation">;</span>    <span class="token function">update_flags</span><span class="token punctuation">(</span>r0<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Store-ST"><a href="#Store-ST" class="headerlink" title="Store(ST)"></a>Store(ST)</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token punctuation">{</span>    uint16_t r0 <span class="token operator">=</span> <span class="token punctuation">(</span>instr <span class="token operator">>></span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x7</span><span class="token punctuation">;</span>    uint16_t pc_offset <span class="token operator">=</span> <span class="token function">sign_extend</span><span class="token punctuation">(</span>instr <span class="token operator">&amp;</span> <span class="token number">0x1FF</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">mem_write</span><span class="token punctuation">(</span>reg<span class="token punctuation">[</span>R_PC<span class="token punctuation">]</span> <span class="token operator">+</span> pc_offset<span class="token punctuation">,</span> reg<span class="token punctuation">[</span>r0<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Store-Indirect-STI"><a href="#Store-Indirect-STI" class="headerlink" title="Store Indirect(STI)"></a>Store Indirect(STI)</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token punctuation">{</span>    uint16_t r0 <span class="token operator">=</span> <span class="token punctuation">(</span>instr <span class="token operator">>></span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x7</span><span class="token punctuation">;</span>    uint16_t pc_offset <span class="token operator">=</span> <span class="token function">sign_extend</span><span class="token punctuation">(</span>instr <span class="token operator">&amp;</span> <span class="token number">0x1FF</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">mem_write</span><span class="token punctuation">(</span><span class="token function">mem_read</span><span class="token punctuation">(</span>reg<span class="token punctuation">[</span>R_PC<span class="token punctuation">]</span> <span class="token operator">+</span> pc_offset<span class="token punctuation">)</span><span class="token punctuation">,</span> reg<span class="token punctuation">[</span>r0<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Store-Register-STR"><a href="#Store-Register-STR" class="headerlink" title="Store Register(STR)"></a>Store Register(STR)</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token punctuation">{</span>    uint16_t r0 <span class="token operator">=</span> <span class="token punctuation">(</span>instr <span class="token operator">>></span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x7</span><span class="token punctuation">;</span>    uint16_t r1 <span class="token operator">=</span> <span class="token punctuation">(</span>instr <span class="token operator">>></span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x7</span><span class="token punctuation">;</span>    uint16_t offset <span class="token operator">=</span> <span class="token function">sign_extend</span><span class="token punctuation">(</span>instr <span class="token operator">&amp;</span> <span class="token number">0x3F</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">mem_write</span><span class="token punctuation">(</span>reg<span class="token punctuation">[</span>r1<span class="token punctuation">]</span> <span class="token operator">+</span> offset<span class="token punctuation">,</span> reg<span class="token punctuation">[</span>r0<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Trap-Routine"><a href="#Trap-Routine" class="headerlink" title="Trap Routine"></a>Trap Routine</h2><p>LC-3提供了一些预定义的例程(predefined routines)，用于执行常见任务并与I / O设备进行交互。 例如，有一些例程可以从键盘获取输入并在控制台上显示字符串。 这些称为<em>trap routines</em>，您可以将其视为LC-3或操作系统的API。 每个<em>trap routines</em>都分配有一个标识它的<em>trap code</em>（类似于操作码）。 如果想要执行其中一个，用所需例程的 <em>trap code</em>调用TRAP指令。</p><p><img src="https://justinmeiners.github.io/lc3-vm/img/trap_layout.gif" alt="trap_layout"></p><p>为每个trap code定义一个枚举：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">enum</span><span class="token punctuation">{</span>    TRAP_GETC <span class="token operator">=</span> <span class="token number">0x20</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">/* get character from keyboard, not echoed onto the terminal */</span>    TRAP_OUT <span class="token operator">=</span> <span class="token number">0x21</span><span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">/* output a character */</span>    TRAP_PUTS <span class="token operator">=</span> <span class="token number">0x22</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">/* output a word string */</span>    TRAP_IN <span class="token operator">=</span> <span class="token number">0x23</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">/* get character from keyboard, echoed onto the terminal */</span>    TRAP_PUTSP <span class="token operator">=</span> <span class="token number">0x24</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">/* output a byte string */</span>    TRAP_HALT <span class="token operator">=</span> <span class="token number">0x25</span>   <span class="token comment" spellcheck="true">/* halt the program */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可能想知道为什么指令中不包含陷阱代码。 这是因为陷阱代码实际上并未向LC-3引入任何新功能，而只是提供了一种方便的方式来执行任务（类似于C中的系统功能）。 在官方的LC-3仿真器中，陷阱例程以汇编形式编写。 调用陷阱代码时，会将PC移至该代码的地址。 CPU执行该过程的指令，完成后，将PC重置为调用陷阱的位置。</p><blockquote><p>注意：这就是为什么程序从地址0x3000而不是0x0开始的原因。 低位地址留空，以留出陷阱例程代码的空间。</p></blockquote><p>其实并没有任何关于必须如何执行trap routines的规定，只有应该执行的trap routines应该实现什么。 在我们的虚拟机中，我们将通过用C编写它们来做一些稍有不同的事情。调用trap routines时，将调用C函数。 完成后，执行将返回指令。</p><p>即使trap routines可以用汇编语言编写，而且这实际上是一台LC-3计算机的工作方式，但这并不是最适合虚拟机的方法。 除了编写自己的原始I / O例程，我们还可以利用OS上可用的例程。 这将使VM在我们的计算机上更好地运行，简化代码，并为可移植性提供更高级别的抽象。</p><blockquote><p>注意：从键盘获取输入就是一个具体示例。 汇编版本使用循环来连续检查键盘的输入。 这会浪费大量的CPU时间！ 使用适当的OS输入功能可使程序进入休眠状态，直到接收到输入为止。</p></blockquote><p>在操作码有关<strong>Trap</strong>的switch case中，添加一个switch：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">switch</span> <span class="token punctuation">(</span>instr <span class="token operator">&amp;</span> <span class="token number">0xFF</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">case</span> TRAP_GETC<span class="token punctuation">:</span>        <span class="token punctuation">{</span>TRAP GETC<span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">}</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> TRAP_OUT<span class="token punctuation">:</span>        <span class="token punctuation">{</span>TRAP OUT<span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">}</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> TRAP_PUTS<span class="token punctuation">:</span>        <span class="token punctuation">{</span>TRAP PUTS<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">}</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> TRAP_IN<span class="token punctuation">:</span>        <span class="token punctuation">{</span>TRAP IN<span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">}</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> TRAP_PUTSP<span class="token punctuation">:</span>        <span class="token punctuation">{</span>TRAP PUTSP<span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">}</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> TRAP_HALT<span class="token punctuation">:</span>        <span class="token punctuation">{</span>TRAP HALT<span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">}</span>        <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与其他指令一样，接下来将演示如何实现单个陷阱例程，并将其余部分可以由自己实现。</p><h3 id="PUTS"><a href="#PUTS" class="headerlink" title="PUTS"></a>PUTS</h3><p><code>PUTS</code>的trap code用于输出以空值结尾的字符串（类似于C中的<code>printf</code>）。</p><p>要显示一个字符串，我们必须给trap routine一个要显示的字符串。 这是通过在开始自陷(trap)之前将第一个字符的地址存储在<code>R0</code>中来完成的。</p><blockquote><p>将一串ASCII字符写入控制台显示屏。 这些字符存储在在连续的存储位置中，每个存储位置一个字符，从<code>R0</code>中指定的地址开始。 写入终止于在存储单元中出现<code>x0000</code>。</p></blockquote><p>请注意，与C字符串不同，字符不是存储在单个字节中，而是存储在<em>单个存储位置</em>中。 LC-3中的存储位置为16位，因此字符串中的每个字符均为16位宽。 要使用C函数显示此内容，我们需要将每个值转换为char并分别输出。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* one char per word */</span>    uint16_t<span class="token operator">*</span> c <span class="token operator">=</span> memory <span class="token operator">+</span> reg<span class="token punctuation">[</span>R_R0<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>c<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">putc</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token operator">*</span>c<span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">++</span>c<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这就是例程的全部内容。 如果熟悉C的话那么trap routines非常简单。接下来请实施其他例程。 </p><h2 id="Trap-Routine-实现"><a href="#Trap-Routine-实现" class="headerlink" title="Trap Routine 实现"></a>Trap Routine 实现</h2><p>本节包含其余Trap Routine的完整实现。</p><h3 id="Input-Character-GETC"><a href="#Input-Character-GETC" class="headerlink" title="Input Character(GETC)"></a>Input Character(GETC)</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* read a single ASCII char */</span>reg<span class="token punctuation">[</span>R_R0<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>uint16_t<span class="token punctuation">)</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="Output-Character-OUT"><a href="#Output-Character-OUT" class="headerlink" title="Output Character(OUT)"></a>Output Character(OUT)</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token function">putc</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span>reg<span class="token punctuation">[</span>R_R0<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="Prompt-for-Input-Character-IN"><a href="#Prompt-for-Input-Character-IN" class="headerlink" title="Prompt for Input Character(IN)"></a>Prompt for Input Character(IN)</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Enter a character: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">putc</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    reg<span class="token punctuation">[</span>R_R0<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>uint16_t<span class="token punctuation">)</span>c<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Output-String-PUTSP"><a href="#Output-String-PUTSP" class="headerlink" title="Output String(PUTSP)"></a>Output String(PUTSP)</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* one char per byte (two bytes per word)       here we need to swap back to       big endian format */</span>    uint16_t<span class="token operator">*</span> c <span class="token operator">=</span> memory <span class="token operator">+</span> reg<span class="token punctuation">[</span>R_R0<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>c<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">char</span> char1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xFF</span><span class="token punctuation">;</span>        <span class="token function">putc</span><span class="token punctuation">(</span>char1<span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">char</span> char2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>char2<span class="token punctuation">)</span> <span class="token function">putc</span><span class="token punctuation">(</span>char2<span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">++</span>c<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Halt-Program-HALT"><a href="#Halt-Program-HALT" class="headerlink" title="Halt Program(HALT)"></a>Halt Program(HALT)</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"HALT"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>running <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="程序加载"><a href="#程序加载" class="headerlink" title="程序加载"></a>程序加载</h2><p>我们已经学习了很多关于从内存中加载和执行指令的知识，但是指令首先是如何进入内存的呢？ 将汇编程序转换为机器代码时，结果是一个包含指令和数据数组的文件。 只需将内容直接复制到内存中的地址中即可加载该文件。</p><p>程序文件的前16位指定程序应在内存中启动的地址。 此地址称为<code>原点(origin)</code>。 必须先读取它，然后才能从起始地址开始将其余数据从文件读取到内存中。</p><p>这是用于将LC-3程序读入内存的代码：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">read_image_file</span><span class="token punctuation">(</span>FILE<span class="token operator">*</span> file<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* the origin tells us where in memory to place the image */</span>    uint16_t origin<span class="token punctuation">;</span>    <span class="token function">fread</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>origin<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>origin<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> file<span class="token punctuation">)</span><span class="token punctuation">;</span>    origin <span class="token operator">=</span> <span class="token function">swap16</span><span class="token punctuation">(</span>origin<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* we know the maximum file size so we only need one fread */</span>    uint16_t max_read <span class="token operator">=</span> UINT16_MAX <span class="token operator">-</span> origin<span class="token punctuation">;</span>    uint16_t<span class="token operator">*</span> p <span class="token operator">=</span> memory <span class="token operator">+</span> origin<span class="token punctuation">;</span>    size_t read <span class="token operator">=</span> <span class="token function">fread</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>uint16_t<span class="token punctuation">)</span><span class="token punctuation">,</span> max_read<span class="token punctuation">,</span> file<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* swap to little endian */</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>read<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">swap16</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">++</span>p<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，在每个加载的值上调用了<code>swap16</code>。 因为LC-3程序是大端的，但是我们使用的大多数现代计算机都是小端。 因此我们需要交换每个已加载的uint16。 （如果碰巧使用的是奇怪的计算机（例如PPC），则不应进行交换。）</p><pre class="line-numbers language-c"><code class="language-c">uint16_t <span class="token function">swap16</span><span class="token punctuation">(</span>uint16_t x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>NOTE：</strong> 字节顺序是指如何解释整数的字节。 在小字节序中，第一个字节是最低有效数字，在大字节序中，它是相反的。 据我所知，该决定主要是任意的。 不同的公司做出不同的决定，所以现在我们有了不同的实现方式。 您不需要了解有关此项目的字节序的其他信息。</p></blockquote><p>还可以为<code>read_image_file</code>添加一个便捷函数，该函数采用字符串路径；</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">read_image</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> image_path<span class="token punctuation">)</span><span class="token punctuation">{</span>    FILE<span class="token operator">*</span> file <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>image_path<span class="token punctuation">,</span> <span class="token string">"rb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>file<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">read_image_file</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fclose</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="存储器映射寄存器"><a href="#存储器映射寄存器" class="headerlink" title="存储器映射寄存器"></a>存储器映射寄存器</h2><p>有时无法从普通寄存器表访问某些特殊寄存器。 此时需要为它们在存储器中保留一个特殊的地址。 要读写这些寄存器，只需读写它们的存储位置。 这些称为存储器映射寄存器。 它们通常用于与特殊的硬件设备进行交互。</p><p>LC-3具有两个需要实现的存储器映射寄存器。 它们是键盘状态寄存器（<code>KBSR</code>）和键盘数据寄存器（<code>KBDR</code>）。 <code>KBSR</code>指示是否已按下某个键，<code>KBDR</code>标识已按下哪个键。</p><p>尽管可以使用<code>GETC</code>请求键盘输入，但这会阻塞住直到收到输入。 <code>KBSR</code>和<code>KBDR</code>允许您轮询设备的状态并继续执行，因此程序可以在等待输入时保持响应状态。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">enum</span><span class="token punctuation">{</span>    MR_KBSR <span class="token operator">=</span> <span class="token number">0xFE00</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">/* keyboard status */</span>    MR_KBDR <span class="token operator">=</span> <span class="token number">0xFE02</span>  <span class="token comment" spellcheck="true">/* keyboard data */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>存储器映射寄存器使访存更加复杂。 我们不能直接读写存储阵列，而必须调用setter和getter函数。 从<code>KBSR</code>读取内存时，getter将检查键盘并更新两个存储位置。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">mem_write</span><span class="token punctuation">(</span>uint16_t address<span class="token punctuation">,</span> uint16_t val<span class="token punctuation">)</span><span class="token punctuation">{</span>    memory<span class="token punctuation">[</span>address<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span><span class="token punctuation">}</span>uint16_t <span class="token function">mem_read</span><span class="token punctuation">(</span>uint16_t address<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>address <span class="token operator">==</span> MR_KBSR<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">check_key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            memory<span class="token punctuation">[</span>MR_KBSR<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            memory<span class="token punctuation">[</span>MR_KBDR<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            memory<span class="token punctuation">[</span>MR_KBSR<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> memory<span class="token punctuation">[</span>address<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就完成了虚拟机的最后一个组件！ 只要您实现了其余的trap routines和指令，几乎就可以运行了。</p><pre><code>{Memory Mapped Registers}{TRAP Codes}{Memory Storage}{Register Storage}{Sign Extend}{Swap}{Update Flags}{Read Image File}{Read Image}{Check Key}{Memory Access}{Input Buffering}{Handle Interrupt}{Main Loop}</code></pre><h2 id="平台特性-Unix"><a href="#平台特性-Unix" class="headerlink" title="平台特性(Unix)"></a>平台特性(Unix)</h2><p>本节包含一些繁琐的细节，这些细节对于使用键盘和使功能表现良好而言是必需的。 这些不是必须学习的，不与学习虚拟机有关。 随时复制粘贴！</p><p>注意：跳至下一部分，以获取这些功能的Windows版本。</p><pre class="line-numbers language-c"><code class="language-c">uint16_t <span class="token function">check_key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    fd_set readfds<span class="token punctuation">;</span>    <span class="token function">FD_ZERO</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>readfds<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">FD_SET</span><span class="token punctuation">(</span>STDIN_FILENO<span class="token punctuation">,</span> <span class="token operator">&amp;</span>readfds<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> timeval timeout<span class="token punctuation">;</span>    timeout<span class="token punctuation">.</span>tv_sec <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    timeout<span class="token punctuation">.</span>tv_usec <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>readfds<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>timeout<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是Unix专用代码，用于设置终端输入。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> termios original_tio<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">disable_input_buffering</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">tcgetattr</span><span class="token punctuation">(</span>STDIN_FILENO<span class="token punctuation">,</span> <span class="token operator">&amp;</span>original_tio<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> termios new_tio <span class="token operator">=</span> original_tio<span class="token punctuation">;</span>    new_tio<span class="token punctuation">.</span>c_lflag <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token operator">~</span>ICANON <span class="token operator">&amp;</span> <span class="token operator">~</span>ECHO<span class="token punctuation">;</span>    <span class="token function">tcsetattr</span><span class="token punctuation">(</span>STDIN_FILENO<span class="token punctuation">,</span> TCSANOW<span class="token punctuation">,</span> <span class="token operator">&amp;</span>new_tio<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">restore_input_buffering</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">tcsetattr</span><span class="token punctuation">(</span>STDIN_FILENO<span class="token punctuation">,</span> TCSANOW<span class="token punctuation">,</span> <span class="token operator">&amp;</span>original_tio<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">handle_interrupt</span><span class="token punctuation">(</span><span class="token keyword">int</span> signal<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">restore_input_buffering</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c"><code class="language-c"><span class="token function">signal</span><span class="token punctuation">(</span>SIGINT<span class="token punctuation">,</span> handle_interrupt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">disable_input_buffering</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当程序中断时，我们希望将终端设置恢复为正常。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">restore_input_buffering</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;signal.h></span></span><span class="token comment" spellcheck="true">/* unix */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/time.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/termios.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/mman.h></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="平台特性-Windows"><a href="#平台特性-Windows" class="headerlink" title="平台特性(Windows)"></a>平台特性(Windows)</h2><p>本节包含一些繁琐的细节，这些细节对于使用键盘和使功能表现良好而言是必需的。 这些不是必须学习的，不与学习虚拟机有关。 随时复制粘贴！</p><p>注意：如果已经包含Unix版本，请不要添加这些版本！</p><pre class="line-numbers language-c"><code class="language-c">uint16_t <span class="token function">check_key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">WaitForSingleObject</span><span class="token punctuation">(</span>hStdin<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token operator">==</span> WAIT_OBJECT_0 <span class="token operator">&amp;&amp;</span> <span class="token function">_kbhit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c"><code class="language-c">DWORD fdwMode<span class="token punctuation">,</span> fdwOldMode<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">disable_input_buffering</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    hStdin <span class="token operator">=</span> <span class="token function">GetStdHandle</span><span class="token punctuation">(</span>STD_INPUT_HANDLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">GetConsoleMode</span><span class="token punctuation">(</span>hStdin<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fdwOldMode<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* save old mode */</span>    fdwMode <span class="token operator">=</span> fdwOldMode            <span class="token operator">^</span> ENABLE_ECHO_INPUT  <span class="token comment" spellcheck="true">/* no input echo */</span>            <span class="token operator">^</span> ENABLE_LINE_INPUT<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* return when one or                                    more characters are available */</span>    <span class="token function">SetConsoleMode</span><span class="token punctuation">(</span>hStdin<span class="token punctuation">,</span> fdwMode<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* set new mode */</span>    <span class="token function">FlushConsoleInputBuffer</span><span class="token punctuation">(</span>hStdin<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* clear buffer */</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">restore_input_buffering</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">SetConsoleMode</span><span class="token punctuation">(</span>hStdin<span class="token punctuation">,</span> fdwOldMode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c"><code class="language-c"><span class="token function">signal</span><span class="token punctuation">(</span>SIGINT<span class="token punctuation">,</span> handle_interrupt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">disable_input_buffering</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当程序中断时，我们希望将终端设置恢复为正常。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">restore_input_buffering</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h></span> </span><span class="token comment" spellcheck="true">// uint16_t</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span>  </span><span class="token comment" spellcheck="true">// FILE</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;signal.h></span> </span><span class="token comment" spellcheck="true">// SIGINT</span><span class="token comment" spellcheck="true">/* windows only */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;Windows.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;conio.h></span>  </span><span class="token comment" spellcheck="true">// _kbhit</span>HANDLE hStdin <span class="token operator">=</span> INVALID_HANDLE_VALUE<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="运行虚拟机"><a href="#运行虚拟机" class="headerlink" title="运行虚拟机"></a>运行虚拟机</h2><p>现在可以构建并运行LC-3 VM！</p><ol><li><p>使用您最喜欢的C编译器进行编译。 对于<code>gcc：$ gcc lc3.c -o lc3</code></p></li><li><p>下载2048或Rogue的汇编版本。</p></li><li><p>使用obj文件作为参数运行程序：</p></li><li><p>$ lc3 path/to/2048.obj</p></li></ol><p>玩2048！</p><pre><code>Control the game using WASD keys.Are you on an ANSI terminal (y/n)? y+--------------------------+|                          ||                          ||                          ||                     2    ||                          ||   2                      ||                          ||                          ||                          |+--------------------------+</code></pre><h3 id="Debugging"><a href="#Debugging" class="headerlink" title="Debugging"></a>Debugging</h3><p>如果程序无法正常运行，则可能是因为对指令的编程不正确。 这可能很难调试。 我建议通读LC-3程序的汇编源代码，同时使用调试器一次遍历虚拟机的指令。 在阅读程序集时，请确保虚拟机按照您期望的说明进行操作。 如果出现差异，则知道引起该问题的原因。 重新阅读其说明说并仔细检查代码。</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Virtual Machine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell编程小结(二)</title>
      <link href="posts/32059/"/>
      <url>posts/32059/</url>
      
        <content type="html"><![CDATA[<h2 id="文件系统操作"><a href="#文件系统操作" class="headerlink" title="文件系统操作"></a>文件系统操作</h2><h3 id="文件系统在-Linux-操作系统中的位置"><a href="#文件系统在-Linux-操作系统中的位置" class="headerlink" title="文件系统在 Linux 操作系统中的位置"></a>文件系统在 Linux 操作系统中的位置</h3><p>如何来认识文件系统呢？从 Shell 程序员的角度来看，文件系统就是一个用来组织各种文件的方法。但是文件系统无法独立于硬件存储设备和操作系统而存在，因此还是有必要来弄清楚硬件存储设备、分区、操作系统、逻辑卷、文件系统等各种概念之间的联系，以便理解文件系统常规操作的一些“细节”。这个联系或许（也许会有一些问题）可以通过这样一种方式来呈现：</p><p><img src="https://tinylab.gitbooks.io/shellbook/content/zh/chapters/pic/Linux_FileSystem_Architecture.jpg" alt="Linux_FileSystem_Architecture"></p><p>从图中可以清晰地看到各个“概念”之间的关系，它们以不同层次分布，覆盖硬件设备、系统内核空间、系统用户空间。在用户空间，用户可以不管内核如何操作具体硬件设备，仅仅使用程序员设计的各种界面就可以，而普通程序员也仅仅需要利用内核提供的各种接口（System Call）或者一些C库来和内核进行交互，而无须关心具体的实现细节。不过对于操作系统开发人员，他们需要在内核空间设计特定的数据结构来管理和组织底层的硬件设备。</p><p>下面从下到上的方式（即从底层硬件开始），用工具来分析和理解图中几个重要概念。（如果有兴趣，可以先看看下面的几则资料）</p><p>参考资料：</p><ul><li><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-vfs/">从文件 I/O 看 Linux 的虚拟文件系统</a></li><li><a href="http://www.ibm.com/developerworks/cn/linux/l-linux-filesystem/index.html?ca=drs-cn">Linux 文件系统剖析</a></li></ul><h3 id="硬件管理和设备驱动"><a href="#硬件管理和设备驱动" class="headerlink" title="硬件管理和设备驱动"></a>硬件管理和设备驱动</h3><p>Linux 系统通过设备驱动管理硬件设备。如果添加了新的硬件设备，那么需要编写相应的硬件驱动来管理它。对于一些常见的硬件设备，系统已经自带了相应的驱动，编译内核时，选中它们，然后编译成内核的一部分或者以模块的方式编译。如果以模块的方式编译，那么可以在系统的 <code>/lib/modules/$(uname -r)</code>目录下找到对应的模块文件。</p><h4 id="范例：查找设备所需的驱动文件"><a href="#范例：查找设备所需的驱动文件" class="headerlink" title="范例：查找设备所需的驱动文件"></a>范例：查找设备所需的驱动文件</h4><p>比如，可以这样找到相应的 scsi 驱动和 usb 驱动对应的模块文件：</p><p>更新系统中文件索引数据库(有点慢）</p><pre class="line-numbers language-bash"><code class="language-bash">$ updatedb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查找 scsi 相关的驱动</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">locate</span> scsi*.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查找 usb 相关的驱动</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">locate</span> usb*.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这些驱动以 <code>.ko</code> 为后缀，在安装系统时默认编译为了模块。实际上可以把它们编译为内核的一部分，仅仅需要在编译内核时选择为<code>[*]</code>即可。但是，很多情况下会以模块的方式编译它们，这样可以减少内核的大小，并根据需要灵活地加载和卸载它们。下面简单地演示如何卸载模块、加载模块以及查看已加载模块的状态。</p><p>可通过 <code>/proc</code> 文件系统的 <code>modules</code> 文件检查内核中已加载的各个模块的状态，也可以通过 <code>lsmod</code> 命令直接查看它们。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> /proc/modules<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-bash"><code class="language-bash">$ lsmod<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="范例：查看已经加载的设备驱动"><a href="#范例：查看已经加载的设备驱动" class="headerlink" title="范例：查看已经加载的设备驱动"></a>范例：查看已经加载的设备驱动</h4><p>查看 scsi 和 usb 相关驱动，结果各列为模块名、模块大小、被其他模块的引用情况（引用次数、引用它们的模块）</p><pre class="line-numbers language-bash"><code class="language-bash">$ lsmod <span class="token operator">|</span> <span class="token function">egrep</span> <span class="token string">"scsi|usb"</span>usbhid                 29536  0hid                    28928  1 usbhidusbcore               138632  4 usbhid,ehci_hcd,ohci_hcdscsi_mod              147084  4 sg,sr_mod,sd_mod,libata<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="范例：卸载设备驱动"><a href="#范例：卸载设备驱动" class="headerlink" title="范例：卸载设备驱动"></a>范例：卸载设备驱动</h4><p>下面卸载 <code>usbhid</code> 模块看看（不要卸载scsi的驱动！因为你的系统可能就跑在上面，如果确实想玩玩，卸载前记得保存数据），通过 <code>rmmod</code> 命令就可以实现，先切换到 Root 用户：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> -s<span class="token comment" spellcheck="true"># rmmod usbhid</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>再查看该模块的信息，已经看不到了吧</p><pre class="line-numbers language-bash"><code class="language-bash">$ lsmod <span class="token operator">|</span> <span class="token function">grep</span> ^usbhid<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="范例：挂载设备驱动"><a href="#范例：挂载设备驱动" class="headerlink" title="范例：挂载设备驱动"></a>范例：挂载设备驱动</h4><p>如果有个 usb 鼠标，那么移动一下，是不是发现动不了啦？因为设备驱动都没有了，设备自然就没法用罗。不过不要紧张，既然知道原因，那么重新加载驱动就可以，下面用 <code>insmod</code> 把 <code>usbhid</code> 模块重新加载上。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> -s<span class="token comment" spellcheck="true"># insmod `locate usbhid.ko`</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>locate usbhid.ko</code> 是为了找出 <code>usbhid.ko</code> 模块的路径，如果之前没有 <code>updatedb</code>，估计用它是找不到了，不过也可以直接到 <code>/lib/modules</code> 目录下用 <code>find</code> 把 <code>usbhid.ko</code> 文件找到。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># insmod $(find /lib/modules -name "*usbhid.ko*" | grep `uname -r`)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在鼠标又可以用啦，不信再动一下鼠标 :-)</p><p>到这里，硬件设备和设备驱动之间关系应该是比较清楚了。如果没有，那么继续下面的内容。</p><h4 id="范例：查看设备驱动对应的设备文件"><a href="#范例：查看设备驱动对应的设备文件" class="headerlink" title="范例：查看设备驱动对应的设备文件"></a>范例：查看设备驱动对应的设备文件</h4><p>Linux 设备驱动关联着相应的设备文件，而设备文件则和硬件设备一一对应。这些设备文件都统一存放在系统的 <code>/dev/</code> 目录下。</p><p>例如，scsi 设备对应<code>/dev/sda</code>，<code>/dev/sda1</code>，<code>/dev/sda2</code>… 下面查看这些设备信息。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ls</span> -l /dev/sda*brw-rw---- 1 root disk 8, 0 2007-12-28 22:49 /dev/sdabrw-rw---- 1 root disk 8, 1 2007-12-28 22:50 /dev/sda1brw-rw---- 1 root disk 8, 3 2007-12-28 22:49 /dev/sda3brw-rw---- 1 root disk 8, 4 2007-12-28 22:49 /dev/sda4brw-rw---- 1 root disk 8, 5 2007-12-28 22:50 /dev/sda5brw-rw---- 1 root disk 8, 6 2007-12-28 22:50 /dev/sda6brw-rw---- 1 root disk 8, 7 2007-12-28 22:50 /dev/sda7brw-rw---- 1 root disk 8, 8 2007-12-28 22:50 /dev/sda8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到第一列第一个字符都是 <code>b</code>，第五列都是数字 8 。 <code>b</code> 表示该文件是一个块设备文件，对应地，如果是 <code>c</code> 则表示字符设备（例如 `/dev/ttyS0)，关于块设备和字符设备的区别，可以看这里：</p><blockquote><ul><li><p>字符设备：字符设备就是能够像字节流一样访问的设备，字符终端和串口就属于字符设备。</p></li><li><p>块设备：块设备上可以容纳文件系统。与字符设备不同，在读写时，块设备每次只能传输一个或多个完整的块。在 Linux 操作系统中，应用程序可以像访问字符设备一样读写块设备（一次读取或写入任意的字节数据）。因此，块设备和字符设备的区别仅仅是在内核中对于数据的管理不同。</p></li></ul></blockquote><p>数字 8 则是该硬件设备在内核中对应的设备编号，可以在内核的 <code>Documentation/devices.txt</code> 和 <code>/proc/devices</code> 文件中找到设备号分配情况。但是为什么同一个设备会对应不同的设备文件（<code>/dev/sda</code> 后面为什么还有不同的数字，而且 <code>ls</code> 结果中的第 6 列和它们对应起来）。这实际上是为了区分不同设备的不同部分。对于硬盘，这样可以处理硬盘内部的不同分区。就内核而言，它仅仅需要通过第 5 列的设备号就可以找到对应的硬件设备，但是对于驱动模块来说，它还需要知道如何处理不同的分区，于是就多了一个辅设备号，即第 6 列对应的内容。这样一个设备就有了主设备号（第 5 列）和辅设备号（第 6 列），从而方便地实现对各种硬件设备的管理。</p><p>因为设备文件和硬件是对应的，这样可以直接从 <code>/dev/sda</code> （如果是 <code>IDE</code> 的硬盘，那么对应的设备就是 <code>/dev/hda</code> 啦）设备中读出硬盘的信息，例如：</p><h4 id="范例：访问设备文件"><a href="#范例：访问设备文件" class="headerlink" title="范例：访问设备文件"></a>范例：访问设备文件</h4><p>用 <code>dd</code> 命令复制出硬盘的前 512 个字节，要 Root 用户</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">dd</span> if<span class="token operator">=</span>/dev/sda of<span class="token operator">=</span>mbr.bin bs<span class="token operator">=</span>512 count<span class="token operator">=</span>1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用 <code>file</code> 命令查看相应的信息</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">file</span> mbr.binmbr.bin: x86 boot sector, LInux i386 boot LOader<span class="token punctuation">;</span> partition 3: ID<span class="token operator">=</span>0x82, starthead 254, startsector 19535040, 1959930 sectors<span class="token punctuation">;</span> partition 4: ID<span class="token operator">=</span>0x5, starthead 254, startsector 21494970, 56661255 sectors, code offset 0x48<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>也可以用 <code>od</code> 命令以 16 进制的形式读取并进行分析</p><pre class="line-numbers language-bash"><code class="language-bash">$ od -x mbr.bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>bs</code> 是块的大小（以字节 <code>bytes</code> 为单位），<code>count</code> 是块数</p><p>因为这些信息并不直观（而且下面会进一步深入分析），那么先来看看另外一个设备文件，将可以非常直观地演示设备文件和硬件的对应关系。还是以鼠标为例吧，下面来读取鼠标对应的设备文件的信息。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> -s<span class="token comment" spellcheck="true"># cat /dev/input/mouse1 | od -x</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>你的鼠标驱动可能不太一样，所以设备文件可能是其他的，但是都会在 <code>/dev/input</code> 下。</p><p>移动鼠标看看，是不是发现有不同信息输出。基于这一原理，我们经常通过在一端读取设备文件 <code>/dev/ttyS0</code> 中的内容，而在另一端往设备文件 <code>/dev/ttyS0</code> 中写入内容来检查串口线是否被损坏。</p><p>到这里，对设备驱动、设备文件和硬件设备之间的关联应该是印象更深刻了。如果想深入了解设备驱动的工作原理和设备驱动的编写，那么看看下面列出的相关资料，开始设备驱动的编写历程吧。</p><p>参考资料：</p><ul><li><a href="http://www.cyberciti.biz/tips/compiling-linux-kernel-26.html">Compile linux kernel 2.6</a></li><li><a href="http://www.blue1000.com/bkhtml/2001-02/2409.htm">Linux 系统的硬件驱动程序编写原理</a></li><li><a href="http://soft.zdnet.com.cn/software_zone/2007/1108/617545.shtml">Linux 下 USB设备的原理、配置、常见问题</a></li><li><a href="http://www.tldp.org/LDP/lkmpg/2.6/html/lkmpg.html">The Linux Kernel Module Programming Guide</a></li><li><a href="http://lwn.net/Kernel/LDD3/">Linux 设备驱动开发</a></li></ul><h3 id="理解、查看磁盘分区"><a href="#理解、查看磁盘分区" class="headerlink" title="理解、查看磁盘分区"></a>理解、查看磁盘分区</h3><p>实际上内存、u 盘等都可以作为文件系统底层的“存储”设备，但是这里仅用硬盘作为实例来介绍磁盘和分区的关系。</p><p>目前 Linux 的分区依然采用第一台PC硬盘所使用的分区原理，下面逐步分析和演示这一分区原理。</p><h4 id="磁盘分区基本原理"><a href="#磁盘分区基本原理" class="headerlink" title="磁盘分区基本原理"></a>磁盘分区基本原理</h4><p>先来看看几个概念：</p><ul><li><p>设备管理和分区</p><p>Linux 下，每一个存储设备对应一个系统的设备文件，对于硬盘等 <code>IDE</code> 和 <code>SCSI</code> 设备，在系统的 <code>/dev</code> 目录下可以找到对应的包含字符 <code>hd</code> 和 <code>sd</code> 的设备文件。而根据硬盘连接的主板设备接口和数据线接口的不同，在 <code>hd</code> 或者 <code>sd</code> 字符后面可以添加一个从 <code>a</code> 到 <code>z</code> 的字符，例如 <code>hda</code>，<code>hdb</code>，<code>hdc</code> 和 <code>sda</code>，<code>sdb</code>，<code>sdc</code> 等，另外为了区别同一个硬件设备的不同分区，在后面还可以添加了一个数字，例如 <code>hda1</code>，<code>hda2</code>，<code>hda3</code> 和 <code>sda1</code>，<code>sda2</code>，<code>sda3</code>，所以在 <code>/dev</code> 目录下，可以看到很多类似的设备文件。</p></li><li><p>各分区的作用</p></li></ul><p>在分区时常遇到主分区和逻辑分区的问题，这实际上是为了方便扩展分区，正如后面的逻辑卷的引入是为了更好地管理多个硬盘一样，引入主分区和逻辑分区可以方便地进行分区的管理。</p><p>Linux 系统中每一个硬盘设备最多由 4 个主分区（包括扩展分区）构成。</p><p>主分区的作用是计算机用来进行启动操作系统的，因此每一个操作系统的启动程序或者称作是引导程序，都应该存放在主分区上。 Linux 规定主分区（或者扩展分区）占用分区编号中的前 4 个。所以会看到主分区对应的设备文件为 <code>/dev/hda1-4</code> 或者 <code>/dev/sda1-4</code>，而不会是 <code>hda5</code> 或者 <code>sda5</code> 。</p><p>扩展分区则是为了扩展更多的逻辑分区的，在 Linux 下，逻辑分区占用了 <code>hda5-16</code> 或者 <code>sda5-16</code> 等 12 个编号。</p><ul><li>分区类型</li></ul><p>它规定了这个分区上的文件系统的类型。Linux支持诸如msdoc,vfat,ext2,ext3等诸多的文件系统类型，更多信息在下一小节进行进一步的介绍。</p><h4 id="通过分析-MBR-来理解分区原理"><a href="#通过分析-MBR-来理解分区原理" class="headerlink" title="通过分析 MBR 来理解分区原理"></a>通过分析 MBR 来理解分区原理</h4><p>下面通过分析硬盘的前 512 个字节（即 <code>MBR</code>）来分析和理解分区。</p><p>先来看看这张图：</p><p><img src="https://tinylab.gitbooks.io/shellbook/content/zh/chapters/pic/MBR_Architecture.jpg" alt="MBR_Architecture"></p><p>它用来描述 <code>MBR</code> 的结构。 <code>MBR</code> 包括引导部分、分区表、以及结束标记 `(55AAH)，分别占用了 512 字节中 446 字节、 64 字节和 2 字节。这里仅仅关注分区表部分，即中间的 64 字节以及图中左边的部分。</p><p>由于我用的是 <code>SCSI</code> 的硬盘，下面从 <code>/dev/sda</code> 设备中把硬盘的前 512 个字节拷贝到文件 <code>mbr.bin</code> 中。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> -s<span class="token comment" spellcheck="true"># dd if=/dev/sda of=mbr.bin bs=512 count=1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>下面用 <code>file</code>，<code>od</code>，<code>fdisk</code> 等命令来分析这段 <code>MBR</code> 的数据，并对照上图以便加深理解。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">file</span> mbr.binmbr.bin: x86 boot sector, LInux i386 boot LOader<span class="token punctuation">;</span> partition 3: ID<span class="token operator">=</span>0x82, starthead 254, startsector 19535040, 1959930 sectors<span class="token punctuation">;</span> partition 4: ID<span class="token operator">=</span>0x5, starthead 254, startsector 21494970, 56661255 sectors, code offset 0x48$ od -x mbr.bin <span class="token operator">|</span> <span class="token function">tail</span> -6   <span class="token comment" spellcheck="true">#仅关注中间的64字节，所以截取了结果中后6行</span>0000660 0000 0000 0000 0000 a666 a666 0000 01800000700 0001 fe83 ffff 003f 0000 1481 012a 00000000720 0000 0000 0000 0000 0000 0000 0000 fe000000740 ffff fe82 ffff 14c0 012a e7fa 001d fe000000760 ffff fe05 ffff fcba 0147 9507 0360 aa55$ <span class="token function">sudo</span> -s<span class="token comment" spellcheck="true"># fdisk -l | grep ^/  #仅分析MBR相关的部分，不分析逻辑分区部分</span>/dev/sda1   *           1        1216     9767488+  83  Linux/dev/sda3            1217        1338      979965   82  Linux swap / Solaris/dev/sda4            1339        4865    28330627+   5  Extended<span class="token function">file</span><span class="token variable"><span class="token variable">`</span> 命令的结果显示，刚拷贝的 512 字节是启动扇区，用分号分开的几个部分分别是 <span class="token variable">`</span></span>bootloader<span class="token variable"><span class="token variable">`</span>，分区 3 和分区 4 。分区 3 的类型是 82，即 <span class="token variable">`</span></span>swap<span class="token variable"><span class="token variable">`</span> 分区（可以通过 <span class="token variable">`</span></span><span class="token function">fdisk</span><span class="token variable"><span class="token variable">`</span> 命令的 <span class="token variable">`</span></span>l<span class="token variable"><span class="token variable">`</span> 命令列出相关信息），它对应 <span class="token variable">`</span></span><span class="token function">fdisk</span><span class="token variable"><span class="token variable">`</span> 的结果中 <span class="token variable">`</span></span>/dev/sda3<span class="token variable"><span class="token variable">`</span> 所在行的第 5 列，分区 3 的扇区数是 1959930，转换成字节数是 <span class="token variable">`</span></span>1959930\*512<span class="token variable"><span class="token variable">`</span> （目前，硬盘的默认扇区大小是 512 字节），而 <span class="token variable">`</span></span>swap<span class="token variable"><span class="token variable">`</span> 分区的默认块大小是 1024 字节，这样块数就是 <span class="token variable">`</span></span><span class="token keyword">:</span>$ <span class="token keyword">echo</span> 1959930*512/1024 <span class="token operator">|</span> <span class="token function">bc</span>979965<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正好是 <code>fdisk</code> 结果中 <code>/dev/sda3</code> 所在行的第四列对应的块数，同样地，可以对照 <code>fdisk</code> 和 <code>file</code> 的结果分析分区 4 。</p><p>再来看看 <code>od</code> 命令以十六进制显示的结果，同样考虑分区 3，计算一下发现，分区 3 对应的 <code>od</code> 命令的结果为：</p><pre><code>fe00 ffff fe82 ffff 14c0 012a e7fa 001d</code></pre><p>首先是分区标记，<code>00H</code>，从上图中，看出它就不是引导分区（<code>80H</code> 标记的才是引导分区），而分区类型呢？为 <code>82H</code>，和 <code>file</code> 显示结果一致，现在再来关注一下分区大小，即 <code>file</code> 结果中的扇区数。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token string">"ibase=10;obase=16;1959930"</span> <span class="token operator">|</span> <span class="token function">bc</span>1DE7FA<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>刚好对应 <code>e7fa 001d</code>，同样地考虑引导分区的结果：</p><blockquote><p>0180 0001 fe83 ffff 003f 0000 1481 012a</p></blockquote><p>分区标记： <code>80H</code>，正好反应了这个分区是引导分区，随后是引导分区所在的磁盘扇区情况，010100，即 1 面 0 道 1 扇区。其他内容可以对照分析。</p><p>考虑到时间关系，更多细节请参考下面的资料或者查看看系统的相关手册。</p><p>补充：安装系统时，可以用 <code>fdisk</code>，<code>cfdisk</code> 等命令进行分区。如果要想从某个分区启动，那么需要打上 <code>80H</code> 标记，例如可通过 <code>cfdisk</code> 把某个分区设置为 <code>bootable</code> 来实现。</p><p>参考资料：</p><ul><li><a href="http://www-128.ibm.com/developerworks/linux/library/l-linuxboot/">Inside the linux boot process</a></li><li><a href="http://docs.huihoo.com/gnu_linux/own_os/booting.htm">Develop your own OS: booting</a></li><li><a href="http://blog.csdn.net/fowse/article/details/7220021">Redhat9 磁盘分区简介</a></li><li><a href="http://www.tldp.org/HOWTO/Partition/">Linux partition HOWTO</a></li></ul><h3 id="分区和文件系统的关系"><a href="#分区和文件系统的关系" class="headerlink" title="分区和文件系统的关系"></a>分区和文件系统的关系</h3><p>在没有引入逻辑卷之前，分区类型和文件系统类型几乎可以同等对待，设置分区类型的过程就是格式化分区，建立相应的文件系统类型的过程。</p><p>下面主要介绍如何建立分区和文件系统类型的联系，即如何格式化分区为指定的文件系统类型。</p><h4 id="常见分区类型"><a href="#常见分区类型" class="headerlink" title="常见分区类型"></a>常见分区类型</h4><p>先来看看 Linux 下文件系统的常见类型（如果要查看所有 Linux 支持的文件类型，可以用 <code>fdisk</code> 命令的 <code>l</code> 命令查看，或者通过 <code>man fs</code> 查看，也可通过 <code>/proc/filesystems</code> 查看到当前内核支持的文件系统类型）</p><ul><li><code>ext2</code>，<code>ext3</code>，<code>ext4</code> ：这三个是 Linux 根文件系统通常采用的类型</li><li><code>swap</code> ：这个是实现 Linux 虚拟内存时采用的一种文件系统，安装时一般需要建立一个专门的分区，并格式化为 <code>swap</code> 文件系统（如果想添加更多 <code>swap</code> 分区，可以参考本节的<a href="http://soft.zdnet.com.cn/software_zone/2007/1010/545261.shtml">参考资料</a>，熟悉 <code>dd</code>，<code>mkswap</code>，<code>swapon</code>，<code>swapoff</code> 等命令的用法）</li><li><code>proc</code> ：这是一种比较特别的文件系统，作为内核和用户之间的一个接口存在，建立在内存中（可以通过 <code>cat</code> 命令查看 <code>/proc</code> 系统下的文件，甚至可以通过修改 <code>/proc/sys</code> 下的文件实时调整内核配置，当前前提是需要把 <code>proc</code> 文件系统挂载上： <code>mount -t proc proc /proc</code></li></ul><p>除了上述文件系统类型外，Linux 支持包括 <code>vfat</code>，<code>iso</code>，<code>xfs</code>，<code>nfs</code> 在内各种常见的文件系统类型，在 Linux 下，可以自由地查看和操作 Windows 等其他操作系统使用的文件系统。</p><p>那么如何建立磁盘和这些文件系统类型的关联呢？格式化。</p><p>格式化的过程实际上就是重新组织分区的过程，可通过 <code>mkfs</code> 命令来实现，当然也可以通过 <code>fdisk</code> 等命令来实现。这里仅介绍 <code>mkfs</code>，<code>mkfs</code> 可用来对一个已有的分区进行格式化，不能实现分区操作（如果要对一个磁盘进行分区和格式化，那么可以用 <code>fdisk</code>）。格式化后，相应分区上的数据就会通过某种特别的文件系统类型进行组织。</p><h4 id="范例：格式化文件系统"><a href="#范例：格式化文件系统" class="headerlink" title="范例：格式化文件系统"></a>范例：格式化文件系统</h4><p>例如：把 <code>/dev/sda9</code> 分区格式化为 <code>ext3</code> 的文件系统。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> -s<span class="token comment" spellcheck="true"># mkfs -t ext3 /dev/sda9</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果要列出各个分区的文件系统类型，那么可以用 <code>fdisk -l</code> 命令。</p><p>更多信息请参考下列资料。</p><p>参考资料：</p><ul><li><a href="http://soft.zdnet.com.cn/software_zone/2007/1010/545261.shtml">Linux 下加载 swap 分区的步骤</a></li><li><a href="http://www.examda.com/linux/fudao/20071212/113445321.html">Linux 下 ISO 镜像文件的制作与刻录</a></li><li>RAM 磁盘分区解释: <a href="http://oldlinux.org/oldlinux/viewthread.php?tid=2677">[1]</a>, <a href="http://www.ibm.com/developerworks/cn/linux/l-initrd.html">[2]</a></li><li><a href="http://www.ibm.com/Search/?q=高级文件系统实现者指南&v=17&en=utf&lang=en&cc=us">高级文件系统实现者指南</a></li></ul><h3 id="分区、逻辑卷和文件系统的关系"><a href="#分区、逻辑卷和文件系统的关系" class="headerlink" title="分区、逻辑卷和文件系统的关系"></a>分区、逻辑卷和文件系统的关系</h3><p>上一节直接把分区格式化为某种文件系统类型，但是考虑到扩展新的存储设备的需要，开发人员在文件系统和分区之间引入了逻辑卷。考虑到时间关系，这里不再详述，请参考资料：<a href="http://unix-cd.com/vc/www/28/2007-06/1178.html">Linux 逻辑卷管理详解</a></p><h3 id="文件系统的可视化结构"><a href="#文件系统的可视化结构" class="headerlink" title="文件系统的可视化结构"></a>文件系统的可视化结构</h3><p>文件系统最终呈现出来的是一种可视化的结构，可用ls,find,tree等命令把它呈现出来。它就像一颗倒挂的“树”，在树的节点上还可以挂载新的“树”。</p><p>下面简单介绍文件系统的挂载。</p><p>一个文件系统可以通过一个设备挂载（<code>mount</code>）到某个目录下，这个目录被称为挂载点。有趣的是，在 Linux 下，一个目录本身还可以挂载到另外一个目录下，一个格式化了的文件也可以通过一个特殊的设备 <code>/dev/loop</code> 进行挂载（如 <code>iso</code> 文件）。另外，就文件系统而言，Linux 不仅支持本地文件系统，还支持远程文件系统（如 <code>nfs</code>）。</p><h4 id="范例：挂载文件系统"><a href="#范例：挂载文件系统" class="headerlink" title="范例：挂载文件系统"></a>范例：挂载文件系统</h4><p>下面简单介绍文件系统挂载的几个实例。</p><ul><li>根文件系统的挂载</li></ul><p>挂载需要 Root 权限，例如，挂载系统根文件系统 <code>/dev/sda1</code> 到 <code>/mnt</code></p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> -s<span class="token comment" spellcheck="true"># mount -t ext3 /dev/sda1 /mnt/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看 <code>/dev/sda1</code> 的挂载情况，可以看到，一个设备可以多次挂载</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">mount</span> <span class="token operator">|</span> <span class="token function">grep</span> sda1/dev/sda1 on / <span class="token function">type</span> ext3 <span class="token punctuation">(</span>rw,errors<span class="token operator">=</span>remount-ro<span class="token punctuation">)</span>/dev/sda1 on /mnt <span class="token function">type</span> ext3 <span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对于一个已经挂载的文件系统，为支持不同属性可以重新挂载</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">mount</span> -n -o remount, rw /<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>挂载一个新增设备</li></ul><p>如果内核已经支持 USB 接口，那么插入 u 盘时，可以通过 <code>dmesg</code> 命令查看对应的设备号，并挂载它。</p><p>查看 <code>dmesg</code> 结果中的最后几行内容，找到类似 <code>/dev/sdN</code> 的信息，找出 u 盘对应的设备号</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">dmesg</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里假设 u 盘是 <code>vfat</code> 格式，以便在一些打印店里的 Windows 上也可使用</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># mount -t vfat /dev/sdN /path/to/mountpoint_directory</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>挂载一个 iso 文件或者是光盘</li></ul><p>对于一些iso文件或者是 iso 格式的光盘，同样可以通过 <code>mount</code> 命令挂载。</p><p>对于 iso 文件：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># mount -t iso9660 /path/to/isofile /path/to/mountpoint_directory</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于光盘：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># mount -t iso9660 /dev/cdrom /path/to/mountpoint_directory</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>挂载一个远程文件系统</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># mount -t nfs remote_ip:/path/to/share_directory /path/to/local_directory</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>挂载一个 proc 文件系统</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># mount -t proc proc /proc</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>proc</code> 文件系统组织在内存中，但是可以把它挂载到某个目录下。通常把它挂载在 <code>/proc</code> 目录下，以便一些系统管理和配置工具使用它。例如 <code>top</code> 命令用它分析内存的使用情况（读取 <code>/proc/meminfo</code> 和 <code>/proc/stat</code> 等文件中的内容）； <code>lsmod</code> 命令通过它获取内核模块的状态（读取 <code>/proc/modules</code>）； <code>netstat</code> 命令通过它获取网络的状态（读取 <code>/proc/net/dev</code> 等文件）。当然，也可以编写相关工具。除此之外，通过调整 <code>/proc/sys</code> 目录下的文件，可以动态地调整系统配置，比如往 <code>/proc/sys/net/ipv4/ip_forward</code> 文件中写入数字 1 就可以让内核支持数据包转发。（更多信息请参考 <code>proc</code> 的帮助，<code>man</code> <code>proc</code>）</p><ul><li>挂载一个目录</li></ul><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">mount</span> --bind /path/to/needtomount_directory /path/to/mountpoint_directory<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个非常有意思，比如可以把某个目录挂载到 ftp 服务的根目录下，而无须把内容复制过去，就可以把相应目录中的资源提供给别人共享。</p><h4 id="范例：卸载某个分区"><a href="#范例：卸载某个分区" class="headerlink" title="范例：卸载某个分区"></a>范例：卸载某个分区</h4><p>以上都只提到了挂载，那怎么卸载呢？用 <code>umount</code> 命令跟上挂载的源地址或者挂载点（设备，文件，远程目录等）就可以。例如：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">umount</span> /path/to/mountpoint_directory<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">umount</span> /path/to/mount_source<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果想管理大量的或者经常性的挂载服务，那么每次手动挂载是很糟糕的事情。这时就可利用 <code>mount</code> 的配置文件 <code>/etc/fstab</code>，把 <code>mount</code> 对应的参数写到 <code>/etc/fstab</code> 文件对应的列中即可实现批量挂载（ <code>mount -a</code> ）和卸载（ <code>umount -a</code> ）。 <code>/etc/fstab</code> 中各列分别为文件系统、挂载点、类型、相关选项。更多信息可参考 <code>fstab</code> 的帮助（ <code>man fstab</code> ）。</p><p>参考资料：</p><ul><li><a href="http://www.xxlinux.com/linux/article/accidence/technique/20070521/8493.html">Linux 硬盘分区以及其挂载原理</a></li><li><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-vfs/">从文件 I/O 看 Linux 的虚拟文件系统</a></li><li><a href="http://www.tinylab.org/callgraph-draw-the-calltree-of-c-functions/">源码分析：静态分析 C 程序函数调用关系图</a></li></ul><h3 id="如何制作一个文件系统"><a href="#如何制作一个文件系统" class="headerlink" title="如何制作一个文件系统"></a>如何制作一个文件系统</h3><p>Linux 文件系统下有一些最基本的目录，不同的目录下存放着不同作用的各类文件。最基本的目录有 <code>/etc</code>，<code>/lib</code>，<code>/dev</code>，<code>/bin</code> 等，它们分别存放着系统配置文件，库文件，设备文件和可执行程序。这些目录一般情况下是必须的，在做嵌入式开发时，需要手动或者是用 <code>busybox</code> 等工具来创建这样一个基本的文件系统。这里仅制作一个非常简单的文件系统，并对该文件系统进行各种常规操作，以便加深对文件系统的理解。</p><h4 id="范例：用-dd-创建一个固定大小的文件"><a href="#范例：用-dd-创建一个固定大小的文件" class="headerlink" title="范例：用 dd 创建一个固定大小的文件"></a>范例：用 dd 创建一个固定大小的文件</h4><p>还记得 <code>dd</code> 命令么？就用它来产生一个固定大小的文件，这个为 <code>1M(1024\*1024 bytes)</code> 的文件</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">dd</span> if<span class="token operator">=</span>/dev/zero of<span class="token operator">=</span>minifs bs<span class="token operator">=</span>1024 count<span class="token operator">=</span>1024<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看文件类型，这里的 <code>minifs</code> 是一个充满 <code>\\0</code> 的文件，没有任何特定的数据结构</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">file</span> minifsminifs: data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>说明： <code>/dev/zero</code> 是一个非常特殊的设备，如果读取它，可以获取任意多个 <code>\\0</code> 。</p><p>接着把该文件格式化为某个指定文件类型的文件系统。（是不是觉得不可思议，文件也可以格式化？是的，不光是设备可以，文件也可以以某种文件系统类型进行组织，但是需要注意的是，某些文件系统（如 <code>ext3</code>）要求被格式化的目标最少有 <code>64M</code> 的空间）。</p><h4 id="范例：用-mkfs-格式化文件"><a href="#范例：用-mkfs-格式化文件" class="headerlink" title="范例：用 mkfs 格式化文件"></a>范例：用 mkfs 格式化文件</h4><pre class="line-numbers language-bash"><code class="language-bash">$ mkfs.ext2 minifs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看此时的文件类型，这时文件 <code>minifs</code> 就以 <code>ext2</code> 文件系统的格式组织了</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">file</span> minifsminifs: Linux <span class="token function">rev</span> 1.0 ext2 filesystem data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="范例：挂载刚创建的文件系统"><a href="#范例：挂载刚创建的文件系统" class="headerlink" title="范例：挂载刚创建的文件系统"></a>范例：挂载刚创建的文件系统</h4><p>因为该文件以文件系统的类型组织了，那么可以用 <code>mount</code> 命令挂载并使用它。</p><p>请切换到 <code>root</code> 用户挂载它，并通过 <code>-o loop</code> 选项把它关联到一个特殊设备 <code>/dev/loop</code></p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> -s<span class="token comment" spellcheck="true"># mount minifs /mnt/ -o loop</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看该文件系统信息，仅可以看到一个目录文件 <code>lost+found</code></p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ls</span> /mnt/lost+found<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="范例：对文件系统进行读、写、删除等操作"><a href="#范例：对文件系统进行读、写、删除等操作" class="headerlink" title="范例：对文件系统进行读、写、删除等操作"></a>范例：对文件系统进行读、写、删除等操作</h4><p>在该文件系统下进行各种常规操作，包括读、写、删除等。(每次操作前先把 <code>minifs</code> 文件保存一份，以便比较，结合相关资料就可以深入地分析各种操作对文件系统的改变情况，从而深入理解文件系统作为一种组织数据的方式的实现原理等)</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cp</span> minifs minifs.bak$ <span class="token function">cd</span> /mnt$ <span class="token function">touch</span> hello$ <span class="token function">cd</span> -$ <span class="token function">cp</span> minifs minifs-touch.bak$ od -x minifs.bak <span class="token operator">></span> orig.od$ od -x minifs-touch.bak <span class="token operator">></span> touch.od<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建一个文件后，比较此时文件系统和之前文件系统的异同</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">diff</span> orig.od touch.od<span class="token function">diff</span> orig.od touch.od61,63c61,64<span class="token operator">&lt;</span> 0060020 000c 0202 2e2e 0000 000b 0000 03e8 020a<span class="token operator">&lt;</span> 0060040 6f6c 7473 662b 756f 646e 0000 0000 0000<span class="token operator">&lt;</span> 0060060 0000 0000 0000 0000 0000 0000 0000 0000---<span class="token operator">></span> 0060020 000c 0202 2e2e 0000 000b 0000 0014 020a<span class="token operator">></span> 0060040 6f6c 7473 662b 756f 646e 0000 000c 0000<span class="token operator">></span> 0060060 03d4 0105 6568 6c6c 006f 0000 0000 0000<span class="token operator">></span> 0060100 0000 0000 0000 0000 0000 0000 0000 0000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过比较发现：添加文件，文件系统的相应位置发生了明显的变化</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token string">"hello, world"</span> <span class="token operator">></span> /mnt/hello<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行 <code>sync</code> 命令，确保缓存中的数据已经写入磁盘（还记得本节图 1 的 <code>buffer cache</code> 吧，这里就是把 <code>cache</code> 中的数据写到磁盘中）</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sync</span>$ <span class="token function">cp</span> minifs minifs-echo.bak$ od -x minifs-echo.bak <span class="token operator">></span> echo.od<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>写入文件内容后，比较文件系统和之前的异同</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">diff</span> touch.od echo.od<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看文件系统中的字符串</p><pre class="line-numbers language-bash"><code class="language-bash">$ strings minifslost+foundhellohello, world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>删除 <code>hello</code> 文件，查看文件系统变化</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">rm</span> /mnt/hello$ <span class="token function">cp</span> minifs minifs-rm.bak$ od -x minifs-rm.bak <span class="token operator">></span> rm.od$ <span class="token function">diff</span> echo.od rm.od<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过查看文件系统的字符串发现：删除文件时并没有覆盖文件内容，所以从理论上说内容此时还是可恢复的</p><pre class="line-numbers language-bash"><code class="language-bash">$ strings minifslost+foundhellohello, world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面仅仅演示了一些分析文件系统的常用工具，并分析了几个常规的操作，如果想非常深入地理解文件系统的实现原理，请熟悉使用上述工具并阅读相关资料。</p><p>参考资料：</p><ul><li><a href="http://202.201.1.130:8080/docs/summer_school_2007/team3/doc/build_a_mini_filesystem_from_scratch">Build a mini filesystem in linux from scratch</a></li><li><a href="http://202.201.1.130:8080/docs/summer_school_2007/team3/doc/build_a_mini_filesystem_with_busybox">Build a mini filesystem in linux with BusyBox</a></li><li><a href="http://man.chinaunix.net/tech/lyceum/linuxK/fs/filesystem.html">ext2 文件系统</a></li></ul><h3 id="如何开发自己的文件系统"><a href="#如何开发自己的文件系统" class="headerlink" title="如何开发自己的文件系统"></a>如何开发自己的文件系统</h3><p>随着 <code>fuse</code> 的出现，在用户空间开发文件系统成为可能，如果想开发自己的文件系统，那么推荐阅读：<a href="http://www.ibm.com/developerworks/cn/linux/l-fuse/">使用 fuse 开发自己的文件系统</a>。</p><h2 id="进程操作"><a href="#进程操作" class="headerlink" title="进程操作"></a>进程操作</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>进程作为程序真正发挥作用时的“形态”，我们有必要对它的一些相关操作非常熟悉，这一节主要描述进程相关的概念和操作，将介绍包括程序、进程、作业等基本概念以及进程状态查询、进程通信等相关的操作。</p><p>###什么是程序，什么又是进程</p><p>程序是指令的集合，而进程则是程序执行的基本单元。为了让程序完成它的工作，必须让程序运行起来成为进程，进而利用处理器资源、内存资源，进行各种 <code>I/O</code> 操作，从而完成某项特定工作。</p><p>从这个意思上说，程序是静态的，而进程则是动态的。</p><p>进程有区别于程序的地方还有：进程除了包含程序文件中的指令数据以外，还需要在内核中有一个数据结构用以存放特定进程的相关属性，以便内核更好地管理和调度进程，从而完成多进程协作的任务。因此，从这个意义上可以说“高于”程序，超出了程序指令本身。</p><p>如果进行过多进程程序的开发，又会发现，一个程序可能创建多个进程，通过多个进程的交互完成任务。在 Linux 下，多进程的创建通常是通过 <code>fork</code> 系统调用来实现。从这个意义上来说程序则”包含”了进程。</p><p>另外一个需要明确的是，程序可以由多种不同程序语言描述，包括 C 语言程序、汇编语言程序和最后编译产生的机器指令等。</p><p>下面简单讨论 Linux 下面如何通过 Shell 进行进程的相关操作。</p><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>通常在命令行键入某个程序文件名以后，一个进程就被创建了。例如，</p><h4 id="范例：让程序在后台运行"><a href="#范例：让程序在后台运行" class="headerlink" title="范例：让程序在后台运行"></a>范例：让程序在后台运行</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sleep</span> 100 <span class="token operator">&amp;</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span> 9298<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="范例：查看进程-ID"><a href="#范例：查看进程-ID" class="headerlink" title="范例：查看进程 ID"></a>范例：查看进程 ID</h4><p>用<code>pidof</code>可以查看指定程序名的进程ID：</p><pre class="line-numbers language-bash"><code class="language-bash">$ pidof <span class="token function">sleep</span>9298<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="范例：查看进程的内存映像"><a href="#范例：查看进程的内存映像" class="headerlink" title="范例：查看进程的内存映像"></a>范例：查看进程的内存映像</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> /proc/9298/maps08048000-0804b000 r-xp 00000000 08:01 977399     /bin/sleep0804b000-0804c000 rw-p 00003000 08:01 977399     /bin/sleep0804c000-0806d000 rw-p 0804c000 00:00 0          <span class="token punctuation">[</span>heap<span class="token punctuation">]</span>b7c8b000-b7cca000 r--p 00000000 08:01 443354<span class="token punctuation">..</span>.bfbd8000-bfbed000 rw-p bfbd8000 00:00 0          <span class="token punctuation">[</span>stack<span class="token punctuation">]</span>ffffe000-fffff000 r-xp 00000000 00:00 0          <span class="token punctuation">[</span>vdso<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序被执行后，就被加载到内存中，成为了一个进程。上面显示了该进程的内存映像（虚拟内存），包括程序指令、数据，以及一些用于存放程序命令行参数、环境变量的栈空间，用于动态内存申请的堆空间都被分配好。</p><p>实际上，创建一个进程，也就是说让程序运行，还有其他的办法，比如，通过一些配置让系统启动时自动启动程序（具体参考 <code>man init</code>），或者是通过配置 <code>crond</code> （或者 <code>at</code>）让它定时启动程序。除此之外，还有一个方式，那就是编写 Shell 脚本，把程序写入一个脚本文件，当执行脚本文件时，文件中的程序将被执行而成为进程。这些方式的细节就不介绍，下面了解如何查看进程的属性。</p><p>需要补充一点的是：在命令行下执行程序，可以通过 <code>ulimit</code> 内置命令来设置进程可以利用的资源，比如进程可以打开的最大文件描述符个数，最大的栈空间，虚拟内存空间等。具体用法见 <code>help ulimit</code> 。</p><h3 id="查看进程的属性和状态"><a href="#查看进程的属性和状态" class="headerlink" title="查看进程的属性和状态"></a>查看进程的属性和状态</h3><p>可以通过 <code>ps</code> 命令查看进程相关属性和状态，这些信息包括进程所属用户，进程对应的程序，进程对 <code>cpu</code> 和内存的使用情况等信息。熟悉如何查看它们有助于进行相关的统计分析等操作。</p><h4 id="范例：通过-ps-命令查看进程属性"><a href="#范例：通过-ps-命令查看进程属性" class="headerlink" title="范例：通过 ps 命令查看进程属性"></a>范例：通过 ps 命令查看进程属性</h4><p>查看系统当前所有进程的属性：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ps</span> -ef<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看命令中包含某字符的程序对应的进程，进程 <code>ID</code> 是 1 。 <code>TTY</code> 为？表示和终端没有关联：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ps</span> -C init  PID TTY          TIME CMD    1 ?        00:00:01 init<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>选择某个特定用户启动的进程：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ps</span> -U falcon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>按照指定格式输出指定内容，下面输出命令名和 <code>cpu</code> 使用率：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ps</span> -e -o <span class="token string">"%C %c"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打印 <code>cpu</code> 使用率最高的前 4 个程序：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ps</span> -e -o <span class="token string">"%C %c"</span> <span class="token operator">|</span> <span class="token function">sort</span> -u -k1 -r <span class="token operator">|</span> <span class="token function">head</span> -5 7.5 firefox-bin 1.1 Xorg 0.8 scim-panel-gtk 0.2 scim-bridge<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>获取使用虚拟内存最大的 5 个进程：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ps</span> -e -o <span class="token string">"%z %c"</span> <span class="token operator">|</span> <span class="token function">sort</span> -n -k1 -r <span class="token operator">|</span> <span class="token function">head</span> -5349588 firefox-bin 96612 xfce4-terminal 88840 xfdesktop 76332 gedit 58920 scim-panel-gt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="范例：通过-pstree-查看进程亲缘关系"><a href="#范例：通过-pstree-查看进程亲缘关系" class="headerlink" title="范例：通过 pstree 查看进程亲缘关系"></a>范例：通过 pstree 查看进程亲缘关系</h4><p>系统所有进程之间都有“亲缘”关系，可以通过 <code>pstree</code> 查看这种关系：</p><pre class="line-numbers language-bash"><code class="language-bash">$ pstree<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面会打印系统进程调用树，可以非常清楚地看到当前系统中所有活动进程之间的调用关系。</p><h4 id="范例：用top动态查看进程信息"><a href="#范例：用top动态查看进程信息" class="headerlink" title="范例：用top动态查看进程信息"></a>范例：用top动态查看进程信息</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">top</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该命令最大特点是可以动态地查看进程信息，当然，它还提供了一些其他的参数，比如 <code>-S</code> 可以按照累计执行时间的大小排序查看，也可以通过 <code>-u</code> 查看指定用户启动的进程等。</p><p>补充： <code>top</code> 命令支持交互式，比如它支持 <code>u</code> 命令显示用户的所有进程，支持通过 <code>k</code> 命令杀掉某个进程；如果使用 <code>-n 1</code> 选项可以启用批处理模式，具体用法为：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">top</span> -n 1 -b<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="范例：确保特定程序只有一个副本在运行"><a href="#范例：确保特定程序只有一个副本在运行" class="headerlink" title="范例：确保特定程序只有一个副本在运行"></a>范例：确保特定程序只有一个副本在运行</h4><p>下面来讨论一个有趣的问题：如何让一个程序在同一时间只有一个在运行。</p><p>这意味着当一个程序正在被执行时，它将不能再被启动。那该怎么做呢？</p><p>假如一份相同的程序被复制成了很多份，并且具有不同的文件名被放在不同的位置，这个将比较糟糕，所以考虑最简单的情况，那就是这份程序在整个系统上是唯一的，而且名字也是唯一的。这样的话，有哪些办法来回答上面的问题呢？</p><p>总的机理是：在程序开头检查自己有没有执行，如果执行了则停止否则继续执行后续代码。</p><p>策略则是多样的，由于前面的假设已经保证程序文件名和代码的唯一性，所以通过 <code>ps</code> 命令找出当前所有进程对应的程序名，逐个与自己的程序名比较，如果已经有，那么说明自己已经运行了。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">ps</span> -e -o <span class="token string">"%c"</span> <span class="token operator">|</span> <span class="token function">tr</span> -d <span class="token string">" "</span> <span class="token operator">|</span> <span class="token function">grep</span> -q ^init$   <span class="token comment" spellcheck="true">#查看当前程序是否执行</span><span class="token punctuation">[</span> <span class="token variable">$?</span> -eq 0 <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">exit</span>   <span class="token comment" spellcheck="true">#如果在，那么退出, $?表示上一条指令是否执行成功</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>每次运行时先在指定位置检查是否存在一个保存自己进程 <code>ID</code> 的文件，如果不存在，那么继续执行，如果存在，那么查看该进程 <code>ID</code> 是否正在运行，如果在，那么退出，否则往该文件重新写入新的进程 <code>ID</code>，并继续。</p><pre class="line-numbers language-bash"><code class="language-bash">pidfile<span class="token operator">=</span>/tmp/<span class="token variable">$0</span><span class="token string">".pid"</span><span class="token keyword">if</span> <span class="token punctuation">[</span> -f <span class="token variable">$pidfile</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>       OLDPID<span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">cat</span> $pidfile<span class="token variable">)</span></span>    <span class="token function">ps</span> -e -o <span class="token string">"%p"</span> <span class="token operator">|</span> <span class="token function">tr</span> -d <span class="token string">" "</span> <span class="token operator">|</span> <span class="token function">grep</span> -q <span class="token string">"^<span class="token variable">$OLDPID</span>$"</span>    <span class="token punctuation">[</span> <span class="token variable">$?</span> -eq 0 <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">exit</span><span class="token keyword">fi</span><span class="token keyword">echo</span> $$ <span class="token operator">></span> <span class="token variable">$pidfile</span><span class="token comment" spellcheck="true">#... 代码主体</span><span class="token comment" spellcheck="true">#设置信号0的动作，当程序退出时触发该信号从而删除掉临时文件</span><span class="token function">trap</span> <span class="token string">"rm <span class="token variable">$pidfile</span>"</span>      0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更多实现策略自己尽情发挥吧！</p><h3 id="调整进程的优先级"><a href="#调整进程的优先级" class="headerlink" title="调整进程的优先级"></a>调整进程的优先级</h3><p>在保证每个进程都能够顺利执行外，为了让某些任务优先完成，那么系统在进行进程调度时就会采用一定的调度办法，比如常见的有按照优先级的时间片轮转的调度算法。这种情况下，可以通过 <code>renice</code> 调整正在运行的程序的优先级，例如：`</p><h4 id="范例：获取进程优先级"><a href="#范例：获取进程优先级" class="headerlink" title="范例：获取进程优先级"></a>范例：获取进程优先级</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ps</span> -e -o <span class="token string">"%p %c %n"</span> <span class="token operator">|</span> <span class="token function">grep</span> xfs 5089 xfs               0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="范例：调整进程的优先级"><a href="#范例：调整进程的优先级" class="headerlink" title="范例：调整进程的优先级"></a>范例：调整进程的优先级</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">renice</span> 1 -p 5089renice: 5089: setpriority: Operation not permitted$ <span class="token function">sudo</span> <span class="token function">renice</span> 1 -p 5089   <span class="token comment" spellcheck="true">#需要权限才行</span><span class="token punctuation">[</span>sudo<span class="token punctuation">]</span> password <span class="token keyword">for</span> falcon:5089: old priority 0, new priority 1$ <span class="token function">ps</span> -e -o <span class="token string">"%p %c %n"</span> <span class="token operator">|</span> <span class="token function">grep</span> xfs  <span class="token comment" spellcheck="true">#再看看，优先级已经被调整过来了</span> 5089 xfs               1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h3><p>既然可以通过命令行执行程序，创建进程，那么也有办法结束它。可以通过 <code>kill</code> 命令给用户自己启动的进程发送某个信号让进程终止，当然“万能”的 <code>root</code> 几乎可以 <code>kill</code> 所有进程（除了 <code>init</code> 之外）。例如，</p><h4 id="范例：结束进程"><a href="#范例：结束进程" class="headerlink" title="范例：结束进程"></a>范例：结束进程</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sleep</span> 50 <span class="token operator">&amp;</span>   <span class="token comment" spellcheck="true">#启动一个进程</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span> 11347$ <span class="token function">kill</span> 11347<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>kill</code> 命令默认会发送终止信号（ <code>SIGTERM</code> ）给程序，让程序退出，但是 <code>kill</code> 还可以发送其他信号，这些信号的定义可以通过 <code>man 7 signal</code> 查看到，也可以通过 <code>kill -l</code> 列出来。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">man</span> 7 signal$ <span class="token function">kill</span> -l 1<span class="token punctuation">)</span> SIGHUP       2<span class="token punctuation">)</span> SIGINT       3<span class="token punctuation">)</span> SIGQUIT      4<span class="token punctuation">)</span> SIGILL 5<span class="token punctuation">)</span> SIGTRAP      6<span class="token punctuation">)</span> SIGABRT      7<span class="token punctuation">)</span> SIGBUS       8<span class="token punctuation">)</span> SIGFPE 9<span class="token punctuation">)</span> SIGKILL     10<span class="token punctuation">)</span> SIGUSR1     11<span class="token punctuation">)</span> SIGSEGV     12<span class="token punctuation">)</span> SIGUSR213<span class="token punctuation">)</span> SIGPIPE     14<span class="token punctuation">)</span> SIGALRM     15<span class="token punctuation">)</span> SIGTERM     16<span class="token punctuation">)</span> SIGSTKFLT17<span class="token punctuation">)</span> SIGCHLD     18<span class="token punctuation">)</span> SIGCONT     19<span class="token punctuation">)</span> SIGSTOP     20<span class="token punctuation">)</span> SIGTSTP21<span class="token punctuation">)</span> SIGTTIN     22<span class="token punctuation">)</span> SIGTTOU     23<span class="token punctuation">)</span> SIGURG      24<span class="token punctuation">)</span> SIGXCPU25<span class="token punctuation">)</span> SIGXFSZ     26<span class="token punctuation">)</span> SIGVTALRM   27<span class="token punctuation">)</span> SIGPROF     28<span class="token punctuation">)</span> SIGWINCH29<span class="token punctuation">)</span> SIGIO       30<span class="token punctuation">)</span> SIGPWR      31<span class="token punctuation">)</span> SIGSYS      34<span class="token punctuation">)</span> SIGRTMIN35<span class="token punctuation">)</span> SIGRTMIN+1  36<span class="token punctuation">)</span> SIGRTMIN+2  37<span class="token punctuation">)</span> SIGRTMIN+3  38<span class="token punctuation">)</span> SIGRTMIN+439<span class="token punctuation">)</span> SIGRTMIN+5  40<span class="token punctuation">)</span> SIGRTMIN+6  41<span class="token punctuation">)</span> SIGRTMIN+7  42<span class="token punctuation">)</span> SIGRTMIN+843<span class="token punctuation">)</span> SIGRTMIN+9  44<span class="token punctuation">)</span> SIGRTMIN+10 45<span class="token punctuation">)</span> SIGRTMIN+11 46<span class="token punctuation">)</span> SIGRTMIN+1247<span class="token punctuation">)</span> SIGRTMIN+13 48<span class="token punctuation">)</span> SIGRTMIN+14 49<span class="token punctuation">)</span> SIGRTMIN+15 50<span class="token punctuation">)</span> SIGRTMAX-1451<span class="token punctuation">)</span> SIGRTMAX-13 52<span class="token punctuation">)</span> SIGRTMAX-12 53<span class="token punctuation">)</span> SIGRTMAX-11 54<span class="token punctuation">)</span> SIGRTMAX-1055<span class="token punctuation">)</span> SIGRTMAX-9  56<span class="token punctuation">)</span> SIGRTMAX-8  57<span class="token punctuation">)</span> SIGRTMAX-7  58<span class="token punctuation">)</span> SIGRTMAX-659<span class="token punctuation">)</span> SIGRTMAX-5  60<span class="token punctuation">)</span> SIGRTMAX-4  61<span class="token punctuation">)</span> SIGRTMAX-3  62<span class="token punctuation">)</span> SIGRTMAX-263<span class="token punctuation">)</span> SIGRTMAX-1  64<span class="token punctuation">)</span> SIGRTMAX<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="范例：暂停某个进程"><a href="#范例：暂停某个进程" class="headerlink" title="范例：暂停某个进程"></a>范例：暂停某个进程</h4><p>例如，用 <code>kill</code> 命令发送 <code>SIGSTOP</code> 信号给某个程序，让它暂停，然后发送 <code>SIGCONT</code> 信号让它继续运行。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sleep</span> 50 <span class="token operator">&amp;</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span> 11441$ <span class="token function">jobs</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span>+  Running                 <span class="token function">sleep</span> 50 <span class="token operator">&amp;</span>$ <span class="token function">kill</span> -s SIGSTOP 11441   <span class="token comment" spellcheck="true">#这个等同于我们对一个前台进程执行CTRL+Z操作</span>$ <span class="token function">jobs</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span>+  Stopped                 <span class="token function">sleep</span> 50$ <span class="token function">kill</span> -s SIGCONT 11441   <span class="token comment" spellcheck="true">#这个等同于之前我们使用bg %1操作让一个后台进程运行起来</span>$ <span class="token function">jobs</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span>+  Running                 <span class="token function">sleep</span> 50 <span class="token operator">&amp;</span>$ <span class="token function">kill</span> %1                  <span class="token comment" spellcheck="true">#在当前会话(session)下，也可以通过作业号控制进程</span>$ <span class="token function">jobs</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span>+  Terminated              <span class="token function">sleep</span> 50<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见 <code>kill</code> 命令提供了非常好的功能，不过它只能根据进程的 <code>ID</code> 或者作业来控制进程，而 <code>pkill</code> 和 <code>killall</code> 提供了更多选择，它们扩展了通过程序名甚至是进程的用户名来控制进程的方法。更多用法请参考它们的手册。</p><h4 id="范例：查看进程退出状态"><a href="#范例：查看进程退出状态" class="headerlink" title="范例：查看进程退出状态"></a>范例：查看进程退出状态</h4><p>当程序退出后，如何判断这个程序是正常退出还是异常退出呢？还记得 Linux 下，那个经典 <code>hello world</code> 程序吗？在代码的最后总是有条 <code>return 0</code> 语句。这个 <code>return 0</code> 实际上是让程序员来检查进程是否正常退出的。如果进程返回了一个其他的数值，那么可以肯定地说这个进程异常退出了，因为它都没有执行到 <code>return 0</code> 这条语句就退出了。</p><p>那怎么检查进程退出的状态，即那个返回的数值呢？</p><p>在 <code>Shell</code> 中，可以检查这个特殊的变量 <code>$?</code>，它存放了上一条命令执行后的退出状态。</p><pre class="line-numbers language-bash"><code class="language-bash">$ test1bash: test1: <span class="token function">command</span> not found$ <span class="token keyword">echo</span> <span class="token variable">$?</span>127$ <span class="token function">cat</span> ./test.c <span class="token operator">|</span> <span class="token function">grep</span> hello$ <span class="token keyword">echo</span> <span class="token variable">$?</span>1$ <span class="token function">cat</span> ./test.c <span class="token operator">|</span> <span class="token function">grep</span> hi    printf<span class="token punctuation">(</span><span class="token string">"hi, myself!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>$ <span class="token keyword">echo</span> <span class="token variable">$?</span>0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>貌似返回 0 成为了一个潜规则，虽然没有标准明确规定，不过当程序正常返回时，总是可以从 <code>$?</code> 中检测到 0，但是异常时，总是检测到一个非 0 值。这就告诉我们在程序的最后最好是跟上一个 <code>exit 0</code> 以便任何人都可以通过检测 <code>$?</code> 确定程序是否正常结束。如果有一天，有人偶尔用到你的程序，试图检查它的退出状态，而你却在程序的末尾莫名地返回了一个 <code>-1</code> 或者 1，那么他将会很苦恼，会怀疑他自己编写的程序到底哪个地方出了问题，检查半天却不知所措，因为他太信任你了，竟然从头至尾都没有怀疑你的编程习惯可能会与众不同！</p><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>为便于设计和实现，通常一个大型的任务都被划分成较小的模块。不同模块之间启动后成为进程，它们之间如何通信以便交互数据，协同工作呢？在《UNIX 环境高级编程》一书中提到很多方法，诸如管道（无名管道和有名管道）、信号（<code>signal</code>）、报文（<code>Message</code>）队列（消息队列）、共享内存（<code>mmap/munmap</code>）、信号量（<code>semaphore</code>，主要是同步用，进程之间，进程的不同线程之间）、套接口（<code>Socket</code>，支持不同机器之间的进程通信）等，而在 Shell 中，通常直接用到的就有管道和信号等。下面主要介绍管道和信号机制在 Shell 编程时的一些用法。</p><h4 id="范例：无名管道（pipe）"><a href="#范例：无名管道（pipe）" class="headerlink" title="范例：无名管道（pipe）"></a>范例：无名管道（pipe）</h4><p>在 Linux 下，可以通过 <code>|</code> 连接两个程序，这样就可以用它来连接后一个程序的输入和前一个程序的输出，因此被形象地叫做个管道。在 C 语言中，创建无名管道非常简单方便，用 <code>pipe</code> 函数，传入一个具有两个元素的 <code>int</code> 型的数组就可以。这个数组实际上保存的是两个文件描述符，父进程往第一个文件描述符里头写入东西后，子进程可以从第一个文件描述符中读出来。</p><p>如果用多了命令行，这个管子 <code>|</code> 应该会经常用。比如上面有个演示把 <code>ps</code> 命令的输出作为 <code>grep</code> 命令的输入：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ps</span> -ef <span class="token operator">|</span> <span class="token function">grep</span> init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也许会觉得这个“管子”好有魔法，竟然真地能够链接两个程序的输入和输出，它们到底是怎么实现的呢？实际上当输入这样一组命令时，当前 Shell 会进行适当的解析，把前面一个进程的输出关联到管道的输出文件描述符，把后面一个进程的输入关联到管道的输入文件描述符，这个关联过程通过输入输出重定向函数 <code>dup</code> （或者 <code>fcntl</code> ）来实现。</p><h4 id="范例：有名管道（named-pipe）"><a href="#范例：有名管道（named-pipe）" class="headerlink" title="范例：有名管道（named pipe）"></a>范例：有名管道（named pipe）</h4><p>有名管道实际上是一个文件（无名管道也像一个文件，虽然关系到两个文件描述符，不过只能一边读另外一边写），不过这个文件比较特别，操作时要满足先进先出，而且，如果试图读一个没有内容的有名管道，那么就会被阻塞，同样地，如果试图往一个有名管道里写东西，而当前没有程序试图读它，也会被阻塞。下面看看效果。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">mkfifo</span> fifo_test    <span class="token comment" spellcheck="true">#通过mkfifo命令创建一个有名管道</span>$ <span class="token keyword">echo</span> <span class="token string">"fewfefe"</span> <span class="token operator">></span> fifo_test<span class="token comment" spellcheck="true">#试图往fifo_test文件中写入内容，但是被阻塞，要另开一个终端继续下面的操作</span>$ <span class="token function">cat</span> fifo_test        <span class="token comment" spellcheck="true">#另开一个终端，记得，另开一个。试图读出fifo_test的内容</span>fewfefe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的 <code>echo</code> 和 <code>cat</code> 是两个不同的程序，在这种情况下，通过 <code>echo</code> 和 <code>cat</code> 启动的两个进程之间并没有父子关系。不过它们依然可以通过有名管道通信。</p><p>这样一种通信方式非常适合某些特定情况：例如有这样一个架构，这个架构由两个应用程序构成，其中一个通过循环不断读取 <code>fifo_test</code> 中的内容，以便判断，它下一步要做什么。如果这个管道没有内容，那么它就会被阻塞在那里，而不会因死循环而耗费资源，另外一个则作为一个控制程序不断地往 <code>fifo_test</code> 中写入一些控制信息，以便告诉之前的那个程序该做什么。下面写一个非常简单的例子。可以设计一些控制码，然后控制程序不断地往 <code>fifo_test</code> 里头写入，然后应用程序根据这些控制码完成不同的动作。当然，也可以往 <code>fifo_test</code> 传入除控制码外的其他数据。</p><ul><li><p>应用程序的代码</p><pre class="line-numbers language-bash"><code class="language-bash">  $ <span class="token function">cat</span> app.sh  <span class="token comment" spellcheck="true">#!/bin/bash</span>  FIFO<span class="token operator">=</span>fifo_test  <span class="token keyword">while</span> <span class="token keyword">:</span><span class="token punctuation">;</span>  <span class="token keyword">do</span>      CI<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">cat</span> $FIFO<span class="token variable">`</span></span>  <span class="token comment" spellcheck="true">#CI --> Control Info</span>      <span class="token keyword">case</span> <span class="token variable">$CI</span> <span class="token keyword">in</span>          0<span class="token punctuation">)</span> <span class="token keyword">echo</span> <span class="token string">"The CONTROL number is ZERO, do something ..."</span>              <span class="token punctuation">;</span><span class="token punctuation">;</span>          1<span class="token punctuation">)</span> <span class="token keyword">echo</span> <span class="token string">"The CONTROL number is ONE, do something ..."</span>              <span class="token punctuation">;</span><span class="token punctuation">;</span>          *<span class="token punctuation">)</span> <span class="token keyword">echo</span> <span class="token string">"The CONTROL number not recognized, do something else..."</span>              <span class="token punctuation">;</span><span class="token punctuation">;</span>      esac  <span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>控制程序的代码</p><pre class="line-numbers language-bash"><code class="language-bash">  $ <span class="token function">cat</span> control.sh  <span class="token comment" spellcheck="true">#!/bin/bash</span>  FIFO<span class="token operator">=</span>fifo_test  CI<span class="token operator">=</span><span class="token variable">$1</span>  <span class="token punctuation">[</span> -z <span class="token string">"<span class="token variable">$CI</span>"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">echo</span> <span class="token string">"the control info should not be empty"</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">exit</span>  <span class="token keyword">echo</span> <span class="token variable">$CI</span> <span class="token operator">></span> <span class="token variable">$FIFO</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>一个程序通过管道控制另外一个程序的工作</p><pre class="line-numbers language-bash"><code class="language-bash">  $ <span class="token function">chmod</span> +x app.sh control.sh    <span class="token comment" spellcheck="true">#修改这两个程序的可执行权限，以便用户可以执行它们</span>  $ ./app.sh  <span class="token comment" spellcheck="true">#在一个终端启动这个应用程序，在通过./control.sh发送控制码以后查看输出</span>  The CONTROL number is ONE, <span class="token keyword">do</span> something <span class="token punctuation">..</span>.    <span class="token comment" spellcheck="true">#发送1以后</span>  The CONTROL number is ZERO, <span class="token keyword">do</span> something <span class="token punctuation">..</span>.    <span class="token comment" spellcheck="true">#发送0以后</span>  The CONTROL number not recognized, <span class="token keyword">do</span> something else<span class="token punctuation">..</span>.  <span class="token comment" spellcheck="true">#发送一个未知的控制码以后</span>  $ ./control.sh 1            <span class="token comment" spellcheck="true">#在另外一个终端，发送控制信息，控制应用程序的工作</span>  $ ./control.sh 0  $ ./control.sh 4343<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>这样一种应用架构非常适合本地的多程序任务设计，如果结合 <code>web cgi</code>，那么也将适合远程控制的要求。引入 <code>web cgi</code> 的唯一改变是，要把控制程序 <code>./control.sh</code> 放到 <code>web</code> 的 <code>cgi</code> 目录下，并对它作一些修改，以使它符合 <code>CGI</code> 的规范，这些规范包括文档输出格式的表示（在文件开头需要输出 <code>content-tpye: text/html</code> 以及一个空白行）和输入参数的获取 <code>(web</code> 输入参数都存放在 <code>QUERY_STRING</code> 环境变量里头）。因此一个非常简单的 <code>CGI</code> 控制程序可以写成这样：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>FIFO<span class="token operator">=</span>./fifo_testCI<span class="token operator">=</span><span class="token variable">$QUERY_STRING</span><span class="token punctuation">[</span> -z <span class="token string">"<span class="token variable">$CI</span>"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">echo</span> <span class="token string">"the control info should not be empty"</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">exit</span><span class="token keyword">echo</span> -e <span class="token string">"content-type: text/html\n\n"</span><span class="token keyword">echo</span> <span class="token variable">$CI</span> <span class="token operator">></span> <span class="token variable">$FIFO</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在实际使用时，请确保 <code>control.sh</code> 能够访问到 <code>fifo_test</code> 管道，并且有写权限，以便通过浏览器控制 <code>app.sh</code> ：</p><pre><code>http://ipaddress\_or\_dns/cgi-bin/control.sh?0</code></pre><p>问号 <code>?</code> 后面的内容即 <code>QUERY_STRING</code>，类似之前的 <code>$1</code> 。</p><p>这样一种应用对于远程控制，特别是嵌入式系统的远程控制很有实际意义。在去年的暑期课程上，我们就通过这样一种方式来实现马达的远程控制。首先，实现了一个简单的应用程序以便控制马达的转动，包括转速，方向等的控制。为了实现远程控制，我们设计了一些控制码，以便控制马达转动相关的不同属性。</p><p>在 C 语言中，如果要使用有名管道，和 Shell 类似，只不过在读写数据时用 <code>read</code>，<code>write</code> 调用，在创建 <code>fifo</code> 时用 <code>mkfifo</code> 函数调用。</p><h4 id="范例：信号（Signal）"><a href="#范例：信号（Signal）" class="headerlink" title="范例：信号（Signal）"></a>范例：信号（Signal）</h4><p>信号是软件中断，Linux 用户可以通过 <code>kill</code> 命令给某个进程发送一个特定的信号，也可以通过键盘发送一些信号，比如 <code>CTRL+C</code> 可能触发 <code>SGIINT</code> 信号，而 <code>CTRL+\</code> 可能触发 <code>SGIQUIT</code> 信号等，除此之外，内核在某些情况下也会给进程发送信号，比如在访问内存越界时产生 <code>SGISEGV</code> 信号，当然，进程本身也可以通过 <code>kill</code>，<code>raise</code> 等函数给自己发送信号。对于 Linux 下支持的信号类型，大家可以通过 <code>man 7 signal</code> 或者 <code>kill -l</code> 查看到相关列表和说明。</p><p>对于有些信号，进程会有默认的响应动作，而有些信号，进程可能直接会忽略，当然，用户还可以对某些信号设定专门的处理函数。在 Shell 中，可以通过 <code>trap</code> 命令（Shell 内置命令）来设定响应某个信号的动作（某个命令或者定义的某个函数），而在 C 语言中可以通过 <code>signal</code> 调用注册某个信号的处理函数。这里仅仅演示 <code>trap</code> 命令的用法。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">function</span> signal_handler <span class="token punctuation">{</span> <span class="token keyword">echo</span> <span class="token string">"hello, world."</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">#定义signal_handler函数</span>$ <span class="token function">trap</span> signal_handler SIGINT  <span class="token comment" spellcheck="true">#执行该命令设定：收到SIGINT信号时打印hello, world</span>$ hello, world     <span class="token comment" spellcheck="true">#按下CTRL+C，可以看到屏幕上输出了hello, world字符串</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>类似地，如果设定信号 0 的响应动作，那么就可以用 <code>trap</code> 来模拟 C 语言程序中的 <code>atexit</code> 程序终止函数的登记，即通过 <code>trap signal_handler SIGQUIT</code> 设定的 <code>signal_handler</code> 函数将在程序退出时执行。信号 0 是一个特别的信号，在 <code>POSIX.1</code> 中把信号编号 0 定义为空信号，这常被用来确定一个特定进程是否仍旧存在。当一个程序退出时会触发该信号。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> sigexit.sh<span class="token comment" spellcheck="true">#!/bin/bash</span><span class="token keyword">function</span> signal_handler <span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">"hello, world"</span><span class="token punctuation">}</span><span class="token function">trap</span> signal_handler 0$ <span class="token function">chmod</span> +x sigexit.sh$ ./sigexit.sh    <span class="token comment" spellcheck="true">#实际Shell编程会用该方式在程序退出时来做一些清理临时文件的收尾工作</span>hello, world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="作业和作业控制"><a href="#作业和作业控制" class="headerlink" title="作业和作业控制"></a>作业和作业控制</h3><p>当我们为完成一些复杂的任务而将多个命令通过 <code>|,\&gt;,&lt;, ;, (,)</code> 等组合在一起时，通常这个命令序列会启动多个进程，它们间通过管道等进行通信。而有时在执行一个任务的同时，还有其他的任务需要处理，那么就经常会在命令序列的最后加上一个&amp;，或者在执行命令后，按下 <code>CTRL+Z</code> 让前一个命令暂停。以便做其他的任务。等做完其他一些任务以后，再通过 <code>fg</code> 命令把后台任务切换到前台。这样一种控制过程通常被成为作业控制，而那些命令序列则被成为作业，这个作业可能涉及一个或者多个程序，一个或者多个进程。下面演示一下几个常用的作业控制操作。</p><h4 id="范例：创建后台进程，获取进程的作业号和进程号"><a href="#范例：创建后台进程，获取进程的作业号和进程号" class="headerlink" title="范例：创建后台进程，获取进程的作业号和进程号"></a>范例：创建后台进程，获取进程的作业号和进程号</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sleep</span> 50 <span class="token operator">&amp;</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span> 11137<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="范例：把作业调到前台并暂停"><a href="#范例：把作业调到前台并暂停" class="headerlink" title="范例：把作业调到前台并暂停"></a>范例：把作业调到前台并暂停</h4><p>使用 Shell 内置命令 <code>fg</code> 把作业 1 调到前台运行，然后按下 <code>CTRL+Z</code> 让该进程暂停</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">fg</span> %1<span class="token function">sleep</span> 50^Z<span class="token punctuation">[</span>1<span class="token punctuation">]</span>+  Stopped                 <span class="token function">sleep</span> 50<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="范例：查看当前作业情况"><a href="#范例：查看当前作业情况" class="headerlink" title="范例：查看当前作业情况"></a>范例：查看当前作业情况</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">jobs</span>            <span class="token comment" spellcheck="true">#查看当前作业情况，有一个作业停止</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span>+  Stopped                 <span class="token function">sleep</span> 50$ <span class="token function">sleep</span> 100 <span class="token operator">&amp;</span>     <span class="token comment" spellcheck="true">#让另外一个作业在后台运行</span><span class="token punctuation">[</span>2<span class="token punctuation">]</span> 11138$ <span class="token function">jobs</span>            <span class="token comment" spellcheck="true">#查看当前作业情况，一个正在运行，一个停止</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span>+  Stopped                 <span class="token function">sleep</span> 50<span class="token punctuation">[</span>2<span class="token punctuation">]</span>-  Running                 <span class="token function">sleep</span> 100 <span class="token operator">&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="范例：启动停止的进程并运行在后台"><a href="#范例：启动停止的进程并运行在后台" class="headerlink" title="范例：启动停止的进程并运行在后台"></a>范例：启动停止的进程并运行在后台</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">bg</span> %1<span class="token punctuation">[</span>2<span class="token punctuation">]</span>+ <span class="token function">sleep</span> 50 <span class="token operator">&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>不过，要在命令行下使用作业控制，需要当前 Shell，内核终端驱动等对作业控制支持才行。</p><h2 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>前面章节已经介绍了Shell编程范例之数值、布尔值、字符串、文件、文件系统、进程等的操作。这些内容基本覆盖了网络中某个独立机器正常工作的“方方面面”，现在需要把视角从单一的机器延伸到这些机器通过各种网络设备和协议连接起来的网络世界，分析网络拓扑结构、网络工作原理、了解各种常见网络协议、各种常见硬件工作原理、网络通信与安全相关软件以及工作原理分析等。</p><p>不过，因为网络相关的问题确实太复杂了，这里不可能介绍具体，因此如果想了解更多细节，还是建议参考相关资料。但Linux是一个网络原理学习和实践的好平台，不仅因为它本身对网络体系结构的实现是开放源代码的，而且各种相关的分析工具和函数库数不胜数，因此千万不要错过通过它来做相关的实践工作。</p><h3 id="网络原理介绍"><a href="#网络原理介绍" class="headerlink" title="网络原理介绍"></a>网络原理介绍</h3><h4 id="我们的网络世界"><a href="#我们的网络世界" class="headerlink" title="我们的网络世界"></a>我们的网络世界</h4><p>在进行所有介绍之前，来直观地感受一下那个真真实实存在的网络世界吧。当我在 Linux 下通过 <code>Web</code> 编辑器写这篇 Blog 时，一边用 <code>mplayer</code> 听着远程音乐，累了时则打开兰大的网络 <code>TV</code> 频道开始看看凤凰卫视……这些“现代化”的生活，我想，如果没有网络，将变得无法想象。</p><p>下面来构想一下这样一个网络世界的优美图画：</p><blockquote><p>一边盯着显示器，一边敲击着键盘，一边挂着耳机。</p><p>主机电源灯灿烂得很，发着绿光，这时很容易想象主机背后的那个网卡位置肯定有两个不同颜色的灯光在闪烁，它显示着主机正在与计算机网络世界打着交道。</p><p>就在实验室的某个角落，有一个交换机上的一个网口的网线连到主机上，这个交换机接到了一个局域网的网关上，然后这个网关再接到了信息楼的某个路由器上，再转接到学校网络中心的另外一个路由器上……</p><p>期间，有一个路由器连接到了这个 Blog 服务器上，而另外一个则可能连到了那个网络 <code>TV</code> 服务器上，还有呢，另外一些则连接到了电信网络里头的某个音乐服务器上……</p></blockquote><p>下面用 <code>dia</code> 绘制一个简单的“网络地图”：</p><p><img src="https://tinylab.gitbooks.io/shellbook/content/zh/chapters/pic/Network_Architecture.jpg" alt="Network_Architecture"></p><p>该图把一些最常见的网络设备和网络服务基本都呈现出来了，包括本地主机、路由、交换机、网桥，域名服务器，万维网服务，视频服务，防火墙服务，动态 <code>IP</code> 地址服务等。其中各种设备构成了整个物理网络，而网络服务则是构建在这些设备上的各种网络应用。</p><p>现在的网络应用越来越丰富多样，比如即时聊天（<code>IM</code>）、 <code>p2p</code> 资源共享、网络搜索等，它们是如何实现的，它们如何构建在各种各样的网络设备之上，并且能够安全有效的工作呢？这取决于这背后逐步完善的网络体系结构和各种相关网络协议的开发、实现和应用。</p><h4 id="网络体系结构和网络协议介绍"><a href="#网络体系结构和网络协议介绍" class="headerlink" title="网络体系结构和网络协议介绍"></a>网络体系结构和网络协议介绍</h4><p>那么网络体系结构是怎么样的呢？涉及到哪些相关的网络协议呢？什么又是网络协议呢？</p><p>在《计算机网络——自顶向下的方法》一书中非常巧妙地给出了网络体系结构分层的比喻，把网络中各层跟交通运输体系中的各个环节对照起来，让人通俗易懂。在交通运输体系中，运输的是人和物品，在计算机网络体系中，运输的是电子数据。考虑到交通运输网络和计算机网络中最终都可以划归为点对点的信息传输。这里考虑两点之间的信息传递过程，得到这样一个对照关系，见下图：</p><p><img src="https://tinylab.gitbooks.io/shellbook/content/zh/chapters/pic/Network_Layer_Compare.jpg" alt="Network_Layer_Compare"></p><p>对照上图，更容易理解右侧网络体系结构的分层原理（如果比照一封信发出到收到的这一中间过程可能更容易理解），上图右侧是 <code>TCP/IP</code> 网络体系结构的一个网络分层示意图，在把数据发送到网络之前，在各层中需要进行各种“打包”的操作，而从网络接收到数据后，就需要进行“解包”操作，最终把纯粹的数据信息给提取出来。这种分层的方式是为了传输数据的需要，也是两个主机之间如何建立连接以及如何保证数据传输的完整性和可靠性的需要。通过把各种需要分散在不同的层次，使得整个体系结构更加清晰和明了。这些“需求”具体通过各种对应的协议来规范，这些规范统成为网络协议。</p><p>关于 <code>OSI</code> 模型（7 层）比照 <code>TCP/IP</code> 模型（4 层）的协议栈可以从下图（来自网络）看个明了：</p><p><img src="https://tinylab.gitbooks.io/shellbook/content/zh/chapters/pic/Network_Layer_OSI.jpg" alt="Network_Layer_OSI"></p><p>而下图（来自网络）则更清晰地体现了 <code>TCP/IP</code> 分层模型。</p><p><img src="https://tinylab.gitbooks.io/shellbook/content/zh/chapters/pic/Network_Layer_TCP_IP.jpg" alt="Network_Layer_TCP_IP"></p><p>上面介绍了网络原理方面的基本内容，如果想了解更多网络原理和操作系统对网络支持的实现，可以考虑阅读后面的参考资料。下面将做一些实践，即在 Linux 下如何联网，如何用 Linux 搭建各种网络服务，并进行网络安全方面的考量以及基本的网络编程和开发的介绍。</p><h3 id="Linux-下网络“实战”"><a href="#Linux-下网络“实战”" class="headerlink" title="Linux 下网络“实战”"></a>Linux 下网络“实战”</h3><h4 id="如何把我们的-Linux-主机接入网络"><a href="#如何把我们的-Linux-主机接入网络" class="headerlink" title="如何把我们的 Linux 主机接入网络"></a>如何把我们的 Linux 主机接入网络</h4><p>如果要让一个系统能够联网，首先当然是搭建好物理网络了。接入网络的物理方式还是蛮多的，比如直接用网线接入以太网，用无线网卡上网，用 <code>ADSL</code> 拨号上网……</p><p>对于用以太网网卡接入网络的常见方式，在搭建好物理网络并确保连接正常后，可以通过配置 <code>IP</code> 地址和默认网关来接入网络，这个可以通过手工配置和动态获取两种方式。</p><h5 id="范例：通过dhclient获取IP地址"><a href="#范例：通过dhclient获取IP地址" class="headerlink" title="范例：通过dhclient获取IP地址"></a>范例：通过dhclient获取IP地址</h5><p>如果所在的局域网有 <code>DHCP</code> 服务，那么可以这么获取，<code>N</code> 是设备名称，如果只有一块网卡，一般是 0 或者 1 。</p><pre><code>$ dhclient ethN</code></pre><h5 id="范例：静态配置IP地址"><a href="#范例：静态配置IP地址" class="headerlink" title="范例：静态配置IP地址"></a>范例：静态配置IP地址</h5><p>当然，也可以考虑采用静态配置的方式，<code>ip_address</code> 是本地主机的 <code>IP</code> 地址，<code>gw_ip_address</code> 是接入网络的网关的 <code>IP</code> 地址。</p><pre><code>$ ifconfig eth0 ip_address on$ route add deafult gw gw_ip_address</code></pre><p>如果上面不工作，记得通过 <code>ifconfig/mii-tool/ethtool</code> 等工具检查网卡是否有被驱动起来，然后通过 <code>lspci/dmesg</code> 等检查网卡类型（或者通过主板手册和独立网卡自带的手册查看），接着安装或者编译相关驱动，最后把驱动通过 <code>insmod/modprobe</code> 等工具加载到内核中。</p><h4 id="用-Linux-搭建网桥"><a href="#用-Linux-搭建网桥" class="headerlink" title="用 Linux 搭建网桥"></a>用 Linux 搭建网桥</h4><p>网桥工作在 <code>OSI</code> 模型的第二层，即数据链路层，它只需要知道目标主机的 <code>MAC</code> 地址就可以工作。 Linux 内核在 <code>2.2</code> 开始就已经支持了这个功能，具体怎么配置看看后续<a href="http://www.ibm.com/developerworks/cn/linux/kernel/l-netbr/index.html">参考资料</a>吧。如果要把 Linux 主机配置成一个网桥，至少需要两个网卡。</p><p>网桥的作用相当于一根网线，用户无须关心里头有什么东西，把它的两个网口连接到两个主机上就可以让这两个主机支持相互通信。不过它比网线更厉害，如果配上防火墙，就可以隔离连接在它两端的网段（注意这里是网络，因为它不识别 <code>IP</code>），另外，如果这个网桥有多个网口，那么可以实现一个功能复杂的交换机，而如果有效组合多个网桥，则有可能实现一个复杂的可实现流量控制和负载平衡的防火墙系统。</p><h4 id="用-Linux-做路由"><a href="#用-Linux-做路由" class="headerlink" title="用 Linux 做路由"></a>用 Linux 做路由</h4><p>路由工作在 <code>OSI</code> 模型的第三层，即网络层，通过 <code>router</code> 可以配置 Linux 的路由，当然，Linux 下也有很多工具支持动态路由的。相关的资料在网路中铺天盖地，由于时间关系，这里不做介绍。</p><h4 id="用-Linux-搭建各种常规的网络服务"><a href="#用-Linux-搭建各种常规的网络服务" class="headerlink" title="用 Linux 搭建各种常规的网络服务"></a>用 Linux 搭建各种常规的网络服务</h4><p>需要什么网络服务呢？</p><ul><li>给局域网弄个 <code>DHCP</code> 服务器，那就弄个 <code>dhcpd</code>，看看<a href="http://tldp.org/HOWTO/DHCP/">参考资料</a>；</li><li>如果想弄个邮件发送服务器，那就安装个 <code>sendmail</code> 或者 <code>exim4</code> ；</li><li>如果再想弄个邮件列表服务器呢，那就装个 <code>mailman</code> ；</li><li>如果想弄个接收邮件的服务器呢，那就安装个 <code>pop3</code> 服务器；</li><li>如果想弄个 <code>web</code> 站点，那就弄个 <code>apache</code> 或者 <code>nginx</code> 服务器；</li><li>如果想弄上防火墙服务，那么通过 <code>iptables</code> 工具配置 <code>netfilter</code> 就可以</li></ul><p>What’s more？如果你能想到，Linux上基本都有相应的实现。</p><h4 id="Linux-下网络问题诊断与维护"><a href="#Linux-下网络问题诊断与维护" class="headerlink" title="Linux 下网络问题诊断与维护"></a>Linux 下网络问题诊断与维护</h4><p>如果出现网络问题，不要惊慌，逐步检查网络的各个层次：物理链接、链路层、网络层直到应用层，熟悉使用各种如下的工具，包括 <code>ethereal/tcpdump</code>，<code>hping</code>，<code>nmap</code>，<code>netstat</code>，<code>netpipe</code>，<code>netperf</code>，<code>vnstat</code>，<code>ntop</code> 等。</p><p>关于这些工具的详细用法和网络问题诊断和维护的相关知识，请看后续相关资料。</p><h3 id="Linux-下网络编程与开发"><a href="#Linux-下网络编程与开发" class="headerlink" title="Linux 下网络编程与开发"></a>Linux 下网络编程与开发</h3><p>如果想做网络编程开发，比如：</p><ul><li>要实现一个客户端 <code>/</code> 服务器架构的应用，可以采用 Linux 下的 <code>socket</code> 编程了；</li><li>如果想写一个数据包抓获和协议分析的程序，可以采用 <code>libpap</code> 等函数库；</li><li>如果想实现某个协议呢，那就可以参考相关的 <code>RFC</code> 文档，并通过 <code>socket</code> 编程来实现。</li></ul><p>这个可以参考相关的 <code>Linux socket</code> 编程等资料。</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>本来介绍网络相关的一些基本内容，但因时间关系，没有详述，更多细节请参考相关资料。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>计算机网络——自上而下的分析方法</li><li>Linux 网络体系结构（清华大学出版社出版）</li><li>Linux 系统故障诊断与排除 第13章 网络问题（人民邮电出版社）</li><li>在 Linux 下用 ADSL 拨号上网</li><li>Linux 下无线网络相关资料收集</li><li><a href="http://www.ibm.com/developerworks/cn/linux/kernel/l-netbr/index.html">Linux网桥的实现分析与使用</a></li><li><a href="http://tldp.org/HOWTO/DHCP/">DHCP mini howto</a></li><li>最佳的 75 个安全工具</li><li>网络管理员必须掌握的知识</li><li>Linux 上检测 rootkit 的两种工具: Rootkit Hunter 和 Chkrootkit</li><li>数据包抓获与 ip 协议的简单分析（基于 pcap 库）</li><li><a href="http://www.ietf.org/rfc">RFC</a></li><li><a href="http://zhoulifa.bokee.com/4640913.html">HTTP 协议的 C 语言编程实现实例</a></li></ul><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>在实际使用中，Linux 系统首先是面向用户的系统，所有之前介绍的内容全部是提供给不同的用户使用的。实际使用中常常碰到各类用户操作，所以这里添加一个独立的章节来介绍。</p><p>Linux 支持多用户，也就是说允许不同的人使用同一个系统，每个人有一个属于自己的帐号。而且允许大家设置不同的认证密码，确保大家的私有信息得到保护。另外，为了确保整个系统的安全，用户权限又做了进一步划分，包括普通用户和系统管理员。普通用户只允许访问自己账户授权下的信息，而系统管理员才能访问所有资源。普通用户如果想行使管理员的职能，必须获得系统管理员的许可。</p><p>为避免分散注意力，咱们不去介绍背后的那些数据文件： <code>/etc/passwd</code>，<code>/etc/shadow</code>，<code>/etc/group</code>，<code>/etc/gshadow</code></p><p>如果确实有需要，大家可通过如下命令查看帮助： <code>man 5 passwd</code>，<code>man shadow</code>, <code>man group</code> 和 <code>man gshadow</code></p><p>下面我们分如下几个部分来介绍：</p><ul><li>用户帐号</li><li>用户口令</li><li>用户组别</li><li>用户和组</li><li>用户切换</li></ul><h3 id="用户帐号"><a href="#用户帐号" class="headerlink" title="用户帐号"></a>用户帐号</h3><p>帐号操作主要是增、删、改、禁。Linux 系统提供了底层的 <code>useradd</code>, <code>userdel</code> 和 <code>usermod</code> 来完成相关操作，也提供了进一步的简化封装：<code>adduser</code>, <code>deluser</code>。为了避免混淆，咱们这里只介绍最底层的指令，这些指令设计上已经够简洁明了方便。</p><p>由于只有系统管理员才能创建新用户，请确保以 root 帐号登录或者可以通过 sudo 切换为管理员帐号。</p><h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><p>创建家目录并指定登录 Shell：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># useradd -s /bin/bash -m test</span><span class="token comment" spellcheck="true"># groups test</span><span class="token function">test</span> <span class="token keyword">:</span> <span class="token function">test</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>并加入所属组：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># useradd -s /bin/bash -m -G docker test</span><span class="token comment" spellcheck="true"># groups test</span><span class="token function">test</span> <span class="token keyword">:</span> <span class="token function">test</span> docker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>删除用户以及家目录等：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># userdel -r test</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p>常常用来修改默认的 Shell：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># usermod -s /bin/bash test</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者把用户加入某个新安装软件所属的组：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># usermod -a -G docker test</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改登录用户名并搬到新家：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># usermod -d /home/new_test -m -l new_test test</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="禁用"><a href="#禁用" class="headerlink" title="禁用"></a>禁用</h4><p>如果想禁用某个帐号：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># usermod -L test</span><span class="token comment" spellcheck="true"># usermod --expiredate 1 test</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="用户口令"><a href="#用户口令" class="headerlink" title="用户口令"></a>用户口令</h3><p>口令操作主要是设置、删除、修改和禁用。Linux 系统提供了 <code>passwd</code> 命令来管理用户口令。</p><h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><p>设置用户 test 的初始密码：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">passwd</span> <span class="token function">test</span>Enter new UNIX password:Retype new UNIX password:passwd: password updated successfully<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><p>让用户 test 无须密码登录（密码为空）：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">passwd</span> -d <span class="token function">test</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个很方便某些安全无关紧要的条件下（比如已登录主机中的虚拟机），可避免每次频繁输入密码。</p><h4 id="修改-1"><a href="#修改-1" class="headerlink" title="修改"></a>修改</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">passwd</span> <span class="token function">test</span>Changing password <span class="token keyword">for</span> test.<span class="token punctuation">(</span>current<span class="token punctuation">)</span> UNIX password:Enter new UNIX password:Retype new UNIX password:passwd: password updated successfully<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="禁用-1"><a href="#禁用-1" class="headerlink" title="禁用"></a>禁用</h4><p>禁止用户通过密码登录：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">passwd</span> -l user<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为了安全起见或者为了避免暴力破解，我们通常可以禁用密码登录，而只允许通过 SSH Key 登录。</p><p>如果要真地禁用整个帐号的使用，需要用上一节提到的 <code>usermod --expiredate 1</code>。</p><h3 id="用户组别"><a href="#用户组别" class="headerlink" title="用户组别"></a>用户组别</h3><p>类似帐号，主要操作也是增、删、改。</p><p>Linux 系统提供了底层的 <code>groupadd</code>, <code>groupdel</code> 和 <code>groupmod</code> 来完成相关操作，也提供了进一步的简化封装：<code>addgroup</code>, <code>delgroup</code>。</p><p>用户组别通常用来管理不同的资源，确保只有某个组别的用户才可以访问某类资源。当然，实际案例中，有些软件也为自己定义一个组别，只有该组别的用户才能访问该软件的一些功能。</p><h4 id="添加-1"><a href="#添加-1" class="headerlink" title="添加"></a>添加</h4><p>添加一个新组别：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># groupadd test</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># groupdel test</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="修改-2"><a href="#修改-2" class="headerlink" title="修改"></a>修改</h4><p>修改组别名：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># groupmod -n new_test test</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="用户和组"><a href="#用户和组" class="headerlink" title="用户和组"></a>用户和组</h3><p>用户和组别不能独立存在，<code>gpasswd</code> 可以用来处理两者的关系。</p><h4 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h4><p>从 docker 组中增加用户 test（等同于把 test 增加到 docker 组中）：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># gpasswd -a test docker</span>或<span class="token comment" spellcheck="true"># usermod -a -G docker test</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="删除-3"><a href="#删除-3" class="headerlink" title="删除"></a>删除</h4><p>从 test 组中删除用户 test：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># gpasswd -d test test</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="用户切换"><a href="#用户切换" class="headerlink" title="用户切换"></a>用户切换</h3><p>由于支持多用户，那么在登录一个帐号后，可能需要切换到另外一个帐号下，可以通过 <code>su</code> 命令完成，而 <code>sudo</code> 则可以用来作为另外一个用户来执行命令。</p><h4 id="切换帐号"><a href="#切换帐号" class="headerlink" title="切换帐号"></a>切换帐号</h4><p>切换到 Root 并启用 Bash：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">su</span> -s /bin/bash -root@falcon-desktop:~<span class="token comment" spellcheck="true">#</span>或者$ <span class="token function">sudo</span> -s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>切换到普通用户：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">su</span> -s /bin/bash - <span class="token function">test</span>test@falcon-desktop:~$ 或者$ <span class="token function">sudo</span> -i -u <span class="token function">test</span> test@falcon-desktop:~$ <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="免密码切到-Root"><a href="#免密码切到-Root" class="headerlink" title="免密码切到 Root"></a>免密码切到 Root</h4><p>首先得把用户加入到 sudo 用户组：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># usermod -a -G sudo falcon</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>否则，会看到如下信息：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> -s<span class="token punctuation">[</span>sudo<span class="token punctuation">]</span> password <span class="token keyword">for</span> test: <span class="token function">test</span> is not <span class="token keyword">in</span> the sudoers file.  This incident will be reported.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>加入 sudo 用户组以后：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> -s<span class="token punctuation">[</span>sudo<span class="token punctuation">]</span> password <span class="token keyword">for</span> test: <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>要实现免密切换，需要先修改 <code>/etc/sudoers</code>，加入如下一行：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">test</span> ALL<span class="token operator">=</span><span class="token punctuation">(</span>ALL<span class="token punctuation">)</span> NOPASSWD: ALL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者在 <code>/etc/sudoers.d/</code> 下创建一个文件并加入上述内容。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># echo "test ALL=(ALL) NOPASSWD: ALL" > /etc/sudoers.d/test</span><span class="token comment" spellcheck="true"># chmod 440 /etc/sudoers.d/test</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里，整个复习系列就要结束了，作为总结篇，主要回顾一下各个小节的主要内容，并总结出 Shell 编程的一些常用框架和相关注意事项等。</p><h3 id="正确使用-source-和"><a href="#正确使用-source-和" class="headerlink" title="正确使用 source 和 ."></a>正确使用 <code>source</code> 和 <code>.</code></h3><p>仅使用 <code>source</code> 和 <code>.</code> 来执行你的环境配置等功能，建议不要用于其它用途。 在Shell中使用脚本时，使用 <code>bash your_script.sh</code> 而不是 <code>source your_script.sh</code> 或 <code>. your_script.sh</code>。</p><p>当使用 <code>bash</code> 的时候，当前的Shell会创建一个新的子进程执行你的脚本；当使用 <code>source</code> 和 <code>.</code> 时，当前的Shell会直接解释执行 <code>your_script.sh</code> 中的代码。如果 <code>your_script.sh</code> 中包含了类似 <code>exit 0</code> 这样的代码，使用<code>source</code> 和 <code>.</code> 执行会导致当前Shell意外地退出。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 教程 </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell基础学习</title>
      <link href="posts/50641/"/>
      <url>posts/50641/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>主要包括 Shell 概述、 Shell 变量、位置参数、特殊符号、别名、各种控制语句、函数等 Shell 编程知识。</p><h3 id="执行-Shell-脚本的方式"><a href="#执行-Shell-脚本的方式" class="headerlink" title="执行 Shell 脚本的方式"></a>执行 Shell 脚本的方式</h3><h4 id="范例：输入重定向到-Bash"><a href="#范例：输入重定向到-Bash" class="headerlink" title="范例：输入重定向到 Bash"></a>范例：输入重定向到 Bash</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">bash</span> <span class="token operator">&lt;</span> ex1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以读入 <code>ex1</code> 中的程序，并执行</p><h4 id="范例：以脚本名作为参数"><a href="#范例：以脚本名作为参数" class="headerlink" title="范例：以脚本名作为参数"></a>范例：以脚本名作为参数</h4><p>其一般形式是：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">bash</span> 脚本名 ［参数<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">bash</span> ex2 /usr/meng /usr/zhang<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其执行过程与上一种方式一样，但这种方式的好处是能在脚本名后面带有参数，从而将参数值传递给程序中的命令，使一个 Shell 脚本可以处理多种情况，就如同函数调用时可根据具体问题传递相应的实参。</p><h4 id="范例：以-来执行"><a href="#范例：以-来执行" class="headerlink" title="范例：以 . 来执行"></a>范例：以 . 来执行</h4><p>如果以当前 Shell （以 <code>·</code> 表示）执行一个 Shell 脚本，则可以使用如下简便形式：</p><pre class="line-numbers language-bash"><code class="language-bash">$ · ex3［参数］<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="范例：直接执行"><a href="#范例：直接执行" class="headerlink" title="范例：直接执行"></a>范例：直接执行</h4><p>将 Shell 脚本的权限设置为可执行，然后在提示符下直接执行它。</p><p>具体办法：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">chmod</span> a+x ex4$ ./ex4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个要求在 Shell 脚本的开头指明执行该脚本的具体 Shell，例如 <code>/bin/bash</code>：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Shell-的执行原理"><a href="#Shell-的执行原理" class="headerlink" title="Shell 的执行原理"></a>Shell 的执行原理</h3><p>Shell 接收用户输入的命令（脚本名），并进行分析。如果文件被标记为可执行，但不是被编译过的程序，Shell 就认为它是一个 Shell 脚本。 Shell 将读取其中的内容，并加以解释执行。所以，从用户的观点看，执行 Shell 脚本的方式与执行一般的可执行文件的方式相似。</p><p>因此，用户开发的 Shell 脚本可以驻留在命令搜索路径的目录之下（通常是 <code>/bin</code>、<code>/usr/bin</code>等，可通过 <code>PATH</code> 环境变量设置和查看），像普通命令一样使用。这样，也就开发出自己的新命令。如果打算反复使用编好的 Shell 脚本，那么采用这种方式就比较方便。</p><h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><p>可以将一个命令的执行结果赋值给变量。有两种形式的命令替换：一种是使用倒引号引用命令，其一般形式是： <code>命令表</code>。</p><h4 id="范例：获取当前的工作目录并存放到变量中"><a href="#范例：获取当前的工作目录并存放到变量中" class="headerlink" title="范例：获取当前的工作目录并存放到变量中"></a>范例：获取当前的工作目录并存放到变量中</h4><p>例如：将当前工作目录的全路径名存放到变量dir中，输入以下命令行：</p><pre class="line-numbers language-bash"><code class="language-bash">$ dir<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">pwd</span><span class="token variable">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>另一种形式是：<code>$(命令表)</code>。上面的命令行也可以改写为：</p><pre class="line-numbers language-bash"><code class="language-bash">$ dir<span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><code>Bash</code> 只提供一维数组，并且没有限定数组的大小。类似与 C 语言，数组元素的下标由 0 开始编号。获取数组中的元素要利用下标。下标可以是整数或算术表达式，其值应大于或等于 0 。用户可以使用赋值语句对数组变量赋值。</p><h4 id="范例：对数组元素赋值"><a href="#范例：对数组元素赋值" class="headerlink" title="范例：对数组元素赋值"></a>范例：对数组元素赋值</h4><p>对数组元素赋值的一般形式是：<code>数组名[下标]＝值</code>，例如：</p><pre class="line-numbers language-bash"><code class="language-bash">$ city<span class="token punctuation">[</span>0<span class="token punctuation">]</span><span class="token operator">=</span>Beijing$ city<span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token operator">=</span>Shanghai$ city<span class="token punctuation">[</span>2<span class="token punctuation">]</span><span class="token operator">=</span>Tianjin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>也可以用 <code>declare</code> 命令显式声明一个数组，一般形式是：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">declare</span> -a 数组名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="范例：访问某个数组元素"><a href="#范例：访问某个数组元素" class="headerlink" title="范例：访问某个数组元素"></a>范例：访问某个数组元素</h4><p>读取数组元素值的一般格式是： <code>${数组名[下标]}</code>，例如：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">${city[0]}</span>Beijing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="范例：数组组合赋值"><a href="#范例：数组组合赋值" class="headerlink" title="范例：数组组合赋值"></a>范例：数组组合赋值</h4><p>一个数组的各个元素可以利用上述方式一个元素一个元素地赋值，也可以组合赋值。定义一个数组并为其赋初值的一般形式是：</p><pre class="line-numbers language-bash"><code class="language-bash">数组名<span class="token operator">=</span><span class="token punctuation">(</span>值1 值2 <span class="token punctuation">..</span>. 值n<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，各个值之间以空格分开。例如：</p><pre class="line-numbers language-bash"><code class="language-bash">$ A<span class="token operator">=</span><span class="token punctuation">(</span>this is an example of shell script<span class="token punctuation">)</span>$ <span class="token keyword">echo</span> <span class="token variable">${A[0]}</span> <span class="token variable">${A[2]}</span> <span class="token variable">${A[3]}</span> <span class="token variable">${A[6]}</span>this an example script$ <span class="token keyword">echo</span> <span class="token variable">${A[8]}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>由于值表中初值共有 7 个，所以 <code>A</code> 的元素个数也是 7 。 <code>A[8]</code> 超出了已赋值的数组 <code>A</code> 的范围，就认为它是一个新元素，由于预先没有赋值，所以它的值是空串。</p><p>若没有给出数组元素的下标，则数组名表示下标为 0 的数组元素，如 <code>city</code> 就等价于 <code>city[0]</code>。</p><h4 id="范例：列出数组中所有内容"><a href="#范例：列出数组中所有内容" class="headerlink" title="范例：列出数组中所有内容"></a>范例：列出数组中所有内容</h4><p>使用 <code>*</code> 或 <code>@</code> 做下标，则会以数组中所有元素取代。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">${A[*]}</span>this is an example of shell script<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="范例：获取数组元素个数"><a href="#范例：获取数组元素个数" class="headerlink" title="范例：获取数组元素个数"></a>范例：获取数组元素个数</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">${#A[*]}</span>7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>假如要编写一个 Shell 来求两个数的和，可以怎么实现呢？为了介绍参数传递的用法，编写这样一个脚本：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> <span class="token operator">></span> add<span class="token keyword">let</span> sum<span class="token operator">=</span><span class="token variable">$1</span>+<span class="token variable">$2</span><span class="token keyword">echo</span> <span class="token variable">$sum</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>保存后，执行一下：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">chmod</span> a+x ./add$ ./add 5 1015<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看出 5 和 10 分别传给了 <code>$1</code> 和 <code>$2</code>，这是 Shell 自己预设的参数顺序，其实也可以先定义好变量，然后传递进去。</p><p>例如，修改上述脚本得到：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">let</span> sum<span class="token operator">=</span><span class="token variable">$X</span>+<span class="token variable">$Y</span><span class="token keyword">echo</span> <span class="token variable">$sum</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>再次执行：</p><pre class="line-numbers language-bash"><code class="language-bash">$ X<span class="token operator">=</span>5 Y<span class="token operator">=</span>10 ./add15<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以发现，同样可以得到正确结果。</p><h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><p>export一个环境变量：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">export</span> opid<span class="token operator">=</span>True<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样子就可以，如果要登陆后都生效，可以直接添加到 <code>/etc/profile</code> 或者 <code>~/.bashrc</code> 里头。</p><h3 id="键盘读起变量值"><a href="#键盘读起变量值" class="headerlink" title="键盘读起变量值"></a>键盘读起变量值</h3><p>可以通过 <code>read</code> 来读取变量值，例如，来等待用户输入一个值并且显示出来：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">read</span> -p <span class="token string">"请输入一个值 ： "</span>  input <span class="token punctuation">;</span> <span class="token keyword">echo</span> <span class="token string">"你输入了一个值为 ："</span> <span class="token variable">$input</span>请输入一个值 ： 21500你输入了一个值为 ： 21500<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="设置变量的只读属性"><a href="#设置变量的只读属性" class="headerlink" title="设置变量的只读属性"></a>设置变量的只读属性</h3><p>有些重要的 Shell 变量，赋值后不应该修改，那么可设置它为 <code>readonly</code> ：</p><pre class="line-numbers language-bash"><code class="language-bash">$ oracle_home<span class="token operator">=</span>/usr/oracle7/bin$ <span class="token function">readonly</span> oracle_home<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="条件测试命令-test"><a href="#条件测试命令-test" class="headerlink" title="条件测试命令 test"></a>条件测试命令 test</h3><p>语法：<code>test 表达式</code> 如果表达式为真，则返回真，否则，返回假。</p><h4 id="范例：数值比较"><a href="#范例：数值比较" class="headerlink" title="范例：数值比较"></a>范例：数值比较</h4><p>先给出数值比较时常见的比较符：</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">-eg <span class="token operator">=</span>；-ne <span class="token operator">!=</span>；-gt <span class="token operator">></span>；-ge <span class="token operator">>=</span>；-lt <span class="token operator">&lt;</span>；-le <span class="token operator">&lt;=</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">test</span> var1 -gt var2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="范例：测试文件属性"><a href="#范例：测试文件属性" class="headerlink" title="范例：测试文件属性"></a>范例：测试文件属性</h4><p>文件的可读、可写、可执行，是否为普通文件，是否为目录分别对应：</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">-r<span class="token punctuation">;</span> -w<span class="token punctuation">;</span> -x<span class="token punctuation">;</span> -f<span class="token punctuation">;</span> -d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">test</span> -r filename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="范例：字符传属性以及比较"><a href="#范例：字符传属性以及比较" class="headerlink" title="范例：字符传属性以及比较"></a>范例：字符传属性以及比较</h4><blockquote><p>串的长度为零：<code>-z</code>； 非零：<code>-n</code>，如:</p></blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">test</span> -z s1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果串 <code>s1</code> 长度为零，返回真。</p><h4 id="范例：串比较"><a href="#范例：串比较" class="headerlink" title="范例：串比较"></a>范例：串比较</h4><blockquote><p>相等<code>&quot;s1&quot;=&quot;s2&quot;</code>； 不相等 <code>&quot;s1&quot;!=&quot;s2&quot;</code></p></blockquote><p>还有一种比较串的方法（可以按字典序来比较）：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token string">'abcde'</span> <span class="token operator">&lt;</span> <span class="token string">'abcdf'</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>  <span class="token keyword">echo</span> <span class="token string">"yeah,果然是诶"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>yeah,果然是诶<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="整数算术或关系运算-expr"><a href="#整数算术或关系运算-expr" class="headerlink" title="整数算术或关系运算 expr"></a>整数算术或关系运算 expr</h3><p>可用该命令进行的运算有：</p><blockquote><p>算术运算：<code>+ - * / %</code>；逻辑运算<code>：= ! &lt; &lt;= &gt; &gt;=</code></p></blockquote><p>如:</p><pre class="line-numbers language-bash"><code class="language-bash">$ i<span class="token operator">=</span>5<span class="token punctuation">;</span><span class="token function">expr</span> <span class="token variable">$i</span>+5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>另外，<code>bc</code> 是一个命令行计算器，可以进行一些算术计算。</p><h3 id="控制执行流程命令"><a href="#控制执行流程命令" class="headerlink" title="控制执行流程命令"></a>控制执行流程命令</h3><h4 id="范例：条件分支命令-if"><a href="#范例：条件分支命令-if" class="headerlink" title="范例：条件分支命令 if"></a>范例：条件分支命令 if</h4><p><code>if</code> 命令举例：如果第一个参数是一个普通文件名，那么分页打印该文件；否则，如果它为目录名，则进入该目录并打印该目录下的所有文件，如果也不是目录，那么提示相关信息。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token function">test</span> -f <span class="token variable">$1</span><span class="token keyword">then</span>    <span class="token function">pr</span> <span class="token variable">$1</span><span class="token operator">></span>/dev/lp0<span class="token keyword">elif</span>    test-d <span class="token variable">$1</span><span class="token keyword">then</span>    <span class="token punctuation">(</span>cd <span class="token variable">$1</span><span class="token punctuation">;</span><span class="token function">pr</span> *<span class="token operator">></span>/dev/lp0<span class="token punctuation">)</span><span class="token keyword">else</span>    <span class="token keyword">echo</span> <span class="token variable">$1</span> is neither a <span class="token function">file</span> nor a directory<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="范例：case-命令举例"><a href="#范例：case-命令举例" class="headerlink" title="范例：case 命令举例"></a>范例：case 命令举例</h4><p><code>case</code> 命令是一个基于模式匹配的多路分支命令，下面将根据用户键盘输入情况决定下一步将执行那一组命令。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">while</span> ［ <span class="token variable">$reply!</span><span class="token operator">=</span><span class="token string">"y"</span> ］ <span class="token operator">&amp;&amp;</span> <span class="token punctuation">[</span> <span class="token variable">$reply!</span><span class="token operator">=</span><span class="token string">"Y"</span> <span class="token punctuation">]</span>                         <span class="token comment" spellcheck="true">#下面将学习的循环语句</span><span class="token keyword">do</span>    <span class="token keyword">echo</span> <span class="token string">"\nAre you want to continue?(Y/N)\c"</span>    <span class="token function">read</span> reply             <span class="token comment" spellcheck="true">#读取键盘</span>    <span class="token keyword">case</span> <span class="token variable">$replay</span> <span class="token keyword">in</span>        <span class="token punctuation">(</span>y<span class="token operator">|</span>Y<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">#退出循环</span>        <span class="token punctuation">(</span>n<span class="token operator">|</span>N<span class="token punctuation">)</span> <span class="token keyword">echo</span> <span class="token string">"\n\nTerminating\n"</span>              <span class="token keyword">exit</span> 0<span class="token punctuation">;</span><span class="token punctuation">;</span>            *<span class="token punctuation">)</span> <span class="token keyword">echo</span> <span class="token string">"\n\nPlease answer y or n"</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">#直接返回内层循环开始出继续</span>    esac<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="范例：循环语句-while-until"><a href="#范例：循环语句-while-until" class="headerlink" title="范例：循环语句 while, until"></a>范例：循环语句 while, until</h4><p>语法：</p><pre class="line-numbers language-bash"><code class="language-bash">while/until 命令表1<span class="token keyword">do</span>    命令表2<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>区别是，前者执行命令表 1 后，如果退出状态为零，那么执行 <code>do</code> 后面的命令表 2，然后回到起始处，而后者执行命令表 1 后，如果退出状态非零，才执行类似操作。例子同上。</p><h4 id="范例：有限循环命令-for"><a href="#范例：有限循环命令-for" class="headerlink" title="范例：有限循环命令 for"></a>范例：有限循环命令 for</h4><p>语法：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">for</span> 变量名 <span class="token keyword">in</span> 字符串表<span class="token keyword">do</span>    命令表<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>举例：</p><pre class="line-numbers language-bash"><code class="language-bash">FILE<span class="token operator">=</span><span class="token string">"test1.c myfile1.f pccn.h"</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token variable">$FILE</span><span class="token keyword">do</span>    <span class="token function">cd</span> ./tmp    <span class="token function">cp</span> <span class="token variable">$i</span> <span class="token variable">$i</span>.old    <span class="token keyword">echo</span> <span class="token string">"<span class="token variable">$i</span> copied"</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>现在来看看 Shell 里头的函数用法，先看个例子：写一个函数，然后调用它显示 <code>Hello, World!</code></p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> <span class="token operator">></span> show<span class="token comment" spellcheck="true"># 函数定义</span><span class="token keyword">function</span> show<span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token variable">$1</span><span class="token variable">$2</span><span class="token punctuation">;</span><span class="token punctuation">}</span>H<span class="token operator">=</span><span class="token string">"Hello,"</span>W<span class="token operator">=</span><span class="token string">"World!"</span><span class="token comment" spellcheck="true"># 调用函数，并传给两个参数H和W</span>show <span class="token variable">$H</span> <span class="token variable">$W</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>演示：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">chmod</span> 770 show$./showHello,World<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>看出什么蹊跷了吗？</p><pre class="line-numbers language-bash"><code class="language-bash">$ show <span class="token variable">$H</span> <span class="token variable">$W</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>咱们可以直接在函数名后面跟实参。</p><p>实参顺序对应“虚参”的 <code>$1,$2,$3</code>……</p><p>注意：假如要传入一个参数，如果这个参数中间带空格，怎么办？ 先试试看。</p><p>来显示 <code>Hello World</code> （两个单词之间有个空格）</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">function</span> show<span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token variable">$1</span><span class="token punctuation">}</span>HW<span class="token operator">=</span><span class="token string">"Hello World"</span>show <span class="token string">"<span class="token variable">$HW</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果直接 <code>show $HW</code>，肯定不行，因为 <code>$1</code> 只接受到了 <code>Hello</code>，所以结果只显示 <code>Hello</code>，原因是字符串变量必须用 <code>&quot;</code> 包含起来。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 教程 </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell编程小结</title>
      <link href="posts/21090/"/>
      <url>posts/21090/</url>
      
        <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote><p>为了系统地学习和总结 Shell 编程，制定了一个 Shell 编程范例的总结计划，不会专门介绍 Shell 的语法， 而是假设对 Shell 编程有了一定的基础。另外，该系列涵盖：数值、逻辑值、字符串、文件、进程、文件系统等所有我们可以操作的“对象”，这个操作对象也将从低级到高级，进而上升到网络层面，整个通过各种方式连接起来的计算机的集合。实际上这也未尝不是在摸索 UNIX 的哲学，那”K.I.S.S”（Keep It Simple, Stupid）蕴藏的巨大能量。</p></blockquote><h3 id="什么是Shell"><a href="#什么是Shell" class="headerlink" title="什么是Shell"></a>什么是Shell</h3><p>首先让我们从下图看看 Shell 在整个操作系统中所处的位置吧，该图的外圆描述了整个操作系统（比如 <code>Debian/Ubuntu/Slackware</code> 等），内圆描述了操作系统的核心（比如 <code>Linux Kernel</code>），而 <code>Shell</code> 和 <code>GUI</code> 一样作为用户和操作系统之间的接口。</p><p><img src="https://tinylab.gitbooks.io/shellbook/content/zh/chapters/pic/UI_Shell_and_GUI.jpg" alt="UI_Shell_and_GUI"></p><p><code>GUI</code> 提供了一种图形化的用户接口，使用起来非常简便易学；而 <code>Shell</code> 则为用户提供了一种命令行的接口，接收用户的键盘输入，并分析和执行输入字符串中的命令，然后给用户返回执行结果，使用起来可能会复杂一些，但是由于占用的资源少，而且在操作熟练以后可能会提高工作效率，而且具有批处理的功能，因此在某些应用场合还非常流行。</p><p><code>Shell</code> 作为一种用户接口，它实际上是一个能够解释和分析用户键盘输入，执行输入中的命令，然后返回结果的一个解释程序（Interpreter，例如在 <code>linux</code> 下比较常用的 <code>Bash</code>），我们可以通过下面的命令查看当前的 <code>Shell</code> ：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$SHELL</span>/bin/bash$ <span class="token function">ls</span> -l /bin/bash-rwxr-xr-x 1 root root 702160 2020-06-18 02:33 /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>该解释程序不仅能够解释简单的命令，而且可以解释一个具有特定语法结构的文件，这种文件被称作脚本（Script）。它具体是如何解释这些命令和脚本文件的，这里不深入分析。</p><h3 id="搭建运行环境"><a href="#搭建运行环境" class="headerlink" title="搭建运行环境"></a>搭建运行环境</h3><p>为了方便后面的练习，我们先搭建一个基本运行环境：在一个 Linux 操作系统中，有一个运行有 <code>Bash</code> 的命令行在等待我们键入命令，这个命令行可以是图形界面下的 <code>Terminal</code> （例如 <code>Ubuntu</code> 下非常厉害的 <code>Terminator</code>），也可以是字符界面的 <code>Console</code> （可以用 <code>CTRL+ALT+F1~6</code> 切换），如果你发现当前 <code>Shell</code> 不是 <code>Bash</code>，请用下面的方法替换它：</p><pre class="line-numbers language-bash"><code class="language-bash">$ chsh <span class="token variable">$USER</span> -s /bin/bash$ <span class="token function">su</span> <span class="token variable">$USER</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>或者是简单地键入Bash：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">bash</span>$ <span class="token keyword">echo</span> <span class="token variable">$SHELL</span>  <span class="token comment" spellcheck="true"># 确认一下</span>/bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>有了基本的运行环境，那么如何来运行用户键入的命令或者是用户编写好的脚本文件呢 <code>?</code></p><p>假设我们编写好了一个 Shell 脚本，叫 <code>test.sh</code> 。</p><p>第一种方法是确保我们执行的命令具有可执行权限，然后直接键入该命令执行它：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">chmod</span> +x /path/to/test.sh$ /path/to/test.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第二种方法是直接把脚本作为 <code>Bash</code> 解释器的参数传入：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">bash</span> /path/to/test.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">source</span> /path/to/test.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">.</span> /path/to/test.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>###基本语法介绍</p><p>先来一个 <code>Hello, World</code> 程序。</p><p>下面来介绍一个 Shell 程序的基本结构，以 <code>Hello, World</code> 为例：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span> -v<span class="token comment" spellcheck="true"># test.sh</span><span class="token keyword">echo</span> <span class="token string">"Hello, World"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>把上述代码保存为 <code>test.sh</code>，然后通过上面两种不同方式运行，可以看到如下效果。</p><p>方法一：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">chmod</span> +x test.sh$ ./test.sh ./test.sh <span class="token comment" spellcheck="true">#!/bin/bash -v</span> <span class="token keyword">echo</span> <span class="token string">"Hello, World"</span> Hello, World<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法二：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">bash</span> test.shHello, World$ <span class="token function">source</span> test.shHello, World$ <span class="token keyword">.</span> test.shHello, World<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们发现两者运行结果有区别，为什么呢？这里我们需要关注一下 <code>test.sh</code> 文件的内容，它仅仅有两行，第二行打印了 <code>Hello, World</code>，两种方法都达到了目的，但是第一种方法却多打印了脚本文件本身的内容，为什么呢？</p><p>原因在该文件的第一行，当我们直接运行该脚本文件时，该行告诉操作系统使用用<code>#!</code> 符号之后面的解释器以及相应的参数来解释该脚本文件，通过分析第一行，我们发现对应的解释器以及参数是 <code>/bin/bash -v</code>，而 <code>-v</code> 刚好就是要打印程序的源代码；但是我们在用第二种方法时没有给 <code>Bash</code> 传递任何额外的参数，因此，它仅仅解释了脚本文件本身。</p><p>其他语法细节请直接看每一章小结后的附录。</p><h3 id="Shell-程序设计过程"><a href="#Shell-程序设计过程" class="headerlink" title="Shell 程序设计过程"></a>Shell 程序设计过程</h3><p>Shell 语言作为解释型语言，它的程序设计过程跟编译型语言有些区别，其基本过程如下：</p><ul><li>设计算法</li><li>用 Shell 编写脚本程序实现算法</li><li>直接运行脚本程序</li></ul><p>可见它没有编译型语言的”麻烦的”编译和链接过程，不过正是因为这样，它出错时调试起来不是很方便，因为语法错误和逻辑错误都在运行时出现。下面我们简单介绍一下调试方法。</p><h3 id="调试方法介绍"><a href="#调试方法介绍" class="headerlink" title="调试方法介绍"></a>调试方法介绍</h3><p>可以直接参考资料：<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-shell-debug/index.html">Shell 脚本调试技术</a> 或者 <a href="http://www.tinylab.org/bash-debugging-tools/">BASH 的调试手段</a>。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Shell 语言作为一门解释型语言，可以使用大量的现有工具，包括数值计算、符号处理、文件操作、网络操作等，因此，编写过程可能更加高效，但是因为它是解释型的，需要在执行过程中从磁盘上不断调用外部的程序并进行进程之间的切换，在运行效率方面可能有劣势，所以我们应该根据应用场合选择使用 Shell 或是用其他的语言来编程。</p><h2 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这一小节开始，打算结合平时积累和进一步实践，通过一些范例来介绍Shell编程。因为范例往往能够给人以学有所用的感觉，而且给人以动手实践的机会，从而激发人的学习热情。</p><p>考虑到易读性，这些范例将非常简单，但是实用，希望它们能够成为我们解决日常问题的参照物或者是“茶余饭后”的小点心，当然这些“点心”肯定还有值得探讨、优化的地方。</p><p>概要：</p><ul><li>目的：享受用 Shell 解决问题的乐趣；和朋友们一起交流和探讨。</li><li>读者：熟悉 Linux 基本知识，如文件系统结构、常用命令行工具、Shell 编程基础等。</li><li>补充：看范例时，可参考<a href="http://bbs.chinaunix.net/forum.php?mod=viewthread&tid=2198159">《Shell基础十二篇》</a>和<a href="http://bbs.chinaunix.net/thread-218853-1-1.html">《Shell十三问》</a>。</li><li>环境：如没特别说明，该系列使用的 Shell 将特指 Bash，版本在 3.1.17 以上。</li><li>说明：该系列不是依据 Shell 语法组织，而是面向某些潜在的操作对象和操作本身，它们反应了现实应用。当然，在这个过程中肯定会涉及到 Shell 的语法。</li></ul><p>这一小节打算讨论一下 Shell 编程中的基本数值运算，这类运算包括：</p><ul><li>数值（包括整数和浮点数）间的加、减、乘、除、求幂、求模等</li><li>产生指定范围的随机数</li><li>产生指定范围的数列</li></ul><p>Shell 本身可以做整数运算，复杂一些的运算要通过外部命令实现，比如 <code>expr</code>，<code>bc</code>，<code>awk</code> 等。另外，可通过 <code>RANDOM</code> 环境变量产生一个从 0 到 32767 的随机数，一些外部工具，比如 <code>awk</code> 可以通过 <code>rand()</code> 函数产生随机数。而 <code>seq</code> 命令可以用来产生一个数列。下面对它们分别进行介绍。</p><h3 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h3><h4 id="范例：对某个数加-1"><a href="#范例：对某个数加-1" class="headerlink" title="范例：对某个数加 1"></a>范例：对某个数加 1</h4><pre class="line-numbers language-bash"><code class="language-bash">$ i<span class="token operator">=</span>0<span class="token punctuation">;</span>$ <span class="token variable"><span class="token punctuation">((</span>i<span class="token operator">++</span><span class="token punctuation">))</span></span>$ <span class="token keyword">echo</span> <span class="token variable">$i</span>1$ <span class="token keyword">let</span> i++$ <span class="token keyword">echo</span> <span class="token variable">$i</span>2$ <span class="token function">expr</span> <span class="token variable">$i</span> + 13$ <span class="token keyword">echo</span> <span class="token variable">$i</span>2$ <span class="token keyword">echo</span> <span class="token variable">$i</span> 1 <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{printf <span class="token variable">$1</span>+<span class="token variable">$2</span>}'</span>3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明： <code>expr</code> 之后的 <code>$i</code>，<code>+</code>，1 之间有空格分开。如果进行乘法运算，需要对运算符进行转义，否则 Shell 会把乘号解释为通配符，导致语法错误； <code>awk</code> 后面的 <code>$1</code> 和 <code>$2</code> 分别指 <code>$i</code> 和 1，即从左往右的第 1 个和第 2 个数。</p><p>用 Shell 的内置命令查看各个命令的类型如下：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">type</span> <span class="token function">type</span><span class="token function">type</span> is a shell <span class="token function">builtin</span>$ <span class="token function">type</span> <span class="token keyword">let</span><span class="token keyword">let</span> is a shell <span class="token function">builtin</span>$ <span class="token function">type</span> <span class="token function">expr</span><span class="token function">expr</span> is hashed <span class="token punctuation">(</span>/usr/bin/expr<span class="token punctuation">)</span>$ <span class="token function">type</span> <span class="token function">bc</span><span class="token function">bc</span> is hashed <span class="token punctuation">(</span>/usr/bin/bc<span class="token punctuation">)</span>$ <span class="token function">type</span> <span class="token function">awk</span><span class="token function">awk</span> is /usr/bin/awk<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上述演示可看出： <code>let</code> 是 Shell 内置命令，其他几个是外部命令，都在 <code>/usr/bin</code> 目录下。而 <code>expr</code> 和 <code>bc</code> 因为刚用过，已经加载在内存的 <code>hash</code> 表中。这将有利于我们理解在上一章介绍的脚本多种执行方法背后的原理。</p><p>说明：如果要查看不同命令的帮助，对于 <code>let</code> 和 <code>type</code> 等 Shell 内置命令，可以通过 Shell 的一个内置命令 <code>help</code> 来查看相关帮助，而一些外部命令可以通过 Shell 的一个外部命令 <code>man</code> 来查看帮助，用法诸如 <code>help let</code>，<code>man expr</code> 等。</p><h4 id="范例：从-1-加到某个数"><a href="#范例：从-1-加到某个数" class="headerlink" title="范例：从 1 加到某个数"></a>范例：从 1 加到某个数</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment" spellcheck="true"># calc.sh</span>i<span class="token operator">=</span>0<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token variable">$i</span> -lt 10000 <span class="token punctuation">]</span><span class="token keyword">do</span>    <span class="token variable"><span class="token punctuation">((</span>i<span class="token operator">++</span><span class="token punctuation">))</span></span><span class="token keyword">done</span><span class="token keyword">echo</span> <span class="token variable">$i</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：这里通过 <code>while [ 条件表达式 ]; do .... done</code> 循环来实现。<code>-lt</code> 是小于号 <code>&lt;</code>，具体见 <code>test</code> 命令的用法：<code>help test</code>。</p><p>如何执行该脚本？</p><p>办法一：直接把脚本文件当成子 Shell （Bash）的一个参数传入</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">bash</span> calc.sh$ <span class="token function">type</span> <span class="token function">bash</span><span class="token function">bash</span> is hashed <span class="token punctuation">(</span>/bin/bash<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>办法二：是通过 <code>bash</code> 的内置命令 <code>.</code> 或 <code>source</code> 执行</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">.</span> ./calc.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">source</span> ./calc.sh$ <span class="token function">type</span> <span class="token keyword">.</span><span class="token keyword">.</span> is a shell <span class="token function">builtin</span>$ <span class="token function">type</span> <span class="token function">source</span><span class="token function">source</span> is a shell <span class="token function">builtin</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>办法三：是修改文件为可执行，直接在当前 Shell 下执行</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">chmod</span> ./calc.sh$ ./calc.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>下面，逐一演示用其他方法计算变量加一，即把 <code>((i++))</code> 行替换成下面的某一个：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">let</span> i++<span class="token punctuation">;</span>i<span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">expr</span> $i + 1<span class="token variable">)</span></span>i<span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token keyword">echo</span> $i+1<span class="token operator">|</span><span class="token function">bc</span><span class="token variable">)</span></span>i<span class="token operator">=</span><span class="token punctuation">$(</span>echo <span class="token string">"<span class="token variable">$i</span> 1"</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{printf <span class="token variable">$1</span>+<span class="token variable">$2</span>;}'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>比较计算时间如下：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">time</span> calc.sh10000real    0m1.319suser    0m1.056ssys     0m0.036s$ <span class="token function">time</span> calc_let.sh10000real    0m1.426suser    0m1.176ssys     0m0.032s$  <span class="token function">time</span> calc_expr.sh1000real    0m27.425suser    0m5.060ssys     0m14.177s$ <span class="token function">time</span> calc_bc.sh1000real    0m56.576suser    0m9.353ssys     0m24.618s$ <span class="token function">time</span> ./calc_awk.sh100real    0m11.672suser    0m2.604ssys     0m2.660s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明： <code>time</code> 命令可以用来统计命令执行时间，这部分时间包括总的运行时间，用户空间执行时间，内核空间执行时间，它通过 <code>ptrace</code> 系统调用实现。</p><p>通过上述比较可以发现 <code>(())</code> 的运算效率最高。而 <code>let</code> 作为 Shell 内置命令，效率也很高，但是 <code>expr</code>，<code>bc</code>，<code>awk</code> 的计算效率就比较低。所以，在 Shell 本身能够完成相关工作的情况下，建议优先使用 Shell 本身提供的功能。但是 Shell 本身无法完成的功能，比如浮点运算，所以就需要外部命令的帮助。另外，考虑到 Shell 脚本的可移植性，在性能不是很关键的情况下，不要使用某些 Shell 特有的语法。</p><p><code>let</code>，<code>expr</code>，<code>bc</code> 都可以用来求模，运算符都是 <code>%</code>，而 <code>let</code> 和 <code>bc</code> 可以用来求幂，运算符不一样，前者是 <code>**</code>，后者是 <code>^</code> 。例如：</p><h4 id="范例：求模"><a href="#范例：求模" class="headerlink" title="范例：求模"></a>范例：求模</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">expr</span> 5 % 21$ <span class="token keyword">let</span> i<span class="token operator">=</span>5%2$ <span class="token keyword">echo</span> <span class="token variable">$i</span>1$ <span class="token keyword">echo</span> 5 % 2 <span class="token operator">|</span> <span class="token function">bc</span>1$ <span class="token variable"><span class="token punctuation">((</span>i<span class="token operator">=</span><span class="token number">5</span><span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">))</span></span>$ <span class="token keyword">echo</span> <span class="token variable">$i</span>1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="范例：求幂"><a href="#范例：求幂" class="headerlink" title="范例：求幂"></a>范例：求幂</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">let</span> i<span class="token operator">=</span>5**2$ <span class="token keyword">echo</span> <span class="token variable">$i</span>25$ <span class="token variable"><span class="token punctuation">((</span>i<span class="token operator">=</span><span class="token number">5</span><span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">))</span></span>$ <span class="token keyword">echo</span> <span class="token variable">$i</span>25$ <span class="token keyword">echo</span> <span class="token string">"5^2"</span> <span class="token operator">|</span> <span class="token function">bc</span>25<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="范例：进制转换"><a href="#范例：进制转换" class="headerlink" title="范例：进制转换"></a>范例：进制转换</h4><p>进制转换也是比较常用的操作，可以用 <code>Bash</code> 的内置支持也可以用 <code>bc</code> 来完成，例如把 8 进制的 11 转换为 10 进制，则可以：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token string">"obase=10;ibase=8;11"</span> <span class="token operator">|</span> <span class="token function">bc</span> -l9$ <span class="token keyword">echo</span> <span class="token punctuation">$((</span>8<span class="token comment" spellcheck="true">#11))</span>9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面都是把某个进制的数转换为 10 进制的，如果要进行任意进制之间的转换还是 <code>bc</code> 比较灵活，因为它可以直接用 <code>ibase</code> 和 <code>obase</code> 分别指定进制源和进制转换目标。</p><h4 id="范例：ascii-字符编码"><a href="#范例：ascii-字符编码" class="headerlink" title="范例：ascii 字符编码"></a>范例：ascii 字符编码</h4><p>如果要把某些字符串以特定的进制表示，可以用 <code>od</code> 命令，例如默认的分隔符 <code>IFS</code> 包括空格、 <code>TAB</code> 以及换行，可以用 <code>man ascii</code> 佐证。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> -n <span class="token string">"<span class="token variable">$IFS</span>"</span> <span class="token operator">|</span> od -c0000000      t  n0000003$ <span class="token keyword">echo</span> -n <span class="token string">"<span class="token variable">$IFS</span>"</span> <span class="token operator">|</span> od -b0000000 040 011 0120000003<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h3><p><code>let</code> 和 <code>expr</code> 都无法进行浮点运算，但是 <code>bc</code> 和 <code>awk</code> 可以。</p><h4 id="范例：求-1-除以-13，保留-3-位有效数字"><a href="#范例：求-1-除以-13，保留-3-位有效数字" class="headerlink" title="范例：求 1 除以 13，保留 3 位有效数字"></a>范例：求 1 除以 13，保留 3 位有效数字</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token string">"scale=3; 1/13"</span>  <span class="token operator">|</span> <span class="token function">bc</span>.076$ <span class="token keyword">echo</span> <span class="token string">"1 13"</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{printf("%0.3f\n",<span class="token variable">$1</span>/<span class="token variable">$2</span>)}'</span>0.077<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明： <code>bc</code> 在进行浮点运算时需指定精度，否则默认为 0，即进行浮点运算时，默认结果只保留整数。而 <code>awk</code> 在控制小数位数时非常灵活，仅仅通过 <code>printf</code> 的格式控制就可以实现。</p><p>补充：在用 <code>bc</code> 进行运算时，如果不用 <code>scale</code> 指定精度，而在 <code>bc</code> 后加上 <code>-l</code> 选项，也可以进行浮点运算，只不过这时的默认精度是 20 位。例如：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> 1/13100 <span class="token operator">|</span> <span class="token function">bc</span> -l.00007633587786259541<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="范例：余弦值转角度"><a href="#范例：余弦值转角度" class="headerlink" title="范例：余弦值转角度"></a>范例：余弦值转角度</h4><p>用 <code>bc -l</code> 计算，可以获得高精度：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">export</span> cos<span class="token operator">=</span>0.996293<span class="token punctuation">;</span> <span class="token keyword">echo</span> <span class="token string">"scale=100; a(sqrt(1-<span class="token variable">$cos</span>^2)/<span class="token variable">$cos</span>)*180/(a(1)*4)"</span> <span class="token operator">|</span> <span class="token function">bc</span> -l4.9349547554113836327198340369318406051597063986552438753727649177325495504159766011527078286004072131<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当然也可以用 <code>awk</code> 来计算：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> 0.996293 <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{ printf("%s\n", atan2(sqrt(1-<span class="token variable">$1</span>^2),<span class="token variable">$1</span>)*180/3.1415926535);}'</span>4.93495<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="范例：有一组数据，求人均月收入最高家庭"><a href="#范例：有一组数据，求人均月收入最高家庭" class="headerlink" title="范例：有一组数据，求人均月收入最高家庭"></a>范例：有一组数据，求人均月收入最高家庭</h4><p>在这里随机产生了一组测试数据，文件名为 <code>income.txt</code>。</p><pre class="line-numbers language-bash"><code class="language-bash">1 3 44902 5 38963 4 31124 4 47165 4 45786 6 53997 3 50898 6 30299 4 619510 5 5145<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：上面的三列数据分别是家庭编号、家庭人数、家庭月总收入。</p><p>分析：为了求月均收入最高家庭，需要对后面两列数进行除法运算，即求出每个家庭的月均收入，然后按照月均收入排序，找出收入最高家庭。</p><p>实现：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment" spellcheck="true"># gettopfamily.sh</span><span class="token punctuation">[</span> $<span class="token comment" spellcheck="true"># -lt 1 ] &amp;&amp; echo "please input the income file" &amp;&amp; exit -1</span><span class="token punctuation">[</span> <span class="token operator">!</span> -f <span class="token variable">$1</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">echo</span> <span class="token string">"<span class="token variable">$1</span> is not a file"</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">exit</span> -1income<span class="token operator">=</span><span class="token variable">$1</span><span class="token function">awk</span> <span class="token string">'{    printf("%d %0.2f\n", <span class="token variable">$1</span>, <span class="token variable">$3</span>/<span class="token variable">$2</span>);}'</span> <span class="token variable">$income</span> <span class="token operator">|</span> <span class="token function">sort</span> -k 2 -n -r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><ul><li><code>[ $# -lt 1 ]</code>：要求至少输入一个参数，<code>$#</code> 是 Shell 中传入参数的个数</li><li><code>[ ! -f $1 ]</code>：要求输入参数是一个文件，<code>-f</code> 的用法见 <code>test</code> 命令，<code>help test</code></li><li><code>income=$1</code>：把输入参数赋给 income 变量，再作为 <code>awk</code> 的参数，即需处理的文件</li><li><code>awk</code>：用文件第三列除以第二列，求出月均收入，考虑到精确性，保留了两位精度</li><li><code>sort -k 2 -n -r</code>：这里对结果的 <code>awk</code> 结果的第二列 <code>-k 2</code>，即月均收入进行排序，按照数字排序 <code>-n</code>，并按照递减的顺序排序 <code>-r</code>。</li></ul><p>演示：</p><pre class="line-numbers language-bash"><code class="language-bash">$ ./gettopfamily.sh income.txt7 1696.339 1548.751 1496.674 1179.005 1144.5010 1029.006 899.832 779.203 778.008 504.83<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>补充：之前的 <code>income.txt</code> 数据是随机产生的。在做一些实验时，往往需要随机产生一些数据，在下一小节，我们将详细介绍它。这里是产生 <code>income.txt</code> 数据的脚本：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment" spellcheck="true"># genrandomdata.sh</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">seq</span> 1 10<span class="token variable">)</span></span><span class="token keyword">do</span>    <span class="token keyword">echo</span> <span class="token variable">$i</span> <span class="token variable"><span class="token variable">$((</span>$RANDOM<span class="token operator">/</span><span class="token number">8192</span><span class="token operator">+</span><span class="token number">3</span><span class="token variable">))</span></span> <span class="token variable"><span class="token variable">$((</span>RANDOM<span class="token operator">/</span><span class="token number">10</span><span class="token operator">+</span><span class="token number">3000</span><span class="token variable">))</span></span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：上述脚本中还用到<code>seq</code>命令产生从1到10的一列数，这个命令的详细用法在该篇最后一节也会进一步介绍。</p><h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><p>环境变量 <code>RANDOM</code> 产生从 0 到 32767 的随机数，而 <code>awk</code> 的 <code>rand()</code> 函数可以产生 0 到 1 之间的随机数。</p><h4 id="范例：获取一个随机数"><a href="#范例：获取一个随机数" class="headerlink" title="范例：获取一个随机数"></a>范例：获取一个随机数</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$RANDOM</span>81$ <span class="token keyword">echo</span> <span class="token string">""</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{srand(); printf("%f", rand());}'</span>0.237788<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明： <code>srand()</code> 在无参数时，采用当前时间作为 <code>rand()</code> 随机数产生器的一个 <code>seed</code> 。</p><h4 id="范例：随机产生一个从-0-到-255-之间的数字"><a href="#范例：随机产生一个从-0-到-255-之间的数字" class="headerlink" title="范例：随机产生一个从 0 到 255 之间的数字"></a>范例：随机产生一个从 0 到 255 之间的数字</h4><p>可以通过 <code>RANDOM</code> 变量的缩放和 <code>awk</code> 中 <code>rand()</code> 的放大来实现。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">expr</span> <span class="token variable">$RANDOM</span> / 128$ <span class="token keyword">echo</span> <span class="token string">""</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{srand(); printf("%d\n", rand()*255);}'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>思考：如果要随机产生某个 IP 段的 IP 地址，该如何做呢？看例子：友善地获取一个可用的 IP 地址。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment" spellcheck="true"># getip.sh -- get an usable ipaddress automatically</span><span class="token comment" spellcheck="true"># author: falcon &amp;lt;zhangjinw@gmail.com></span><span class="token comment" spellcheck="true"># update: Tue Oct 30 23:46:17 CST 2007</span><span class="token comment" spellcheck="true"># set your own network, default gateway, and the time out of "ping" command</span>net<span class="token operator">=</span><span class="token string">"192.168.1"</span>default_gateway<span class="token operator">=</span><span class="token string">"192.168.1.1"</span>over_time<span class="token operator">=</span>2<span class="token comment" spellcheck="true"># check the current ipaddress</span><span class="token function">ping</span> -c 1 <span class="token variable">$default_gateway</span> -W <span class="token variable">$over_time</span><span class="token punctuation">[</span> <span class="token variable">$?</span> -eq 0 <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">echo</span> <span class="token string">"the current ipaddress is okey!"</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">exit</span> -1<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token keyword">:</span><span class="token punctuation">;</span> <span class="token keyword">do</span>    <span class="token comment" spellcheck="true"># clear the current configuration</span>    <span class="token function">ifconfig</span> eth0 down    <span class="token comment" spellcheck="true"># configure the ip address of the eth0</span>    <span class="token function">ifconfig</span> eth0 \        <span class="token variable">$net</span><span class="token keyword">.</span><span class="token variable"><span class="token variable">$((</span>$RANDOM <span class="token operator">/</span><span class="token number">130</span> <span class="token operator">+</span><span class="token number">2</span><span class="token variable">))</span></span> \        up    <span class="token comment" spellcheck="true"># configure the default gateway</span>    route add default gw <span class="token variable">$default_gateway</span>    <span class="token comment" spellcheck="true"># check the new configuration</span>    <span class="token function">ping</span> -c 1 <span class="token variable">$default_gateway</span> -W <span class="token variable">$over_time</span>    <span class="token comment" spellcheck="true"># if work, finish</span>    <span class="token punctuation">[</span> <span class="token variable">$?</span> -eq 0 <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">break</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：如果你的默认网关地址不是 <code>192.168.1.1</code>，请自行配置 <code>default_gateway</code>（可以用 <code>route -n</code> 命令查看），因为用 <code>ifconfig</code> 配置地址时不能配置为网关地址，否则你的IP地址将和网关一样，导致整个网络不能正常工作。</p><h3 id="其他运算"><a href="#其他运算" class="headerlink" title="其他运算"></a>其他运算</h3><p>其实通过一个循环就可以产生一系列数，但是有相关工具为什么不用呢！<code>seq</code> 就是这么一个小工具，它可以产生一系列数，你可以指定数的递增间隔，也可以指定相邻两个数之间的分割符。</p><h4 id="范例：获取一系列数"><a href="#范例：获取一系列数" class="headerlink" title="范例：获取一系列数"></a>范例：获取一系列数</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">seq</span> 512345$ <span class="token function">seq</span> 1 512345$ <span class="token function">seq</span> 1 2 5135$ <span class="token function">seq</span> -s: 1 2 51:3:5$ <span class="token function">seq</span> 1 2 14135791113$ <span class="token function">seq</span> -w 1 2 1401030507091113$ <span class="token function">seq</span> -s: -w 1 2 1401:03:05:07:09:11:13$ <span class="token function">seq</span> -f <span class="token string">"0x%g"</span> 1 50x10x20x30x40x5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个比较典型的使用 <code>seq</code> 的例子，构造一些特定格式的链接，然后用 <code>wget</code> 下载这些内容：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">for</span> i <span class="token keyword">in</span> `seq -f<span class="token string">"http://thns.tsinghua.edu.cn/thnsebooks/ebook73/%02g.pdf"</span> 1 21`<span class="token punctuation">;</span><span class="token keyword">do</span> <span class="token function">wget</span> -c <span class="token variable">$i</span><span class="token punctuation">;</span> <span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token variable"><span class="token variable">`</span><span class="token function">seq</span> -w 1 21<span class="token variable">`</span></span><span class="token punctuation">;</span><span class="token keyword">do</span> <span class="token function">wget</span> -c <span class="token string">"http://thns.tsinghua.edu.cn/thnsebooks/ebook73/<span class="token variable">$i</span>"</span><span class="token punctuation">;</span> <span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>补充：在 <code>Bash</code> 版本 3 以上，在 <code>for</code> 循环的 <code>in</code> 后面，可以直接通过 <code>{1..5}</code> 更简洁地产生自 1 到 5 的数字（注意，1 和 5 之间只有两个点），例如：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token punctuation">{</span>1<span class="token punctuation">..</span>5<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token keyword">echo</span> -n <span class="token string">"<span class="token variable">$i</span> "</span><span class="token punctuation">;</span> <span class="token keyword">done</span>1 2 3 4 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="范例：统计字符串中各单词出现次数"><a href="#范例：统计字符串中各单词出现次数" class="headerlink" title="范例：统计字符串中各单词出现次数"></a>范例：统计字符串中各单词出现次数</h4><p>我们先给单词一个定义：由字母组成的单个或者多个字符系列。</p><p>首先，统计每个单词出现的次数：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">wget</span> -c http://tinylab.org$ <span class="token function">cat</span> index.html <span class="token operator">|</span> <span class="token function">sed</span> -e <span class="token string">"s/[^a-zA-Z]/\n/g"</span> <span class="token operator">|</span> <span class="token function">grep</span> -v ^$ <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">uniq</span> -c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>接着，统计出现频率最高的前10个单词：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">wget</span> -c http://tinylab.org$ <span class="token function">cat</span> index.html <span class="token operator">|</span> <span class="token function">sed</span> -e <span class="token string">"s/[^a-zA-Z]/\n/g"</span> <span class="token operator">|</span> <span class="token function">grep</span> -v ^$ <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">uniq</span> -c <span class="token operator">|</span> <span class="token function">sort</span> -n -k 1 -r <span class="token operator">|</span> <span class="token function">head</span> -10    524 a    238 tag    205 href    201 class    193 http    189 org    175 tinylab    174 www    146 div    128 title<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><ul><li><code>cat index.html</code>: 输出 index.html 文件里的内容</li><li><code>sed -e &quot;s/[^a-zA-Z]/\n/g&quot;</code>: 把非字母字符替换成空格，只保留字母字符</li><li><code>grep -v ^$</code>: 去掉空行</li><li><code>sort</code>: 排序</li><li><code>uniq -c</code>：统计相同行的个数，即每个单词的个数</li><li><code>sort -n -k 1 -r</code>：按照第一列 <code>-k 1</code> 的数字 <code>-n</code> 逆序 <code>-r</code> 排序</li><li><code>head -10</code>：取出前十行</li></ul><h4 id="范例：统计指定单词出现次数"><a href="#范例：统计指定单词出现次数" class="headerlink" title="范例：统计指定单词出现次数"></a>范例：统计指定单词出现次数</h4><p>可以考虑采取两种办法：</p><ul><li>只统计那些需要统计的单词</li><li>用上面的算法把所有单词的个数都统计出来，然后再返回那些需要统计的单词给用户</li></ul><p>不过，这两种办法都可以通过下面的结构来实现。先看办法一：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment" spellcheck="true"># statistic_words.sh</span><span class="token keyword">if</span> <span class="token punctuation">[</span> $<span class="token comment" spellcheck="true"># -lt 1 ]; then</span>    <span class="token keyword">echo</span> <span class="token string">"Usage: basename <span class="token variable">$0</span> FILE WORDS ...."</span>    <span class="token keyword">exit</span> -1<span class="token keyword">fi</span>FILE<span class="token operator">=</span><span class="token variable">$1</span><span class="token punctuation">((</span>WORDS_NUM<span class="token operator">=</span>$<span class="token comment" spellcheck="true">#-1))</span><span class="token keyword">for</span> n <span class="token keyword">in</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">seq</span> $WORDS_NUM<span class="token variable">)</span></span><span class="token keyword">do</span>    <span class="token function">shift</span>    <span class="token function">cat</span> <span class="token variable">$FILE</span> <span class="token operator">|</span> <span class="token function">sed</span> -e <span class="token string">"s/[^a-zA-Z]/\n/g"</span> \        <span class="token operator">|</span> <span class="token function">grep</span> -v ^$ <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">grep</span> ^<span class="token variable">$1</span>$ <span class="token operator">|</span> <span class="token function">uniq</span> -c<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><ul><li><code>if 条件部分</code>：要求至少两个参数，第一个单词文件，之后参数为要统计的单词</li><li><code>FILE=$1</code>: 获取文件名，即脚本之后的第一个字符串</li><li><code>((WORDS_NUM=$#-1))</code>：获取单词个数，即总的参数个数 <code>$#</code> 减去文件名参数（1个）</li><li><code>for 循环部分</code>：首先通过 <code>seq</code> 产生需要统计的单词个数系列，<code>shift</code> 是 Shell 内置变量（请通过 <code>help shift</code> 获取帮助)，它把用户从命令行中传入的参数依次往后移动位置，并把当前参数作为第一个参数即 <code>$1</code>，这样通过 <code>$1</code>就可以遍历用户所有输入的单词（仔细一想，这里貌似有数组下标的味道）。你可以考虑把 <code>shift</code> 之后的那句替换成 <code>echo $1</code> 测试 <code>shift</code> 的用法</li></ul><p>演示：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">chmod</span> +x statistic_words.sh$ ./statistic_words.sh index.html tinylab linux python    175 tinylab     43 linux      3 python<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再看办法二，我们只需要修改 <code>shift</code> 之后的那句即可：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment" spellcheck="true"># statistic_words.sh</span><span class="token keyword">if</span> <span class="token punctuation">[</span> $<span class="token comment" spellcheck="true"># -lt 1 ]; then</span>    <span class="token keyword">echo</span> <span class="token string">"ERROR: you should input 2 words at least"</span><span class="token punctuation">;</span>    <span class="token keyword">echo</span> <span class="token string">"Usage: basename <span class="token variable">$0</span> FILE WORDS ...."</span>    <span class="token keyword">exit</span> -1<span class="token keyword">fi</span>FILE<span class="token operator">=</span><span class="token variable">$1</span><span class="token punctuation">((</span>WORDS_NUM<span class="token operator">=</span>$<span class="token comment" spellcheck="true">#-1))</span><span class="token keyword">for</span> n <span class="token keyword">in</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">seq</span> $WORDS_NUM<span class="token variable">)</span></span><span class="token keyword">do</span>    <span class="token function">shift</span>    <span class="token function">cat</span> <span class="token variable">$FILE</span> <span class="token operator">|</span> <span class="token function">sed</span> -e <span class="token string">"s/[^a-zA-Z]/\n/g"</span> \        <span class="token operator">|</span> <span class="token function">grep</span> -v ^$ <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">uniq</span> -c <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">" <span class="token variable">$1</span>$"</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>演示：</p><pre class="line-numbers language-bash"><code class="language-bash">$ ./statistic_words.sh index.html tinylab linux python    175 tinylab     43 linux      3 python<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>说明：很明显，办法一的效率要高很多，因为它提前找出了需要统计的单词，然后再统计，而后者则不然。实际上，如果使用 <code>grep</code> 的 <code>-E</code> 选项，我们无须引入循环，而用一条命令就可以搞定：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> index.html <span class="token operator">|</span> <span class="token function">sed</span> -e <span class="token string">"s/[^a-zA-Z]/\n/g"</span> <span class="token operator">|</span> <span class="token function">grep</span> -v ^$ <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">grep</span> -E <span class="token string">"^tinylab$|^linux$"</span> <span class="token operator">|</span> <span class="token function">uniq</span> -c     43 linux    175 tinylab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> index.html <span class="token operator">|</span> <span class="token function">sed</span> -e <span class="token string">"s/[^a-zA-Z]/\n/g"</span> <span class="token operator">|</span> <span class="token function">grep</span> -v ^$ <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">egrep</span>  <span class="token string">"^tinylab$|^linux$"</span> <span class="token operator">|</span> <span class="token function">uniq</span> -c     43 linux    175 tinylab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>说明：需要注意到 <code>sed</code> 命令可以直接处理文件，而无需通过 <code>cat</code> 命令输出以后再通过管道传递，这样可以减少一个不必要的管道操作，所以上述命令可以简化为：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sed</span> -e <span class="token string">"s/[^a-zA-Z]/\n/g"</span> index.html <span class="token operator">|</span> <span class="token function">grep</span> -v ^$ <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">egrep</span>  <span class="token string">"^tinylab$|^linux$"</span> <span class="token operator">|</span> <span class="token function">uniq</span> -c     43 linux    175 tinylab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>所以，可见这些命令 <code>sed</code>，<code>grep</code>，<code>uniq</code>，<code>sort</code> 是多么有用，它们本身虽然只完成简单的功能，但是通过一定的组合，就可以实现各种五花八门的事情啦。对了，统计单词还有个非常有用的命令 <code>wc -w</code>，需要用到的时候也可以用它。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>到这里，Shell 编程范例之数值计算就结束啦。该小节主要介绍了：</p><ul><li>Shell 编程中的整数运算、浮点运算、随机数的产生、数列的产生</li><li>Shell 的内置命令、外部命令的区别，以及如何查看他们的类型和帮助</li><li>Shell 脚本的几种执行办法</li><li>几个常用的 Shell 外部命令： <code>sed</code>，<code>awk</code>，<code>grep</code>，<code>uniq</code>，<code>sort</code> 等</li><li>范例：数字递增；求月均收入；自动获取 <code>IP</code> 地址；统计单词个数</li><li>其他：相关用法如命令列表，条件测试等在上述范例中都已涉及，请认真阅读之</li></ul><h2 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>在 Bash 里有这样的常量(实际上是两个内置命令，在这里我们姑且这么认为，后面将介绍)，即 true 和 false，一个表示真，一个表示假。对它们可以进行与、或、非运算等常规的逻辑运算，在这一节，我们除了讨论这些基本逻辑运算外，还将讨论Shell编程中的<strong>条件测试</strong>和<strong>命令列表</strong>，并介绍它们和布尔运算的关系。</p><h3 id="常规的布尔运算"><a href="#常规的布尔运算" class="headerlink" title="常规的布尔运算"></a>常规的布尔运算</h3><p>这里主要介绍 <code>Bash</code> 里头常规的逻辑运算，与、或、非。</p><h4 id="在-Shell-下如何进行逻辑运算"><a href="#在-Shell-下如何进行逻辑运算" class="headerlink" title="在 Shell 下如何进行逻辑运算"></a>在 Shell 下如何进行逻辑运算</h4><h5 id="范例：true-or-false"><a href="#范例：true-or-false" class="headerlink" title="范例：true or false"></a>范例：true or false</h5><p>单独测试 <code>true</code> 和 <code>false</code>，可以看出 <code>true</code> 是真值，<code>false</code> 为假</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">if</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>YES$ <span class="token keyword">if</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>NO<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="范例：与运算"><a href="#范例：与运算" class="headerlink" title="范例：与运算"></a>范例：与运算</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">if</span> <span class="token boolean">true</span> <span class="token operator">&amp;&amp;</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>YES$ <span class="token keyword">if</span> <span class="token boolean">true</span> <span class="token operator">&amp;&amp;</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>NO$ <span class="token keyword">if</span> <span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>NO$ <span class="token keyword">if</span> <span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>NO<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="范例：或运算"><a href="#范例：或运算" class="headerlink" title="范例：或运算"></a>范例：或运算</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">if</span> <span class="token boolean">true</span> <span class="token operator">||</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>YES$ <span class="token keyword">if</span> <span class="token boolean">true</span> <span class="token operator">||</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>YES$ <span class="token keyword">if</span> <span class="token boolean">false</span> <span class="token operator">||</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>YES$ <span class="token keyword">if</span> <span class="token boolean">false</span> <span class="token operator">||</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>NO<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="范例：非运算，即取反"><a href="#范例：非运算，即取反" class="headerlink" title="范例：非运算，即取反"></a>范例：非运算，即取反</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">if</span> <span class="token operator">!</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>YES$ <span class="token keyword">if</span> <span class="token operator">!</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>NO<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出 <code>true</code> 和 <code>false</code> 按照我们对逻辑运算的理解进行着，但是为了能够更好的理解 Shell 对逻辑运算的实现，我们还得弄清楚，<code>true</code> 和 <code>false</code> 是怎么工作的？</p><h4 id="Bash-里头的-true-和-false-是我们通常认为的-1-和-0-么？"><a href="#Bash-里头的-true-和-false-是我们通常认为的-1-和-0-么？" class="headerlink" title="Bash 里头的 true 和 false 是我们通常认为的 1 和 0 么？"></a>Bash 里头的 true 和 false 是我们通常认为的 1 和 0 么？</h4><p>回答是：否。</p><h5 id="范例：返回值-v-s-逻辑值"><a href="#范例：返回值-v-s-逻辑值" class="headerlink" title="范例：返回值 v.s. 逻辑值"></a>范例：返回值 v.s. 逻辑值</h5><p><code>true</code> 和 <code>false</code> 它们本身并非逻辑值，它们都是 Shell 的内置命令，只是它们的返回值是一个“逻辑值”：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token boolean">true</span>$ <span class="token keyword">echo</span> <span class="token variable">$?</span>0$ <span class="token boolean">false</span>$ <span class="token keyword">echo</span> <span class="token variable">$?</span>1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到 <code>true</code> 返回了 0，而 <code>false</code> 则返回了 1 。跟我们离散数学里学的真值 1 和 0 并不是对应的，而且相反的。</p><h5 id="范例：查看-true-和-false-帮助和类型"><a href="#范例：查看-true-和-false-帮助和类型" class="headerlink" title="范例：查看 true 和 false 帮助和类型"></a>范例：查看 true 和 false 帮助和类型</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">help</span> <span class="token boolean">true</span> <span class="token boolean">false</span>true: <span class="token boolean">true</span>     Return a successful result.false: <span class="token boolean">false</span>     Return an unsuccessful result.$ <span class="token function">type</span> <span class="token boolean">true</span> <span class="token boolean">false</span><span class="token boolean">true</span> is a shell <span class="token function">builtin</span><span class="token boolean">false</span> is a shell <span class="token function">builtin</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：<code>$?</code> 是一个特殊变量，存放有上一次进程的结束状态（退出状态码）。</p><p>从上面的操作不难联想到在 C 语言程序设计中为什么会强调在 <code>main</code> 函数前面加上 <code>int</code>，并在末尾加上 <code>return 0</code> 。因为在 Shell 里，将把 0 作为程序是否成功结束的标志，这就是 Shell 里头 <code>true</code> 和 <code>false</code> 的实质，它们用以反应某个程序是否正确结束，而并非传统的真假值（1 和 0），相反地，它们返回的是 0 和 1 。不过庆幸地是，我们在做逻辑运算时，无须关心这些。</p><h3 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h3><p>从上节中，我们已经清楚地了解了 Shell 下的“逻辑值”是什么：是进程退出时的返回值，如果成功返回，则为真，如果不成功返回，则为假。</p><p>而条件测试正好使用了 <code>test</code> 这么一个指令，它用来进行数值测试（各种数值属性测试）、字符串测试（各种字符串属性测试）、文件测试（各种文件属性测试），我们通过判断对应的测试是否成功，从而完成各种常规工作，再加上各种测试的逻辑组合后，将可以完成更复杂的工作。</p><h4 id="条件测试基本使用"><a href="#条件测试基本使用" class="headerlink" title="条件测试基本使用"></a>条件测试基本使用</h4><h5 id="范例：数值测试"><a href="#范例：数值测试" class="headerlink" title="范例：数值测试"></a>范例：数值测试</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">if</span> <span class="token function">test</span> 5 -eq 5<span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>YES$ <span class="token keyword">if</span> <span class="token function">test</span> 5 -ne 5<span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>NO<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="范例：字符串测试"><a href="#范例：字符串测试" class="headerlink" title="范例：字符串测试"></a>范例：字符串测试</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">if</span> <span class="token function">test</span> -n <span class="token string">"not empty"</span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>YES$ <span class="token keyword">if</span> <span class="token function">test</span> -z <span class="token string">"not empty"</span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>NO$ <span class="token keyword">if</span> <span class="token function">test</span> -z <span class="token string">""</span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>YES$ <span class="token keyword">if</span> <span class="token function">test</span> -n <span class="token string">""</span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>NO<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="范例：文件测试"><a href="#范例：文件测试" class="headerlink" title="范例：文件测试"></a>范例：文件测试</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">if</span> <span class="token function">test</span> -f /boot/System.map<span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>YES$ <span class="token keyword">if</span> <span class="token function">test</span> -d /boot/System.map<span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>NO<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="各种逻辑测试的组合"><a href="#各种逻辑测试的组合" class="headerlink" title="各种逻辑测试的组合"></a>各种逻辑测试的组合</h4><h5 id="范例：如果-a，b，c-都等于下面对应的值，那么打印-YES，通过-a-进行”与”测试"><a href="#范例：如果-a，b，c-都等于下面对应的值，那么打印-YES，通过-a-进行”与”测试" class="headerlink" title="范例：如果 a，b，c 都等于下面对应的值，那么打印 YES，通过 -a 进行”与”测试"></a>范例：如果 a，b，c 都等于下面对应的值，那么打印 YES，通过 -a 进行”与”测试</h5><pre class="line-numbers language-bash"><code class="language-bash">$ a<span class="token operator">=</span>5<span class="token punctuation">;</span>b<span class="token operator">=</span>4<span class="token punctuation">;</span>c<span class="token operator">=</span>6<span class="token punctuation">;</span>$ <span class="token keyword">if</span> <span class="token function">test</span> <span class="token variable">$a</span> -eq 5 -a <span class="token variable">$b</span> -eq 4 -a <span class="token variable">$c</span> -eq 6<span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>YES<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="范例：测试某个“东西”是文件或者目录，通过-o-进行“或”运算"><a href="#范例：测试某个“东西”是文件或者目录，通过-o-进行“或”运算" class="headerlink" title="范例：测试某个“东西”是文件或者目录，通过 -o 进行“或”运算"></a>范例：测试某个“东西”是文件或者目录，通过 -o 进行“或”运算</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">if</span> <span class="token function">test</span> -f /etc/profile -o -d /etc/profile<span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>YES<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="范例：测试某个“东西”是否为文件，测试-非运算"><a href="#范例：测试某个“东西”是否为文件，测试-非运算" class="headerlink" title="范例：测试某个“东西”是否为文件，测试 ! 非运算"></a>范例：测试某个“东西”是否为文件，测试 <code>!</code> 非运算</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">if</span> <span class="token function">test</span> <span class="token operator">!</span> -f /etc/profile<span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>NO<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面仅仅演示了 <code>test</code> 命令一些非常简单的测试，你可以通过 <code>help test</code> 获取 <code>test</code> 的更多用法。需要注意的是，<code>test</code> 命令内部的逻辑运算和 Shell 的逻辑运算符有一些区别，对应的为 <code>-a</code> 和 <code>&amp;&amp;</code>，<code>-o</code> 与 <code>||</code>，这两者不能混淆使用。而非运算都是 <code>!</code>，下面对它们进行比较。</p><h4 id="比较-a-与-amp-amp-o-与-，-test-与-test"><a href="#比较-a-与-amp-amp-o-与-，-test-与-test" class="headerlink" title="比较 -a 与 &amp;&amp;, -o 与 ||， ! test 与 test !"></a>比较 -a 与 &amp;&amp;, -o 与 ||， ! test 与 test !</h4><h5 id="范例：要求某文件可执行且有内容，用-a-和-amp-amp-分别实现"><a href="#范例：要求某文件可执行且有内容，用-a-和-amp-amp-分别实现" class="headerlink" title="范例：要求某文件可执行且有内容，用 -a 和 &amp;&amp; 分别实现"></a>范例：要求某文件可执行且有内容，用 -a 和 &amp;&amp; 分别实现</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> <span class="token operator">></span> test.sh<span class="token comment" spellcheck="true">#!/bin/bash</span><span class="token keyword">echo</span> <span class="token string">"test"</span><span class="token punctuation">[</span>CTRL+D<span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 按下组合键CTRL与D结束cat输入，后同，不再注明</span>$ <span class="token function">chmod</span> +x test.sh$ <span class="token keyword">if</span> <span class="token function">test</span> -s test.sh -a -x test.sh<span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>YES$ <span class="token keyword">if</span> <span class="token function">test</span> -s test.sh <span class="token operator">&amp;&amp;</span> <span class="token function">test</span> -x test.sh<span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>YES<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="范例：要求某个字符串要么为空，要么和某个字符串相等"><a href="#范例：要求某个字符串要么为空，要么和某个字符串相等" class="headerlink" title="范例：要求某个字符串要么为空，要么和某个字符串相等"></a>范例：要求某个字符串要么为空，要么和某个字符串相等</h5><pre class="line-numbers language-bash"><code class="language-bash">$ str1<span class="token operator">=</span><span class="token string">"test"</span>$ str2<span class="token operator">=</span><span class="token string">"test"</span>$ <span class="token keyword">if</span> <span class="token function">test</span> -z <span class="token string">"<span class="token variable">$str2</span>"</span> -o <span class="token string">"<span class="token variable">$str2</span>"</span> <span class="token operator">==</span> <span class="token string">"<span class="token variable">$str1</span>"</span><span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>YES$ <span class="token keyword">if</span> <span class="token function">test</span> -z <span class="token string">"<span class="token variable">$str2</span>"</span> <span class="token operator">||</span> <span class="token function">test</span> <span class="token string">"<span class="token variable">$str2</span>"</span> <span class="token operator">==</span> <span class="token string">"<span class="token variable">$str1</span>"</span><span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>YES<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="范例：测试某个数字不满足指定的所有条件"><a href="#范例：测试某个数字不满足指定的所有条件" class="headerlink" title="范例：测试某个数字不满足指定的所有条件"></a>范例：测试某个数字不满足指定的所有条件</h5><pre class="line-numbers language-bash"><code class="language-bash">$ i<span class="token operator">=</span>5$ <span class="token keyword">if</span> <span class="token function">test</span> <span class="token operator">!</span> <span class="token variable">$i</span> -lt 5 -a <span class="token variable">$i</span> -ne 6<span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>YES$ <span class="token keyword">if</span> <span class="token operator">!</span> <span class="token function">test</span> <span class="token variable">$i</span> -lt 5 -a <span class="token variable">$i</span> -eq 6<span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>YES<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很容易找出它们的区别，<code>-a</code> 和 <code>-o</code> 作为测试命令的参数用在测试命令的内部，而 <code>&amp;&amp;</code> 和 <code>||</code> 则用来运算测试的返回值，<code>!</code> 为两者通用。需要关注的是：</p><ul><li>有时可以不用 <code>!</code> 运算符，比如 <code>-eq</code> 和 <code>-ne</code> 刚好相反，可用于测试两个数值是否相等； <code>-z</code> 与 <code>-n</code> 也是对应的，用来测试某个字符串是否为空</li><li>在 <code>Bash</code> 里，<code>test</code> 命令可以用[] 运算符取代，但是需要注意，[<code>之后与</code>] 之前需要加上额外的空格</li><li>在测试字符串时，所有变量建议用双引号包含起来，以防止变量内容为空时出现仅有测试参数，没有测试内容的情况</li></ul><p>下面我们用实例来演示上面三个注意事项：</p><ul><li><p><code>-ne</code> 和 <code>-eq</code> 对应的，我们有时候可以免去 <code>!</code> 运算</p><pre class="line-numbers language-bash"><code class="language-bash">$ i<span class="token operator">=</span>5$ <span class="token keyword">if</span> <span class="token function">test</span> <span class="token variable">$i</span> -eq 5<span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>YES$ <span class="token keyword">if</span> <span class="token function">test</span> <span class="token variable">$i</span> -ne 5<span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>NO$ <span class="token keyword">if</span> <span class="token function">test</span> <span class="token operator">!</span> <span class="token variable">$i</span> -eq 5<span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>NO<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>用 <code>[ ]</code> 可以取代 <code>test</code>，这样看上去会“美观”很多</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$i</span> -eq 5 <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>YES$ <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$i</span> -gt 4 <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">[</span> <span class="token variable">$i</span> -lt 6 <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>YES<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>记得给一些字符串变量加上 <code>&quot;&quot;</code>，记得 <code>[</code> 之后与 <code>]</code> 之前多加一个空格</p><pre class="line-numbers language-bash"><code class="language-bash">$ str<span class="token operator">=</span><span class="token string">""</span>$ <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$str</span>"</span> <span class="token operator">=</span> <span class="token string">"test"</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>-bash: <span class="token punctuation">[</span>: missing `<span class="token punctuation">]</span>'NO$ <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$str</span> <span class="token operator">=</span> <span class="token string">"test"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>-bash: <span class="token punctuation">[</span>: <span class="token operator">=</span>: unary operator expectedNO$ <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$str</span>"</span> <span class="token operator">=</span> <span class="token string">"test"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string">"NO"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>NO<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>到这里，<strong>条件测试</strong>就介绍完了，下面介绍<strong>命令列表</strong>，实际上在上面我们已经使用过了，即多个test命令的组合，通过 <code>&amp;&amp;</code>，<code>||</code> 和 <code>!</code> 组合起来的命令序列。这种命令序列可以有效替换 <code>if/then</code> 的条件分支结构。这不难想到我们在 C 语言程序设计中经常做的如下的选择题（很无聊的例子，但是有意义）：下面是否会打印 <code>j</code>，如果打印，将打印什么？</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>    i<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很容易知道将打印数字 5，因为 <code>i==5</code> 这个条件成立，而且随后是 <code>&amp;&amp;</code>，要判断整个条件是否成立，我们得进行后面的判断，可是这个判断并非常规的判断，而是先把 <code>j</code> 修改为 5，再转换为真值，所以条件为真，打印出 5 。因此，这句可以解释为：如果 <code>i</code> 等于 5，那么把 <code>j</code> 赋值为 5，如果 <code>j</code> 大于 1 （因为之前已经为真），那么打印出 <code>j</code> 的值。这样用 <code>&amp;&amp;</code> 连结起来的判断语句替代了两个 <code>if</code> 条件分支语句。</p><p>正是基于逻辑运算特有的性质，我们可以通过 <code>&amp;&amp;</code>，<code>||</code> 来取代 <code>if/then</code> 等条件分支结构，这样就产生了命令列表。</p><h3 id="命令列表"><a href="#命令列表" class="headerlink" title="命令列表"></a>命令列表</h3><h4 id="命令列表的执行规律"><a href="#命令列表的执行规律" class="headerlink" title="命令列表的执行规律"></a>命令列表的执行规律</h4><p>命令列表的执行规律符合逻辑运算的运算规律，用 <code>&amp;&amp;</code> 连接起来的命令，如果前者成功返回，将执行后面的命令，反之不然；用 <code>||</code> 连接起来的命令，如果前者成功返回，将不执行后续命令，反之不然。</p><h5 id="范例：如果-ping-通-https-www-uestc-edu-cn-那么打印连通信息"><a href="#范例：如果-ping-通-https-www-uestc-edu-cn-那么打印连通信息" class="headerlink" title="范例：如果 ping 通 https://www.uestc.edu.cn/  ,那么打印连通信息"></a>范例：如果 ping 通 <a href="https://www.uestc.edu.cn/">https://www.uestc.edu.cn/</a>  ,那么打印连通信息</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ping</span> -c 1 https://www.uestc.edu.cn/ -W 1 <span class="token operator">&amp;&amp;</span> <span class="token keyword">echo</span> <span class="token string">"=======connected======="</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>非常有趣的问题出来了，即我们上面已经提到的：为什么要让 C 程序在 <code>main()</code> 函数的最后返回 0 ？如果不这样，把这种程序放入命令列表会有什么样的结果？你自己写个简单的 C 程序，然后放入命令列表看看。</p><h4 id="命令列表的作用"><a href="#命令列表的作用" class="headerlink" title="命令列表的作用"></a>命令列表的作用</h4><p>有时用命令列表取代 <code>if/then</code> 等条件分支结构可以省掉一些代码，而且使得程序比较美观、易读，例如：</p><h5 id="范例：在脚本里判断程序的参数个数，和参数类型"><a href="#范例：在脚本里判断程序的参数个数，和参数类型" class="headerlink" title="范例：在脚本里判断程序的参数个数，和参数类型"></a>范例：在脚本里判断程序的参数个数，和参数类型</h5><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token keyword">echo</span> $<span class="token comment" spellcheck="true">#</span><span class="token keyword">echo</span> <span class="token variable">$1</span><span class="token keyword">if</span> <span class="token punctuation">[</span> $<span class="token comment" spellcheck="true"># -eq 1 ] &amp;&amp; (echo $1 | grep '^[0-9]*$' >/dev/null);then</span>    <span class="token keyword">echo</span> <span class="token string">"YES"</span><span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：上例要求参数个数为 1 并且类型为数字。</p><p>再加上 <code>exit 1</code>，我们将省掉 <code>if/then</code> 结构</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token keyword">echo</span> $<span class="token comment" spellcheck="true">#</span><span class="token keyword">echo</span> <span class="token variable">$1</span><span class="token operator">!</span> <span class="token punctuation">(</span><span class="token punctuation">[</span> $<span class="token comment" spellcheck="true"># -eq 1 ] &amp;&amp; (echo $1 | grep '^[0-9]*$' >/dev/null)) &amp;&amp; exit 1</span><span class="token keyword">echo</span> <span class="token string">"YES"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样处理后，对程序参数的判断仅仅需要简单的一行代码，而且变得更美观。</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>这一节介绍了 Shell 编程中的逻辑运算，条件测试和命令列表。</p><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h3><p>之前已经完成数值运算和布尔运算，这次轮到介绍<em>字符串操作</em> 。咱们先得弄明白两个内容：</p><ul><li><p>什么是字符串？</p></li><li><p>对字符串有哪些操作？</p></li><li><p>什么是字符串？</p></li><li><p>对字符串有哪些操作？</p></li></ul><p>下面是”在线新华字典”的解释：</p><blockquote><p>字符串: 简称“串”。有限字符的序列。数据元素为字符的线性表，是一种数据的逻辑结构。在计算机中可有不同的存储结构。在串上可进行求子串、插入字符、删除字符、置换字符等运算。</p></blockquote><p>而字符呢？</p><blockquote><p>字符: 计算机程序设计及操作时使用的符号。包括字母、数字、空格符、提示符及各种专用字符等。</p></blockquote><p>照这样说，之前介绍的中的数字，布尔运算中的真假值，都是以字符的形式呈现出来的，是一种特别的字符，对它们的运算只不过是字符操作的特例罢了。而这里将研究一般字符的运算，它具有非常重要的意义，因为对我们来说，一般的工作都是处理字符而已。这些运算实际上将围绕上述两个定义来做，它们包括：</p><ul><li>找出字符或者字符串的类型，是数字、字母还是其他特定字符，是可打印字符，还是不可打印字符（一些控制字符）。</li><li>找出组成字符串的字符个数和字符串的存储结构（比如数组）。</li><li>对串的常规操作：求子串、插入字符、删除字符、置换字符、字符串的比较等。</li><li>对串的一些比较复杂而有趣的操作，这里将在最后介绍一些有趣的范例。</li></ul><h3 id="字符串的属性"><a href="#字符串的属性" class="headerlink" title="字符串的属性"></a>字符串的属性</h3><h4 id="字符串的类型"><a href="#字符串的类型" class="headerlink" title="字符串的类型"></a>字符串的类型</h4><p>字符有可能是数字、字母、空格、其他特殊字符，而字符串有可能是它们中的一种或者多种的组合，在组合之后还可能形成具有特定意义的字符串，诸如邮件地址，URL地址等。</p><h5 id="范例：数字或者数字组合"><a href="#范例：数字或者数字组合" class="headerlink" title="范例：数字或者数字组合"></a>范例：数字或者数字组合</h5><pre class="line-numbers language-bash"><code class="language-bash">$ i<span class="token operator">=</span>5<span class="token punctuation">;</span>j<span class="token operator">=</span>9423483247234<span class="token punctuation">;</span>$ <span class="token keyword">echo</span> <span class="token variable">$i</span> <span class="token operator">|</span> <span class="token function">grep</span> -q <span class="token string">"^[0-9]$"</span>$ <span class="token keyword">echo</span> <span class="token variable">$?</span>0$ <span class="token keyword">echo</span> <span class="token variable">$j</span> <span class="token operator">|</span> <span class="token function">grep</span> -q <span class="token string">"^[0-9]\+$"</span>$ <span class="token keyword">echo</span> <span class="token variable">$?</span>0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="范例：字符组合（小写字母、大写字母、两者的组合）"><a href="#范例：字符组合（小写字母、大写字母、两者的组合）" class="headerlink" title="范例：字符组合（小写字母、大写字母、两者的组合）"></a>范例：字符组合（小写字母、大写字母、两者的组合）</h5><pre class="line-numbers language-bash"><code class="language-bash">$ c<span class="token operator">=</span><span class="token string">"A"</span><span class="token punctuation">;</span> d<span class="token operator">=</span><span class="token string">"fwefewjuew"</span><span class="token punctuation">;</span> e<span class="token operator">=</span><span class="token string">"fewfEFWefwefe"</span>$ <span class="token keyword">echo</span> <span class="token variable">$c</span> <span class="token operator">|</span> <span class="token function">grep</span> -q <span class="token string">"^[A-Z]$"</span>$ <span class="token keyword">echo</span> <span class="token variable">$d</span> <span class="token operator">|</span> <span class="token function">grep</span> -q <span class="token string">"^[a-z]\+$"</span>$ <span class="token keyword">echo</span> <span class="token variable">$e</span> <span class="token operator">|</span> <span class="token function">grep</span> -q <span class="token string">"^[a-zA-Z]\+$"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="范例：字母和数字的组合"><a href="#范例：字母和数字的组合" class="headerlink" title="范例：字母和数字的组合"></a>范例：字母和数字的组合</h5><pre class="line-numbers language-bash"><code class="language-bash">$ ic<span class="token operator">=</span><span class="token string">"432fwfwefeFWEwefwef"</span>$ <span class="token keyword">echo</span> <span class="token variable">$ic</span> <span class="token operator">|</span> <span class="token function">grep</span> -q <span class="token string">"^[0-9a-zA-Z]\+$"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="范例：空格或者-Tab-键等"><a href="#范例：空格或者-Tab-键等" class="headerlink" title="范例：空格或者 Tab 键等"></a>范例：空格或者 Tab 键等</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token string">" "</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">" "</span>$ <span class="token keyword">echo</span> -e <span class="token string">"\t"</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"[[:space:]]"</span> <span class="token comment" spellcheck="true">#[[:space:]]会同时匹配空格和TAB键</span>$ <span class="token keyword">echo</span> -e <span class="token string">" \t"</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"[[:space:]]"</span>$ <span class="token keyword">echo</span> -e <span class="token string">"\t"</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">""</span> <span class="token comment" spellcheck="true">#为在键盘上按下TAB键，而不是字符</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="范例：匹配邮件地址"><a href="#范例：匹配邮件地址" class="headerlink" title="范例：匹配邮件地址"></a>范例：匹配邮件地址</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token string">"test2007@lzu.cn"</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"[0-9a-zA-Z\.]*@[0-9a-zA-Z\.]*"</span>test2007@lzu.cn<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="范例：匹配-URL-地址-以-http-链接为例）"><a href="#范例：匹配-URL-地址-以-http-链接为例）" class="headerlink" title="范例：匹配 URL 地址(以 http 链接为例）"></a>范例：匹配 URL 地址(以 http 链接为例）</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token string">"http://news.lzu.edu.cn/article.jsp?newsid=10135"</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"^http://[0-9a-zA-Z\./=?]\+$"</span>http://news.lzu.edu.cn/article.jsp?newsid<span class="token operator">=</span>10135<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>说明：</p><ul><li><code>/dev/null</code> 和 <code>/dev/zero</code> 设备非常有趣，都犹如黑洞，什么东西掉进去都会消失殆尽；后者还是个能源箱，总能从那里取到0，直到退出</li><li><code>[[:space:]]</code> 是 <code>grep</code> 用于匹配空格或 TAB 键字符的标记，其他标记请查帮助：<code>man grep</code></li><li>上面都是用 <code>grep</code> 来进行模式匹配，实际上 <code>sed</code>，<code>awk</code> 都可用来做模式匹配，关于匹配中用到的正则表达式知识，请参考后面的相关资料</li><li>如果想判断字符串是否为空，可判断其长度是否为零，可通过 <code>test</code> 命令的 <code>-z</code> 选项来实现，具体用法见 <code>test</code> 命令，<code>help test</code></li></ul><h5 id="范例：判断字符是否为可打印字符"><a href="#范例：判断字符是否为可打印字符" class="headerlink" title="范例：判断字符是否为可打印字符"></a>范例：判断字符是否为可打印字符</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token string">"\t\n"</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"[[:print:]]"</span>\t\n$ <span class="token keyword">echo</span> <span class="token variable">$?</span>0$ <span class="token keyword">echo</span> -e <span class="token string">"\t\n"</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"[[:print:]]"</span>$ <span class="token keyword">echo</span> <span class="token variable">$?</span>1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字符串的长度"><a href="#字符串的长度" class="headerlink" title="字符串的长度"></a>字符串的长度</h4><p>除了组成字符串的字符类型外，字符串还有哪些属性呢？组成字符串的字符个数。</p><p>下面我们来计算字符串的长度，即所有字符的个数，并简单介绍几种求字符串中指定字符个数的方法。</p><h5 id="范例：计算某个字符串的长度"><a href="#范例：计算某个字符串的长度" class="headerlink" title="范例：计算某个字符串的长度"></a>范例：计算某个字符串的长度</h5><p>即计算所有字符的个数，计算方法五花八门，择其优着而用之：</p><pre class="line-numbers language-bash"><code class="language-bash">$ var<span class="token operator">=</span><span class="token string">"get the length of me"</span>$ <span class="token keyword">echo</span> <span class="token variable">${var}</span>     <span class="token comment" spellcheck="true"># 这里等同于$var</span>get the length of me$ <span class="token keyword">echo</span> <span class="token variable">${#var}</span>20$ <span class="token function">expr</span> length <span class="token string">"<span class="token variable">$var</span>"</span>20$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{printf("%d\n", length(<span class="token variable">$0</span>));}'</span>20$ <span class="token keyword">echo</span> -n <span class="token variable">$var</span> <span class="token operator">|</span>  <span class="token function">wc</span> -c20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="范例：计算某些指定字符或者字符组合的个数"><a href="#范例：计算某些指定字符或者字符组合的个数" class="headerlink" title="范例：计算某些指定字符或者字符组合的个数"></a>范例：计算某些指定字符或者字符组合的个数</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">tr</span> -cd g <span class="token operator">|</span> <span class="token function">wc</span> -c2$ <span class="token keyword">echo</span> -n <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">sed</span> -e <span class="token string">'s/[^g]//g'</span> <span class="token operator">|</span> <span class="token function">wc</span> -c2$ <span class="token keyword">echo</span> -n <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">sed</span> -e <span class="token string">'s/[^gt]//g'</span> <span class="token operator">|</span> <span class="token function">wc</span> -c5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="范例：统计单词个数"><a href="#范例：统计单词个数" class="headerlink" title="范例：统计单词个数"></a>范例：统计单词个数</h5><p>更多相关信息见之前<em>单词统计</em> 相关范例。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">wc</span> -w5$ <span class="token keyword">echo</span> <span class="token string">"<span class="token variable">$var</span>"</span> <span class="token operator">|</span> <span class="token function">tr</span> <span class="token string">" "</span> <span class="token string">"\n"</span> <span class="token operator">|</span> <span class="token function">grep</span> get <span class="token operator">|</span> <span class="token function">uniq</span> -c1$ <span class="token keyword">echo</span> <span class="token string">"<span class="token variable">$var</span>"</span> <span class="token operator">|</span> <span class="token function">tr</span> <span class="token string">" "</span> <span class="token string">"\n"</span> <span class="token operator">|</span> <span class="token function">grep</span> get <span class="token operator">|</span> <span class="token function">wc</span> -l1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><p><code>${}</code> 操作符在 Bash 里头是一个“大牛”，能胜任相当多的工作，具体就看网中人的<a href="http://bbs.chinaunix.net/forum.php?mod=viewthread&tid=218853&page=7#pid1617953">《Shell十三问》之<code>$(())</code>与<code>$()</code> 还有<code>${}</code>差在哪？”</a>吧。</p><h3 id="字符串的显示"><a href="#字符串的显示" class="headerlink" title="字符串的显示"></a>字符串的显示</h3><p>接下来讨论如何控制字符在终端的显示。</p><h4 id="范例：在屏幕控制字符显示位置、颜色、背景等"><a href="#范例：在屏幕控制字符显示位置、颜色、背景等" class="headerlink" title="范例：在屏幕控制字符显示位置、颜色、背景等"></a>范例：在屏幕控制字符显示位置、颜色、背景等</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> -e <span class="token string">"\033[31;40m"</span> <span class="token comment" spellcheck="true">#设置前景色为黑色，背景色为红色</span>$ <span class="token keyword">echo</span> -e <span class="token string">'\033[11;29H Hello, World!'</span> <span class="token comment" spellcheck="true">#在屏幕的第11行，29列开始打印字符串Hello,World!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="范例：在屏幕的某个位置动态显示当前系统时间"><a href="#范例：在屏幕的某个位置动态显示当前系统时间" class="headerlink" title="范例：在屏幕的某个位置动态显示当前系统时间"></a>范例：在屏幕的某个位置动态显示当前系统时间</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">while</span> <span class="token keyword">:</span><span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token keyword">echo</span> -e <span class="token string">"\033[11;29H "</span><span class="token punctuation">$(</span>date <span class="token string">"+%Y-%m-%d %H:%M:%S"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="范例：过滤掉某些控制字符串"><a href="#范例：过滤掉某些控制字符串" class="headerlink" title="范例：过滤掉某些控制字符串"></a>范例：过滤掉某些控制字符串</h4><p>用 <code>col</code> 命令过滤某些控制字符，在处理诸如 <code>script</code>，<code>screen</code> 等截屏命令的输出结果时，很有用。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">screen</span> -L$ <span class="token function">cat</span> /bin/cat$ <span class="token keyword">exit</span>$ <span class="token function">cat</span> screenlog.0 <span class="token operator">|</span> col -b   <span class="token comment" spellcheck="true"># 把一些控制字符过滤后，就可以保留可读的操作日志</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字符串的存储"><a href="#字符串的存储" class="headerlink" title="字符串的存储"></a>字符串的存储</h3><p>在我们看来，字符串是一连串的字符而已，但是为了操作方便，我们往往可以让字符串呈现出一定的结构。在这里，我们不关心字符串在内存中的实际存储结构，仅仅关系它呈现出来的逻辑结构。比如，这样一个字符串： <code>&quot;get the length of me&quot;</code>，我们可以从不同的方面来呈现它。</p><ul><li>通过字符在串中的位置来呈现它</li></ul><p>这样我们就可以通过指定位置来找到某个子串。这在 C 语言中通常可以利用指针来做。而在 Shell 编程中，有很多可用的工具，诸如 <code>expr</code>，<code>awk</code> 都提供了类似方法来实现子串的查询动作。两者都几乎支持模式匹配 <code>match</code> 和完全匹配 <code>index</code>。这在后面的字符串操作中将详细介绍。</p><ul><li>根据某个分割符来取得字符串的各个部分</li></ul><p>这里最常见的就是行分割符、空格或者 <code>TAB</code> 分割符了，前者用来当行号，我们似乎已经司空见惯了，因为我们的编辑器就这样“莫名”地处理着行分割符（在 UNIX 下为 <code>\n</code>，在其他系统下有一些不同，比如 Windows 下为 <code>\r\n</code> ）。而空格或者 <code>TAB</code> 键经常用来分割数据库的各个字段，这似乎也是司空见惯的事情。</p><p>正因为这样，所以产生了大量优秀的行编辑工具，诸如 <code>grep</code>，<code>awk</code>，<code>sed</code> 等。在“行内”（姑且这么说吧，就是处理单行，即字符串中不再包含行分割符）的字符串分割方面，<code>cut</code> 和 <code>awk</code> 提供了非常优越的“行内”（处理单行）处理能力。</p><ul><li>更方便地处理用分割符分割好的各个部分</li></ul><p>同样是用到分割符，但为了更方便的操作分割以后的字符串的各个部分，我们抽象了“数组”这么一个数据结构，从而让我们更加方便地通过下标来获取某个指定的部分。 <code>bash</code> 提供了这么一种数据结构，而优秀的 <code>awk</code> 也同样提供了它，我们这里将简单介绍它们的用法。</p><h4 id="范例：把字符串拆分成字符串数组"><a href="#范例：把字符串拆分成字符串数组" class="headerlink" title="范例：把字符串拆分成字符串数组"></a>范例：把字符串拆分成字符串数组</h4><ul><li><p>Bash 提供的数组数据结构，以数字为下标的，和 C 语言从 0 开始的下标一样</p><pre class="line-numbers language-bash"><code class="language-bash">$ var<span class="token operator">=</span><span class="token string">"get the length of me"</span>$ var_arr<span class="token operator">=</span><span class="token punctuation">(</span><span class="token variable">$var</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#把字符串var存放到字符串数组var_arr中，默认以空格作为分割符</span>$ <span class="token keyword">echo</span> <span class="token variable">${var_arr[0]}</span> <span class="token variable">${var_arr[1]}</span> <span class="token variable">${var_arr[2]}</span> <span class="token variable">${var_arr[3]}</span> <span class="token variable">${var_arr[4]}</span>get the length of me$ <span class="token keyword">echo</span> <span class="token variable">${var_arr[@]}</span>    <span class="token comment" spellcheck="true">#整个字符串，可以用*代替@，下同</span>get the length of me$ <span class="token keyword">echo</span> <span class="token variable">${#var_arr[@]}</span>   <span class="token comment" spellcheck="true">#类似于求字符串长度，`#`操作符也可用来求数组元素个数</span>5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以直接给某个数组元素赋值</p><pre class="line-numbers language-bash"><code class="language-bash">$ var_arr<span class="token punctuation">[</span>5<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"new_element"</span>$ <span class="token keyword">echo</span> <span class="token variable">${#var_arr[@]}</span>6$ <span class="token keyword">echo</span> <span class="token variable">${var_arr[5]}</span>new_element<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Bash 实际上还提供了一种类似于“数组”的功能，即 <code>for i in</code>，它可以很方便地获取某个字符串的各个部分，例如：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token variable">$var</span><span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token keyword">echo</span> -n <span class="token variable">$i</span><span class="token string">"_"</span><span class="token punctuation">;</span> <span class="token keyword">done</span>get_the_length_of_me_<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>awk</code> 里的数组，注意比较它和 <code>Bash</code> 里的数组的异同</p><p><code>split</code> 把一行按照空格分割，存放到数组 <code>var_arr</code> 中，并返回数组长度。注意：这里第一个元素下标不是 0，而是 1</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{printf("%d %s\n", split(<span class="token variable">$0</span>, var_arr, " "), var_arr[1]);}'</span>5 get<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>实际上，上述操作很类似 <code>awk</code> 自身的行处理功能： <code>awk</code> 默认把一行按照空格分割为多个域，并可以通过 <code>$1</code>，<code>$2</code>，<code>$3</code> <code>...</code> 来获取，<code>$0</code> 表示整行。</p><p>这里的 <code>NF</code> 是该行的域的总数，类似于上面数组的长度，它同样提供了一种通过类似“下标”访问某个字符串的功能。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{printf("%d | %s %s %s %s %s | %s\n", NF, <span class="token variable">$1</span>, <span class="token variable">$2</span>, <span class="token variable">$3</span>, <span class="token variable">$4</span>, <span class="token variable">$5</span>, <span class="token variable">$0</span>);}'</span>5 <span class="token operator">|</span> get the length of me <span class="token operator">|</span> get the length of me<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>awk</code> 的“数组”功能何止于此呢，看看它的 <code>for</code> 引用吧，注意，这个和 <code>Bash</code> 里头的 <code>for</code> 不太一样，<code>i</code> 不是元素本身，而是下标：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{split(<span class="token variable">$0</span>, var_arr, " "); for(i in var_arr) printf("%s ",var_arr[i]);}'</span>of me get the length4 5 1 2 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>另外，从上述结果可以看到，经过 <code>for</code> 处理后，整个结果没有按照原理的字符顺序排列，不过如果仅仅是迭代出所有元素这个同样很有意义。</p></li></ul><p><code>awk</code> 还有更“厉害”的处理能力，它的下标可以不是数字，可以是字符串，从而变成了“关联”数组，这种“关联”在某些方面非常方便。 比如，把某个文件中的某个系统调用名根据另外一个文件中的函数地址映射表替换成地址，可以这么实现：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> symbolsys_exitsys_readsys_close$ <span class="token function">ls</span> /boot/System.map*/boot/System.map-2.6.20-16-generic$ <span class="token function">awk</span> <span class="token string">'{if(FILENAME ~ "System.map") map[<span class="token variable">$3</span>]=<span class="token variable">$1</span>; else {printf("%s\n", map[<span class="token variable">$1</span>])}}'</span> \    /boot/System.map-2.6.20-16-generic symbolc0129a80c0177310c0175d80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外，awk还支持用delete函数删除某个数组元素。如果某些场合有需要的话，别忘了awk还支持二维数组。</p><h3 id="字符串常规操作"><a href="#字符串常规操作" class="headerlink" title="字符串常规操作"></a>字符串常规操作</h3><p>字符串操作包括取子串、查询子串、插入子串、删除子串、子串替换、子串比较、子串排序、子串进制转换、子串编码转换等。</p><h4 id="取子串"><a href="#取子串" class="headerlink" title="取子串"></a>取子串</h4><p>取子串的方法主要有：</p><ul><li>直接到指定位置求子串</li><li>字符匹配求子串</li></ul><h5 id="范例：按照位置取子串"><a href="#范例：按照位置取子串" class="headerlink" title="范例：按照位置取子串"></a>范例：按照位置取子串</h5><p>比如从什么位置开始，取多少个字符</p><pre class="line-numbers language-bash"><code class="language-bash">$ var<span class="token operator">=</span><span class="token string">"get the length of me"</span>$ <span class="token keyword">echo</span> <span class="token variable">${var:0:3}</span>get$ <span class="token keyword">echo</span> <span class="token variable">${var:(-2)}</span>   <span class="token comment" spellcheck="true"># 方向相反呢</span>me$ <span class="token keyword">echo</span> `expr substr <span class="token string">"<span class="token variable">$var</span>"</span> 5 3` <span class="token comment" spellcheck="true">#记得把$var引起来，否则expr会因为空格而解析错误</span>the$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{printf("%s\n", substr(<span class="token variable">$0</span>, 9, 6))}'</span>length<span class="token function">awk</span><span class="token variable"><span class="token variable">`</span> 把 <span class="token variable">`</span></span><span class="token variable">$var</span><span class="token variable"><span class="token variable">`</span> 按照空格分开为多个变量，依次为 <span class="token variable">`</span></span><span class="token variable">$1</span><span class="token variable"><span class="token variable">`</span>，<span class="token variable">`</span></span><span class="token variable">$2</span><span class="token variable"><span class="token variable">`</span>，<span class="token variable">`</span></span><span class="token variable">$3</span><span class="token variable"><span class="token variable">`</span>，<span class="token variable">`</span></span><span class="token variable">$4</span><span class="token variable"><span class="token variable">`</span>，<span class="token variable">`</span></span><span class="token variable">$5</span>$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{printf("%s\n", <span class="token variable">$1</span>);}'</span>get$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{printf("%s\n", <span class="token variable">$5</span>);}'</span>me<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>差点略掉<code>cut</code>小工具，它用起来和awk类似，<code>-d</code>指定分割符，如同<code>awk</code>用<code>-F</code>指定分割符一样；<code>-f</code>指定“域”，如同awk的<code>$数字</code>。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">cut</span> -d<span class="token string">" "</span> -f 5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="范例：匹配字符求子串"><a href="#范例：匹配字符求子串" class="headerlink" title="范例：匹配字符求子串"></a>范例：匹配字符求子串</h5><p>用 Bash 内置支持求子串：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">${var%% *}</span> <span class="token comment" spellcheck="true">#从右边开始计算，删除最左边的空格右边的所有字符</span>get$ <span class="token keyword">echo</span> <span class="token variable">${var% *}</span> <span class="token comment" spellcheck="true">#从右边开始计算，删除第一个空格右边的所有字符</span>get the length of$ <span class="token keyword">echo</span> $<span class="token punctuation">{</span>var<span class="token comment" spellcheck="true">##* }  #从左边开始计算，删除最右边的空格左边的所有字符</span>me$ <span class="token keyword">echo</span> $<span class="token punctuation">{</span>var<span class="token comment" spellcheck="true">#* }  #从左边开始计算，删除第一个空格左边的所有字符</span>the length of me<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>删除所有 <code>空格＋字母组合</code> 的字符串：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'s/ [a-z]*//g'</span>get$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'s/[a-z]* //g'</span>me<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>sed</code> 有按地址（行）打印(p)的功能，记得先用 <code>tr</code> 把空格换成行号：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">tr</span> <span class="token string">" "</span> <span class="token string">"\n"</span> <span class="token operator">|</span> <span class="token function">sed</span> -n 1pget$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">tr</span> <span class="token string">" "</span> <span class="token string">"\n"</span> <span class="token operator">|</span> <span class="token function">sed</span> -n 5pme<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>tr</code> 也可以用来取子串，它可以类似<code>#</code>和 <code>%</code> 来“拿掉”一些字符串来实现取子串：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">tr</span> -d <span class="token string">" "</span>getthelengthofme$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">tr</span> -cd <span class="token string">"[a-z]"</span> <span class="token comment" spellcheck="true">#把所有的空格都拿掉了，仅仅保留字母字符串，注意-c和-d的用法</span>getthelengthofme<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><ul><li><code>%</code> 和<code>#</code>删除字符的方向不一样，前者在右，后者在左，<code>%%</code> 和 <code>%</code>， <code>##</code> 和 <code>#</code> 的方向是前者是最大匹配，后者是最小匹配。（好的记忆方法见网中人的键盘记忆法：<code>#</code>，<code>$</code>，<code>%</code> 是键盘依次从左到右的三个键）</li><li><code>tr</code> 的 <code>-c</code> 选项是 <code>complement</code> 的缩写，即 <code>invert</code>，而 <code>-d</code> 选项是删除，<code>tr -cd &quot;[a-z]&quot;</code> 这样一来就变成保留所有的字母</li></ul><p>对于字符串的截取，实际上还有一些命令，如果 <code>head</code>，<code>tail</code> 等可以实现有意思的功能，可以截取某个字符串的前面、后面指定的行数或者字节数。例如：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token string">"abcdefghijk"</span> <span class="token operator">|</span> <span class="token function">head</span> -c 4abcd$ <span class="token keyword">echo</span> -n <span class="token string">"abcdefghijk"</span> <span class="token operator">|</span> <span class="token function">tail</span> -c 4hijk<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="查询子串"><a href="#查询子串" class="headerlink" title="查询子串"></a>查询子串</h4><p>子串查询包括：</p><ul><li>返回符合某个模式的子串本身</li><li>返回子串在目标串中的位置</li></ul><p>准备：在进行下面的操作之前，请准备一个文件 test.txt，里头有内容 “consists of”，用于下面的范例。</p><h5 id="范例：查询子串在目标串中的位置"><a href="#范例：查询子串在目标串中的位置" class="headerlink" title="范例：查询子串在目标串中的位置"></a>范例：查询子串在目标串中的位置</h5><p><code>expr index</code>貌似仅仅可以返回某个字符或者多个字符中第一个字符出现的位置</p><pre class="line-numbers language-bash"><code class="language-bash">$ var<span class="token operator">=</span><span class="token string">"get the length of me"</span>$ <span class="token function">expr</span> index <span class="token string">"<span class="token variable">$var</span>"</span> t3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>awk却能找出字串，match还可以匹配正则表达式</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{printf("%d\n", match(<span class="token variable">$0</span>,"the"));}'</span>5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="范例：查询子串，返回包含子串的行"><a href="#范例：查询子串，返回包含子串的行" class="headerlink" title="范例：查询子串，返回包含子串的行"></a>范例：查询子串，返回包含子串的行</h5><p><code>awk</code>，<code>sed</code> 都可以实现这些功能，但是 <code>grep</code> 最擅长</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">grep</span> <span class="token string">"consists of"</span> test.txt   <span class="token comment" spellcheck="true"># 查询文件包含consists of的行，并打印这些行</span>$ <span class="token function">grep</span> <span class="token string">"consists[[:space:]]of"</span> -n -H test.txt <span class="token comment" spellcheck="true"># 打印文件名，子串所在行的行号和该行的内容</span>$ <span class="token function">grep</span> <span class="token string">"consists[[:space:]]of"</span> -n -o test.txt <span class="token comment" spellcheck="true"># 仅仅打印行号和匹配到的子串本身的内容</span>$ <span class="token function">awk</span> <span class="token string">'/consists of/{ printf("%s:%d:%s\n",FILENAME, FNR, <span class="token variable">$0</span>)}'</span> text  <span class="token comment" spellcheck="true">#看到没？和grep的结果一样</span>$ <span class="token function">sed</span> -n -e <span class="token string">'/consists of/=;/consists of/p'</span> text <span class="token comment" spellcheck="true">#同样可以打印行号</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><ul><li><code>awk</code>，<code>grep</code>，<code>sed</code> 都能通过模式匹配查找指定字符串，但它们各有所长，将在后续章节中继续使用和比较它们，进而发现各自优点</li><li>在这里姑且把文件内容当成了一个大的字符串，在后面章节中将专门介绍文件操作，所以对文件内容中存放字符串的操作将会有更深入的分析和介绍</li></ul><h4 id="子串替换"><a href="#子串替换" class="headerlink" title="子串替换"></a>子串替换</h4><p>子串替换就是把某个指定的子串替换成其他的字符串，这里蕴含了“插入子串”和“删除子串”的操作。例如，想插入某个字符串到某个子串之前，就可以把原来的子串替换成”子串+新的字符串“，如果想删除某个子串，就把子串替换成空串。不过有些工具提供了一些专门的用法来做插入子串和删除子串的操作，所以呆伙还会专门介绍。另外，要想替换掉某个子串，一般都是先找到子串（查询子串），然后再把它替换掉，实质上很多工具在使用和设计上都体现了这么一点。</p><h5 id="范例：把变量-var-中的空格替换成下划线"><a href="#范例：把变量-var-中的空格替换成下划线" class="headerlink" title="范例：把变量 var 中的空格替换成下划线"></a>范例：把变量 var 中的空格替换成下划线</h5><p>用 <code>{}</code> 运算符，还记得么？网中人的教程</p><pre class="line-numbers language-bash"><code class="language-bash">$ var<span class="token operator">=</span><span class="token string">"get the length of me"</span>$ <span class="token keyword">echo</span> <span class="token variable">${var/ /_}</span>        <span class="token comment" spellcheck="true">#把第一个空格替换成下划线</span>get_the length of me$ <span class="token keyword">echo</span> <span class="token variable">${var// /_}</span>       <span class="token comment" spellcheck="true">#把所有空格都替换成下划线</span>get_the_length_of_me<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用 <code>awk</code>，<code>awk</code> 提供了转换的最小替换函数 <code>sub</code> 和全局替换函数 <code>gsub</code>，类似 <code>/</code> 和 <code>//</code></p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{sub(" ", "_", <span class="token variable">$0</span>); printf("%s\n", <span class="token variable">$0</span>);}'</span>get_the length of me$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{gsub(" ", "_", <span class="token variable">$0</span>); printf("%s\n", <span class="token variable">$0</span>);}'</span>get_the_length_of_me<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>用 <code>sed</code>，子串替换可是 <code>sed</code> 的特长：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">sed</span> -e <span class="token string">'s/ /_/'</span>    <span class="token comment" spellcheck="true">#s &lt;= substitude</span>get_the length of me$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">sed</span> -e <span class="token string">'s/ /_/g'</span>   <span class="token comment" spellcheck="true">#看到没有，简短两个命令就实现了最小匹配和最大匹配g &lt;= global</span>get_the_length_of_me<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>有忘记 <code>tr</code> 命令么？可以用替换单个字符的：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">tr</span> <span class="token string">" "</span> <span class="token string">"_"</span>get_the_length_of_me$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">tr</span> <span class="token string">'[a-z]'</span> <span class="token string">'[A-Z]'</span>   <span class="token comment" spellcheck="true">#这个可有意思了，把所有小写字母都替换为大写字母</span>GET THE LENGTH OF ME<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>说明： <code>sed</code> 还有很有趣的标签用法呢，下面再介绍吧。</p><p>有一种比较有意思的字符串替换是：整个文件行的倒置，这个可以通过 <code>tac</code> 命令实现，它会把文件中所有的行全部倒转过来。在某种意义上来说，排序实际上也是一个字符串替换。</p><h4 id="插入子串"><a href="#插入子串" class="headerlink" title="插入子串"></a>插入子串</h4><p>在指定位置插入子串，这个位置可能是某个子串的位置，也可能是从某个文件开头算起的某个长度。通过上面的练习，我们发现这两者之间实际上是类似的。</p><p>公式：插入子串=把”old子串”替换成”old子串+new子串”或者”new子串+old子串”</p><h5 id="范例：在-var-字符串的空格之前或之后插入一个下划线"><a href="#范例：在-var-字符串的空格之前或之后插入一个下划线" class="headerlink" title="范例：在 var 字符串的空格之前或之后插入一个下划线"></a>范例：在 var 字符串的空格之前或之后插入一个下划线</h5><p>用{}：</p><pre class="line-numbers language-bash"><code class="language-bash">$ var<span class="token operator">=</span><span class="token string">"get the length of me"</span>$ <span class="token keyword">echo</span> <span class="token variable">${var/ /_ }</span>        <span class="token comment" spellcheck="true">#在指定字符串之前插入一个字符串</span>get_ the length of me$ <span class="token keyword">echo</span> <span class="token variable">${var// /_ }</span>get_ the_ length_ of_ me$ <span class="token keyword">echo</span> <span class="token variable">${var/ / _}</span>        <span class="token comment" spellcheck="true">#在指定字符串之后插入一个字符串</span>get _the length of me$ <span class="token keyword">echo</span> <span class="token variable">${var// / _}</span>get _the _length _of _me<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其他的还用演示么？这里主要介绍sed怎么用来插入字符吧，因为它的标签功能很有趣 说明：<code>(</code> 和 <code>)</code> 将匹配到的字符串存放为一个标签，按匹配顺序为<code>\1</code>,<code>\2</code>…</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">sed</span> -e <span class="token string">'s/\( \)/_\1/'</span>get_ the length of me$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">sed</span> -e <span class="token string">'s/\( \)/_\1/g'</span>get_ the_ length_ of_ me$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">sed</span> -e <span class="token string">'s/\( \)/\1_/'</span>get _the length of me$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">sed</span> -e <span class="token string">'s/\( \)/\1_/g'</span>get _the _length _of _me<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看看 <code>sed</code> 的标签的顺序是不是 <code>\1</code>,<code>\2</code>…，看到没？<code>\2</code> 和 <code>\1</code> 调换位置后，<code>the</code> 和 <code>get</code> 的位置掉换了：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">sed</span> -e <span class="token string">'s/\([a-z]*\) \([a-z]*\) /\2 \1 /g'</span>the get of length me<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>sed</code> 还有专门的插入指令，<code>a</code> 和 <code>i</code>，分别表示在匹配的行后和行前插入指定字符</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'/get/a test'</span>get the length of me<span class="token function">test</span>$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'/get/i test'</span><span class="token function">test</span>get the length of me<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="删除子串"><a href="#删除子串" class="headerlink" title="删除子串"></a>删除子串</h4><p>删除子串：应该很简单了吧，把子串替换成“空”（什么都没有）不就变成了删除么。还是来简单复习一下替换吧。</p><h5 id="范例：把-var-字符串中所有的空格给删除掉"><a href="#范例：把-var-字符串中所有的空格给删除掉" class="headerlink" title="范例：把 var 字符串中所有的空格给删除掉"></a>范例：把 var 字符串中所有的空格给删除掉</h5><p>鼓励：这样一替换不知道变成什么单词啦，谁认得呢？但是中文却是连在一起的，所以中文有多难，你想到了么？原来你也是个语言天才，而英语并不可怕，你有学会它的天赋，只要有这个打算。</p><p>再用 <code>{}</code></p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">${var// /}</span>getthelengthofme<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>再用 <code>awk</code></p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{gsub(" ","",<span class="token variable">$0</span>); printf("%s\n", <span class="token variable">$0</span>);}'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再用 <code>sed</code></p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'s/ //g'</span>getthelengthofme<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>还有更简单的 <code>tr</code> 命令，<code>tr</code> 也可以把空格给删除掉，看</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">tr</span> -d <span class="token string">" "</span>getthelengthofme<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果要删除第一个空格后面所有的字符串该怎么办呢？还记得 <code>{}</code> 的 <code>#</code> 和 <code>%</code> 用法么？如果不记得，回到这节的开头开始复习吧。（实际上删除子串和取子串未尝不是两种互补的运算呢，删除掉某些不想要的子串，也就同时取得另外那些想要的子串——这个世界就是一个“二元”的世界，非常有趣）</p><h4 id="子串比较"><a href="#子串比较" class="headerlink" title="子串比较"></a>子串比较</h4><p>这个很简单：还记得 <code>test</code> 命令的用法么？ <code>help test</code> 。它可以用来判断两个字符串是否相等。另外，有发现“字符串是否相等”和“字符串能否跟另外一个字符串匹配 <code>&quot;</code> 两个问题之间的关系吗？如果两个字符串完全匹配，那么这两个字符串就相等了。所以呢，上面用到的字符串匹配方法，也同样可以用到这里。</p><h4 id="子串排序"><a href="#子串排序" class="headerlink" title="子串排序"></a>子串排序</h4><p>差点忘记这个重要内容了，子串排序可是经常用到，常见的有按字母序、数字序等正序或反序排列。 <code>sort</code> 命令可以用来做这个工作，它和其他行处理命令一样，是按行操作的，另外，它类似 <code>cut</code> 和 <code>awk</code>，可以指定分割符，并指定需要排序的列。</p><pre class="line-numbers language-bash"><code class="language-bash">$ var<span class="token operator">=</span><span class="token string">"get the length of me"</span>$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">tr</span> <span class="token string">' '</span> <span class="token string">'\n'</span> <span class="token operator">|</span> <span class="token function">sort</span>   <span class="token comment" spellcheck="true">#正序排</span>getlengthmeofthe$ <span class="token keyword">echo</span> <span class="token variable">$var</span> <span class="token operator">|</span> <span class="token function">tr</span> <span class="token string">' '</span> <span class="token string">'\n'</span> <span class="token operator">|</span> <span class="token function">sort</span> -r <span class="token comment" spellcheck="true">#反序排</span>theofmelengthget$ <span class="token function">cat</span> <span class="token operator">></span> data.txt1 2 3 4 5 6 7 8 9 10 11 12 13 14 1541 45 44 44 26 44 42 20 20 38 37 25 45 45 4516 17 18 19 20 21 22 23 24 25 26 27 28 29 3044 20 30 39 35 38 38 28 25 30 36 20 24 32 3331 32 33 34 35 36 37 38 39 40 41 42 43 44 4541 33 51 39 20 20 44 37 38 39 42 40 37 50 5046 47 48 49 50 51 52 53 54 55 5642 43 41 42 45 42 19 39 75 17 17$ <span class="token function">cat</span> data.txt <span class="token operator">|</span> <span class="token function">sort</span> -k 2 -n1 2 3 4 5 6 7 8 9 10 11 12 13 14 1516 17 18 19 20 21 22 23 24 25 26 27 28 29 3044 20 30 39 35 38 38 28 25 30 36 20 24 32 3331 32 33 34 35 36 37 38 39 40 41 42 43 44 4541 33 51 39 20 20 44 37 38 39 42 40 37 50 5042 43 41 42 45 42 19 39 75 17 1741 45 44 44 26 44 42 20 20 38 37 25 45 45 4546 47 48 49 50 51 52 53 54 55 56<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="子串进制转换"><a href="#子串进制转换" class="headerlink" title="子串进制转换"></a>子串进制转换</h4><p>如果字母和数字字符用来计数，那么就存在进制转换的问题。在数值计算一节，已经介绍了 <code>bc</code> 命令，这里再复习一下。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token string">"ibase=10;obase=16;10"</span> <span class="token operator">|</span> <span class="token function">bc</span>A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>说明： <code>ibase</code> 指定输入进制，<code>obase</code> 指出输出进制，这样通过调整 <code>ibase</code> 和 <code>obase</code>，你想怎么转就怎么转啦！</p><h4 id="子串编码转换"><a href="#子串编码转换" class="headerlink" title="子串编码转换"></a>子串编码转换</h4><p>什么是字符编码？这个就不用介绍了吧，看过那些乱七八糟显示的网页么？大多是因为浏览器显示时的”编码“和网页实际采用的”编码“不一致导致的。字符编码通常是指：把一序列”可打印“字符转换成二进制表示，而字符解码呢则是执行相反的过程，如果这两个过程不匹配，则出现了所谓的”乱码“。</p><p>为了解决”乱码“问题呢？就需要进行编码转换。在 Linux 下，我们可以使用 <code>iconv</code> 这个工具来进行相关操作。这样的情况经常在不同的操作系统之间移动文件，不同的编辑器之间交换文件的时候遇到，目前在 Windows 下常用的汉字编码是 <code>gb2312</code>，而在 Linux 下则大多采用 <code>utf8</code> 。</p><pre class="line-numbers language-bash"><code class="language-bash">$ nihao_utf8<span class="token operator">=</span><span class="token punctuation">$(</span>echo <span class="token string">"你好"</span><span class="token punctuation">)</span>$ nihao_gb2312<span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token keyword">echo</span> $nihao_utf8 <span class="token operator">|</span> <span class="token function">iconv</span> -f utf8 -t gb2312<span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="字符串操作进阶"><a href="#字符串操作进阶" class="headerlink" title="字符串操作进阶"></a>字符串操作进阶</h3><p>实际上，在用 Bash 编程时，大部分时间都是在处理字符串，因此把这一节熟练掌握非常重要。</p><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><h5 id="范例：处理-URL-地址"><a href="#范例：处理-URL-地址" class="headerlink" title="范例：处理 URL 地址"></a>范例：处理 URL 地址</h5><p>URL 地址(URL（Uniform Resoure Locator：统一资源定位器）是WWW页的地址)几乎是我们日常生活的玩伴，我们已经到了无法离开它的地步啦，对它的操作很多，包括判断 URL 地址的有效性，截取地址的各个部分（服务器类型、服务器地址、端口、路径等）并对各个部分进行进一步的操作。</p><p>下面我们来具体处理这个URL地址：<a href="ftp://anonymous:ftp@mirror.lzu.edu.cn/software/scim-1.4.7.tar.gz">ftp://anonymous:ftp@mirror.lzu.edu.cn/software/scim-1.4.7.tar.gz</a></p><pre class="line-numbers language-bash"><code class="language-bash">$ url<span class="token operator">=</span><span class="token string">"ftp://anonymous:ftp@mirror.lzu.edu.cn/software/scim-1.4.7.tar.gz"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>匹配URL地址，判断URL地址的有效性</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$url</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"ftp://[a-z]*:[a-z]*@[a-z\./-]*"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>截取服务器类型</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">${url%%:*}</span><span class="token function">ftp</span>$ <span class="token keyword">echo</span> <span class="token variable">$url</span> <span class="token operator">|</span> <span class="token function">cut</span> -d<span class="token string">":"</span> -f 1<span class="token function">ftp</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>截取域名</p><pre class="line-numbers language-bash"><code class="language-bash">$ tmp<span class="token operator">=</span>$<span class="token punctuation">{</span>url<span class="token comment" spellcheck="true">##*@} ; echo ${tmp%%/*}</span>mirror.lzu.edu.cn<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>截取路径</p><pre class="line-numbers language-bash"><code class="language-bash">$ tmp<span class="token operator">=</span>$<span class="token punctuation">{</span>url<span class="token comment" spellcheck="true">##*@} ; echo ${tmp%/*}</span>mirror.lzu.edu.cn/software<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>截取文件名</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">basename</span> <span class="token variable">$url</span>scim-1.4.7.tar.gz$ <span class="token keyword">echo</span> $<span class="token punctuation">{</span>url<span class="token comment" spellcheck="true">##*/}</span>scim-1.4.7.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>截取文件类型（扩展名）</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$url</span> <span class="token operator">|</span> <span class="token function">sed</span> -e <span class="token string">'s/.*[0-9].\(.*\)/\1/g'</span>tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="范例：匹配某个文件中的特定范围的行"><a href="#范例：匹配某个文件中的特定范围的行" class="headerlink" title="范例：匹配某个文件中的特定范围的行"></a>范例：匹配某个文件中的特定范围的行</h5><p>先准备一个测试文件README</p><pre class="line-numbers language-bash"><code class="language-bash">Chapter 7 -- Exercises7.1 please execute the program: mainwithoutreturn, and print the <span class="token keyword">return</span> valueof it with the <span class="token function">command</span> <span class="token string">"echo <span class="token variable">$?</span>"</span>, and <span class="token keyword">then</span> compare the <span class="token keyword">return</span> of the <span class="token function">printf</span>function, they are the same.7.2 it will depend on the exection mode, interactive or redirection to a file,<span class="token keyword">if</span> interactive, the <span class="token string">"output"</span> action will accur after the \n char with the linebuffer mode, else, it will be really <span class="token string">"printed"</span> after all of the strings havebeen stayed <span class="token keyword">in</span> the buffer.7.3 there is no another effective method <span class="token keyword">in</span> <span class="token function">most</span> OS. because argc and argv arenot global variables like environ.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后开始实验，</p><p>打印出答案前指定行范围：第 7 行到第 9 行，刚好找出了第 2 题的答案</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sed</span> -n 7,9p README7.2 it will depend on the exection mode, interactive or redirection to a file,<span class="token keyword">if</span> interactive, the <span class="token string">"output"</span> action will accur after the \n char with the linebuffer mode, else, it will be really <span class="token string">"printed"</span> after all of the strings have<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其实，因为这个文件内容格式很有特色，有更简单的办法</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">awk</span> <span class="token string">'/7.2/,/^$/ {printf("%s\n", <span class="token variable">$0</span>);}'</span> README7.2 it will depend on the exection mode, interactive or redirection to a file,<span class="token keyword">if</span> interactive, the <span class="token string">"output"</span> action will accur after the \n char with the linebuffer mode, else, it will be really <span class="token string">"printed"</span> after all of the strings havebeen stayed <span class="token keyword">in</span> the buffer.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了上面的知识，就可以非常容易地进行这些工作啦：修改某个文件的文件名，比如调整它的编码，下载某个网页里头的所有 <code>pdf</code> 文档等。这些就作为练习自己做吧。</p><h4 id="处理格式化的文本"><a href="#处理格式化的文本" class="headerlink" title="处理格式化的文本"></a>处理格式化的文本</h4><p>平时做工作，大多数时候处理的都是一些“格式化”的文本，比如类似 <code>/etc/passwd</code> 这样的有固定行和列的文本，也有类似 <code>tree</code> 命令输出的那种具有树形结构的文本，当然还有其他具有特定结构的文本。</p><p>实际上，只要把握好特性结构的一些特点，并根据具体的应用场合，处理起来就不会困难。</p><p>下面来介绍具体文本的操作，以 <code>/etc/passwd</code> 文件为例。关于这个文件的帮忙和用法，请通过 <code>man 5 passwd</code> 查看。下面对这个文件以及相关的文件进行一些有意义的操作。</p><h5 id="范例：选取指定列"><a href="#范例：选取指定列" class="headerlink" title="范例：选取指定列"></a>范例：选取指定列</h5><p>选取/etc/passwd文件中的用户名和组ID两列</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> /etc/passwd <span class="token operator">|</span> <span class="token function">cut</span> -d<span class="token string">":"</span> -f1,4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>选取/etc/group文件中的组名和组ID两列</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> /etc/group <span class="token operator">|</span> <span class="token function">cut</span> -d<span class="token string">":"</span> -f1,3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="范例：文件关联操作"><a href="#范例：文件关联操作" class="headerlink" title="范例：文件关联操作"></a>范例：文件关联操作</h5><p>如果想找出所有用户所在的组，怎么办？</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">join</span> -o 1.1,2.1 -t<span class="token string">":"</span> -1 4 -2 3 /etc/passwd /etc/grouproot:rootbin:bindaemon:daemonadm:admlp:lppop:popnobody:nogroupfalcon:users<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明： <code>join</code> 命令用来连接两个文件，有点类似于数据库的两个表的连接。 <code>-t</code> 指定分割符，<code>-1 4 -2 3</code> 指定按照第一个文件的第 4 列和第二个文件的第 3 列，即组 <code>ID</code> 进行连接，<code>-o</code> <code>1.1,2.1</code> 表示仅仅输出第一个文件的第一列和第二个文件的第一列，这样就得到了我们要的结果，不过，可惜的是，这个结果并不准确，再进行下面的操作，你就会发现：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> /etc/passwd <span class="token operator">|</span> <span class="token function">sort</span> -t<span class="token string">":"</span> -n -k 4 <span class="token operator">></span> /tmp/passwd$ <span class="token function">cat</span> /etc/group <span class="token operator">|</span> <span class="token function">sort</span> -t<span class="token string">":"</span> -n -k 3 <span class="token operator">></span> /tmp/group$ <span class="token function">join</span> -o 1.1,2.1 -t<span class="token string">":"</span> -1 4 -2 3 /tmp/passwd /tmp/grouphalt:rootoperator:rootroot:rootshutdown:rootsync:rootbin:bindaemon:daemonadm:admlp:lppop:popnobody:nogroupfalcon:usersgames:users<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到这个结果才是正确的，所以以后使用 <code>join</code> 千万要注意这个问题，否则采取更保守的做法似乎更能保证正确性，更多关于文件连接的讨论见参考后续资料。</p><p>上面涉及到了处理某格式化行中的指定列，包括截取（如 <code>SQL</code> 的 <code>select</code> 用法），连接（如 <code>SQL</code> 的 <code>join</code> 用法），排序（如 <code>SQL</code> 的 <code>order by</code> 用法），都可以通过指定分割符来拆分某个格式化的行，另外，“截取”的做法还有很多，不光是 <code>cut</code>，<code>awk</code>，甚至通过 <code>IFS</code> 指定分割符的 <code>read</code> 命令也可以做到，例如：</p><pre class="line-numbers language-bash"><code class="language-bash">$ IFS<span class="token operator">=</span><span class="token string">":"</span><span class="token punctuation">;</span> <span class="token function">cat</span> /etc/group <span class="token operator">|</span> <span class="token keyword">while</span> <span class="token function">read</span> C1 C2 C3 C4<span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token keyword">echo</span> <span class="token variable">$C1</span> <span class="token variable">$C3</span><span class="token punctuation">;</span> <span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因此，熟悉这些用法，我们的工作将变得非常灵活有趣。</p><p>到这里，需要做一个简单的练习，如何把按照列对应的用户名和用户 ID 转换成按照行对应的，即把类似下面的数据：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> /etc/passwd <span class="token operator">|</span> <span class="token function">cut</span> -d<span class="token string">":"</span> -f1,3 --output-delimiter<span class="token operator">=</span><span class="token string">" "</span>root 0bin 1daemon 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>转换成：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> aroot    bin     daemon0       1       2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>并转换回去，有什么办法呢？记得诸如 <code>tr</code>，<code>paste</code>，<code>split</code> 等命令都可以使用。</p><p>参考方法：</p><ul><li>正转换：先截取用户名一列存入文件 <code>user</code>，再截取用户 <code>ID</code> 存入 <code>id</code>，再把两个文件用 <code>paste -s</code> 命令连在一起，这样就完成了正转换</li><li>逆转换：先把正转换得到的结果用 <code>split -1</code> 拆分成两个文件，再把两个拆分后的文件用 <code>tr</code> 把分割符 <code>\t</code> 替换成 <code>\n</code>，只有用 <code>paste</code> 命令把两个文件连在一起，这样就完成了逆转换。</li></ul><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="前言-3"><a href="#前言-3" class="headerlink" title="前言"></a>前言</h3><p>在日常学习和工作中，总是在不断地和各种文件打交道，这些文件包括普通文本文件，可以执行的程序，带有控制字符的文档、存放各种文件的目录、网络套接字文件、设备文件等。这些文件又具有诸如属主、大小、创建和修改日期等各种属性。文件对应文件系统的一些数据块，对应磁盘等存储设备的一片连续空间，对应于显示设备却是一些具有不同形状的字符集。</p><p>在这一节，为了把关注点定位在文件本身，不会深入探讨文件系统以及存储设备是如何组织文件的（在后续章节再深入探讨），而是探讨对它最熟悉的一面，即把文件当成是一系列的字符（一个 <code>byte</code>）集合看待。因此之前介绍的字符串操作在这里将会得到广泛的应用，关于普通文件的读写操作已经非常熟练，那就是“重定向”，这里会把这部分独立出来介绍。关于文件在 Linux 下的“数字化”（文件描述符）高度抽象，“一切皆为文件”的哲学在 Shell 编程里也得到了深刻的体现。</p><p>下面先来介绍文件的各种属性，然后介绍普通文件的一般操作。</p><h3 id="文件的各种属性"><a href="#文件的各种属性" class="headerlink" title="文件的各种属性"></a>文件的各种属性</h3><p>首先通过文件的结构体来看看文件到底有哪些属性：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> stat <span class="token punctuation">{</span>    dev_t st_dev<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 设备   */</span>    ino_t st_ino<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 节点   */</span>    mode_t st_mode<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 模式   */</span>    nlink_t st_nlink<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 硬连接 */</span>    uid_t st_uid<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 用户ID */</span>    gid_t st_gid<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 组ID   */</span>    dev_t st_rdev<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 设备类型 */</span>    off_t st_off<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 文件字节数 */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>  st_blksize<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 块大小 */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> st_blocks<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 块数   */</span>    time_t st_atime<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 最后一次访问时间 */</span>    time_t st_mtime<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 最后一次修改时间 */</span>    time_t st_ctime<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 最后一次改变时间(指属性) */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面逐次来了解这些属性，如果需要查看某个文件属性，用 <code>stat</code> 命令就可，它会按照上面的结构体把信息列出来。另外，<code>ls</code> 命令在跟上一定参数后也可以显示文件的相关属性，比如 <code>-l</code> 参数。</p><h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h4><p>文件类型对应于上面的 <code>st_mode</code>, 文件类型有很多，比如常规文件、符号链接（硬链接、软链接）、管道文件、设备文件(符号设备、块设备)、socket文件等，不同的文件类型对应不同的功能和作用。</p><h5 id="范例：在命令行简单地区分各类文件"><a href="#范例：在命令行简单地区分各类文件" class="headerlink" title="范例：在命令行简单地区分各类文件"></a>范例：在命令行简单地区分各类文件</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ls</span> -ltotal 12drwxr-xr-x 2 root root 4096 2007-12-07 20:08 directory_fileprw-r--r-- 1 root root    0 2007-12-07 20:18 fifo_pipebrw-r--r-- 1 root root 3, 1 2007-12-07 21:44 hda1_block_dev_filecrw-r--r-- 1 root root 1, 3 2007-12-07 21:43 null_char_dev_file-rw-r--r-- 2 root root  506 2007-12-07 21:55 regular_file-rw-r--r-- 2 root root  506 2007-12-07 21:55 regular_file_hard_linklrwxrwxrwx 1 root root   12 2007-12-07 20:15 regular_file_soft_link -<span class="token operator">></span> regular_file$ <span class="token function">stat</span> directory_file/  File: `directory_file/<span class="token string">'  Size: 4096            Blocks: 8          IO Block: 4096   directoryDevice: 301h/769d       Inode: 521521      Links: 2Access: (0755/drwxr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)Access: 2007-12-07 20:08:18.000000000 +0800Modify: 2007-12-07 20:08:18.000000000 +0800Change: 2007-12-07 20:08:18.000000000 +0800$ stat null_char_dev_file  File: `null_char_dev_file'</span>  Size: 0               Blocks: 0          IO Block: 4096   character special <span class="token function">file</span>Device: 301h/769d       Inode: 521240      Links: 1     Device type: 1,3Access: <span class="token punctuation">(</span>0644/crw-r--r--<span class="token punctuation">)</span>  Uid: <span class="token punctuation">(</span>    0/    root<span class="token punctuation">)</span>   Gid: <span class="token punctuation">(</span>    0/    root<span class="token punctuation">)</span>Access: 2007-12-07 21:43:38.000000000 +0800Modify: 2007-12-07 21:43:38.000000000 +0800Change: 2007-12-07 21:43:38.000000000 +0800<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：通过 <code>ls</code> 命令结果每行的第一个字符可以看到，它们之间都不相同，这正好反应了不同文件的类型。 <code>d</code> 表示目录，<code>-</code> 表示普通文件（或者硬链接），<code>l</code> 表示符号链接，<code>p</code> 表示管道文件，<code>b</code> 和 <code>c</code> 分别表示块设备和字符设备（另外 <code>s</code> 表示 <code>socket</code> 文件）。在 <code>stat</code> 命令的结果中，可以在第二行的最后找到说明，从上面的操作可以看出，<code>directory_file</code> 是目录，<code>stat</code> 命令的结果中用 <code>directory</code> 表示，而 <code>null_char_dev_file</code> 它则用 <code>character special file</code> 说明。</p><h5 id="范例：简单比较它们的异同"><a href="#范例：简单比较它们的异同" class="headerlink" title="范例：简单比较它们的异同"></a>范例：简单比较它们的异同</h5><p>通常只会用到目录、普通文件、以及符号链接，很少碰到其他类型的文件，不过这些文件还是各有用处的，如果要做嵌入式开发或者进程通信等，可能会涉及到设备文件、有名管道（FIFO）。下面通过简单的操作来反应它们之间的区别（具体原理会在下一节介绍，如果感兴趣，也可以提前到网上找找设备文件的作用、块设备和字符设备的区别、以及驱动程序中如何编写相关设备驱动等）。</p><p>对于普通文件：就是一系列字符的集合，所以可以读、写等</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token string">"hello, world"</span> <span class="token operator">></span> regular_file$ <span class="token function">cat</span> regular_filehello, world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在目录中可以创建新文件，所以目录还有叫法：文件夹，到后面会分析目录文件的结构体，它实际上存放了它下面的各个文件的文件名。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cd</span> directory_file$ <span class="token function">touch</span> file1 file2 file3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对于有名管道，操作起来比较有意思：如果要读它，除非有内容，否则阻塞；如果要写它，除非有人来读，否则阻塞。它常用于进程通信中。可以打开两个终端 <code>terminal1</code> 和 <code>terminal2</code>，试试看：</p><pre class="line-numbers language-bash"><code class="language-bash">terminal1$ <span class="token function">cat</span> fifo_pipe <span class="token comment" spellcheck="true">#刚开始阻塞在这里，直到下面的写动作发生，才打印test字符串</span>terminal2$ <span class="token keyword">echo</span> <span class="token string">"test"</span> <span class="token operator">></span> fifo_pipe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>关于块设备，字符设备，设备文件对应于 <code>/dev/hda1</code> 和 <code>/dev/null</code>，如果用过 U 盘，或者是写过简单的脚本的话，这样的用法应该用过： :-)</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">mount</span> hda1_block_dev_file /mnt <span class="token comment" spellcheck="true">#挂载硬盘的第一个分区到/mnt下（关于挂载的原理，在下一节讨论）</span>$ <span class="token keyword">echo</span> <span class="token string">"fewfewfef"</span> <span class="token operator">></span> /dev/null   <span class="token comment" spellcheck="true">#/dev/null像个黑洞，什么东西丢进去都消失殆尽</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>最后两个文件分别是 <code>regular_file</code> 文件的硬链接和软链接，去读写它们，他们的内容是相同的，不过去删除它们，他们却互不相干，硬链接和软链接又有何不同呢？前者可以说就是原文件，后者呢只是有那么一个 <code>inode</code>，但没有实际的存储空间，建议用 <code>stat</code> 命令查看它们之间的区别，包括它们的 <code>Blocks</code>，<code>inode</code> 等值，也可以考虑用 <code>diff</code> 比较它们的大小。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ls</span> regular_file*<span class="token function">ls</span> regular_file* -l-rw-r--r-- 2 root root 204800 2007-12-07 22:30 regular_file-rw-r--r-- 2 root root 204800 2007-12-07 22:30 regular_file_hard_linklrwxrwxrwx 1 root root     12 2007-12-07 20:15 regular_file_soft_link -<span class="token operator">></span> regular_file$ <span class="token function">rm</span> regular_file      <span class="token comment" spellcheck="true"># 删除原文件</span>$ <span class="token function">cat</span> regular_file_hard_link   <span class="token comment" spellcheck="true"># 硬链接还在，而且里头的内容还有呢</span>fefe$ <span class="token function">cat</span> regular_file_soft_linkcat: regular_file_soft_link: No such <span class="token function">file</span> or directory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然软链接文件本身还在，不过因为它本身不存储内容，所以读不到东西，这就是软链接和硬链接的区别。</p><p>需要注意的是，硬链接不可以跨文件系统，而软链接则可以。另外，也不允许给目录创建硬链接。</p><h5 id="范例：普通文件再分类"><a href="#范例：普通文件再分类" class="headerlink" title="范例：普通文件再分类"></a>范例：普通文件再分类</h5><p>文件类型从 Linux 文件系统那么一个级别分了以上那么多类型，不过普通文件还是可以再分的（根据文件内容的”数据结构“分），比如常见的文本文件，可执行的 <code>ELF</code> 文件，<code>odt</code> 文档，<code>jpg</code> 图片格式，<code>swap</code> 分区文件，<code>pdf</code> 文件。除了文本文件外，它们大多是二进制文件，有特定的结构，因此需要有专门的工具来创建和编辑它们。关于各类文件的格式，可以参考相关文档标准。不过非常值得深入了解 Linux 下可执行的 <code>ELF</code> 文件的工作原理，如果有兴趣，建议阅读一下参考资料中和 <code>ELF</code> 文件相关部分，这一部分对于嵌入式 Linux 工程师至关重要。</p><p>虽然各类普通文件都有专属的操作工具，但是还是可以直接读、写它们，这里先提到这么几个工具，回头讨论细节。</p><ul><li><code>od</code> ：以八进制或者其他格式“导出”文件内容。</li><li><code>strings</code> ：读出文件中的字符（可打印的字符）</li><li><code>gcc</code>，<code>gdb</code>，<code>readelf</code>，objdump<code>等：</code>ELF<code>文件分析、处理工具（</code>gcc<code>编译器、</code>gdb<code>调试器、</code>readelf<code>分析 ELF 文件，</code>objdump` 反编译工具）</li></ul><p>再补充一个非常重要的命令，<code>file</code>，这个命令用来查看各类文件的属性。和 <code>stat</code> 命令相比，它可以进一步识别普通文件，即 <code>stat</code> 命令显示的 <code>regular file</code> 。因为 <code>regular file</code> 可以有各种不同的结构，因此在操作系统的支持下得到不同的解释，执行不同的动作。虽然，Linux 下，文件也会加上特定的后缀以便用户能够方便地识别文件的类型，但是 Linux 操作系统根据文件头识别各类文件，而不是文件后缀，这样在解释相应的文件时就更不容易出错。下面简单介绍 <code>file</code> 命令的用法。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">file</span> ././: directory$ <span class="token function">file</span> /etc/profile/etc/profile: ASCII English text$ <span class="token function">file</span> /lib/libc-2.5.so/lib/libc-2.5.so: ELF 32-bit LSB shared object, Intel 80386, version 1 <span class="token punctuation">(</span>SYSV<span class="token punctuation">)</span>, not stripped$ <span class="token function">file</span> /bin/test/bin/test: ELF 32-bit LSB executable, Intel 80386, version 1 <span class="token punctuation">(</span>SYSV<span class="token punctuation">)</span>, dynamically linked <span class="token punctuation">(</span>uses shared libs<span class="token punctuation">)</span>, stripped$ <span class="token function">file</span> /dev/hda/dev/hda: block special <span class="token punctuation">(</span>3/0<span class="token punctuation">)</span>$ <span class="token function">file</span> /dev/console/dev/console: character special <span class="token punctuation">(</span>5/1<span class="token punctuation">)</span>$ <span class="token function">cp</span> /etc/profile <span class="token keyword">.</span>$ <span class="token function">tar</span> zcf profile.tar.gz profile$ <span class="token function">file</span> profile.tar.gzprofile.tar.gz: <span class="token function">gzip</span> compressed data, from Unix, last modified: Tue Jan  4 18:53:53 2000$ <span class="token function">mkfifo</span> fifo_test$ <span class="token function">file</span> fifo_testfifo_test: fifo <span class="token punctuation">(</span>named pipe<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更多用法见 <code>file</code> 命令的手册，关于 <code>file</code> 命令的实现原理，请参考 <code>magic</code> 的手册（看看 <code>/etc/file/magic</code> 文件，了解什么是文件的 <code>magic number</code> 等）。</p><h4 id="文件属主"><a href="#文件属主" class="headerlink" title="文件属主"></a>文件属主</h4><p>Linux 作为一个多用户系统，为多用户使用同一个系统提供了极大的方便，比如对于系统上的文件，它通过属主来区分不同的用户，以便分配它们对不同文件的操作权限。为了更方便地管理，文件属主包括该文件所属用户，以及该文件所属的用户组，因为用户可以属于多个组。先来简单介绍 Linux 下用户和组的管理。</p><p>Linux 下提供了一组命令用于管理用户和组，比如用于创建用户的 <code>useradd</code> 和 <code>groupadd</code>，用于删除用户的 <code>userdel</code> 和 <code>groupdel</code>，另外，<code>passwd</code> 命令用于修改用户密码。当然，Linux 还提供了两个相应的配置，即 <code>/etc/passwd</code> 和 <code>/etc/group</code>，另外，有些系统还把密码单独放到了配置文件 <code>/etc/shadow</code> 中。关于它们的详细用法请参考后面的资料，这里不再介绍，仅介绍文件和用户之间的一些关系。</p><h5 id="范例：修改文件的属主"><a href="#范例：修改文件的属主" class="headerlink" title="范例：修改文件的属主"></a>范例：修改文件的属主</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">chown</span> 用户名:组名 文件名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果要递归地修改某个目录下所有文件的属主，可以添加 <code>-R</code> 选项。</p><p>从本节开头列出的文件结构体中，可以看到仅仅有用户 <code>ID</code> 和组 <code>ID</code> 的信息，但 <code>ls -l</code> 的结果却显示了用户名和组名信息，这个是怎么实现的呢？下面先看看 <code>-n</code> 的结果：</p><h5 id="范例：查看文件的属主"><a href="#范例：查看文件的属主" class="headerlink" title="范例：查看文件的属主"></a>范例：查看文件的属主</h5><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ls</span> -n regular_file-rw-r--r-- 1 0 0 115 2007-12-07 23:45 regular_file$ <span class="token function">ls</span> -l regular_file-rw-r--r-- 1 root root 115 2007-12-07 23:45 regular_file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="范例：分析文件属主实现的背后原理"><a href="#范例：分析文件属主实现的背后原理" class="headerlink" title="范例：分析文件属主实现的背后原理"></a>范例：分析文件属主实现的背后原理</h5><p>可以看到，<code>ls -n</code> 显示了用户 <code>ID</code> 和组 <code>ID</code>，而 <code>ls -l</code> 显示了它们的名字。还记得上面提到的两个配置文件 <code>/etc/passwd</code> 和 <code>/etc/group</code> 文件么？它们分别存放了用户 <code>ID</code> 和用户名，组 <code>ID</code> 和组名的对应关系，因此很容易想到 <code>ls -l</code> 命令在实现时是如何通过文件结构体的 <code>ID</code> 信息找到它们对应的名字信息的。如果想对 <code>ls -l</code> 命令的实现有更进一步的了解，可以用 <code>strace</code> 跟踪看看它是否读取了这两个配置文件。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">strace</span> -f -o strace.log <span class="token function">ls</span> -l regular_file$ <span class="token function">cat</span> strace.log <span class="token operator">|</span> <span class="token function">egrep</span> <span class="token string">"passwd|group|shadow"</span>2989  open<span class="token punctuation">(</span><span class="token string">"/etc/passwd"</span>, O_RDONLY<span class="token punctuation">)</span>     <span class="token operator">=</span> 32989  open<span class="token punctuation">(</span><span class="token string">"/etc/group"</span>, O_RDONLY<span class="token punctuation">)</span>      <span class="token operator">=</span> 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>说明： <code>strace</code> 可以用来跟踪系统调用和信号。如同 <code>gdb</code> 等其他强大的工具一样，它基于系统的 <code>ptrace</code> 系统调用实现。</p><p>实际上，把属主和权限分开介绍不太好，因为只有它们两者结合才使得多用户系统成为可能，否则无法隔离不同用户对某个文件的操作，所以下面来介绍文件操作权限。</p><h4 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h4><p>从 <code>ls -l</code> 命令的结果的第一列的后 9 个字符中，可以看到类似这样的信息 <code>rwxr-xr-x</code>，它们对应于文件结构体的 <code>st_mode</code> 部分（<code>st_mode</code> 包含文件类型信息和文件权限信息两部分）。这类信息可以分成三部分，即 <code>rwx</code>，<code>r-x</code>，<code>r-x</code>，分别对应该文件所属用户、所属组、其他组对该文件的操作权限，如果有 <code>rwx</code> 中任何一个表示可读、可写、可执行，如果为 <code>-</code> 表示没有这个权限。对应地，可以用八进制来表示它，比如 <code>rwxr-xr-x</code> 就可表示成二进制 111101101，对应的八进制则为 755 。正因为如此，要修改文件的操作权限，也可以有多种方式来实现，它们都可通过 <code>chmod</code> 命令来修改。</p><h5 id="范例：给文件添加读、写、可执行权限"><a href="#范例：给文件添加读、写、可执行权限" class="headerlink" title="范例：给文件添加读、写、可执行权限"></a>范例：给文件添加读、写、可执行权限</h5><p>比如，把 <code>regular_file</code> 的文件权限修改为所有用户都可读、可写、可执行，即 <code>rwxrwxrwx</code>，也可表示为 111111111，翻译成八进制，则为 777 。这样就可以通过两种方式修改这个权限。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">chmod</span> a+rwx regular_file<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">chmod</span> 777 regular_file<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>说明： <code>a</code> 指所有用户，如果只想给用户本身可读可写可执行权限，那么可以把 <code>a</code> 换成 <code>u</code> ；而 <code>+</code> 就是添加权限，相反的，如果想去掉某个权限，用 <code>-</code>，而 <code>rwx</code> 则对应可读、可写、可执行。更多用法见 <code>chmod</code> 命令的帮助。</p><p>实际上除了这些权限外，还有两个涉及到安全方面的权限，即 <code>setuid/setgid</code> 和只读控制等。</p><p>如果设置了文件（程序或者命令）的 <code>setuid/setgid</code> 权限，那么用户将可用 <code>root</code> 身份去执行该文件，因此，这将可能带来安全隐患；如果设置了文件的只读权限，那么用户将仅仅对该文件将有可读权限，这为避免诸如 <code>rm -rf</code> 的“可恶”操作带来一定的庇佑。</p><h5 id="范例：授权普通用户执行root所属命令"><a href="#范例：授权普通用户执行root所属命令" class="headerlink" title="范例：授权普通用户执行root所属命令"></a>范例：授权普通用户执行root所属命令</h5><p>默认情况下，系统是不允许普通用户执行 <code>passwd</code> 命令的，通过 <code>setuid/setgid</code>，可以授权普通用户执行它。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ls</span> -l /usr/bin/passwd-rwx--x--x 1 root root 36092 2007-06-19 14:59 /usr/bin/passwd$ <span class="token function">su</span>      <span class="token comment" spellcheck="true">#切换到root用户，给程序或者命令添加“粘着位”</span>$ <span class="token function">chmod</span> +s /usr/bin/passwd$ <span class="token function">ls</span> -l /usr/bin/passwd-rws--s--x 1 root root 36092 2007-06-19 14:59 /usr/bin/passwd$ <span class="token keyword">exit</span>$ <span class="token function">passwd</span> <span class="token comment" spellcheck="true">#普通用户通过执行该命令，修改自己的密码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><blockquote><p><code>setuid</code> 和 <code>setgid</code> 位是让普通用户可以以 <code>root</code> 用户的角色运行只有 <code>root</code> 帐号才能运行的程序或命令。</p></blockquote><p>虽然这在一定程度上为管理提供了方便，比如上面的操作让普通用户可以修改自己的帐号，而不是要 <code>root</code> 帐号去为每个用户做这些工作。关于 <code>setuid/setgid</code> 的更多详细解释，请参考最后推荐的资料。</p><h5 id="范例：给重要文件加锁"><a href="#范例：给重要文件加锁" class="headerlink" title="范例：给重要文件加锁"></a>范例：给重要文件加锁</h5><p>只读权限示例：给重要文件加锁（添加不可修改位 [immutable]))，以避免各种误操作带来的灾难性后果（例如 <code>:</code> <code>rm -rf</code>）</p><pre class="line-numbers language-bash"><code class="language-bash">$ chattr +i regular_file$ lsattr regular_file----i-------- regular_file$ <span class="token function">rm</span> regular_file    <span class="token comment" spellcheck="true">#加immutable位后就无法对文件进行任何“破坏性”的活动啦</span>rm: remove write-protected regular <span class="token function">file</span> `regular_file<span class="token string">'? yrm: cannot remove `regular_file'</span><span class="token keyword">:</span> Operation not permitted$ chattr -i regular_file <span class="token comment" spellcheck="true">#如果想对它进行常规操作，那么可以把这个位去掉</span>$ <span class="token function">rm</span> regular_file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明： <code>chattr</code> 可以用于设置文件的特殊权限，更多用法请参考 <code>chattr</code> 的帮助。</p><h4 id="文件大小"><a href="#文件大小" class="headerlink" title="文件大小"></a>文件大小</h4><p>文件大小对于普通文件而言就是文件内容的大小，而目录作为一个特殊的文件，它存放的内容是以目录结构体组织的各类文件信息，所以目录的大小一般都是固定的，它存放的文件个数自然也就有上限，即它的大小除以文件名的长度。设备文件的“文件大小”则对应设备的主、次设备号，而有名管道文件因为特殊的读写性质，所以大小常是 0 。硬链接（目录文件不能创建硬链接）实质上是原文件的一个完整的拷贝，因此，它的大小就是原文件的大小。而软链接只是一个 <code>inode</code>，存放了一个指向原文件的指针，因此它的大小仅仅是原文件名的字节数。下面我们通过演示增加记忆。</p><h5 id="范例：查看普通文件和链接文件"><a href="#范例：查看普通文件和链接文件" class="headerlink" title="范例：查看普通文件和链接文件"></a>范例：查看普通文件和链接文件</h5><p>原文件，链接文件文件大小的示例：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> -n <span class="token string">"abcde"</span> <span class="token operator">></span> regular_file   <span class="token comment" spellcheck="true">#往regular_file写入5字节</span>$ <span class="token function">ls</span> -l regular_file*-rw-r--r-- 2 root root  5 2007-12-08 15:28 regular_file-rw-r--r-- 2 root root  5 2007-12-08 15:28 regular_file_hard_filelrwxrwxrwx 1 root root 12 2007-12-07 20:15 regular_file_soft_link -<span class="token operator">></span> regular_filelrwxrwxrwx 1 root root 22 2007-12-08 15:21 regular_file_soft_link_link -<span class="token operator">></span> regular_file_soft_link$ i<span class="token operator">=</span><span class="token string">"regular_file"</span>$ j<span class="token operator">=</span><span class="token string">"regular_file_soft_link"</span>$ <span class="token keyword">echo</span> <span class="token variable">${#i}</span> <span class="token variable">${#j}</span>   <span class="token comment" spellcheck="true">#软链接存放的刚好是它们指向的原文件的文件名的字节数</span>12 22<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="范例：查看设备文件"><a href="#范例：查看设备文件" class="headerlink" title="范例：查看设备文件"></a>范例：查看设备文件</h5><p>设备号对应的文件大小：主、次设备号</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ls</span> -l hda1_block_dev_filebrw-r--r-- 1 root root 3, 1 2007-12-07 21:44 hda1_block_dev_file$ <span class="token function">ls</span> -l null_char_dev_filecrw-r--r-- 1 root root 1, 3 2007-12-07 21:43 null_char_dev_file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>补充：主 <code>(major)、次</code>(minor)设备号的作用有不同。当一个设备文件被打开时，内核会根据主设备号（<code>major number</code>）去查找在内核中已经以主设备号注册的驱动（可以 <code>cat /proc/devices</code> 查看已经注册的驱动号和主设备号的对应情况），而次设备号（<code>minor number</code>）则是通过内核传递给了驱动本身（参考《The Linux Primer》第十章）。因此，对于内核而言，通过主设备号就可以找到对应的驱动去识别某个设备，而对于驱动而言，为了能够更复杂地访问设备，比如访问设备的不同部分（如硬件通过分区分成不同部分，而出现 <code>hda1</code>，<code>hda2</code>，<code>hda3</code> 等），比如产生不同要求的随机数（如 <code>/dev/random</code> 和 <code>/dev/urandom</code> 等）。</p><h5 id="范例：查看目录"><a href="#范例：查看目录" class="headerlink" title="范例：查看目录"></a>范例：查看目录</h5><p>目录文件的大小，为什么是这样呢？看看下面的目录结构体的大小，目录文件的 Block 中存放了该目录下所有文件名的入口。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ls</span> -ld directory_file/drwxr-xr-x 2 root root 4096 2007-12-07 23:14 directory_file/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>目录的结构体如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> dirent <span class="token punctuation">{</span>    <span class="token keyword">long</span> d_ino<span class="token punctuation">;</span>    off_t d_off<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> d_reclen<span class="token punctuation">;</span>    <span class="token keyword">char</span> d_name<span class="token punctuation">[</span>NAME_MAX<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 文件名称 */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="文件访问、更新、修改时间"><a href="#文件访问、更新、修改时间" class="headerlink" title="文件访问、更新、修改时间"></a>文件访问、更新、修改时间</h4><p>文件的时间属性可以记录用户对文件的操作信息，在系统管理、判断文件版本信息等情况下将为管理员提供参考。因此，在阅读文件时，建议用 <code>cat</code> 等阅读工具，不要用编辑工具 <code>vim</code> 去阅读，因为即使没有做任何修改操作，一旦执行了保存命令，将修改文件的时间戳信息。</p><h4 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h4><p>文件名并没有存放在文件结构体内，而是存放在它所在的目录结构体中。所以，在目录的同一级别中，文件名必须是唯一的。</p><h3 id="文件的基本操作"><a href="#文件的基本操作" class="headerlink" title="文件的基本操作"></a>文件的基本操作</h3><p>对于文件，常见的操作包括创建、删除、修改、读、写等。关于各种操作对应的“背后动作”将在下一节详细分析。</p><h4 id="范例：创建文件"><a href="#范例：创建文件" class="headerlink" title="范例：创建文件"></a>范例：创建文件</h4><p><code>socket</code> 文件是一类特殊的文件，可以通过 C 语言创建，这里不做介绍（暂时不知道是否可以用命令直接创建），其他文件将通过命令创建。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">touch</span> regular_file      <span class="token comment" spellcheck="true">#创建普通文件</span>$ <span class="token function">mkdir</span> directory_file     <span class="token comment" spellcheck="true">#创建目录文件，目录文件里头可以包含更多文件</span>$ <span class="token function">ln</span> regular_file regular_file_hard_link  <span class="token comment" spellcheck="true">#硬链接，是原文件的一个完整拷比</span>$ <span class="token function">ln</span> -s regular_file regular_file_soft_link  <span class="token comment" spellcheck="true">#类似一个文件指针，指向原文件</span>$ <span class="token function">mkfifo</span> fifo_pipe   <span class="token comment" spellcheck="true">#或者通过 "mknod fifo_pipe p" 来创建，FIFO满足先进先出的特点</span>$ <span class="token function">mknod</span> hda1_block_dev_file b 3 1  <span class="token comment" spellcheck="true">#块设备</span>$ <span class="token function">mknod</span> null_char_dev_file c 1 3   <span class="token comment" spellcheck="true">#字符设备</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建一个文件实际上是在文件系统中添加了一个节点（<code>inode)，该节点信息将保存到文件系统的节点表中。更形象地说，就是在一颗树上长了一颗新的叶子（文件）或者枝条（目录文件，上面还可以长叶子的那种），这些可以通过</code>tree<code>命令或者</code>ls` 命令形象地呈现出来。文件系统从日常使用的角度，完全可以当成一颗倒立的树来看，因为它们太像了，太容易记忆啦。</p><pre class="line-numbers language-bash"><code class="language-bash">$ tree 当前目录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ls</span> 当前目录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="范例：删除文件"><a href="#范例：删除文件" class="headerlink" title="范例：删除文件"></a>范例：删除文件</h4><p>删除文件最直接的印象是这个文件再也不存在了，这同样可以通过 <code>ls</code> 或者 <code>tree</code> 命令呈现出来，就像树木被砍掉一个分支或者摘掉一片叶子一样。实际上，这些文件删除之后，并不是立即消失了，而是仅仅做了删除标记，因此，如果删除之后，没有相关的磁盘写操作把相应的磁盘空间“覆盖”，那么原理上是可以恢复的（虽然如此，但是这样的工作往往很麻烦，所以在删除一些重要数据时，请务必三思而后行，比如做好备份工作），相应的做法可以参考后续资料。</p><p>具体删除文件的命令有 <code>rm</code>，如果要删除空目录，可以用 <code>rmdir</code> 命令。例如：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">rm</span> regular_file$ <span class="token function">rmdir</span> directory_file$ <span class="token function">rm</span> -r directory_file_not_empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>rm</code> 有两个非常重要的参数，一个是 <code>-f</code>，这个命令是非常“野蛮的”，它估计给很多 Linux user 带来了痛苦，另外一个是 <code>-i</code>，这个命令是非常“温柔的”，它估计让很多用户感觉烦躁不已。用哪个还是根据您的“心情”吧，如果做好了充分的备份工作，或者采取了一些有效避免灾难性后果的动作的话，您在做这些工作的时候就可以放心一些啦。</p><h4 id="范例：复制文件"><a href="#范例：复制文件" class="headerlink" title="范例：复制文件"></a>范例：复制文件</h4><p>文件的复制通常是指文件内容的“临时”复制。通过这一节开头的介绍，我们应该了解到，文件的硬链接和软链接在某种意义上说也是“文件的复制”，前者同步复制文件内容，后者在读写的情况下同步“复制”文件内容。例如：</p><p>用 <code>cp</code> 命令常规地复制文件（复制目录需要 <code>-r</code> 选项）</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cp</span> regular_file regular_file_copy$ <span class="token function">cp</span> -r diretory_file directory_file_copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>创建硬链接（<code>link</code> 和 <code>copy</code> 不同之处是：<code>link</code> 为同步更新，<code>copy</code> 则不然，复制之后两者不再相关）</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ln</span> regular_file regular_file_hard_link<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建软链接</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ln</span> -s regular_file regluar_file_soft_link<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="范例：修改文件名"><a href="#范例：修改文件名" class="headerlink" title="范例：修改文件名"></a>范例：修改文件名</h4><p>修改文件名实际上仅仅修改了文件名标识符。可以通过 <code>mv</code> 命令来实现修改文件名操作（即重命名）。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">mv</span> regular_file regular_file_new_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="范例：编辑文件"><a href="#范例：编辑文件" class="headerlink" title="范例：编辑文件"></a>范例：编辑文件</h4><p>编辑文件实际上是操作文件的内容，对应普通文本文件的编辑，这里主要涉及到文件内容的读、写、追加、删除等。这些工作通常会通过专门的编辑器来做，这类编辑器有命令行下的 <code>vim</code> 、 <code>emacs</code> 和图形界面下的 <code>gedit,kedit</code> 等。如果是一些特定的文件，会有专门的编辑和处理工具，比如图像处理软件 <code>gimp</code>，文档编辑软件 <code>OpenOffice</code> 等。这些工具一般都会有专门的教程。</p><p>下面主要简单介绍 Linux 下通过重定向来实现文件的这些常规的编辑操作。</p><p>创建一个文件并写入 <code>abcde</code></p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token string">"abcde"</span> <span class="token operator">></span> new_regular_file<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再往上面的文件中追加一行 <code>abcde</code></p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token string">"abcde"</span> <span class="token operator">>></span> new_regular_file<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>按行读一个文件</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">while</span> <span class="token function">read</span> LINE<span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token keyword">echo</span> <span class="token variable">$LINE</span><span class="token punctuation">;</span> <span class="token keyword">done</span> <span class="token operator">&lt;</span> test.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>提示：如果要把包含重定向的字符串变量当作命令来执行，请使用 <code>eval</code> 命令，否则无法解释重定向。例如，</p><pre class="line-numbers language-bash"><code class="language-bash">$ redirect<span class="token operator">=</span><span class="token string">"echo \"abcde\" >test_redirect_file"</span>$ <span class="token variable">$redirect</span>   <span class="token comment" spellcheck="true">#这里会把>当作字符 > 打印出来，而不会当作 重定向 解释</span><span class="token string">"abcde"</span> <span class="token operator">></span>test_redirect_file$ <span class="token function">eval</span> <span class="token variable">$redirect</span>    <span class="token comment" spellcheck="true">#这样才会把 > 解释成 重定向</span>$ <span class="token function">cat</span> test_redirect_fileabcde<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="范例：压缩／解压缩文件"><a href="#范例：压缩／解压缩文件" class="headerlink" title="范例：压缩／解压缩文件"></a>范例：压缩／解压缩文件</h4><p>压缩和解压缩文件在一定意义上来说是为了方便文件内容的传输，不过也可能有一些特定的用途，比如内核和文件系统的映像文件等（更多相关的知识请参考后续资料）。</p><p>这里仅介绍几种常见的压缩和解压缩方法：</p><p>tar</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">tar</span> -cf file.tar <span class="token function">file</span>   <span class="token comment" spellcheck="true">#压缩</span>$ <span class="token function">tar</span> -xf file.tar    <span class="token comment" spellcheck="true">#解压</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>gz</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">gzip</span>  -9 <span class="token function">file</span>$ gunzip <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>tar.gz</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">tar</span> -zcf file.tar.gz <span class="token function">file</span>$ <span class="token function">tar</span> -zxf file.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>bz2</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">bzip2</span> <span class="token function">file</span>$ bunzip2 <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>tar.bz2</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">tar</span> -jcf file.tar.bz2 <span class="token function">file</span>$ <span class="token function">tar</span> -jxf file.tar.bz2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过上面的演示，应该已经非常清楚 <code>tar</code>，<code>bzip2，</code>bunzip2，<code>gzip，</code>gunzip<code>命令的角色了吧？如果还不清楚，多操作和比较一些上面的命令，并查看它们的手册：</code>man tar`…</p><h4 id="范例：文件搜索（文件定位）"><a href="#范例：文件搜索（文件定位）" class="headerlink" title="范例：文件搜索（文件定位）"></a>范例：文件搜索（文件定位）</h4><p>文件搜索是指在某个目录层次中找出具有某些属性的文件在文件系统中的位置，这个位置如果扩展到整个网络，那么可以表示为一个 <code>URL</code> 地址，对于本地的地址，可以表示为 <code>file://+</code> 本地路径。本地路径在 Linux 系统下是以 <code>/</code> 开头，例如，每个用户的家目录可以表示为： <code>file:///home/</code> 。下面仅仅介绍本地文件搜索的一些办法。</p><p><code>find</code> 命令提供了一种“及时的”搜索办法，它根据用户的请求，在指定的目录层次中遍历所有文件直到找到需要的文件为止。而 <code>updatedb+locate</code> 提供了一种“快速的”的搜索策略，<code>updatedb</code> 更新并产生一个本地文件数据库，而 <code>locate</code> 通过文件名检索这个数据库以便快速找到相应的文件。前者支持通过各种文件属性进行搜索，并且提供了一个接口（<code>-exec</code> 选项）用于处理搜索后的文件。因此为“单条命令”脚本的爱好者提供了极大的方便，不过对于根据文件名的搜索而言，<code>updatedb+locate</code> 的方式在搜索效率上会有明显提高。下面简单介绍这两种方法：</p><p><code>find</code> 命令基本使用演示</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">find</span> ./ -name <span class="token string">"*.c"</span> -o -name <span class="token string">"*.h"</span>  <span class="token comment" spellcheck="true">#找出所有的C语言文件，-o是或者</span>$ <span class="token function">find</span> ./ \<span class="token punctuation">(</span> -name <span class="token string">"*.c"</span> -o -name <span class="token string">"*.h"</span> \<span class="token punctuation">)</span> -exec <span class="token function">mv</span> <span class="token string">'{}'</span> ./c_files/ \<span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 把找到的文件移到c_files下，这种用法非常有趣</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面的用法可以用 <code>xargs</code> 命令替代</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">find</span> ./ -name <span class="token string">"*.c"</span> -o -name <span class="token string">"*.h"</span> <span class="token operator">|</span> <span class="token function">xargs</span> -i <span class="token function">mv</span> <span class="token string">'{}'</span> ./c_files/<span class="token comment" spellcheck="true"># 如果要对文件做更复杂的操作，可以考虑把mv改写为你自己的处理命令，例如，我需要修</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>改所有的文件名后缀为大写。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">find</span> ./ -name <span class="token string">"*.c"</span> -o -name <span class="token string">"*.h"</span> <span class="token operator">|</span> <span class="token function">xargs</span> -i ./toupper.sh <span class="token string">'{}'</span> ./c_files/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>toupper.sh</code> 就是我们需要实现的转换小写为大写的一个处理文件，具体实现如下：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> toupper.sh<span class="token comment" spellcheck="true">#!/bin/bash</span><span class="token comment" spellcheck="true"># the {} will be expended to the current line and becomen the first argument of this script</span>FROM<span class="token operator">=</span><span class="token variable">$1</span>BASENAME<span class="token operator">=</span>$<span class="token punctuation">{</span>FROM<span class="token comment" spellcheck="true">##*/}</span>BASE<span class="token operator">=</span><span class="token variable">${BASENAME%.*}</span>SUFFIX<span class="token operator">=</span>$<span class="token punctuation">{</span>BASENAME<span class="token comment" spellcheck="true">##*.}</span>TOSUFFIX<span class="token operator">=</span><span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token keyword">echo</span> $SUFFIX <span class="token operator">|</span> <span class="token function">tr</span> '<span class="token punctuation">[</span>a-z<span class="token punctuation">]</span>' '<span class="token punctuation">[</span>A-Z<span class="token punctuation">]</span>'<span class="token variable">)</span></span>"</span>TO<span class="token operator">=</span><span class="token variable">$2</span>/<span class="token variable">$BASE</span><span class="token keyword">.</span><span class="token variable">$TOSUFFIX</span>COM<span class="token operator">=</span><span class="token string">"mv <span class="token variable">$FROM</span> <span class="token variable">$TO</span>"</span><span class="token keyword">echo</span> <span class="token variable">$COM</span><span class="token function">eval</span> <span class="token variable">$COM</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>updatedb+locate</code> 基本使用演示</p><pre class="line-numbers language-bash"><code class="language-bash">$ updatedb <span class="token comment" spellcheck="true">#更新库</span>$ <span class="token function">locate</span> find*.gz <span class="token comment" spellcheck="true">#查找包含find字符串的所有gz压缩包</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>实际上，除了上面两种命令外，Linux 下还有命令查找工具：<code>which</code> 和 <code>whereis</code>，前者用于返回某个命令的全路径，而后者用于返回某个命令、源文件、<code>man 文件的路径。例如，查找</code>find` 命令的绝对路径：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">which</span> <span class="token function">find</span>/usr/bin/find$ <span class="token function">whereis</span> <span class="token function">find</span>find: /usr/bin/find /usr/X11R6/bin/find /usr/bin/X11/find /usr/X11/bin/find /usr/man/man1/find.1.gz /usr/share/man/man1/find.1.gz /usr/X11/man/man1/find.1.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>需要提到的是，如果想根据文件的内容搜索文件，那么 <code>find</code> 和 <code>updatedb+locate</code> 以及 <code>which</code>，<code>whereis</code> 都无能为力啦，可选的方法是 <code>grep</code>，<code>sed</code> 等命令，前者在加上 <code>-r</code> 参数以后可以在指定目录下文件中搜索指定的文件内容，后者再使用 <code>-i</code> 参数后，可以对文件内容进行替换。它们的基本用法在前面的章节中已经详细介绍了，这里就不再赘述。</p><p>值得强调的是，这些命令对文件的操作非常有意义。它们在某个程度上把文件系统结构给抽象了，使得对整个文件系统的操作简化为对单个文件的操作，而单个文件如果仅仅考虑文本部分，那么最终却转化成了之前的字符串操作，即上一节讨论过的内容。为了更清楚地了解文件的组织结构，文件之间的关系，在下一节将深入探讨文件系统。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-vfs/">从文件 I/O 看 Linux 的虚拟文件系统</a></li><li><a href="http://www.ibm.com/developerworks/cn/linux/l-linux-filesystem/index.html?ca=drs-cn">Linux 文件系统剖析</a></li><li><a href="http://lwn.net/Kernel/LDD3/">Linux Device Drivers, 3rd Edition</a></li><li><a href="http://www.ibm.com/developerworks/cn/linux/l-iotips/index.html">技巧：Linux I/O 重定向的一些小技巧</a></li><li>Intel 平台下 Linux 中 ELF 文件动态链接的加载、解析及实例分析:<ul><li><a href="http://www.ibm.com/developerworks/cn/linux/l-elf/part1/index.html">part1</a>,</li><li><a href="http://www.ibm.com/developerworks/cn/linux/l-elf/part2/index.html">part2</a></li></ul></li><li><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-shell-debug/index.html">Shell 脚本调试技术</a></li><li><a href="http://www.linuxsir.org/bbs/thread206356.html">ELF 文件格式及程序加载执行过程总汇</a></li><li><a href="http://fanqiang.chinaunix.net/a4/b2/20010508/113315.html">Linux下 C 语言编程——文件的操作</a></li><li><a href="http://www.mwjx.com/aboutfish/private/book/linux_c.txt">“Linux下 C 语言编程” 的 文件操作部分</a></li><li><a href="http://www.pathname.com/fhs/pub/fhs-2.3.html#INTRODUCTION">Filesystem Hierarchy Standard</a></li><li><a href="http://tech.ccidnet.com/art/237/20070720/1150559_1.html">学会恢复 Linux系统里被删除的 Ext3 文件</a></li><li><a href="http://bbs.tech.ccidnet.com/read.php?tid=48372">使用mc恢复被删除文件</a></li><li><a href="http://www.linuxdiyf.com/viewarticle.php?id=30866">linux ext3 误删除及恢复原理</a></li><li><a href="http://www.cnblogs.com/eoiioe/archive/2008/09/20/1294681.html">Linux压缩／解压缩方式大全</a></li><li><a href="http://www.reteam.org/papers/e56.pdf">Everything is a byte</a></li></ul><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><ul><li>考虑到文件和文件系统的重要性，将把它分成三个小节来介绍：文件、文件系统、程序与进程。在“文件”这一部分，主要介绍文件的基本属性和常规操作，在“文件系统”那部分，将深入探讨 Linux 文件系统的各个部分（包括 Linux 文件系统的结构、具体某个文件系统的大体结构分析、底层驱动的工作原理），在“程序与进程”一节将专门讨论可执行文件的相关内容（包括不同的程序类型、加载执行过程、不同进程之间的交互[命令管道和无名管道、信号通信]、对进程的控制等）</li><li>有必要讨论清楚 目录大小 的含义，另外，最好把一些常规的文件操作全部考虑到，包括文件的读、写、执行、删除、修改、复制、压缩／解压缩等</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 教程 </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程的内存映像</title>
      <link href="posts/61063/"/>
      <url>posts/61063/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>APUE的第 14 章时，看到一个“打印不同类型的数据所存放的位置”的例子，它非常清晰地从程序内部反应了“进程的内存映像”，通过结合它与Gcc 编译的背后和缓冲区溢出与注入分析的相关内容，可以更好地辅助理解相关的内容。</p><h2 id="进程内存映像表"><a href="#进程内存映像表" class="headerlink" title="进程内存映像表"></a>进程内存映像表</h2><p>首先回顾一下缓冲区溢出与注入中提到的”进程内存映像表”，并把共享内存的大概位置加入该表：</p><table><thead><tr><th>地址</th><th>内核空间</th><th>描述</th></tr></thead><tbody><tr><td>0xC0000000</td><td></td><td></td></tr><tr><td></td><td>(program flie) 程序名</td><td>execve 的第一个参数</td></tr><tr><td></td><td>(environment) 环境变量</td><td>execve 的第三个参数，main 的第三个参数</td></tr><tr><td></td><td>(arguments) 参数</td><td>execve 的第二个参数，main 的形参</td></tr><tr><td></td><td>(stack) 栈</td><td>自动变量以及每次函数调用时所需保存的信息都</td></tr><tr><td></td><td></td><td>存放在此，包括函数返回地址、调用者的</td></tr><tr><td></td><td></td><td>环境信息等，函数的参数，局部变量都存放在此</td></tr><tr><td></td><td>(shared memory) 共享内存</td><td>共享内存的大概位置</td></tr><tr><td></td><td>…</td><td></td></tr><tr><td></td><td>…</td><td></td></tr><tr><td></td><td>(heap) 堆</td><td>主要在这里进行动态存储分配，比如 malloc，new 等。</td></tr><tr><td></td><td>…</td><td></td></tr><tr><td></td><td>.bss (uninitilized data)</td><td>没有初始化的数据（全局变量哦）</td></tr><tr><td></td><td>.data (initilized global data)</td><td>已经初始化的全局数据（全局变量）</td></tr><tr><td></td><td>.text (Executable Instructions)</td><td>通常是可执行指令</td></tr><tr><td>0x08048000</td><td></td><td></td></tr><tr><td>0x00000000</td><td></td><td>…</td></tr></tbody></table><h2 id="在程序内部打印内存分布信息"><a href="#在程序内部打印内存分布信息" class="headerlink" title="在程序内部打印内存分布信息"></a>在程序内部打印内存分布信息</h2><p>为了能够反应上述内存分布情况，这里在APUE的程序 14-11 的基础上，添加了一个已经初始化的全局变量（存放在已经初始化的数据段内），并打印了它以及 <code>main</code> 函数(处在代码正文部分)的位置。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * showmemory.c -- print the position of different types of data in a program in the memory */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/ipc.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/shm.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">define</span> ARRAY_SIZE 4000</span><span class="token macro property">#<span class="token directive keyword">define</span> MALLOC_SIZE 100000</span><span class="token macro property">#<span class="token directive keyword">define</span> SHM_SIZE 100000</span><span class="token macro property">#<span class="token directive keyword">define</span> SHM_MODE (SHM_R | SHM_W)    </span><span class="token comment" spellcheck="true">/* user read/write */</span><span class="token keyword">int</span> init_global_variable <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* initialized global variable */</span><span class="token keyword">char</span> array<span class="token punctuation">[</span>ARRAY_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* uninitialized data = bss */</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> shmid<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token operator">*</span>shmptr<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"main: the address of the main function is %x\n"</span><span class="token punctuation">,</span> main<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"data: data segment is from %x\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>init_global_variable<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"bss: array[] from %x to %x\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>array<span class="token punctuation">[</span>ARRAY_SIZE<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"stack: around %x\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>shmid<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">/* shmid is a local variable, which is stored in the stack, hence, you     * can get the address of the stack via it*/</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>ptr <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>MALLOC_SIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"malloc error!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"heap: malloced from %x to %x\n"</span><span class="token punctuation">,</span> ptr<span class="token punctuation">,</span> ptr<span class="token operator">+</span>MALLOC_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>shmid <span class="token operator">=</span> <span class="token function">shmget</span><span class="token punctuation">(</span>IPC_PRIVATE<span class="token punctuation">,</span> SHM_SIZE<span class="token punctuation">,</span> SHM_MODE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"shmget error!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>shmptr <span class="token operator">=</span> <span class="token function">shmat</span><span class="token punctuation">(</span>shmid<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"shmat error!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"shared memory: attached from %x to %x\n"</span><span class="token punctuation">,</span> shmptr<span class="token punctuation">,</span> shmptr<span class="token operator">+</span>SHM_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shmctl</span><span class="token punctuation">(</span>shmid<span class="token punctuation">,</span> IPC_RMID<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"shmctl error!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该程序的运行结果如下：</p><pre class="line-numbers language-bash"><code class="language-bash">$  <span class="token function">make</span> showmemorycc     showmemory.c   -o showmemory$ ./showmemorymain: the address of the main <span class="token keyword">function</span> is 804846cdata: data segment is from 80498e8bss: array<span class="token punctuation">[</span><span class="token punctuation">]</span> from 8049920 to 804a8c0stack: around bfe3e224heap: malloced from 804b008 to 80636a8shared memory: attached from b7da7000 to b7dbf6a0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述运行结果反应了几个重要部分数据的大概分布情况，比如 <code>data</code> 段（那个初始化过的全局变量就位于这里）、bss 段、stack、heap，以及 shared memory 和main（代码段）的内存分布情况。</p><h2 id="在程序内部获取完整内存分布信息"><a href="#在程序内部获取完整内存分布信息" class="headerlink" title="在程序内部获取完整内存分布信息"></a>在程序内部获取完整内存分布信息</h2><p>不过，这些结果还是没有精确和完整地反应所有相关信息，如果要想在程序内完整反应这些信息，结合之前的博客，就不难想到，我们还可以通过扩展一些已经链接到可执行文件中的外部符号来获取它们。这些外部符号全部定义在可执行文件的符号表中，可以通过 <code>nm/readelf -s/objdump -t</code> 等查看到，例如：</p><pre class="line-numbers language-bash"><code class="language-bash">$ nm showmemory080497e4 d _DYNAMIC080498b0 d _GLOBAL_OFFSET_TABLE_080486c8 R _IO_stdin_used         w _Jv_RegisterClasses080497d4 d __CTOR_END__080497d0 d __CTOR_LIST__080497dc d __DTOR_END__080497d8 d __DTOR_LIST__080487cc r __FRAME_END__080497e0 d __JCR_END__080497e0 d __JCR_LIST__080498ec A __bss_start080498dc D __data_start08048680 t __do_global_ctors_aux08048414 t __do_global_dtors_aux080498e0 D __dso_handle         w __gmon_start__0804867a T __i686.get_pc_thunk.bx080497d0 d __init_array_end080497d0 d __init_array_start08048610 T __libc_csu_fini08048620 T __libc_csu_init         U __libc_start_main@@GLIBC_2.0080498ec A _edata0804a8c0 A _end080486a8 T _fini080486c4 R _fp_hw08048328 T _init080483f0 T _start08049920 B array08049900 b completed.1080498dc W data_start         U exit@@GLIBC_2.008048444 t frame_dummy080498e8 D init_global_variable0804846c T main         U malloc@@GLIBC_2.0080498e4 d p.0         U printf@@GLIBC_2.0         U shmat@@GLIBC_2.0         U shmctl@@GLIBC_2.2         U shmget@@GLIBC_2.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第三列的符号在我们的程序中被扩展以后就可以直接引用，这些符号基本上就已经完整地覆盖了相关的信息了，这样就可以得到一个更完整的程序，从而完全反应上面提到的内存分布表的信息。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * showmemory.c -- print the position of different types of data in a program in the memory */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/ipc.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/shm.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">define</span> ARRAY_SIZE 4000</span><span class="token macro property">#<span class="token directive keyword">define</span> MALLOC_SIZE 100000</span><span class="token macro property">#<span class="token directive keyword">define</span> SHM_SIZE 100000</span><span class="token macro property">#<span class="token directive keyword">define</span> SHM_MODE (SHM_R | SHM_W)        </span><span class="token comment" spellcheck="true">/* user read/write */</span>                                        <span class="token comment" spellcheck="true">/* declare the address relative variables */</span><span class="token keyword">extern</span> <span class="token keyword">char</span> _start<span class="token punctuation">,</span> __data_start<span class="token punctuation">,</span> __bss_start<span class="token punctuation">,</span> etext<span class="token punctuation">,</span> edata<span class="token punctuation">,</span> end<span class="token punctuation">;</span><span class="token keyword">extern</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>environ<span class="token punctuation">;</span><span class="token keyword">char</span> array<span class="token punctuation">[</span>ARRAY_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/* uninitialized data = bss */</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> shmid<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token operator">*</span>shmptr<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"===== memory map =====\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">".text:\t0x%x->0x%x (_start, code text)\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>_start<span class="token punctuation">,</span> <span class="token operator">&amp;</span>etext<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">".data:\t0x%x->0x%x (__data_start, initilized data)\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>__data_start<span class="token punctuation">,</span> <span class="token operator">&amp;</span>edata<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">".bss: \t0x%x->0x%x (__bss_start, uninitilized data)\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>__bss_start<span class="token punctuation">,</span> <span class="token operator">&amp;</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* shmid is a local variable, which is stored in the stack, hence, you     * can get the address of the stack via it*/</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>ptr <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>MALLOC_SIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"malloc error!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"heap: \t0x%x->0x%x (address of the malloc space)\n"</span><span class="token punctuation">,</span> ptr<span class="token punctuation">,</span> ptr<span class="token operator">+</span>MALLOC_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>shmid <span class="token operator">=</span> <span class="token function">shmget</span><span class="token punctuation">(</span>IPC_PRIVATE<span class="token punctuation">,</span> SHM_SIZE<span class="token punctuation">,</span> SHM_MODE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"shmget error!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>shmptr <span class="token operator">=</span> <span class="token function">shmat</span><span class="token punctuation">(</span>shmid<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"shmat error!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"shm  :\t0x%x->0x%x (address of shared memory)\n"</span><span class="token punctuation">,</span> shmptr<span class="token punctuation">,</span> shmptr<span class="token operator">+</span>SHM_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shmctl</span><span class="token punctuation">(</span>shmid<span class="token punctuation">,</span> IPC_RMID<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"shmctl error!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"stack:\t &lt;--0x%x--> (address of local variables)\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>shmid<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"arg:  \t0x%x (address of arguments)\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"env:  \t0x%x (address of environment variables)\n"</span><span class="token punctuation">,</span> environ<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">make</span> showmemory$ ./showmemory<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span> memory map <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>.text:    0x8048440-<span class="token operator">></span>0x8048754 <span class="token punctuation">(</span>_start, code text<span class="token punctuation">)</span>.data:    0x8049a3c-<span class="token operator">></span>0x8049a48 <span class="token punctuation">(</span>__data_start, initilized data<span class="token punctuation">)</span>.bss:     0x8049a48-<span class="token operator">></span>0x804aa20 <span class="token punctuation">(</span>__bss_start, uninitilized data<span class="token punctuation">)</span>heap:     0x804b008-<span class="token operator">></span>0x80636a8 <span class="token punctuation">(</span>address of the malloc space<span class="token punctuation">)</span>shm  <span class="token keyword">:</span>    0xb7db6000-<span class="token operator">></span>0xb7dce6a0 <span class="token punctuation">(</span>address of shared memory<span class="token punctuation">)</span>stack:     <span class="token operator">&lt;</span>--0xbff85b64--<span class="token operator">></span> <span class="token punctuation">(</span>address of local variables<span class="token punctuation">)</span>arg:      0xbff85bf4 <span class="token punctuation">(</span>address of arguments<span class="token punctuation">)</span>env:      0xbff85bfc <span class="token punctuation">(</span>address of environment variables<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>上述程序完整地勾勒出了进程的内存分布的各个重要部分，这样就可以从程序内部获取跟程序相关的所有数据了，一个非常典型的例子是，在程序运行的过程中检查代码正文部分是否被恶意篡改。</p><p>如果想更深地理解相关内容，那么可以试着利用 <code>readelf</code>，<code>objdump</code> 等来分析 ELF 可执行文件格式的结构，并利用 <code>gdb</code> 来了解程序运行过程中的内存变化情况。</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> C </tag>
            
            <tag> 编程透视 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码测试、调试与优化</title>
      <link href="posts/33911/"/>
      <url>posts/33911/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>代码写完以后往往要做测试（或验证）、调试，可能还要优化。</p><ul><li><p>关于测试（或验证）</p><p>通常对应着两个英文单词 <code>Verification</code> 和 <code>Validation</code></p><blockquote><p>The differences between verification and validation are unimportant except to the theorist; practitioners use the term V&amp;V to refer to all of the activities that are aimed at making sure the software will function as required.</p></blockquote><p>所以，无论测试（或验证）目的都是为了让软件的功能能够达到需求。测试和验证通常会通过一些形式化（貌似可以简单地认为有数学根据的）或者非形式化的方法去验证程序的功能是否达到要求。</p></li><li><p>关于调试</p><p>而调试对应英文 debug，debug 叫“驱除害虫”，也许一个软件的功能达到了要求，但是可能会在测试或者是正常运行时出现异常，因此需要处理它们。</p></li><li><p>关于优化</p><p>debug 是为了保证程序的正确性，之后就需要考虑程序的执行效率，对于存储资源受限的嵌入式系统，程序的大小也可能是优化的对象。</p><p>很多理论性的东西实在没有研究过，暂且不说吧。这里只是想把一些需要动手实践的东西先且记录和总结一下，另外很多工具在这里都有提到和罗列，包括 Linux 内核调试相关的方法和工具。关于更详细更深入的内容还是建议直接看后面的参考资料为妙。</p></li></ul><p>下面的所有演示在如下环境下进行：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">uname</span> -aLinux falcon 2.6.22-14-generic <span class="token comment" spellcheck="true">#1 SMP Tue Feb 12 07:42:25 UTC 2008 i686 GNU/Linux</span>$ <span class="token keyword">echo</span> <span class="token variable">$SHELL</span>/bin/bash$ /bin/bash --version <span class="token operator">|</span> <span class="token function">grep</span> <span class="token function">bash</span>GNU bash, version 3.2.25<span class="token punctuation">(</span>1<span class="token punctuation">)</span>-release <span class="token punctuation">(</span>i486-pc-linux-gnu<span class="token punctuation">)</span>$ gcc --version <span class="token operator">|</span> <span class="token function">grep</span> gccgcc <span class="token punctuation">(</span>GCC<span class="token punctuation">)</span> 4.1.3 20070929 <span class="token punctuation">(</span>prerelease<span class="token punctuation">)</span> <span class="token punctuation">(</span>Ubuntu 4.1.2-16ubuntu2<span class="token punctuation">)</span>$ <span class="token function">cat</span> /proc/cpuinfo <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"model name"</span>model name      <span class="token keyword">:</span> Intel<span class="token punctuation">(</span>R<span class="token punctuation">)</span> Pentium<span class="token punctuation">(</span>R<span class="token punctuation">)</span> 4 CPU 2.80GHz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h2><p>代码测试有很多方面，例如运行时间、函数调用关系图、代码覆盖度、性能分析（Profiling）、内存访问越界（Segmentation Fault）、缓冲区溢出（Stack Smashing 合法地进行非法的内存访问？所以很危险）、内存泄露（Memory Leak）等。</p><h3 id="测试程序的运行时间-time"><a href="#测试程序的运行时间-time" class="headerlink" title="测试程序的运行时间 time"></a>测试程序的运行时间 time</h3><p>Shell 提供了内置命令 <code>time</code> 用于测试程序的执行时间，默认显示结果包括三部分：实际花费时间（real time）、用户空间花费时间（user time）和内核空间花费时间（kernel time）。</p><pre><code>$ time pstree 2&gt;&amp;1 &gt;/dev/nullreal    0m0.024suser    0m0.008ssys     0m0.004s</code></pre><p><code>time</code> 命令给出了程序本身的运行时间。这个测试原理非常简单，就是在程序运行（通过 <code>system</code> 函数执行）前后记录了系统时间（用 <code>times</code> 函数），然后进行求差就可以。如果程序运行时间很短，运行一次看不到效果，可以考虑采用测试纸片厚度的方法进行测试，类似把很多纸张叠到一起来测试纸张厚度一样，我们可以让程序运行很多次。</p><p>如果程序运行时间太长，执行效率很低，那么得考虑程序内部各个部分的执行情况，从而对代码进行可能的优化。具体可能会考虑到这两点：</p><p>对于 C 语言程序而言，一个比较宏观的层次性的轮廓（profile）是函数调用图、函数内部的条件分支构成的语句块，然后就是具体的语句。把握好这样一个轮廓后，就可以有针对性地去关注程序的各个部分，包括哪些函数、哪些分支、哪些语句最值得关注（执行次数越多越值得优化，术语叫 hotspots）。</p><p>对于 Linux 下的程序而言，程序运行时涉及到的代码会涵盖两个空间，即用户空间和内核空间。由于这两个空间涉及到地址空间的隔离，在测试或调试时，可能涉及到两个空间的工具。前者绝大多数是基于 <code>Gcc</code> 的特定参数和系统的 <code>ptrace</code> 调用，而后者往往实现为内核的补丁，它们在原理上可能类似，但实际操作时后者显然会更麻烦，不过如果你不去 hack 内核，那么往往无须关心后者。</p><h3 id="函数调用关系图-calltree"><a href="#函数调用关系图-calltree" class="headerlink" title="函数调用关系图 calltree"></a>函数调用关系图 calltree</h3><p><code>calltree</code> 可以非常简单方便地反应一个项目的函数调用关系图，虽然诸如 <code>gprof</code> 这样的工具也能做到，不过如果仅仅要得到函数调用图，<code>calltree</code> 应该是更好的选择。如果要产生图形化的输出可以使用它的 <code>-dot</code> 参数。</p><p>这里是一份基本用法演示结果：</p><pre><code>$ calltree -b -np -m *.cmain:|   close|   commitchanges|   |   err|   |   |   fprintf|   |   ferr|   |   ftruncate|   |   lseek|   |   write|   ferr|   getmemorysize|   modifyheaders|   open|   printf|   readelfheader|   |   err|   |   |   fprintf|   |   ferr|   |   read|   readphdrtable|   |   err|   |   |   fprintf|   |   ferr|   |   malloc|   |   read|   truncatezeros|   |   err|   |   |   fprintf|   |   ferr|   |   lseek|   |   read$</code></pre><p>这样一份结果对于“反向工程”应该会很有帮助，它能够呈现一个程序的大体结构，对于阅读和分析源代码来说是一个非常好的选择。虽然 <code>cscope</code> 和 <code>ctags</code> 也能够提供一个函数调用的“即时”（在编辑 Vim 的过程中进行调用）视图（view），但是 <code>calltree</code> 却给了我们一个宏观的视图。</p><p>不过这样一个视图只涉及到用户空间的函数，如果想进一步给出内核空间的宏观视图，那么 <code>strace</code>，<code>KFT</code> 或者 <code>Ftrace</code> 就可以发挥它们的作用。另外，该视图也没有给出库中的函数，如果要跟踪呢？需要 <code>ltrace</code> 工具。</p><p>另外发现 <code>calltree</code> 仅仅给出了一个程序的函数调用视图，而没有告诉我们各个函数的执行次数等情况。如果要关注这些呢？我们有 <code>gprof</code>。</p><h3 id="性能测试工具-gprof-amp-kprof"><a href="#性能测试工具-gprof-amp-kprof" class="headerlink" title="性能测试工具 gprof &amp; kprof"></a>性能测试工具 gprof &amp; kprof</h3><p><code>gprof</code> 是一个命令行的工具，而 KDE 桌面环境下的 <code>kprof</code> 则给出了图形化的输出，这里仅演示前者。</p><p>首先来看一段代码，算 <code>Fibonacci</code> 数列的，</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> fib<span class="token punctuation">;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">&lt;=</span> <span class="token number">42</span><span class="token punctuation">;</span> n<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        fib <span class="token operator">=</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fibonnaci(%d) = %d\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> fib<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> fib<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        fib <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        fib <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        fib <span class="token operator">=</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> fib<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 <code>calltree</code> 看看这段代码的视图，</p><pre><code>$ calltree -b -np -m *.cmain:|   fibonacci|   |   fibonacci ....|   printf</code></pre><p>可以看出程序主要涉及到一个 <code>fibonacci</code> 函数，这个函数递归调用自己。为了能够使用 <code>gprof</code>，需要编译时加上 <code>-pg</code> 选项，让 <code>Gcc</code> 加入相应的调试信息以便 <code>gprof</code> 能够产生函数执行情况的报告。</p><pre><code>$ gcc -pg -o fib fib.c$ lsfib  fib.c</code></pre><p>运行程序并查看执行时间，</p><pre><code>$ time ./fibfibonnaci(0) = 0fibonnaci(1) = 1fibonnaci(2) = 1fibonnaci(3) = 2...fibonnaci(41) = 165580141fibonnaci(42) = 267914296real    1m25.746suser    1m9.952ssys     0m0.072s$ lsfib  fib.c  gmon.out</code></pre><p>上面仅仅选取了部分执行结果，程序运行了 1 分多钟，代码运行以后产生了一个 <code>gmon.out</code> 文件，这个文件可以用于 <code>gprof</code> 产生一个相关的性能报告。</p><pre class="line-numbers language-bash"><code class="language-bash">$ gprof  -b ./fib gmon.out Flat profile:Each sample counts as 0.01 seconds.  %   cumulative   self              self     total            <span class="token function">time</span>   seconds   seconds    calls  ms/call  ms/call  name     96.04     14.31    14.31       43   332.80   332.80  fibonacci  4.59     14.99     0.68                             main                        Call graphgranularity: each sample hit covers 2 byte<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">for</span> 0.07% of 14.99 secondsindex % <span class="token function">time</span>    self  children    called     name                                                 <span class="token operator">&lt;</span>spontaneous<span class="token operator">></span><span class="token punctuation">[</span>1<span class="token punctuation">]</span>    100.0    0.68   14.31                 main <span class="token punctuation">[</span>1<span class="token punctuation">]</span>               14.31    0.00      43/43          fibonacci <span class="token punctuation">[</span>2<span class="token punctuation">]</span>-----------------------------------------------                             2269806252             fibonacci <span class="token punctuation">[</span>2<span class="token punctuation">]</span>               14.31    0.00      43/43          main <span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token punctuation">[</span>2<span class="token punctuation">]</span>     95.4   14.31    0.00      43+2269806252 fibonacci <span class="token punctuation">[</span>2<span class="token punctuation">]</span>                             2269806252             fibonacci <span class="token punctuation">[</span>2<span class="token punctuation">]</span>-----------------------------------------------Index by <span class="token keyword">function</span> name   <span class="token punctuation">[</span>2<span class="token punctuation">]</span> fibonacci               <span class="token punctuation">[</span>1<span class="token punctuation">]</span> main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从这份结果中可观察到程序中每个函数的执行次数等情况，从而找出值得修改的函数。在对某些部分修改之后，可以再次比较程序运行时间，查看优化结果。另外，这份结果还包含一个特别有用的东西，那就是程序的动态函数调用情况，即程序运行过程中实际执行过的函数，这和 <code>calltree</code> 产生的静态调用树有所不同，它能够反应程序在该次执行过程中的函数调用情况。而如果想反应程序运行的某一时刻调用过的函数，可以考虑采用 <code>gdb</code> 的 <code>backtrace</code> 命令。</p><p>类似测试纸片厚度的方法，<code>gprof</code> 也提供了一个统计选项，用于对程序的多次运行结果进行统计。另外，<code>gprof</code> 有一个 KDE 下图形化接口 <code>kprof</code>。</p><p>对于非 KDE 环境，可以使用 <a href="https://code.google.com/p/jrfonseca/wiki/Gprof2Dot">Gprof2Dot</a> 把 <code>gprof</code> 输出转换成图形化结果。</p><p>关于 <code>dot</code> 格式的输出，也可以可以考虑通过 <code>dot</code> 命令把结果转成 <code>jpg</code> 等格式，例如：</p><pre><code>$ dot -Tjpg test.dot -o test.jp</code></pre><p><code>gprof</code> 虽然给出了函数级别的执行情况，但是如果想关心具体哪些条件分支被执行到，哪些语句没有被执行，该怎么办？</p><h3 id="代码覆盖率测试-gcov-amp-ggcov"><a href="#代码覆盖率测试-gcov-amp-ggcov" class="headerlink" title="代码覆盖率测试 gcov &amp; ggcov"></a>代码覆盖率测试 gcov &amp; ggcov</h3><p>如果要使用 <code>gcov</code>，在编译时需要加上这两个选项 <code>-fprofile-arcs -ftest-coverage</code>，这里直接用之前的 <code>fib.c</code> 做演示。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ls</span>fib.c$ gcc -fprofile-arcs -ftest-coverage -o fib fib.c$ <span class="token function">ls</span>fib  fib.c  fib.gcno<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行程序，并通过 <code>gcov</code> 分析代码的覆盖度：</p><pre class="line-numbers language-bash"><code class="language-bash">$ ./fib$ gcov fib.cFile <span class="token string">'fib.c'</span>Lines executed:100.00% of 12fib.c:creating <span class="token string">'fib.c.gcov'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>12 行代码 100% 被执行到，再查看分支情况，</p><pre class="line-numbers language-bash"><code class="language-bash">$ gcov -b fib.cFile <span class="token string">'fib.c'</span>Lines executed:100.00% of 12Branches executed:100.00% of 6Taken at least once:100.00% of 6Calls executed:100.00% of 4fib.c:creating <span class="token string">'fib.c.gcov'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发现所有函数，条件分支和语句都被执行到，说明代码的覆盖率很高，不过<code>gprof</code> 的演示显示代码的覆盖率高并不一定说明代码的性能就好，因为那些被覆盖到的代码可能能够被优化成性能更高的代码。那到底哪些代码值得被优化呢？执行次数最多的，另外，有些分支虽然都覆盖到了，但是这个分支的位置可能并不是理想的，如果一个分支的内容被执行的次数很多，那么把它作为最后一个分支的话就会浪费很多不必要的比较时间。因此，通过覆盖率测试，可以尝试着剔除那些从未执行过的代码或者把那些执行次数较多的分支移动到较早的条件分支里头。通过性能测试，可以找出那些值得优化的函数、分支或者是语句。</p><p>如果使用 <code>-fprofile-arcs -ftest-coverage</code> 参数编译完代码，可以接着用 <code>-fbranch-probabilities</code> 参数对代码进行编译，这样，编译器就可以对根据代码的分支测试情况进行优化。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">wc</span> -c fib16333 fib$ <span class="token function">ls</span> fib.gcda  <span class="token comment" spellcheck="true">#确保fib.gcda已经生成，这个是运行fib后的结果</span>fib.gcda$ gcc -fbranch-probabilities -o fib fib.c <span class="token comment" spellcheck="true">#再次运行</span>$ <span class="token function">wc</span> -c fib6604 fib$ <span class="token function">time</span> ./fib<span class="token punctuation">..</span>.real    0m21.686suser    0m18.477ssys     0m0.008s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见代码量减少了，而且执行效率会有所提高，当然，这个代码效率的提高可能还跟其他因素有关，比如 <code>Gcc</code> 还优化了一些跟平台相关的指令。</p><p>如果想看看代码中各行被执行的情况，可以直接看 <code>fib.c.gcov</code> 文件。这个文件的各列依次表示执行次数、行号和该行的源代码。次数有三种情况，如果一直没有执行，那么用 <code>####</code> 表示；如果该行是注释、函数声明等，用 <code>-</code> 表示；如果是纯粹的代码行，那么用执行次数表示。这样我们就可以直接分析每一行的执行情况。</p><p><code>gcov</code> 也有一个图形化接口 <code>ggcov</code>，是基于 <code>gtk+</code> 的，适合 Gnome 桌面的用户。</p><p>现在都已经关注到代码行了，实际上优化代码的前提是保证代码的正确性，如果代码还有很多 bug，那么先要 debug。不过下面的这些 “bug” 用普通的工具确实不太方便，虽然可能，不过这里还是把它们归结为测试的内容，并且这里刚好承接上 <code>gcov</code> 部分，<code>gcov</code> 能够测试到每一行的代码覆盖情况，而无论是内存访问越界、缓冲区溢出还是内存泄露，实际上是发生在具体的代码行上的。</p><h3 id="内存访问越界-catchsegv-libSegFault-so"><a href="#内存访问越界-catchsegv-libSegFault-so" class="headerlink" title="内存访问越界 catchsegv, libSegFault.so"></a>内存访问越界 catchsegv, libSegFault.so</h3><p>“Segmentation fault” 是很头痛的一个问题，估计“纠缠”过很多人。这里仅仅演示通过 <code>catchsegv</code> 脚本测试段错误的方法，其他方法见后面相关资料。</p><p><code>catchsegv</code> 利用系统动态链接的 <code>PRELOAD</code> 机制（请参考<code>man ld-linux</code>），把库 <code>/lib/libSegFault.so</code> 提前 load 到内存中，然后通过它检查程序运行过程中的段错误。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> test.c<span class="token comment" spellcheck="true">#include &lt;stdio.h></span>int main<span class="token punctuation">(</span>void<span class="token punctuation">)</span><span class="token punctuation">{</span>    char str<span class="token punctuation">[</span>10<span class="token punctuation">]</span><span class="token punctuation">;</span>        sprintf<span class="token punctuation">(</span>str, <span class="token string">"%s"</span>, 111<span class="token punctuation">)</span><span class="token punctuation">;</span>        printf<span class="token punctuation">(</span><span class="token string">"str = %s\n"</span>, str<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> 0<span class="token punctuation">;</span><span class="token punctuation">}</span>$ <span class="token function">make</span> <span class="token function">test</span>$ LD_PRELOAD<span class="token operator">=</span>/lib/libSegFault.so ./test  <span class="token comment" spellcheck="true">#等同于catchsegv ./test</span>*** Segmentation faultRegister dump: EAX: 0000006f   EBX: b7eecff4   ECX: 00000003   EDX: 0000006f ESI: 0000006f   EDI: 0804851c   EBP: bff9a8a4   ESP: bff9a27c EIP: b7e1755b   EFLAGS: 00010206 CS: 0073   DS: 007b   ES: 007b   FS: 0000   GS: 0033   SS: 007b Trap: 0000000e   Error: 00000004   OldMask: 00000000 ESP/signal: bff9a27c   CR2: 0000006fBacktrace:/lib/libSegFault.so<span class="token punctuation">[</span>0xb7f0604f<span class="token punctuation">]</span><span class="token punctuation">[</span>0xffffe420<span class="token punctuation">]</span>/lib/tls/i686/cmov/libc.so.6<span class="token punctuation">(</span>vsprintf+0x8c<span class="token punctuation">)</span><span class="token punctuation">[</span>0xb7e0233c<span class="token punctuation">]</span>/lib/tls/i686/cmov/libc.so.6<span class="token punctuation">(</span>sprintf+0x2e<span class="token punctuation">)</span><span class="token punctuation">[</span>0xb7ded9be<span class="token punctuation">]</span>./test<span class="token punctuation">[</span>0x804842b<span class="token punctuation">]</span>/lib/tls/i686/cmov/libc.so.6<span class="token punctuation">(</span>__libc_start_main+0xe0<span class="token punctuation">)</span><span class="token punctuation">[</span>0xb7dbd050<span class="token punctuation">]</span>./test<span class="token punctuation">[</span>0x8048391<span class="token punctuation">]</span><span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果中可以看出，代码的 <code>sprintf</code> 有问题。经过检查发现它把整数当字符串输出，对于字符串的输出，需要字符串的地址作为参数，而这里的 <code>111</code> 则刚好被解释成了字符串的地址，因此 <code>sprintf</code> 试图访问 <code>111</code> 这个地址，从而发生了非法访问内存的情况，出现 “Segmentation Fault”。</p><h3 id="缓冲区溢出-libsafe-so"><a href="#缓冲区溢出-libsafe-so" class="headerlink" title="缓冲区溢出 libsafe.so"></a>缓冲区溢出 libsafe.so</h3><p>缓冲区溢出是堆栈溢出（Stack Smashing），通常发生在对函数内的局部变量进行赋值操作时，超出了该变量的字节长度而引起对栈内原有数据（比如 eip，ebp 等）的覆盖，从而引发内存访问越界，甚至执行非法代码，导致系统崩溃。这里仅仅演示该资料中提到的一种用于检查缓冲区溢出的方法，它同样采用动态链接的 <code>PRELOAD</code> 机制提前装载一个名叫 <code>libsafe.so</code> 的库。</p><p>下面，演示一个非常简单的，但可能存在缓冲区溢出的代码，并演示 <code>libsafe.so</code> 的用法。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> test.c$ <span class="token function">make</span> <span class="token function">test</span>$ LD_PRELOAD<span class="token operator">=</span>/path/to/libsafe.so ./test ABCDEFGHIJKLMNABCDEFGHIJKLMN*** stack smashing detected ***: ./test terminatedAborted <span class="token punctuation">(</span>core dumped<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果不能够对缓冲区溢出进行有效的处理，可能会存在很多潜在的危险。虽然 <code>libsafe.so</code> 采用函数替换的方法能够进行对这类 Stack Smashing 进行一定的保护，但是无法根本解决问题。</p><h3 id="内存泄露-Memwatch-Valgrind-mtrace"><a href="#内存泄露-Memwatch-Valgrind-mtrace" class="headerlink" title="内存泄露 Memwatch, Valgrind, mtrace"></a>内存泄露 Memwatch, Valgrind, mtrace</h3><p>堆栈通常会被弄在一起叫，不过这两个名词却是指进程的内存映像中的两个不同的部分，栈（Stack）用于函数的参数传递、局部变量的存储等，是系统自动分配和回收的；而堆（heap）则是用户通过 <code>malloc</code> 等方式申请而且需要用户自己通过 <code>free</code> 释放的，如果申请的内存没有释放，那么将导致内存泄露，进而可能导致堆的空间被用尽；而如果已经释放的内存再次被释放（double-free）则也会出现非法操作。如果要真正理解堆和栈的区别，需要理解进程的内存映像，请参考之前的博客。</p><p>这里演示通过 <code>Memwatch</code> 来检测程序中可能存在内存泄露。 使用这个工具的方式很简单，只要把它链接（ld）到可执行文件中去，并在编译时加上两个宏开关<code>-DMEMWATCH -DMW_STDIO</code>。这里演示一个简单的例子。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> test.c <span class="token comment" spellcheck="true">#include &lt;stdlib.h></span><span class="token comment" spellcheck="true">#include &lt;stdio.h></span><span class="token comment" spellcheck="true">#include "memwatch.h"</span>int main<span class="token punctuation">(</span>void<span class="token punctuation">)</span><span class="token punctuation">{</span>    char *ptr1<span class="token punctuation">;</span>    char *ptr2<span class="token punctuation">;</span>    ptr1 <span class="token operator">=</span> malloc<span class="token punctuation">(</span>512<span class="token punctuation">)</span><span class="token punctuation">;</span>    ptr2 <span class="token operator">=</span> malloc<span class="token punctuation">(</span>512<span class="token punctuation">)</span><span class="token punctuation">;</span>    ptr2 <span class="token operator">=</span> ptr1<span class="token punctuation">;</span>    free<span class="token punctuation">(</span>ptr2<span class="token punctuation">)</span><span class="token punctuation">;</span>    free<span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>$ gcc -DMEMWATCH -DMW_STDIO test.c memwatch.c -o <span class="token function">test</span>$ <span class="token function">cat</span> memwatch.log<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span> MEMWATCH 2.71 Copyright <span class="token punctuation">(</span>C<span class="token punctuation">)</span> 1992-1999 Johan Lindh <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>Started at Sat Mar  1 07:34:33 2008Modes: __STDC__ 32-bit mwDWORD<span class="token operator">==</span><span class="token punctuation">(</span>unsigned long<span class="token punctuation">)</span>mwROUNDALLOC<span class="token operator">==</span>4 sizeof<span class="token punctuation">(</span>mwData<span class="token punctuation">)</span><span class="token operator">==</span>32 mwDataSize<span class="token operator">==</span>32double-free: <span class="token operator">&lt;</span>4<span class="token operator">></span> test.c<span class="token punctuation">(</span>15<span class="token punctuation">)</span>, 0x80517e4 was freed from test.c<span class="token punctuation">(</span>14<span class="token punctuation">)</span>Stopped at Sat Mar  1 07:34:33 2008unfreed: <span class="token operator">&lt;</span>2<span class="token operator">></span> test.c<span class="token punctuation">(</span>11<span class="token punctuation">)</span>, 512 bytes at 0x8051a14         <span class="token punctuation">{</span>FE FE FE FE FE FE FE FE FE FE FE FE FE FE FE FE <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">}</span>Memory usage statistics <span class="token punctuation">(</span>global<span class="token punctuation">)</span>: N<span class="token punctuation">)</span>umber of allocations made: 2 L<span class="token punctuation">)</span>argest memory usage      <span class="token keyword">:</span> 1024 T<span class="token punctuation">)</span>otal of all alloc<span class="token punctuation">(</span><span class="token punctuation">)</span> calls: 1024 U<span class="token punctuation">)</span>nfreed bytes totals      <span class="token keyword">:</span> 512<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过测试，可以看到有一个 512 字节的空间没有被释放，而另外 512 字节空间却被连续释放两次（double-free）。<code>Valgrind</code> 和 <code>mtrace</code> 也可以做类似的工作。</p><h2 id="代码调试"><a href="#代码调试" class="headerlink" title="代码调试"></a>代码调试</h2><p>调试的方法很多，调试往往要跟踪代码的运行状态，<code>printf</code> 是最基本的办法，然后呢？静态调试方法有哪些，非交互的呢？非实时的有哪些？实时的呢？用于调试内核的方法有哪些？有哪些可以用来调试汇编代码呢？</p><h3 id="静态调试：printf-gcc-D（打印程序中的变量）"><a href="#静态调试：printf-gcc-D（打印程序中的变量）" class="headerlink" title="静态调试：printf + gcc -D（打印程序中的变量）"></a>静态调试：printf + gcc -D（打印程序中的变量）</h3><p>利用 <code>Gcc</code> 的宏定义开关（<code>-D</code>）和 <code>printf</code> 函数可以跟踪程序中某个位置的状态，这个状态包括当前一些变量和寄存器的值。调试时需要用 <code>-D</code> 开关进行编译，在正式发布程序时则可把 <code>-D</code> 开关去掉。这样做比单纯用 <code>printf</code> 方便很多，它可以避免清理调试代码以及由此带来的代码误删除等问题。</p><pre class="line-numbers language-c"><code class="language-c">$ cat test<span class="token punctuation">.</span>c<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">ifdef</span> DEBUG</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"i = %d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> t<span class="token punctuation">;</span>        __asm__ <span class="token function">__volatile__</span> <span class="token punctuation">(</span><span class="token string">"movl %%ebp, %0;"</span><span class="token punctuation">:</span><span class="token string">"=r"</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token string">"%ebp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ebp = 0x%x\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>        <span class="token function">_exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>$ gcc <span class="token operator">-</span>DDEBUG <span class="token operator">-</span>g <span class="token operator">-</span>o test test<span class="token punctuation">.</span>c$ <span class="token punctuation">.</span><span class="token operator">/</span>testi <span class="token operator">=</span> <span class="token number">0</span>ebp <span class="token operator">=</span> <span class="token number">0xbfb56d98</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面演示了如何跟踪普通变量和寄存器变量的办法。跟踪寄存器变量采用了内联汇编。</p><p>不过，这种方式不够灵活，我们无法“即时”获取程序的执行状态，而 <code>gdb</code> 等交互式调试工具不仅解决了这样的问题，而且通过把调试器拆分成调试服务器和调试客户端适应了嵌入式系统的调试，另外，通过预先设置断点以及断点处需要收集的程序状态信息解决了交互式调试不适应实时调试的问题。</p><h3 id="交互式的调试（动态调试）：gdb（支持本地和远程）-ald（汇编指令级别的调试）"><a href="#交互式的调试（动态调试）：gdb（支持本地和远程）-ald（汇编指令级别的调试）" class="headerlink" title="交互式的调试（动态调试）：gdb（支持本地和远程）/ald（汇编指令级别的调试）"></a>交互式的调试（动态调试）：gdb（支持本地和远程）/ald（汇编指令级别的调试）</h3><h4 id="嵌入式系统调试方法-gdbserver-gdb"><a href="#嵌入式系统调试方法-gdbserver-gdb" class="headerlink" title="嵌入式系统调试方法 gdbserver/gdb"></a>嵌入式系统调试方法 gdbserver/gdb</h4><p>估计大家已经非常熟悉 GDB（Gnu DeBugger）了，所以这里并不介绍常规的 <code>gdb</code> 用法，而是介绍它的服务器／客户（<code>gdbserver/gdb</code>）调试方式。这种方式非常适合嵌入式系统的调试，为什么呢？先来看看这个：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">wc</span> -c /usr/bin/gdbserver 56000 /usr/bin/gdbserver$ <span class="token function">which</span> gdb/usr/bin/gdb$ <span class="token function">wc</span> -c /usr/bin/gdb2557324 /usr/bin/gdb$ <span class="token keyword">echo</span> <span class="token string">"(2557324-56000)/2557324"</span>  <span class="token operator">|</span> <span class="token function">bc</span> -l.97810210986171482377<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>gdb</code> 比 <code>gdbserver</code> 大了将近 97%，如果把整个 <code>gdb</code> 搬到存储空间受限的嵌入式系统中是很不合适的，不过仅仅 5K 左右的 <code>gdbserver</code> 即使在只有 8M Flash 卡的嵌入式系统中也都足够了。所以在嵌入式开发中，我们通常先在本地主机上交叉编译好 <code>gdbserver/gdb</code>。</p><p>如果是初次使用这种方法，可能会遇到麻烦，而麻烦通常发生在交叉编译 <code>gdb</code> 和 <code>gdbserver</code> 时。在编译 <code>gdbserver/gdb</code> 前，需要配置(./configure)两个重要的选项：</p><ul><li><code>--host</code>，指定 gdb/gdbserver 本身的运行平台，</li><li><code>--target</code>，指定 gdb/gdbserver 调试的代码所运行的平台，</li></ul><p>关于运行平台，通过 <code>$MACHTYPE</code> 环境变量就可获得，对于 <code>gdbserver</code>，因为要把它复制到嵌入式目标系统上，并且用它来调试目标平台上的代码，因此需要把 <code>--host</code> 和 <code>--target</code> 都设置成目标平台；而 <code>gdb</code> 因为还是运行在本地主机上，但是需要用它调试目标系统上的代码，所以需要把 <code>--target</code> 设置成目标平台。</p><p>编译完以后就是调试，调试时需要把程序交叉编译好，并把二进制文件复制一份到目标系统上，并在本地需要保留一份源代码文件。调试过程大体如下，首先在目标系统上启动调试服务器：</p><pre><code>$ gdbserver :port /path/to/binary_file...</code></pre><p>然后在本地主机上启动gdb客户端链接到 <code>gdb</code> 调试服务器，（<code>gdbserver_ipaddress</code> 是目标系统的IP地址，如果目标系统不支持网络，那么可以采用串口的方式，具体看手册）</p><pre><code>$ gdb -q(gdb) target remote gdbserver_ipaddress:2345...</code></pre><p>其他调试过程和普通的gdb调试过程类似。</p><h4 id="汇编代码的调试-ald"><a href="#汇编代码的调试-ald" class="headerlink" title="汇编代码的调试 ald"></a>汇编代码的调试 ald</h4><p>用 <code>gdb</code> 调试汇编代码貌似会比较麻烦，不过有人正是因为这个原因而开发了一个专门的汇编代码调试器，名字就叫做 <code>assembly language debugger</code>，简称 <code>ald</code>，你可以从<a href="http://ald.sourceforge.net/">这里</a>下载到。</p><p>下载后，解压编译，我们来调试一个程序看看。</p><p>这里是一段非常简短的汇编代码：</p><pre><code>.global _start _start:        popl %ecx        popl %ecx        popl %ecx        movb $10,12(%ecx)         xorl %edx, %edx        movb $13, %dl        xorl %eax, %eax         movb $4, %al         xorl %ebx, %ebx        int $0x80         xorl %eax, %eax        incl %eax                int $0x80</code></pre><p>汇编、链接、运行：</p><pre><code>$ as -o test.o test.s$ ld -o test test.o$ ./test &quot;Hello World&quot;Hello World</code></pre><p>查看程序的入口地址：</p><pre><code>$ readelf -h test | grep Entry   Entry point address:               0x8048054</code></pre><p>接着用 <code>ald</code> 调试：</p><pre><code>$ ald testald&gt; displayAddress 0x8048054 added to step display listald&gt; neax = 0x00000000 ebx = 0x00000000 ecx = 0x00000001 edx = 0x00000000 esp = 0xBFBFDEB4 ebp = 0x00000000 esi = 0x00000000 edi = 0x00000000 ds  = 0x007B es  = 0x007B fs  = 0x0000 gs  = 0x0000 ss  = 0x007B cs  = 0x0073 eip = 0x08048055 eflags = 0x00200292 Flags: AF SF IF ID Dumping 64 bytes of memory starting at 0x08048054 in hex08048054:  59 59 59 C6 41 0C 0A 31 D2 B2 0D 31 C0 B0 04 31    YYY.A..1...1...108048064:  DB CD 80 31 C0 40 CD 80 00 2E 73 79 6D 74 61 62    ...1.@....symtab08048074:  00 2E 73 74 72 74 61 62 00 2E 73 68 73 74 72 74    ..strtab..shstrt08048084:  61 62 00 2E 74 65 78 74 00 00 00 00 00 00 00 00    ab..text........08048055                      59                   pop ecx</code></pre><p>可见 <code>ald</code> 在启动时就已经运行了被它调试的 <code>test</code> 程序，并且进入了程序的入口 <code>0x8048054</code>，紧接着单步执行时，就执行了程序的第一条指令 <code>popl ecx</code>。</p><p><code>ald</code> 的命令很少，而且跟 <code>gdb</code> 很类似，比如这个几个命令用法和名字都类似 <code>help,next,continue,set args,break,file,quit,disassemble,enable,disable</code> 等。名字不太一样但功能对等的有：<code>examine</code> 对 <code>x</code>, <code>enter</code> 对 <code>set variable {int} 地址=数据</code>。</p><p>需要提到的是：Linux 下的调试器包括上面的 <code>gdb</code> 和 <code>ald</code>，以及 <code>strace</code> 等都用到了 Linux 系统提供的 ptrace() 系统调用，这个调用为用户访问内存映像提供了便利。</p><p>如果确实需要用gdb调试汇编，可以参考：</p><ul><li><a href="http://web.cecs.pdx.edu/~bjorn/CS200/linux_tutorial/">Linux Assembly “Hello World” Tutorial, CS 200</a></li><li><a href="http://lab46.corning-cc.edu/Documentation-Assembly_GDB_Debugger.php">Debugging your Alpha Assembly Programs using GDB</a></li></ul><h3 id="实时调试：gdb-tracepoint"><a href="#实时调试：gdb-tracepoint" class="headerlink" title="实时调试：gdb tracepoint"></a>实时调试：gdb tracepoint</h3><p>对于程序状态受时间影响的程序，用上述普通的设置断点的交互式调试方法并不合适，因为这种方式将由于交互时产生的通信延迟和用户输入命令的时延而完全改变程序的行为。所以 <code>gdb</code> 提出了一种方法以便预先设置断点以及在断点处需要获取的程序状态，从而让调试器自动执行断点处的动作，获取程序的状态，从而避免在断点处出现人机交互产生时延改变程序的行为。</p><p>这种方法叫 <code>tracepoints</code>（对应 <code>breakpoint</code>），它在 <code>gdb</code> 的用户手册里头有详细的说明，见 <a href="https://sourceware.org/gdb/onlinedocs/gdb/Tracepoints.html">Tracepoints</a>。</p><p>在内核中，有实现了相应的支持，叫 <a href="http://lwn.net/Articles/538818/">KGTP</a>。</p><h3 id="调试内核"><a href="#调试内核" class="headerlink" title="调试内核"></a>调试内核</h3><p>虽然这里并不会演示如何去 hack 内核，但是相关的工具还是需要简单提到的，<a href="http://elinux.org/images/c/c6/Tools_slides.pdf">这个资料</a>列出了绝大部分用于内核调试的工具，这些对你 hack 内核应该会有帮助的。</p><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>这部分暂时没有准备足够的素材，有待进一步完善。</p><p>暂且先提到两个比较重要的工具，一个是 Oprofile，另外一个是 Perf。</p><p>实际上呢？“代码测试”部分介绍的很多工具是为代码优化服务的，更多具体的细节请参考后续资料，自己做实验吧。</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> C </tag>
            
            <tag> 编程透视 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程复习</title>
      <link href="posts/49397/"/>
      <url>posts/49397/</url>
      
        <content type="html"><![CDATA[<h2 id="复习大纲"><a href="#复习大纲" class="headerlink" title="复习大纲"></a>复习大纲</h2><h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><ul><li><p>软件：软件是逻辑和物理的系统，由程序、文档、数据和其他相关元素构成。软件是一个过程的抽象表示</p></li><li><p>软件工程：应用系统化、学科化、定量的方法，来开发、运行和维护软件，即将工程应用到软件。以及对以上过程中各种方法的研究</p></li><li><p><code>软件危机</code>：在计算机软件的开发和维护过程中所遇到的一系列严重问题</p><p><code>软件危机的表现</code>：</p><ul><li>开发<strong>成本</strong>和<strong>进度</strong>估计不准，开发<strong>进度难以控制</strong></li><li>用户对“已完成的”软件系统<strong>不满意</strong></li><li>软件<strong>质量和可靠性</strong>差强人意</li><li>软件常常是<strong>不可维护</strong>的</li><li>软件通常没有适当的<strong>文档</strong>资料</li><li>软件<strong>成本</strong>逐年上升</li><li>软件开发<strong>生产率</strong>滞后于硬件和计算机应用普及</li></ul></li><li><p><code>软件工程原则</code></p><ul><li>使用阶段性生命周期计划的管理</li><li>进行连续的验证</li><li>保证严格的产品控制</li><li>使用现代编程工具和工程实践</li><li>保持清晰的责任分配</li><li>用更好更少的人</li><li>保持过程改进</li></ul></li></ul><h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><ul><li><p>软件过程：开发和维护软件及其相关产品所涉及的一系列活动</p></li><li><p>过程模型： 软件过程模型是软件开发全部过程、活动和任务的结构框架</p></li><li><p>瀑布模型</p><ul><li><p>特点</p><p>阶段间具有<strong>顺序性</strong>和<strong>依赖性</strong>。<strong>推迟实现</strong>的观点。每个阶段必须完成规定的文档;  每个阶段结束前完成文档审查,及早改正错误</p></li><li><p>优点</p><ul><li>简单，过程<strong>透明性高</strong>，过程<strong>可管理性高</strong></li><li><strong>推迟实现</strong>，软件实现前必须进行系统分析和设计工作</li><li>以<strong>阶段评审和文档控制</strong>为手段进行质量控制，能够及时发现并纠正软件缺陷，能够达到预期质量要求</li></ul></li><li><p>缺点</p><ul><li>模型<strong>灵活性差</strong>，不适合需求不明确或准确的场合</li><li>模型<strong>风险控制能力弱</strong></li><li>过多的文档<strong>增加了工作量</strong>，当技术具有不确定性情况下完全以文档来评估项目进度时会产生错误的结论</li></ul></li><li><p>适用场合：适用于系统需求明确、技术成熟、工程管理较严格的场合</p></li></ul></li><li><p>演化模型-原型模型</p><ul><li><p>优点</p><ul><li><p>强调<strong>用户参与和决策</strong>，强化了用户与开发人员的沟通</p></li><li><p>可<strong>加快需求的确定</strong>，能够处理需求的不确定性和风险</p></li><li><p><strong>简化</strong>了项目管理、<strong>缩短</strong>了开发时间、<strong>降低</strong>了风险和开发成本</p></li></ul></li><li><p>缺点</p><ul><li><p>不适用于开发大型系统</p></li><li><p>软件<strong>可维护性差</strong></p></li><li><p><strong>用户合作要求高</strong>，如果合作不好，反而会拖延开发进度</p></li></ul></li><li><p>适用情况：客户定义一个总体目标集，但是他们并<strong>不清楚系统的具体输入输出</strong>；或开发者<strong>不确定算法的效率</strong>、软件与操作系统是否兼容以及客户与计算机交互的方式</p></li></ul></li><li><p>增量模型</p><ul><li><p>特点</p><ul><li>在前面增量的基础上开发后面的增量</li><li>每个增量的开发可用瀑布或快速原型模型</li><li>迭代的思路</li></ul></li><li><p>优点</p><ul><li>引入增量包概念，不需要提供完整的需求</li><li>在项目的初始阶段不需要投入太多的人力资源</li><li>增量可以有效地管理技术风险，降低系统失败风险</li><li>有利于增加客户信心，提高系统可靠性、可维护性和稳定性</li></ul></li><li><p>缺点</p><ul><li>增量粒度难以选择</li><li>确定所有的基本业务比较困难</li></ul></li></ul></li><li><p>RAD</p><ul><li><p>缺点</p><ul><li>对大型项目而言，RAD 需要足够的人力资源</li><li>由于时间约束，开发者和客户都要实现承诺，沟通配合不当都会导致失败</li><li>不适合：不能合理模块化的系统、高性能需求并且要调整构件接口的、技术风险很高的系统均不适合</li></ul></li><li><p>适用范围：管理类信息系统开发 </p></li></ul></li><li><p>螺旋模型</p><ul><li><p>适用范围：需求不明确、特别是大型软件系统的开发</p></li><li><p>优点：</p><ul><li>支持用户需求的<strong>动态变化</strong></li><li><strong>原型可看作可执行的需求规格说明书</strong>，易于用户和开发人员共同理解，可作为继续开发的基础，为用户参与关键决策提供了方便</li><li>螺旋模型特别<strong>强调原型的可扩充性和可修改性</strong>，原型的进化贯穿整个软件生存周期，这将有助于目标软件的适应能力</li><li>螺旋模型为项目管理人员及时调整管理决策提供了方便，进而<strong>可降低开发风险</strong></li></ul></li><li><p>缺点</p><ul><li>如果每次迭代的效率不高，致使迭代次数过多，将会<strong>增加成本并推迟提交时间</strong></li><li>使用该模型需要有相当丰富的风险评估经验和专门知识，<strong>要求开发队伍水平较高</strong></li></ul></li></ul></li><li><p>敏捷过程</p><ul><li>缺点 ： 本身不是完整的方法论，是对生命周期过程的补充</li></ul></li></ul><h3 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h3><ul><li><p>需求分析过程：通过对问题及环境的理解与分析，为问题涉及的信息、功能及系统行为建立模型，将用户需求精确化、完全化、最终形成需求规格说明，这一系列的活动，即为需求分析</p></li><li><p>需求分析步骤：需求获取，需求提炼，需求描述（需求规格书），需求验证</p></li></ul><h3 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h3><ul><li><p>软件设计的主要技术：抽象，设计模式，模块化，信息隐藏，功能独立，细化，重构</p></li><li><p>主要活动：软件架构设计（概要设计），软件详细设计</p></li><li><p>模块化：是指解决一个复杂问题时自顶向下逐层分解成若干模块的过程。每个模块完成一个特定的子功能，所有模块按系统结构组合起来，完成整个系统所要求的功能</p></li><li><p>模块化设计标准</p><ul><li>模块化分解性</li><li>模块化组合性</li><li>模块化可理解性</li><li>模块化连续性</li><li>模块化保护</li></ul></li><li><p>模块独立标准：耦合、内聚</p></li></ul><h3 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h3><ul><li><p>基于代码行数的度量方法</p><ul><li><p>优点</p><ul><li>LOC、KLOC和相关度量容易计算</li><li>许多现有的软件估算模型都使用LOC和KLOC作为一项重要输入</li><li>有大量的关于LOC的文献和数据</li></ul></li><li><p>缺点</p><ul><li>LOC依赖于使用的语言，这对短小精悍的程序不利</li><li>不太适用于非过程化语言</li><li>LOC是由在设计完成时候才能计算，估算需要一定程度的细节，而这些细节可能很难获得</li></ul></li></ul></li><li><p>基于功能点的度量方法</p><p>代码行数和功能点之间的关系依赖于编程语言 </p></li></ul><h3 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h3><ul><li>软件测试的定义：1）在某种指定的条件下对操作系统或组件，观察或记录结果，对系统或组件的某些方面进行评估的过程。2）分析软件各项目以检测现有的结果和应有结果之间的差异（即软件缺陷），并评估软件各项目的特征的过程</li><li>软件测试目标<ul><li>确认系统满足其预期的使用和用户的需要。</li><li>确认解决了所需解决的问题（如实现商业规则和使用合适的系统假定）。</li><li>为测试的过程建立责任和可解释性。</li><li>便于及早发现软件和系统的异常。</li><li>及早提供软件和系统的性能评估。</li><li>为管理提供真实信息，以决定在当前状态下发布产品在商业上的风险</li><li>鉴别出程序在功能等方面的异常集聚之处。</li></ul></li></ul><h3 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h3><ul><li><p>单元测试</p><ul><li>概念： 针对软件的设计的最小单位-程序模块，进行正确性检验的测试工作</li><li><code>主要内容</code>：模块接口测试，局部数据结构测试，路径测试，出错处理测试，边界条件测试</li></ul></li><li><p>集成测试</p><ul><li>概念：将软件集成起来后进行测试。又称为子系统测试、组装测试、部件测试</li></ul></li><li><p>系统测试</p><ul><li>概念：系统测试是从用户使用的角度来进行的测试，主要工作是将完成了集成测试的系统放在真实的运行环境下进行测试，用于功能确认和验证</li><li>主要内容：功能性测试、性能测试、压力测试、恢复测试、安全测试</li></ul></li></ul><ul><li>验收测试<ul><li>概念：是软件测试部门对经过项目组内部单元测试、集成测试和系统测试后的软件所进行的测试</li><li>主要内容：根据合同进行的验收测试、用户验收测试、现场测试</li></ul></li></ul><h3 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h3><ul><li>软件维护：软件维护是指由于软件产品出现问题或需要改进而对代码及相关文档的修改，其目的是对现有软件产品进行修改的同时保持其完整性</li><li>必要性：<ul><li>改正错误</li><li>改善设计</li><li>实现软件的改进</li><li>与其他系统进行交互</li><li>为使用不同的硬件、软件、系统的新性能以及通讯设备等而对软件进行改进</li><li>完成遗留程序的移植</li><li>软件退出使用</li></ul></li></ul><h2 id="课程复习"><a href="#课程复习" class="headerlink" title="课程复习"></a>课程复习</h2><blockquote><p><em>斜体</em>表示补充内容，<strong>加粗</strong>表示出过简答，<code>着重</code>表示会挖空，引用部分为例题</p></blockquote><h3 id="分值介绍"><a href="#分值介绍" class="headerlink" title="分值介绍"></a>分值介绍</h3><p>选择题（20道题，每题1分），判断题（10道题，每题1分），填空题（10道题，每题1分），简答题（6道题，每题5分），应用题（3道题，每题10分）</p><h3 id="第一章-1"><a href="#第一章-1" class="headerlink" title="第一章"></a>第一章</h3><p>1.软件的四个层次以及各组成的定义</p><p><code>软件 = 程序 + 数据 + 文档</code></p><ul><li>软件是逻辑和物理的系统，由程序、文档、数据和其他相关元素组成</li><li>程序是按事先设计的<strong>功能</strong>和<strong>性能</strong>要求执行的指令序列</li><li>数据是使程序能正确地处理信息的数据结构</li><li>文档是与程序开发、维护和使用有关的图文资料</li></ul><p>2.<strong>软件的特点</strong></p><ul><li>软件是开发出来的或者说是工程化的，并不是制造出来的</li><li>软件开发环境对产品影响较大</li><li>软件开发的时间和工作量难以估算</li><li>用户往往不能一次性提出完整的需求，因此在经历了许多次修改后软件才能令人满意</li><li>几乎没有客观的标准或措施来评估软件的开发进度</li><li>软件的测试非常困难</li><li>软件不会”耗尽“</li><li>硬件可使用物理模型评价，而软件设计的评价取决于判断和直觉</li><li>硬件和软件的项目管理之间存在很大区别，传统的硬件项目控制方法应用到软件项目中可能会适得其反</li></ul><p>3.软件的双重作用</p><ul><li>一方面软件是一种产品，另一方面软件也是开发其他软件产品的工具，包括如下功能：<ul><li>支持或直接提供系统所需的功能</li><li>控制(如操作系统)其他程序</li><li>改善通信（如网络软件）</li><li>帮助开发其他软件（如软件开发工具）</li></ul></li></ul><p>4.软件工程的目标</p><ul><li>软件工程的目标是在给定的<code>时间</code>和<code>预算</code>内，按照用户的需求，开发易修改、高效、可靠、可维护、适应力强、可移动、可重用的软件</li></ul><p>5.<strong>软件工程的七个原则</strong> </p><ul><li>使用阶段性生命周期计划的管理</li><li>进行连续的验证</li><li>保证严格的产品控制</li><li>使用现代编程工具和工程实践</li><li>保持清晰的责任分配</li><li>用更好、更少的人</li><li>保持过程改进</li></ul><p>6.IEEE软件工程体系的十个方面</p><ul><li><code>需求</code>、<code>设计</code>、<code>结构</code>、<code>测试</code>、<code>维护</code>、<code>配置管理</code>、<code>工程管理</code>、<code>工程过程</code>、<code>质量</code>、<code>工程工具与方法</code></li></ul><p>7.缺乏<code>有力的方法学</code>和<code>有效的开发工具</code>的支持，这往往是产生软件危机的原因之一</p><p>8.软件危机的表现</p><ul><li>项目超出预算</li><li>项目超过计划完成时间</li><li>软件运行效率很低</li><li>软件质量差</li><li>软件通常不符合要求</li><li>项目难以管理并且代码难以维护</li><li>软件不能交付</li></ul><p>9.对软件工程的误解（判断理解即可）</p><ul><li>更多的程序员赶进度可以加快落后的项目进度</li><li>软件项目外包给第三方可以减轻负担</li><li>对目标有一般陈述就足以开始编程，可以今后再补充细节</li><li>一旦变成完毕并成功运行则程序员的工作就结束了</li><li>在程序运行之前无法评估它的质量</li><li>唯一可交付的工作成果是一个成功运行的项目程序</li><li>软件工程会创建大量不必要的文档，并且拖慢了开发进度，软件工程仅仅是文档而已</li></ul><p>10.在软件工程中文档的作用</p><ul><li>提高软件开发过程的能见度</li><li>记录开发过程的有关信息，便于使用与维护</li><li>作为开发人员阶段工作成果和结束标志</li><li>提高开发效率</li><li>提供软件运行、维护、培训的有关资料</li><li>便于用户了解软件功能和性能</li></ul><blockquote><ol><li>软件产品的开发主要是<code>研制</code></li><li>软件是一种<code>逻辑产品</code></li><li>软件工程出现主要是由于<code>软件危机的出现</code></li></ol></blockquote><h3 id="第二章-1"><a href="#第二章-1" class="headerlink" title="第二章"></a>第二章</h3><p>11.<strong>软件过程的模型的定义：</strong></p><ul><li>软件过程模型是从软件项目需求定义直至软件运行维护为止，跨越整个生命周期的系统开发、运行和维护所实施的全部过程、 活动和任务的结构框架 ，软件过程模型能直观表达软件开发总过程，明确规定软件开发要完成的主要活动任务和开发策略。</li></ul><p><strong>12.</strong> 瀑布模型是非迭代的，它的<strong>特点</strong>以及<strong>全部缺点</strong></p><p>特点：</p><ul><li>阶段间具有顺序性和依赖性</li><li>推迟实现</li><li>每个阶段必须完成规定的文档，没有交出合格的文<br>档就是没有完成该阶段的任务</li><li>每个阶段结束前都要对所完成的文档进行评审，以<br>便尽早发现，改正错误  </li></ul><p>缺点：</p><ul><li>不够灵活。在下一阶段开始之前， 当前阶段的结果需要固定下来，这个条件非常严格</li><li>整体性太强。开发计划是面向单一交付日期制定的，在分析阶段出现的任何错误，都只能在软件交付给用户后才能发现。若没有正确理解用户需求，或者在设计、编码和测试阶段需求发生改变，则瀑布模型将导致软件产品的不合格（ 增加了开发的风险）</li><li>严格的文档驱动，比较繁琐</li><li>在软件开发的早期就需要投入大量的成本，使得它难以应对客户需求的变更  </li></ul><p>13.螺旋模型是风险驱动的，它的优缺点是</p><p>优点：</p><ul><li>强调可选方案和限制条件，以支持现有解决方案的重用</li><li>维护和开发一样，是螺旋模型的一个阶段</li><li>评估（预算和进度）更加准确，因为重要问题能被及早发现</li><li>更能应对开发过程中出现的各种变化</li><li>软件工程师可以提前开始项目工作  </li></ul><p>缺点：</p><ul><li>仅适用于内部（一个公司内部） 项目，因为开发过程中要进行风险评估，该模型不能用于合同性的软件开发</li><li>螺旋模型是风险驱动的，因此它适合经验丰富的员工</li><li>使用该模型要求软件开发人员必须具有丰富的风险评估经验和这方面的专门知识，要求开发队伍水平较高</li><li>只适用于大型软件的开发。如果风险分析占用了整个项目成本的主要部分，则使用该模型没有任何意义  </li></ul><p>14.增量模型的特点和优缺点,以及需要注意的问题</p><p>特点：在前面增量的基础上开发后面的增量，增量是可以运行的，在项目开发早期就可以得到程序的运行版本(常考)</p><p>优点：</p><ul><li>增量包概念的引入，以及它不需要提供完整的需求。只要有一个增量包出现，开发就可以进行</li><li>在项目的初始阶段不需要投入太多的人力资源。如果核心产品被用户接受，才会投入更多的人力资源</li><li>即使开发者不能在截止日期前完成项目，项目的核心产品也能交付给用户</li><li>增量可以有效地管理技术风险</li></ul><blockquote><ul><li>能在较短时间内向用户提交一些有用的工作产品，即从第一个增量交付之日起，用户就能做一些有用的工作</li><li>逐步增加产品的功能可以使用户有较充裕的时间学习和适应新产品，从而减少一个全新的软件可能给用户带来的冲击</li><li>虽然在某些增量中可能遇到一些问题，但其他增量将能够成功地交付给客户</li><li>优先级最高的服务首先交付，然后再将其他增量逐次集成进来。因此， 最重要的系统服务将接受最多的测试，这样能够保证系统最重要的部分一般不会遭遇失败  </li></ul></blockquote><p>缺点：</p><ul><li>每个增量必须提供一些系统功能，这使得开发者很难<br>根据客户需求给出大小适合的增量  </li></ul><p>需要注意的问题：</p><ul><li><p>在把每个新的增量集成到现有软件体系结构中时， 必须不破坏原来已经开发出的产品</p></li><li><p>软件体系结构必须是开放的，即向现有产品中加入新构件的过程必须简单、方便</p></li><li><p>因此，采用增量模型比采用瀑布模型和快速原型模型更需要精心的设计  </p></li></ul><p>15.增量模型适用于<code>软件需求不明确</code>，<code>设计方案有一定风险</code>的软件项目</p><p>16.如何选择过程模型的第三点</p><ul><li>软件过程决定了软件产品的质量，不同的项目需要不同的过程模型或模型的组合 </li></ul><p>17.<strong>过程和产品的关系</strong> </p><blockquote><p>工具不是过程模型，软件工程以<strong><code>质量</code></strong>为中心，<strong><code>软件过程、工具、方法</code></strong>为三要素</p></blockquote><p>18.软件生命周期的阶段和每个阶段的提交</p><ul><li>可行性研究和项目开发计划，并提交项目开发计划和可行性研究报告</li><li>需求分析，提交软件需求说明书</li><li>概要设计以及提交概要设计说明书</li><li>详细设计以及提交详细设计说明书</li><li>编码，提交源程序清单</li><li>测试，提交测试报告</li><li>维护，提交维护报告</li></ul><p>19.CMMI五个级别的名字和侧重点</p><table><thead><tr><th align="left">级别</th><th>侧重点</th></tr></thead><tbody><tr><td align="left">1.初始级</td><td>有能力的人和个人英雄主义</td></tr><tr><td align="left">2.可重复级</td><td>基本项目管理</td></tr><tr><td align="left">3.已定义级</td><td>过程标准化</td></tr><tr><td align="left">4.量化管理级</td><td>量化管理</td></tr><tr><td align="left">5.优化级</td><td>持续的过程改进</td></tr></tbody></table><p>20.增量模型和螺旋模型的异同</p><p>同：都是非整体的，迭代式的开发方式</p><p>不同：</p><ul><li>两者迭代的层次不同，增量模型是活动级的迭代，螺旋模型是过程级的迭代</li><li>两者需求分析的时间不同，增量模型往往是选做整体的需求分析，再做编码和逐个的增量包开发；而螺旋模型往往是开发周期内采用瀑布模型</li><li>两者交付软件的时间不同，增量模型是每次增量开发都在上一次增量基础上提交新一部分软件；而螺旋模型每次迭代都提交一个新的完整的软件版本</li><li>两者减小风险的方式不同，增量模型避免使用未成熟的技术和经常的客户反馈降低风险；螺旋模型则直接饮用风险设计和分析</li></ul><blockquote><ol><li>大多数软件系统是不易变化的(指不易改动)的，除非它们在设计时考虑了变化</li><li>目前绝大多数软件都适合快速原型技术</li><li>不属于能力成熟度模型的级别:高效性(确定级≈定义级)</li><li>用户和设计交互最频繁的方法：<code>原型化方法</code></li><li>增量构件的开发可以采用瀑布方式</li><li>瀑布、<code>演化</code>、增量模型是常用的三种软件过程模型</li></ol></blockquote><h3 id="第三章-1"><a href="#第三章-1" class="headerlink" title="第三章"></a>第三章</h3><p>21.软件需求的定义</p><ul><li>软件需求表达了对解决现实世界中某类问题的产品的要求和约束</li></ul><p>22.功能性需求和非功能性需求的定义和区别（理解例子）</p><blockquote><p>设计问题和需求问题，举例非功能性需求5个</p></blockquote><ul><li>功能性需求：描述软件执行时的功能</li><li>非功能性需求：指解决问题时的约束，非功能性需求有时也称为限制或质量需求<ul><li>非功能性需求可进一步被分为性能要求、可维护性要求、安全需求、可靠性要求、可移植性要求、 ……  </li></ul></li></ul><p>23.需求分析的4个步骤和定义</p><ul><li><code>需求获取</code>指的是软件需求的来源以及软件工程师收集这些软件需求的方法</li><li><code>需求分析</code>产生操作规格参数表，指明与其他系统元件的软件接口，确定软件必须遵循的约束</li><li><code>需求定义</code>即编写《 软件需求规格说明书》</li><li><code>需求验证</code>即检查需求的正确性、完整性、非二义性、内部和外部的连贯性  </li></ul><p>24.需求分析的主要任务</p><ul><li>准确地定义未来系统的目标，确定为了满足用户的需求系统需要做什么，并用需求规格说明书规范的形式准确地表达用户需求</li></ul><p>25.结构化分析建立哪三种模型？核心是面向什么？分别对应什么建模？</p><ul><li>核心是<code>数据字典</code></li><li>围绕这个核心，有3种图： <code>数据流图</code>（ DFD，用于<code>功能建模</code>）、<code>实体-关系图</code>（ ER图，用于<code>数据建模</code>）、 <code>状态转换图</code>（ STD，用于<code>行为建模</code>）</li></ul><p>26.数据流图4种符号(只考填空)，数据流图至少有<code>一个输入数据流</code>和<code>一个输出数据流</code></p><p><img src="/posts/49397/1.png" alt="数据流图符号"></p><p>27.结构化分析方法的策略是：<code>自顶向下逐步求精</code></p><p>28.UML图有：<code>部署图</code>、<code>活动图</code>、<code>顺序或时序图</code>、<code>用例图</code>、<code>交互图</code>、<code>类图</code></p><p>29.UML动态模型的描述工具有哪三种图：<code>顺序图</code>、<code>活动图</code>、<code>状态图</code></p><p>30.用例图的绘制（填空加大题），用例图有哪些元素</p><ul><li>元素：<code>用例</code>、<code>参与者</code>、<code>系统</code>、<code>用例之间关系</code></li></ul><p>31.用例图的用途：<code>用于需求的获取，定义和分析</code></p><p>32.<strong>UML中哪些是系统的参与者，可以提出哪些问题来确定？</strong></p><ul><li>谁或者什么为系统提供输入？</li><li>谁或者什么接收系统的输出？</li><li>需要与其他系统连接的接口吗？</li><li>是否存在在预定的时间自动触发的事件？</li><li>谁将维护系统中的信息？  </li></ul><p>33.顺序图的组成元素：<code>类角色（参与者）</code>、<code>对象</code>、<code>激活期</code>、<code>生命线</code>、<code>消息</code></p><p>34.<strong>什么是用例图，它的作用是什么？内容是什么</strong></p><ul><li>用例图是体现一组用例、参与者和它们之间关系的图，从用户角度而不是开发者角度来描述，体现对软件开发产品的需求，分析产品所需的功能和动态行为</li><li>用例图对需求建模是至关重要的，其正确与否直接影响到客户对最终产品的满意度</li><li>内容包括了参与者、用例与拓展的泛化关系</li></ul><h3 id="第四章-1"><a href="#第四章-1" class="headerlink" title="第四章"></a>第四章</h3><p>35.软件设计包含的两类主要活动</p><ul><li>软件架构设计（又称为顶层设计、概要设计）：描述软件的顶层架构和组织，划分不同的组件</li><li>软件详细设计：详细描述各组件以便能够编码实现</li></ul><p>36.创新设计不是软件设计中的步骤，是<code>需求分析</code>中的步骤</p><p>37.模块划分不是越多越好，单个复杂度降低但接口增多，会成为一个U型曲线</p><p>38.简述模块化与软件成本间的关系</p><ul><li>尽管模块分解可以简化要解决的问题，但模块分解并不是越小越好</li><li>当模块数目增加时，每个模块的规模将减小， 开发单个模块的成本确实减少了；但是，随着模块数目增加， 模<br>块之间关系的复杂程度也会增加，设计模块间接口所需要的工作量也将增加 </li></ul><p>39.模块的扇入数大好不好？何时好何时不好？</p><ul><li>模块的扇出数是指模块调用子模块的个数。 如果一个模块的扇出数过大，就意味着该模块过分复杂，需要协调和控制过多的下属模块 。</li><li>一个模块的扇入数越大，则共享该模块的上级模块数目越多， 但如果一个模块的扇入数太大，如超过8，而它又不是公用模块，说明该模块可能具有多个功能， 这时应当对其进一步分析并将其功能分解  </li></ul><p>40.模块独立的两个标准是什么？分别表示什么含义？</p><ul><li><code>内聚性</code>：模块的功能相对强度</li><li><code>耦合性</code>：模块之间的相互依赖程度</li></ul><blockquote><p> 高内聚低耦合表示独立性强的模块</p></blockquote><p>41.内聚和耦合的类型，它们各自的定义和含义，顺序中最高最低是什么？</p><ul><li><p>内聚</p><ul><li>一个模块内部各个元素之间的结合越紧密，其内聚性就越高  </li></ul></li><li><p>耦合</p><ul><li>耦合的强弱取决于模块间接口的复杂程度、进入或访问模块的点，以及通过接口的数据  </li><li>模块之间的连接越紧密，耦合性就越高，而模块的独立性就越弱</li></ul></li><li><p>模块间的耦合</p><p><img src="/posts/49397/3.png" alt="模块间的耦合"></p><ul><li>非直接耦合:两个模块之间没有直接关系，即它们中的任何一个都不依赖于另一个而能独立工作</li><li>数据耦合：两个模块之间仅通过模块参数交换信息，且交换的信息全部为简单数据</li><li>标记耦合：两个模块之间通过参数表传递一个数据结构的一部分（如某一数据结构的子结构）</li><li>控制耦合：如果一个模块传送给另一个模块的参数中包含了控制信息，该控制信息用于控制接收模块中的执行逻辑</li><li>外部耦合 ：指模块间通过软件之外的环境联结（如I/O将模块耦合到特定的设备、格式、通信协议上）</li><li>公共耦合 ：一组模块都访问同一个公共数据环境 </li><li><strong><code>内容耦合 ：若一个模块对另一模块中的内容（包括数据和程序段）进行了直接的引用甚至修改，或通过非正常入口进入到另一模块内部，或一个模块具有多个入口，或两个模块共享一部分代码</code></strong><ul><li>内容耦合是所有耦合关系中耦合程度最高的，会使因模块间的联系过于紧密而对后期的开发和维护工作带来很大的麻烦</li><li>有两种情况：(1)进入另一模块内部 (2)模块代码重迭（只可能出现在汇编语言中）</li></ul></li></ul></li><li><p>模块的内聚</p><p><img src="/posts/49397/4.png" alt="模块的内聚"></p><ul><li><p>巧合内聚 ：一个模块由多个完成不同任务的语句段组成，各语句段之间的联系十分松散或根本没有任何联系 </p></li><li><p>逻辑内聚 ：把几种功能组合在一起，每次调用时，由传递给模块的判定参数来确定该模块应执行哪一种功能 </p></li><li><p>时间内聚 ：一个模块包含了需要在同一时间段中执行的多个任务 </p></li><li><p>过程内聚 ：一个模块中的各个部分相关，并且必须按特定的次序执行  </p></li><li><p>通信内聚 ：一个模块中的各个部分使用同一个输入数据或产生同一个输出数据  </p></li><li><p><strong><code>顺序内聚 ：一个模块中的各个部分都与同一个功能密切相关，并且必须按照先后顺序执行（通常前一个部分的输出数据就是后一个部分的输入数据）</code></strong></p><blockquote><p>顺序内聚的例子：假设有一个按给出的生日计算雇员年龄、退休时间的子程序，如果它是<code>利用所计算的年龄</code>来确定雇员将要<code>退休的时间</code>（即：生日-&gt;年龄-&gt;退休时间），那么它就具有<code>顺序内聚性</code>。而如果它是<code>分别计算</code>年龄和退休时间的，但使用相同生日数据（即： 生日-&gt;年龄， 生日-&gt;退休时间），那它就只具有<code>通讯内聚</code>性  </p></blockquote></li><li><p>功能内聚 ：一个模块中各个组成部分构成一个整体并共同完成一个单一的功能  </p></li></ul></li></ul><p>42.设计是<code>模块化</code>的，换言之软件在逻辑上应划分为多个元素或子系统</p><blockquote><p>结构化的设计思想是把系统设计成相对独立的，功能单一的模块组成的层次结构</p></blockquote><p>43.理解模块调用的四个图（软件结构的宽度和深度，模块扇入数和扇出数）</p><ul><li><p>模块结构最普通的形式就是树状结构和网状结构  </p><p><img src="/posts/49397/5.png" alt="模块的结构"></p><ul><li>树状结构<ul><li>只有一个顶层模块，上层模块调用下层模块， 同一层模块之间互不调用  </li><li>在最底层可能存在一些公共模块，使得整个系统的模块结构不是严格的树状结构，这属于正常情况  </li></ul></li><li>网状结构<ul><li>任意两个模块之间都可以有调用关系，因此无法分出层次。</li><li>由于模块间相互关系的任意性，使得整个系统的结构十分复杂，难以处理</li></ul></li></ul></li><li><p>结构图</p><ul><li><p>模块的调用关系和接口：在结构图中，两个模块之间用单向箭头连接</p></li><li><p>模块间的信息传递：当一个模块调用另一个模块时，调用模块把数据和/或控制信息传送给被调用模块，以使被调用模块能够运行</p><p><img src="/posts/49397/6.png" alt></p></li><li><p>条件调用和循环调用 ：当模块A<code>有条件地</code>调用另一个模块B时，在模块A的箭头尾部标以一个菱形符号；当一个模块A反复地调用模块C和模块D时，在调用箭头尾部则标以一个<code>弧形符号</code></p><p><img src="/posts/49397/7.png" alt></p></li><li><p>结构图的形态特征。在图中，上级模块调用下级模块，它们之间存在主从关系 </p><p><img src="/posts/49397/8.png" alt></p><blockquote><ul><li><p>程序结构的深度：程序结构的层次数称为结构的深度</p></li><li><p>程序结构的宽度：层次结构中同一层模块的最大模块个数称为结构的宽度</p></li><li><p>模块的扇入和扇出：扇出表示一个模块直接调用（或控制）的其它模块数目。扇入则定义为调用（或控制）一个给定模块的模块个数。 多扇出意味着需要控制和协调许多下属模块。而多扇入的模块通常是公用模块  </p></li></ul></blockquote></li></ul></li></ul><p>44.重构的定义</p><ul><li>重构是不改变代码（设计）现有功能的基础上对其内部结构进行修改的过程</li></ul><p>45.用户界面设计由一系列分析开始</p><ul><li>用户特点分析：应用从具体业务和技术资料收集而来的各种信息，定义各种最终用户的属性和配置信息</li><li>用户任务分析：使用结构化设计方法或面向对象方法定义用户任务和相关操作</li><li>应用场景分析：确定用户操作接口的呈现方式约束和布局风格约束  </li></ul><p>46.接口设计包含哪三个方面</p><ul><li>内部接口：软件内部结构模块之间的接口</li><li>外部接口<ul><li>与其他软、硬件之间的接口</li><li>软件与用户之间接口</li></ul></li></ul><p><em>外部接口设计依据环境图进行</em></p><p>47.信息隐藏原则</p><ul><li>模块定义和设计应当保证模块内的信息（包括过程和数据）不可以被不需要这些信息的其他模块访问</li><li>信息隐藏原则有利于提高模块<code>内聚性</code></li><li>有效的模块划分可以通过定义一些相对独立的模块来实现  </li></ul><p>48.<strong>架构风格和模式的简要分类</strong></p><ul><li>数据中心架构</li><li>数据流体系架构</li><li>调用和返回架构</li><li>面向对象架构</li><li>层次架构</li></ul><p>49.结构化程序的定义</p><ul><li>如果一个程序的代码块仅仅通过顺序、选择和循环这三种基本控制结构进行连接，并且每个代码块只有一个入口和一个出口，则称这个程序是结构化的</li></ul><p><img src="/posts/49397/9.png" alt></p><p>50.<strong>程序流程图的主要缺点</strong></p><ul><li>程序流程图从本质上来说不是逐步求精的好工具，它容易使程序员过早地考虑程序的控制流程，而不去考虑程序的全局结构。</li><li>程序流程图中用箭头代表控制流，程序员可以不顾结构程序设计的精神，随意转移控制，而使程序结构过于混乱。</li><li>程序流程图在表示数据结构方面存在不足。  </li></ul><p>51.体系结构的另一种分类</p><ul><li>单主机结构（集中式体系结构）</li><li>分布式结构<ul><li>多处理器体系结构</li><li>客户机/服务器体系结构(C/S、B/S结构)</li><li>分布式对象体系结构</li><li>代理</li></ul></li></ul><p>52.概要设计包含三个层次</p><blockquote><p>概要设计=体系结构设计+接口设计+数据设计</p></blockquote><p><img src="/posts/49397/2.png" alt="软件设计的任务"></p><h3 id="第七章-1"><a href="#第七章-1" class="headerlink" title="第七章"></a>第七章</h3><p>53.软件测试的基本原则</p><ul><li>穷尽测试是不可能的</li><li>测试无法显示潜伏的软件缺陷</li><li>测试活动应尽早进行</li><li>软件缺陷具有群聚性</li><li>注意杀虫剂现象</li><li>应尽量由独立的测试团队进行测试</li></ul><p>54.软件测试的目标</p><ul><li>确认系统满足其预期的使用和用户的需要</li><li>确认解决了所需解决的问题</li><li>为测试的过程建立责任和可解释性</li><li>便于及早发现软件和系统的异常</li><li>及早提供软件和系统的性能的评估</li><li>为管理提供真实信息，以决定在当前状态下发布产品在商业上的风险</li><li>鉴别出程序在功能等方面的异常集聚之处  </li></ul><p>55.什么情况下称为发现软件缺陷</p><ul><li>至少满足下列一个条件，则称发生了一个软件缺陷：<ul><li>软件未实现产品说明书要求的功能</li><li>软件出现了产品说明书指明不能出现的错误</li><li>软件实现了产品说明书未提到的功能</li><li>软件未实现产品说明书虽未明确提及但应该实现的目标</li><li>软件难以理解、不易使用、运行缓慢，或者测试员的角度看，最终用户会认为不好  </li></ul></li></ul><p>56.测试用例的定义由哪三部分组成</p><ul><li>测试用例是<code>测试输入</code>、 <code>执行条件</code>，以及<code>预期结果</code>的集合，是为特定的目的开发的，例如执行特定的程序路径或验证与指定的需求相符合</li></ul><p>57.软件测试的评估准则</p><ul><li>覆盖率</li><li>故障插入(软件缺陷)</li><li>变异分支</li></ul><p>58.覆盖率的定义，100%测试率是可能的吗？为什么？</p><ul><li>给定一个测试需求集合TR和一个测试集合T， 覆盖率可以定义为T满足的测试需求占TR 总数的比例 </li><li>某些测试需求是不能满足的，例如测试需求要求每条语句都得到执行，在某些不能执行到得情况下就是不能满足的。对大多数覆盖标准，检测不可行测试在需求形式上是不可判定的。因此100%测试率在实际中是不现实的。</li></ul><p>59.测试人员的目标是？</p><ul><li>尽早找出软件缺陷，并确保缺陷得已修复</li></ul><p>60.软件白盒、黑盒、灰盒测试的定义</p><ul><li>黑盒测试：指忽略系统或组件的内部机制，仅关注于那些响应所选择的输入及相应执行条件的输出的测试形式，也称为功能性测试</li><li>白盒测试：指考虑系统或组件的内部机制的测试形式，也称为结构性测试。由于通常需要进行白盒测试，因此软件测试工程师也需要具有编程能力</li><li>灰盒测试：兼具黑盒测试和白盒测试的特性，对所有输入数据的各种可能值的排列组合都进行测试，来检查程序是否都能产生正确的输出  </li></ul><p>61.<strong>简述软件测试与调试的同与不同</strong></p><ul><li>两者都包含有处理软件缺陷和查看代码的过程</li><li>测试的目标是发现软件缺陷的存在， 调试的目标是定位与修复缺陷。软件测试员把问题缩减为能够演示软件缺陷的最简化测试用例（或可疑的代码行），进行调试的程序员进而判断到底是什么导致软件缺陷，并设法修复  </li></ul><p>62.软件测试的目标</p><ul><li>确认系统满足其预期的使用和用户的需要</li><li>确认解决了所需解决的问题（如实现商业规则和使用合适的系统假定）</li><li>为测试的过程建立责任和可解释性</li><li>便于及早发现软件和系统的异常</li><li>及早提供软件和系统的性能的评估</li><li>为管理提供真实信息，以决定在当前状态下发布产品在商业上的风险</li><li>鉴别出程序在功能等方面的异常集聚之处  </li></ul><p>63.不同覆盖准则设计测试用例</p><ul><li>语句覆盖</li><li>分支覆盖</li><li>条件覆盖</li><li><em>判定—条件覆盖</em></li><li>条件组合覆盖</li><li>路径覆盖</li></ul><p>64.不同覆盖准则之间的强弱关系</p><ul><li>语句覆盖是最弱的逻辑覆盖</li><li>分支覆盖具有比语句覆盖更强的测试能力，但仍是弱的逻辑覆盖 </li><li>条件覆盖不一定包含分支覆盖，满足条件覆盖不一定满足分支覆盖 </li><li><em>判定—条件覆盖</em>即既满足条件覆盖，又满足判定覆盖</li><li>条件组合覆盖满足分支覆盖、条件覆盖准则，但可能有的路径会遗漏掉  </li><li>路径覆盖覆盖程序中所有可能的路径  </li></ul><p>65.分支覆盖又叫判定覆盖</p><p>66.<strong>基本路径测试的控制流图与环路复杂度</strong></p><ul><li>控制流图仅描述程序内部的控制流程，完全不表现对数据的具体操作，以及分支和循环的具体条件 </li></ul><p><img src="/posts/49397/10.png" alt></p><p><img src="/posts/49397/11.png" alt></p><ul><li><p>边和节点围成的封闭域叫做区域，当对区域计数时，图形外的区域也应记为一个区域 </p></li><li><p>程序的环形复杂度 :对于一个程序的控制流图G（其中的决策节点均是基本判定），程序的环形复杂度V(G)即是控制流图中的区域数  </p></li><li><p>也可以用以下公式计算：</p><blockquote><p>V(G)＝ e－ n＋ 2，其中 e是图G中边的数目， n是图G中节点的数目 </p></blockquote></li><li><p>可以证明：</p><blockquote><p>V(G)＝ P＋ 1,其中， P是图G中的基本判定的数目  </p></blockquote></li><li><p>McCabe提出的基线方法和反转接点</p></li></ul><p>67.基本路径集合不唯一但数目唯一</p><p>68.黑盒测试的3种方法和定义(补充的错误猜测法和因果图法)</p><ul><li>等价类划分方法：把所有可能的输入（被测程序的输入域） 划分成若干互不相交的部分（子集），然后从每一个部分中选取少数具有代表性的数据（通常是1个） 作为测试用例 </li><li>边界值分析方法：对输入或输出的边界值进行测试的一种黑盒测试方法。通常边界值分析法是作为对等价类划分法的补充，这种情况下，其测试用例来自等价类的边界</li><li>状态测试：通常，访问所有的状态是可以实现的，但除了极少数简单程序外， 不可能以走完所有分支的方式来达到每种状态，即必须选择重要的内容进行测试 </li><li>错误猜测法：在测试程序时，人们可以根据经验或直觉推测程序中可能存在的各种错误，从而有针对性地编写检查这些错误的测试用例的方法</li><li>因果图法：用图解的方法表示输入的各种组合关系，写出判定表，从而设计相应的测试用例</li></ul><p>69.<strong>错误猜测法和因果图法</strong></p><ul><li>考虑为失效性测试设计用例，主要以已知的缺陷空间为依据设计测试用例。设计测试用例的目的是证明已知的缺陷在软件中都不存在</li></ul><p>70.静态测试的目的和基本思想</p><ul><li>静态测试的范围很广，软件开发项目中的代码、所有的文档以及项目外有价值的文档都可以通过人工方式审查。其目的是从已有的规格说明、已定义的标准以及项目的计划中发现缺陷和偏差。这些检查的结果可以用于优化开发过程</li><li>静态测试的基本思想是缺陷的预防，即尽可能早地在缺陷和偏差对将来开发过程产生影响之前发现并修改它们，否则会导致代价高昂的返工</li></ul><p>71.<strong>通用评审过程的步骤</strong></p><p>评审过程就是执行静态分析的过程:</p><ul><li>计划</li><li>概述</li><li>准备</li><li>评审会议</li><li>返工</li><li>跟踪  </li></ul><p>72.正式评审和非正式评审的3种类型</p><ul><li>同事审查(非正式)</li><li>走查(非正式)</li><li>审查 (正式)</li></ul><h3 id="第八章-1"><a href="#第八章-1" class="headerlink" title="第八章"></a>第八章</h3><p>73.V模型中四个级别的测试的主要目的或测试依据</p><ul><li>单元测试的主要目的是验证软件模块是否按详细设计的规格说明正确运行</li><li>集成测试的主要目的是检查多个模块间是否按概要设计说明的方式协同工作</li><li>系统测试的主要目的是验证整个系统是否满足需求规格说明</li><li>验收测试从用户的角度检查系统是否满足合同中定义的需求，以及以确认产品是否能符合业务上的需要  </li></ul><p>74.系统测试的定义</p><ul><li>从用户使用的角度来进行的测试，主要工作是将完成了集成测试的软件放在真实的运行环境下进行测试，用于功能确认和验证  </li></ul><p>75.验收测试中测试用例如何得到？验收测试的关注点？是否需要客户参与？</p><ul><li>测试用例采用项目组的系统测试用例子集，或者由验收测试人员自行决定测试内容 </li><li>关注点是客户的观点和判断，如果软件是为指定客户开发的，那么验收测试就更为重要。验收测试通常情况下需要客户的参与，甚至客户可以完全负责验收测试 </li><li>验收测试在多个级别中进行</li></ul><p>76.在改进的V模型中，测试要提前，一旦有了<code>文档提供</code>就可以<code>开始测试计划，确定测试条件和编写测试用例等测试</code></p><p>77.回归测试</p><ul><li>原因：在软件测试的各个阶段，在修正发现的软件缺陷或增加新功能时， 变化的部分必须进行再测试。此外，对软件进行修改还可能会导致引入新的软件缺陷以及其他问题。为解决这些问题，需要进行回归测试</li><li>回归测试是指有选择地重新测试系统或其组件，以验证对软件的修改没有导致不希望出现的影响，以及系统或组件仍然符合其指定的需求  </li><li>回归测试可以在所有的测试级别执行，并应用于功能和非功能测试中</li><li>回归测试应该尽量采用自动化测试  </li></ul><p>78.4级别测试分别采用白盒测试还是黑盒测试</p><ul><li>单元测试：主要采用白盒测试方法设计测试用例，但在白盒测试方法之前应该先依据详细设计说明书建立黑盒<br>测试用例进行测试，使之对任何合理的输入和不合理的输入，都能鉴别和响应  </li><li>集成测试：既有白盒测试的成分又有黑盒测试的成分，也称为灰盒测试</li><li>系统测试：基本上使用黑盒测试方法</li><li>验收测试：黑盒测试方法</li></ul><p>79.驱动模块和桩模块的含义</p><ul><li>驱动模块用来调用被测模块，使被测的模块得到执行。在绝大多数情况下， 驱动模块执行的任务是接收测试数据，把数据传送给待测模块，然后从待测模块获取返回的数据，并输出测试的结果。通常， 测试用例是在驱动模块中实现的 </li><li>桩模块也叫做存根模块， 用以替代被测模块所调用的那些模块。桩模块的接口与其替代的模块完全一致， 但其功能非常简单，且不包含错误。桩模块的作用首先是隔离缺陷，在用桩模块替代被测模块调用的模块后，如果测试中发现问题，则问题肯定出在被测模块的内部。其次， 可以用桩模块来模拟一些被调用模块难以出现的情况（例如，数量很大的网络连接）， 降低测试的费用  </li></ul><p>80.被测模块需要驱动模块时，测试常在<code>驱动模块</code>中实现</p><p>81.<strong>单元测试的主要内容</strong></p><ul><li>对模块接口的测试保证在测试时进出程序单元的数据流是正确的</li><li>对局部数据结构的测试保证临时存储的数据在算法执行的整个过程中都能维持其完整性</li><li>对边界条件的测试保证模块在极限或严格的情形下仍然能够正确执行</li><li>控制结构中的所有独立路径（基本路径）原则上都应覆盖，以保证在一个模块中的所有语句都能至少执行一次</li><li>要对所有出错处理的路径进行测试 </li></ul><p>82.为什么单元测试的依据不是代码？</p><ul><li>单元测试的主要依据是详细设计，而不是针对代码的测试。因为未测代码可能包含错误和缺陷，如果依照其测试，则可能无法发现一些错误  </li></ul><p>83.集成测试有哪3种集成方法？</p><ul><li>自顶向下的集成方法</li><li>自底向上的集成方法</li><li>Smoke方法 </li></ul><p>84.什么是自顶向下/自底向上的集成测试，它们的优缺点是什么？</p><ul><li><p>自顶向下的集成方法：从顶层模块（主控模块）开始，沿着软件的控制层次向下移动，逐渐把各个模块结合起来，这种集成方式中，每层程序调用的下一层程序单元都要打桩，整个集成可以按深度或宽度优先进行，采用前者可以快速验证一个子系统的完整性</p><ul><li><p>优点：</p><ul><li><p>可以较早地验证主程序的功能</p></li><li><p>缺陷隔离较好</p></li><li><p>可以较早地验证主要的控制和判断点</p></li></ul></li><li><p>缺点：</p><ul><li>桩的开发量较大 </li></ul></li></ul></li><li><p>自底向上的集成方法：是从软件结构最底层的模块开始，按照接口依赖关系逐层向上集成以进行测试。由于是从最底层开始集成，对于一个给定层次的模块，它的子模块（包括子模块的所有下属模块）已经集成并测试完成，所以不再需要使用桩模块进行辅助测试，在模块的测试过程中需要从子模块得到的信息可以直接运行子模块得到。 但需要为每个模块编写驱动模块</p><ul><li><p>优点：</p><ul><li>每个模块调用的各底层模块都已经测试，不需要桩模块</li></ul></li><li><p>缺点：</p><ul><li>每个模块都必须编写驱动模块</li><li>缺陷隔离和定位不如自顶向下的集成方法 </li></ul></li></ul></li></ul><p>85.自顶向下结合的渐增式测试法在组合模块时有两种组合策略：<code>深度优先</code>,<code>广度优先</code></p><p>86.系统测试的五种方法</p><ul><li>功能性测试</li><li>性能测试</li><li>压力测试</li><li>恢复测试</li><li>安全测试  </li></ul><p>87.压力测试为<code>比平常限度约高一个数量级输入</code>，用来检查软件系统对异常情况的承受能力压力测试强迫系统在异常情况（如异常数量、异常频率、异常资源配置等）下运行 ，压力测试经常与<code>性能测试</code>一起进行  </p><p>88.现场测试包含α测试和β测试，各自的定义是什么？</p><ul><li>α测试是用户在开发者的场所来进行的，软件在开发者对用户的指导下进行测试， 开发者负责记录错误和使用中出现的问题，α测试人员是除产品开发人员外首先见到产品的人， 他们提出的功能和修改意见是特别有价值的 </li><li>β测试是在一个开发者不能控制的真实环境中进行的软件现场应用。与α测试不同， 开发者不在测试现场。用户记录下所有在测试中遇到的问题，并定期把这些问题报告给开发者，在接到β测试的问题报告之后，开发者对系统进行最后的修改，然后就开始准备向所有的用户发布最终的软件产品  </li></ul><blockquote><ol><li>单元测试主要针对模块的几个基本特例进行测试，该阶段不能完成的测试是<code>系统功能</code>测试</li><li><code>接口</code>不属于系统测试的主要内容</li><li>系统测试是把软件、硬件和环境连在一起的全面测试</li><li>单元测试时对所有出错处理的路径都要进行测试</li></ol></blockquote><p>89.生产力度量包括<code>基于功能点的度量</code>和<code>代码行数</code>的度量</p><h3 id="第五章-1"><a href="#第五章-1" class="headerlink" title="第五章"></a>第五章</h3><p>90.FP（功能点方法）的计算</p><ul><li><p>根据软件的每类功能的各级复杂性功能点的数量，可以计算出该软件的未调节功能点 total_counts  </p></li><li><p>任何软件都会有其自身特性，因此前面计算出的未调节功能点（ total_counts） 还需要进行调节，即乘以一个复杂度调节因子CAF，最终得到交付功能点，教材上简称为功能点FP </p><blockquote><p>FP= total_counts× (0.65+0.01× ∑Fi)  </p></blockquote></li></ul><p>91.LOC或FP的相关计算（记得带上单位）</p><ul><li><p>生产率是指平均每个人月生成出多大规模的软件（生产出多少代码行数LOC或功能点FP），其单位是LOC(或KLOC)/人月、 FP/人月</p></li><li><p>直接测量——基于代码行数的度量即：基于代码行数（ LOC）进行度量。生产率即每人月的代码行数： <code>总代码行数(LOC或KLOC)/总人月</code>, 此外， 基于LOC还可以得到其他一些度量，如：</p><ul><li><p>每千代码行的错误数： <code>总错误数/总KLOC</code></p></li><li><p>每千代码行的缺陷数： <code>总缺陷数/总KLOC</code></p></li><li><p>每千代码行的文档页数： <code>总文档页数/总KLO</code></p></li></ul></li><li><p>间接测量——基于功能点的度量即：基于功能点（ FP）进行度量。生产率即每人月的FP数： 总FP数/总人月此外， 基于FP还可以得到其他一些度量，如：</p><ul><li>每FP的错误数： <code>总错误数/总FP数</code></li><li>每FP的缺陷数： <code>总缺陷数/总FP数</code></li><li>每FP的文档页数： <code>总文档页数/总FP数</code></li></ul></li></ul><p>92.LOC(代码行数)估计软件生产率的优缺点</p><ul><li>优点<ul><li>LOC、 KLOC和相关度量容易计算</li><li>许多现有的软件估算模型都使用LOC和KLOC作为一项重要输入</li><li>有大量的关于LOC的参考文献和数据  </li></ul></li><li>缺点<ul><li>LOC依赖于使用的语言，这对短小精悍的程序不利</li><li>不太适用于非过程化语言</li><li>LOC只有在设计完成时候才能计算，同时估算需要一定程度的细节，而这些细节可能很难获得。项目计划人员很难在分析和设计完成之前估算LOC  </li></ul></li></ul><p>93.FP与LOC的换算</p><p><img src="/posts/49397/12.png" alt></p><p>94.不应当苛刻的关注生产率度量，工程师可能会通过产生较大的LOC和FP来追求高生产率，而降低产品的质量。“低生产率的”程序员写的代码可能会更加可靠，容易理解和维护  </p><p>95.COCOMO模型是成本估算模型</p><h3 id="第九章-1"><a href="#第九章-1" class="headerlink" title="第九章"></a>第九章</h3><p>96.<strong>ISO-IEC 12207-2008</strong>中对软件维护的定义</p><ul><li>软件维护是指由于软件产品出现问题或需要改进而对代码及相关文档的修改，其目的是对现有软件产品进行修改的同时保持其完整性</li></ul><p>97.软件维护耗时最多的部分<code>测试用例</code></p><p>98.软件维护中4种维护及每种百分比</p><ul><li>纠错性维护(21%)</li><li>适应性维护(25%)</li><li>完善性维护(50%)</li><li>预防性维护(4%) </li></ul><p>99.各类维护占维护工作量的比例  </p><ul><li>在维护阶段的最初一段时期，纠错性维护的工作量较大。随着错误发现率逐渐降低，并趋于稳定，软件进入正常使用期。然而，由于新需求的提出， 适应性维护和完善性维护的工作量逐步增加。在整个软件维护阶段花费的全部工作量中， 完善性维护占了几乎一半的工作量  </li></ul><p>100.软件维护的必要性</p><ul><li>软件维护能够改正错误</li><li>软件维护能够改善设计</li><li>软件维护能够实现软件的改进</li><li>软件维护能够与其他系统进行交互</li><li>软件维护能够为使用不同的硬件、软件、系统的新性能以及通讯设备等而对软件进行改进</li><li>软件维护能够完成遗留程序的移植</li><li>软件退出使用  </li></ul><p>101.软件维护的困难性</p><ul><li><strong>配置管理工作不到位</strong> ，软件系统的改动没有被标记，所要维护的软件无文档、文档不完整或者有些文档没有及时更新，导致维护过程中参考的是过时的文档</li><li><strong>人员变动</strong>造成的影响</li><li><strong>维护人员大多不是编写代码的人</strong>，所以必须先理解软件，然后才能进行维护。但是许多软件的<strong>可读性差，导致理解困难</strong></li><li>往往是<strong>在任务急、时间紧的情况下处理维护请求</strong>的，这就要求维护人员必须在短时间内发现并解决问题  </li></ul><p>102.IEEE对可维护性的定义</p><ul><li>是指通过一定的手段，使软件可以被维护、改进、改动或修正，以满足特定的需求的方便程度  </li></ul><p>103.估算维护工作量的模型，理解4个参数与复杂程度</p><blockquote><p>维护工作量的一个模型： M=P+K·exp(c-d)  </p></blockquote><ul><li>维护分成生产性活动（如分析评价、修改设计和编写程序代码等）和非生产性活动（如理解程序代码的功能，解释数据结构、接口特点和性能限度等）</li><li>M是维护用的总工作量， P是生产性工作量， K是经验常数， c是复杂程度（非结构化设计和缺少文档都会增加软件的复杂程度）， d是维护人员对软件的熟悉程度  </li></ul><p>104.软件维护技术</p><ul><li>程序的理解</li><li>软件再工程</li><li>软件逆向工程  </li></ul><p>105.软件再工程的定义</p><ul><li>指对现有软件进行仔细审查和改造，对其进行重新构造，使之成为一个新的形式，同时包括随之产生的对新形式的实现  </li></ul><p>106.理解逆向工程的含义和主要三方面内容与过程(了解)</p><ul><li><p>含义：分析目标系统，识别系统的构件及其交互关系，并且通过高层抽象或其他形式来展现目标系统的过程 </p></li><li><p>主要内容：</p><ul><li>① 数据的逆向工程</li><li>② 处理的逆向工程</li><li>③ 用户界面的逆向工程过程：</li></ul></li><li><p>过程：</p><p><img src="/posts/49397/14.png" alt></p></li></ul><h3 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h3><p>107.P-CMM是什么？五个级别分别是？</p><ul><li>人员资源管理能力成熟度模型(People Capability Maturity Model)</li><li>五个级别<ul><li>初始级</li><li>管理级</li><li>定义级</li><li>可预测级</li><li>优化级</li></ul></li></ul><p>108.软件项目管理的四要素，其中最重要的是？</p><ul><li>人员(最重要)</li><li>产品</li><li>过程</li><li>项目</li></ul><p>109.3种团队组织形式，名字与缩写分别是？</p><ul><li>民主分权制(DD)</li><li>有控制的分权制(CD)</li><li>有控制的集中制(CC)</li></ul><p>110.沟通是横向的还是垂直的？</p><ul><li>民主分权制(DD)中对问题的解决方法都由小组达成共识，团队成员之间进行横向通信</li><li>有控制的分权制(CD)中小组和个人之间横向沟通，垂直控制层次的沟通都会发生</li><li>有控制的集中制(CC)中领导者和团队成员之间的沟通是垂直的</li></ul><p>111.团队有没有领导者？有的话是一个还是多个？</p><ul><li>民主分权制(DD)中团队没有永久的领导者，任务协调员的任期为短工期，协调不同的任务时由不同的协调员取代</li><li>有控制的分权制(CD)中有领导协调具体任务，也有负责子任务的次要领导人</li><li>有控制的集中制(CC)中团队内部问题的解决和协调是由一个团队的领导者来管理的</li></ul><p>112.虚拟团队的定义以及优缺点?</p><ul><li>定义：跨越时间、空间和组织界限，运用通信技术加强连接的队伍</li><li>优点：提高生产力，扩大市场机遇，进行知识转移</li><li>缺点：沟通不足，领导不力，团队成员不称职</li></ul><p>113.对一个团队来说，<code>目标</code>是最重要的方面</p><p>114.在策划一个项目以前，应当建立产品的目标和范围，应考虑其他解决办法，以及约束技术和管理。如果没有这些信息，它无法精确地界定费用、进行有效风险评估、适当地分解项目任务、制定管理的项目进度表或提供有意义的进度估计</p><p>115.软件项目管理的第一个活动<code>确定软件范围</code></p><p>116.项目估算方法</p><ul><li>分解技术</li><li>经验模型</li></ul><p>117.项目计划</p><ul><li>软件项目计划的目的是使项目经理能够对资源、成本及时间进行合理的估算，一般是在项目开始时进行，随着项目进展定期更新。此外估算应该尝试确定最好和最坏的情况，使项目的成果是有界的</li><li>要注意软件项目计划不是一个静态的文件，也就是说随着项目的进行，项目组反复修正计划、更新风险估计和有关信息</li></ul><p>118.软件开发者和客户必须一起定义产品的目标和范围。在许多情况下，这个活动开始时作为系统工程或业务过程的一部分，接下来作为软件需求分析的第一步。</p><p>119.问题分解是用来干什么的</p><ul><li>将一个复杂的问题划分成更易于管理的小问题，有助于更精确地定义软件范围，从而指定更准确的项目计划</li></ul><p>120.哪种团队组织形式会带来更高的满意度？模块化程度高或低分别对应哪一个模型？</p><ul><li>民主分权制(DD)队伍结构会带来比较高的士气和工作满意度</li><li>民主分权制(DD)队伍结构最好应用于模块化程度相对较低的项目，因为它需要较高的通信量</li><li>在高度模块化的任务中，有控制的分权制(CD)和有控制的集中制(CC)队伍结构更加合适</li></ul><blockquote><ol><li>软件质量保证涵盖了整个软件开发过程</li><li>问题分解不适用于对软件的详细设计</li></ol></blockquote><h3 id="大概率出的问题"><a href="#大概率出的问题" class="headerlink" title="大概率出的问题"></a>大概率出的问题</h3><p><strong>软件危机定义和表现</strong></p><p>原因:</p><blockquote><p>缺乏<code>有力的方法学</code>和<code>有效的开发工具</code>的支持，这往往是产生软件危机的原因之一</p></blockquote><ul><li>项目超出预算</li><li>项目超过计划完成时间</li><li>软件运行效率很低</li><li>软件质量差</li><li>软件通常不符合要求</li><li>项目难以管理并且代码难以维护</li><li>软件不能交付</li></ul><p><strong>软件工程的七个原则</strong></p><ul><li>使用阶段性生命周期计划的管理</li><li>进行连续的验证</li><li>保证严格的产品控制</li><li>使用现代编程工具和工程实践</li><li>保持清晰的责任分配</li><li>用更好、更少的人</li><li>保持过程改进</li></ul><p>软件的特点</p><ul><li>软件是开发出来的或者说是工程化的，并不是制造出来的</li><li>软件开发环境对产品影响较大</li><li>软件开发的时间和工作量难以估算</li><li>用户往往不能一次性提出完整的需求，因此在经历了许多次修改后软件才能令人满意</li><li>几乎没有客观的标准或措施来评估软件的开发进度</li><li>软件的测试非常困难</li><li>软件不会”耗尽“</li><li>硬件可使用物理模型评价，而软件设计的评价取决于判断和直觉</li><li>硬件和软件的项目管理之间存在很大区别，传统的硬件项目控制方法应用到软件项目中可能会适得其反</li></ul><p><strong>软件设计的主要技术</strong></p><ul><li>软件架构设计（又称为顶层设计、概要设计）：描述软件的顶层架构和组织，划分不同的组件</li><li>软件详细设计：详细描述各组件以便能够编码实现</li></ul><p>软件过程模型的定义：</p><ul><li>软件过程模型是从软件项目需求定义直至软件运行维护为止，跨越整个生命周期的系统开发、运行和维护所实施的全部过程、 活动和任务的结构框架 ，软件过程模型能直观表达软件开发总过程，明确规定软件开发要完成的主要活动任务和开发策略。</li></ul><p>增量模型和螺旋模型的异同</p><ul><li>同：都是非整体的，迭代式的开发方式</li><li>不同：<ul><li>两者迭代的层次不同，增量模型是活动级的迭代，螺旋模型是过程级的迭代</li><li>两者需求分析的时间不同，增量模型往往是选做整体的需求分析，再做编码和逐个的增量包开发；而螺旋模型往往是开发周期内采用瀑布模型</li><li>两者交付软件的时间不同，增量模型是每次增量开发都在上一次增量基础上提交新一部分软件；而螺旋模型每次迭代都提交一个新的完整的软件版本</li><li>两者减小风险的方式不同，增量模型避免使用未成熟的技术和经常的客户反馈降低风险；螺旋模型则直接饮用风险设计和分析</li></ul></li></ul><p>需求分析过程与步骤</p><ul><li><code>需求获取</code>指的是软件需求的来源以及软件工程师收集这些软件需求的方法</li><li><code>需求分析</code>产生操作规格参数表，指明与其他系统元件的软件接口，确定软件必须遵循的约束</li><li><code>需求定义</code>即编写《 软件需求规格说明书》</li><li><code>需求验证</code>即检查需求的正确性、完整性、非二义性、内部和外部的连贯性</li></ul><p>结构化分析建立哪三种模型？核心是面向什么？分别对应什么建模？</p><ul><li>核心是<code>数据字典</code></li><li>围绕这个核心，有3种图： <code>数据流图</code>（ DFD，用于<code>功能建模</code>）、<code>实体-关系图</code>（ ER图，用于<code>数据建模</code>）、 <code>状态转换图</code>（ STD，用于<code>行为建模</code>）</li></ul><p>什么是用例图，它的作用是什么？内容是什么</p><ul><li>用例图是体现一组用例、参与者和它们之间关系的图，从用户角度而不是开发者角度来描述，体现对软件开发产品的需求，分析产品所需的功能和动态行为</li><li>用例图对需求建模是至关重要的，其正确与否直接影响到客户对最终产品的满意度</li><li>内容包括了参与者、用例与拓展的泛化关系</li></ul><p>UML中哪些是系统的参与者，可以提出哪些问题来确定？</p><ul><li>谁或者什么为系统提供输入？</li><li>谁或者什么接收系统的输出？</li><li>需要与其他系统连接的接口吗？</li><li>是否存在在预定的时间自动触发的事件？</li><li>谁将维护系统中的信息？</li></ul><p><strong>模块的扇入数大好不好？何时好何时不好？</strong></p><ul><li>模块的扇出数是指模块调用子模块的个数。 如果一个模块的扇出数过大，就意味着该模块过分复杂，需要协调和控制过多的下属模块 。</li><li>一个模块的扇入数越大，则共享该模块的上级模块数目越多， 但如果一个模块的扇入数太大，如超过8，而它又不是公用模块，说明该模块可能具有多个功能， 这时应当对其进一步分析并将其功能分解</li></ul><p><strong>模块化模块独立的标准</strong></p><ul><li><code>内聚性</code>：模块的功能相对强度</li><li><code>耦合性</code>：模块之间的相互依赖程度</li></ul><p><strong>模块数量的确定</strong></p><ul><li>尽管模块分解可以简化要解决的问题，但模块分解并不是越小越好</li><li>当模块数目增加时，每个模块的规模将减小， 开发单个模块的成本确实减少了；但是，随着模块数目增加， 模<br>块之间关系的复杂程度也会增加，设计模块间接口所需要的工作量也将增加</li></ul><p><strong>基于功能点和代码行数的相关指标计算，优缺点</strong></p><ul><li>优点<ul><li>LOC、 KLOC和相关度量容易计算</li><li>许多现有的软件估算模型都使用LOC和KLOC作为一项重要输入</li><li>有大量的关于LOC的参考文献和数据</li></ul></li><li>缺点<ul><li>LOC依赖于使用的语言，这对短小精悍的程序不利</li><li>不太适用于非过程化语言</li><li>LOC只有在设计完成时候才能计算，同时估算需要一定程度的细节，而这些细节可能很难获得。项目计划人员很难在分析和设计完成之前估算LOC</li></ul></li></ul><p>软件测试的基本原则</p><ul><li>穷尽测试是不可能的</li><li>测试无法显示潜伏的软件缺陷</li><li>测试活动应尽早进行</li><li>软件缺陷具有群聚性</li><li>注意杀虫剂现象</li><li>应尽量由独立的测试团队进行测试</li></ul><p>软件测试的目标</p><ul><li>确认系统满足其预期的使用和用户的需要</li><li>确认解决了所需解决的问题</li><li>为测试的过程建立责任和可解释性</li><li>便于及早发现软件和系统的异常</li><li>及早提供软件和系统的性能的评估</li><li>为管理提供真实信息，以决定在当前状态下发布产品在商业上的风险</li><li>鉴别出程序在功能等方面的异常集聚之处</li></ul><p>什么情况下称为发现软件缺陷</p><ul><li>至少满足下列一个条件，则称发生了一个软件缺陷：<ul><li>软件未实现产品说明书要求的功能</li><li>软件出现了产品说明书指明不能出现的错误</li><li>软件实现了产品说明书未提到的功能</li><li>软件未实现产品说明书虽未明确提及但应该实现的目标</li><li>软件难以理解、不易使用、运行缓慢，或者测试员的角度看，最终用户会认为不好</li></ul></li></ul><p><strong>白盒测试和黑盒测试的含义</strong></p><ul><li>黑盒测试：指忽略系统或组件的内部机制，仅关注于那些响应所选择的输入及相应执行条件的输出的测试形式，也称为功能性测试</li><li>白盒测试：指考虑系统或组件的内部机制的测试形式，也称为结构性测试。由于通常需要进行白盒测试，因此软件测试工程师也需要具有编程能力</li></ul><p>简述软件测试与调试的同与不同</p><ul><li>两者都包含有处理软件缺陷和查看代码的过程</li><li>测试的目标是发现软件缺陷的存在， 调试的目标是定位与修复缺陷。软件测试员把问题缩减为能够演示软件缺陷的最简化测试用例（或可疑的代码行），进行调试的程序员进而判断到底是什么导致软件缺陷，并设法修复</li></ul><p>V模型中四个级别的测试的主要目的或测试依据</p><ul><li>单元测试的主要目的是验证软件模块是否按详细设计的规格说明正确运行</li><li>集成测试的主要目的是检查多个模块间是否按概要设计说明的方式协同工作</li><li>系统测试的主要目的是验证整个系统是否满足需求规格说明</li><li>验收测试从用户的角度检查系统是否满足合同中定义的需求，以及以确认产品是否能符合业务上的需要</li></ul><p><strong>单元测试的主要内容</strong></p><ul><li>对模块接口的测试保证在测试时进出程序单元的数据流是正确的</li><li>对局部数据结构的测试保证临时存储的数据在算法执行的整个过程中都能维持其完整性</li><li>对边界条件的测试保证模块在极限或严格的情形下仍然能够正确执行</li><li>控制结构中的所有独立路径（基本路径）原则上都应覆盖，以保证在一个模块中的所有语句都能至少执行一次</li><li>要对所有出错处理的路径进行测试</li></ul><p>集成测试有哪3种集成方法？</p><ul><li>自顶向下的集成方法</li><li>自底向上的集成方法</li><li>Smoke方法</li></ul><p>4级别测试分别采用白盒测试还是黑盒测试</p><ul><li>单元测试：主要采用白盒测试方法设计测试用例，但在白盒测试方法之前应该先依据详细设计说明书建立黑盒<br>测试用例进行测试，使之对任何合理的输入和不合理的输入，都能鉴别和响应</li><li>集成测试：既有白盒测试的成分又有黑盒测试的成分，也称为灰盒测试</li><li>系统测试：基本上使用黑盒测试方法</li><li>验收测试：黑盒测试方法</li></ul><p>软件维护的定义和必要性</p><ul><li>软件维护是指由于软件产品出现问题或需要改进而对代码及相关文档的修改，其目的是对现有软件产品进行修改的同时保持其完整性</li><li>软件维护能够改正错误</li><li>软件维护能够改善设计</li><li>软件维护能够实现软件的改进</li><li>软件维护能够与其他系统进行交互</li><li>软件维护能够为使用不同的硬件、软件、系统的新性能以及通讯设备等而对软件进行改进</li><li>软件维护能够完成遗留程序的移植</li><li>软件退出使用</li></ul><blockquote><p>复习到此结束 希望之后有愿意看的同学 多看一下数据流图怎么画</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> UESTC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UESTC </tag>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录博客的一次更新</title>
      <link href="posts/10533/"/>
      <url>posts/10533/</url>
      
        <content type="html"><![CDATA[<h2 id="记录一次博客的更新"><a href="#记录一次博客的更新" class="headerlink" title="记录一次博客的更新"></a>记录一次博客的更新</h2><p>已经很久没有写博客了，上一次写博客还是在半年前因为课程要求做读书笔记才记的，这半年来发生了很多事情，我的想法与之前也发生了很大的变化，希望能够从现在开始认认真真读几本书，好好写一下博客，记录一下自己的生活，最后希望自己能够考上研究生。</p><p>关于的博客一些TODO：</p><ul><li>加速访问</li><li>弄一个域名</li><li>加上https</li><li>增加产出</li></ul><p>暂时就这些吧(另外插件不要搞太多，太多直接把我电脑搞宕机了。。)</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gcc编译的背后</title>
      <link href="posts/41703/"/>
      <url>posts/41703/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在linux下写代码时，使用gcc只需要输入<code>gcc a.c -o a</code>就将代码编译好了，这背后做了些什么，在学习了下一学期的《编译原理》则不难理解，一般来说高级语言程序编译的过程只需要：预处理、编译、汇编、链接。gcc在后台实际上也经历了这几个过程，通过<code>-v</code>参数就可以查看它的编译细节，想要看某个具体的编译过程，则可以分别使用<code>-E</code>,<code>-S</code>,<code>-c</code>,<code>-o</code>,对应的后台工具分别为<code>cpp</code>,<code>ccl</code>,<code>as</code>,<code>ld</code>。</p><p>下面将逐步分析这几个过程以及相关的内容，比如语法检查，代码调试，汇编语言等待。</p><a id="more"></a><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>预处理过程主要是C语言编译器执行各种预处理命令，编译的基本过程(词法分析、语法分析)之前需要先对源代码中头文件的包含、宏定义的扩展、条件编译等命令先行处理，其中以<code>#define</code>,<code>#include</code>,<code>#ifdef ... #endif</code>这三类最为常见，其中<code>#define</code>除了可以单独使用来设置一些常量之外，还可以配合<code>#ifdef ... #endif</code>使用来控制代码块的编译与否，同时也可以避免同一个头文件多次包含，而<code>#include</code>则比较简单，<code>&lt;&gt;</code>或者’” “‘包含头文件即可。下面介绍几个和预处理相关的几个简单内容。</p><h3 id="打印出预处理之后的结果"><a href="#打印出预处理之后的结果" class="headerlink" title="打印出预处理之后的结果"></a>打印出预处理之后的结果</h3><p><code>$ gcc -E hello.c</code></p><p>这样可以看到源代码中各种预处理命令是如何被解释的，从而方便理解和查错。</p><h3 id="在命令行定义宏"><a href="#在命令行定义宏" class="headerlink" title="在命令行定义宏"></a>在命令行定义宏</h3><p><code>$gcc -Dmacro hello.c</code></p><p>这个等同于在文件的开头定义宏，即 <code>#define macro</code>，但是在命令行定义更灵活。例如，在源代码中有这些语句。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">ifdef</span> DEBUG</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"this code is for debugging\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果编译时加上 <code>-DDEBUG</code> 选项，那么编译器就会把 <code>printf</code> 所在的行编译进目标代码，从而方便地跟踪该位置的某些程序状态。这样 <code>-DDEBUG</code> 就可以当作一个调试开关，编译时加上它就可以用来打印调试信息，发布时则可以通过去掉该编译选项把调试信息去掉。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><h3 id="简述-1"><a href="#简述-1" class="headerlink" title="简述"></a>简述</h3><p>编译之前C 语言编译器会进行词法分析、语法分析，接着会把源代码翻译成中间语言，即汇编语言。如果想看到这个中间结果，可以用 <code>gcc -S</code>。需要提到的是，诸如 Shell 等解释语言也会经历一个词法分析和语法分析的阶段，不过之后并不会进行“翻译”，而是“解释”，边解释边执行。</p><p>把源代码翻译成汇编语言，实际上是编译的整个过程中的第一个阶段，之后的阶段和汇编语言的开发过程没有什么区别。这个阶段涉及到对源代码的词法分析、语法检查（通过 <code>-std</code> 指定遵循哪个标准），并根据优化 <code>（-O）</code> 要求进行翻译成汇编语言的动作。</p><h3 id="语法检查"><a href="#语法检查" class="headerlink" title="语法检查"></a>语法检查</h3><p>如果只是想要检查语法化可以使用<code>gcc</code>的<code>-fsyntax-only</code>选项，如果是要让代码有更好的可移植性的话则尽量少使用<code>gcc</code>的扩展特性，并结合<code>-std</code>让源代码遵循某个标准：</p><pre class="line-numbers language-c"><code class="language-c">$ cat hello<span class="token punctuation">.</span>c<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello, world\n"</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span>$ gcc <span class="token operator">-</span>fsyntax<span class="token operator">-</span>only hello<span class="token punctuation">.</span>chello<span class="token punctuation">.</span>c<span class="token punctuation">:</span> In function ‘main’<span class="token punctuation">:</span>hello<span class="token punctuation">.</span>c<span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">:</span> error<span class="token punctuation">:</span> expected ‘<span class="token punctuation">;</span>’ before ‘<span class="token keyword">return</span>’$ vim hello<span class="token punctuation">.</span>c$ cat hello<span class="token punctuation">.</span>c<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello, world\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span>$ gcc <span class="token operator">-</span>std<span class="token operator">=</span>c89 <span class="token operator">-</span>pedantic<span class="token operator">-</span>errors hello<span class="token punctuation">.</span>c    #默认情况下，gcc是允许在程序中间声明变量的，但是turboc就不支持hello<span class="token punctuation">.</span>c<span class="token punctuation">:</span> In function ‘main’<span class="token punctuation">:</span>hello<span class="token punctuation">.</span>c<span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">:</span> error<span class="token punctuation">:</span> ISO C90 forbids mixed declarations and code<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h2><p>检测语法后就是翻译，<code>gcc</code>提供了<code>-O</code>选项供不同运行平台的用户产生优化过的汇编代码。</p><pre class="line-numbers language-bash"><code class="language-bash">$ gcc -o hello hello.c         <span class="token comment" spellcheck="true"># 采用默认选项，不优化</span>$ gcc -O2 -o hello2 hello.c    <span class="token comment" spellcheck="true"># 优化等次是2</span>$ gcc -Os -o hellos hello.c    <span class="token comment" spellcheck="true"># 优化目标代码的大小</span>$ <span class="token function">ls</span> -S hello hello2 hellos    <span class="token comment" spellcheck="true"># 可以看到，hellos 比较小, hello2 比较大</span>hello2  hello  hellos$ <span class="token function">time</span> ./hellohello, worldreal    0m0.001suser    0m0.000ssys     0m0.000s$ <span class="token function">time</span> ./hello2     <span class="token comment" spellcheck="true"># 可能是代码比较少的缘故，执行效率看上去不是很明显</span>hello, worldreal    0m0.001suser    0m0.000ssys     0m0.000s$ <span class="token function">time</span> ./hellos     <span class="token comment" spellcheck="true"># 虽然目标代码小了，但是执行效率慢了些</span>hello, worldreal    0m0.002suser    0m0.000ssys     0m0.000s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="生成汇编语言程序"><a href="#生成汇编语言程序" class="headerlink" title="生成汇编语言程序"></a>生成汇编语言程序</h2><p>通过<code>-S</code>选项来查看编译出来的汇编语言程序。</p><pre class="line-numbers language-assembly"><code class="language-assembly">$ gcc -S hello.c  # 默认输出是hello.s，可自己指定，输出到屏幕`-o -`，输出到其他文件`-o file`$ cat hello.scat hello.s        .file   "hello.c"        .section        .rodata.LC0:        .string "hello, world"        .text.globl main        .type   main, @functionmain:        leal    4(%esp), %ecx        andl    $-16, %esp        pushl   -4(%ecx)        pushl   %ebp        movl    %esp, %ebp        pushl   %ecx        subl    $4, %esp        movl    $.LC0, (%esp)        call    puts        movl    $0, %eax        addl    $4, %esp        popl    %ecx        popl    %ebp        leal    -4(%ecx), %esp        ret        .size   main, .-main        .ident  "GCC: (GNU) 4.1.3 20070929 (prerelease) (Ubuntu 4.1.2-16ubuntu2)"        .section        .note.GNU-stack,"",@progbits<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的用的汇编的语法格式是<code>AT&amp;T</code>的格式,在使用IDE进行DEBUG的时候是可以更改的(如使用的<code>CLion</code>)</p><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><h3 id="简述-2"><a href="#简述-2" class="headerlink" title="简述"></a>简述</h3><p>汇编实际上是作为翻译为与机器代码的中间桥梁，汇编还不可以实际上运行,想要查看中间的汇编代码可以通过<code>gcc -c</code>来查看。</p><h3 id="生成目标代码"><a href="#生成目标代码" class="headerlink" title="生成目标代码"></a>生成目标代码</h3><p>下面来演示一下通过<code>gcc -c</code>和<code>as</code>来产生目标代码：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">file</span> hello.shello.s: ASCII assembler program text$ gcc -c hello.s   <span class="token comment" spellcheck="true">#用gcc把汇编语言编译成目标代码</span>$ <span class="token function">file</span> hello.o     <span class="token comment" spellcheck="true">#file命令用来查看文件类型，目标代码可重定位的(relocatable)，</span>                   <span class="token comment" spellcheck="true">#需要通过ld进行进一步链接成可执行程序(executable)和共享库(shared)</span>hello.o: ELF 32-bit LSB relocatable, Intel 80386, version 1 <span class="token punctuation">(</span>SYSV<span class="token punctuation">)</span>, not stripped$ as -o hello.o hello.s        <span class="token comment" spellcheck="true">#用as把汇编语言编译成目标代码</span>$ <span class="token function">file</span> hello.ohello.o: ELF 32-bit LSB relocatable, Intel 80386, version 1 <span class="token punctuation">(</span>SYSV<span class="token punctuation">)</span>, not stripped<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>gcc</code>和<code>as</code>默认产生的目标代码都是ELF格式的，这里讨论一下ELF格式的目标代码。</p><blockquote><p>什么是ELF(format of Executable and Linking Format (ELF) files)?</p><p>是UNIX系统实验室（<a href="https://baike.baidu.com/item/USL">USL</a>）作为应用程序二进制接口（Application Binary Interface，<a href="https://baike.baidu.com/item/ABI">ABI</a>）而开发和发布的，也是<a href="https://baike.baidu.com/item/Linux/27050">Linux</a>的主要可执行文件格式。</p><p>1999年，被86open项目选为<a href="https://baike.baidu.com/item/x86架构/7470217">x86架构</a>上的类<a href="https://baike.baidu.com/item/Unix操作系统">Unix操作系统</a>的二进制文件标准格式，用来取代<a href="https://baike.baidu.com/item/COFF">COFF</a>。因其可扩展性与灵活性，也可应用在其它处理器、计算机系统架构的操作系统上</p><p>ELF文件由4部分组成，分别是ELF头（ELF header）、程序头表（Program header table）、节（Section）和节头表（Section header table）。实际上，一个文件中不一定包含全部内容，而且它们的位置也未必如同所示这样安排，只有ELF头的位置是固定的，其余各部分的位置、大小等信息由ELF头中的各项值来决定。</p></blockquote><h3 id="ELF文件初次接触"><a href="#ELF文件初次接触" class="headerlink" title="ELF文件初次接触"></a>ELF文件初次接触</h3><p>目标代码此时发现不再是普通的文本格式，无法通过文本编辑器来浏览。如果想了解更多目标代码的细节，区分 <code>relocatable</code>（可重定位）、<code>executable</code>（可执行）、<code>shared libarary</code>（共享库）的不同，我们得设法了解目标代码的组织方式和相关的阅读和分析工具。下面主要介绍这部分内容。</p><blockquote><p>BFD is a package which allows applications to use the same routines(例行程序) to operate on object files whatever the object file format. A new object file format can be supported simply by creating a new BFD back end and adding it to the library.</p></blockquote><p><code>binutils</code>（GNU Binary Utilities）的很多工具都采用这个库来操作目标文件，这类工具有 <code>objdump</code>，<code>objcopy</code>，<code>nm</code>，<code>strip</code> 等（当然，我们也可以利用它。如果深入了解ELF格式，那么通过它来分析和编写 Virus 程序将会更加方便），不过另外一款非常优秀的分析工具 <code>readelf</code> 并不是基于这个库，所以也应该可以直接用 <code>elf.h</code> 头文件中定义的相关结构来操作 ELF 文件。</p><p>下面将通过这些辅助工具（主要是 <code>readelf</code> 和 <code>objdump</code>），结合 ELF 手册来分析它们。将依次介绍 ELF 文件的结构和三种不同类型 ELF 文件的区别。</p><h3 id="ELF文件的结构"><a href="#ELF文件的结构" class="headerlink" title="ELF文件的结构"></a>ELF文件的结构</h3><pre class="line-numbers language-bash"><code class="language-bash">ELF Header<span class="token punctuation">(</span>ELF文件头<span class="token punctuation">)</span>Program Headers Table<span class="token punctuation">(</span>程序头表，实际上叫段表好一些，用于描述可执行文件和可共享库<span class="token punctuation">)</span>Section 1Section 2Section 3<span class="token punctuation">..</span>.Section Headers Table<span class="token punctuation">(</span>节区头部表，用于链接可重定位文件成可执行文件或共享库<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于可重定位文件，程序头是可选的，而对于可执行文件和共享库文件（动态链接库），节区表则是可选的。可以分别通过 <code>readelf</code> 文件的 <code>-h</code>，<code>-l</code> 和 <code>-S</code> 参数查看 ELF 文件头（ELF Header）、程序头部表（Program Headers Table，段表）和节区表（Section Headers Table）。</p><p>文件头说明了文件的类型，大小，运行平台，节区数目等。</p><h3 id="三种不同类型ELF文件比较"><a href="#三种不同类型ELF文件比较" class="headerlink" title="三种不同类型ELF文件比较"></a>三种不同类型ELF文件比较</h3><p>先来通过文件头看看不同ELF的类型。为了说明问题，先来几段代码吧。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* myprintf.c */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">void</span> <span class="token function">myprintf</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello, world!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* test.h -- myprintf function declaration */</span><span class="token macro property">#<span class="token directive keyword">ifndef</span> _TEST_H_</span><span class="token macro property">#<span class="token directive keyword">define</span> _TEST_H_</span><span class="token keyword">void</span> <span class="token function">myprintf</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token comment" spellcheck="true">/* test.c */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"test.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">myprintf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面通过这几段代码来演示通过 <code>readelf -h</code> 参数查看 ELF 的不同类型。期间将演示如何创建动态链接库（即可共享文件）、静态链接库，并比较它们的异同。</p><p>编译产生两个目标文件 <code>myprintf.o</code> 和 <code>test.o</code>，它们都是可重定位文件（REL）：</p><pre class="line-numbers language-bash"><code class="language-bash">$ gcc -c myprintf.c test.c$ readelf -h test.o <span class="token operator">|</span> <span class="token function">grep</span> Type  Type:                              REL <span class="token punctuation">(</span>Relocatable file<span class="token punctuation">)</span>$ readelf -h myprintf.o <span class="token operator">|</span> <span class="token function">grep</span> Type  Type:                              REL <span class="token punctuation">(</span>Relocatable file<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据目标代码链接产生可执行文件，这里的文件类型是可执行的(EXEC)：</p><pre class="line-numbers language-bash"><code class="language-bash">$ gcc -o <span class="token function">test</span> myprintf.o test.o$ readelf -h <span class="token function">test</span> <span class="token operator">|</span> <span class="token function">grep</span> Type  Type:                              EXEC <span class="token punctuation">(</span>Executable file<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>用 <code>ar</code> 命令创建一个静态链接库，静态链接库也是可重定位文件（REL）：</p><pre class="line-numbers language-bash"><code class="language-bash">$ ar rcsv libmyprintf.a myprintf.o$ readelf -h libmyprintf.a <span class="token operator">|</span> <span class="token function">grep</span> Type  Type:                              REL <span class="token punctuation">(</span>Relocatable file<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可见，静态链接库和可重定位文件类型一样，它们之间唯一不同是前者可以是多个可重定位文件的“集合”。</p><p>静态链接库可直接链接（只需库名，不要前面的 <code>lib</code>），也可用 <code>-l</code> 参数，<code>-L</code> 指定库搜索路径。</p><pre class="line-numbers language-bash"><code class="language-bash">$ gcc -o <span class="token function">test</span> test.o -lmyprintf -L./<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编译产生动态链接库，并支持 <code>major</code> 和 <code>minor</code> 版本号，动态链接库类型为 <code>DYN</code>：</p><pre class="line-numbers language-bash"><code class="language-bash">$ gcc -Wall myprintf.o -shared -Wl,-soname,libmyprintf.so.0 -o libmyprintf.so.0.0$ <span class="token function">ln</span> -sf libmyprintf.so.0.0 libmyprintf.so.0$ <span class="token function">ln</span> -sf libmyprintf.so.0 libmyprintf.so$ readelf -h libmyprintf.so <span class="token operator">|</span> <span class="token function">grep</span> Type  Type:                              DYN <span class="token punctuation">(</span>Shared object file<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>动态链接库编译时和静态链接库类似：</p><pre class="line-numbers language-bash"><code class="language-bash">$ gcc -o <span class="token function">test</span> test.o -lmyprintf -L./<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是执行时需要指定动态链接库的搜索路径，把 <code>LD_LIBRARY_PATH</code> 设为当前目录，指定 <code>test</code> 运行时的动态链接库搜索路径：</p><pre class="line-numbers language-bash"><code class="language-bash">$ LD_LIBRARY_PATH<span class="token operator">=</span>./ ./test$ gcc -static -o <span class="token function">test</span> test.o -lmyprintf -L./<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在不指定 <code>-static</code> 时会优先使用动态链接库，指定时则阻止使用动态链接库，这时会把所有静态链接库文件加入到可执行文件中，使得执行文件很大，而且加载到内存以后会浪费内存空间，因此不建议这么做。</p><p>经过上面的演示基本可以看出它们之间的不同：</p><ul><li>可重定位文件本身不可以运行，仅仅是作为可执行文件、静态链接库（也是可重定位文件）、动态链接库的 “组件”。</li><li>静态链接库和动态链接库本身也不可以执行，作为可执行文件的“组件”，它们两者也不同，前者也是可重定位文件（只不过可能是多个可重定位文件的集合），并且在链接时加入到可执行文件中去。</li><li>而动态链接库在链接时，库文件本身并没有添加到可执行文件中，只是在可执行文件中加入了该库的名字等信息，以便在可执行文件运行过程中引用库中的函数时由动态链接器去查找相关函数的地址，并调用它们。</li></ul><p>从这个意义上说，动态链接库本身也具有可重定位的特征，含有可重定位的信息。对于什么是重定位？如何进行静态符号和动态符号的重定位，我们将在链接部分和后面一节中介绍。</p><h3 id="ELF主体：节区"><a href="#ELF主体：节区" class="headerlink" title="ELF主体：节区"></a>ELF主体：节区</h3><p>下面来看看 ELF 文件的主体内容：节区（Section)。</p><p>ELF 文件具有很大的灵活性，它通过文件头组织整个文件的总体结构，通过节区表 (Section Headers Table）和程序头（Program Headers Table 或者叫段表）来分别描述可重定位文件和可执行文件。但不管是哪种类型，它们都需要它们的主体，即各种节区。</p><p>在可重定位文件中，节区表描述的就是各种节区本身；而在可执行文件中，程序头描述的是由各个节区组成的段（Segment），以便程序运行时动态装载器知道如何对它们进行内存映像，从而方便程序加载和运行。</p><p>下面先来看看一些常见的节区，而关于这些节区（Section）如何通过重定位构成不同的段（Segments），以及有哪些常规的段，我们将在链接部分进一步介绍。</p><p>可以通过 <code>readelf -S</code> 查看 ELF 的节区，先来看看可重定位文件的节区信息，通过节区表来查看：</p><p>默认编译好 <code>myprintf.c</code>，将产生一个可重定位的文件 <code>myprintf.o</code>，这里通过 <code>myprintf.o</code> 的节区表查看节区信息。</p><pre class="line-numbers language-bash"><code class="language-bash">$ gcc -c myprintf.c$ readelf -S myprintf.oThere are 11 section headers, starting at offset 0xc0:Section Headers:  <span class="token punctuation">[</span>Nr<span class="token punctuation">]</span> Name              Type            Addr     Off    Size   ES Flg Lk Inf Al  <span class="token punctuation">[</span> 0<span class="token punctuation">]</span>                   NULL            00000000 000000 000000 00      0   0  0  <span class="token punctuation">[</span> 1<span class="token punctuation">]</span> .text             PROGBITS        00000000 000034 000018 00  AX  0   0  4  <span class="token punctuation">[</span> 2<span class="token punctuation">]</span> .rel.text         REL             00000000 000334 000010 08      9   1  4  <span class="token punctuation">[</span> 3<span class="token punctuation">]</span> .data             PROGBITS        00000000 00004c 000000 00  WA  0   0  4  <span class="token punctuation">[</span> 4<span class="token punctuation">]</span> .bss              NOBITS          00000000 00004c 000000 00  WA  0   0  4  <span class="token punctuation">[</span> 5<span class="token punctuation">]</span> .rodata           PROGBITS        00000000 00004c 00000e 00   A  0   0  1  <span class="token punctuation">[</span> 6<span class="token punctuation">]</span> .comment          PROGBITS        00000000 00005a 000012 00      0   0  1  <span class="token punctuation">[</span> 7<span class="token punctuation">]</span> .note.GNU-stack   PROGBITS        00000000 00006c 000000 00      0   0  1  <span class="token punctuation">[</span> 8<span class="token punctuation">]</span> .shstrtab         STRTAB          00000000 00006c 000051 00      0   0  1  <span class="token punctuation">[</span> 9<span class="token punctuation">]</span> .symtab           SYMTAB          00000000 000278 0000a0 10     10   8  4  <span class="token punctuation">[</span>10<span class="token punctuation">]</span> .strtab           STRTAB          00000000 000318 00001a 00      0   0  1Key to Flags:  W <span class="token punctuation">(</span>write<span class="token punctuation">)</span>, A <span class="token punctuation">(</span>alloc<span class="token punctuation">)</span>, X <span class="token punctuation">(</span>execute<span class="token punctuation">)</span>, M <span class="token punctuation">(</span>merge<span class="token punctuation">)</span>, S <span class="token punctuation">(</span>strings<span class="token punctuation">)</span>  I <span class="token punctuation">(</span>info<span class="token punctuation">)</span>, L <span class="token punctuation">(</span>link order<span class="token punctuation">)</span>, G <span class="token punctuation">(</span>group<span class="token punctuation">)</span>, x <span class="token punctuation">(</span>unknown<span class="token punctuation">)</span>  O <span class="token punctuation">(</span>extra OS processing required<span class="token punctuation">)</span> o <span class="token punctuation">(</span>OS specific<span class="token punctuation">)</span>, p <span class="token punctuation">(</span>processor specific<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用 <code>objdump -d</code> 可看反编译结果，用 <code>-j</code> 选项可指定需要查看的节区：</p><pre class="line-numbers language-bash"><code class="language-bash">$ objdump -d -j .text   myprintf.omyprintf.o:     <span class="token function">file</span> <span class="token function">format</span> elf32-i386Disassembly of section .text:00000000 <span class="token operator">&lt;</span>myprintf<span class="token operator">></span>:   0:   55                      push   %ebp   1:   89 e5                   mov    %esp,%ebp   3:   83 ec 08                sub    <span class="token variable">$0x8</span>,%esp   6:   83 ec 0c                sub    <span class="token variable">$0xc</span>,%esp   9:   68 00 00 00 00          push   <span class="token variable">$0x0</span>   e:   e8 fc ff ff ff          call   f <span class="token operator">&lt;</span>myprintf+0xf<span class="token operator">></span>  13:   83 c4 10                add    <span class="token variable">$0x10</span>,%esp  16:   c9                      leave  17:   c3                      ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用 <code>-r</code> 选项可以看到有关重定位的信息，这里有两部分需要重定位：</p><pre class="line-numbers language-bash"><code class="language-bash">$ readelf -r myprintf.oRelocation section <span class="token string">'.rel.text'</span> at offset 0x334 contains 2 entries: Offset     Info    Type            Sym.Value  Sym. Name0000000a  00000501 R_386_32          00000000   .rodata0000000f  00000902 R_386_PC32        00000000   puts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>.rodata</code> 节区包含只读数据，即我们要打印的 <code>hello, world!</code></p><pre class="line-numbers language-bash"><code class="language-bash">$ readelf -x .rodata myprintf.oHex dump of section <span class="token string">'.rodata'</span><span class="token keyword">:</span>  0x00000000 68656c6c 6f2c2077 6f726c64 2100     hello, world<span class="token operator">!</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>没有找到 <code>.data</code> 节区, 它应该包含一些初始化的数据：</p><pre class="line-numbers language-bash"><code class="language-bash">$ readelf -x .data myprintf.oSection <span class="token string">'.data'</span> has no data to dump.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>也没有 <code>.bss</code> 节区，它应该包含一些未初始化的数据，程序默认初始为 0：</p><pre class="line-numbers language-bash"><code class="language-bash">$ readelf -x .bss       myprintf.oSection <span class="token string">'.bss'</span> has no data to dump.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>.comment</code> 是一些注释，可以看到是是 <code>Gcc</code> 的版本信息</p><pre class="line-numbers language-bash"><code class="language-bash">$ readelf -x .comment myprintf.oHex dump of section <span class="token string">'.comment'</span><span class="token keyword">:</span>  0x00000000 00474343 3a202847 4e552920 342e312e .GCC: <span class="token punctuation">(</span>GNU<span class="token punctuation">)</span> 4.1.  0x00000010 3200                                2.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>.note.GNU-stack</code> 这个节区也没有内容：</p><pre class="line-numbers language-bash"><code class="language-bash">$ readelf -x .note.GNU-stack myprintf.oSection <span class="token string">'.note.GNU-stack'</span> has no data to dump.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>.shstrtab</code> 包括所有节区的名字：</p><pre class="line-numbers language-bash"><code class="language-bash">$ readelf -x .shstrtab myprintf.oHex dump of section <span class="token string">'.shstrtab'</span><span class="token keyword">:</span>  0x00000000 002e7379 6d746162 002e7374 72746162 <span class="token punctuation">..</span>symtab<span class="token punctuation">..</span>strtab  0x00000010 002e7368 73747274 6162002e 72656c2e <span class="token punctuation">..</span>shstrtab<span class="token punctuation">..</span>rel.  0x00000020 74657874 002e6461 7461002e 62737300 text<span class="token punctuation">..</span>data<span class="token punctuation">..</span>bss.  0x00000030 2e726f64 61746100 2e636f6d 6d656e74 .rodata<span class="token punctuation">..</span>comment  0x00000040 002e6e6f 74652e47 4e552d73 7461636b <span class="token punctuation">..</span>note.GNU-stack  0x00000050 00                                  <span class="token keyword">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>符号表 <code>.symtab</code> 包括所有用到的相关符号信息，如函数名、变量名，可用 <code>readelf</code> 查看：</p><pre class="line-numbers language-bash"><code class="language-bash">$ readelf -symtab myprintf.oSymbol table <span class="token string">'.symtab'</span> contains 10 entries:   Num:    Value  Size Type    Bind   Vis      Ndx Name     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND     1: 00000000     0 FILE    LOCAL  DEFAULT  ABS myprintf.c     2: 00000000     0 SECTION LOCAL  DEFAULT    1     3: 00000000     0 SECTION LOCAL  DEFAULT    3     4: 00000000     0 SECTION LOCAL  DEFAULT    4     5: 00000000     0 SECTION LOCAL  DEFAULT    5     6: 00000000     0 SECTION LOCAL  DEFAULT    7     7: 00000000     0 SECTION LOCAL  DEFAULT    6     8: 00000000    24 FUNC    GLOBAL DEFAULT    1 myprintf     9: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND puts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字符串表 <code>.strtab</code> 包含用到的字符串，包括文件名、函数名、变量名等：</p><pre class="line-numbers language-bash"><code class="language-bash">$ readelf -x .strtab myprintf.oHex dump of section <span class="token string">'.strtab'</span><span class="token keyword">:</span>  0x00000000 006d7970 72696e74 662e6300 6d797072 .myprintf.c.mypr  0x00000010 696e7466 00707574 7300              intf.puts.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上表可以看出，对于可重定位文件，会包含这些基本节区 <code>.text</code>, <code>.rel.text</code>, <code>.data</code>, <code>.bss</code>, <code>.rodata</code>, <code>.comment</code>, <code>.note.GNU-stack</code>, <code>.shstrtab</code>, <code>.symtab</code> 和 <code>.strtab</code>。</p><h3 id="汇编语言文件中的节区表述"><a href="#汇编语言文件中的节区表述" class="headerlink" title="汇编语言文件中的节区表述"></a>汇编语言文件中的节区表述</h3><p>为了进一步理解这些节区和源代码的关系，这里来看一看 <code>myprintf.c</code> 产生的汇编代码。</p><pre class="line-numbers language-assembly"><code class="language-assembly">$ gcc -S myprintf.c$ cat myprintf.s        .file   "myprintf.c"        .section        .rodata.LC0:        .string "hello, world!"        .text.globl myprintf        .type   myprintf, @functionmyprintf:        pushl   %ebp        movl    %esp, %ebp        subl    $8, %esp        subl    $12, %esp        pushl   $.LC0        call    puts        addl    $16, %esp        leave        ret        .size   myprintf, .-myprintf        .ident  "GCC: (GNU) 4.1.2"        .section        .note.GNU-stack,"",@progbits<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>是不是可以从中看出可重定位文件中的那些节区和汇编语言代码之间的关系？在上面的可重定位文件，可以看到有一个可重定位的节区，即 <code>.rel.text</code>，它标记了两个需要重定位的项，<code>.rodata</code> 和 <code>puts</code>。这个节区将告诉编译器这两个信息在链接或者动态链接的过程中需要重定位， 具体如何重定位？将根据重定位项的类型，比如上面的 <code>R_386_32</code> 和 <code>R_386_PC32</code>。</p><p>到这里，对可重定位文件应该有了一个基本的了解，下面将介绍什么是可重定位，可重定位文件到底是如何被链接生成可执行文件和动态链接库的，这个过程除了进行一些符号的重定位外，还进行了哪些工作呢？</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="简述-3"><a href="#简述-3" class="headerlink" title="简述"></a>简述</h3><p>重定位是将符号引用与符号定义进行链接的过程。因此链接是处理可重定位文件，把它们的各种符号引用和符号定义转换为可执行文件中的合适信息（一般是虚拟内存地址）的过程。</p><p>链接又分为静态链接和动态链接，前者是程序开发阶段程序员用 <code>ld</code>（<code>gcc</code> 实际上在后台调用了 <code>ld</code>）静态链接器手动链接的过程，而动态链接则是程序运行期间系统调用动态链接器（<code>ld-linux.so</code>）自动链接的过程。</p><p>比如，如果链接到可执行文件中的是静态链接库 <code>libmyprintf.a</code>，那么 <code>.rodata</code> 节区在链接后需要被重定位到一个绝对的虚拟内存地址，以便程序运行时能够正确访问该节区中的字符串信息。而对于 <code>puts</code> 函数，因为它是动态链接库 <code>libc.so</code> 中定义的函数，所以会在程序运行时通过动态符号链接找出 <code>puts</code> 函数在内存中的地址，以便程序调用该函数。在这里主要讨论静态链接过程，动态链接过程见之后更新的章节。</p><p>静态链接过程主要是把可重定位文件依次读入，分析各个文件的文件头，进而依次读入各个文件的节区，并计算各个节区的虚拟内存位置，对一些需要重定位的符号进行处理，设定它们的虚拟内存地址等，并最终产生一个可执行文件或者是动态链接库。这个链接过程是通过 <code>ld</code> 来完成的，<code>ld</code> 在链接时使用了一个链接脚本（<code>linker script</code>），该链接脚本处理链接的具体细节。</p><p>由于静态符号链接过程非常复杂，特别是计算符号地址的过程。这里主要介绍可重定位文件中的节区（节区表描述的）和可执行文件中段（程序头描述的）的对应关系以及 <code>gcc</code> 编译时采用的一些默认链接选项。</p><h3 id="可执行文件的段：节区重排"><a href="#可执行文件的段：节区重排" class="headerlink" title="可执行文件的段：节区重排"></a>可执行文件的段：节区重排</h3><p>下面先来看看可执行文件的节区信息，通过程序头（段表）来查看，为了比较，先把 <code>test.o</code> 的节区表也列出：</p><pre class="line-numbers language-bash"><code class="language-bash">$ readelf -S test.oThere are 10 section headers, starting at offset 0xb4:Section Headers:  <span class="token punctuation">[</span>Nr<span class="token punctuation">]</span> Name              Type            Addr     Off    Size   ES Flg Lk Inf Al  <span class="token punctuation">[</span> 0<span class="token punctuation">]</span>                   NULL            00000000 000000 000000 00      0   0  0  <span class="token punctuation">[</span> 1<span class="token punctuation">]</span> .text             PROGBITS        00000000 000034 000024 00  AX  0   0  4  <span class="token punctuation">[</span> 2<span class="token punctuation">]</span> .rel.text         REL             00000000 0002ec 000008 08      8   1  4  <span class="token punctuation">[</span> 3<span class="token punctuation">]</span> .data             PROGBITS        00000000 000058 000000 00  WA  0   0  4  <span class="token punctuation">[</span> 4<span class="token punctuation">]</span> .bss              NOBITS          00000000 000058 000000 00  WA  0   0  4  <span class="token punctuation">[</span> 5<span class="token punctuation">]</span> .comment          PROGBITS        00000000 000058 000012 00      0   0  1  <span class="token punctuation">[</span> 6<span class="token punctuation">]</span> .note.GNU-stack   PROGBITS        00000000 00006a 000000 00      0   0  1  <span class="token punctuation">[</span> 7<span class="token punctuation">]</span> .shstrtab         STRTAB          00000000 00006a 000049 00      0   0  1  <span class="token punctuation">[</span> 8<span class="token punctuation">]</span> .symtab           SYMTAB          00000000 000244 000090 10      9   7  4  <span class="token punctuation">[</span> 9<span class="token punctuation">]</span> .strtab           STRTAB          00000000 0002d4 000016 00      0   0  1Key to Flags:  W <span class="token punctuation">(</span>write<span class="token punctuation">)</span>, A <span class="token punctuation">(</span>alloc<span class="token punctuation">)</span>, X <span class="token punctuation">(</span>execute<span class="token punctuation">)</span>, M <span class="token punctuation">(</span>merge<span class="token punctuation">)</span>, S <span class="token punctuation">(</span>strings<span class="token punctuation">)</span>  I <span class="token punctuation">(</span>info<span class="token punctuation">)</span>, L <span class="token punctuation">(</span>link order<span class="token punctuation">)</span>, G <span class="token punctuation">(</span>group<span class="token punctuation">)</span>, x <span class="token punctuation">(</span>unknown<span class="token punctuation">)</span>  O <span class="token punctuation">(</span>extra OS processing required<span class="token punctuation">)</span> o <span class="token punctuation">(</span>OS specific<span class="token punctuation">)</span>, p <span class="token punctuation">(</span>processor specific<span class="token punctuation">)</span>$ gcc -o <span class="token function">test</span> test.o myprintf.o$ readelf -l <span class="token function">test</span>Elf <span class="token function">file</span> <span class="token function">type</span> is EXEC <span class="token punctuation">(</span>Executable file<span class="token punctuation">)</span>Entry point 0x80482b0There are 7 program headers, starting at offset 52Program Headers:  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align  PHDR           0x000034 0x08048034 0x08048034 0x000e0 0x000e0 R E 0x4  INTERP         0x000114 0x08048114 0x08048114 0x00013 0x00013 R   0x1      <span class="token punctuation">[</span>Requesting program interpreter: /lib/ld-linux.so.2<span class="token punctuation">]</span>  LOAD           0x000000 0x08048000 0x08048000 0x0047c 0x0047c R E 0x1000  LOAD           0x00047c 0x0804947c 0x0804947c 0x00104 0x00108 RW  0x1000  DYNAMIC        0x000490 0x08049490 0x08049490 0x000c8 0x000c8 RW  0x4  NOTE           0x000128 0x08048128 0x08048128 0x00020 0x00020 R   0x4  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4 Section to Segment mapping:  Segment Sections<span class="token punctuation">..</span>.   00   01     .interp   02     .interp .note.ABI-tag .hash .dynsym .dynstr .gnu.version .gnu.version_r          .rel.dyn .rel.plt .init .plt .text .fini .rodata .eh_frame   03     .ctors .dtors .jcr .dynamic .got .got.plt .data .bss   04     .dynamic   05     .note.ABI-tag   06<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 可发现，<code>test</code> 和 <code>test.o</code>，<code>myprintf.o</code> 相比，多了很多节区，如 <code>.interp</code> 和 <code>.init</code> 等。另外，上表也给出了可执行文件的如下几个段（Segment）：</p><ul><li><code>PHDR</code>: 给出了程序表自身的大小和位置，不能出现一次以上。</li><li><code>INTERP</code>: 因为程序中调用了 <code>puts</code>（在动态链接库中定义），使用了动态链接库，因此需要动态装载器／链接器（<code>ld-linux.so</code>）</li><li><code>LOAD</code>: 包括程序的指令，<code>.text</code> 等节区都映射在该段，只读（R）</li><li><code>LOAD</code>: 包括程序的数据，<code>.data</code>,<code>.bss</code> 等节区都映射在该段，可读写（RW）</li><li><code>DYNAMIC</code>: 动态链接相关的信息，比如包含有引用的动态链接库名字等信息</li><li><code>NOTE</code>: 给出一些附加信息的位置和大小</li><li><code>GNU_STACK</code>: 这里为空，应该是和GNU相关的一些信息</li></ul><p>这里的段可能包括之前的一个或者多个节区，也就是说经过链接之后原来的节区被重排了，并映射到了不同的段，这些段将告诉系统应该如何把它加载到内存中。</p><h3 id="链接背后的故事"><a href="#链接背后的故事" class="headerlink" title="链接背后的故事"></a>链接背后的故事</h3><p>从上表中，通过比较可执行文件 <code>test</code> 中拥有的节区和可重定位文件（<code>test.o</code> 和 <code>myprintf.o</code>）中拥有的节区后发现，链接之后多了一些之前没有的节区，这些新的节区来自哪里？它们的作用是什么呢？先来通过 <code>gcc -v</code> 看看它的后台链接过程。</p><p>把可重定位文件链接成可执行文件：</p><pre class="line-numbers language-bash"><code class="language-bash">$ gcc -v -o <span class="token function">test</span> test.o myprintf.oReading specs from /usr/lib/gcc/i486-slackware-linux/4.1.2/specsTarget: i486-slackware-linuxConfigured with: <span class="token punctuation">..</span>/gcc-4.1.2/configure --prefix<span class="token operator">=</span>/usr --enable-shared--enable-languages<span class="token operator">=</span>ada,c,c++,fortran,java,objc --enable-threads<span class="token operator">=</span>posix--enable-__cxa_atexit --disable-checking --with-gnu-ld --verbose--with-arch<span class="token operator">=</span>i486 --target<span class="token operator">=</span>i486-slackware-linux --host<span class="token operator">=</span>i486-slackware-linuxThread model: posixgcc version 4.1.2 /usr/libexec/gcc/i486-slackware-linux/4.1.2/collect2 --eh-frame-hdr -melf_i386 -dynamic-linker /lib/ld-linux.so.2 -o <span class="token function">test</span>/usr/lib/gcc/i486-slackware-linux/4.1.2/<span class="token punctuation">..</span>/<span class="token punctuation">..</span>/<span class="token punctuation">..</span>/crt1.o/usr/lib/gcc/i486-slackware-linux/4.1.2/<span class="token punctuation">..</span>/<span class="token punctuation">..</span>/<span class="token punctuation">..</span>/crti.o/usr/lib/gcc/i486-slackware-linux/4.1.2/crtbegin.o-L/usr/lib/gcc/i486-slackware-linux/4.1.2-L/usr/lib/gcc/i486-slackware-linux/4.1.2-L/usr/lib/gcc/i486-slackware-linux/4.1.2/<span class="token punctuation">..</span>/<span class="token punctuation">..</span>/<span class="token punctuation">..</span>/<span class="token punctuation">..</span>/i486-slackware-linux/lib-L/usr/lib/gcc/i486-slackware-linux/4.1.2/<span class="token punctuation">..</span>/<span class="token punctuation">..</span>/<span class="token punctuation">..</span> test.o myprintf.o -lgcc--as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed/usr/lib/gcc/i486-slackware-linux/4.1.2/crtend.o/usr/lib/gcc/i486-slackware-linux/4.1.2/<span class="token punctuation">..</span>/<span class="token punctuation">..</span>/<span class="token punctuation">..</span>/crtn.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上述演示看出，<code>gcc</code> 在链接了我们自己的目标文件 <code>test.o</code> 和 <code>myprintf.o</code> 之外，还链接了 <code>crt1.o</code>，<code>crtbegin.o</code> 等额外的目标文件，难道那些新的节区就来自这些文件？</p><h3 id="用-ld-完成链接过程"><a href="#用-ld-完成链接过程" class="headerlink" title="用 ld 完成链接过程"></a>用 ld 完成链接过程</h3><p>另外 <code>gcc</code> 在进行了相关配置（<code>./configure</code>）后，调用了 <code>collect2</code>，却并没有调用 <code>ld</code>，通过查找 <code>gcc</code> 文档中和 <code>collect2</code> 相关的部分发现 <code>collect2</code> 在后台实际上还是去寻找 <code>ld</code> 命令的。为了理解 <code>gcc</code> 默认链接的后台细节，这里直接把 <code>collect2</code> 替换成 <code>ld</code>，并把一些路径换成绝对路径或者简化，得到如下的 <code>ld</code> 命令以及执行的效果。</p><pre class="line-numbers language-bash"><code class="language-bash">$ ld --eh-frame-hdr \-m elf_i386 \-dynamic-linker /lib/ld-linux.so.2 \-o <span class="token function">test</span> \/usr/lib/crt1.o /usr/lib/crti.o /usr/lib/gcc/i486-slackware-linux/4.1.2/crtbegin.o \test.o myprintf.o \-L/usr/lib/gcc/i486-slackware-linux/4.1.2 -L/usr/i486-slackware-linux/lib -L/usr/lib/ \-lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed \/usr/lib/gcc/i486-slackware-linux/4.1.2/crtend.o /usr/lib/crtn.o$ ./testhello, world<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不出所料，它完美地运行了。下面通过 <code>ld</code> 的手册（<code>man ld</code>）来分析一下这几个参数：</p><ul><li><p><code>--eh-frame-hdr</code></p><p>要求创建一个 <code>.eh_frame_hdr</code> 节区(貌似目标文件test中并没有这个节区，所以不关心它)。</p></li><li><p><code>-m elf_i386</code></p><p>这里指定不同平台上的链接脚本，可以通过 <code>--verbose</code> 命令查看脚本的具体内容，如 <code>ld -m elf_i386 --verbose</code>，它实际上被存放在一个文件中（<code>/usr/lib/ldscripts</code> 目录下），我们可以去修改这个脚本，具体如何做？请参考 <code>ld</code> 的手册。在后面我们将简要提到链接脚本中是如何预定义变量的，以及这些预定义变量如何在我们的程序中使用。需要提到的是，如果不是交叉编译，那么无须指定该选项。</p></li><li><p>-dynamic-linker /lib/ld-linux.so.2</p><p>指定动态装载器/链接器，即程序中的 <code>INTERP</code> 段中的内容。动态装载器/链接器负责链接有可共享库的可执行文件的装载和动态符号链接。</p></li><li><p>-o test</p><p>指定输出文件，即可执行文件名的名字</p></li><li><p>/usr/lib/crt1.o /usr/lib/crti.o /usr/lib/gcc/i486-slackware-linux/4.1.2/crtbegin.o</p><p>链接到 <code>test</code> 文件开头的一些内容，这里实际上就包含了 <code>.init</code> 等节区。<code>.init</code> 节区包含一些可执行代码，在 <code>main</code> 函数之前被调用，以便进行一些初始化操作，在 C++ 中完成构造函数功能。</p></li><li><p>test.o myprintf.o</p><p>链接我们自己的可重定位文件</p></li><li><p><code>-L/usr/lib/gcc/i486-slackware-linux/4.1.2 -L/usr/i486-slackware-linux/lib -L/usr/lib/ \ -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed</code></p><p>链接 <code>libgcc</code> 库和 <code>libc</code> 库，后者定义有我们需要的 <code>puts</code> 函数</p></li><li><p>/usr/lib/gcc/i486-slackware-linux/4.1.2/crtend.o /usr/lib/crtn.o</p><p>链接到 <code>test</code> 文件末尾的一些内容，这里实际上包含了 <code>.fini</code> 等节区。<code>.fini</code> 节区包含了一些可执行代码，在程序退出时被执行，作一些清理工作，在 C++ 中完成析构造函数功能。我们往往可以通过 <code>atexit</code> 来注册那些需要在程序退出时才执行的函数。</p></li></ul><h3 id="C-构造与析构：crtbegin-o和crtend-o"><a href="#C-构造与析构：crtbegin-o和crtend-o" class="headerlink" title="C++构造与析构：crtbegin.o和crtend.o"></a>C++构造与析构：crtbegin.o和crtend.o</h3><p>对于 <code>crtbegin.o</code> 和 <code>crtend.o</code> 这两个文件，貌似完全是用来支持 C++ 的构造和析构工作的，所以可以不链接到我们的可执行文件中，链接时把它们去掉看看，</p><pre class="line-numbers language-bash"><code class="language-bash">$ ld -m elf_i386 -dynamic-linker /lib/ld-linux.so.2 -o <span class="token function">test</span> \  /usr/lib/crt1.o /usr/lib/crti.o test.o myprintf.o \  -L/usr/lib -lc /usr/lib/crtn.o    <span class="token comment" spellcheck="true">#后面发现不用链接libgcc，也不用--eh-frame-hdr参数</span>$ readelf -l <span class="token function">test</span>Elf <span class="token function">file</span> <span class="token function">type</span> is EXEC <span class="token punctuation">(</span>Executable file<span class="token punctuation">)</span>Entry point 0x80482b0There are 7 program headers, starting at offset 52Program Headers:  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align  PHDR           0x000034 0x08048034 0x08048034 0x000e0 0x000e0 R E 0x4  INTERP         0x000114 0x08048114 0x08048114 0x00013 0x00013 R   0x1      <span class="token punctuation">[</span>Requesting program interpreter: /lib/ld-linux.so.2<span class="token punctuation">]</span>  LOAD           0x000000 0x08048000 0x08048000 0x003ea 0x003ea R E 0x1000  LOAD           0x0003ec 0x080493ec 0x080493ec 0x000e8 0x000e8 RW  0x1000  DYNAMIC        0x0003ec 0x080493ec 0x080493ec 0x000c8 0x000c8 RW  0x4  NOTE           0x000128 0x08048128 0x08048128 0x00020 0x00020 R   0x4  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4 Section to Segment mapping:  Segment Sections<span class="token punctuation">..</span>.   00   01     .interp   02     .interp .note.ABI-tag .hash .dynsym .dynstr .gnu.version .gnu.version_r          .rel.dyn .rel.plt .init .plt .text .fini .rodata   03     .dynamic .got .got.plt .data   04     .dynamic   05     .note.ABI-tag   06$ ./testhello, world<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完全可以工作，而且发现 <code>.ctors</code>（保存着程序中全局构造函数的指针数组）, <code>.dtors</code>（保存着程序中全局析构函数的指针数组）,<code>.jcr</code>（未知）,<code>.eh_frame</code> 节区都没有了，所以 <code>crtbegin.o</code> 和 <code>crtend.o</code> 应该包含了这些节区。</p><h3 id="初始化与退出清理：crti-o-和-crtn-o"><a href="#初始化与退出清理：crti-o-和-crtn-o" class="headerlink" title="初始化与退出清理：crti.o 和 crtn.o"></a>初始化与退出清理：crti.o 和 crtn.o</h3><p>而对于另外两个文件 <code>crti.o</code> 和 <code>crtn.o</code>，通过 <code>readelf -S</code> 查看后发现它们都有 <code>.init</code> 和 <code>.fini</code> 节区，如果我们不需要让程序进行一些初始化和清理工作呢？是不是就可以不链接这个两个文件？试试看。</p><pre class="line-numbers language-bash"><code class="language-bash">$ ld  -m elf_i386 -dynamic-linker /lib/ld-linux.so.2 -o <span class="token function">test</span> \      /usr/lib/crt1.o test.o myprintf.o -L/usr/lib/ -lc/usr/lib/libc_nonshared.a<span class="token punctuation">(</span>elf-init.oS<span class="token punctuation">)</span>: In <span class="token keyword">function</span> `__libc_csu_init<span class="token string">':(.text+0x25): undefined reference to `_init'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>貌似不行，竟然有人调用了 <code>__libc_csu_init</code> 函数，而这个函数引用了 <code>_init</code>。这两个符号都在哪里呢？</p><pre class="line-numbers language-bash"><code class="language-bash">$ readelf -s /usr/lib/crt1.o <span class="token operator">|</span> <span class="token function">grep</span> __libc_csu_init    18: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND __libc_csu_init$ readelf -s /usr/lib/crti.o <span class="token operator">|</span> <span class="token function">grep</span> _init    17: 00000000     0 FUNC    GLOBAL DEFAULT    5 _init<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>竟然是 <code>crt1.o</code> 调用了 <code>__libc_csu_init</code> 函数，而该函数却引用了我们没有链接的 <code>crti.o</code> 文件中定义的 <code>_init</code> 符号。这样的话不链接 <code>crti.o</code> 和 <code>crtn.o</code> 文件，不用 <code>crt1.o</code> ，看看 <code>gcc</code> 额外链接进去的最后一个文件 <code>crt1.o</code> 到底干什么</p><pre class="line-numbers language-bash"><code class="language-bash">$ ld  -m elf_i386 -dynamic-linker /lib/ld-linux.so.2 -o \      <span class="token function">test</span> test.o myprintf.o -L/usr/lib/ -lcld: warning: cannot <span class="token function">find</span> entry symbol _start<span class="token punctuation">;</span> defaulting to 00000000080481a4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样却说没有找到入口符号 <code>_start</code>，难道 <code>crt1.o</code> 中定义了这个符号？不过它给默认设置了一个地址，只是个警告，说明 <code>test</code> 已经生成，不管怎样先运行看看再说。</p><pre class="line-numbers language-bash"><code class="language-bash">$ ./testhello, world<span class="token operator">!</span>Segmentation fault<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>貌似程序运行完了，不过结束时冒出个段错误？可能是程序结束时有问题，用 <code>gdb</code> 调试看看：</p><pre class="line-numbers language-bash"><code class="language-bash">$ gcc -g -c test.c myprintf.c <span class="token comment" spellcheck="true">#产生目标代码, 非交叉编译，不指定-m也可链接，所以下面可去掉-m</span>$ ld -dynamic-linker /lib/ld-linux.so.2 -o <span class="token function">test</span> \     test.o myprintf.o -L/usr/lib -lcld: warning: cannot <span class="token function">find</span> entry symbol _start<span class="token punctuation">;</span> defaulting to 00000000080481d8$ ./testhello, world<span class="token operator">!</span>Segmentation fault$ gdb -q ./test<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> l1       <span class="token comment" spellcheck="true">#include "test.h"</span>23       int main<span class="token punctuation">(</span><span class="token punctuation">)</span>4       <span class="token punctuation">{</span>5               myprintf<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>6               <span class="token keyword">return</span> 0<span class="token punctuation">;</span>7       <span class="token punctuation">}</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> <span class="token keyword">break</span> 7      <span class="token comment" spellcheck="true">#在程序的末尾设置一个断点</span>Breakpoint 1 at 0x80481bf: <span class="token function">file</span> test.c, line 7.<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> r            <span class="token comment" spellcheck="true">#程序都快结束了都没问题，怎么会到最后出个问题呢？</span>Starting program: /mnt/hda8/Temp/c/program/testhello, world<span class="token operator">!</span>Breakpoint 1, main <span class="token punctuation">(</span><span class="token punctuation">)</span> at test.c:77       <span class="token punctuation">}</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> n        <span class="token comment" spellcheck="true">#单步执行看看，怎么下面一条指令是0x00000001，肯定是程序退出以后出了问题</span>0x00000001 <span class="token keyword">in</span> ?? <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> n        <span class="token comment" spellcheck="true">#诶，当然找不到边了，都跑到0x00000001了</span>Cannot <span class="token function">find</span> bounds of current <span class="token keyword">function</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> cContinuing.Program received signal SIGSEGV, Segmentation fault.0x00000001 <span class="token keyword">in</span> ?? <span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原来是这么回事，估计是 <code>return 0</code> 返回之后出问题了，看看它的汇编去。</p><pre class="line-numbers language-assembly"><code class="language-assembly">$ gcc -S test.c #产生汇编代码$ cat test.s...        call    myprintf        movl    $0, %eax        addl    $4, %esp        popl    %ecx        popl    %ebp        leal    -4(%ecx), %esp        ret...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>后面就这么几条指令，难不成 <code>ret</code> 返回有问题，不让它 <code>ret</code> 返回，把 <code>return</code> 改成 <code>_exit</code> 直接进入内核退出。</p><pre class="line-numbers language-bash"><code class="language-bash">$ vim test.c$ <span class="token function">cat</span> test.c    <span class="token comment" spellcheck="true">#就把return语句修改成_exit了。</span><span class="token comment" spellcheck="true">#include "test.h"</span><span class="token comment" spellcheck="true">#include &lt;unistd.h> /* _exit */</span>int main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    myprintf<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    _exit<span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>$ gcc -g -c test.c myprintf.c$ ld -dynamic-linker /lib/ld-linux.so.2 -o <span class="token function">test</span> test.o myprintf.o -L/usr/lib -lcld: warning: cannot <span class="token function">find</span> entry symbol _start<span class="token punctuation">;</span> defaulting to 00000000080481d8$ ./test    <span class="token comment" spellcheck="true">#竟然好了，再看看汇编有什么不同</span>hello, world<span class="token operator">!</span>$ gcc -S test.c$ <span class="token function">cat</span> test.s    <span class="token comment" spellcheck="true">#貌似就把ret指令替换成了_exit函数调用，直接进入内核，让内核处理了，那为什么ret有问题呢？</span><span class="token punctuation">..</span>.        call    myprintf        subl    <span class="token variable">$12</span>, %esp        pushl   <span class="token variable">$0</span>        call    _exit<span class="token punctuation">..</span>.$ gdb -q ./test    <span class="token comment" spellcheck="true">#把代码改回去（改成return 0;），再调试看看调用main函数返回时的下一条指令地址eip</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> lwarning: Source <span class="token function">file</span> is <span class="token function">more</span> recent than executable.1       <span class="token comment" spellcheck="true">#include "test.h"</span>23       int main<span class="token punctuation">(</span><span class="token punctuation">)</span>4       <span class="token punctuation">{</span>5               myprintf<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>6               <span class="token keyword">return</span> 0<span class="token punctuation">;</span>7       <span class="token punctuation">}</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> <span class="token keyword">break</span> 5Breakpoint 1 at 0x80481b5: <span class="token function">file</span> test.c, line 5.<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> <span class="token keyword">break</span> 7Breakpoint 2 at 0x80481bc: <span class="token function">file</span> test.c, line 7.<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> rStarting program: /mnt/hda8/Temp/c/program/testBreakpoint 1, main <span class="token punctuation">(</span><span class="token punctuation">)</span> at test.c:55               myprintf<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x/8x <span class="token variable">$esp</span>0xbf929510:     0xbf92953c      0x080481a4      0x00000000      0xb7eea84f0xbf929520:     0xbf92953c      0xbf929534      0x00000000      0x00000001<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发现 <code>0x00000001</code> 刚好是之前调试时看到的程序返回后的位置，即 <code>eip</code>，说明程序在初始化时，这个 <code>eip</code> 就是错误的。为什么呢？因为根本没有链接进初始化的代码，而是在编译器自己给我们，初始化了程序入口即 <code>00000000080481d8</code>，也就是说，没有人调用 <code>main</code>，<code>main</code> 不知道返回哪里去，所以，我们直接让 <code>main</code> 结束时进入内核调用 <code>_exit</code> 而退出则不会有问题。</p><p>通过上面的演示和解释发现只要把return语句修改为 <code>_exit</code> 语句，程序即使不链接任何额外的目标代码都可以正常运行（原因是不链接那些额外的文件时相当于没有进行初始化操作，如果在程序的最后执行 <code>ret</code> 汇编指令，程序将无法获得正确的 <code>eip</code>，从而无法进行后续的动作）。但是为什么会有“找不到 <code>_start</code> 符号”的警告呢？通过 <code>readelf -s</code> 查看 <code>crt1.o</code> 发现里头有这个符号，并且 <code>crt1.o</code> 引用了 <code>main</code> 这个符号，是不是意味着会从 <code>_start</code> 进入 <code>main</code> 呢？是不是程序入口是 <code>_start</code>，而并非 <code>main</code> 呢？</p><h3 id="C-语言程序真正的入口"><a href="#C-语言程序真正的入口" class="headerlink" title="C 语言程序真正的入口"></a>C 语言程序真正的入口</h3><p>先来看看刚才提到的链接器的默认链接脚本（<code>ld -m elf_386 --verbose</code>），它告诉我们程序的入口（entry）是 <code>_start</code>，而一个可执行文件必须有一个入口地址才能运行，所以这就是说明了为什么 <code>ld</code> 一定要提示我们 “_start找不到”，找不到以后就给默认设置了一个地址。</p><pre class="line-numbers language-bash"><code class="language-bash">$ ld --verbose  <span class="token operator">|</span> <span class="token function">grep</span> ^ENTRY    <span class="token comment" spellcheck="true">#非交叉编译，可不用-m参数；ld默认找_start入口，并不是main</span>ENTRY<span class="token punctuation">(</span>_start<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>原来是这样，程序的入口（entry）竟然不是 <code>main</code> 函数，而是 <code>_start</code>。那干脆把汇编里头的 <code>main</code> 给改掉算了，看行不行？</p><p>先生成汇编 <code>test.s</code>：</p><pre class="line-numbers language-c"><code class="language-c">$ cat test<span class="token punctuation">.</span>c<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"test.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span>     </span><span class="token comment" spellcheck="true">/* _exit */</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">myprintf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>$ gcc <span class="token operator">-</span>S test<span class="token punctuation">.</span>c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后把汇编中的 <code>main</code> 改为 <code>_start</code>，即改程序入口为 <code>_start</code>：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sed</span> -i -e <span class="token string">"s#main#_start#g"</span> test.s$ gcc -c test.s myprintf.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>重新链接，发现果然没问题了：</p><pre class="line-numbers language-bash"><code class="language-bash">$ ld -dynamic-linker /lib/ld-linux.so.2 -o <span class="token function">test</span> test.o myprintf.o -L/usr/lib/ -lc$ ./testhello, world<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>_start</code> 竟然是真正的程序入口，那在有 <code>main</code> 的情况下呢？为什么在 <code>_start</code> 之后能够找到 <code>main</code> 呢？这个看看 alert7 大叔的<a href="http://blog.chinaunix.net/uid-21471835-id-441223.html">Before main 分析</a>吧，这里不再深入介绍。</p><p>总之呢，通过修改程序的 <code>return</code> 语句为 <code>_exit(0)</code> 和修改程序的入口为 <code>_start</code>，我们的代码不链接 <code>gcc</code> 默认链接的那些额外的文件同样可以工作得很好。并且打破了一个学习 C 语言以来的常识：<code>main</code> 函数作为程序的主函数，是程序的入口，实际上则不然。</p><h3 id="链接脚本初次接触"><a href="#链接脚本初次接触" class="headerlink" title="链接脚本初次接触"></a>链接脚本初次接触</h3><p>再补充一点内容，在 <code>ld</code> 的链接脚本中，有一个特别的关键字 <code>PROVIDE</code>，由这个关键字定义的符号是 <code>ld</code> 的预定义字符，我们可以在 C 语言函数中扩展它们后直接使用。这些特别的符号可以通过下面的方法获取，</p><pre class="line-numbers language-bash"><code class="language-bash">$ ld --verbose <span class="token operator">|</span> <span class="token function">grep</span> PROVIDE <span class="token operator">|</span> <span class="token function">grep</span> -v HIDDEN  PROVIDE <span class="token punctuation">(</span>__executable_start <span class="token operator">=</span> 0x08048000<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">.</span> <span class="token operator">=</span> 0x08048000 + SIZEOF_HEADERS<span class="token punctuation">;</span>  PROVIDE <span class="token punctuation">(</span>__etext <span class="token operator">=</span> .<span class="token punctuation">)</span><span class="token punctuation">;</span>  PROVIDE <span class="token punctuation">(</span>_etext <span class="token operator">=</span> .<span class="token punctuation">)</span><span class="token punctuation">;</span>  PROVIDE <span class="token punctuation">(</span>etext <span class="token operator">=</span> .<span class="token punctuation">)</span><span class="token punctuation">;</span>  _edata <span class="token operator">=</span> <span class="token keyword">.</span><span class="token punctuation">;</span> PROVIDE <span class="token punctuation">(</span>edata <span class="token operator">=</span> .<span class="token punctuation">)</span><span class="token punctuation">;</span>  _end <span class="token operator">=</span> <span class="token keyword">.</span><span class="token punctuation">;</span> PROVIDE <span class="token punctuation">(</span>end <span class="token operator">=</span> .<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里面有几个我们比较关心的，第一个是程序的入口地址 <code>__executable_start</code>，另外三个是 <code>etext</code>，<code>edata</code>，<code>end</code>，分别对应程序的代码段（text）、初始化数据（data）和未初始化的数据（bss）（可参考<code>man etext</code>），如何引用这些变量呢？看看这个例子。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* predefinevalue.c */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">extern</span> <span class="token keyword">int</span> __executable_start<span class="token punctuation">,</span> etext<span class="token punctuation">,</span> edata<span class="token punctuation">,</span> end<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"program entry: 0x%x \n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>__executable_start<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"etext address(text segment): 0x%x \n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>etext<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"edata address(initilized data): 0x%x \n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>edata<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"end address(uninitilized data): 0x%x \n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到这里，程序链接过程的一些细节都介绍得差不多了。在后续中将主要介绍 ELF 文件的动态符号链接过程。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.ibm.com/developerworks/cn/linux/l-assembly/index.html">Linux 汇编语言开发指南</a></li><li><a href="http://www.ibm.com/developerworks/cn/linux/hardware/ppc/assembly/index.html">PowerPC 汇编</a></li><li><a href="http://www.ibm.com/developerworks/cn/linux/l-powasm1.html">用于 Power 体系结构的汇编语言</a></li><li><a href="http://www.ibm.com/developerworks/cn/linux/sdk/assemble/inline/index.html">Linux 中 x86 的内联汇编</a></li><li>Linux Assembly HOWTO</li><li>Linux Assembly Language Programming</li><li>Guide to Assembly Language Programming in Linux</li><li><a href="http://www.luv.asn.au/overheads/compile.html">An beginners guide to compiling programs under Linux</a></li><li><a href="http://gcc.gnu.org/onlinedocs/gcc-4.2.2/gcc/">gcc manual</a></li><li><a href="http://efrw01.frascati.enea.it/Software/Unix/IstrFTU/cern-cnl-2001-003-25-link.html">A Quick Tour of Compiling, Linking, Loading, and Handling Libraries on Unix</a></li><li><a href="http://www.ibm.com/developerworks/cn/aix/library/au-unixtools.html">Unix 目标文件初探</a></li><li><a href="http://www.xfocus.net/articles/200109/269.html">Before main()分析</a></li><li><a href="http://www.linuxforums.org/forum/linux-kernel/51790-process-viewing-its-own-proc-pid-map-information.html">A Process Viewing Its Own /proc//map Information</a></li><li>UNIX 环境高级编程</li><li>Linux Kernel Primer</li><li><a href="http://www.linuxforums.org/misc/understanding_elf_using_readelf_and_objdump.html">Understanding ELF using readelf and objdump</a></li><li><a href="http://netwinder.osuosl.org/users/p/patb/public_html/elf_relocs.html">Study of ELF loading and relocs</a></li><li>ELF file format and ABI<ul><li><a href="http://refspecs.linuxbase.org/elf/elf.pdf">[1]</a></li><li><a href="http://www.muppetlabs.com/~breadbox/software/ELF.txt">[2]</a></li></ul></li><li>TN05.ELF.Format.Summary.pdf</li><li><a href="http://www.xfocus.net/articles/200105/174.html">ELF文件格式(中文)</a></li><li>关于 GCC 方面的论文，请查看历年的会议论文集<ul><li><a href="http://www.gccsummit.org/2005/2005-GCC-Summit-Proceedings.pdf">2005</a></li><li><a href="http://www.gccsummit.org/2006/2006-GCC-Summit-Proceedings.pdf">2006</a></li></ul></li><li><a href="http://www.faqs.org/docs/Linux-HOWTO/GCC-HOWTO.html">The Linux GCC HOW TO</a></li><li><a href="http://linux.jinr.ru/usoft/WWW/www_debian.org/Documentation/elf/elf.html">ELF: From The Programmer’s Perspective</a></li><li><a href="http://www.xxlinux.com/linux/article/development/soft/20070424/8267.html">C/C++ 程序编译步骤详解</a></li><li><a href="http://c-faq-chn.sourceforge.net/ccfaq/index.html">C 语言常见问题集</a></li><li><a href="http://elfhack.whitecell.org/mydocs/use_bfd.txt">使用 BFD 操作 ELF</a></li><li><a href="http://sourceware.org/binutils/docs/bfd/index.html">bfd document</a></li><li><a href="http://blog.chinaunix.net/u/19881/showart_215242.html">UNIX/LINUX 平台可执行文件格式分析</a></li><li><a href="http://www.tinylab.org/linux-assembly-language-quick-start/">Linux 汇编语言快速上手：4大架构一块学</a></li><li>GNU binutils 小结</li></ul>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> C </tag>
            
            <tag> 编程透视 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习笔记(十)</title>
      <link href="posts/64955/"/>
      <url>posts/64955/</url>
      
        <content type="html"><![CDATA[<h2 id="df-du与归档压缩等"><a href="#df-du与归档压缩等" class="headerlink" title="df,du与归档压缩等"></a>df,du与归档压缩等</h2><h3 id="df与du"><a href="#df与du" class="headerlink" title="df与du"></a>df与du</h3><p>df显示可用空间，-h用常见的格式显示出大小</p><p><img src="/posts/64955/1.png" alt="挂载情况"></p><p>du统计文件或者目录的磁盘使用情况，用得比较少。</p><p>这些命令通常是在要扩容和挂载时候才使用，配合fdisk -l和lvextend来使用。</p><a id="more"></a><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p>tar 命令：用来压缩和解压文件。tar本身不具有压缩功能。他是调用压缩功能实现的。十分常用，但可以在使用时候查找就行了，如果是使用VMware Workstation的话，官方会提示你安装Vmware Workstation tools，可以帮助用户虚拟硬件的驱动，鼠标的无缝移出移入，剪贴板共享，共享主机上的文件夹等实用功能，在安装过程中就会使用到tar来解压。</p><ul><li>tar zcfv压缩成.tar.gz文件</li><li>tar zxfv解压.tar.gz文件</li><li>tar Jcfv压缩成.tar.xz文件</li><li>tar Jxfv解压.tar.xz文件</li><li>tar jcfv压缩成.tar.bz2文件</li><li>tar jxfv解压.tar.bz2文件</li></ul><h3 id="chmod类"><a href="#chmod类" class="headerlink" title="chmod类"></a>chmod类</h3><p>chmod修改文件目录的访问权限,每种 MODE 都应属于这类形式[ugoa]+-=rwx</p><ul><li><p>操作对像</p><ul><li>u 文件属主权限</li><li>g 同组用户权限</li><li>o 其它用户权限</li><li>a 所有用户（包括以上三种）</li></ul></li><li><p>权限设定</p><ul><li>+ 增加权限</li><li>- 取消权限</li><li>=  唯一设定权限</li></ul></li><li><p>权限类别(也可以用数字表示，前面出现过)</p><ul><li>r 读权限 ( r–&gt;4)</li><li>w 写权限 ( w–&gt;2)</li><li>x 执行权限 ( x–&gt;1)</li></ul></li></ul><p>相似的，chown修改文件目录的owner,chgrp修改文件目录的group。</p><h2 id="Unix通信"><a href="#Unix通信" class="headerlink" title="Unix通信"></a>Unix通信</h2><h3 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h3><p>因为用的是树莓派4b的原因，在没有配显示器又想无线连接到树莓派的话，必须通过ssh，在此基础上如果想要使用桌面系统的话，则又要使用VNC Viewer与树莓派相连接。</p><p>方法就在这简单描述一下，在烧录完系统后，打开SD卡直接新建SSH文件（无后缀名），随后在配置wpa_supplicant.conf，正常的话开机树莓派就能自动连接到wifi，可以通过路由器管理页面直接查看树莓派分配的ip，直接连接就行了(电脑用的是Putty)，通过ssh远程登陆主机和实体操作没有什么区别，另外ssh在github的配置上也有需求，可以查阅一下资料配置一下。</p><h3 id="接口与状态"><a href="#接口与状态" class="headerlink" title="接口与状态"></a>接口与状态</h3><p>ifconfig用来查看ip地址和网络状态。<br><img src="/posts/64955/2.png" alt="ifconfig"></p><p>ping用来查看与某个网址之间的延迟。<br><img src="/posts/64955/3.png" alt="ping"></p><h3 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h3><p>curl是一个利用URL规则在命令行下工作的文件传输工具。它支持文件的上传和下载，所以是综合传输工具，但按传统，习惯称url为下载工具。</p><p><img src="/posts/64955/4.png" alt="ping"></p><h3 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h3><p>wget是一个下载文件的工具，对于Linux用户是必不可少的工具，我们经常要下载一些软件或从远程服务器恢复备份到本地服务器，同时wget支持断点下载和指定目录下载，同时非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性.如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。是十分实用的一个命令。</p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p>使用wget -O下载并以不同的文件名保存(-O：下载文件到对应目录，并且修改文件名称)</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">wget</span> -O wordpress.zip http://www.minjieren.com/download.aspx?id<span class="token operator">=</span>1080<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用wget -b后台下载</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">wget</span> -b <span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"http://www.minjieren.com/wordpress-3.1-zh_CN.zip"</span><span class="token operator">></span>http://www.minjieren.com/wordpress-3.1-zh_CN.zip<span class="token operator">&lt;</span>/a<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h3><p>文件传输可以在此基础上使用别的软件，如FileZilla Client来传输。</p><h3 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h3><p>systemd 是一个专用于 Linux 操作系统的系统与服务管理器。以mysql为例子。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 开机启动</span>systemctl <span class="token function">enable</span> mysqld<span class="token comment" spellcheck="true"># 关闭开机启动</span>systemctl disable mysqld<span class="token comment" spellcheck="true"># 启动服务</span>systemctl start mysqld<span class="token comment" spellcheck="true"># 停止服务</span>systemctl stop mysqld<span class="token comment" spellcheck="true"># 重启服务</span>systemctl restart mysqld<span class="token comment" spellcheck="true"># 查看服务状态</span>systemctl status mysqldsystemctl is-active sshd.service<span class="token comment" spellcheck="true"># 结束服务进程(服务无法停止时)</span>systemctl <span class="token function">kill</span> mysqld<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>system daemon，代替常用的System V与BSD风格init程序，可以即时发现依赖。</p><ul><li>init采用脚本来加载各种服务，各种服务的依赖难以维持，服务加载速度 慢</li><li>systemd使用c编写的程序接管各种服务加载</li></ul><p>关于systemd的管理对象抽象为单元，详细就不叙述了，感兴趣的话可以man 5 systemd.unit，此外systemd还可以配置服务启动或者自定义服务，但个人觉得掌握上面举的例子就能应付很多情况了，感兴趣可以学习哈。</p><h3 id="Gnu工具链"><a href="#Gnu工具链" class="headerlink" title="Gnu工具链"></a>Gnu工具链</h3><p>Gnu toolchain是开发操作系统、应用程序的一套完整的程序和库，包括gcc、gdb、glibc等。</p><p>其中gcc是一族编译器，包括c、c++、go、java等，</p><ul><li>.c为后缀的文件，C语言源代码文件；</li><li>.a为后缀的文件，是由目标文件构成的档案库文件；</li><li>.C、.cc或.cxx 为后缀的文件，是C++源代码文件；</li><li>.h为后缀的文件，是程序所包含的头文件；</li><li>.i 为后缀的文件，是已经预处理过的C源代码文件；</li><li>.ii为后缀的文件，是已经预处理过的C++源代码文件；</li><li>.m为后缀的文件，是Objective-C源代码文件；</li><li>.o为后缀的文件，是编译后的目标文件；</li><li>.s为后缀的文件，是汇编语言源代码文件；</li><li>.S为后缀的文件，是经过预编译的汇编语言源代码文件。</li></ul><p>C语言编译过程</p><ul><li>gcc -E hello.c -o hello.i</li><li>gcc -S hello.i -o hello.s</li><li>gcc -c hello.s -o hello.o</li><li>gcc -o hello hello.o</li></ul><p><img src="/posts/64955/5.png" alt="ping"></p><h4 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h4><table><thead><tr><th align="left">命令</th><th align="left">缩写</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">list</td><td align="left">l</td><td align="left">打印当前位置源码</td></tr><tr><td align="left">break</td><td align="left">b</td><td align="left">设置断点</td></tr><tr><td align="left">run</td><td align="left">r</td><td align="left">运行程序</td></tr><tr><td align="left">step</td><td align="left">s</td><td align="left">单步进入函数</td></tr><tr><td align="left">next</td><td align="left">n</td><td align="left">单步不进入函数</td></tr><tr><td align="left">print</td><td align="left">p</td><td align="left">打印变量</td></tr><tr><td align="left">continue</td><td align="left">c</td><td align="left">继续运行</td></tr><tr><td align="left">backtrace</td><td align="left">bt</td><td align="left">显示调用栈</td></tr><tr><td align="left">info threads</td><td align="left"></td><td align="left">显示线程</td></tr><tr><td align="left">thread n</td><td align="left"></td><td align="left">切换线程</td></tr><tr><td align="left">set scheduler-locking on</td><td align="left"></td><td align="left">关闭线程调度</td></tr></tbody></table><h4 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h4><p>Makefile用于工程组织和编译，与常见的命令式语言不同，它是一种依赖推导语言。</p><ul><li>Shell语言：变量定义+命令执行</li><li>Makefile：变量定义+依赖描述</li></ul><p>有显式规则与隐式规则，推导规则为检查目标和依赖文件的时间，如果依赖更新，则执行动作，显式规则 &gt; 隐式规则。</p><h4 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h4><p>Cmake在不同平台上生成不同的本地化脚本：Linux下的Gnu Makefile，Visual Studio的sln，Google等ninja</p><p>Cmake管理的代码编译主要有两步：</p><ul><li>利用cmake生成本地编译脚本</li><li>利用本地脚本编译程序</li></ul><h4 id="git"><a href="#git" class="headerlink" title="git"></a>git</h4><p>版本控制系统，是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统，git采用分布式管理，十分推荐学习。</p><p><a href="https://learngitbranching.js.org/?locale=zh_CN">一个非常好的，可视化的学习git的网站</a></p><p><img src="/posts/64955/6.png" alt="ping"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习笔记(九)</title>
      <link href="posts/4083/"/>
      <url>posts/4083/</url>
      
        <content type="html"><![CDATA[<h2 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h2><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p>shell脚本工作原理:</p><ul><li>loader程序加载脚本，发现不是elf可执行文件，返回错误</li><li>bash收到错误，然后打开文件头部，发现是脚本</li><li>调用脚本执行</li></ul><p>几乎所有编程语言的教程都是从使用著名的“Hello World”开始的，我们的第一个 Shell 脚本也输出“Hello World”。</p><a id="more"></a><p>使用vim创建一个新的文本文件，并输入</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span><span class="token keyword">echo</span> <span class="token string">"Hello World !"</span>  <span class="token comment" spellcheck="true">#这是一条语句</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第 1 行的#!是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell；后面的/bin/sh就是指明了解释器的具体位置。然后将文件修改为可执行文件 <code>chmod 777 filename</code> 可以为所有用户赋予读写执行的权限，如果有其他需求修改即可。</p><p>shell的注释以#开头，#后面的内容即为注释</p><h3 id="脚本调试"><a href="#脚本调试" class="headerlink" title="脚本调试"></a>脚本调试</h3><p>在编写较长并且复杂的脚本文件容易出现错误，且脚本文件是非编译程序，不配置的话是不会有编译器差错的。因为只能靠运行程序并尝试解释屏幕显示错误。</p><p>set命令选项</p><table><thead><tr><th align="left">选项</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">-n</td><td align="left">读取命令但不执行，用来检查脚本中的语法错误</td></tr><tr><td align="left">-v</td><td align="left">输出参数替换前的命令</td></tr><tr><td align="left">-x</td><td align="left">输出的是带参数展开后的命令</td></tr></tbody></table><p>如果想要关闭上述命令，将-换为+即可。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>关于变量赋值已经在八中讲过了，现在我们来学习一下怎么进行变量替换操作，既只有某种条件发生时才进行替换,这里举出几个最常用的:</p><table><thead><tr><th align="left">替换操作</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">${value:-word}</td><td align="left">如果变量不存在(或为空)，返回word，否则返回变量的值</td></tr><tr><td align="left">${value:=word}</td><td align="left">如果变量不存在(或为空)，设置VAR变量为word，返回word</td></tr><tr><td align="left">${value:?word}</td><td align="left">如果变量不存在(或为空)，打印message，退出，但交互shell不会退出</td></tr><tr><td align="left">${value:+word}</td><td align="left">如果变量存在，返回word；否则返回null</td></tr></tbody></table><p>删除变量则使用unset VARNAME即可</p><h4 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h4><h4 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h4><p>运行 Shell 脚本文件时我们可以给它传递一些参数，这些参数在脚本文件内部可以使用$n的形式来接收，例如，$1 表示第一个参数，$2 表示第二个参数，依次类推，最多可以有10个命令行参数,如果参数个数太多，达到或者超过了 10 个，那么就得用${n}的形式来接收了，例如 ${10}、${23}。{ }的作用是为了帮助解释器识别参数的边界，这跟使用变量时加{ }是一样的效果。</p><p>同样，在调用函数时也可以传递参数。<strong>Shell 函数参数的传递和其它编程语言不同，没有所谓的形参和实参， 在定义函数时也不用指明参数的名字和数目。</strong> 换句话说，定义 Shell 函数时不能带参数，但是在调用函数时却可以传递参数，这些传递进来的参数，在函数内部就也使用$n的形式接收，例如，$1 表示第一个参数，$2 表示第二个参数，依次类推。</p><p>这种通过$n的形式来接收的参数，在 Shell 中称为位置参数，除了 $n，Shell 中还有 $#、$*、$@、$?、$$ 几个特殊参数。</p><h5 id="给脚本文件传递位置参数"><a href="#给脚本文件传递位置参数" class="headerlink" title="给脚本文件传递位置参数"></a>给脚本文件传递位置参数</h5><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span><span class="token keyword">echo</span> <span class="token string">"Language: <span class="token variable">$1</span>"</span><span class="token keyword">echo</span> <span class="token string">"URL: <span class="token variable">$2</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>运行并附带参数：<br><img src="/posts/4083/1.png"></p><h4 id="给函数传递位置参数"><a href="#给函数传递位置参数" class="headerlink" title="给函数传递位置参数"></a>给函数传递位置参数</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span><span class="token comment" spellcheck="true">#定义函数</span><span class="token keyword">function</span> func<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">"Language: <span class="token variable">$1</span>"</span>    <span class="token keyword">echo</span> <span class="token string">"URL: <span class="token variable">$2</span>"</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">#调用函数</span>func shell https://github.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/posts/4083/2.png"><h4 id="特殊参数"><a href="#特殊参数" class="headerlink" title="特殊参数"></a>特殊参数</h4><table><thead><tr><th align="left">变量</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">$0</td><td align="left">当前脚本的文件名</td></tr><tr><td align="left">$n（n≥1）</td><td align="left">传递给脚本或函数的参数。n 是一个数字，表示第几个参数</td></tr><tr><td align="left">$#</td><td align="left">传递给脚本或函数的参数个数</td></tr><tr><td align="left">$*</td><td align="left">传递给脚本或函数的所有参数,将所有参数使用$IFS隔开，形成一个字符串</td></tr><tr><td align="left">$@</td><td align="left">传递给脚本或函数的所有参数。当被双引号” “包含时，$@ 与 $* 稍有不同</td></tr><tr><td align="left">$?</td><td align="left">上个命令的退出状态，或函数的返回值</td></tr><tr><td align="left">$$</td><td align="left">表示当前进程id</td></tr></tbody></table><p>$* 和 $@ 都表示传递给函数或脚本的所有参数,这里重点区分一下当，$*和 $@ 不被双引号” “包围时，它们之间没有任何区别，都是将接收到的每个参数看做一份数据，彼此之间以空格来分隔。</p><p>但是当它们被双引号” “包含时，就会有区别了：</p><ul><li><code>&quot;$*&quot;</code>会将所有的参数从整体上看做一份数据，而不是把每个参数都看做一份数据。</li><li><code>&quot;$@&quot;</code>仍然将每个参数都看作一份数据，彼此之间是独立的。</li></ul><p>比如传递了 5 个参数，那么对于”$*”来说，这 5 个参数会合并到一起形成一份数据，它们之间是无法分割的；而对于”$@”来说，这 5 个参数是相互独立的，它们是 5 份数据。</p><p>如果使用 echo 直接输出”$*”和”$@”做对比，是看不出区别的；但如果使用 for 循环来逐个输出数据，立即就能看出区别来,这里先提前使用for循环，如果不了解的话请在学习后再来回顾。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span><span class="token keyword">echo</span> <span class="token string">"print each param from \"\<span class="token variable">$*</span>\""</span><span class="token keyword">for</span> var <span class="token keyword">in</span> <span class="token string">"<span class="token variable">$*</span>"</span><span class="token keyword">do</span>    <span class="token keyword">echo</span> <span class="token string">"<span class="token variable">$var</span>"</span><span class="token keyword">done</span><span class="token keyword">echo</span> <span class="token string">"print each param from \"\<span class="token variable">$@</span>\""</span><span class="token keyword">for</span> var <span class="token keyword">in</span> <span class="token string">"<span class="token variable">$@</span>"</span><span class="token keyword">do</span>    <span class="token keyword">echo</span> <span class="token string">"<span class="token variable">$var</span>"</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/4083/3.png" alt="例子"></p><p>$? 获取上一个命令的退出状态,所谓退出状态，就是上一个命令执行后的返回结果。退出状态是一个数字，一般情况下，大部分命令执行成功会返回 0，失败返回 1，这和C语言的 main() 函数是类似的,除了用于获取上一个命令退出状态外，还可以用来获取函数的返回值。这里仅讲获取函数的返回值，前一种情况类比即可。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment" spellcheck="true">#得到两个数相加的和</span><span class="token keyword">function</span> add<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">expr</span> $1 + $2<span class="token variable">)</span></span><span class="token punctuation">}</span>add 23 50  <span class="token comment" spellcheck="true">#调用函数</span><span class="token keyword">echo</span> <span class="token variable">$?</span>  <span class="token comment" spellcheck="true">#获取函数返回值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算术表达式"><a href="#算术表达式" class="headerlink" title="算术表达式"></a>算术表达式</h4><p>Shell中变量都是字符串，计算算术的时候使用$(())作为算术表达式并获取值(注意，双小括号运算仅在Bash shell中运行)，否则将视作两个字符串操作。</p><p><code>echo $((3+2))</code></p><p>除了算术运算外还可以进行逻辑运算，规则与其他编程语言相同，不再累述了（值得注意的是对于字符串而言=也可以表示等于）。</p><h4 id="逻辑连接"><a href="#逻辑连接" class="headerlink" title="逻辑连接"></a>逻辑连接</h4><p>使用&amp;&amp;和||连接两条命令,&amp;&amp;表示and,||表示or,相似的，在shell中也有逻辑短路。</p><ul><li>Command1 &amp;&amp; command2，当command1正确执行，才会执行command2</li><li>Command1 || command2，当command1执行错误，才会执行command2</li></ul><h4 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h4><p>eval命令将会首先扫描命令行进行所有的替换，然后再执行命令。该命令使用于那些一次扫描无法实现其功能的变量。该命令对变量进行两次扫描。这些需要进行两次扫描的变量有时候被称为复杂变量，eval告诉shell再跑一遍命令解释流程。</p><p><code>eval echo \$$# 取得最后一个参数</code></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cat</span> last<span class="token function">eval</span> <span class="token keyword">echo</span> \$$<span class="token comment" spellcheck="true">#</span>./last one two three fourfour<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>第一遍扫描后，shell把反斜杠去掉了。当shell再次扫描该行时，它替换了$4的值，并执行echo命令。</p><h3 id="shift"><a href="#shift" class="headerlink" title="shift"></a>shift</h3><p>位置参数可以用shift命令左移。比如shift 3表示原来的$4现在变成$1，原来的$5现在变成$2等等，原来的$1、$2、$3丢弃，$0不移动。不带参数的shift命令相当于shift 1。</p><p>我们知道，对于位置变量或命令行参数，其个数必须是确定的，或者当 Shell 程序不知道其个数时，可以把所有参数一起赋值给变量$*。若用户要求 Shell 在不知道位置变量个数的情况下，还能逐个的把参数一一处理，也就是在 $1 后为 $2,在 $2 后面为 $3 等。在 shift 命令执行前变量 $1 的值在 shift 命令执行后就不可用了。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">until</span> <span class="token punctuation">[</span> $<span class="token comment" spellcheck="true"># -eq 0 ]</span><span class="token keyword">do</span><span class="token keyword">echo</span> <span class="token string">"第一个参数为: <span class="token variable">$1</span> 参数个数为: <span class="token variable">$#</span>"</span><span class="token function">shift</span><span class="token keyword">done</span>执行以上程序x_shift.sh：./x_shift.sh 1 2 3 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果显示如下：</p><p>第一个参数为: 1 参数个数为: 4<br>第一个参数为: 2 参数个数为: 3<br>第一个参数为: 3 参数个数为: 2<br>第一个参数为: 4 参数个数为: 1</p><h3 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h3><p>语法格式为:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">if</span> 条件<span class="token punctuation">;</span> <span class="token keyword">then</span>    <span class="token function">command</span> lines<span class="token punctuation">[</span>elif 条件    <span class="token function">command</span> lines<span class="token punctuation">]</span><span class="token punctuation">[</span>else    <span class="token function">command</span> lines<span class="token punctuation">]</span><span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>条件是一段命令，测试的是$?是否是0,为0满足条件,条件外面的括号是必须的，且条件必须用空格包围起来。</p><h4 id="测试条件"><a href="#测试条件" class="headerlink" title="测试条件"></a>测试条件</h4><h5 id="测试字符串表达式"><a href="#测试字符串表达式" class="headerlink" title="测试字符串表达式"></a>测试字符串表达式</h5><p>[]和test是等价的</p><p>逻辑运算符有：</p><ul><li>-a与运算符</li><li>-o或运算符</li><li>-!非运算符</li></ul><table><thead><tr><th align="left">操作符</th><th align="left">示例</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">“$STR1” = “STR2”</td><td align="left">两个字符串是否相同</td></tr><tr><td align="left">!=</td><td align="left">“$STR1” != “STR2”</td><td align="left">两个字符串是否不同</td></tr><tr><td align="left">-n</td><td align="left">-n “$STR”</td><td align="left">字符串不是null</td></tr><tr><td align="left">-z</td><td align="left">-z “$STR”</td><td align="left">字符串是null</td></tr></tbody></table><p>在引用变量做字符串测试时，一定要加引号(保证正确的检验)，操作符两侧必须有空格，[ … ]中括号必须有空格</p><h5 id="文件测试表达式"><a href="#文件测试表达式" class="headerlink" title="文件测试表达式"></a>文件测试表达式</h5><table><thead><tr><th align="left">操作符</th><th align="left">示例</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-r</td><td align="left">-r filename</td><td align="left">文件是否可读</td></tr><tr><td align="left">-w</td><td align="left">-w filename</td><td align="left">文件是否可写</td></tr><tr><td align="left">-s</td><td align="left">-s filename</td><td align="left">文件是否存在并且长度非0</td></tr><tr><td align="left">-f</td><td align="left">-f filename</td><td align="left">文件是否为普通文件</td></tr><tr><td align="left">-d</td><td align="left">-d filename</td><td align="left">文件是否为目录文件</td></tr></tbody></table><p>例子：[ -e /var/log/syslog ] 判断是否存在</p><h5 id="算术表达式测试"><a href="#算术表达式测试" class="headerlink" title="算术表达式测试"></a>算术表达式测试</h5><p>利用$(())计算算算术表达式</p><p>即[ $((2+3)) = 5 ]</p><p>例</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span><span class="token function">printf</span> <span class="token string">"Are you ok?\n"</span><span class="token function">printf</span> <span class="token string">"Input y for yes and no for no: "</span><span class="token function">read</span> ANSWER<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$ANSWER</span>"</span> <span class="token operator">=</span> y <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>    <span class="token function">printf</span> <span class="token string">"Glad to hear that!\n"</span><span class="token keyword">else</span>    <span class="token function">printf</span> <span class="token string">"Go home!\n"</span><span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">case</span> <span class="token variable">$1</span> <span class="token keyword">in</span>    -f<span class="token punctuation">)</span>        … <span class="token punctuation">;</span><span class="token punctuation">;</span>    -d <span class="token operator">|</span> --directory<span class="token punctuation">)</span>        … <span class="token punctuation">;</span><span class="token punctuation">;</span>    *<span class="token punctuation">)</span>        … <span class="token punctuation">;</span><span class="token punctuation">;</span>esac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>case、in 和 esac 都是 Shell 关键字，;;和*)就相当于其它编程语言中的 break 和 default。</p><p>例子</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#! /bin/sh</span><span class="token function">printf</span> <span class="token string">"Are you ok?\n"</span><span class="token function">printf</span> <span class="token string">"Input y for yes and no for no: "</span><span class="token function">read</span> ANSWER<span class="token keyword">case</span> <span class="token variable">$ANSWER</span> <span class="token keyword">in</span>    <span class="token punctuation">[</span>Yy<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">printf</span> <span class="token string">"Glad to hear that!\n"</span><span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token punctuation">[</span>Nn<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">printf</span> <span class="token string">"Go home!\n"</span><span class="token punctuation">;</span><span class="token punctuation">;</span>       *<span class="token punctuation">)</span> <span class="token function">printf</span> <span class="token string">"No such option\n"</span><span class="token punctuation">;</span><span class="token punctuation">;</span>esac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>case in 的 pattern 部分支持简单的正则表达式，具体来说，可以使用以下几种格式：</p><table><thead><tr><th align="left">格式</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">*</td><td align="left">表示任意字符串。</td></tr><tr><td align="left">[abc]</td><td align="left">表示 a、b、c 三个字符中的任意一个。比如，[15ZH] 表示 1、5、Z、H 四个字符中的任意一个</td></tr><tr><td align="left">[m-n]</td><td align="left">表示从 m 到 n 的任意一个字符。比如，[0-9] 表示任意一个数字，[0-9a-zA-Z] 表示字母或数字</td></tr><tr><td align="left">|</td><td align="left">表示多重选择，类似逻辑运算中的或运算。比如，abc</td></tr></tbody></table><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>for循环有C风格的循环也有Python风格的for in循环，这里介绍后者。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">for</span> variable <span class="token keyword">in</span> list-of-values<span class="token punctuation">;</span> <span class="token keyword">do</span>…<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>list-of-values用$IFS隔开，缺省是空格、tab、回车,例子如下</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#! /bin/sh</span><span class="token keyword">for</span> count <span class="token keyword">in</span> 1 2 3<span class="token punctuation">;</span> <span class="token keyword">do</span><span class="token keyword">echo</span> “In the loop <span class="token keyword">for</span> <span class="token variable">$count</span> times”<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>while循环格式如:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">while</span> <span class="token punctuation">[</span> condition <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">do</span>…<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>[ condition ]等价于前述的test命令,例子如下</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#! /bin/sh</span>count<span class="token operator">=</span>1<span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token variable"><span class="token variable">$((</span>count <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token variable">))</span></span> <span class="token operator">=</span> “1” <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">do</span><span class="token keyword">echo</span> <span class="token variable">$count</span>count<span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span>count<span class="token operator">+</span><span class="token number">1</span><span class="token variable">))</span></span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="until循环"><a href="#until循环" class="headerlink" title="until循环"></a>until循环</h4><p>Until循环的格式如下,Until表示条件为假时，执行循环体</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">until</span> <span class="token punctuation">[</span> condition <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">do</span>…<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>例子如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#! /bin/sh</span>count<span class="token operator">=</span>1<span class="token keyword">until</span> <span class="token punctuation">[</span> <span class="token variable"><span class="token variable">$((</span>count <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token variable">))</span></span> <span class="token operator">=</span> “0” <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">do</span><span class="token keyword">echo</span> <span class="token variable">$count</span>count<span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span>count<span class="token operator">+</span><span class="token number">1</span><span class="token variable">))</span></span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数已经在前面中出现过了，函数引用类似于普通命令，但是函数执行类似于内置命令，不会新fork一个shell。</p><p>Shell 函数定义的语法格式如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">function</span> name<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    statements    <span class="token punctuation">[</span>return value<span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>调用 Shell 函数时可以给它传递参数，也可以不传递。如果不传递参数，直接给出函数名字即可,如果传递参数，那么多个参数之间以空格分隔，不管是哪种形式，函数名字后面都不需要带括号，和其它编程语言不同的是，Shell 函数在定义时不能指明参数，但是在调用时却可以传递参数，并且给它传递什么参数它就接收什么参数。</p><p>Shell 也不限制定义和调用的顺序，你可以将定义放在调用的前面，也可以反过来，将定义放在调用的后面。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习笔记(八)</title>
      <link href="posts/24357/"/>
      <url>posts/24357/</url>
      
        <content type="html"><![CDATA[<h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p>Unix操作系统分为两个部分：内核和应用，内核是UNIX系统的核心并且驻留内存，日常事务比如直接与硬件通信等都由内核完成。除了内核，有一些基本模块也是驻留内存的，这些模块完成重要的功能，比如输入/输出管理，文件管理内存管理等待。</p><p>Unix系统的其他部分保存在磁盘中，在需要时调入内存，绝大多数UNIX命令时保存在磁盘上的程序，在需要时调入内存，在用户输入一个命令时相应的程序就被调入内存。</p><a id="more"></a><p>Shell 是一个应用程序，它连接了用户和 Linux 内核，让用户能够更加高效、安全、低成本地使用 Linux 内核，这就是 Shell 的本质。Shell 本身并不是内核的一部分，它只是站在内核的基础上编写的一个应用程序，然而 Shell 也有着它的特殊性，就是开机立马启动，并呈现在用户面前；用户通过 Shell 来使用 Linux，不启动 Shell 的话，用户就没办法使用 Linux。</p><p>sehll可以用来执行命令，文件名替换，I/O重定向和管道符处理，环境控制，后台计算以及运行shell脚本，/etc/passwd决定了用户登录后执行的shell程序,有些特殊的用户，可以不是shell程序</p><h3 id="shell解析用户命令和进程的退出"><a href="#shell解析用户命令和进程的退出" class="headerlink" title="shell解析用户命令和进程的退出"></a>shell解析用户命令和进程的退出</h3><ul><li><p>shell解析用户命令</p><ul><li>创建子进程执行用户命令</li><li>shell等待命令子进程退出</li><li>命令子进程退出，发送SIGCHLD信号给shell</li><li>shell在信号处理函数中处理子进程退出</li></ul></li><li><p>shell进程退出</p><ul><li>发送SIGCHLD信号给login进程</li><li>login进程处理SIGCHLD信号</li><li>退出，发送SIGCHLD信号给init进程</li><li>init进程处理SIGCHLD信号，重新fork/exec一个getty进程</li></ul></li></ul><img src="/posts/24357/1.png"><h3 id="shell语言"><a href="#shell语言" class="headerlink" title="shell语言"></a>shell语言</h3><p>Shell 命令的基本格式如下：</p><p>command [选项] [参数],与前面所学的命令十分相像,如果有多行单条命令，则要在行尾以<code>\</code>结束，shell也有扩展符，大体上与C相似，就不复述了。</p><p>shell的命令解析过程：</p><p><img src="/posts/24357/3.png" alt="解析过程"></p><ul><li>完整的命令解析过程<ul><li>tilde是~表达式展开</li><li>变量替换</li><li>命令展开是重音符的命令展开</li><li>单词划分利用$IFS变量分割</li><li>寻找命令</li></ul></li></ul><h4 id="显示信息echo"><a href="#显示信息echo" class="headerlink" title="显示信息echo"></a>显示信息echo</h4><p>echo用来显示信息到终端上，如果需要格式化输出请使用printf</p><p><code>echo hello there</code></p><img src="/posts/24357/2.png"><p>有些shell的元字符对shell来说有特殊含义，这时候就有引用字符来消除元字符的特殊含义，除了反斜杠外还提供了：<code>&#39; &#39;</code> ,<code>&quot; &quot;</code>。</p><p><code>双引号:</code>双引号可以忽略大多数字符的特殊意义，除了 <strong>$,单引号和双引号</strong>，此外双引号还保留了空白字符。</p><p><code>单引号：</code>单引号在双引号基础上加强了，除了单引号外，任何符合的特殊意义都被消除，单引号同样保留空白符，除此之外还有一个非常重要的特性，包含在单引号的字符串变成1个单个的参数，空格也失去了作为参数分隔符的含义。</p><h3 id="shell变量"><a href="#shell变量" class="headerlink" title="shell变量"></a>shell变量</h3><p>变量是任何一种编程语言都必不可少的组成部分，变量用来存放各种数据。脚本语言在定义变量时通常不需要指明类型，直接赋值就可以，Shell 变量也遵循这个规则。</p><p>在 Bash shell 中，每一个变量的值都是字符串，无论你给变量赋值时有没有使用引号，值都会以字符串的形式存储。</p><p>这意味着，Bash shell 在默认情况下不会区分变量类型，即使你将整数和小数赋值给变量，它们也会被视为字符串，这一点和大部分的编程语言不同。例如在C语言或者 C++ 中，变量分为整数、小数、字符串、布尔等多种类型。</p><h4 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h4><p>shell中的变量分为环境变量和局部变量，其中环境变量也被称为标准变量，拥有为系统所知道的变量名，被用于定义系统基本的特征，环境变量会传递给子进程(fork)。而局部变量就由用户自定义使用。</p><p>set命令显示所有变量，export命令显示所有环境变量。</p><p>Shell 支持以下三种定义变量的方式，注意，三种的等号两侧都是不能有空格的</p><ul><li>variable=value</li><li>variable=’value’</li><li>variable=”value”</li></ul><p>export VAR=xxx则用于添加环境变量</p><h4 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h4><p>使用一个定义过的变量，只要在变量名前面加美元符号$即可，如：</p><pre class="line-numbers language-bash"><code class="language-bash">author<span class="token operator">=</span><span class="token string">"aaa"</span><span class="token keyword">echo</span> <span class="token variable">$author</span><span class="token keyword">echo</span> <span class="token variable">${author}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>变量名外面的花括号{ }是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，推荐都加上，这是个良好的编程习惯.</p><p>其中有一些标准变量：</p><ul><li>HOME变量记录用户主目录</li><li>PATH变量给出外部程序的搜索路径，在win中也有类似的存在</li><li>IFS变量定义扩展命令参数时的分隔符</li></ul><h4 id="命令参数展开"><a href="#命令参数展开" class="headerlink" title="命令参数展开"></a>命令参数展开</h4><p>shell在解释命令时，有一个重要的步骤是展开变量得到命令参数</p><p>例如 <code>ls -al *</code></p><ul><li>shell在解释这条命令时<ul><li>ls是命令，special builtins 到functions 到builtins 到export command去查找</li><li>-al是参数</li><li>*需要展开</li></ul></li></ul><p>shell内部将对参数的展开：</p><ul><li>-开头当成选项</li><li>双引号、单引号、重音符号开头作为字符串</li><li>$开头作为变量</li><li>&lt;&gt;作为重定向符号</li><li>|作为管道符号</li><li>其余字符串如果包含*?[]需要做路径匹配展开</li></ul><h4 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h4><p>以单引号’ ‘包围变量的值时，单引号里面是什么就输出什么，即使内容中有变量和命令（命令需要反引起来）也会把它们原样输出。这种方式比较适合定义显示纯字符串的情况，即不希望解析变量、命令等的场景。</p><p>以双引号” “包围变量的值时，输出时会先解析里面的变量和命令，而不是把双引号中的变量名和命令原样输出。这种方式比较适合字符串中附带有变量和命令并且想将其解析后再输出的变量定义。</p><p>重音符号表示一个内嵌命令，要先执行，然后得到输出作为参数，双引号内的重音符号要先执行。<code>$()</code>也可以实现同样的效果，而且从视觉上说不容易与单引号和重音符号弄混淆。</p><p>有一个建议：</p><p><strong>如果变量的内容是数字，那么可以不加引号；如果真的需要原样输出就加单引号；其他没有特别要求的字符串等最好都加上双引号，定义变量时加双引号是最常见的使用场景。</strong></p><p>除了单引号双引号重音符号外，还可以使用分号进行命令排序或者使用括号进行命令编组，需要后台运行的话，使用&amp;符号，后面会有介绍。</p><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><p>在学习后台运行之前，先来学习如何管理进程，ps命令显示用户当前活动进程的信息，如果学会了systemd的话可以一起配合使用(自行了解)。</p><ul><li>PID:进程ID数</li><li>TTY:控制该进程的用户终端号</li><li>TIME:用户进程以及运行的时间(以秒计)</li><li>COMMAND:命令名称</li></ul><table><thead><tr><th align="left">参数</th><th align="left">选项</th></tr></thead><tbody><tr><td align="left">-a</td><td align="left">显示所有终端机下执行的进程，除了阶段作业领导者之外，不包括无终端进程。</td></tr><tr><td align="left">-f</td><td align="left">显示UID,PPIP,C与STIME栏位。</td></tr><tr><td align="left">-e</td><td align="left">显示所有进程。</td></tr><tr><td align="left">-H</td><td align="left">按照树型显示</td></tr><tr><td align="left">-j</td><td align="left">按照job形式输出</td></tr></tbody></table><img src="/posts/24357/4.png"><h4 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h4><p><code>nohup “command”&amp;</code></p><p>如果想要在用户退出系统后继续执行后台进程，则可以使用nohup命令，他可以让进程免于被终止信号终止，了解即可。</p><h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h4><p>在知道如何查看用户进程后，就可以使用kill来停止那些想要停止的程序，kill命令通过向进程发送信号来控制，默认发送的信号为15（SIGTERM）信号,强制停止的话，则使用9(SIGKILL)信号。</p><p>信号类似于硬件中断，Ctrl-c快捷键类似发送SIGINT信号，而Ctrl-d类似发送EOF，意思是输入关闭。</p><table><thead><tr><th align="left">参数</th><th align="left">选项</th></tr></thead><tbody><tr><td align="left">-l</td><td align="left">列出所有信号</td></tr><tr><td align="left">-1</td><td align="left">除了init进程和自身外关闭所有进程</td></tr><tr><td align="left">-s</td><td align="left">指定发送信号</td></tr><tr><td align="left">-u</td><td align="left">指定用户</td></tr></tbody></table><img src="/posts/24357/5.png"><h4 id="trap"><a href="#trap" class="headerlink" title="trap"></a>trap</h4><p>trap是一个shell内建命令，它用来在脚本中指定信号如何处理。比如，按Ctrl+C会使脚本终止执行，实际上系统发送了SIGINT信号给脚本进程，SIGINT信号的默认处理方式就是退出程序。如果要在Ctrl+C不退出程序，那么就得使用trap命令来指定一下SIGINT的处理方式了。trap命令不仅仅处理Linux信号，还能对脚本退出（EXIT）、调试（DEBUG）、错误（ERR）、返回（RETURN）等情况指定处理方式。</p><p>格式为:</p><p><code>trap “command”  signal numbers 将执行双引号中的命令串。</code></p><p><code>trap &#39;&#39;  TERM 则是忽略SIGTERM信号</code></p><p><code>trap - TERM 用来恢复SIGTERM信号缺省处理</code></p><p>如果在编写shell脚本的话，trap最好放在开头第一个非注释行。另外，在trap语句中，单引号和双引号是不同的，当shell程序第一次碰到trap语句时，将把commands中的命令扫描一遍。此时若commands是用单引号括起来的话，那么shell不会对commands中的变量和命令进行替换， 否则commands中的变量和命令将用当时具体的值来替换。</p><p>在实际使用中，可以使用下面的命令来创建临时文件，并在退出时候（无论以那种形式）时将临时文件删除。<br><img src="/posts/24357/6.png"></p><h3 id="其他一些命令"><a href="#其他一些命令" class="headerlink" title="其他一些命令"></a>其他一些命令</h3><p>Bash在执行命令后，会在内存中记录所有使用的命令，当用户退出登录，所有命令保存在~/.bash_history文件中，而history命令则列出到目前为止，执行的所有命令。</p><p>fc是一个builtin命令</p><ul><li>fc first last    命令先编辑从first到last的命令，然后执行</li><li>fc –s cmd    cmd是history的命令编号，执行该编号任务</li></ul><p>alias是一个builtin命令，相当于为命令设置别名。</p><p>tee命令分离输出，同时输出到标准输出和文件</p><table><thead><tr><th align="left">参数</th><th align="left">选项</th></tr></thead><tbody><tr><td align="left">-a</td><td align="left">追加到文件</td></tr><tr><td align="left">-i</td><td align="left">忽略中断信号</td></tr></tbody></table><p>例如ls -al | tee dir.list</p><p>以上内容了解即可，接下来我们不会按照课本上的顺序，而是先将shell学完。</p><h4 id="终端命令"><a href="#终端命令" class="headerlink" title="终端命令"></a>终端命令</h4><ul><li><p>stty设定终端模式</p><ul><li>stty –echo禁止回显，输入口令时</li><li>stty echo打开回显</li></ul></li><li><p>tput控制终端输出缓冲</p><ul><li>tput clear清屏</li><li>tput cup row column移动光标到row行column列</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习笔记(七)</title>
      <link href="posts/28587/"/>
      <url>posts/28587/</url>
      
        <content type="html"><![CDATA[<h2 id="tr和sed"><a href="#tr和sed" class="headerlink" title="tr和sed"></a>tr和sed</h2><h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><p>sed命令对文本的处理很强大，并且参数少，容易掌握，sed按顺序逐行读取文件。然后，它执行为该行指定的所有操作，并在完成请求的修改之后的内容显示出来，也可以存放到文件中。完成了一行上的所有操作之后，它读取文件的下一行，然后重复该过程直到它完成该文件。</p><a id="more"></a><p>sed 命令的基本格式如下：</p><p><code>sed [选项] &#39;[脚本命令]&#39; 文件名</code></p><table><thead><tr><th align="left">选项</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">-e 脚本命令</td><td align="left">该选项会将其后跟的脚本命令添加到已有的命令中。</td></tr><tr><td align="left">-f 脚本命令文件</td><td align="left">该选项会将其后文件中的脚本命令添加到已有的命令中。</td></tr><tr><td align="left">-n</td><td align="left">取消默认控制台输出,仅显示处理后的结果</td></tr></tbody></table><p>其中最常使用的使用sed来替换的脚本命令为：</p><p><code>sed -n &#39;[address]s/pattern/replacement/flags&#39;</code></p><p>其中，address 表示指定要操作的具体行，pattern 指的是需要替换的内容，replacement 指的是要替换的新内容。</p><p>address用于决定对哪些行进行编辑。地址的形式可以是数字、正则表达式、或二者的结合。如果没有指定地址，sed将处理输入文件的所有行。</p><p>address是一个数字，则表示行号；是“$”符号，则表示最后一行。address是逗号分隔的，那么需要处理的内容是这两行之间的范围（包括这两行在内）。</p><p>此命令中常用的 flags 标记</p><table><thead><tr><th align="left">选项</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">n</td><td align="left">1~512 之间的数字，表示指定要替换的字符串出现第几次时才进行替换，例如，一行中有 3 个 A，但用户只想替换第二个 A，这是就用到这个标记；</td></tr><tr><td align="left">g</td><td align="left">对数据中所有匹配到的内容进行替换，如果没有 g，则只会在第一次匹配成功时做替换操作。例如，一行数据中有 3 个 A，则只会替换第一个 A；</td></tr><tr><td align="left">p</td><td align="left">会打印与替换命令中指定的模式匹配的行。此标记通常与 -n 选项一起使用。</td></tr><tr><td align="left">d</td><td align="left">删除行</td></tr></tbody></table><p>像这种比较抽象的命令应该多举几个例子：</p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p><code>sed &#39;1,3d&#39; test.txt</code>,删除第1~3行</p><p>删除hello.h文件中的空行，保存到hello2.h</p><p><code>sed -e &#39;s/^[[:space:]]*$//g&#39; hello.txt &gt; hello2.txt</code></p><h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><p><code>sed &#39;s/old/new/&#39; testfile</code>,把testfile文件中的old替换成new,只替换一次及终止在这一行的操作</p><p><code>sed &#39;s/old/new/g&#39; testfile</code>,用new把文件testfile中的old全部替换掉</p><p><code>sed -n &#39;s/old/new/p&#39; testfile</code>,只打印那些发生替换的行</p><p><code>cat test | sed -ne &#39;2,8s/^zhang/ying/gp&#39;</code>,在第二行，到第八行之间，替换以zhang开头的行，用ying来替换，并显示替换的行</p><p>在一个reference.bib文件中，将所有”…”替换为{…}</p><p><code>sed -e &#39;s/&quot;\([^&quot;]*\)&quot;/{\1}/g&#39; reference.bib</code></p><p>使用下来你会发现其实和vi中的替换很类似，同样都是用 <strong>/</strong> 分割，当然也不一定，比如：</p><p>查找/usr/include/boost目录下的所有头文件，然后将之替换为/usr/local/include/boost路径，输出到header文件</p><p><code>find /usr/include/boost -name &quot;*.h&quot; | sed -e &#39;s:/usr/include/\(.*\):/usr/local/include/\1:g&#39; &gt; header</code></p><p>其中使用的是: 为分隔符</p><h3 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h3><p>tr命令可以对来自标准输入的字符进行替换、压缩和删除。它可以将一组字符变成另一组字符，经常用来编写优美的单行命令，作用很强大。</p><p>用法：</p><p><code>tr [选项]... SET1 [SET2]</code></p><table><thead><tr><th align="left">选项</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">-c</td><td align="left">取代所有不属于第一字符集的字符</td></tr><tr><td align="left">-d</td><td align="left">删除所有属于第一字符集的字符</td></tr><tr><td align="left">-s</td><td align="left">把连续重复的字符以单独一个字符表示</td></tr><tr><td align="left">-t</td><td align="left">削减 SET1 指定范围，使之与 SET2 设定长度相等</td></tr></tbody></table><p>仅在SET1 和SET2 都给出，同时没有-d 选项的时候才会进行替换。利用tr命令将一个dos结尾的\r\n文本文件变换为Unix结尾的\n</p><p><code>tr -d &quot;\r&quot; &lt; a.txt &gt; b.txt</code></p><p><code>tr -s &quot;\r\n&quot; &quot;\n&quot; &lt; a.txt &gt; b.txt</code></p><p>大写字母转小写</p><p><code>echo &quot;TANK&quot; |tr A-Z a-z</code>   #大写字母转小写</p><p><code>cat aaa.txt|tr &#39;a&#39; &#39;c&#39;</code>     #字母c替换字母a</p><p><code>cat aaa.txt|tr -d &#39;a&#39;</code>    #删除所有字母a</p><p><code>cat aaa.txt|tr -s &#39;\n&#39;</code>    #删除空行</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习笔记(六)</title>
      <link href="posts/65318/"/>
      <url>posts/65318/</url>
      
        <content type="html"><![CDATA[<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h3><blockquote><p>正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。</p></blockquote><p>Unix系统偏好于以可读的文本处理，例如vi、emacs、grep、sed、awk都支持正则表达式。</p><p>Posix标准中RE分为：</p><ul><li>BRE</li><li>ERE</li></ul><a id="more"></a><h3 id="RE字符集"><a href="#RE字符集" class="headerlink" title="RE字符集"></a>RE字符集</h3><p>RE将字符分为普通字符和元字符,元字符不代表他们本身的字面意思，他们都有特殊的含义。一些元字符写在方括号中的时候有一些特殊的意思。以下是一些元字符的介绍：</p><table><thead><tr><th align="left">字符</th><th align="center">BRE/ERE</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">\</td><td align="center">Both</td><td align="left">转义</td></tr><tr><td align="left">.</td><td align="center">Both</td><td align="left">匹配单个字符</td></tr><tr><td align="left">*</td><td align="center">Both</td><td align="left">匹配任意次，可以是0次。a<em>表示匹配任意多次a，.</em>表示任意字符串</td></tr><tr><td align="left">^</td><td align="center">Both</td><td align="left">锚定匹配位置，从一行的行首开始</td></tr><tr><td align="left">$</td><td align="center">Both</td><td align="left">锚定匹配位置，到一行的行尾</td></tr><tr><td align="left">[…]</td><td align="center">Both</td><td align="left">匹配中括号内的某个字符。x-y表示一个范围；[^…]表示不匹配中括号中的任意字符。[开括号后跟-或]，-]转义为普通字符</td></tr><tr><td align="left">{n,m}</td><td align="center">BRE</td><td align="left">匹配次数为[n,m]，{n}匹配n次，{n,}最小匹配次数为n</td></tr><tr><td align="left">()</td><td align="center">BRE</td><td align="left">定义一个匹配位置，在后部可以引用该位置。例如，(ab).*\1表示ab字符串包夹了一个任意字符串。</td></tr><tr><td align="left">\n</td><td align="center">BRE</td><td align="left">引用已经定义的位置，可以从\1到\9</td></tr><tr><td align="left">{n,m}</td><td align="center">ERE</td><td align="left">与BRE的{n,m}相同</td></tr><tr><td align="left">+</td><td align="center">ERE</td><td align="left">匹配至少1次</td></tr><tr><td align="left">?</td><td align="center">ERE</td><td align="left">匹配0或1次</td></tr><tr><td align="left">|</td><td align="center">ERE</td><td align="left">或</td></tr><tr><td align="left">()</td><td align="center">ERE</td><td align="left">匹配括号内的整个字符串</td></tr></tbody></table><p>其中[ ]表达式是选择匹配中任意一个字符，<code>.*</code> 即贪婪匹配，会在满足条件下尽可能多匹配。</p><ul><li><code>c[aeiouy]t</code>，匹配可以是cat、cet、cot等</li><li><code>[0123456789]</code>表示为[0-9]</li><li><code>\([[:alpha:]_][[:alnum:]_]*\) = \1</code>    c语言赋值语句</li><li><code>\(why\).*\1</code>   whyXXwhy</li></ul><p>特别需要记忆的：</p><ul><li>[[:alnum:]]   字符+数字</li><li>[[:alpha:]]   字符</li><li>[[:digit:]]   数字</li><li>[[:lower:]]   小写字符</li><li>[[:upper:]]   大写字符</li><li>[[:space:]]   空字符：空格、tab等</li></ul><p>一个在线练习regex的网站：</p><p><a href="https://regex101.com/">regex101</a></p><p>Markdown文件中# （#后跟一个空格）表示一级标题，## 表示二级标题，匹配所有标题的BRE正则表达式</p><p>^#{1,}</p><p>匹配html、xml文件中标记&lt;…&gt;的正则表达式</p><p>&lt;[^&gt;]*&gt;</p><h3 id="vi中使用正则表达式"><a href="#vi中使用正则表达式" class="headerlink" title="vi中使用正则表达式"></a>vi中使用正则表达式</h3><p>在上一篇文章末尾我们就提到过搜索替换要配合正则表达式才能达到最优效果，现在我们学习在vi中使用正则表达式</p><p>首先需要明确一点，vi中的正则表达式和先前学的不一定完全一致，最好先使用:help pattern得到更多帮助。</p><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>首先检查magic变量，一般是magic。</p><p>:set magic?</p><p>/或？后跟一个RE表达式即可完成查询</p><h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><p>查询的通用格式是：</p><p><code>:range s/from/to/flags</code></p><p>flags为g表示行中所有的匹配项都替换,c则先要通过用户确认才替换。</p><p>实例有：</p><table><thead><tr><th align="left">实例</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">:n1,n2s/word1/word2/g</td><td align="left">n1 n2为数字，在第n1行与n2行之间寻找word1这个字符串并将其替换为word2</td></tr><tr><td align="left">:1,$s/word1/word2/g</td><td align="left">从第一行到最后一行寻找word1字符串，并将字符串替换为word2</td></tr><tr><td align="left">:1,$s/word1/word2/gc</td><td align="left">从第一行到最后一行寻找word1字符串，并将字符串替换为word2,在取代前显示提示字符给用户确认是否替换</td></tr></tbody></table><p>关于range，有下面的规定:</p><ul><li>如果不指定range，则表示当前行。</li><li><code>m,n</code>: 从m行到n行。</li><li><code>0</code>: 最开始一行（可能是这样）。</li><li><code>$</code>: 最后一行</li><li><code>.</code>: 当前行</li><li><code>%</code>: 所有行</li></ul><p>:%s/from/to/g就是在全文替换from为to，也是最常用的操作。</p><h2 id="重定向与文件操作"><a href="#重定向与文件操作" class="headerlink" title="重定向与文件操作"></a>重定向与文件操作</h2><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>重定向和管道是UNIX中非常重要的一部分，可以将我们之前所学部分连接起来。shell提供的最有用的功能之一就是”shell重定向操作符”,shell重定向操作符允许把进程的输出保存到文件中，或者用文件作为进程的输入。在Unix系统中，文件是io的基本抽象。标准输入、标准输出、错误输出可以替换为其它文件。</p><p>标准输出重定向：</p><ul><li>command &gt; file</li><li>command &gt;&gt; file 追加</li></ul><p>标准输入重定向：</p><ul><li>command &lt; file</li><li>command &lt;&lt; EOF 标准输入，当碰到EOF字符串时，输入结束</li></ul><p>标准错误输出重定向：</p><ul><li>command 2&gt; file 将command的错误输出重定向到file文件</li><li>command 2&gt;&gt; file 追加重定向</li></ul><p>重定向标准输出+标准错误输出:</p><ul><li>command &amp;&gt; file</li><li>command &amp;&gt;&gt; file    追加重定向</li></ul><p>Unix中特别的文件，/dev/null，其作为bit垃圾桶</p><p>使用重定向的几个例子：</p><ul><li>cat myfirst mysecond &gt; mythird</li><li>cat &gt; myfirst &lt;&lt; EOF</li></ul><h3 id="管道操作符"><a href="#管道操作符" class="headerlink" title="管道操作符"></a>管道操作符</h3><p>管道符使用”丨”代表。管道符也是用来连接多条命令的，如”命令1丨命令2”，用管道符连接的命令，命令 1 的正确输出作为命令 2 的操作对象。这里需要注意，命令 1 必须有正确输出，而命令 2 必须可以处理命令 1 的输出结果；而且命令 2 只能处理命令 1 的正确输出，而不能处理错误输出。</p><p>command A | command B，两条命令之间是以一个匿名文件传输</p><p>例：<code>ls –al | grep -e “^d”</code></p><p>Shell如何实现管道？</p><ul><li>pipe()函数创建一个两个文件描述符，一个输入，一个输出</li><li>fork创建子进程,子进程继承父进程的文件描述符</li><li>父进程关闭管道的输出端,子进程将标准输入替换为管道输入,随后子进程关闭管道输入和输出。</li><li>父进程写完数据后，关闭管道输出。子进程从父进程收到EOF，输入数据完毕</li></ul><p>将父进程的标准输出替换为pipe输出，子进程的标准输入替换为pipe输入</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><h4 id="文件操作命令"><a href="#文件操作命令" class="headerlink" title="文件操作命令"></a>文件操作命令</h4><p>在先前我们就学习了一些有关文件的命令，现在我们将继续学习</p><p>cp拷贝源文件成目标文件</p><ul><li>-b        如果目标文件存在备份</li><li>-i        如果目标文件存在，提示</li><li>-r        递归拷贝</li></ul><p>mv移动文件，也可以用来重命名文件</p><ul><li>-b      如果目标文件存在，则备份</li><li>-i      如果目标文件存在，提示</li><li>-f      强制移动</li></ul><p>wc统计字数</p><ul><li>-l        统计行数</li><li>-w        统计单词数量</li><li>-c        统计字符数量</li></ul><p>head/tail 显示文件头部/尾部，默认显示10行</p><ul><li>-n        显示头部n行</li><li>-c n      显示头部n个字符</li></ul><p>more命令分页显示文件内容，可以向后翻，但不能向前翻</p><p>less命令是more的改进，可以向前翻</p><h4 id="ln在文件之间建立连接"><a href="#ln在文件之间建立连接" class="headerlink" title="ln在文件之间建立连接"></a>ln在文件之间建立连接</h4><p>在Unix世界里有两个’link’（连接）概念，一般称之为硬连接和软连接。一个硬连接仅仅是一个文件名。一个软连接（或符号连接）是完全不同的：它是一个包含了路径信息的小小的指定文件。因此， 软连接可以指向不同文件系统里的文件，甚至可以指向一个不一定确实存在的文件，软链接完全可以当作 Windows 的快捷方式来对待，它的特点和快捷方式一样。</p><p><strong>默认不带参数</strong>的情况下，ln创建的是<strong>硬链接</strong>，带<code>-s</code>参数的ln命令创建的是<strong>软链接</strong>，使用<code>ls –i</code>显示节点，<code>ls -l</code>中，第二列的数字就是显示连接数。</p><p>它们之间的区别在于</p><ul><li>硬链接不度能对目录进行创建，只可对文件创建</li><li>软链接可知对文件或目录创建</li><li>删除一个硬链接文件并不影响其他有相同 inode 号的文件</li></ul><p><strong>硬链接</strong>不会建立自己的 inode 索引和 block（数据块），而是直接指向源文件的 inode 信息和 block，所以硬链接和源文件的 inode 号是一致的,只是增加引用计数。</p><p>而<strong>软链接</strong>会真正建立自己的 inode 索引和 block，所以软链接和源文件的 inode 号是不一致的，而且在软链接的 block 中，写的不是真正的数据，而仅仅是源文件的文件名及 inode 号。</p><h3 id="Shell路径元字符"><a href="#Shell路径元字符" class="headerlink" title="Shell路径元字符"></a>Shell路径元字符</h3><p>在Shell中也有存在需要操作大量文件的时候，因此shell支持“文件替换”，允许用户选择那些文件名与指定模式相匹配的文件。这些支持指定模式，具有特殊意义的字符被称为元字符（通配符）。注意，他与vi中的正则表达式相似但是不同。</p><table><thead><tr><th align="right">元字符</th><th align="left">功能</th></tr></thead><tbody><tr><td align="right">?</td><td align="left">匹配路径名的单个字符</td></tr><tr><td align="right">*</td><td align="left">匹配路径名的任意长度的字符串</td></tr><tr><td align="right">[list]</td><td align="left">匹配list中任意一个字符</td></tr><tr><td align="right">[!list]</td><td align="left">匹配不在list中的任意一个字符</td></tr></tbody></table><h4 id="通配符和正则表达式比较"><a href="#通配符和正则表达式比较" class="headerlink" title="通配符和正则表达式比较"></a>通配符和正则表达式比较</h4><p>（1）通配符和正则表达式看起来有点像，不能混淆。可以简单的理解为通配符只有*,?,[],{}这4种，而正则表达式复杂多了。</p><p>（2）*在通配符和正则表达式中有其不一样的地方，在通配符中*可以匹配任意的0个或多个字符，而在正则表达式中他是匹配之前的一个或者多个字符，不能独立使用的。比如通配符可以用*来匹配任意字符，而正则表达式不行，他只匹配任意长度的前面的字符。</p><h3 id="其他文件操作命令"><a href="#其他文件操作命令" class="headerlink" title="其他文件操作命令"></a>其他文件操作命令</h3><h4 id="寻找文件-find"><a href="#寻找文件-find" class="headerlink" title="寻找文件 find"></a>寻找文件 find</h4><p>find命令用来在目录中定位一组与给定标准相匹配的文件。标准可以是文件名，在找到文件后，用户可以将命令定向到删除、重命名等其他文件操作，总的来说，find命令是一个有用且重要的命令。</p><p>find命令的格式与其他UNIX命令不同，他的语法为：</p><p><code>find pathname searchfile options action option</code></p><p>pathname表明find开始搜索的目录，然后会向下继续搜索他的子目录，除了用绝对路径表示外，可以用<code>~</code>表示home目录，<code>.</code>表示当前目录</p><p>搜索选项有：</p><table><thead><tr><th align="left">选项</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">-name filename</td><td align="left">根据给定的filename做匹配查找，要加“”</td></tr><tr><td align="left">-size +/-n</td><td align="left">查找大于或者小于n的文件</td></tr><tr><td align="left">-type filetype</td><td align="left">查找指定类型filetype的文件</td></tr><tr><td align="left">-atime +/-n</td><td align="left">查找n天以前/以内访问的文件</td></tr><tr><td align="left">-mtime +/-n</td><td align="left">查找n天以前/以内更改的文件</td></tr></tbody></table><p>例：</p><p>find . -name “first.c” -print<br>find . -name “*.c” -print</p><p>Action选项有：</p><table><thead><tr><th align="left">选项</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">-print</td><td align="left">打印输出</td></tr><tr><td align="left">-exec command;</td><td align="left">执行命令</td></tr><tr><td align="left">-ok command;</td><td align="left">在执行命令前要求确认</td></tr></tbody></table><p>重点讲一下-exec选项，-exec允许用户给出一个命令，作用于发现的文件，-exec后跟指定命令，空格，反斜杠和分号，用户可以用一对大括号（{}）表示发现的文件名，当然后面会学到xargs来取代-exec，例子有：</p><p><code>find . -name &quot;first.c&quot; -mtime +90 -exec rm -i {} \;</code></p><p>寻找并删除当前目录下所有大于90天且名为first.c的文件，删除前要先确认</p><h4 id="cut命令"><a href="#cut命令" class="headerlink" title="cut命令"></a>cut命令</h4><p>cut命令纵向输出文件的某个列,一般与cat配合管道符联用。</p><table><thead><tr><th align="left">选项</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">-f LIST</td><td align="left">指定剪切的域</td></tr><tr><td align="left">-d x</td><td align="left">指定域的分隔符</td></tr><tr><td align="left">-c LIST</td><td align="left">指定剪切字符位置</td></tr></tbody></table><p>使用且只使用 -c 或 -f 中的一个选项，LIST由一个范围 (range) 或 逗号隔开的多个范围组成. 如下形式</p><ul><li>n     第n个字符或字段，从1开始计数</li><li>n-   从第n个字符或字段到结束</li><li>-n   从第1个字符或字段到第n个(包括第n)字符或字段结束</li><li>n-m   表示[n,m]的域</li><li>n,m   表示n和m域</li></ul><p>默认的分隔符是TAB制表键</p><p>以/etc/passwd为例</p><p><code>cat /etc/passwd | cut -c 1-4 |head -5</code>    #输出文件的前四个字符</p><p><code>cat /etc/passwd | cut -f1 -d &#39;:&#39; |head -5</code>   #以:分割文件，输出第一个字段</p><h4 id="paste命令"><a href="#paste命令" class="headerlink" title="paste命令"></a>paste命令</h4><p>paste命令横向连接两个文件</p><table><thead><tr><th align="left">选项</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">-d x</td><td align="left">指定域分隔符</td></tr></tbody></table><p>默认的分隔符是TAB制表键</p><h4 id="sort命令"><a href="#sort命令" class="headerlink" title="sort命令"></a>sort命令</h4><p>sort命令排序按照行做字典序排列文件内容</p><table><thead><tr><th align="left">选项</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">-b</td><td align="left">忽略行首的空格</td></tr><tr><td align="left">-d</td><td align="left">在字典序比较中，忽略标点符号和控制符号</td></tr><tr><td align="left">-t</td><td align="left">指定域分隔符</td></tr><tr><td align="left">-n</td><td align="left">数字以数值排序</td></tr><tr><td align="left">-r</td><td align="left">逆序排列</td></tr><tr><td align="left">-o</td><td align="left">指定输出文件</td></tr></tbody></table><p>按照字典序，大写字母比小写字母更靠前</p><p>例</p><p>按照uid排列所有用户(0开始计数)</p><p>sort -t “:” -n +2 /etc/passwd</p><h4 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h4><p>grep是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p><p>格式为： grep [OPTION…] PATTERNS [FILE…]</p><table><thead><tr><th align="left">选项</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">-c</td><td align="left">只显示匹配的行数</td></tr><tr><td align="left">-i</td><td align="left">忽略大小写匹配</td></tr><tr><td align="left">-G</td><td align="left">BRE，grep默认选项</td></tr><tr><td align="left">-E</td><td align="left">ERE，egrep默认选项</td></tr><tr><td align="left">-e PATTERNS</td><td align="left">指定一个或多个RE</td></tr><tr><td align="left">-v</td><td align="left">显示不匹配的行</td></tr><tr><td align="left">-n</td><td align="left">输出行号</td></tr></tbody></table><p>以/etc/passwd为例，匹配以root开头或者以zhang开头的行，注意反斜杠</p><p><code>cat /etc/passwd |grep &#39;^\(root\|zhang\)&#39;</code></p><h4 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h4><p>xargs 又称管道命令，构造参数等。是给命令传递参数的一个过滤器,也是组合多个命令的一个工具 它把一个数据流分割为一些足够小的块,以方便过滤器和命令进行处理 。简单的说 就是把 其他命令的给它的数据 传递给它后面的命令作为参数，xargs的格式为：</p><p>xargs [command [initial-arguments]]</p><p>xargs从标准输入上读，将标准输入文件按照空格/TAB拆解成参数，作为command执行参数，经常与find和awk或者tr配合使用</p><p>一个典型的例子：查找epoll_wait函数在那个文件：</p><p><code>find /usr/include –name “*.h” -type f | xargs grep “epoll_wait”</code></p><h2 id="文件系统原理"><a href="#文件系统原理" class="headerlink" title="文件系统原理"></a>文件系统原理</h2><p>Unix有三大抽象</p><ul><li>进程、线程对执行过程</li><li>文件对io</li><li>地址空间对内存</li></ul><p>有四种io：文件系统、块设备、字符设备、socket</p><ul><li>块设备和字符设备出现在文件系统的名字空间</li><li>Socket仅表现为文件</li></ul><h3 id="UNIX磁盘结构"><a href="#UNIX磁盘结构" class="headerlink" title="UNIX磁盘结构"></a>UNIX磁盘结构</h3><p>UNIX里面，磁盘是一个标准块设备，一个UNIX磁盘被分成四个块：</p><ul><li>主引导块<ul><li>保存着引导程序，系统启动时激活。</li></ul></li><li>超级块<ul><li>包含磁盘自身的信息，包括磁盘总块数，空闲块数，块大小和使用块数。</li></ul></li><li>i节点列表块<ul><li>维护i节点的列表，列表每个条目是一个64字节存储区的i节点，规则文件或目录文件的i节点包含着所在磁盘块的位置，特殊文件的i节点包含确定外围设备的信息。i节点还有许多信息，不累述了。</li></ul></li><li>文件和目录块<ul><li>存放数据，由 i 节点指向。</li></ul></li></ul><p>磁盘文件组织，需要从几个维度去考虑磁盘如何组织成文件</p><blockquote><p>快速访问<br>方便修改<br>节省空间</p></blockquote><p>考虑磁盘的空间组织，主要有几种形式：</p><blockquote><p>变长的堆<br>定长的记录<br>索引</p></blockquote><p>Unix文件系统的选择：堆+索引</p><ul><li>索引 key,value对，key是文件名，要求变长，</li><li>目录文件</li></ul><img src="/posts/65318/1.png"><h4 id="整体过程"><a href="#整体过程" class="headerlink" title="整体过程"></a>整体过程</h4><p>登录时,UNIX读取根目录(i-node2),找出用户主目录(homedirectory),存储用户主目录的i节点号。当用cd改变目录时, UNIX用新目录的i节点号进行替换。</p><p>用系统工具或命令(例如vi或at)访问文件或者某个程序打开文件时, UNIX查找指定文件名的目录。每个文件名与i节点列表中的一个i节点相联系。UNIX通过用户工作目录的i节点开始搜索,但是如果用户给定了全路径名,则从根目录(i-node 2)开始查找。</p><p>下一章中我们会先来学习sed和tr命令.</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习笔记(五)</title>
      <link href="posts/24325/"/>
      <url>posts/24325/</url>
      
        <content type="html"><![CDATA[<h2 id="VI高级用法"><a href="#VI高级用法" class="headerlink" title="VI高级用法"></a>VI高级用法</h2><p>前面我们已经学习了vi的基本用法，现在我们将要更进一步，学习更多和vi相关的内容。</p><a id="more"></a><h3 id="VI编辑器"><a href="#VI编辑器" class="headerlink" title="VI编辑器"></a>VI编辑器</h3><h4 id="只读选项"><a href="#只读选项" class="headerlink" title="只读选项"></a>只读选项</h4><p>在打开某些配置文件的时候，为了安全起见应该避免修改源文件，这时候vi编辑器就提供了只读启动选项。</p><p><code>-R</code> 作为vi的选项，使一个文件只读并允许用户逐行查看内容并且不会意外修改文件。</p><h4 id="编辑多文档"><a href="#编辑多文档" class="headerlink" title="编辑多文档"></a>编辑多文档</h4><p>在大部分情况，我们并不止打开一个文件，而是需要打开一系列文件，vi自然也提供了多文档编辑的能力，可以不退出vi而继续编辑下一个文件。</p><p>其原理来自vi的缓冲区功能。vi内部每个buffer打开一个文件，多个buffer也可以同时打开一个文件。相对应的一个tab对应了一个buffer，每个buffer可以由不同的buffer相对应。</p><p>在vi外部的话，可以一次打开多个文件，如</p><pre class="line-numbers language-shell"><code class="language-shell">vi a.txt b.txt c.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用:<code>next(:n)</code>编辑下一个文件。<br><code>:2n</code> 编辑下2个文件。<br>使用<code>:previous</code>或<code>:N</code>编辑上一个文件。<br>使用<code>:args</code>或<code>:ar</code>显示文件列表。</p><p>如果打开了vi的话：</p><p>首先<code>:tabnew</code>创建一个标签<br>然后<code>:e</code>+文件名打开一个文件<br><code>:tabnext</code>在窗口上打开下一个tab<br><code>:tabprevious</code>在窗口上打开前一个tab<br><code>:q</code>或者<code>:tabclose</code>关闭tab</p><h4 id="vi-vim的定制"><a href="#vi-vim的定制" class="headerlink" title="vi/vim的定制"></a>vi/vim的定制</h4><p>vi最大的优点就在于可定制化，基于你的习惯可以最大限度强化vi/vim的功能，有个vi/vim的配置网上有很多人晒出自己的配置，就不在这里叙述了。</p><h3 id="文字重排"><a href="#文字重排" class="headerlink" title="文字重排"></a>文字重排</h3><p>相关内容在三中已经总结过了，这里就跳过，如果有不明白的话就请看3中对于剪切、复制、粘贴等操作的总结。</p><h3 id="vi操作符的域"><a href="#vi操作符的域" class="headerlink" title="vi操作符的域"></a>vi操作符的域</h3><p>在先前的学习中，其实就出现了有关操作域的应用。使用vi命令结合域控制键能让用户在进行编辑工作时具有更多的控制能力。这类命令格式为:</p><p><code>命令=操作符+域</code></p><p>以下是常用的域控制键：</p><table><thead><tr><th align="left">域</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">$</td><td align="left">标识域从光标所在位置到行的行尾</td></tr><tr><td align="left">0</td><td align="left">标识域从光标前一个位置到该行所在行首</td></tr><tr><td align="left">e或w</td><td align="left">标识域从光标所在位置到光标所在单词的末尾</td></tr><tr><td align="left">b</td><td align="left">标识域从光标前一个字母到光标所在单词的开始</td></tr></tbody></table><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>vim中设计了特别的暂存机制——寄存器，用于保存拷贝和删除的文本。例如当用户键入dd命令时，vi将删除行放入缓冲区1，再次使用dd时，vi将缓冲区1中内容后移到缓冲区2，以此类推。</p><p>其中，有名寄存器a-z，一共26个，供用户使用</p><ul><li>编号寄存器0-9，10个，vim自己使用，存放删除和拷贝的文本<ul><li>“0号寄存器是visual模式下拷贝的问题</li><li>“1-“9号寄存器是dd删除、yy拷贝的行文本</li></ul></li></ul><p>类似的，默认寄存器有：</p><ul><li>% 当前窗口对应的文件名</li><li># 当前窗口的其它文件名</li><li>: 命令行模式最近输入的命令</li><li>. 最近插入的文本</li><li>“ 最近删除或拷贝的文本</li></ul><p>在命令模式下以”双引号开头引用这些寄存器。比如想要使用2号寄存器中的内容，只需要输入”2p。</p><p>指定缓冲区的格式可以总结为</p><p><code>&quot;+指定寄存器+命令</code></p><p>命令行模式下，:reg显示寄存器。</p><h4 id="寄存器加操作符作用域"><a href="#寄存器加操作符作用域" class="headerlink" title="寄存器加操作符作用域"></a>寄存器加操作符作用域</h4><p>刚刚所学的寄存器和操作符作用域是可以结合起来使用的:</p><p>寄存器+[range]+d/y+[motion]组合，完成拷贝/删除动作到寄存器，例如</p><p><code>“wdd  删除当前行到”w寄存器</code><br><code>“z7yy  拷贝从当前光标开始算，一共7行，到”z寄存器</code></p><h3 id="光标定位"><a href="#光标定位" class="headerlink" title="光标定位"></a>光标定位</h3><p>首先我们能够知道当前行在文本的百分之多少，在命令状态想按[Ctrl-g]可以查看当前行号。</p><p>然后是快速定位到文件的特定行：</p><ul><li>:n定位到文件的第n行</li><li>:0或:1定位到第1行的行首</li><li>:$定位到最后一行</li><li>1G定位到第1行的行首</li><li>G或0G定位到最后一行的行首</li><li>nG定位到第n行的行首</li></ul><h3 id="运行shell命令"><a href="#运行shell命令" class="headerlink" title="运行shell命令"></a>运行shell命令</h3><p>跟多文档编辑类似的，我们希望能够不离开vi直接查看shell命令的运行结果。这也是可以实现的。</p><ul><li>:shell命令切换到shell，exit回到vim</li><li>:!命令，执行shell命令</li><li>:r!命令，将shell命令输出粘贴到当前位置</li></ul><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>vi中的搜索要结合正则表达式才能发挥强大的效果，在这里先提前学习一下。</p><p>/something: 在光标后面的文本中查找something</p><p>?something: 在光标前面的文本中查找something</p><p>n: 向后查找下一个。</p><p>N: 向前查找下一个。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习笔记(四)</title>
      <link href="posts/22865/"/>
      <url>posts/22865/</url>
      
        <content type="html"><![CDATA[<h2 id="磁盘与文件"><a href="#磁盘与文件" class="headerlink" title="磁盘与文件"></a>磁盘与文件</h2><p>数据存储在文件之中，而文件就保存在硬盘的某个部分之中，用户可以把磁盘分成更小的单元和子单元，分别命名，然后把相关的信息保存在同一个单元或子单元中。文件是操作系统对io设备的一个抽象，进程/线程是对执行过程的抽象。</p><a id="more"></a><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>在UNX系统中,文件是字节序列。UNIX不支持另外一些操作系统支持的其他结构(例如记录或者域)。UNIX 有3类文件。</p><p><strong>普通文件:</strong> 规则文件包含字节序列，可以是程序代码、文本等。用vi编辑器创建的文件是普通文件,大多数用户管理使用的都是这类文件。</p><p><strong>目录文件:</strong> 在很多方面,目录文件和其他文件一样,目录以树的形式组织文件，其本身是一个文件。</p><p><strong>特殊文件:</strong> 特殊文件(设备文件)包含对应于外围设备(如打印机、磁盘等)的特殊信息。UNIX把I/O设备看作文件。</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>目录是UNIX文件系统的基本特征，目录系统提供了磁盘组织文件的结构。UNIX中，目录结构是分层组织，允许用户方便地组织和查找文件，最高层目录为根目录，所有其他目录是它的直接或间接分支，目录不包含所含文件的信息，而是提供一个索引路径，允许用户组织和查找文件。</p><img style="width:400px;height:200px" src="/posts/22865/1.jpg"><br><pre class="line-numbers language-markdown"><code class="language-markdown">/bin 普通用户执行的命令存放的地方/sbin 管理员执行的命令存放的地方/usr应用程序存放的目录　　/usr/bin 存放应用程序　　　　/usr/lib 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件　　/usr/local 存放软件升级包/lib 系统使用的函数库的目录/root 管理员的家目录(宿主目录)/home 普通用户的家目录/var 放置系统执行过程中经常变化的文件，如随时更改的日志文件/etc 存放各种配置文件/srv 服务启动之后要访问的目录/mnt 光盘默认挂载点/dev 存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备/opt 给主机额外安装软件所存放的目录/tmp 一般用户或正在执行的程序临时存放文件的目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="理解路径和路径名"><a href="#理解路径和路径名" class="headerlink" title="理解路径和路径名"></a>理解路径和路径名</h3><p>每个路径的最后是一个普通文件或目录文件，普通文件在路径的末尾，不能再有更下级的目录。</p><p>几个重要的目录概念：</p><pre class="line-numbers language-markdown"><code class="language-markdown">~HOME目录.当前目录..父目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每个文件有一个路径名，路径名在文件系统中定位文件，</p><ul><li>1.路径名开始的斜杠(/)代表根目录。</li><li>2.其他斜杠用来分割目录和文件名。</li><li>3.工作目录的文件可以立即访问，访问其他目录的文件需要用路径名指定该文件。</li></ul><h3 id="使用文件和目录名"><a href="#使用文件和目录名" class="headerlink" title="使用文件和目录名"></a>使用文件和目录名</h3><p>Unix中，不要在文件名中使用以下字符</p><ul><li>避免使用：&lt;&gt;，()，[]，{}，*，?，“，‘，-，$，^</li></ul><p>因为：这些符号是正则表达式使用，同时，注意文件名是大小写敏感的。</p><h3 id="目录命令"><a href="#目录命令" class="headerlink" title="目录命令"></a>目录命令</h3><ul><li>pwd打印当前工作目录</li><li>cd改变当前工作目录<ul><li>cd</li><li>cd 路径</li></ul></li><li>mkdir创建目录<ul><li>mkdir 路径</li><li>mkdir -p 路径</li></ul></li><li>rmdir删除目录<ul><li>非空目录无法删除</li></ul></li></ul><p>下面是一个比较重要的命令：</p><p>ls命令用来显示指定目录的内容。</p><table><thead><tr><th align="right">选项</th><th align="left">功能</th></tr></thead><tbody><tr><td align="right">-a</td><td align="left">列出所有文件，包括隐藏文件</td></tr><tr><td align="right">-C</td><td align="left">用多列方式列出文件，按列排列</td></tr><tr><td align="right">-F</td><td align="left">将子目录与普通文件类型分开，子目录加/，可执行文件加*</td></tr><tr><td align="right">-l</td><td align="left">详细列出文件的属性，每行一个文件</td></tr><tr><td align="right">-m</td><td align="left">按页宽列出文件，用逗号隔开</td></tr><tr><td align="right">-p</td><td align="left">如果是目录，文件名后加/</td></tr><tr><td align="right">-r</td><td align="left">以字母反序列表</td></tr><tr><td align="right">-R</td><td align="left">循环列出子目录内容</td></tr><tr><td align="right">-s</td><td align="left">以文件块为单位显示文件大小</td></tr><tr><td align="right">-X</td><td align="left">以多列的格式列表，按行排序</td></tr></tbody></table><p>一行命令中可以多于一个选项，加目录的路径名列出其他目录的文件</p><p>下面利用<code>ls -al</code>来继续学习文件类型</p><img src="/posts/22865/2.jpg"><p>开始的字母，表示的是</p><ul><li>文件类型<ul><li>- 表示普通文件</li><li>d 表示目录</li><li>c 表示字符设备</li><li>b 表示块设备</li><li>l 表示符号连接</li></ul></li></ul><p>随后的9个字符由三组r、w、x和连字符-组成，描述了文件的访问模式，表明了系统中的每个用户的指定文件的访问模式</p><ul><li>r 表示读权限</li><li>w 表示写权限</li><li>x 表示执行权限，目录的话是访问权限</li></ul><p>第一组字符rwx字符表示的是所有者的读写执行权限，第二组rwx表示的是用户组的读写执行权限，第三组rwx是指其他用户的读写执行权限，通过对不同用户组设置不同的访问字符，就可以控制谁访问该文件以及具有何种类型的访问权。</p><p><strong>链接数:</strong> 第2列显示链接数。</p><p><strong>文件所有者:</strong> 第3列显示文件的拥有者，该名字通常是创建文件的用户ID。</p><p><strong>文件组:</strong> 第4列显示用户组。每一个UNIX用户有用户ID和组ID,这些是由系统管理员指定的。例如,同一个项目的人设成相同的组ID。</p><p><strong>文件大小:</strong> 第5列显示文件大小，这是文件的字节数。</p><p><strong>日期和时间:</strong> 第6列显示最后更改的日期和时间。</p><p><strong>文件名:</strong> 第7列显示文件名。</p><h3 id="隐藏文件"><a href="#隐藏文件" class="headerlink" title="隐藏文件"></a>隐藏文件</h3><p>以.点开头的文件或目录是缺省不被显示,目录列表命令通常不显示它们。启动文件通常不可见，以避免搞乱目录。</p><p>如果想创建自己的不可见文件，只需要文件名以.开始即可，除根目录外，每个目录都有两个特殊的不可见文件项——单点和双点：</p><ul><li><p>.表示当前目录</p></li><li><p>..表示父目录</p></li></ul><h3 id="显示文件内容"><a href="#显示文件内容" class="headerlink" title="显示文件内容"></a>显示文件内容</h3><p><code>cat</code> 查看文件内容，cat无分屏浏览功能，但只适合于文件内容在一屏内的文件，如果cat命令后跟了两个文件名，那么将按照顺序依次输出两个文件的内容，如果输出内容过多，可以使用<code>[Ctrl-s]</code>来停止输出，<code>[Ctrl-q]</code>来恢复。</p><h3 id="打印文件内容"><a href="#打印文件内容" class="headerlink" title="打印文件内容"></a>打印文件内容</h3><p><code>lp</code>命令来使用打印机来打印</p><table><thead><tr><th align="right">选项</th><th align="left">功能</th></tr></thead><tbody><tr><td align="right">-d</td><td align="left">指定的打印机上打印</td></tr><tr><td align="right">-m</td><td align="left">完成打印请求后向用户邮箱发邮件提醒</td></tr><tr><td align="right">-n</td><td align="left">打印指定份数</td></tr><tr><td align="right">-s</td><td align="left">取消反馈消息</td></tr><tr><td align="right">-t</td><td align="left">输出的标题页打印指定标题</td></tr><tr><td align="right">-w</td><td align="left">完成打印请求后，在用户终端显示消息</td></tr></tbody></table><p>如果不想打印了，可以使用<code>cancel</code>命令来取消打印请求</p><p><code>lpstat</code>命令获取打印机状态</p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><ul><li>rm删除文件<ul><li>rm –fr递归删除文件及目录</li><li>rm –i确认删除</li></ul></li></ul><p>在删除目录的时候，需要使用-r来递归删除。如果要删除其他路径的文件或目录，需要指定路径名。</p><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><p>touch创建一个空文件</p><p>mkdir创建一个空目录</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习笔记(三)</title>
      <link href="posts/53165/"/>
      <url>posts/53165/</url>
      
        <content type="html"><![CDATA[<h2 id="vi编辑器"><a href="#vi编辑器" class="headerlink" title="vi编辑器"></a>vi编辑器</h2><p>所有的Linux系统都会内建vi文本编辑器。</p><p>而vim则是vi的升级版本，vim具有程序编辑的能力，可以看做是vi的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p><a id="more"></a><p>vi/vim与常见的编辑器最大的不同就在于，你使用vi/vim的话完全可以做到手不离键盘，一切操作都不需要使用鼠标（当然你想使用的话也可以设置），但也因此需要记忆大量的命令，当你经常使用，最终熟记时，你就会发现vi/vim的强大。</p><h2 id="vi的工作模式"><a href="#vi的工作模式" class="headerlink" title="vi的工作模式"></a>vi的工作模式</h2><p><code>命令模式：</code> 在启动之时，vi会进入命令模式，命令模式下键盘的输入不会在屏幕上显示出来（不像word），但会被解释执行，在命令模式下可以利用预先定义的按键来移动光标，复制删除查询等等一系列操作,可以通过配置vi/vim将命令模式下键盘输入显示到右下角。</p><p>一些命令常常以冒号( : )、斜杠(/)、问号(?)开头来执行，所有命令均显示在编辑器屏幕的最下角。</p><img src="/posts/53165/2.jpg"><p><code>文本输入模式(插入模式)：</code>文本输入模式下键盘的输入都会显示在屏幕之中，按键不作为命令被执行，而是作为文本写入到用户的文件之中。</p><p><code>命令行模式：</code>可以进行诸多扩展的操作</p><h3 id="vi模式的切换"><a href="#vi模式的切换" class="headerlink" title="vi模式的切换"></a>vi模式的切换</h3><p>进入vi/vim只需要输入vi/vim，空格后加要编辑的文件名即可，要保存退出在命令行模式下输入:wq即可,vi/vim中对于命令而言是区分大小写的，需要额外注意。</p><p><strong>命令模式→插入模式：</strong></p><ul><li>i：在当前光标所在字符的前面，转为输入模式</li><li>I：在当前光标所在行的行首转换为输入模式</li><li>a：在当前光标所在字符的后面，转为输入模式</li><li>A：在光标所在行的行尾，转换为输入模式</li><li>o：在当前光标所在行的下方，新建一行，并转为输入模式</li><li>O：在当前光标所在行的上方，新建一行，并转为输入模式</li></ul><p><strong>插入模式→命令模式</strong><br>在插入模式下<code>ESC键</code></p><p><strong>命令模式→命令行模式</strong><br>输入：即可 转为末行模式</p><img src="/posts/53165/1.jpg"><p>到目前为止，就具有了最基本的读写文件的能力了。</p><h2 id="vi基本命令"><a href="#vi基本命令" class="headerlink" title="vi基本命令"></a>vi基本命令</h2><p>使用基本命令需要在命令模式之下</p><h3 id="1-移动光标"><a href="#1-移动光标" class="headerlink" title="1.移动光标"></a>1.移动光标</h3><p>可以在vi/vim中输入：help查看帮助</p><img src="/posts/53165/3.jpg"><p>除了使用小键盘可以移动光标外，常见的移动光标的方法有：</p><img src="/posts/53165/4.jpg"><p>额外补充的：</p><ul><li>w向后移动一个word</li><li>b向前移动光标到word的开头</li><li>e移动光标到word的尾部</li></ul><div style="page-break-after: always;"></div><h3 id="2-文本插入"><a href="#2-文本插入" class="headerlink" title="2.文本插入"></a>2.文本插入</h3><ul><li>i：在当前光标所在字符的前面，转为输入模式</li><li>I：在当前光标所在行的行首转换为输入模式</li><li>a：在当前光标所在字符的后面，转为输入模式</li><li>A：在光标所在行的行尾，转换为输入模式</li><li>o：在当前光标所在行的下方，新建一行，并转为输入模式</li><li>O：在当前光标所在行的上方，新建一行，并转为输入模式</li><li>s：删除光标所在字符,并转为输入模式</li><li>r：替换光标处字符（输入r之后继续输入替换之后的字符即被替换，还停留在命令模式）</li></ul><h3 id="3-文本修改"><a href="#3-文本修改" class="headerlink" title="3.文本修改"></a>3.文本修改</h3><img src="/posts/53165/51.jpg"><p><code>.</code>可以让用户重复前一个动作，经常配合其他命令使用。数字可以和指令结合。</p><br><img src="/posts/53165/52.jpg"><h3 id="4-搜索"><a href="#4-搜索" class="headerlink" title="4.搜索"></a>4.搜索</h3><img src="/posts/53165/6.jpg"><h2 id="vi的退出"><a href="#vi的退出" class="headerlink" title="vi的退出"></a>vi的退出</h2><p>进入vi的方法只有一种，但是退出vi的方法却有很多种，用户可以根据自己的需要选择不同的退出方式。</p><img src="/posts/53165/7.jpg"><h2 id="存储缓冲与显示"><a href="#存储缓冲与显示" class="headerlink" title="存储缓冲与显示"></a>存储缓冲与显示</h2><p>vi编辑器会为用户生成又或者修改一个文件创建一个临时工作区，用户对文件所做的修改只作用于工作区中的副本而不是源文件。vi编辑器在一个编辑任务中可以使用不同的的缓冲区来管理用户的文件。如果用户想要把偶才能所做的修改，就需要将缓冲区的副本替换源文件。对源文件的修改需要用户执行一个写入操作。</p><p>对于缓冲区而言，只显示一个窗口的大小，并存在一个修改队列，记录用户的操作，<code>.</code>命令将最后一次修改append到队列,<code>u</code>命令回退这个队列</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习笔记(二)</title>
      <link href="posts/24335/"/>
      <url>posts/24335/</url>
      
        <content type="html"><![CDATA[<h2 id="Unix系统下的登陆与退出"><a href="#Unix系统下的登陆与退出" class="headerlink" title="Unix系统下的登陆与退出"></a>Unix系统下的登陆与退出</h2><p>Unix系统一直以其安全性著称，实现安全性的一个比较重要的方法就是多用户分组管理，毕竟你不能让一个随便创建的用户来运行诸如<code>rm -rf \</code>等危险的命令  ,因此用户在使用Unix系统时候，需要进行登录。</p><p>值得一提的是树莓派使用的Raspbian系统，实际上是Debian系统，而在Debian中root账户默认没有密码，并且账户是锁定的，因此如果执行一些需要root权限的命令时，就需要开启root用户。</p><a id="more"></a><p>首先先给root账户设置密码：<code>sudo passwd root</code></p><p>然后解锁root账户：<code>sudo passwd --unlook root</code>，即开启了root用户，同时也算第一次输入passwd命令。</p><img src="/posts/24335/1.png"><p>既然知道如何登入了,就需要知道如何才能够退出才行,通常情况下可以直接在Shell中输入exit或者ctrl-d即可以退出（用户层面），但是如果是类似于树莓派这种物理机的话，因为不只有Shell，想要完全退出的话需要在Shell中输入<code>sudo poweroff</code>后，才算是安全退出（机器层面）。</p><h2 id="Unix下命令"><a href="#Unix下命令" class="headerlink" title="Unix下命令"></a>Unix下命令</h2><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><p>Unix下命令格式基本如下：</p><blockquote><p><code>$&gt; 命令名  [-选项] [参数]</code></p></blockquote><p>注意，选项前面的 <code>-</code> 是必不可少的，对于选项而言，既可以分开多个，以空格为间隔符来写，也可以合并起来例如：</p><p><code>ls -a -l</code> 可以写作 <code>ls-al</code>，且后面那种写法更加常见</p><p><em>注意事项：</em> Unix对于大小写是敏感的，对于ls命令而言不能写成LS（当然也有特例 如果你使用<code>alias</code>命令为命令起了一个大写别名的话）</p><h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><p>目前学习的命令比较少，随着后续的学习了解的命令会慢慢变多，同时也会在相应章节里面更新</p><h4 id="1-操作文件及目录"><a href="#1-操作文件及目录" class="headerlink" title="1.操作文件及目录"></a>1.操作文件及目录</h4><table><thead><tr><th align="left">命令</th><th align="left">参数</th><th align="left">示例</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">cd</td><td align="left"></td><td align="left">cd ~</td><td align="left">切换目录</td></tr><tr><td align="left">pwd</td><td align="left"></td><td align="left">pwd</td><td align="left">显示当前工作目录目录</td></tr><tr><td align="left">touch</td><td align="left"></td><td align="left">touch 1.txt</td><td align="left">创建空文件</td></tr><tr><td align="left">mkdir</td><td align="left"></td><td align="left">mkdir testdir</td><td align="left">创建一个新目录</td></tr><tr><td align="left">\</td><td align="left">-p</td><td align="left">mkidr -p dir1/dir2/dir3/</td><td align="left">创建多级目录，父目录不存在情况下先生成父目录</td></tr><tr><td align="left">cp</td><td align="left"></td><td align="left">cp 1.txt</td><td align="left">复制文件</td></tr><tr><td align="left">\</td><td align="left"></td><td align="left">cp -r dir1/</td><td align="left">递归处理，将指定目录下的文件与子目录一并拷贝</td></tr><tr><td align="left">mv</td><td align="left"></td><td align="left">mv dir1 dir2</td><td align="left">移动文件或目录、文件或目录改名</td></tr><tr><td align="left">rm</td><td align="left"></td><td align="left">rm 1.txt</td><td align="left">删除文件</td></tr><tr><td align="left">\</td><td align="left"></td><td align="left">-rf</td><td align="left">rm -rf dir1</td></tr><tr><td align="left">rmdir</td><td align="left"></td><td align="left">rmdir dir1</td><td align="left">删除空目录</td></tr><tr><td align="left">cat</td><td align="left"></td><td align="left">cat 1.txt</td><td align="left">显示文本文件内容</td></tr></tbody></table><h4 id="2-系统常用命令"><a href="#2-系统常用命令" class="headerlink" title="2.系统常用命令"></a>2.系统常用命令</h4><table><thead><tr><th align="left">命令</th><th align="left">参数</th><th align="left">示例</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ps</td><td align="left"></td><td align="left"></td><td align="left">较少单独使用，配参数根据需求</td></tr><tr><td align="left">\</td><td align="left">-e /-A</td><td align="left">ps -e</td><td align="left">显示所有进程，环境变量</td></tr><tr><td align="left">\</td><td align="left">-f</td><td align="left">ps -ef</td><td align="left">全格式显示</td></tr><tr><td align="left">\</td><td align="left">-a</td><td align="left">ps -a</td><td align="left">显示所有用户的所有进程（包括其它用户）</td></tr><tr><td align="left">\</td><td align="left">-u</td><td align="left">ps -au</td><td align="left">按用户名和启动时间的顺序来显示进程</td></tr><tr><td align="left">\</td><td align="left">-x</td><td align="left">ps -aux</td><td align="left">显示无控制终端的进程</td></tr><tr><td align="left">reboot</td><td align="left"></td><td align="left">reboot</td><td align="left">重新启动</td></tr><tr><td align="left">ifconfig</td><td align="left"></td><td align="left">ifconfig</td><td align="left">网卡网络配置，常用于查看当前IP地址</td></tr><tr><td align="left">date</td><td align="left"></td><td align="left">date</td><td align="left">显示系统当前时间</td></tr><tr><td align="left">cal</td><td align="left"></td><td align="left">cal 3 2020</td><td align="left">显示指定月份的日历表</td></tr></tbody></table><p>ifconfig在使用树莓派的时候经常需要使用（查看地址来使用SSH连接），也可以使用<code>pi@raspberrypi.local</code>来获取树莓派的hostname，相比于使用ifconfig更方便。</p><h2 id="如何阅读MAN手册"><a href="#如何阅读MAN手册" class="headerlink" title="如何阅读MAN手册"></a>如何阅读MAN手册</h2><p>很显然，那么多的命令加上参数，对于人而言是不可能完完全全记住的，在Unix中，系统就为用户提供了查看命令的帮助信息，但是相对的也带来了一些问题，man手册的阅读对于人而言是很痛苦的（无高亮、命令行下，第二语言下），而且有时候理不清文档内容组织结构，思维很混乱，或者明白文档描述所用的体例，但不明白命令各种参数该如何组合也是比较痛苦的。</p><p>在联网的情况下，通常我都是查找开源的社区直接找命令，阅读效果比直接man 命令更好，并且例子丰富且多是实际状况下所需要的。网址见下：</p><p><a href="http://linux.51yip.com/">Linux命令手册查询</a></p><p>例图：<br><img src="/posts/24335/2.png"></p><img src="/posts/24335/3.png"><p>可见确实对于学习命令有很大的帮助</p><p><strong>那如果我需要在Shell中阅读man手册该如何做？</strong></p><h3 id="MAN手册分类"><a href="#MAN手册分类" class="headerlink" title="MAN手册分类"></a>MAN手册分类</h3><pre><code> man [OPTION...] [章节] 手册页...</code></pre><p>共有9卷：</p><table><thead><tr><th align="right">序号</th><th align="left">英文</th><th align="left">中文</th></tr></thead><tbody><tr><td align="right">1</td><td align="left">Executable programs or shell commands</td><td align="left">可执行程序或shell命令</td></tr><tr><td align="right">2</td><td align="left">System calls (functions provided by the kernel)</td><td align="left">系统调用</td></tr><tr><td align="right">3</td><td align="left">Library calls (functions within program libraries)</td><td align="left">库调用</td></tr><tr><td align="right">4</td><td align="left">Special files (usually found in /dev)</td><td align="left">特殊文件</td></tr><tr><td align="right">5</td><td align="left">File formats and conventions eg /etc/passwd</td><td align="left">文件格式和约定</td></tr><tr><td align="right">6</td><td align="left">Games</td><td align="left">游戏</td></tr><tr><td align="right">7</td><td align="left">Miscellaneous (including macro packages and conventions), e.g. man(7), groff(7)</td><td align="left">杂项（包括宏和惯例）</td></tr><tr><td align="right">8</td><td align="left">System administration commands (usually only for root)</td><td align="left">系统管理命令（通常仅适用于root用户）</td></tr><tr><td align="right">9</td><td align="left">Kernel routines [Non standard]</td><td align="left">内核例程（非标准）</td></tr></tbody></table><p>例如：man 2 mkdir</p><p>这时看到的是MKDIR(2)，表示是系统调用这个板块的。要知道，man在没有指定板块时，将使用一种默认的顺序查找这些板块中的命令，只返回含有该命令的第一个文档。当指定板块时，只从该板块中查找。所以，当我们man得不到想要的文档时，就要给出板块号了。</p><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><h3 id="Shell介绍"><a href="#Shell介绍" class="headerlink" title="Shell介绍"></a>Shell介绍</h3><p>shell是unix下负责用户与unix交互的程序，unix命令的处理是由位于用户与操作系统其他部分之间的shell完成的，shell是一个命令解释程序，每一个命令都是由shell来进行分析，然后执行用户请求的。</p><p>值得一提的是，一些UNIX命令时shell程序的一部分，成为shell命令或内部命令（builtin），它是由shell识别并在shell内部执行的。</p><h3 id="Shell的种类"><a href="#Shell的种类" class="headerlink" title="Shell的种类"></a>Shell的种类</h3><p>shell的种类比较多，目前流行的有：</p><ul><li>ksh</li><li>bash</li><li>dash</li><li>zsh等</li></ul><p>切换shell的话，可以直接将shell的名称输入到命令行即可，切换回原来的shell的话，chsh不加参数即可。</p><h3 id="etc-passwd文件"><a href="#etc-passwd文件" class="headerlink" title="/etc/passwd文件"></a>/etc/passwd文件</h3><p>在Linux /etc/passwd文件中每个用户都有一个对应的记录行，它记录了这个用户的一些基本属性,其中也包括了缺省的shell</p><img src="/posts/24335/4.png"><p>可以看到一条记录分为7个字段，以:为分隔符，如果以</p><blockquote><p>root: x:0:0:root:/root:/bin/bash</p></blockquote><p>来分析的话</p><ul><li>第一个 root:代表用户名（用户ID）</li><li>第二个 x:这个用户是否需要密码登录不写代表不需要密码（密码标志）</li><li>第三个 0:uid 用户id（0表示root用户，1-499表示系统用户，500-65535表示普通用户）</li><li>第四个 0:gid 用户组id（组ID）</li><li>第五个 root:注释（用户说明）</li><li>第六个 /root/ :用户的家目录（普通用户：/home/username root用户：/root）</li><li>第七个 /bin/bash：用户登录的命令解释器（登陆的shell，/sbin/nologin 代表不能登录）</li></ul><p>了解到此处即可。</p><h2 id="登录与退出过程"><a href="#登录与退出过程" class="headerlink" title="登录与退出过程"></a>登录与退出过程</h2><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>unix启动时，内核被装入内存，而操作系统的系统工具保存在系统磁盘上，在用户请求时才被装入执行。用户登陆时，shell程序被装入内存。<br>先来简述一下用户登陆的过程：</p><blockquote><p>系统自举时，init继承创建getty进程守护在各个终端上</p><p>当用户输入用户名时，执行login程序</p><p>login执行并提示用户输入password</p><p>当username、password验证成功,fork出shell进程</p></blockquote><p>详细描述的话</p><h4 id="Step1：系统启动时-init进程根据配置文件-etc-inittab确定需要打开哪些终端"><a href="#Step1：系统启动时-init进程根据配置文件-etc-inittab确定需要打开哪些终端" class="headerlink" title="Step1：系统启动时,init进程根据配置文件/etc/inittab确定需要打开哪些终端"></a>Step1：系统启动时,init进程根据配置文件/etc/inittab确定需要打开哪些终端</h4><p>按照配置文件进行</p><h4 id="Step2：getty完成任务"><a href="#Step2：getty完成任务" class="headerlink" title="Step2：getty完成任务"></a>Step2：getty完成任务</h4><p>getty根据命令行参数打开终端设备作为它的控制终端，把文件描述符0、1、2都指向控制终端，然后提示用户输入帐号。用户输入帐号之后，getty的任务就完成了,</p><p>它再执行login程序:</p><pre><code>execle(&quot;/bin/login&quot;, &quot;login&quot;, &quot;-p&quot;, username, NULL, envp)</code></pre><h4 id="Step3：login程序运行"><a href="#Step3：login程序运行" class="headerlink" title="Step3：login程序运行"></a>Step3：login程序运行</h4><p>login程序提示用户输入密码，且在输入密码期间关闭终端的回显，因此我们在linux下输入密码时是看不到的，然后验证帐号密码的正确性。</p><p>如果密码不正确，login进程终止。init会重新fork/exec一个getty进程。如果密码正确，login程序设置⼀些环境变量，设置当前工作⽬录为该⽤户的主目录，然后执行Shell:</p><pre><code>execl(&quot;/bin/bash&quot;, &quot;-bash&quot;, NULL)</code></pre><img style="width:400px;height:200px" src="/posts/24335/6.png"><h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><p>用户退出系统也是差不多类似的道理，shell程序终止执行，login退出，init回收login，然后init再fork出新的getty，来程序等待新用户的登录。</p><img style="width:200px;height:300px" src="/posts/24335/5.png">]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何把VS安到非系统盘</title>
      <link href="posts/49040/"/>
      <url>posts/49040/</url>
      
        <content type="html"><![CDATA[<p>最近打算安一下Unity相关的工具，结果打开VS一看要C盘需要5G <del>(不知为啥只剩下10G的可怜人）</del><br>因此为了给SSD减少些“压力”，搜索了一下方法，给C盘瘦了10G…<del>(与此同时明显感受到开项目运行变卡,要是有钱谁想整这些骚操作)</del></p><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><ul><li>从微软官网下载 Visual Studio(基本操作)</li><li>运行下载的安装程序，到选择安装的组件时退出程序</li></ul><a id="more"></a><h2 id="第二步：使用-mklink-创建链接"><a href="#第二步：使用-mklink-创建链接" class="headerlink" title="第二步：使用 mklink 创建链接"></a>第二步：使用 mklink 创建链接</h2><blockquote><p>原理：这一步的目的是欺骗 VS 安装程序，把它（将要或已经）放在系统盘的内容转移到其他盘，这样 VS 安装时仍然读写的是系统盘的路径，但实际上这些路径被我们转移到了非系统盘了，如此便释放了系统盘空间。</p></blockquote><p>基本用法：</p><pre class="line-numbers language-Shell"><code class="language-Shell">mklink /d "链接需要放置的路径" "链接指向的路径"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以下为 VS 占用的系统盘文件夹路径</p><pre class="line-numbers language-Text"><code class="language-Text">C:\\Program Files (x86)\\Microsoft SDKsC:\\Program Files (x86)\\Microsoft Visual StudioC:\\Program Files (x86)\\Windows KitsC:\\ProgramData\\Microsoft\VisualStudio<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>知道了原理操作起来就十分简单，这些必要的文件夹如果有文件在里面，就把这些文件夹移动到非系统盘，如果没有就删除他们（因为之后我们要创建链接，不删除就不能用他们的名字创建链接）。</p><p>对上面那些文件夹移动完成后使用 mklink /d 创建链接即可<br>下面是一段代码示例（注意 cmd 以管理员身份运行 powershell没有此命令）：</p><pre class="line-numbers language-Shell"><code class="language-Shell">mklink /d "C:\Program Files (x86)\Microsoft SDKs" "D:\Program Files (x86)\Microsoft Visual Studio\2017\C_Microsoft SDKs"mklink /d "C:\Program Files (x86)\Microsoft Visual Studio" "D:\Program Files (x86)\Microsoft Visual Studio\2017\C_Microsoft Visual Studio"mklink /d "C:\Program Files (x86)\Windows Kits" "D:\Program Files (x86)\Microsoft Visual Studio\2017\C_Windows Kits"mklink /d "C:\ProgramData\Microsoft\VisualStudio" "D:\Program Files (x86)\Microsoft Visual Studio\2017\C_VisualStudio"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>第二个参数即目标文件可以自己选</p><h2 id="第三步：以正常方式安装-VS"><a href="#第三步：以正常方式安装-VS" class="headerlink" title="第三步：以正常方式安装 VS"></a>第三步：以正常方式安装 VS</h2><p>打开 Visual Studio Installer安装即可，部分package还是需要放在C盘，但是至少可以少用10G（依照你的安装选项）</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习笔记(一)</title>
      <link href="posts/40875/"/>
      <url>posts/40875/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机硬件"><a href="#计算机硬件" class="headerlink" title="计算机硬件"></a>计算机硬件</h2><p>现代的计算机应该由运算器(算术逻辑与运算)，控制器(执行指令)，存储器(存储数据和指令)，输入设备和输出设备(通信)，其中处理器单元是计算机系统最智能的部分，处理器单元也成为CPU，包括了3个基本组成部分：</p><blockquote><ul><li>算术逻辑单元<br>  算术逻辑单元或ALU是CPU中控制所有算术运算和逻辑的电路，负责执行算术运算和逻辑运算</li><li>寄存器<br>  在CPU内部负责存储指令和数据</li><li>控制单元<br>  用来协调其他部分动作以执行程序指令的电路，并不执行指令本身，而是负责控制其他单元，把内存中的指令和数据传送到寄存器</li></ul></blockquote><a id="more"></a><p>除了上述提到的硬件，计算机还需要可以存储指令集的存储器，因此就需要内存。内存又分为随机存储器（RAM）和只读存储器（ROM），RAM允许CPU依据所求访问特定位置的存储器,允许修改和删除，但是其存储的数据不能被永久存储。而ROM能够永久保存计算机生产商放置在系统中的程序和数据，但是无法修改和删除。</p><p>内存的作用在于可以存储：</p><blockquote><p>当前程序指令<br>程序要处理的数据<br>执行程序指令时的中检结果</p></blockquote><p>值得注意的是，虽然内存用来存储CPU所需要的数据，但是CPU的处理速度是远远快于从内存中读取的速度的，因此就需要采用CPU缓存（Cache Memory）这一位于CPU和内存之间的临时存储器，解决CPU运算速度与内存读写速度不匹配的矛盾。现阶段都是采用三级缓存。</p><h2 id="程序的执行"><a href="#程序的执行" class="headerlink" title="程序的执行"></a>程序的执行</h2><p>程序由指令组成,程序启动前，指令和数据都存放在存储器中，形式上没有差别，都是0/1序列。任何要计算机完成的工作都要先被编写成程序，然后将程序和原始数据送入主存并启动执行。一旦程序被启动，计算机应能在不需操作人员干预下，自动完成逐条取出指令和执行指令的任务。</p><img style="width:400px;height:200px" src="/posts/40875/2.jpg"><p>为了方便用户与计算机交流，同时提高应用程序的资源利用率，于是便诞生了操作系统，操作系统是所有软件和硬件的控制程序的集合。总的来说，操作系统主要的功能在于：</p><blockquote><p>向用户和应用提供一个控制底层硬件功能的接口<br>向各用户的应用程序分配硬件资源<br>按用户要求加载和执行程序</p></blockquote><h2 id="Unix发展"><a href="#Unix发展" class="headerlink" title="Unix发展"></a>Unix发展</h2><p>1965年贝尔实验室（Bell Labs）、通用电气（General Electric）和麻省理工学院（MIT）欲共同打造MULTICS（Multiplexed Information and Computing Service）操作系统。</p><p>1969年贝尔实验室退出MULTICS</p><p>在此期间ken Tphmpson在multics制作了一款游戏：space Travel（星际旅行）跑在multics。</p><p>在bell 退出multics之后，ken Tphmpson不能使用multics的运算能力了，想要使用需要付费，所以决定自己写一个小型系统程序可以跑起自己的游戏。</p><p>于是ken找到一台老古董PDP-7，使用汇编语言编码，在上面写了系统，于是戏称为”UNiplexed Information and Computing Service”（UNICS），后改名为unix，并不断发展完善。</p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>Linux的名称是linux is not unix的缩写，Linux是开源免费的的类unix操作系统，主要用于服务器端。Linux操作系统的诞生、发展和成长过程始终依赖着五个重要支柱：UNIX 操作系统、MINIX 操作系统、GNU计划、POSIX 标准和Internet 网络。<br>其中最著名的是Linux哲学思想：</p><blockquote><p>一切都是一个文件（包括硬件）<br>小型，单一用途的程序<br>链接程序，共同完成复杂的任务<br>避免令人困惑的用户界面<br>配置数据存储在文本中</p></blockquote><h3 id="Linux特点"><a href="#Linux特点" class="headerlink" title="Linux特点"></a>Linux特点</h3><p>Linux操作系统一直是广泛应用于的操作系统，许多软硬件厂商都设计开发采用Linux操作系统的产品。而Linux系统能大范围的应用于，也是因为Linux系统所具有的特点优势。</p><ul><li>是一个完善的支持多用户、多任务、多进程、多CPU的系统</li><li>具有很高的系统稳定性和可靠性</li><li>具有很高的系统安全性</li><li>有完善的网络服务，支持HTTP、FTP、SMTP、POP、SAMBA、SNMP、DNS、DHCP、SSH、TELENT等</li><li>是基于GNU许可，自由开放的系统</li><li>有大量的第三方免费的应用程序</li><li>得到众多业界厂商的支持，如IBM、Oracle、Intel、HP、MOTO、Google等</li><li>有完善的大型数据库平台，包括Oracle、DB/2、Sybase、MySQL、PostgreSQL等</li><li>有完善的图形用户界面，包括GNOME、KDE等</li><li>有完善的开发平台</li></ul><h3 id="Linux系统架构"><a href="#Linux系统架构" class="headerlink" title="Linux系统架构"></a>Linux系统架构</h3><ul><li>内核：主要提供系统服务（不能被直接调用）</li><li>shell：壳，接口/界面</li><li>命令行shell——linux：sh，bash 等</li><li>图形化shell——linux：gnome，kde 等</li></ul><img style="width:400px;height:400px" src="/posts/40875/1.jpg"><h3 id="Linux环境"><a href="#Linux环境" class="headerlink" title="Linux环境"></a>Linux环境</h3><p>本人的Linux环境由VMware Workstation Pro下运行的虚拟机构成,在可以的情况下也使用Git Bash，同时也会使用树莓派下的Debian，意在打造真实的Linux环境，来进行后续一系列的学习。<br><img style="width:400px;height:300px" src="/posts/40875/3.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本博客搭建详细教程</title>
      <link href="posts/6/"/>
      <url>posts/6/</url>
      
        <content type="html"><![CDATA[<h2 id="本博客详细教程地址"><a href="#本博客详细教程地址" class="headerlink" title="本博客详细教程地址"></a>本博客详细教程地址</h2><p>使用的系列教程：</p><ul><li><a href="http://sitoi.cn/posts/6666.html">基于 Hexo GitHub 从零开始搭建个人博客（一）：环境准备篇</a></li><li><a href="https://sitoi.cn/posts/27801.html">基于 Hexo GitHub 从零开始搭建个人博客（二）：搭建基础篇</a></li><li><a href="https://sitoi.cn/posts/63466.html">基于 Hexo GitHub 从零开始搭建个人博客（三）：Matery 主题（DIY 版）详细配置教程，附博客源码</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Play-with-Algorithms(8):详解AVL树</title>
      <link href="posts/22562/"/>
      <url>posts/22562/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><del>你会手写AVL树吗？</del></p><blockquote><p>Wiki:在计算机科学中，AVL树是最早被发明的自平衡二叉查找树。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是 O(logn）。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。AVL 树得名于它的发明者 G. M. Adelson-Velsky 和 Evgenii Landis，他们在1962年的论文《An algorithm for the organization of information》中公开了这一数据结构。</p></blockquote><a id="more"></a><h2 id="1-为什么要有平衡二叉树"><a href="#1-为什么要有平衡二叉树" class="headerlink" title="1 为什么要有平衡二叉树"></a>1 为什么要有平衡二叉树</h2><p>二叉搜索树一定程度上可以提高搜索效率，但是当原序列有序时，例如序列 A = {1，2，3，4，5，6}，构造二叉搜索树如图 1.1。依据此序列构造的二叉搜索树为右斜树，同时二叉树退化成单链表，搜索效率降低为 O(n)。<br><img src="/posts/22562/1.png" alt="图片1"></p><p>在此二叉搜索树中查找元素 6 需要查找 6 次。</p><p>二叉搜索树的查找效率取决于树的高度，因此保持树的高度最小，即可保证树的查找效率。同样的序列 A，将其改为图 1.2 的方式存储，查找元素 6 时只需比较 3 次，查找效率提升一倍。<br><img src="/posts/22562/2.png" alt="图片1"><br>可以看出当节点数目一定，保持树的左右两端保持平衡，树的查找效率最高。</p><p><strong>这种左右子树的高度相差不超过 1 的树为平衡二叉树。</strong></p><h2 id="2-定义"><a href="#2-定义" class="headerlink" title="2. 定义"></a>2. 定义</h2><p><strong>平衡二叉查找树</strong>：简称平衡二叉树。由前苏联的数学家 Adelse-Velskil 和 Landis 在 1962 年提出的高度平衡的二叉树，根据科学家的英文名也称为 AVL 树。它具有如下几个性质：</p><ol><li>可以是空树。</li><li>假如不是空树，任何一个节点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。</li></ol><p>平衡之意，如天平，即两边的分量大约相同。</p><p>例如图 2.1 不是平衡二叉树，因为节点 60 的左子树不是平衡二叉树。</p><p><img src="/posts/22562/3.png" alt="图片1"></p><p>图 2.2 也不是平衡二叉树，因为虽然任何一个节点的左子树与右子树都是平衡二叉树，但高度之差已经超过 1 。</p><p><img src="/posts/22562/4.png" alt="图片1"></p><p>图 2.3 是平衡二叉树。</p><p><img src="/posts/22562/5.png" alt="图片1"></p><h2 id="3-平衡因子"><a href="#3-平衡因子" class="headerlink" title="3. 平衡因子"></a>3. 平衡因子</h2><p><strong>定义：</strong> 某节点的左子树与右子树的高度(深度)差即为该节点的平衡因子（BF,Balance Factor），平衡二叉树中不存在平衡因子大于 1 的节点。在一棵平衡二叉树中，节点的平衡因子只能取 0 、1 或者 -1 ，分别对应着左右子树等高，左子树比较高，右子树比较高。</p><p><img src="/posts/22562/6.png" alt="图片1"></p><p><img src="/posts/22562/7.png" alt="图片1"></p><p><img src="/posts/22562/8.png" alt="图片1"></p><h2 id="4-节点结构"><a href="#4-节点结构" class="headerlink" title="4. 节点结构"></a>4. 节点结构</h2><p>定义平衡二叉树的节点结构：</p><pre class="line-numbers language-C++"><code class="language-C++">typedef struct AVLNode *Tree;typedef int ElementType;struct AVLNode{    int depth; //深度，这里计算每个节点的深度，通过深度的比较可得出是否平衡    Tree parent; //该节点的父节点    ElementType val; //节点值    Tree lchild;    Tree rchild;    AVLNode(int val=0) {        parent = NULL;        depth = 0;        lchild = rchild = NULL;        this->val=val;    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-AVL树插入时的失衡与调整"><a href="#5-AVL树插入时的失衡与调整" class="headerlink" title="5. AVL树插入时的失衡与调整"></a>5. AVL树插入时的失衡与调整</h2><p>图 5.1 是一颗平衡二叉树<br><img src="/posts/22562/9.png" alt="图片1"><br>在此平衡二叉树插入节点 99 ，树结构变为：<br><img src="/posts/22562/1.gif" alt="图片1"><br>在动图 5.2 中，节点 66 的左子树高度为 1，右子树高度为 3，此时平衡因子为 -2，树失去平衡。</p><p>在动图 5.2 中，以节点 66 为父节点的那颗树就称为 <strong>最小失衡子树</strong>。</p><p><strong>最小失衡子树：</strong> 在新插入的节点向上查找，以第一个平衡因子的绝对值超过 1 的节点为根的子树称为最小不平衡子树。也就是说，一棵失衡的树，是有可能有多棵子树同时失衡的。而这个时候，我们只要调整最小的不平衡子树，就能够将不平衡的树调整为平衡的树。</p><p><strong>平衡二叉树的失衡调整主要是通过旋转最小失衡子树来实现的。</strong> 根据旋转的方向有两种处理方式，<strong>左旋</strong> 与 <strong>右旋</strong> 。</p><p>旋转的目的就是减少高度，通过降低整棵树的高度来平衡。哪边的树高，就把那边的树向上旋转。</p><h3 id="5-1-左旋"><a href="#5-1-左旋" class="headerlink" title="5.1 左旋"></a>5.1 左旋</h3><p><img src="/posts/22562/10.png" alt="图片1"></p><p>以图 5.1.1 为例，加入新节点 99 后， 节点 66 的左子树高度为 1，右子树高度为 3，此时平衡因子为 -2。为保证树的平衡，此时需要对节点 66 做出旋转，因为右子树高度高于左子树，对节点进行左旋操作，流程如下：</p><ul><li>（1）节点的右孩子替代此节点位置</li><li>（2）右孩子的左子树变为该节点的右子树</li><li>（3）节点本身变为右孩子的左子树</li></ul><p>整个操作流程如动图 5.1.2 所示。</p><p><img src="/posts/22562/2.gif" alt="图片1"></p><h3 id="5-2-右旋"><a href="#5-2-右旋" class="headerlink" title="5.2 右旋"></a>5.2 右旋</h3><p>右旋操作与左旋类似，操作流程为：</p><ul><li>（1）节点的左孩子代表此节点</li><li>（2）节点的左孩子的右子树变为节点的左子树</li><li>（3）将此节点作为左孩子节点的右子树。</li></ul><p><img src="/posts/22562/3.gif" alt="图片1"></p><h2 id="6-AVL树的四种插入节点方式"><a href="#6-AVL树的四种插入节点方式" class="headerlink" title="6. AVL树的四种插入节点方式"></a>6. AVL树的四种插入节点方式</h2><p>假设一颗 AVL 树的某个节点为 A，有四种操作会使 A 的左右子树高度差大于 1，从而破坏了原有 AVL 树的平衡性。平衡二叉树插入节点的情况分为以下四种：</p><p><img src="/posts/22562/11.png" alt="图片1"><br>具体分析如下：</p><h3 id="6-1-A的左孩子的左子树插入节点-LL"><a href="#6-1-A的左孩子的左子树插入节点-LL" class="headerlink" title="6.1 A的左孩子的左子树插入节点(LL)"></a>6.1 A的左孩子的左子树插入节点(LL)</h3><p>只需要执行一次右旋即可。<br><img src="/posts/22562/4.gif" alt="图片1"></p><p><strong>实现代码如下：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">//LL型调整函数//返回:新父节点Tree LL_rotate(Tree node){    //node为离操作节点最近的失衡的节点    Tree parent=NULL,son;    //获取失衡节点的父节点    parent=node->parent;    //获取失衡节点的左孩子    son=node->lchild;    //设置son节点右孩子的父指针    if (son->rchild!=NULL)  son->rchild->parent=node;    //失衡节点的左孩子变更为son的右孩子    node->lchild=son->rchild;    //更新失衡节点的高度信息    update_depth(node);    //失衡节点变成son的右孩子    son->rchild=node;    //设置son的父节点为原失衡节点的父节点    son->parent=parent;    //如果失衡节点不是根节点，则开始更新父节点    if (parent!=NULL){        //如果父节点的左孩子是失衡节点，指向现在更新后的新孩子son        if (parent->lchild==node){            parent->lchild=son;        }else{             //父节点的右孩子是失衡节点              parent->rchild=son;        }     }    //设置失衡节点的父亲    node->parent=son;    //更新son节点的高度信息    update_depth(son);    return son;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-2-A的右孩子的右子树插入节点-RR"><a href="#6-2-A的右孩子的右子树插入节点-RR" class="headerlink" title="6.2 A的右孩子的右子树插入节点(RR)"></a>6.2 A的右孩子的右子树插入节点(RR)</h3><p>只需要执行一次左旋即可。<br><img src="/posts/22562/5.gif" alt="图片1"><br>实现代码如下：</p><pre class="line-numbers language-C++"><code class="language-C++">//RR型调整函数//返回新父节点Tree RR_rotate(Tree node){    //node为离操作节点最近的失衡的节点    Tree parent=NULL,son;    //获取失衡节点的父节点    parent=node->parent;    //获取失衡节点的右孩子    son=node->rchild;    //设置son节点左孩子的父指针    if (son->lchild!=NULL){          son->lchild->parent=node;    }    //失衡节点的右孩子变更为son的左孩子    node->rchild=son->lchild;    //更新失衡节点的高度信息    update_depth(node);    //失衡节点变成son的左孩子    son->lchild=node;    //设置son的父节点为原失衡节点的父节点    son->parent=parent;    //如果失衡节点不是根节点，则开始更新父节点    if (parent!=NULL){        //如果父节点的左孩子是失衡节点，指向现在更新后的新孩子son        if (parent->lchild==node){            parent->lchild=son;        }else{            //父节点的右孩子是失衡节点            parent->rchild=son;        }     }    //设置失衡节点的父亲    node->parent=son;    //更新son节点的高度信息    update_depth(son);    return son;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-3-A的左孩子的右子树插入节点-LR"><a href="#6-3-A的左孩子的右子树插入节点-LR" class="headerlink" title="6.3 A的左孩子的右子树插入节点(LR)"></a>6.3 A的左孩子的右子树插入节点(LR)</h3><p>若 A 的左孩子节点 B 的右子树 E 插入节点 F ，导致节点 A 失衡，如图：<br><img src="/posts/22562/12.png" alt="图片1"><br>A 的平衡因子为 2 ，若仍按照右旋调整，则变化后的图形为这样：<br><img src="/posts/22562/13.png" alt="图片1"><br>经过右旋调整发现，调整后树仍然失衡，说明这种情况单纯的进行右旋操作不能使树重新平衡。那么这种插入方式需要执行两步操作，使得旋转之后为 <strong>原来根节点的左孩子的右孩子作为新的根节点</strong>。</p><p>（1）对失衡节点 A 的左孩子 B 进行左旋操作，即上述 RR 情形操作。<br>（2）对失衡节点 A 做右旋操作，即上述 LL 情形操作。</p><p>调整过程如下：<br><img src="/posts/22562/14.png" alt="图片1"><br><img src="/posts/22562/15.png" alt="图片1"></p><p>也就是说，经过这两步操作，使得 <strong>原来根节点的左孩子的右孩子 E 节点成为了新的根节点。</strong><br>代码实现：</p><pre class="line-numbers language-c++"><code class="language-c++">//LR型，先左旋转，再右旋转//返回：新父节点Tree LR_rotate(Tree node){    RR_rotate(node->lchild);    return LL_rotate(node);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-4-A的右孩子的左子树插入节点-RL"><a href="#6-4-A的右孩子的左子树插入节点-RL" class="headerlink" title="6.4 A的右孩子的左子树插入节点(RL)"></a>6.4 A的右孩子的左子树插入节点(RL)</h3><p>右孩子插入左节点的过程与左孩子插入右节点过程类似，也是需要执行两步操作，使得旋转之后为 <strong>原来根节点的右孩子的左孩子作为新的根节点。</strong></p><p>（1）对失衡节点 A 的右孩子 C 进行右旋操作，即上述 LL 情形操作。<br>（2）对失衡节点 A 做左旋操作，即上述 RR 情形操作。<br><img src="/posts/22562/16.png" alt="图片1"><br><img src="/posts/22562/17.png" alt="图片1"><br><img src="/posts/22562/18.png" alt="图片1"><br>也就是说，经过这两步操作，使得 原来根节点的右孩子的左孩子 D 节点成为了新的根节点。</p><p>代码实现：</p><pre class="line-numbers language-C++"><code class="language-C++">//RL型，先右旋转，再左旋转//返回:新父节点Tree RL_rotate(Tree node){    LL_rotate(node->rchild);    return RR_rotate(node);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>补充：</strong><br>上述四种插入方式的代码实现的辅助代码如下：</p><pre class="line-numbers language-C++"><code class="language-C++">//更新当前深度void update_depth(Tree node){    if (node==NULL){        return;    }else{        int depth_Lchild=get_balance(node->lchild); //左孩子深度        int depth_Rchild=get_balance(node->rchild); //右孩子深度        node->depth=max(depth_Lchild,depth_Rchild)+1;    }}//获取当前节点的深度int get_balance(Tree node){    if (node==NULL){         return 0;    }    return node->depth;}//返回当前平衡因子int is_balance(Tree node){    if (node==NULL){         return 0;    }else{         return get_balance(node->lchild)-get_balance(node->rchild);     }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-5-小总结"><a href="#6-5-小总结" class="headerlink" title="6.5 小总结"></a>6.5 小总结</h3><ol><li>在所有的不平衡情况中，都是按照先 <strong>寻找最小不平衡树</strong>，然后 <strong>寻找所属的不平衡类别</strong>，再 <strong>根据 4 种类别进行固定化程序的操作。</strong></li><li>LL , LR ，RR ，RL其实已经为我们提供了最后哪个节点作为新的根指明了方向。如 LR 型最后的根节点为原来的根的左孩子的右孩子，RL 型最后的根节点为原来的根的右孩子的左孩子。只要记住这四种情况，可以很快地推导出所有的情况。</li><li>维护平衡二叉树，最麻烦的地方在于平衡因子的维护。建议读者们根据小吴提供的图片和动图，自己动手画一遍，这样可以更加感性的理解操作。</li></ol><h2 id="7-AVL树的四种删除节点方式"><a href="#7-AVL树的四种删除节点方式" class="headerlink" title="7. AVL树的四种删除节点方式"></a>7. AVL树的四种删除节点方式</h2><p>AVL 树和二叉查找树的删除操作情况一致，都分为四种情况：</p><p>（1）删除叶子节点<br>（2）删除的节点只有左子树<br>（3）删除的节点只有右子树<br>（4）删除的节点既有左子树又有右子树</p><p>只不过 AVL 树在删除节点后需要重新<strong>检查平衡性并修正</strong>，同时，删除操作与插入操作后的平衡修正区别在于，插入操作后只需要对插入栈中的弹出的第一个非平衡节点进行修正，而删除操作需要修正栈中的所有非平衡节点。</p><p>删除操作的大致步骤如下：</p><ul><li>以前三种情况为基础尝试删除节点，并将访问节点入栈。</li><li>如果尝试删除成功，则依次检查栈顶节点的平衡状态，遇到非平衡节点，即进行旋转平衡，直到栈空。</li><li>如果尝试删除失败，证明是第四种情况。这时先找到被删除节点的右子树最小节点并删除它，将访问节点继续入栈。</li><li>再依次检查栈顶节点的平衡状态和修正直到栈空。</li></ul><p>对于删除操作造成的非平衡状态的修正，可以这样理解：对左或者右子树的删除操作相当于对右或者左子树的插入操作，然后再对应上插入的四种情况选择相应的旋转就好了。</p><h3 id="7-1-删除叶子节点"><a href="#7-1-删除叶子节点" class="headerlink" title="7.1 删除叶子节点"></a>7.1 删除叶子节点</h3><p>处理步骤：</p><p>①、将该节点直接从树中删除；</p><p>②、其父节点的子树高度的变化将导致父节点平衡因子的变化，通过向上检索并推算其父节点是否失衡；</p><p>③、如果其父节点未失衡，则继续向上检索推算其父节点的父节点是否失衡…如此反复②的判断，直到根节点 ；如果向上推算过程中发现了失衡的现象，则进行 ④ 的处理；</p><p>④、如果其父节点失衡，则判断是哪种失衡类型 [LL、LR、RR、RL] ，并对其进行相应的平衡化处理。如果平衡化处理结束后，发现与原来以父节点为根节点的树的高度发生变化，则继续进行 ② 的检索推算；如果与原来以父节点为根节点的高度一致时，则可说明父节点的父节点及祖先节点的平衡因子将不会有变化，因此可以退出处理；</p><p><img src="/posts/22562/6.gif" alt="图片1"></p><p>具体数字演示：</p><p><img src="/posts/22562/7.gif" alt="图片1"></p><h3 id="7-2-amp-7-3-删除的节点只有左子树或右子树"><a href="#7-2-amp-7-3-删除的节点只有左子树或右子树" class="headerlink" title="7.2 &amp; 7.3 删除的节点只有左子树或右子树"></a>7.2 &amp; 7.3 删除的节点只有左子树或右子树</h3><p>处理步骤：</p><p>①、将左子树（右子树）替代原有节点 C 的位置；</p><p>②、节点 C 被删除后，则以 C 的父节点 B 为起始推算点，依此向上检索推算各节点（父、祖先）是否失衡；</p><p>③、如果其父节点未失衡，则继续向上检索推算其父节点 的父节点 是否失衡…如此反复 ② 的判断，直到根节点 ；如果向上推算过程中发现了失衡的现象，则进行 ④ 的处理；</p><p>④、如果其父节点失衡，则判断是哪种失衡类型 [LL、LR、RR、RL] ，并对其进行相应的平衡化处理。如果平衡化处理结束后，发现与原来以父节点为根节点的树的高度发生变化，则继续进行 ② 的检索推算；如果与原来以父节点为根节点的高度一致时，则可说明父节点的父节点及祖先节点的平衡因子将不会有变化，因此可以退出处理；<br><img src="/posts/22562/8.gif" alt="图片1"></p><h3 id="7-4-删除的节点既有左子树又有右子树"><a href="#7-4-删除的节点既有左子树又有右子树" class="headerlink" title="7.4 删除的节点既有左子树又有右子树"></a>7.4 删除的节点既有左子树又有右子树</h3><p>处理步骤：</p><p>①、找到被删节点 B 和替代节点 BLR (节点 B 的前继节点或后继节点 —— 在此选择 <strong>前继</strong>)；</p><p>②、将替代节点 BLR 的值赋给节点 B ，再把替代节点 BLR 的左孩子 BLRL 替换替代节点 BLR 的位置；</p><p>③、以 BLR 的父节点 BL 为起始推算点，依此向上检索推算父节点或祖先节点是否失衡；</p><p>④、如果其父节点未失衡，则继续向上检索推算其父节点的父节点是否失衡…如此反复③的判断，直到根节点；如果向上推算过程中发现了失衡的现象，则进行⑤的处理；</p><p>⑤、如果其父节点失衡，则判断是哪种失衡类型 [LL、LR、RR、RL] ，并对其进行相应的平衡化处理。如果平衡化处理结束后，发现与原来以父节点为根节点的树的高度发生变化，则继续进行 ② 的检索推算；如果与原来以父节点为根节点的高度一致时，则可说明父节点的父节点及祖先节点的平衡因子将不会有变化，因此可以退出处理；</p><p><img src="/posts/22562/9.gif" alt="图片1"></p><p>注：并没有给出 AVL 的删除操作的代码，也没有给出平衡性修复的动画，因为并不打算过多去讨论它，更复杂的删除操作过程将放在后续的 红黑树 中进行讨论。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过对 AVL 的插入操作和删除操作可以看出，平衡二叉树的优势在于不会出现普通二叉查找树的最差情况，即退化成链表结构，但为了保证高度平衡（对称），动态插入和删除的代价也随之增加。</p><p>AVL 的旋转问题看似复杂，但实际上如果你亲自用笔纸操作一下还是很好理解的。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Play-with-Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接雨水</title>
      <link href="posts/34649/"/>
      <url>posts/34649/</url>
      
        <content type="html"><![CDATA[<p>接雨水这道题目挺有意思，本文就来步步优化，讲解一下这道题。<br><img src="/posts/34649/1.png" alt="1"><br>题目来自 leetcode-cn.com<br>就是用一个数组表示一个条形图，问你这个条形图最多能接多少水。</p><pre class="line-numbers language-C++"><code class="language-C++">int trap(int[] height);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面就来由浅入深介绍暴力解法 -&gt; 备忘录解法 -&gt; 双指针解法，在 O(N) 时间 O(1) 空间内解决这个问题。</p> <a id="more"></a><h3 id="一、核心思路"><a href="#一、核心思路" class="headerlink" title="一、核心思路"></a>一、核心思路</h3><p>对于这种问题，我们不要想整体，而应该去想局部；就像处理字符串问题，不要考虑如何处理整个字符串，而是去思考应该如何处理每一个字符。<br>这么一想，可以发现这道题的思路其实很简单。具体来说，仅仅对于位置 i，能装下多少水呢？<br><img src="/posts/34649/2.png" alt="2"><br>能装 2 格水。为什么恰好是两格水呢？因为 height[i] 的高度为 0，而这里最多能盛 2 格水，2-0=2。</p><p>为什么位置 i 最多能盛 2 格水呢？因为，位置 i 能达到的水柱高度和其左边的最高柱子、右边的最高柱子有关，我们分别称这两个柱子高度为l_max和r_max；位置 i 最大的水柱高度就是<strong>min(l_max, r_max)</strong>。</p><p>更进一步，对于位置 i，能够装的水为：</p><pre class="line-numbers language-C++"><code class="language-C++">water[i] = min(               # 左边最高的柱子               max(height[0..i]),                 # 右边最高的柱子               max(height[i..end])             ) - height[i]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/34649/3.png" alt="3"><br><img src="/posts/34649/4.png" alt="4"></p><p>这就是本问题的核心思路，我们可以简单写一个暴力算法：<br><img src="/posts/34649/5.png" alt="5"><br>有之前的思路，这个解法应该是很直接粗暴的，时间复杂度 O(N^2)，空间复杂度 O(1)。但是很明显这种计算r_max和l_max的方式非常笨拙，一般的优化方法就是备忘录。</p><h3 id="二、备忘录优化"><a href="#二、备忘录优化" class="headerlink" title="二、备忘录优化"></a>二、备忘录优化</h3><p>之前的暴力解法，不是在每个位置 i 都要计算r_max和l_max吗？我们直接把结果都缓存下来，别傻不拉几的每次都遍历，这时间复杂度不就降下来了嘛。</p><p>我们开两个数组r_max和l_max充当备忘录，<strong>l_max[i]表示位置 i 左边最高的柱子高度，r_max[i]表示位置 i 右边最高的柱子高度</strong>。预先把这两个数组计算好，避免重复计算：<br><img src="/posts/34649/6.png" alt="6"><br>这个优化其实和暴力解法差不多，就是避免了重复计算，把时间复杂度降低为 O(N)，已经是最优了，但是空间复杂度是 O(N)。下面来看一个精妙一些的解法，能够把空间复杂度降低到 O(1)。</p><h3 id="三、双指针解法"><a href="#三、双指针解法" class="headerlink" title="三、双指针解法"></a>三、双指针解法</h3><p>这种解法的思路是完全相同的，但在实现手法上非常巧妙，我们这次也不要用备忘录提前计算了，而是用双指针边走边算，节省下空间复杂度。</p><p>首先，看一部分代码：</p><pre class="line-numbers language-C++"><code class="language-C++">int trap(vector<int>& height) {    int n = height.size();    int left = 0, right = n - 1;    int l_max = height[0];    int r_max = height[n - 1];    while (left <= right) {        l_max = max(l_max, height[left]);        r_max = max(r_max, height[right]);        left++; right--;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于这部分代码，请问l_max和r_max分别表示什么意义呢？<br>很容易理解，<strong>l_max是height[0..left]中最高柱子的高度，r_max是height[right..end]的最高柱子的高度</strong>。</p><p>明白了这一点，直接看解法：<br><img src="/posts/34649/7.png" alt="7"></p><p>你看，其中的核心思想和之前一模一样，换汤不换药。但是细心的读者可能会发现次解法还是有点细节差异：</p><p>之前的备忘录解法，l_max[i]和r_max[i]代表的是height[0..i]和height[i..end]的最高柱子高度。</p><pre class="line-numbers language-C++"><code class="language-C++">ans += min(l_max[i], r_max[i]) - height[i];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/34649/8.png" alt="8"><br>但是双指针解法中，l_max和r_max代表的是height[0..left]和height[right..end]的最高柱子高度。比如这段代码：</p><pre class="line-numbers language-C++"><code class="language-C++">if (l_max < r_max) {    ans += l_max - height[left];    left++;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/34649/9.png" alt="9"><br>此时的l_max是left指针左边的最高柱子，但是r_max并不一定是left指针右边最高的柱子，这真的可以得到正确答案吗？</p><p>其实这个问题要这么思考，我们只在乎min(l_max, r_max)。对于上图的情况，我们已经知道l_max &lt; r_max了，至于这个r_max是不是右边最大的，不重要，重要的是<strong>height[i]能够装的水只和l_max有关</strong>。</p><p><img src="/posts/34649/10.png" alt="10"></p><p>对于 l_max &gt; r_max 的情况也是类似的。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ “接口”与“实现”分离的两种方法</title>
      <link href="posts/51223/"/>
      <url>posts/51223/</url>
      
        <content type="html"><![CDATA[<h3 id="接口需求"><a href="#接口需求" class="headerlink" title="接口需求"></a>接口需求</h3><p>在软件开发这个行业中，一个较大的软件项目，一般由几个小组共同开发完成，为了将小组之间的影响降低到最低，定义好接口势在必行，如若要求短时间开发完成，定义好接口更是如此。或者说你的客户要求为其提供实现某个功能的接口，然后再在这些接口的基础上进行二次开发，如何定义才能定义好的接口呢? 第一，接口名字和实际的功能相符合；第二、接口要对数据进行封装，不允许客户直接操作接口之下的数据，尤其是使用new和delete在堆上操作内存数据。因为客户很容易由于操作不当造成错误，误以为是设计的接口有问题。</p><h3 id="接口与实现分离"><a href="#接口与实现分离" class="headerlink" title="接口与实现分离"></a>接口与实现分离</h3><p>c++中实现对接口与实现进行分离有两种方法，一种是将对象的实现细目隐藏于指针背后，简单的说就是将其分成两个类，一个类只提供接口，另一个负责实现该接口，这种设计手法常称为Pimpl Idiom(pointer to implementation)。<br>另一种方法就是将接口定义为抽象类，接口全被定义为纯虚函数（纯虚函数没有具体的实现方法），派生类的成员函数负责实现这些接口。这种设计手法称为Object Interface。千万不要忘记把抽象接口类的析构函数定义为virtual函数，可能会造成内存泄漏。</p> <a id="more"></a><h3 id="Pimpl-Idiom手法"><a href="#Pimpl-Idiom手法" class="headerlink" title="Pimpl Idiom手法"></a>Pimpl Idiom手法</h3><p>下面举个简单的例子，要求实现一个Person接口，其要包含如下四个函数：</p><p>string&amp; getName() const;<br>void setName(string&amp; name);<br>int getAge() const;<br>void setAge(int age);<br>它们的功能是设置获取名字和年龄。其声明在Person.h文件中，具体接口如下：</p><pre class="line-numbers language-C++"><code class="language-C++">#include<string>class PersonImpl;using namespace std;class Person {public:    Person(string& name, int age);    virtual ~Person();    string& getName() const;    void setName(string& name);    int getAge() const;    void setAge(int age);private:    PersonImpl *mPersonImpl;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Person.cpp文件中定义了具体函数接口，其内容如下：</p><pre class="line-numbers language-C++"><code class="language-C++">#include "Person.h"#include "PersonImpl.h"Person::Person(string& name, int age):    mPersonImpl(new PersonImpl(name, age)){    std::cout << "construct Person" << std::endl;}Person::~Person() {    delete mPersonImpl;    std::cout << "deconstruct Person" << std::endl;}string& Person::getName() const {    return mPersonImpl->getName();}void Person::setName(string& name) {    mPersonImpl->setName(name);}int Person::getAge() const {    return mPersonImpl->getAge();}void Person::setAge(int age) {    mPersonImpl->setAge(age);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Person.cpp文件中定义了具体函数接口，其内容如下：</p><pre class="line-numbers language-c++"><code class="language-c++">#include "Person.h"#include "PersonImpl.h"Person::Person(string& name, int age):    mPersonImpl(new PersonImpl(name, age)){    std::cout << "construct Person" << std::endl;}Person::~Person() {    delete mPersonImpl;    std::cout << "deconstruct Person" << std::endl;}string& Person::getName() const {    return mPersonImpl->getName();}void Person::setName(string& name) {    mPersonImpl->setName(name);}int Person::getAge() const {    return mPersonImpl->getAge();}void Person::setAge(int age) {    mPersonImpl->setAge(age);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>PersonImpl.h声明了实现接口背后所需细目的函数接口，其内容如下：</p><pre class="line-numbers language-C++"><code class="language-C++">#include<string>#include <iostream>using namespace std;class PersonImpl {public:    PersonImpl(string& name, int age);    virtual ~PersonImpl();    string& getName() const;    void setName(string& name);    int getAge() const;    void setAge(int age);private:    string& mName;    int mAge;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>PersonImpl.cpp中负责实现这些接口背后的细目函数，其内容如下：</p><pre class="line-numbers language-c++"><code class="language-c++">PersonImpl::PersonImpl(string& name, int age):    mName(name),    mAge(age){}PersonImpl::~PersonImpl() {}string& PersonImpl::getName() const {    return mName;}void PersonImpl::setName(string& name) {    mName = name;}int PersonImpl::getAge() const {    return mAge;}void PersonImpl::setAge(int age) {    mAge = age;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的例子中可以发现，在对外提供的接口函数中，只包含操作背后细目数据的接口方法，致使客户无法直接操作接口背后的细目数据，因此最大限度地降低了客户错误使用的可能性。</p><h3 id="Object-Interface手法"><a href="#Object-Interface手法" class="headerlink" title="Object Interface手法"></a>Object Interface手法</h3><p>同样我们参照上面那个例子，要求实现一个Animal接口，其由如下四个接口组成：<br>string&amp; getName() const;<br>void setName(string&amp; name);<br>int getAge() const;<br>void setAge(int age);<br>它们的功能也是设置和获取名字和年龄，不同的是类不一样罢了，其声明在Animal.h文件中，具体接口如下：</p><pre class="line-numbers language-C++"><code class="language-C++">#include <string>using namespace std;class Animal {public:    Animal(){};    virtual ~Animal(){};    virtual string& getName() const = 0;    virtual void setName(string& name) = 0;    virtual int getAge() const = 0;    virtual void setAge(int age) = 0;};Animal* creat(string& name, int age);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>真正实现Animal类声明的接口函数，声明在RealAnimal.h中，具体细节如下：</p><pre class="line-numbers language-C++"><code class="language-C++">#include "Animal.h"class RealAnimal: public Animal {public:    RealAnimal(string& name, int age);    virtual ~RealAnimal();    string& getName() const;    void setName(string& name);    int getAge() const;    void setAge(int age);private:    friend Animal* creat(string& name, int age);private:    string& mName;    int mAge;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>真正实现Animal类声明的接口函数，声明在RealAnimal.h中，具体细节如下：</p><pre class="line-numbers language-C++"><code class="language-C++">#include "Animal.h"class RealAnimal: public Animal {public:    RealAnimal(string& name, int age);    virtual ~RealAnimal();    string& getName() const;    void setName(string& name);    int getAge() const;    void setAge(int age);private:    friend Animal* creat(string& name, int age);private:    string& mName;    int mAge;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在RealAnimal类中，除了继承的接口函数的声明之外，还多了一个友元函数，其有点类似于工厂函数，其作用就是实例化一个对象。下面看一下接口真正的实现细节，具体如下：</p><pre class="line-numbers language-c++"><code class="language-c++">#include "RealAnimal.h"RealAnimal::RealAnimal(string& name, int age):    mName(name),    mAge(age){}RealAnimal::~RealAnimal(){}string& RealAnimal::getName() const {    return mName;}void RealAnimal::setName(string& name){    mName = name;}int RealAnimal::getAge() const{    return mAge;}void RealAnimal::setAge(int age){    mAge = age;}Animal* creat(string& name, int age) {    return new RealAnimal(name, age);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如前面所说，Animal* creat(string&amp; name, int age)确实只是实例化一个RealAnimal对象，返回的却是Animal接口对象，所以必须将类Animal 的析构函数声明为虚函数，不然会造成内存泄漏。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>无论是Impl Idiom手法，还是Object Interface手法都实现了同样的接口，而且它们有一个共同的目的，降低用户（被提供接口的小组也称为客户）直接操作数据造成不必要错误的可能性。其实它们有一个重要的优点就是将模块的依赖性降到了最低，举个例子吧，假如客户在使用这些接口的时候，如果这些接口内部的实现细目变更了，客户也不需要再重新编译自己的代码，因为客户只依赖接口声明的头文件。如果客户依赖接口的代码量非常大，那么，这个时候，这样定义接口就非常有必要了，毕竟客户在不修改自己代码的前提下，不需要重新编译自己的代码，这样可以提高客户的效率。</p><p>其实，这样来设计接口还是有缺点的，虽然接口定义在一个类中，但是真正实例化接口类的过程中，编译器会自动替我们生成必需的成员函数（比如构造函数、拷贝构造函数等），显然Animal也不例外。虽然有这样的缺点，但还是瑕不掩瑜。</p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 定义和使用接口类</title>
      <link href="posts/10571/"/>
      <url>posts/10571/</url>
      
        <content type="html"><![CDATA[<h3 id="C-中如何定义接口类"><a href="#C-中如何定义接口类" class="headerlink" title="C++中如何定义接口类?"></a>C++中如何定义接口类?</h3><p>首先给接口类下了定义：接口类应该是只提供方法声明，而自身不提供方法定义的抽象类。接口类自身不能实例化，接口类的方法定义/实现只能由接口类的子类来完成。</p><p>而对于C++，其接口类一般具有以下特征：</p><ul><li>1.最好不要有成员变量，但可以有静态常量（static const或enum）</li><li>2.要有纯虚接口方法</li><li>3.要有虚析构函数，并提供默认实现</li><li>4.不要声明构造函数</li></ul><p>如下就是一个最简单的例子：</p><pre class="line-numbers language-C++"><code class="language-C++">class Testable{public:    static const int START = 1;  // #1    static const int STOP = 2;    virtual void test() = 0;  // #2： 接口方法    virtual ~Testable() {};   // #3： 从C++11开始可以： virtual ~Testable() = default;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> <a id="more"></a><p> 如果成员变量，尤其是可变的成员变量，定义在接口中，等于是把实现细节暴露出来了，不符合接口定义的要求，所以一般不在接口中定义可变的成员变量。</p><blockquote><p>而常量可以定义在接口中，因为有时接口需要返回状态，而这些状态可以定义成常量放在接口中。</p></blockquote><hr><p>由于不能让接口类自身能够实例化，并且需要子类必须实现接口暴露的方法，所以接口方法都要声明成纯虚函数。</p><blockquote><p>声明成纯虚函数意味着接口类自身不需要提供方法的定义，方法的定义需要由接口类的子类提供，并且接口类自身也因此变成了抽象类而不能被实例化。</p></blockquote><hr><p><strong>a).</strong> 在使用接口类的指针访问接口类的子类的实例时，当对接口类的指针做delete时，如果接口类的析构函数不是虚析构函数的话，将只会调用接口类的析构函数，接口类的子类的析构函数将不会被调用，内存泄露将会产生，所以接口类的析构函数必须定义成虚析构函数。</p><p> <strong>b).</strong> 如果接口类的析构函数不提供默认实现，即如果接口类的析构函数是纯虚析构函数的话，接口类的子类将被迫必须提供析构函数的实现，这样对接口类的子类不友好。</p><p><strong>c).</strong> 在C++11中也可以用：  virtual ~Testable() = default; 替代 virtual ~Testable() {};</p><hr><blockquote><p>不要显式定义任何的构造函数，但也不要在接口中加入如下代码来禁止生成构造函数：</p></blockquote><pre class="line-numbers language-C++"><code class="language-C++">Testable() = delete;Testable(const Testable&) = delete;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>因为C++的调用机制要求子类的构造函数调用时一定会先调用父类的构造函数，如果禁止生成构造函数，代码编译时会报错。如果程序员不显式的提供构造函数，编译器也会隐式的加上构造函数的，虽然这些构造函数对于接口类来说实际没有什么意义。</p><h3 id="C-中如何定义标识接口（marker-interface）类"><a href="#C-中如何定义标识接口（marker-interface）类" class="headerlink" title="C++中如何定义标识接口（marker interface）类?"></a>C++中如何定义标识接口（marker interface）类?</h3><p>标识接口是没有任何方法和属性的接口。这种接口在java中出现的较多，比如：java.io.Serializable、java.rmi.Remote、java.util.EventListener、java.util.RandomAccess<br>实现代码如下：</p><pre class="line-numbers language-C++"><code class="language-C++">class Testable {public:    virtual ~Testable() = 0 {}; // #5};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>只要对纯虚析构函数提供一个默认实现就可以了。这种对纯虚函数提供实现的写法看似很奇怪，但C++的确是支持的。</p><h3 id="C-：如何正确的使用接口类"><a href="#C-：如何正确的使用接口类" class="headerlink" title="C++：如何正确的使用接口类"></a>C++：如何正确的使用接口类</h3><h4 id="提供接口与实现"><a href="#提供接口与实现" class="headerlink" title="提供接口与实现"></a>提供接口与实现</h4><p>首先，声明一个接口：</p><pre class="line-numbers language-c++"><code class="language-c++">// circle.h// 圆的接口类class Circle {public:    virtual ~Circle() {};    // 接口方法：面积    virtual double area() = 0;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过继承的方式实现这个接口：</p><pre class="line-numbers language-c++"><code class="language-c++">// circle_impl.h#include "circle.h"// 圆的具体实现类class CircleImpl : public Circle {private:    double radius;public:    CircleImpl(double radius);    double area() override;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">// circle_impl.cpp#include <cmath>#include "circle_impl.h"inline double pi() {    return std::atan(1) * 4;};CircleImpl::CircleImpl(double _radius) : radius(_radius) {};double CircleImpl::area() {    return pi() * radius * radius;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，通过管理类创建接口派生类的实例，或者销毁接口派生类的实例：</p><pre class="line-numbers language-c++"><code class="language-c++">// circle_manager.h#include "circle.h"// 圆的创建工厂类class CircleManager {public:    static Circle* create(double radius);     // 创建circle实例    static void destroy(Circle* circlePtr);   // 销毁circle实例};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++"><code class="language-C++">// circle_manager.cpp#include "circle_manager.h"#include "circle_impl.h"Circle* CircleManager::create(double radius) {    Circle* circlePtr = new CircleImpl(radius);    return circlePtr;};void CircleManager::destroy(Circle* circlePtr) {    delete circlePtr;}; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码目录结构：</p><pre class="line-numbers language-c++"><code class="language-c++">proj-+     |-inc-+     |     |-circle.h     |     |-circle_manager.h     |     |-src-+           |-circle_impl.h           |-circle_impl.cpp           |-circle_manager.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中inc目录用于存放Circle接口类和Circle管理类的声明，src目录中存放Circle实现类CircleImpl的声明和定义、Circle管理类CircleManager的定义。</p><p>然后，可以将以上代码编译成静态库circle.lib，并和inc目录中的头文件一起提供给外部调用：</p><h3 id="如何使用静态库？"><a href="#如何使用静态库？" class="headerlink" title="如何使用静态库？"></a>如何使用静态库？</h3><p>外部使用者编译时，需要做如下配置：</p><p>1). 把inc目录添加到“附加包含目录”中。</p><p>2). “附加依赖项”中添加circle.lib。</p><p>3). 把circle.lib所在目录的路径添加到“附加库目录”中。</p><p>外部使用者的代码如下：</p><pre class="line-numbers language-c++"><code class="language-c++">// main.cpp#include <iostream>#include "circle_manager.h"#include "circle.h"int main() {    Circle* circlePtr = CircleManager::create(3);    cout << circlePtr->area() <<endl;    CircleManager::destroy(circlePtr);    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码只提供给外部circle的接口，circle的实现完全被隐藏了起来，外部将无从知晓，外部使用者只能通过circle管理类生成circle的派生类的实例。外部使用者得到circle派生类的实例后，除了能调用接口暴露的方法area()外，其它什么也做不了，这样就完全达到了使用接口的最终目标。</p><h3 id="如何编译成动态库？"><a href="#如何编译成动态库？" class="headerlink" title="如何编译成动态库？"></a>如何编译成动态库？</h3><pre class="line-numbers language-C"><code class="language-C">// dll_export.h // if windows .dll #ifdef _WINDLL #ifdef DLL_API_EXPORTS #define DLL_API __declspec(dllexport) #else #define DLL_API __declspec(dllimport) #endif // else if Linux or macOS .so #else #define DLL_API #endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加此头文件后，代码可以在windows、Linux下都可编译生成动态库，只需在编译时设置不同参数就行了。</p><p>windows： /D “DLL_API_EXPORTS” /D “_WINDLL”</p><p>Linux： 不用配置额外参数</p><p>circle.h和circle_manager.h也要做相应改动：</p><pre class="line-numbers language-C++"><code class="language-C++">// circle.h #pragma once #include "dll_export.h" // 圆的接口类 class DLL_API Circle { public:            virtual ~Circle() {};    // 接口方法：面积             virtual double area() = 0; };<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++"><code class="language-C++">// circle_manager.h #pragma once #include "circle.h" #include "dll_export.h"  // 圆的创建工厂类 class DLL_API CircleManager { public:     static Circle* create(double radius);     static void destroy(Circle* circlePtr); };<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译完成后将生成”circle.lib“和”circle.dll“文件：</p><pre class="line-numbers language-C++"><code class="language-C++">proj-+     |-inc-+     |     |-circle.h     |     |-circle_manager.h     |     |-src-+     |     |-circle_impl.h     |     |-circle_impl.cpp     |     |-circle_manager.cpp     |     |-bin-+           |-circle.lib           |-circlr.dll<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="如何使用动态库？"><a href="#如何使用动态库？" class="headerlink" title="如何使用动态库？"></a>如何使用动态库？</h3><p>外部使用者编译时，需要做如下配置：</p><p>1). 代码中添加#pragma comment(lib,”circle.lib”)， 这里是circle.lib，不是circle.dll。</p><p>2). 把inc目录添加到“附加包含目录”中。</p><p>3). “附加依赖项”中添加circle.lib，这里也是circle.lib，不是circle.dll。</p><p>4). 把bin目录所在路径添加到”附加库目录“中。</p><p>新的外部使用者的代码如下：</p><pre class="line-numbers language-C"><code class="language-C">#include <iostream> #include "circle_manager.h" #include "circle.h" #pragma comment(lib,"circle.lib") int main() {    Circle* circlePtr = CircleManager::create(3);    cout << circlePtr->area() << endl;    CircleManager::destroy(circlePtr);    system("pause");    return 0; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里有几点需要说明一下：</p><ul><li><p>1、为什么CircleManager类即在提供创建实例的方法又要提供销毁实例的方法？<br>由于编译器的实现方式不同，dll的堆空间可能跟调用方的堆空间不同，它可能是由dll自己单独管理的，所以从dll中创建的实例，最好还是在dll中销毁。</p></li><li><p>2、对动态库的调用本文是通过隐式调用的方式完成的，对动态库的调用也可以使用显式调用的方式，但由于windows和Linux在使用显式调用时的API是不同的，不好提供统一的代码，所以本文没有举例，以后有机会再单独行文介绍。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ virtual function分析</title>
      <link href="posts/4469/"/>
      <url>posts/4469/</url>
      
        <content type="html"><![CDATA[<h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>为了实现C++的多态，C++使用了一种动态绑定的技术。这个技术的核心是虚函数表（下文简称虚表）。本文介绍虚函数表是如何实现动态绑定的。</p><h3 id="二、类的虚表"><a href="#二、类的虚表" class="headerlink" title="二、类的虚表"></a>二、类的虚表</h3><p>每个包含了虚函数的类都包含一个虚表。<br>我们知道，当一个类（A）继承另一个类（B）时，类A会继承类B的函数的调用权。所以如果一个基类包含了虚函数，那么其继承类也可调用这些虚函数，换句话说，一个类继承了包含虚函数的基类，那么这个类也拥有自己的虚表。</p><p>我们来看以下的代码。类A包含虚函数vfunc1，vfunc2，由于类A包含虚函数，故类A拥有一个虚表。</p><pre class="line-numbers language-C++"><code class="language-C++">class A {public:    virtual void vfunc1();    virtual void vfunc2();    void func1();    void func2();private:    int m_data1, m_data2;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><a id="more"></a><p>类A的虚表如图1所示:<br><img src="/posts/4469/1.png" alt="类A的虚表示意图"></p><p>虚表是一个指针数组，其元素是虚函数的指针，每个元素对应一个虚函数的函数指针。需要指出的是，普通的函数即非虚函数，其调用并不需要经过虚表，所以虚表的元素并不包括普通函数的函数指针。<br>虚表内的条目，即虚函数指针的赋值发生在编译器的编译阶段，也就是说在代码的编译阶段，虚表就可以构造出来了。</p><h3 id="三、虚表指针"><a href="#三、虚表指针" class="headerlink" title="三、虚表指针"></a>三、虚表指针</h3><p>虚表是属于类的，而不是属于某个具体的对象，一个类只需要一个虚表即可。同一个类的所有对象都使用同一个虚表。<br>为了指定对象的虚表，对象内部包含一个虚表的指针，来指向自己所使用的虚表。为了让每个包含虚表的类的对象都拥有一个虚表指针，编译器在类中添加了一个指针，<em>__vptr，用来指向虚表。这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置为指向类的虚表。<br>*对象与它的虚表:</em><br><img src="/posts/4469/2.png" alt="对象与它的虚表"></p><p>上面指出，一个继承类的基类如果包含虚函数，那个这个继承类也有拥有自己的虚表，故这个继承类的对象也包含一个虚表指针，用来指向它的虚表。</p><h3 id="四、动态绑定"><a href="#四、动态绑定" class="headerlink" title="四、动态绑定"></a>四、动态绑定</h3><p>说到这里，大家一定会好奇C++是如何利用虚表和虚表指针来实现动态绑定的。我们先看下面的代码。</p><pre class="line-numbers language-C++"><code class="language-C++">class A {public:    virtual void vfunc1();    virtual void vfunc2();    void func1();    void func2();private:    int m_data1, m_data2;};class B : public A {public:    virtual void vfunc1();    void func1();private:    int m_data3;};class C: public B {public:    virtual void vfunc2();    void func2();private:    int m_data1, m_data4;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类A是基类，类B继承类A，类C又继承类B。类A，类B，类C，其对象模型如下图3所示。<br><img src="/posts/4469/3.png" alt="类A，类B，类C的对象模型"><br>由于这三个类都有虚函数，故编译器为每个类都创建了一个虚表，即类A的虚表（A vtbl），类B的虚表（B vtbl），类C的虚表（C vtbl）。类A，类B，类C的对象都拥有一个虚表指针，*__vptr，用来指向自己所属类的虚表。<br>类A包括两个虚函数，故A vtbl包含两个指针，分别指向A::vfunc1()和A::vfunc2()。<br>类B继承于类A，故类B可以调用类A的函数，但由于类B重写了B::vfunc1()函数，故B vtbl的两个指针分别指向B::vfunc1()和A::vfunc2()。<br>类C继承于类B，故类C可以调用类B的函数，但由于类C重写了C::vfunc2()函数，故C vtbl的两个指针分别指向B::vfunc1()（指向继承的最近的一个类的函数）和C::vfunc2()。<br>虽然图3看起来有点复杂，但是只要抓住“对象的虚表指针用来指向自己所属类的虚表，虚表中的指针会指向其继承的最近的一个类的虚函数”这个特点，便可以快速将这几个类的对象模型在自己的脑海中描绘出来。</p><p>非虚函数的调用不用经过虚表，故不需要虚表中的指针指向这些函数。</p><p>假设我们定义一个类B的对象。由于bObject是类B的一个对象，故bObject包含一个虚表指针，指向类B的虚表。</p><pre class="line-numbers language-C++"><code class="language-C++">int main() {    B bObject;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>现在，我们声明一个类A的指针p来指向对象bObject。虽然p是基类的指针只能指向基类的部分，但是虚表指针亦属于基类部分，所以p可以访问到对象bObject的虚表指针。bObject的虚表指针指向类B的虚表，所以p可以访问到B vtbl。如图3所示。</p><pre class="line-numbers language-C++"><code class="language-C++">int main(){    B bObject;    A *p = & bObject;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当我们使用p来调用vfunc1()函数时，会发生什么现象？</p><pre class="line-numbers language-C++"><code class="language-C++">int main(){    B bObject;    A *p = & bObject;    p->vfunc1();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序在执行p-&gt;vfunc1()时，会发现p是个指针，且调用的函数是虚函数，接下来便会进行以下的步骤。<br>首先，根据虚表指针p-&gt;<strong>vptr来访问对象bObject对应的虚表。虽然指针p是基类A<em>类型，但是</em></strong>vptr也是基类的一部分，所以可以通过p-&gt;__vptr可以访问到对象对应的虚表。<br>然后，在虚表中查找所调用的函数对应的条目。由于虚表在编译阶段就可以构造出来了，所以可以根据所调用的函数定位到虚表中的对应条目。对于 p-&gt;vfunc1()的调用，B vtbl的第一项即是vfunc1对应的条目。<br>最后，根据虚表中找到的函数指针，调用函数。从图3可以看到，B vtbl的第一项指向B::vfunc1()，所以 p-&gt;vfunc1()实质会调用B::vfunc1()函数。</p><p>如果p指向类A的对象，情况又是怎么样？</p><pre class="line-numbers language-C++"><code class="language-C++">int main(){    A aObject;    A *p = &aObject;    p->vfunc1();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当aObject在创建时，它的虚表指针<strong>vptr已设置为指向A vtbl，这样p-&gt;</strong>vptr就指向A vtbl。vfunc1在A vtbl对应在条目指向了A::vfunc1()函数，所以 p-&gt;vfunc1()实质会调用A::vfunc1()函数。</p><p>可以把以上三个调用函数的步骤用以下表达式来表示：<br><code>(*(p-&gt;__vptr)[n])(p)</code></p><p>可以看到，通过使用这些虚函数表，即使使用的是基类的指针来调用函数，也可以达到正确调用运行中实际对象的虚函数。<br>我们把经过虚表调用虚函数的过程称为动态绑定，其表现出来的现象称为运行时多态。动态绑定区别于传统的函数调用，传统的函数调用我们称之为静态绑定，即函数的调用在编译阶段就可以确定下来了。</p><p>那么，什么时候会执行函数的动态绑定？这需要符合以下三个条件。</p><ul><li>通过指针来调用函数</li><li>指针upcast向上转型（继承类向基类的转换称为upcast，关于什么是upcast，可以参考本文的参考资料）</li><li>调用的是虚函数</li></ul><p>如果一个函数调用符合以上三个条件，编译器就会把该函数调用编译成动态绑定，其函数的调用过程走的是上述通过虚表的机制。</p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 虚函数 </tag>
            
            <tag> 虚表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++虚函数和虚函数表原理</title>
      <link href="posts/42434/"/>
      <url>posts/42434/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>大家都应该知道C++的精髓是虚函数吧? 虚函数带来的好处就是: 可以定义一个基类的指针, 其指向一个继承类, 当通过基类的指针去调用函数时, 可以在运行时决定该调用基类的函数还是继承类的函数. 虚函数是实现多态(动态绑定)/接口函数的基础. 可以说: 没有虚函数, C++将变得一无是处!</p><p>既然是C++的精髓, 那么我们有必要了解一下她的实现方式吗? 有必要! 既然C++是从C语言的基础上发展而来的, 那么我们可以尝试用C语言来模拟实现吗? 有可能! 接下来, 就是我一步一步地来解析C++的虚函数的实现方式, 以及用C语言对其进行的模拟.</p><h3 id="C-对象的内存布局"><a href="#C-对象的内存布局" class="headerlink" title="C++对象的内存布局"></a>C++对象的内存布局</h3><p>要想知道C++对象的内存布局, 可以有多种方式, 比如:</p><ul><li><p>1.输出成员变量的偏移, 通过offsetof宏来得到</p></li><li><p>2.通过调试器查看, 比如常用的VS</p><a id="more"></a></li></ul><h4 id="1-只有数据成员的对象"><a href="#1-只有数据成员的对象" class="headerlink" title="1. 只有数据成员的对象"></a>1. 只有数据成员的对象</h4><p>类实现如下:</p><pre class="line-numbers language-C++"><code class="language-C++">class Base1{public:    int base1_1;    int base1_2;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对象大小及偏移:</p><pre><code>sizeof(Base1):8offsetof(Base1, base1_1):0offsetof(Base1, base1_2):4</code></pre><p>可知对象布局:</p><p><img src="/posts/42434/1.png" alt="1"></p><p>可以看到, 成员变量是按照定义的顺序来保存的, 最先声明的在最上边, 然后依次保存!<br>类对象的大小就是所有成员变量大小之和.</p><h4 id="2-没有虚函数的对象"><a href="#2-没有虚函数的对象" class="headerlink" title="2. 没有虚函数的对象"></a>2. 没有虚函数的对象</h4><p>类实现如下:</p><pre class="line-numbers language-C++"><code class="language-C++">class Base1{public:    int base1_1;    int base1_2;    void foo(){}};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果如下:</p><pre><code>sizeof(Base1):8offsetof(Base1, base1_1):0offsetof(Base1, base1_2):4</code></pre><p>和前面的结果是一样的? 不需要有什么疑问对吧?<br>因为如果一个函数不是虚函数,那么他就不可能会发生动态绑定,也就不会对对象的布局造成任何影响.<br>当调用一个非虚函数时, 那么调用的一定就是当前指针类型拥有的那个成员函数. 这种调用机制在编译时期就确定下来了.</p><h4 id="3-拥有仅一个虚函数的类对象"><a href="#3-拥有仅一个虚函数的类对象" class="headerlink" title="3.拥有仅一个虚函数的类对象"></a>3.拥有仅一个虚函数的类对象</h4><p>类实现如下:</p><pre class="line-numbers language-C++"><code class="language-C++">class Base1{public:    int base1_1;    int base1_2;    virtual void base1_fun1() {}};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果如下:</p><pre><code>sizeof(Base1):12offsetof(Base1, base1_1):4offsetof(Base1, base1_2):8</code></pre><p>咦? 多了4个字节? 且 base1_1 和 base1_2 的偏移都各自向后多了4个字节!<br>说明类对象的最前面被多加了4个字节的”东东”, what’s it?<br>现在, 我们通过VS2013来瞧瞧类Base1的变量b1的内存布局情况:<br>(由于我没有写构造函数, 所以变量的数据没有根据, 但虚函数是编译器为我们构造的, 数据正确!)<br>(Debug模式下, 未初始化的变量值为0xCCCCCCCC, 即:-858983460)<br><img src="/posts/42434/2.png" alt="2"></p><p>看到没? base1_1前面多了一个变量 __vfptr(常说的虚函数表vtable指针), 其类型为void*<em>, 这说明它是一个void</em>指针(注意:不是数组).</p><p>再看看[0]元素, 其类型为void*, 其值为 ConsoleApplication2.exe!Base1::base1_fun1(void), 这是什么意思呢? 如果对WinDbg比较熟悉, 那么应该知道这是一种惯用表示手法, 她就是指 Base1::base1_fun1() 函数的地址.</p><p>可得, __vfptr的定义伪代码大概如下:</p><pre class="line-numbers language-C++"><code class="language-C++">void*   __fun[1] = { &Base1::base1_fun1 };const void**  __vfptr = &__fun[0];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>值得注意的是:</p><ol><li><p>上面只是一种伪代码方式, 语法不一定能通过</p></li><li><p>该类的对象大小为12个字节, 大小及偏移信息如下:</p><pre><code> sizeof(Base1):12 offsetof(__vfptr):0 offsetof(base1_1):4 offsetof(base1_2):8</code></pre></li><li><p>大家有没有留意这个<strong>vfptr? 为什么它被定义成一个指向指针数组的指针, 而不是直接定义成一个指针数组呢?<br>我为什么要提这样一个问题? 因为如果仅是一个指针的情况, 您就无法轻易地修改那个数组里面的内容, 因为她并不属于类对象的一部分.<br>属于类对象的, 仅是一个指向**虚函数表的一个指针</strong>vfptr**而已, 下一节我们将继续讨论这个问题.</p></li><li><p>注意到<strong>vfptr前面的const修饰. 她修饰的是那个虚函数表, 而不是</strong>vfptr.</p></li></ol><p>现在的对象布局如下:<br><img src="/posts/42434/3.png" alt="3"></p><p>虚函数指针__vfptr位于所有的成员变量之前定义.</p><p>注意到: 我并未在此说明__vfptr的具体指向, 只是说明了现在类对象的布局情况.<br>接下来看一个稍微复杂一点的情况, 我将清楚地描述虚函数表的构成.</p><h4 id="4-拥有多个虚函数的类对象"><a href="#4-拥有多个虚函数的类对象" class="headerlink" title="4.拥有多个虚函数的类对象"></a>4.拥有多个虚函数的类对象</h4><p>和前面一个例子差不多, 只是再加了一个虚函数. 定义如下:</p><pre class="line-numbers language-C++"><code class="language-C++">class Base1{public:    int base1_1;    int base1_2;    virtual void base1_fun1() {}    virtual void base1_fun2() {}};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大小以及偏移信息如下:<br><img src="/posts/42434/4.png" alt="4"><br>有情况!? 多了一个虚函数, 类对象大小却依然是12个字节!</p><p>再来看看VS形象的表现:<br><img src="/posts/42434/5.png" alt="5"></p><p>呀, __vfptr所指向的函数指针数组中出现了第2个元素, 其值为Base1类的第2个虚函数base1_fun2()的函数地址.</p><p>现在, 虚函数指针以及虚函数表的伪定义大概如下:</p><pre class="line-numbers language-C++"><code class="language-C++">void* __fun[] = { &Base1::base1_fun1, &Base1::base1_fun2 };const void** __vfptr = &__fun[0];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>前面已经提到过: <strong>vfptr只是一个指针, 她指向一个数组, 并且: 这个数组没有包含到类定义内部, 那么她们之间是怎样一个关系呢?<br>不妨, 我们再定义一个类的变量b2, 现在再来看看</strong>vfptr的指向:<br><img src="/posts/42434/6.png" alt="6"></p><p>通过Watch 1窗口我们看到:</p><ol><li><p>b1和b2是类的两个变量, 理所当然, 她们的地址是不同的(见 &amp;b1 和 &amp;b2)</p></li><li><p>虽然b1和b2是类的两个变量, 但是: 她们的__vfptr的指向却是同一个虚函数表</p></li></ol><p>由此我们可以总结出:</p><p>同一个类的不同实例共用同一份虚函数表, 她们都通过一个所谓的虚函数表指针__vfptr(定义为void**类型)指向该虚函数表.</p><p>是时候该展示一下类对象的内存布局情况了:<br><img src="/posts/42434/7.png" alt="7"></p><p>不出意外, 很清晰明了地展示出来了吧? :-) hoho~~</p><p>那么问题就来了! 这个虚函数表保存在哪里呢? 其实, 我们无需过分追究她位于哪里, 重点是:</p><ol><li>她是编译器在<strong>编译时期</strong>为我们创建好的, 只存在一份</li><li>定义类对象时, 编译器自动将类对象的__vfptr指向这个虚函数表</li></ol><h4 id="5-单继承且本身不存在虚函数的继承类的内存布局"><a href="#5-单继承且本身不存在虚函数的继承类的内存布局" class="headerlink" title="5.单继承且本身不存在虚函数的继承类的内存布局"></a>5.单继承且本身不存在虚函数的继承类的内存布局</h4><p>前面研究了那么多啦, 终于该到研究继承类了! 先研究单继承!</p><p>依然, 简单地定义一个继承类, 如下:</p><pre class="line-numbers language-C++"><code class="language-C++">class Base1{public:    int base1_1;    int base1_2;    virtual void base1_fun1() {}    virtual void base1_fun2() {}};class Derive1 : public Base1{public:    int derive1_1;    int derive1_2;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们再来看看现在的内存布局(定义为Derive1 d1):<br><img src="/posts/42434/8.png" alt="8"><br>没错! 基类在上边, 继承类的成员在下边依次定义! 展开来看看:<br><img src="/posts/42434/9.png" alt="9"><br>经展开后来看, 前面部分完全就是Base1的东西: 虚函数表指针+成员变量定义.<br>并且, Base1的虚函数表的[0][1]两项还是其本身就拥有的函数: base1_fun1() 和 base1_fun2().</p><p>现在类的布局情况应该是下面这样:<br><img src="/posts/42434/10.png" alt="10"></p><h4 id="6-本身不存在虚函数-不严谨-但存在基类虚函数覆盖的单继承类的内存布局"><a href="#6-本身不存在虚函数-不严谨-但存在基类虚函数覆盖的单继承类的内存布局" class="headerlink" title="6.本身不存在虚函数(不严谨)但存在基类虚函数覆盖的单继承类的内存布局"></a>6.本身不存在虚函数(不严谨)但存在基类虚函数覆盖的单继承类的内存布局</h4><p>标题<code>本身不存在虚函数</code>的说法有些不严谨, 我的意思是说: 除经过继承而得来的基类虚函数以外, 自身没有再定义其它的虚函数.</p><p>Ok, 既然存在基类虚函数覆盖, 那么来看看接下来的代码会产生何种影响:</p><pre class="line-numbers language-C++"><code class="language-C++">class Base1{public:    int base1_1;    int base1_2;    virtual void base1_fun1() {}    virtual void base1_fun2() {}};class Derive1 : public Base1{public:    int derive1_1;    int derive1_2;    // 覆盖基类函数    virtual void base1_fun1() {}};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到, Derive1类 重写了Base1类的base1_fun1()函数, 也就是常说的虚函数覆盖. 现在是怎样布局的呢?<br><img src="/posts/42434/11.png" alt="11"><br>特别注意我高亮的那一行: 原本是Base1::base1_fun1(), 但由于<strong>继承类重写</strong>了基类Base1的此方法, 所以现在变成了Derive1::base1_fun1()!</p><p>那么, 无论是通过Derive1的指针还是Base1的指针来调用此方法, 调用的都将是被继承类重写后的那个方法(函数), 多态发生鸟!!!</p><p>那么新的布局图:<br><img src="/posts/42434/12.png" alt="12"></p><h4 id="7-定义了基类没有的虚函数的单继承的类对象布局"><a href="#7-定义了基类没有的虚函数的单继承的类对象布局" class="headerlink" title="7.定义了基类没有的虚函数的单继承的类对象布局"></a>7.定义了基类没有的虚函数的单继承的类对象布局</h4><p>说明一下: 由于前面一种情况只会造成覆盖基类虚函数表的指针, 所以接下来我不再同时讨论虚函数覆盖的情况.</p><p>继续贴代码:</p><pre class="line-numbers language-C++"><code class="language-C++">class Base1{public:    int base1_1;    int base1_2;    virtual void base1_fun1() {}    virtual void base1_fun2() {}};class Derive1 : public Base1{public:    int derive1_1;    int derive1_2;    virtual void derive1_fun1() {}};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>和第5类不同的是多了一个自身定义的虚函数. 和第6类不同的是没有基类虚函数的覆盖.<br><img src="/posts/42434/13.png" alt="13"><br>咦, 有没有发现问题? 表面上看来几乎和第5种情况完全一样? 为嘛呢?<br>现在继承类明明定义了自身的虚函数, 但不见了??<br>那么, 来看看类对象的大小, 以及成员偏移情况吧:<br><img src="/posts/42434/14.png" alt="14"><br>居然没有变化!!! 前面12个字节是Base1的, 有没有觉得很奇怪?</p><p>好吧, 既然表面上没办法了, 我们就只能从汇编入手了, 来看看调用derive1_fun1()时的代码:</p><pre class="line-numbers language-C++"><code class="language-C++">Derive1 d1;Derive1* pd1 = &d1;pd1->derive1_fun1();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>要注意: 我为什么使用指针的方式调用? 说明一下: 因为如果不使用指针调用, 虚函数调用是不会发生动态绑定的哦! 你若直接<code>d1.derive1_fun1()</code>; , 是不可能会发生动态绑定的, 但如果使用指针: <code>pd1-&gt;derive1_fun1()</code>; , 那么 pd1就无从知道她所指向的对象到底是Derive1 还是继承于Derive1的对象, 虽然这里我们并没有对象继承于Derive1, 但是她不得不这样做, 毕竟继承类不管你如何继承, 都不会影响到基类, 对吧?</p><pre class="line-numbers language-armasm"><code class="language-armasm">; pd1->derive1_fun1();00825466  mov         eax,dword ptr [pd1]  00825469  mov         edx,dword ptr [eax]  0082546B  mov         esi,esp  0082546D  mov         ecx,dword ptr [pd1]  00825470  mov         eax,dword ptr [edx+8]  00825473  call        eax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>汇编代码解释:<br>第2行: 由于pd1是指向d1的指针, 所以执行此句后 eax 就是<strong>d1的地址</strong><br>第3行: 又因为Base1::<strong>vfptr是Base1的第1个成员, 同时也是Derive1的第1个成员, 那么: &amp;</strong>vfptr == &amp;d1, clear? 所以当执行完 <code>mov edx</code>, <code>dword ptr[eax]</code> 后, edx就得到了<strong>vfptr的值, 也就是<strong>虚函数表的地址</strong>.<br>第5行: 由于是</strong>thiscall调用, 所以把this保存到ecx中.<br>第6行: 一定要注意到那个 edx+8, 由于edx是虚函数表的地址, 那么 edx+8将是虚函数表的第3个元素, 也就是__vftable[2]!!!<br>第7行: 调用虚函数.</p><p>结果:</p><ol><li>现在我们应该知道内幕了! 继承类Derive1的虚函数表被加在基类的后面! 事实的确就是这样!</li><li>由于Base1只知道自己的两个虚函数索引[0][1], 所以就算在后面加上了[2], Base1根本不知情, 不会对她造成任何影响.</li><li>如果<strong>基类没有虚函数</strong>呢? 这个问题我们留到第9小节再来讨论!</li></ol><p>最新的类对象布局表示:<br><img src="/posts/42434/15.png" alt="15"></p><h4 id="8-多继承且存在虚函数覆盖同时又存在自身定义的虚函数的类对象布局"><a href="#8-多继承且存在虚函数覆盖同时又存在自身定义的虚函数的类对象布局" class="headerlink" title="8.多继承且存在虚函数覆盖同时又存在自身定义的虚函数的类对象布局"></a>8.多继承且存在虚函数覆盖同时又存在自身定义的虚函数的类对象布局</h4><p>真快, 该看看多继承了, 多继承很常见, 特别是接口类中!</p><p>依然写点小类玩玩:</p><pre class="line-numbers language-C++"><code class="language-C++">class Base1{public:    int base1_1;    int base1_2;    virtual void base1_fun1() {}    virtual void base1_fun2() {}};class Base2{public:    int base2_1;    int base2_2;    virtual void base2_fun1() {}    virtual void base2_fun2() {}};// 多继承class Derive1 : public Base1, public Base2{public:    int derive1_1;    int derive1_2;    // 基类虚函数覆盖    virtual void base1_fun1() {}    virtual void base2_fun2() {}    // 自身定义的虚函数    virtual void derive1_fun1() {}    virtual void derive1_fun2() {}};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码变得越来越长啦! 为了代码结构清晰, 我尽量简化定义.</p><p>初步了解一下对象大小及偏移信息:<br><img src="/posts/42434/16.png" alt="16"><br>貌似, 若有所思? 不管, 来看看VS再想:<br><img src="/posts/42434/17.png" alt="17"></p><p>哇, 不摆了! 一丝不挂啊! :-)<br>结论:</p><ol><li><p>按照基类的声明顺序, 基类的成员依次分布在继承中.</p></li><li><p>注意被我高亮的那两行, 已经发生了虚函数覆盖!</p></li><li><p>我们自己定义的虚函数呢? 怎么还是看不见?!</p></li></ol><p>好吧, 继承反汇编, 这次的调用代码如下:</p><pre class="line-numbers language-C++"><code class="language-C++">Derive1 d1;Derive1* pd1 = &d1;pd1->derive1_fun2();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>反汇编代码如下:</p><pre class="line-numbers language-armasm"><code class="language-armasm">; pd1->derive1_fun2();00995306  mov         eax,dword ptr [pd1]  00995309  mov         edx,dword ptr [eax]  0099530B  mov         esi,esp  0099530D  mov         ecx,dword ptr [pd1]  00995310  mov         eax,dword ptr [edx+0Ch]  00995313  call        eax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解释下, 其实差不多:</p><p>第2行: 取d1的地址<br>第3行: 取Base1::__vfptr的值!!<br>第6行: 0x0C, 也就是第4个元素(下标为[3])</p><p>结论:</p><p>Derive1的虚函数表依然是保存到第1个拥有虚函数表的那个基类的后面的.</p><p>看看现在的类对象布局图:<br><img src="/posts/42434/18.png" alt="18"></p><p>如果第1个基类没有虚函数表呢? 进入第9节!</p><h4 id="9-如果第1个直接基类没有虚函数-表"><a href="#9-如果第1个直接基类没有虚函数-表" class="headerlink" title="9.如果第1个直接基类没有虚函数(表)"></a>9.如果第1个直接基类没有虚函数(表)</h4><p>这次的代码应该比上一个要稍微简单一些, 因为把第1个类的虚函数给去掉!</p><pre class="line-numbers language-c++"><code class="language-c++">class Base1{public:    int base1_1;    int base1_2;};class Base2{public:    int base2_1;    int base2_2;    virtual void base2_fun1() {}    virtual void base2_fun2() {}};// 多继承class Derive1 : public Base1, public Base2{public:    int derive1_1;    int derive1_2;    // 自身定义的虚函数    virtual void derive1_fun1() {}    virtual void derive1_fun2() {}};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>来看看VS的布局:<br><img src="/posts/42434/19.png" alt="19"><br>这次相对前面一次的图来说还要简单啦! Base1已经没有虚函数表了! (真实情况并非完全这样, 请继续往下看!)</p><p>现在的大小及偏移情况: 注意: <code>sizeof(Base1) == 8</code>;<br><img src="/posts/42434/20.png" alt="20"></p><p>重点是看虚函数的位置, 进入函数调用(和前一次是一样的):</p><pre class="line-numbers language-c++"><code class="language-c++">Derive1 d1;Derive1* pd1 = &d1;pd1->derive1_fun2();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>反汇编调用代码:</p><pre class="line-numbers language-armasm"><code class="language-armasm">; pd1->derive1_fun2();012E4BA6  mov         eax,dword ptr [pd1]  012E4BA9  mov         edx,dword ptr [eax]  012E4BAB  mov         esi,esp  012E4BAD  mov         ecx,dword ptr [pd1]  012E4BB0  mov         eax,dword ptr [edx+0Ch]  012E4BB3  call        eax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段汇编代码和前面一个完全一样!, 那么问题就来了! Base1 已经没有虚函数表了, 为什么还是把b1的第1个元素当作__vfptr呢?<br>不难猜测: 当前的布局已经发生了变化, 有虚函数表的基类放在对象内存前面!? , 不过事实是否属实? 需要仔细斟酌.</p><p>我们可以通过对基类成员变量求偏移来观察:<br><img src="/posts/42434/21.png" alt="21"><br>可以看到:</p><pre><code>&amp;d1==0x~d4&amp;d1.Base1::__vfptr==0x~d4&amp;d1.base2_1==0x~d8&amp;d1.base2_2==0x~dc&amp;d1.base1_1==0x~e0&amp;d1.base1_2==0x~e4</code></pre><p>所以不难验证: 我们前面的推断是正确的, 谁有虚函数表, 谁就放在前面!</p><p>现在类的布局情况:<br><img src="/posts/42434/22.png" alt="22"><br>那么, 如果两个基类都没有虚函数表呢?</p><h4 id="10-What-if-两个基类都没有虚函数表"><a href="#10-What-if-两个基类都没有虚函数表" class="headerlink" title="10.What if 两个基类都没有虚函数表"></a>10.What if 两个基类都没有虚函数表</h4><p>代码如下:</p><pre class="line-numbers language-C++"><code class="language-C++">class Base1{public:    int base1_1;    int base1_2;};class Base2{public:    int base2_1;    int base2_2;};// 多继承class Derive1 : public Base1, public Base2{public:    int derive1_1;    int derive1_2;    // 自身定义的虚函数    virtual void derive1_fun1() {}    virtual void derive1_fun2() {}};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在先来看看VS的基本布局:<br><img src="/posts/42434/23.png" alt="23"><br>可以看到, 现在__vfptr已经独立出来了, 不再属于Base1和Base2!</p><p>看看求偏移情况:<br><img src="/posts/42434/24.png" alt="24"><br>Ok, 问题解决! 注意高亮的那两行, <code>&amp;d1==&amp;d1.__vfptr</code>, 说明虚函数始终在最前面!</p><p>不用再废话, 相信大家对这种情况已经有底了.<br><img src="/posts/42434/25.png" alt="25"></p><h4 id="11-如果有三个基类-虚函数表分别是有-没有-有"><a href="#11-如果有三个基类-虚函数表分别是有-没有-有" class="headerlink" title="11.如果有三个基类: 虚函数表分别是有, 没有, 有!"></a>11.如果有三个基类: 虚函数表分别是有, 没有, 有!</h4><p>这种情况其实已经无需再讨论了, 作为一个完结篇….</p><p>上代码:</p><pre class="line-numbers language-C++"><code class="language-C++">class Base1{public:    int base1_1;    int base1_2;    virtual void base1_fun1() {}    virtual void base1_fun2() {}};class Base2{public:    int base2_1;    int base2_2;};class Base3{public:    int base3_1;    int base3_2;    virtual void base3_fun1() {}    virtual void base3_fun2() {}};// 多继承class Derive1 : public Base1, public Base2, public Base3{public:    int derive1_1;    int derive1_2;    // 自身定义的虚函数    virtual void derive1_fun1() {}    virtual void derive1_fun2() {}};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只需要看看偏移就行了:<br><img src="/posts/42434/26.png" alt="26"><br>只需知道: 谁有虚函数表, 谁就往前靠!</p><h3 id="C-中父子对象指针间的转换与函数调用"><a href="#C-中父子对象指针间的转换与函数调用" class="headerlink" title="C++中父子对象指针间的转换与函数调用"></a>C++中父子对象指针间的转换与函数调用</h3><p>讲了那么多布局方面的东东, 终于到了尾声, 好累呀!!!</p><p>通过前面的讲解内容, 大家至少应该明白了各类情况下类对象的内存布局了. 如果还不会…..呃….. !@#$%^&amp;*</p><p>进入正题~</p><p>由于继承完全拥有父类的所有, 包括数据成员与虚函数表, 所以:<strong>把一个继承类强制转换为一个基类</strong>是完全可行的.</p><p>如果有一个Derive1的指针, 那么:</p><ul><li>得到Base1的指针: Base1* pb1 = pd1;</li><li>得到Base2的指针: Base2* pb2 = pd1;</li><li>得到Base3的指针: Base3* pb3 = pd1;</li></ul><p>非常值得注意的是:</p><p>这是在基类与继承类之间的转换, 这种转换会自动计算偏移! 按照前面的布局方式!<br>也就是说: 在这里极有可能: pb1 != pb2 != pb3 ~~, 不要以为她们都等于 pd1!</p><p>至于函数调用, 我想, 不用说大家应该知道了:</p><ol><li>如果不是虚函数, 直接调用指针对应的基本类的那个函数</li><li>如果是虚函数, 则查找虚函数表, 并进行后续的调用. 虚函数表在定义一个时, 编译器就为我们创建好了的. 所有的, 同一个类, 共用同一份虚函数表.</li></ol><h3 id="用C语言完全模拟C-虚函数表的实现与运作方式"><a href="#用C语言完全模拟C-虚函数表的实现与运作方式" class="headerlink" title="用C语言完全模拟C++虚函数表的实现与运作方式"></a>用C语言完全模拟C++虚函数表的实现与运作方式</h3><p>如果对前面两大节的描述仔细了解了的话, 想用C语言来模拟C++的虚函数以及多态, 想必是轻而易举的事情!</p><h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><p>但是, 话得说在前面, C++的编译器在生成类及对象的时候, 帮助我们完成了很多事件, 比如生成虚函数表!<br>但是, C语言编译器却没有, 因此, 很多事件我们必须手动来完成, 包括但不限于:</p><ol><li>手动构造父子关系</li><li>手动创建虚函数表</li><li>手动设置__vfptr并指向虚函数表</li><li>手动填充虚函数表</li><li>若有虚函数覆盖, 还需手动修改函数指针</li><li>若要取得基类指针, 还需手动强制转换</li><li>……</li></ol><p>总之, 要想用C语言来实现, 要写的代码绝对有点复杂.</p><h4 id="C-原版调用"><a href="#C-原版调用" class="headerlink" title="C++原版调用"></a>C++原版调用</h4><p>接下来, 我们都将以最后那个, 最繁杂的那个3个基类的实例来讲解, 但作了一些简化与改动:</p><ol><li>用构造函数初始化成员变量</li><li>减少成员变量的个数</li><li>减少虚函数的个数</li><li>调用函数时产生相关输出</li><li>Derive1增加一个基类虚函数覆盖</li></ol><p>以下是对类的改动, 很少:</p><pre class="line-numbers language-C++"><code class="language-C++">class Base1{public:    Base1() : base1_1(11) {}    int base1_1;    virtual void base1_fun1() {        std::cout << "Base1::base1_fun1()" << std::endl;    }};class Base2{public:    Base2() : base2_1(21) {}    int base2_1;};class Base3{public:    Base3() : base3_1(31) {}    int base3_1;    virtual void base3_fun1() {        std::cout << "Base3::base3_fun1()" << std::endl;    }};class Derive1 : public Base1, public Base2, public Base3{public:    Derive1() : derive1_1(11) {}    int derive1_1;    virtual void base3_fun1() {        std::cout << "Derive1::base3_fun1()" << std::endl;    }    virtual void derive1_fun1() {            std::cout << "Derive1::derive1_fun1()" << std::endl;    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了看到多态的效果, 我们还需要定义一个函数来看效果:</p><pre class="line-numbers language-C++"><code class="language-C++">void foo(Base1* pb1, Base2* pb2, Base3* pb3, Derive1* pd1){    std::cout << "Base1::\n"        << "    pb1->base1_1 = " << pb1->base1_1 << "\n"        << "    pb1->base1_fun1(): ";    pb1->base1_fun1();    std::cout << "Base2::\n"        << "    pb2->base2_1 = " << pb2->base2_1        << std::endl;    std::cout << "Base3::\n"        << "    pb3->base3_1 = " << pb3->base3_1 << "\n"        <<"    pb3->base3_fun1(): ";    pb3->base3_fun1();    std::cout << "Derive1::\n"        << "    pd1->derive1_1 = " << pd1->derive1_1<< "\n"        <<"    pd1->derive1_fun1(): ";    pd1->derive1_fun1();    std::cout<< "    pd1->base3_fun1(): ";    pd1->base3_fun1();    std::cout << std::endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用方式如下:</p><pre class="line-numbers language-C++"><code class="language-C++">Derive1 d1;foo(&d1, &d1, &d1, &d1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输出结果:<br><img src="/posts/42434/27.png" alt="27"><br>可以看到输出结果全部正确(当然了! :-), 哈哈~<br>同时注意到 pb3-&gt;base3_fun1() 的多态效果哦!</p><h4 id="用C语言来模拟"><a href="#用C语言来模拟" class="headerlink" title="用C语言来模拟"></a>用C语言来模拟</h4><p>必须要把前面的理解了, 才能看懂下面的代码!</p><p>为了有别于已经完成的C++的类, 我们分别在类前面加一个大写的C以示区分(平常大家都是习惯在C++写的类前面加C, 今天恰好反过来, 哈哈).</p><p><strong>C语言无法实现的部分</strong><br>C/C++是两个语言, 有些语言特性是C++专有的, 我们无法实现! 不过, 这里我是指调用约定, 我们应该把她排除在外.</p><p>对于类的成员函数, C++默认使用__thiscall, 也即this指针通过ecx传递, 这在C语言无法实现, 所以我们必须手动声明调用约定为:</p><ol><li><code>__stdcall</code>, 就像微软的组件对象模型那样</li><li><code>__cdecl</code>, 本身就C语言的调用约定, 当然能使用了</li></ol><p>上面那种调用约定, 使用哪一种无关紧要, 反正不能使用<code>__thiscall</code>就行了.</p><p>因为使用了非__thiscall调用约定, 我们就必须手动传入this指针, 通过成员函数的第1个参数!</p><p><em>从最简单的开始: 实现 Base2</em><br>由于没有虚函数, 仅有成员变量, 这个当然是最好模拟的咯!</p><pre class="line-numbers language-C"><code class="language-C">struct CBase1{    void** __vfptr;    int base1_1;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为有虚函数表, 所以还得单独为虚函数表创建一个结构体的哦!<br>但是, 为了更能清楚起见, 我并未定义前面所说的指针数组, 而是用一个包含一个或多个函数指针的结构体来表示!<br>因为数组能保存的是同一类的函数指针, 不太很友好!<br>但他们的效果是完全一样的, 希望读者能够理解明白!</p><pre class="line-numbers language-C"><code class="language-C">struct CBase1_VFTable{    void(__stdcall* base1_fun1)(CBase1* that);};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>: base1_fun1 在这里是一个指针变量!<br><strong>注意</strong>: base1_fun1 有一个CBase1的指针, 因为我们不再使用__thiscall, 我们必须手动传入! Got it?</p><p>Base1的成员函数base1_fun1()我们也需要自己定义, 而且是定义成全局的:</p><pre class="line-numbers language-C"><code class="language-C">void __stdcall base1_fun1(CBase1* that){    std::cout << "base1_fun1()" << std::endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>有虚函数覆盖的Base3</strong><br>虚函数覆盖在这里并不能体现出来, 要在构造对象初始化的时候才会体现, 所以: base3其实和Base1是一样的.</p><pre class="line-numbers language-C"><code class="language-C">struct CBase3{    void** __vfptr;    int base3_1;};struct CBase3_VFTable{    void(__stdcall* base3_fun1)(CBase3* that);};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Base3的成员函数:</p><pre class="line-numbers language-C"><code class="language-C">void __stdcall base3_fun1(CBase3* that){    std::cout << "base3_fun1()" << std::endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>定义继承类CDerive1</strong><br>相对前面几个类来说, 这个类要显得稍微复杂一些了, 因为包含了前面几个类的内容:</p><pre class="line-numbers language-C"><code class="language-C">struct CDerive1{    CBase1 base1;    CBase3 base3;    CBase2 base2;    int derive1_1;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Base3的成员函数:</p><pre class="line-numbers language-C"><code class="language-C">void __stdcall base3_fun1(CBase3* that){    std::cout << "base3_fun1()" << std::endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>定义继承类CDerive1</strong><br>相对前面几个类来说, 这个类要显得稍微复杂一些了, 因为包含了前面几个类的内容:</p><pre class="line-numbers language-C"><code class="language-C">struct CDerive1{    CBase1 base1;    CBase3 base3;    CBase2 base2;    int derive1_1;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>特别注意: CBase123的顺序不能错!</p><p>另外: 由于Derive1本身还有虚函数表, 而且所以项是加到第一个虚函数表(CBase1)的后面的, 所以此时的CBase1::__vfptr不应该单单指向CBase1_VFTable, 而应该指向下面这个包含Derive1类虚函数表的结构体才行:</p><pre class="line-numbers language-C"><code class="language-C">struct CBase1_CDerive1_VFTable{    void (__stdcall* base1_fun1)(CBase1* that);    void(__stdcall* derive1_fun1)(CDerive1* that);};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为CDerive1覆盖了CBase3的base3_fun1()函数, 所以不能直接用Base3的那个表:</p><pre class="line-numbers language-C"><code class="language-C">struct CBase3_CDerive1_VFTable{    void(__stdcall* base3_fun1)(CDerive1* that);};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Derive1覆盖Base3::base3_fun1()的函数以及自身定义的derive1_fun1()函数:</p><pre class="line-numbers language-C"><code class="language-C">void __stdcall base3_derive1_fun1(CDerive1* that){    std::cout << "base3_derive1_fun1()" << std::endl;}void __stdcall derive1_fun1(CDerive1* that){    std::cout << "derive1_fun1()" << std::endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>构造各类的全局虚函数表</strong><br>由于没有了编译器的帮忙, 在定义一个类对象时, 所有的初始化工作都只能由我们自己来完成了!</p><p>首先构造全局的, 被同一个类共同使用的虚函数表!</p><pre class="line-numbers language-C"><code class="language-C">// CBase1 的虚函数表CBase1_VFTable __vftable_base1;__vftable_base1.base1_fun1 = base1_fun1;// CBase3 的虚函数表CBase3_VFTable __vftable_base3;__vftable_base3.base3_fun1 = base3_fun1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后构造CDerive1和CBase1共同使用的虚函数表:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// CDerive1 和 CBase1 共用的虚函数表</span>CBase1_CDerive1_VFTable __vftable_base1_derive1<span class="token punctuation">;</span>__vftable_base1_derive1<span class="token punctuation">.</span>base1_fun1 <span class="token operator">=</span> base1_fun1<span class="token punctuation">;</span>__vftable_base1_derive1<span class="token punctuation">.</span>derive1_fun1 <span class="token operator">=</span> derive1_fun1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>再构造CDerive1覆盖CBase3后的虚函数表: 注意: 数覆盖会替换原来的函数指针</p><pre class="line-numbers language-c"><code class="language-c">CBase3_CDerive1_VFTable __vftable_base3_derive1<span class="token punctuation">;</span>__vftable_base3_derive1<span class="token punctuation">.</span>base3_fun1 <span class="token operator">=</span> base3_derive1_fun1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>开始! 从CDerive1构造一个完整的Derive1类</strong><br>先初始化成员变量与__vfptr的指向: 注意不是指错了!</p><pre class="line-numbers language-C"><code class="language-C">CDerive1 d1;d1.derive1 = 1;d1.base1.base1_1 = 11;d1.base1.__vfptr = reinterpret_cast<void**>(&__vftable_base1_derive1);d1.base2.base2_1 = 21;d1.base3.base3_1 = 31;d1.base3.__vfptr = reinterpret_cast<void**>(&__vftable_base3_derive1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于目前的CDerive1是我们手动构造的, 不存在真正语法上的继承关系, 如要得到各基类指针, 我们就不能直接来取, 必须手动根据偏移计算:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">char</span><span class="token operator">*</span> p <span class="token operator">=</span> reinterpret_cast<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d1<span class="token punctuation">)</span><span class="token punctuation">;</span>Base1<span class="token operator">*</span> pb1 <span class="token operator">=</span> reinterpret_cast<span class="token operator">&lt;</span>Base1<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Base2<span class="token operator">*</span> pb2 <span class="token operator">=</span> reinterpret_cast<span class="token operator">&lt;</span>Base2<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>CBase1<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>CBase3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Base3<span class="token operator">*</span> pb3 <span class="token operator">=</span> reinterpret_cast<span class="token operator">&lt;</span>Base3<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>CBase1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Derive1<span class="token operator">*</span> pd1 <span class="token operator">=</span> reinterpret_cast<span class="token operator">&lt;</span>Derive1<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>真正调用:</p><pre><code>foo(pb1, pb2, pb3, pd1);</code></pre><p>调用结果:<br><img src="/posts/42434/28.png" alt="28"></p><p><strong>结果相当正确!!!</strong></p><p>原文链接：<a href="https://blog.twofei.com/496/">https://blog.twofei.com/496/</a></p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 虚函数 </tag>
            
            <tag> 虚表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在浏览器输入 URL 回车之后发生了什么？</title>
      <link href="posts/18919/"/>
      <url>posts/18919/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这个问题已经是老生常谈了，更是经常被作为面试的压轴题出现，网上也有很多文章（<del>而且记得大一下去面试的时候人家就问过这个问题，然后我就把人家给鸽掉了，现在来还债</del>）</p><p>前端方面会比较重点分析浏览器渲染页面那一部分，至于其他部分我会罗列出关键词，感兴趣的可以自行查阅，</p><p>注意：本文的步骤是建立在，请求的是一个简单的 HTTP 请求，没有 HTTPS、HTTP2、最简单的 DNS、没有代理、并且服务器没有任何问题的基础上，尽管这是不切实际的。</p><p>来源 | <a href="https://4ark.me/post/b6c7c0a2.html">https://4ark.me/post/b6c7c0a2.html</a></p><h3 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h3><ol><li>URL 解析</li><li>DNS 查询</li><li>TCP 连接</li><li>处理请求</li><li>接受响应</li><li>渲染页面</li></ol><a id="more"></a><h3 id="一、URL-解析"><a href="#一、URL-解析" class="headerlink" title="一、URL 解析"></a>一、URL 解析</h3><p><strong>地址解析</strong><br>首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行自动完成、字符编码等操作。</p><p><strong>HSTS</strong><br>由于安全隐患，会使用 HSTS 强制客户端使用 HTTPS 访问页面。详见：你所不知道的 HSTS[1]。</p><p><strong>其他操作</strong><br>浏览器还会进行一些额外的操作，比如安全检查、访问限制（之前国产浏览器限制 996.icu）。</p><p><strong>检查缓存</strong><br><img src="/posts/18919/1.png" alt="检查缓存"></p><h3 id="二、DNS-查询"><a href="#二、DNS-查询" class="headerlink" title="二、DNS 查询"></a>二、DNS 查询</h3><p><strong>基本步骤</strong><br><img src="/posts/18919/2.png" alt="DNS"></p><p><strong>1. 浏览器缓存</strong><br>浏览器会先检查是否在缓存中，没有则调用系统库函数进行查询。</p><p><strong>2. 操作系统缓存</strong><br>操作系统也有自己的 DNS缓存，但在这之前，会向检查域名是否存在本地的 Hosts 文件里，没有则向 DNS 服务器发送查询请求。</p><p><strong>3. 路由器缓存</strong><br>路由器也有自己的缓存。</p><p><strong>4. ISP DNS 缓存</strong><br>ISP DNS 就是在客户端电脑上设置的首选 DNS 服务器，它们在大多数情况下都会有缓存。</p><p><strong>根域名服务器查询</strong><br>在前面所有步骤没有缓存的情况下，本地 DNS 服务器会将请求转发到互联网上的根域，下面这个图很好的诠释了整个流程：<br><img src="/posts/18919/3.png" alt="根域名服务器递归"><br><strong>需要注意的点</strong></p><ol><li><p>递归方式：一路查下去中间不返回，得到最终结果才返回信息（浏览器到本地DNS服务器的过程）</p></li><li><p>迭代方式，就是本地DNS服务器到根域名服务器查询的方式。</p></li><li><p>什么是 DNS 劫持</p></li><li><p>前端 dns-prefetch 优化</p></li></ol><h3 id="三、TCP-连接"><a href="#三、TCP-连接" class="headerlink" title="三、TCP 连接"></a>三、TCP 连接</h3><p>TCP/IP 分为四层，在发送数据时，每层都要对数据进行封装：<br><img src="/posts/18919/4.png" alt="TCP连接"></p><h4 id="1-应用层：发送-HTTP-请求"><a href="#1-应用层：发送-HTTP-请求" class="headerlink" title="1. 应用层：发送 HTTP 请求"></a>1. 应用层：发送 HTTP 请求</h4><p>在前面的步骤我们已经得到服务器的 IP 地址，浏览器会开始构造一个 HTTP 报文，其中包括：</p><ul><li><p>请求报头（Request Header）：请求方法、目标地址、遵循的协议等等</p></li><li><p>请求主体（其他参数）</p></li></ul><p>其中需要注意的点：</p><ul><li>浏览器只能发送 GET、POST 方法，而打开网页使用的是 GET 方法</li></ul><h4 id="2-传输层：TCP-传输报文"><a href="#2-传输层：TCP-传输报文" class="headerlink" title="2. 传输层：TCP 传输报文"></a>2. 传输层：TCP 传输报文</h4><p>传输层会发起一条到达服务器的 TCP 连接，为了方便传输，会对数据进行分割（以报文段为单位），并标记编号，方便服务器接受时能够准确地还原报文信息。</p><p>在建立连接前，会先进行 TCP 三次握手。</p><blockquote><p>关于 TCP/IP 三次握手，网上已经有很多段子和图片生动地描述了。<br>相关知识点：<br>SYN 泛洪攻击</p></blockquote><h4 id="3-网络层：IP协议查询Mac地址"><a href="#3-网络层：IP协议查询Mac地址" class="headerlink" title="3. 网络层：IP协议查询Mac地址"></a>3. 网络层：IP协议查询Mac地址</h4><p>将数据段打包，并加入源及目标的IP地址，并且负责寻找传输路线。</p><p>判断目标地址是否与当前地址处于同一网络中，是的话直接根据 Mac 地址发送，否则使用路由表查找下一跳地址，以及使用 ARP 协议查询它的 Mac 地址。</p><blockquote><p>注意：在 OSI 参考模型中 ARP 协议位于链路层，但在 TCP/IP 中，它位于网络层。</p></blockquote><h4 id="4-链路层：以太网协议"><a href="#4-链路层：以太网协议" class="headerlink" title="4. 链路层：以太网协议"></a>4. 链路层：以太网协议</h4><p><strong>以太网协议</strong><br>根据以太网协议将数据分为以“帧”为单位的数据包，每一帧分为两个部分：</p><p>标头：数据包的发送者、接受者、数据类型</p><p>数据：数据包具体内容</p><p><strong>Mac 地址</strong><br>以太网规定了连入网络的所有设备都必须具备“网卡”接口，数据包都是从一块网卡传递到另一块网卡，网卡的地址就是 Mac 地址。每一个 Mac 地址都是独一无二的，具备了一对一的能力。</p><p><strong>广播</strong><br>发送数据的方法很原始，直接把数据通过 ARP 协议，向本网络的所有机器发送，接收方根据标头信息与自身 Mac 地址比较，一致就接受，否则丢弃。</p><p>注意：接收方回应是单播。</p><blockquote><p>相关知识点：<br>ARP 攻击</p></blockquote><p><strong>服务器接受请求</strong><br>接受过程就是把以上步骤逆转过来，参见上图。</p><h3 id="四、服务器处理请求"><a href="#四、服务器处理请求" class="headerlink" title="四、服务器处理请求"></a>四、服务器处理请求</h3><p><strong>大致流程</strong><br><img src="/posts/18919/5.png" alt="TCP连接"></p><p><strong>HTTPD</strong><br>最常见的 HTTPD 有 Linux 上常用的 Apache 和 Nginx，以及 Windows 上的 IIS。</p><p>它会监听得到的请求，然后开启一个子进程去处理这个请求。</p><p><strong>处理请求</strong><br>接受 TCP 报文后，会对连接进行处理，对HTTP协议进行解析（请求方法、域名、路径等），并且进行一些验证：</p><ul><li><p>验证是否配置虚拟主机</p></li><li><p>验证虚拟主机是否接受此方法</p></li><li><p>验证该用户可以使用该方法（根据 IP 地址、身份信息等）</p></li></ul><p><strong>重定向</strong><br>假如服务器配置了 HTTP 重定向，就会返回一个 301永久重定向响应，浏览器就会根据响应，重新发送 HTTP 请求（重新执行上面的过程）。</p><p><strong>URL 重写</strong><br>然后会查看 URL 重写规则，如果请求的文件是真实存在的，比如图片、html、css、js文件等，则会直接把这个文件返回。</p><p>否则服务器会按照规则把请求重写到 一个 REST 风格的 URL 上。</p><p>然后根据动态语言的脚本，来决定调用什么类型的动态文件解释器来处理这个请求。</p><p>以 PHP 语言的 MVC 框架举例，它首先会初始化一些环境的参数，根据 URL 由上到下地去匹配路由，然后让路由所定义的方法去处理请求。</p><h2 id="五、浏览器接受响应"><a href="#五、浏览器接受响应" class="headerlink" title="五、浏览器接受响应"></a>五、浏览器接受响应</h2><p>浏览器接收到来自服务器的响应资源后，会对资源进行分析。</p><p>首先查看 Response header，根据不同状态码做不同的事（比如上面提到的重定向）。</p><p>如果响应资源进行了压缩（比如 gzip），还需要进行解压。</p><p>然后，对响应资源做缓存。</p><p>接下来，根据响应资源里的 MIME[3]类型去解析响应内容（比如 HTML、Image各有不同的解析方式）。</p><h2 id="六、渲染页面"><a href="#六、渲染页面" class="headerlink" title="六、渲染页面"></a>六、渲染页面</h2><p><strong>浏览器内核</strong><br><img src="/posts/18919/6.png" alt="TCP连接"><br><del>(最后一个大家也就康康)</del><br>不同的浏览器内核，渲染过程也不完全相同，但大致流程都差不多。</p><p><strong>基本流程</strong><br><img src="/posts/18919/7.png" alt="TCP连接"></p><h4 id="6-1-HTML-解析"><a href="#6-1-HTML-解析" class="headerlink" title="6.1. HTML 解析"></a>6.1. HTML 解析</h4><p>首先要知道浏览器解析是从上往下一行一行地解析的。</p><p>解析的过程可以分为四个步骤：</p><p><strong>① 解码（encoding）</strong><br>传输回来的其实都是一些二进制字节数据，浏览器需要根据文件指定编码（例如UTF-8）转换成字符串，也就是HTML 代码。</p><p><strong>② 预解析（pre-parsing）</strong><br>预解析做的事情是提前加载资源，减少处理时间，它会识别一些会请求资源的属性，比如img标签的src属性，并将这个请求加到请求队列中。</p><p><strong>③ 符号化（Tokenization）</strong><br>符号化是词法分析的过程，将输入解析成符号，HTML 符号包括，开始标签、结束标签、属性名和属性值。</p><p>它通过一个状态机去识别符号的状态，比如遇到&lt;，&gt;状态都会产生变化。</p><p><strong>④ 构建树（tree construction）</strong></p><blockquote><p>注意：符号化和构建树是并行操作的，也就是说只要解析到一个开始标签，就会创建一个 DOM 节点。</p></blockquote><p>在上一步符号化中，解析器获得这些标记，然后以合适的方法创建DOM对象并把这些符号插入到DOM对象中。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Web page parsing<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>Web page parsing<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>This is an example Web page.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/18919/8.png" alt="TCP连接"></p><p>浏览器容错进制</p><p>你从来没有在浏览器看过类似”语法无效”的错误，这是因为浏览器去纠正错误的语法，然后继续工作。</p><p>事件</p><p>当整个解析的过程完成以后，浏览器会通过DOMContentLoaded事件来通知DOM解析完成。</p><h4 id="6-2-CSS-解析"><a href="#6-2-CSS-解析" class="headerlink" title="6.2. CSS 解析"></a>6.2. CSS 解析</h4><p>一旦浏览器下载了 CSS，CSS 解析器就会处理它遇到的任何 CSS，根据语法规范[4]解析出所有的 CSS 并进行标记化，然后我们得到一个规则表。</p><p><strong>CSS 匹配规则</strong></p><p>在匹配一个节点对应的 CSS 规则时，是按照从右到左的顺序的，例如：div p { font-size :14px }会先寻找所有的p标签然后判断它的父元素是否为div。</p><p>所以我们写 CSS 时，尽量用 id 和 class，千万不要过度层叠。</p><h4 id="6-3-渲染树"><a href="#6-3-渲染树" class="headerlink" title="6.3. 渲染树"></a>6.3. 渲染树</h4><p>其实这就是一个 DOM 树和 CSS 规则树合并的过程。</p><blockquote><p>注意：渲染树会忽略那些不需要渲染的节点，比如设置了display:none的节点。</p></blockquote><p><strong>计算</strong><br>通过计算让任何尺寸值都减少到三个可能之一：auto、百分比、px，比如把rem转化为px。</p><p><strong>级联</strong><br>浏览器需要一种方法来确定哪些样式才真正需要应用到对应元素，所以它使用一个叫做specificity的公式，这个公式会通过：</p><ol><li><p>标签名、class、id</p></li><li><p>是否内联样式</p></li><li><p>!important</p></li></ol><p>然后得出一个权重值，取最高的那个。</p><p><strong>渲染阻塞</strong><br>当遇到一个script标签时，DOM 构建会被暂停，直至脚本完成执行，然后继续构建 DOM 树。</p><p>但如果 JS 依赖 CSS 样式，而它还没有被下载和构建时，浏览器就会延迟脚本执行，直至 CSS Rules 被构建。</p><p>所有我们知道：</p><ul><li><p>CSS 会阻塞 JS 执行</p></li><li><p>JS 会阻塞后面的 DOM 解析</p></li></ul><p>为了避免这种情况，应该以下原则：</p><ul><li><p>CSS 资源排在 JavaScript 资源前面</p></li><li><p>JS 放在 HTML 最底部，也就是         <script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script>        <script>        const hasAttr = (e,a) => a.some(_=> e.attr(_)!==undefined);        $('a').each(function() {          const $this = $(this);          if(hasAttr($this,["data-fancybox","ignore-external-link"])) return;          const href = $this.attr('href');          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {            const strs = href.split('/');            if (strs.length >= 3) {                const host = strs[2];                if (host !== '' || window.location.host) {                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');                    if (true) {                        $this.attr('target', '_blank');                    }                }            }          }        });        </script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":150,"height":200},"mobile":{"show":false},"react":{"opacity":0.7}});</script>前</p></li></ul><p>另外，如果要改变阻塞模式，可以使用 defer 与 async，详见：这篇文章[5]</p><h4 id="6-4-布局与绘制"><a href="#6-4-布局与绘制" class="headerlink" title="6.4. 布局与绘制"></a>6.4. 布局与绘制</h4><p>确定渲染树种所有节点的几何属性，比如：位置、大小等等，最后输入一个盒子模型，它能精准地捕获到每个元素在屏幕内的准确位置与大小。</p><p>然后遍历渲染树，调用渲染器的 paint() 方法在屏幕上显示其内容。</p><h4 id="6-5-合并渲染层"><a href="#6-5-合并渲染层" class="headerlink" title="6.5. 合并渲染层"></a>6.5. 合并渲染层</h4><p>把以上绘制的所有图片合并，最终输出一张图片。</p><h4 id="6-6-回流与重绘"><a href="#6-6-回流与重绘" class="headerlink" title="6.6. 回流与重绘"></a>6.6. 回流与重绘</h4><p><strong>回流(reflow)</strong><br>当浏览器发现某个部分发现变化影响了布局时，需要倒回去重新渲染，会从html标签开始递归往下，重新计算位置和大小。</p><p>reflow基本是无法避免的，因为当你滑动一下鼠标、resize 窗口，页面就会产生变化。</p><p><strong>重绘(repaint)</strong><br>改变了某个元素的背景色、文字颜色等等不会影响周围元素的位置变化时，就会发生重绘。</p><p>每次重绘后，浏览器还需要合并渲染层并输出到屏幕上。</p><p>回流的成本要比重绘高很多，所以我们应该尽量避免产生回流。</p><p>比如：</p><ul><li>display:none 会触发回流，而 visibility:hidden 只会触发重绘。</li></ul><h4 id="6-7-JavaScript-编译执行"><a href="#6-7-JavaScript-编译执行" class="headerlink" title="6.7. JavaScript 编译执行"></a>6.7. JavaScript 编译执行</h4><p><strong>大致流程</strong><br><img src="/posts/18919/9.png" alt="TCP连接"><br>可以分为三个阶段：</p><p><strong>1. 词法分析</strong><br>JS 脚本加载完毕后，会首先进入语法分析阶段，它首先会分析代码块的语法是否正确，不正确则抛出“语法错误”，停止执行。</p><p>几个步骤：</p><ul><li><p>分词，例如将var a = 2，，分成var、a、=、2这样的词法单元。</p></li><li><p>解析，将词法单元转换成抽象语法树（AST）。</p></li><li><p>代码生成，将抽象语法树转换成机器指令。</p></li></ul><p><strong>2. 预编译</strong><br>JS 有三种运行环境：</p><ul><li><p>全局环境</p></li><li><p>函数环境</p></li><li><p>eval</p></li></ul><p>每进入一个不同的运行环境都会创建一个对应的执行上下文，根据不同的上下文环境，形成一个函数调用栈，栈底永远是全局执行上下文，栈顶则永远是当前执行上下文。</p><p><strong>创建执行上下文</strong></p><p>创建执行上下文的过程中，主要做了以下三件事：</p><ul><li><p>创建变量对象</p><ul><li>参数、函数、变量</li></ul></li><li><p>建立作用域链</p><ul><li>确认当前执行环境是否能访问变量</li></ul></li><li><p>确定 This 指向</p></li></ul><p><strong>3. 执行</strong><br><strong>JS 线程</strong><br><img src="/posts/18919/10.png" alt="TCP连接"><br>虽然 JS 是单线程的，但实际上参与工作的线程一共有四个：</p><blockquote><p>其中三个只是协助，只有 JS 引擎线程是真正执行的</p></blockquote><ul><li><p>JS 引擎线程：也叫 JS 内核，负责解析执行 JS 脚本程序的主线程，例如 V8 引擎</p></li><li><p>事件触发线程：属于浏览器内核线程，主要用于控制事件，例如鼠标、键盘等，当事件被触发时，就会把事件的处理函数推进事件队列，等待 JS 引擎线程执行</p></li><li><p>定时器触发线程：主要控制setInterval和setTimeout，用来计时，计时完毕后，则把定时器的处理函数推进事件队列中，等待 JS 引擎线程。</p></li><li><p>HTTP 异步请求线程：通过XMLHttpRequest连接后，通过浏览器新开的一个线程，监控readyState状态变更时，如果设置了该状态的回调函数，则将该状态的处理函数推进事件队列中，等待JS引擎线程执行。</p></li></ul><p><strong>注：浏览器对同一域名的并发连接数是有限的，通常为 6 个。</strong></p><p><strong>宏任务</strong><br>分为：</p><ul><li><p>同步任务：按照顺序执行，只有前一个任务完成后，才能执行后一个任务</p></li><li><p>异步任务：不直接执行，只有满足触发条件时，相关的线程将该异步任务推进任务队列中，等待JS引擎主线程上的任务执行完毕时才开始执行，例如异步Ajax、DOM事件，setTimeout等。</p></li></ul><p><strong>微任务</strong><br>微任务是ES6和Node环境下的，主要 API 有：Promise，process.nextTick。</p><p>微任务的执行在宏任务的同步任务之后，在异步任务之前。<br><img src="/posts/18919/11.png" alt="TCP连接"></p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">console<span class="token class">.log</span>('1'); // 宏任务 同步setTimeout(function() </span><span class="token punctuation">{</span>    console<span class="token number">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> // 宏任务 异步<span class="token punctuation">}</span><span class="token selector">)new Promise(function(resolve) </span><span class="token punctuation">{</span>    console<span class="token number">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'3'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> // 宏任务 同步    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">)<span class="token class">.then</span>(function() </span><span class="token punctuation">{</span>    console<span class="token number">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'4'</span><span class="token punctuation">)</span> // 微任务<span class="token punctuation">}</span><span class="token punctuation">)</span>console<span class="token number">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'5'</span><span class="token punctuation">)</span> // 宏任务 同步<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>以上代码输出顺序为：1,3,5,4,2</strong></p><hr><p>参考文档<br>[1] 你所不知道的 HSTS: <a href="http://t.cn/AiR8pTqx">http://t.cn/AiR8pTqx</a><br>[2] 详见这篇文章: <a href="http://t.cn/AiR8pnEC">http://t.cn/AiR8pnEC</a><br>[3] MIME: <a href="http://t.cn/AiR8prtm">http://t.cn/AiR8prtm</a><br>[4] 语法规范: <a href="http://t.cn/AiR80GdO">http://t.cn/AiR80GdO</a><br>[5] 这篇文章: <a href="http://t.cn/AiR80c1k">http://t.cn/AiR80c1k</a><br>[6] what-happens-when-zh_CN: <a href="http://t.cn/AiR80xb5">http://t.cn/AiR80xb5</a><br>[7] Tags to DOM:<a href="http://t.cn/AiR80djX">http://t.cn/AiR80djX</a><br>[8] 彻底理解浏览器的缓存机制: <a href="http://t.cn/AiR8Ovob">http://t.cn/AiR8Ovob</a><br>[9] 浏览器的工作原理：新式网络浏览器幕后揭秘: <a href="http://t.cn/AiR8Oz06">http://t.cn/AiR8Oz06</a><br>[10]    深入浅出浏览器渲染原理: <a href="http://t.cn/AiR8O4fO">http://t.cn/AiR8O4fO</a><br>[11]    js引擎的执行过程（一）:<a href="http://t.cn/AiR8Ot3s">http://t.cn/AiR8Ot3s</a></p>]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算计网络 </tag>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Play-with-Algorithms(7):二分搜索树（删除、广度优先遍历、顺序性）及 衍生算法问题</title>
      <link href="posts/51492/"/>
      <url>posts/51492/</url>
      
        <content type="html"><![CDATA[<p>上篇博文介绍了二分查找算法和二分搜索树的基本操作，如插入、查找、深度优先遍历，此篇博文将要介绍二分搜索树的广度优先遍历、顺序性、局限性等相关知识，还有二分搜索树中最复杂的部分——删除节点及衍生的算法知识，涉及到的知识点如下：</p><ul><li>层序遍历（广度优先遍历）</li><li>删除最大值，最小值、删除节点</li><li>二分搜索树的顺序性</li><li>二分搜索树的局限性</li><li>树形问题和更多树。<a id="more"></a></li></ul><h2 id="一-层序遍历（广度优先遍历）"><a href="#一-层序遍历（广度优先遍历）" class="headerlink" title="一. 层序遍历（广度优先遍历）"></a>一. 层序遍历（广度优先遍历）</h2><h4 id="1-算法思想"><a href="#1-算法思想" class="headerlink" title="1.算法思想"></a>1.算法思想</h4><p>在此需要引入两个概念：深度优先遍历和广度优先遍历，而以上讲解的前序、中序、后序遍历都属于深度优先遍历，遍历一开始首先会走到最深，再回溯到开始遍历整棵树。</p><p>而广度优先遍历则是层序遍历，一层一层地向下遍历，查看以下动画：<br><img src="/posts/51492/1.gif" alt="图片"></p><h4 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h4><p>查看以上动画，实现其过程需要引入先进先出的“队列”数据结构，首先将28入队，第一层遍历完毕，可进行操作，将28出队并打印。遍历第二层16、30依次入队，再出队进行打印操作，依次类推。</p><pre class="line-numbers language-C++"><code class="language-C++">public:    // 二分搜索树的层序遍历    void levelOrder(){        queue<Node*> q;        q.push(root);//入队根节点        while( !q.empty() ){//队列为空时结束循环            Node *node = q.front();//获取队首元素            q.pop();            cout<<node->key<<endl;            if( node->left )                q.push( node->left );            if( node->right )                q.push( node->right );        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-广度、深度优先遍历总结"><a href="#3-广度、深度优先遍历总结" class="headerlink" title="3. 广度、深度优先遍历总结"></a>3. 广度、深度优先遍历总结</h4><p>不论是二分搜索树的深度优先遍历还是广度优先遍历，性能都是很高效的，为O(n)，基本上是最小的了，毕竟“遍历”至少需要每个节点遍历一次。在很多实际运用中可能不需要显示地构建出一棵树，但是需要遍历一次树中节点。</p><p>而之前学过的排序算法例如归并排序、快速排序本质上是一棵二叉树的深度优先遍历过程，此二分搜索树也是通过递归等基本内容构造的一棵复杂的数结构，可见算法与数据结构之间的互相依赖。</p><h2 id="二-二分搜索树的删除"><a href="#二-二分搜索树的删除" class="headerlink" title="二. 二分搜索树的删除"></a>二. 二分搜索树的删除</h2><p>二分搜索树中最复杂的操作——删除节点，其实此过程中的查找需删除节点和删除操作并不复杂，复杂的是如何操作删除之后节点的左右孩子，使得最后整棵树依然保持二分搜索树的性质。</p><h4 id="1-删除二分搜索树的最小值和最大值"><a href="#1-删除二分搜索树的最小值和最大值" class="headerlink" title="1. 删除二分搜索树的最小值和最大值"></a>1. 删除二分搜索树的最小值和最大值</h4><h5 id="（1）算法思想"><a href="#（1）算法思想" class="headerlink" title="（1）算法思想"></a>（1）算法思想</h5><p><strong>查找过程</strong></p><p>首先来了解最简单的情况—–删除二分搜索树的最小值和最大值，其实此过程根据搜索树的特征很容易解决，从根节点开始遍历其左孩子，直至最后节点无左孩子，那么此节点就是最小值；最大值同理，遍历其右孩子即可。<br><img src="/posts/51492/1.png" alt="图片"></p><p><strong>删除过程</strong></p><p>注意，这里二分搜索数的最小、大值并非一定完全二叉树下的情况，例如下图，所以在删除节点时，需要将其左孩子或右孩子代替其删除节点，来保持二分搜索树的特征。</p><p>举个例子，需要删除下图二分搜索树的最小值22，删除22后，22必然没有左孩子，因为它已经是最小值，将其右孩子33代替22的位置，返回节点33。删除最大值同理<br><img src="/posts/51492/2.png" alt="图片"></p><h5 id="（2）代码实现"><a href="#（2）代码实现" class="headerlink" title="（2）代码实现"></a>（2）代码实现</h5><p>公有函数，供外层调用：</p><ul><li>minimum()：寻找二分搜索树的最小的键值</li><li>maximum()：寻找二分搜索树的最大的键值</li><li>removeMin()：从二分搜索树中删除最小值所在节点</li><li>removeMax()：从二分搜索树中删除最大值所在节点</li></ul><p>私有函数，内部实际操作：</p><ul><li>Node* minimum(Node* node)：返回以node为根的二分搜索树的最小键值所在的节点</li><li>Node* maximum(Node* node)：返回以node为根的二分搜索树的最大键值所在的节点</li><li>Node* removeMin(Node* node)：删除掉以node为根的二分搜索树中的最小节点，返回删除节点后新的二分搜索树的根</li><li>Node* removeMax(Node* node)：删除掉以node为根的二分搜索树中的最大节点，返回删除节点后新的二分搜索树的根</li></ul><pre class="line-numbers language-C++"><code class="language-C++">public:    // 寻找二分搜索树的最小的键值    Key minimum(){        assert( count != 0 );        Node* minNode = minimum( root );        return minNode->key;    }    // 寻找二分搜索树的最大的键值    Key maximum(){        assert( count != 0 );        Node* maxNode = maximum(root);        return maxNode->key;    }    // 从二分搜索树中删除最小值所在节点    void removeMin(){        if( root )            root = removeMin( root );    }    // 从二分搜索树中删除最大值所在节点    void removeMax(){        if( root )            root = removeMax( root );    }private:        // 返回以node为根的二分搜索树的最小键值所在的节点    Node* minimum(Node* node){        if( node->left == NULL )            return node;        return minimum(node->left);    }    // 返回以node为根的二分搜索树的最大键值所在的节点    Node* maximum(Node* node){        if( node->right == NULL )            return node;        return maximum(node->right);    }    // 删除掉以node为根的二分搜索树中的最小节点    // 返回删除节点后新的二分搜索树的根    Node* removeMin(Node* node){        if( node->left == NULL ){            Node* rightNode = node->right;            delete node;            count --;            return rightNode;        }        node->left = removeMin(node->left);        return node;    }    // 删除掉以node为根的二分搜索树中的最大节点    // 返回删除节点后新的二分搜索树的根    Node* removeMax(Node* node){        if( node->right == NULL ){            Node* leftNode = node->left;            delete node;            count --;            return leftNode;        }        node->right = removeMax(node->right);        return node;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-删除节点"><a href="#2-删除节点" class="headerlink" title="2. 删除节点"></a>2. 删除节点</h4><h5 id="（1）算法思想-1"><a href="#（1）算法思想-1" class="headerlink" title="（1）算法思想"></a>（1）算法思想</h5><p>以上是删除节点的特殊情况，<strong>可以确定待删除节点只有1个孩子或者没有，所以在删除此节点之后，其孩子可以顶替，这样仍维护了二分搜索树的特征，</strong> 如下图示例：<br><img src="/posts/51492/2.gif" alt="图片"></p><p>但是，以上讨论的是特殊情况，若待删除节点58同时拥有左、右孩子，该如何操作？</p><p><strong>Hubbard Deletion</strong></p><p>以下介绍的算法被称为<em>Hubbard Deletion</em>，在之前的讨论中，若待删除节点只有一个孩子，则用此孩子替代待删除节点；<strong>若有两个孩子，其思想也是类似，找到一个合适的节点来替代，而<em>Hubbard Deletion</em>算法则认为此替代节点是右子树的最小节点！</strong></p><p>因此，需要代替58的节点是59，注意二分搜索树的特征，59的所有右孩子都比58要大，所以右孩子子树中的最小值59代替其58后，此二分搜索树的特征仍然成立！</p><p>因此，<strong>整个过程可以总结为首先寻找待删除节点的后继节点（右子树中的最小值），由后继节点代替待删除节点即可。</strong></p><p><img src="/posts/51492/3.gif" alt="图片"></p><h5 id="（2）代码实现-1"><a href="#（2）代码实现-1" class="headerlink" title="（2）代码实现"></a>（2）代码实现</h5><p>若要删除左右都有孩子的节点 d</p><ul><li>找到 s = min(d-&gt;right)，s 是 d 右子树中的最小值，需要代替d的后继节点</li><li><strong>s-&gt;right = delMin(d-&gt;right)</strong></li><li><strong>s-&gt;left = d-&gt;left</strong></li><li>删除d，s是新的子树的根</li></ul><pre class="line-numbers language-C++"><code class="language-C++">public:    // 从二分搜索树中删除键值为key的节点    void remove(Key key){        root = remove(root, key);    }private:    // 删除掉以node为根的二分搜索树中键值为key的节点, 递归算法    // 返回删除节点后新的二分搜索树的根    Node* remove(Node* node, Key key){        if( node == NULL )            return NULL;//未找到对应key的节点        if( key < node->key ){//在node的左子树中寻找            node->left = remove( node->left , key );            return node;        }        else if( key > node->key ){//在node的右子树中寻找            node->right = remove( node->right, key );            return node;        }        else{   // key == node->key            // 待删除节点左子树为空的情况            if( node->left == NULL ){                Node *rightNode = node->right;                delete node;                count --;                return rightNode;            }            // 待删除节点右子树为空的情况            if( node->right == NULL ){                Node *leftNode = node->left;                delete node;                count--;                return leftNode;            }            // 待删除节点左右子树均不为空的情况            // 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点            // 用这个节点顶替待删除节点的位置            Node *successor = new Node(minimum(node->right));            count ++;            successor->right = removeMin(node->right);            successor->left = node->left;            delete node;            count --;            return successor;        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：以上过程可完成二分搜索树的节点删除过程，其重点就是当待删除节点同时拥有左、右子树时，寻找右子树中的最小值进行代替。其实同理而言，另外一个思路也可实现：寻找左子树的最大值进行代替，如下图所示，这种特性来源于二分搜索树的特征，可自行实现。</strong></p><p><img src="/posts/51492/3.png" alt="图片"></p><h5 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h5><p>二分搜索树的删除操作时间复杂度为O(logn)，主要消耗于查找待删除节点，一旦找到了删除节点的过程只是指针间的交换，是常数级别的，是非常高效的。</p><h2 id="三-二分搜索树的顺序性"><a href="#三-二分搜索树的顺序性" class="headerlink" title="三. 二分搜索树的顺序性"></a>三. 二分搜索树的顺序性</h2><p>以上内容讲解了二分搜索树的各种操作，大部分情况将二分搜索树当作查找表来实现，主要关注的是如何查找一个key对应的value值，同时完成插入、删除、查找、遍历所有元素等操作，<strong>注意二分搜索树还有一个重要的特征：顺序性，也就是说不仅可以在二分搜索树中定位一个元素，还可以回答其顺序性相关的问题：</strong></p><ul><li><strong>minimum , maximum</strong>：已经实现，非常容易可在一组数据中找到最小、大值。</li><li><strong>successor , predecessor</strong>：待实现，可找到一个元素的前驱节点和后继节点。</li><li><strong>floor , ceil</strong>：待实现</li></ul><h4 id="1-前驱节点和后继节点（successor-predecessor）"><a href="#1-前驱节点和后继节点（successor-predecessor）" class="headerlink" title="1. 前驱节点和后继节点（successor , predecessor）"></a>1. 前驱节点和后继节点（successor , predecessor）</h4><h5 id="（1）算法思想-2"><a href="#（1）算法思想-2" class="headerlink" title="（1）算法思想"></a>（1）算法思想</h5><p>首先需要理解清楚前驱节点和后继节点的定义，几个例子，下图中 41的前驱节点是 37，后继节点是42。</p><p><strong>因此，规律也自然而然得出：</strong></p><ul><li>一个节点的前驱节点是其左子树中的最大值，若无左子树，其前驱节点在从根节点到key的路径上，比key小的最大值。</li><li>一个节点的后继节点是右子树的最小值，若无右子树，其后继节点在从根节点到key的路径上，比key大的最小值。</li></ul><h5 id="（2）代码实现-2"><a href="#（2）代码实现-2" class="headerlink" title="（2）代码实现"></a>（2）代码实现</h5><p>这里寻找前驱节点或后继节点的逻辑主要分为3个步骤（这里只列出寻找前驱节点的步骤，后继节点同理，在此不赘述）：</p><ul><li>如果key所在的节点不存在，则key没有前驱, 返回NULL</li><li>如果key所在的节点左子树不为空，则其左子树的最大值为key的前驱</li><li>否则，<strong>key的前驱在从根节点到key的路径上，在这个路径上寻找到比key小的最大值， 即为key的前驱</strong></li></ul><pre class="line-numbers language-C++"><code class="language-C++">public:    // 查找key的前驱    // 如果不存在key的前驱(key不存在, 或者key是整棵二叉树中的最小值), 则返回NULL    Key* predecessor(Key key){        Node *node = search(root, key);        // 如果key所在的节点不存在, 则key没有前驱, 返回NULL        if(node == NULL)            return NULL;        // 如果key所在的节点左子树不为空,则其左子树的最大值为key的前驱        if(node->left != NULL)            return &(maximum(node->left)->key);        // 否则, key的前驱在从根节点到key的路径上, 在这个路径上寻找到比key小的最大值, 即为key的前驱        Node* preNode = predecessorFromAncestor(root, key);        return preNode == NULL ? NULL : &(preNode->key);    }    // 查找key的后继, 递归算法    // 如果不存在key的后继(key不存在, 或者key是整棵二叉树中的最大值), 则返回NULL    Key* successor(Key key){        Node *node = search(root, key);        // 如果key所在的节点不存在, 则key没有前驱, 返回NULL        if(node == NULL)            return NULL;        // 如果key所在的节点右子树不为空,则其右子树的最小值为key的后继        if(node->right != NULL)            return &(minimum(node->right)->key);        // 否则, key的后继在从根节点到key的路径上, 在这个路径上寻找到比key大的最小值, 即为key的后继        Node* sucNode = successorFromAncestor(root, key);        return sucNode == NULL ? NULL : &(sucNode->key);    }private:    // 在以node为根的二叉搜索树中, 寻找key的祖先中,比key小的最大值所在节点, 递归算法    // 算法调用前已保证key存在在以node为根的二叉树中    Node* predecessorFromAncestor(Node* node, Key key){        if(node->key == key)            return NULL;        Node* maxNode;        if(key < node->key)            // 如果当前节点大于key, 则当前节点不可能是比key小的最大值            // 向下搜索到的结果直接返回            return predecessorFromAncestor(node->left, key);        else{            assert(key > node->key);            // 如果当前节点小于key, 则当前节点有可能是比key小的最大值            // 向下搜索结果存储到maxNode中            maxNode = predecessorFromAncestor(node->right, key);            if(maxNode)                // maxNode和当前节点node取最大值返回                return maxNode->key > node->key ? maxNode : node;            else                // 如果maxNode为空, 则当前节点即为结果                return node;        }    }    // 在以node为根的二叉搜索树中, 寻找key的祖先中,比key大的最小值所在节点, 递归算法    // 算法调用前已保证key存在在以node为根的二叉树中    Node* successorFromAncestor(Node* node, Key key){        if(node->key == key)            return NULL;        Node* minNode;        if(key > node->key)            // 如果当前节点小于key, 则当前节点不可能是比key大的最小值            // 向下搜索到的结果直接返回            return successorFromAncestor(node->right, key);        else{            assert(key < node->key);            // 如果当前节点大于key, 则当前节点有可能是比key大的最小值            // 向下搜索结果存储到minNode中            minNode = predecessorFromAncestor(node->left, key);            if(minNode)                // minNode和当前节点node取最小值返回                return minNode->key < node->key ? minNode : node;            else                // 如果minNode为空, 则当前节点即为结果                return node;        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-floor-ceil"><a href="#2-floor-ceil" class="headerlink" title="2. floor , ceil"></a>2. floor , ceil</h4><h5 id="（1）算法思想-3"><a href="#（1）算法思想-3" class="headerlink" title="（1）算法思想"></a>（1）算法思想</h5><p>寻找floor , ceil不同于上部分所讲的，寻找一个节点的前驱节点和后继节点首先有个前提就是要保证此节点一定存在，但是寻找floor , ceil无需保证。</p><ul><li><p>若key值存在，那么floor , ceil就是key值自身。</p></li><li><p>若key值不存在： </p><ul><li>floor：是最接近key值且<strong>小于</strong> key的节点</li><li>ceil：是最接近key值且<strong>大于</strong> key的节点<br>例如下图，举几个例子来了解：</li></ul></li><li><p>节点41的floor , ceil是41；</p></li><li><p>45的floor是42，ceil是50；</p></li><li><p>64无ceil，floor是61；</p></li><li><p>11无floor，ceil是13。</p></li></ul><p><img src="/posts/51492/4.png" alt="图片"></p><h5 id="2）代码实现"><a href="#2）代码实现" class="headerlink" title="(2）代码实现"></a>(2）代码实现</h5><p>这里寻找floor 或 ceil 的逻辑主要分为3个步骤（这里只列出寻找floor 的步骤，ceil 同理，在此不赘述）：</p><ul><li>如果node的key值和要寻找的key值相等：则node本身就是key的floor节点。</li><li>如果node的key值比要寻找的key值大：则要寻找的key的floor节点一定在node的左子树中。</li><li>如果node的key值比要寻找的key值小：<strong>则node有可能是key的floor节点, 也有可能不是(存在比node-&gt;key大但是小于key的其余节点)，需要尝试向node的右子树寻找一下。</strong></li></ul><pre class="line-numbers language-C++"><code class="language-C++">public:     // 寻找key的floor值, 递归算法    // 如果不存在key的floor值(key比BST中的最小值还小), 返回NULL    Key* floor(Key key){        if( count == 0 || key < minimum() )            return NULL;        Node *floorNode = floor(root, key);        return &(floorNode->key);    }    // 寻找key的ceil值, 递归算法    // 如果不存在key的ceil值(key比BST中的最大值还大), 返回NULL    Key* ceil(Key key){        if( count == 0 || key > maximum() )            return NULL;        Node *ceilNode = ceil(root, key);        return &(ceilNode->key);    }private:    // 在以node为根的二叉搜索树中, 寻找key的floor值所处的节点, 递归算法    Node* floor(Node* node, Key key){        if( node == NULL )            return NULL;        // 如果node的key值和要寻找的key值相等        // 则node本身就是key的floor节点        if( node->key == key )            return node;        // 如果node的key值比要寻找的key值大        // 则要寻找的key的floor节点一定在node的左子树中        if( node->key > key )            return floor( node->left , key );        // 如果node->key < key        // 则node有可能是key的floor节点, 也有可能不是(存在比node->key大但是小于key的其余节点)        // 需要尝试向node的右子树寻找一下        Node* tempNode = floor( node->right , key );        if( tempNode != NULL )            return tempNode;        return node;    }    // 在以node为根的二叉搜索树中, 寻找key的ceil值所处的节点, 递归算法    Node* ceil(Node* node, Key key){        if( node == NULL )            return NULL;        // 如果node的key值和要寻找的key值相等        // 则node本身就是key的ceil节点        if( node->key == key )            return node;        // 如果node的key值比要寻找的key值小        // 则要寻找的key的ceil节点一定在node的右子树中        if( node->key < key )            return ceil( node->right , key );        // 如果node->key > key        // 则node有可能是key的ceil节点, 也有可能不是(存在比node->key小但是大于key的其余节点)        // 需要尝试向node的左子树寻找一下        Node* tempNode = ceil( node->left , key );        if( tempNode != NULL )            return tempNode;        return node;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四-局限性"><a href="#四-局限性" class="headerlink" title="四. 局限性"></a>四. 局限性</h2><p>它的局限性来源于哪？注意其二分搜索树的创建，如下图所示，同样的数据，可以对应不同的二分搜索树。<br><img src="/posts/51492/5.png" alt="图片"><br>如上图，第一种创建情况可能是大部分人心中设想，但是第二种情况也是符合二分搜索树的特征，如此一来，二分搜索树可能退化成链表。二分搜索树的查找过程是与其高度相关，此时高度为n，时间复杂度为O(n^2)。<br>分析:</p><p>首先顺序查找表SST本质是用链表实现，只需要处理一个指针，BST2虽然退化成链表，但是在实现操作过程中还是有左孩子的概念，所以需要一直判断左孩子为空的情况，并且BST采用递归方式实现，其中的入栈出栈操作本身就会比链表中迭代的实现方式满。因此，以上两个因素累积起来，造成BST2性能损耗严重。</p><p>总结:其实二分搜索树的性能总体而言还是十分优异的，它所有的有关操作时间复杂度为O(n)，出现以上情况的概率很小，但如果创建时其数据都是有序的，那么就会令人担忧了。也许你会想到快速排序中也有此问题，不过它通过随机获取标志点的方法解决了此问题。</p><p>所以类似以上解决办法，将其顺序打乱再插入到二分搜索树即可？这是一个解决办法，但是需要一开始获取所有数据，其实这些数据是慢慢流入系统的，所以在创建其过程中才会发现数据是否几乎有序。</p><p>为了解决此问题，<strong>可以改造二叉树的实现，使得其无法退化成链表—–平衡二叉树，它有左右两棵子树，并且其高度差不会超过1，因此可以保证其高度一定是 logn 级别的，此概念的经典实现就是红黑树。</strong></p><p><img src="/posts/51492/6.png" alt="图片"><br>如上图，红黑树中有两类节点：红色节点和黑色节点，在插入、删除等操作中会考虑节点的颜色进行处理，是一种很经典的数据结构。</p><h2 id="五-树形问题和更多树"><a href="#五-树形问题和更多树" class="headerlink" title="五. 树形问题和更多树"></a>五. 树形问题和更多树</h2><p>这两篇博文主要都在讲解如何构造一棵二分搜索树，你会发现在很多算法问题中虽然未要求创建出一棵树结构，但是在问题求解过程中会使用到树结构，<strong>这种结构含有天然的递归性质。</strong></p><h4 id="1-排序问题"><a href="#1-排序问题" class="headerlink" title="1. 排序问题"></a>1. 排序问题</h4><h5 id="（1）归并排序"><a href="#（1）归并排序" class="headerlink" title="（1）归并排序"></a>（1）归并排序</h5><p>例如之前讲解排序算法中的归并排序，回忆其重点，将数组逐渐分成两个部分，分别排序，再逐渐归并起来。这整个过程归纳起来就是一棵树的情况，虽然在解决问题时并未创建树结构。<br><img src="/posts/51492/7.png" alt="图片"></p><h5 id="（2）快速排序"><a href="#（2）快速排序" class="headerlink" title="（2）快速排序"></a>（2）快速排序</h5><p>同理，快速排序中找到数组的标志点将其一分为二，在子数组中继续找到标志点再将其一份为二。其过程都是对数的一次遍历，类似于后序遍历或前序遍历。<br><img src="/posts/51492/8.png" alt="图片"></p><h4 id="2-搜索问题"><a href="#2-搜索问题" class="headerlink" title="2. 搜索问题"></a>2. 搜索问题</h4><p>递归方式对于搜索问题更是尤为重要！事实上，绝大部分计算机问题都可以使用搜索方式解决。</p><h5 id="（1）一条龙游戏"><a href="#（1）一条龙游戏" class="headerlink" title="（1）一条龙游戏"></a>（1）一条龙游戏</h5><p>例如下图：“一条龙游戏”，在与电脑博弈的过程中，每次在九宫格走的e格子进行枚举，每次枚举会产生新的棋局，相当于上个棋局派生的子节点，再次派生其子节点，以此类推，产生决策树，选择最优可能。<br><img src="/posts/51492/9.png" alt="图片"></p><h5 id="（2）8皇后"><a href="#（2）8皇后" class="headerlink" title="（2）8皇后"></a>（2）8皇后</h5><p>经典的一个问题，在国际象棋中摆放8个皇后，使得横、竖、对角线之间<br>无重复元素。<br><img src="/posts/51492/10.png" alt="图片"></p><h5 id="（3）数独"><a href="#（3）数独" class="headerlink" title="（3）数独"></a>（3）数独</h5><p><img src="/posts/51492/11.png" alt="图片"></p><p>树形搜索同样是人工智能中的一个重点，例如国际象棋中的人工智能核心就是搜索。</p><h4 id="3-各种各样的树"><a href="#3-各种各样的树" class="headerlink" title="3. 各种各样的树"></a>3. 各种各样的树</h4><p>KD 树<br>区间树<br>哈夫曼树<br>树的应用十分广泛，以上第五点内容仅为扩展，有兴趣可自行深入探究。</p><p>来源：<a href="https://blog.csdn.net/ITermeng/article/details/77763237">https://blog.csdn.net/ITermeng/article/details/77763237</a></p>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Play-with-Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Play-with-Algorithms(6):二分查找 和 二分搜索树（插入、查找、深度优先遍历)</title>
      <link href="posts/45476/"/>
      <url>posts/45476/</url>
      
        <content type="html"><![CDATA[<p>此篇文章将介绍二叉搜索树（Binary Search Tree），同上篇文章介绍的二叉堆本质上类似，都是一个二叉树。选择什么特征的二叉树是根据具体问题来决定的，需谨记选择数据结构的核心在于解决问题，并非为了使用而使用，而是因为二叉树能够高效地解决某类问题。</p><p>此篇博文涉及的知识点如下：</p><ul><li>二分查找法</li><li>二分搜索树基础</li><li>二分搜索树的节点插入</li><li>二分搜索书的查找</li><li>二分搜索树的遍历（深度优先遍历）</li></ul><a id="more"></a><h2 id="一-查找问题"><a href="#一-查找问题" class="headerlink" title="一.查找问题"></a>一.查找问题</h2><p>搜索树能够高效地解决查找问题，虽然查找问题的描述看起来十分简单，但它是计算机中重要的基础问题，应用很广泛。在进行搜索树讲解之前，先介绍一个经典查找算法 —– 二分查找（Binary Search）。</p><h4 id="1-限制"><a href="#1-限制" class="headerlink" title="1. 限制"></a>1. 限制</h4><p><strong>对于有序数列，才能使用二分查找法！在此体现出前面几篇文章介绍的排序算法的作用：可作为其它算法的子过程 。</strong></p><h4 id="2-算法思想"><a href="#2-算法思想" class="headerlink" title="2. 算法思想"></a>2. 算法思想</h4><p>注意该算法的前提条件：有序数组。例如下图，想查找元素value，先查看数组中间元素值v与value的大小，若相等则刚好，否则根据比较结果选择左、右半部分再次寻找。</p><p>整个查找过程可构成一棵树，时间复杂度为O(logn)。</p><p><img src="/posts/45476/1.png" alt="图片"></p><h4 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h4><pre class="line-numbers language-C++"><code class="language-C++">// 二分查找法,在有序数组arr中,查找target// 如果找到target,返回相应的索引index// 如果没有找到target,返回-1template<typename T>int binarySearch(T arr[], int n, T target){    // 在arr[l...r]之中查找target    int l = 0, r = n-1;    while( l <= r ){        //int mid = (l + r)/2;        // 防止极端情况下的整形溢出，使用下面的逻辑求出mid        int mid = l + (r-l)/2;        if( arr[mid] == target )            return mid;        if( arr[mid] > target )            r = mid - 1;        else            l = mid + 1;    }    return -1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看以上代码，发现整个查找过程就是通过比较中间值大小，从而在其左部分或右部分查找，其实也是一个递归的过程，可通过递归实现，通常思维思考起来更容易，只是性能上会略差（常数级别）。</p><pre class="line-numbers language-C++"><code class="language-C++">// 用递归的方式写二分查找法template<typename T>int __binarySearch2(T arr[], int l, int r, T target){    if( l > r )        return -1;    //int mid = (l+r)/2;    // 防止极端情况下的整形溢出，使用下面的逻辑求出mid    int mid = l + (r-l)/2;    if( arr[mid] == target )        return mid;    else if( arr[mid] > target )        return __binarySearch2(arr, l, mid-1, target);    else        return __binarySearch2(arr, mid+1, r, target);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-变种算法-floor-和-ceil"><a href="#4-变种算法-floor-和-ceil" class="headerlink" title="4. 变种算法 floor 和 ceil"></a>4. 变种算法 floor 和 ceil</h4><h5 id="（1）算法思想"><a href="#（1）算法思想" class="headerlink" title="（1）算法思想"></a>（1）算法思想</h5><p>以上实现的二分查找，在数组中存在重复值的情况下无法确定返回的唯一索引值，于是二分查找法的变种：floor 和 ceil</p><p><img src="/posts/45476/2.png" alt="图片"></p><ul><li><p><strong>floor</strong>：是查找元素在数组中<strong>第一个</strong>索引位置；若数组中无此元素，则是查找元素值<strong>前一个</strong>索引位置。</p></li><li><p><strong>ceil</strong>：是查找元素在数组中<strong>最后一个</strong>索引位置；若数组中无此元素，则是查找元素值<strong>后一个</strong>索引位置。</p></li></ul><p><img src="/posts/45476/3.png" alt="图片"></p><h5 id="（2）代码实现"><a href="#（2）代码实现" class="headerlink" title="（2）代码实现"></a>（2）代码实现</h5><pre class="line-numbers language-C++"><code class="language-C++">// 二分查找法, 在有序数组arr中, 查找target// 如果找到target, 返回第一个target相应的索引index// 如果没有找到target, 返回比target小的最大值相应的索引, 如果这个最大值有多个, 返回最大索引// 如果这个target比整个数组的最小元素值还要小, 则不存在这个target的floor值, 返回-1template<typename T>int floor(T arr[], int n, T target){    assert( n >= 0 );    // 寻找比target小的最大索引    int l = -1, r = n-1;    while( l < r ){        // 使用向上取整避免死循环        int mid = l + (r-l+1)/2;        if( arr[mid] >= target )            r = mid - 1;        else            l = mid;    }    assert( l == r );    // 如果该索引+1就是target本身, 该索引+1即为返回值    if( l + 1 < n && arr[l+1] == target )        return l + 1;    // 否则, 该索引即为返回值    return l;}// 二分查找法, 在有序数组arr中, 查找target// 如果找到target, 返回最后一个target相应的索引index// 如果没有找到target, 返回比target大的最小值相应的索引, 如果这个最小值有多个, 返回最小的索引// 如果这个target比整个数组的最大元素值还要大, 则不存在这个target的ceil值, 返回整个数组元素个数ntemplate<typename T>int ceil(T arr[], int n, T target){    assert( n >= 0 );    // 寻找比target大的最小索引值    int l = 0, r = n;    while( l < r ){        // 使用普通的向下取整即可避免死循环        int mid = l + (r-l)/2;        if( arr[mid] <= target )            l = mid + 1;        else // arr[mid] > target            r = mid;    }    assert( l == r );    // 如果该索引-1就是target本身, 该索引+1即为返回值    if( r - 1 >= 0 && arr[r-1] == target )        return r-1;    // 否则, 该索引即为返回值    return r;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二-二分搜索树"><a href="#二-二分搜索树" class="headerlink" title="二. 二分搜索树"></a>二. 二分搜索树</h2><h4 id="1-优势"><a href="#1-优势" class="headerlink" title="1. 优势"></a>1. 优势</h4><p>首先来了解二分搜索树的优势。</p><h5 id="（1）查找表的实现-字典数据结构"><a href="#（1）查找表的实现-字典数据结构" class="headerlink" title="（1）查找表的实现 - 字典数据结构"></a>（1）查找表的实现 - 字典数据结构</h5><p>查找表的实现，通常这种实现又被称为“字典数据结构”，都是以键值对形式形成了表，通过key来查找对应value。如果这些key值都是整型，那么可以使用数组实现，但是在实际运用中key值是比较复杂的，例如字典。因此需要实现一个“查找表”，最基础方式就是二分搜索树。<br><img src="/posts/45476/4.png" alt="图片"></p><h5 id="（2）时间复杂度比较"><a href="#（2）时间复杂度比较" class="headerlink" title="（2）时间复杂度比较"></a>（2）时间复杂度比较</h5><p>通过以上分析，其实普通数组和顺序数组也可以完成以上需求，但是操作起来消耗的时间却不尽人意。<br><img src="/posts/45476/5.png" alt="图片"></p><h5 id="（3）高效性"><a href="#（3）高效性" class="headerlink" title="（3）高效性"></a>（3）高效性</h5><ul><li>不仅可查找数据，还可以高效地插入，删除数据之类的动态维护数据。</li><li>可以方便地回答很多数据之间的关系问题： </li><li>min, max</li><li>floor, ceil</li><li>rank</li><li>select</li></ul><h4 id="2-定义"><a href="#2-定义" class="headerlink" title="2. 定义"></a>2. 定义</h4><h5 id="（1）特征"><a href="#（1）特征" class="headerlink" title="（1）特征"></a>（1）特征</h5><p>二分搜索树本质上是一棵二叉树。</p><ul><li><strong>每个节点的键值大于左孩子</strong></li><li><strong>每个节点的键值小于右孩子</strong></li><li>以左右孩子为根的子树仍为二分搜索树<br><img src="/posts/45476/6.png" alt="图片"></li></ul><p><em>注意：上篇博文中讲解的堆是一棵完全的二叉树，但对于二分搜索而言，并无此限制，例如下图。</em></p><p><img src="/posts/45476/7.png" alt="图片"></p><h4 id="3-代码实现-1"><a href="#3-代码实现-1" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h4><p>在代码实现堆时，正是因为它是一棵完全的二叉树此特点，所以可使用数组进行实现，但是二分搜索树并无此特性，<strong>所以在实现上是设立key、value这种Node节点，节点之间的连续使用指针。</strong></p><p><strong>Node节点结构体包含：</strong></p><ul><li>Key key;</li><li>Value value;</li><li>Node *left; //左孩子节点指针</li><li>Node *right; //右孩子节点指针</li></ul><p><strong>私有成员变量：</strong></p><ul><li>Node *root; // 根节点</li><li>int count; // 节点个数</li></ul><p><strong>公有基本方法：</strong></p><ul><li>BST() // 构造函数, 默认构造一棵空二分搜索树</li><li>int size() // 返回二分搜索树的节点个数</li><li>bool isEmpty() // 返回二分搜索树是否为空</li></ul><p>以下就是二分搜索树的基本结构，实现并不复杂，代码如下：</p><pre class="line-numbers language-C++"><code class="language-C++">// 二分搜索树template <typename Key, typename Value>class BST{private:    // 二分搜索树中的节点为私有的结构体, 外界不需要了解二分搜索树节点的具体实现    struct Node{        Key key;        Value value;        Node *left;        Node *right;        Node(Key key, Value value){            this->key = key;            this->value = value;            this->left = this->right = NULL;        }    };    Node *root; // 根节点    int count;  // 节点个数public:    // 构造函数, 默认构造一棵空二分搜索树    BST(){        root = NULL;        count = 0;    }    ~BST(){        // TODO: ~BST()    }    // 返回二分搜索树的节点个数    int size(){        return count;    }    // 返回二分搜索树是否为空    bool isEmpty(){        return count == 0;    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-插入新节点"><a href="#4-插入新节点" class="headerlink" title="4. 插入新节点"></a>4. 插入新节点</h4><p>算法思想</p><p>查看以下动画演示了解插入新节点的算法思想：（其插入过程充分利用了二分搜索树的特性）</p><p>例如待插入数据60，首先与根元素41比较，大于根元素，则与其右孩子再进行比较，大于58由于58无右孩子，则60为58的右孩子，过程结束。（注意其递归过程）<br><img src="/posts/45476/1.gif" alt="图片"></p><p><strong>代码实现：insert函数</strong></p><ul><li>判断node节点是否为空，为空则创建节点并将其返回（ <strong>判断递归到底的情况</strong>）。<br>若不为空，则继续判断根元素的key值是否等于根元素的key值： <ul><li>若相等则直接更新value值即可。</li><li><strong>若不相等，则根据其大小比较在左孩子或 右孩子部分继续递归直至找到合适位置为止。</strong></li></ul></li></ul><pre class="line-numbers language-C++"><code class="language-C++">public:    // 向二分搜索树中插入一个新的(key, value)数据对    void insert(Key key, Value value){        root = insert(root, key, value);    }private:    // 向以node为根的二分搜索树中, 插入节点(key, value), 使用递归算法    // 返回插入新节点后的二分搜索树的根    Node* insert(Node *node, Key key, Value value){        if( node == NULL ){            count ++;            return new Node(key, value);        }        if( key == node->key )            node->value = value;        else if( key < node->key )            node->left = insert( node->left , key, value);        else    // key > node->key            node->right = insert( node->right, key, value);        return node;    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上就是二分搜索树插入节点的算法，以递归的形式进行实现。</p><h4 id="5-二分搜索树的查找"><a href="#5-二分搜索树的查找" class="headerlink" title="5. 二分搜索树的查找"></a>5. 二分搜索树的查找</h4><p>其实在理解二分搜索树的插入过程后，其查找过程本质上是相同的，这里提供两个搭配使用的查找函数：</p><ul><li>bool contain(Key key)：查看二分搜索树中是否存在键key</li><li>Value* search(Key key)：在二分搜索树中搜索键key所对应的值。如果这个值不存在, 则返回NULL。<strong>（注意：这里返回值使用Value* ，就是为了避免用户查找的值并不存在而出现异常）</strong></li></ul><pre class="line-numbers language-C++"><code class="language-C++">public:   // 查看二分搜索树中是否存在键key    bool contain(Key key){        return contain(root, key);    }    // 在二分搜索树中搜索键key所对应的值。如果这个值不存在, 则返回NULL    Value* search(Key key){        return search( root , key );    }private:    // 查看以node为根的二分搜索树中是否包含键值为key的节点, 使用递归算法    bool contain(Node* node, Key key){        if( node == NULL )            return false;        if( key == node->key )            return true;        else if( key < node->key )            return contain( node->left , key );        else // key > node->key            return contain( node->right , key );    }    // 在以node为根的二分搜索树中查找key所对应的value, 递归算法    // 若value不存在, 则返回NULL    Value* search(Node* node, Key key){        if( node == NULL )            return NULL;        if( key == node->key )            return &(node->value);        else if( key < node->key )            return search( node->left , key );        else // key > node->key            return search( node->right, key );    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三-二分搜索树的遍历"><a href="#三-二分搜索树的遍历" class="headerlink" title="三. 二分搜索树的遍历"></a>三. 二分搜索树的遍历</h2><p>接下来讲解二分搜索树的遍历过程，学习之后不论是其它的树、图结构，都会使用到遍历。</p><p><strong>二分搜索树的前中后序遍历：</strong></p><p>对于每个节点而言，可能会有左、右两个孩子，所以分成下图中3个点，每次递归过程中会经过这3个点<br><img src="/posts/45476/8.png" alt="图片"></p><ul><li>前序遍历：先访问当前节点，再依次递归访问左右子树</li><li>中序遍历：先递归访问左子树，再访问自身，再递归访问右子树</li><li>后续遍历：先递归访问左右子树，再访问自身节点</li></ul><h4 id="1-前序遍历"><a href="#1-前序遍历" class="headerlink" title="1. 前序遍历"></a>1. 前序遍历</h4><h5 id="（1）算法思想-1"><a href="#（1）算法思想-1" class="headerlink" title="（1）算法思想"></a>（1）算法思想</h5><p><strong>前序遍历：先访问当前节点，再依次递归访问左右子树。</strong><br><img src="/posts/45476/2.gif" alt="图片"></p><p>其实在遍历过程中每个节点都访问了3次，对应着这3个小点，顺序为前-&gt; 中 -&gt; 后，<strong>只有在“前”点时才会打印该节点元素值。</strong></p><p>最终打印结果：<br><img src="/posts/45476/9.png" alt="图片"></p><h5 id="（2）代码实现-1"><a href="#（2）代码实现-1" class="headerlink" title="（2）代码实现"></a>（2）代码实现</h5><pre class="line-numbers language-C++"><code class="language-C++">public:    // 二分搜索树的前序遍历    void preOrder(){        preOrder(root);    }private:    // 对以node为根的二叉搜索树进行前序遍历, 递归算法    void preOrder(Node* node){        if( node != NULL ){            cout<<node->key<<endl;            preOrder(node->left);            preOrder(node->right);        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2. 中序遍历"></a>2. 中序遍历</h4><h5 id="（1）算法思想-2"><a href="#（1）算法思想-2" class="headerlink" title="（1）算法思想"></a>（1）算法思想</h5><p><strong>中序遍历：先递归访问左子树，再访问自身，再递归访问右子树。</strong><br><img src="/posts/45476/3.gif" alt="图片"><br>在遍历过程中每个节点都访问了3次，对应着这3个小点，顺序为前-&gt; 中 -&gt; 后，<strong>只有在“中”点时才会打印该节点元素值。</strong><br><img src="/posts/45476/10.png" alt="图片"><br>查看其打印结果，<strong>是按照从小到大的顺序进行打印的，所以在进行实际应用时，可使用二分搜索输的中序遍历将元素按照从小到大顺序输出。其原因与二分搜索树定义相关的！</strong></p><h5 id="（2）代码实现-2"><a href="#（2）代码实现-2" class="headerlink" title="（2）代码实现"></a>（2）代码实现</h5><pre class="line-numbers language-C++"><code class="language-C++">public:    // 二分搜索树的中序遍历    void inOrder(){        inOrder(root);    }private:    // 对以node为根的二叉搜索树进行中序遍历, 递归算法    void inOrder(Node* node){        if( node != NULL ){            inOrder(node->left);            cout<<node->key<<endl;            inOrder(node->right);        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="3. 后序遍历"></a>3. 后序遍历</h4><h5 id="（1）算法思想-3"><a href="#（1）算法思想-3" class="headerlink" title="（1）算法思想"></a>（1）算法思想</h5><p><strong>后续遍历：先递归访问左右子树，再访问自身节点。</strong><br><img src="/posts/45476/4.gif" alt="图片"><br>在遍历过程中每个节点都访问了3次，对应着这3个小点，顺序为前-&gt; 中 -&gt; 后，<strong>只有在“后”点时才会打印该节点元素值。</strong></p><p>最终打印结果：<br><img src="/posts/45476/11.png" alt="图片"></p><h5 id="（2）代码实现-3"><a href="#（2）代码实现-3" class="headerlink" title="（2）代码实现"></a>（2）代码实现</h5><pre class="line-numbers language-C++"><code class="language-C++">public:    // 二分搜索树的后序遍历    void postOrder(){        postOrder(root);    }private:    // 对以node为根的二叉搜索树进行后序遍历, 递归算法    void postOrder(Node* node){        if( node != NULL ){            postOrder(node->left);            postOrder(node->right);            cout<<node->key<<endl;        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上所有深度优先遍历代码实现可分为3个步骤：</p><ul><li>递归左孩子</li><li>递归右孩子</li><li>打印自身<br>以上遍历只是交换了这3个步骤的执行顺序。</li></ul><h4 id="4-释放空间"><a href="#4-释放空间" class="headerlink" title="4. 释放空间"></a>4. 释放空间</h4><h5 id="（1）析构函数思想"><a href="#（1）析构函数思想" class="headerlink" title="（1）析构函数思想"></a>（1）析构函数思想</h5><p>在第二大点中构造二分搜索树的基本结构时，并未具体实现析构函数~BST()，而在理解以上深度优先遍历思想后，可以由此实现：<strong>通过后序遍历来删除节点。先判断节点是否为空，若不为空，则先删除掉其左孩子，再删除掉右孩子，最后毫无顾虑了，删除掉自身。</strong></p><h5 id="（2）析构函数代码实现"><a href="#（2）析构函数代码实现" class="headerlink" title="（2）析构函数代码实现"></a>（2）析构函数代码实现</h5><pre class="line-numbers language-C++"><code class="language-C++">public:    // 析构函数, 释放二分搜索树的所有空间    ~BST(){        destroy( root );    }private:    // 释放以node为根的二分搜索树的所有节点    // 采用后续遍历的递归算法    void destroy(Node* node){        if( node != NULL ){            destroy( node->left );            destroy( node->right );            delete node;            count --;        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上是二分搜索树的部分内容，需要注意的是二分搜索树中最复杂的部分——删除节点，在下篇博文会进行讲解，涉及到的知识点如下：</p><ul><li>层序遍历（广度优先遍历）</li><li>删除最大值，最小值、删除节点</li><li>二分搜索树的顺序性</li><li>二分搜索树的局限性</li><li>树形问题和更多树</li></ul><p>转自：<a href="https://blog.csdn.net/ITermeng/article/details/77737480">https://blog.csdn.net/ITermeng/article/details/77737480</a></p>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Play-with-Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Play-with-Algorithms(5)：排序算法总结 和 索引堆及优化（堆结构）</title>
      <link href="posts/31650/"/>
      <url>posts/31650/</url>
      
        <content type="html"><![CDATA[<p>前四篇博文介绍的O(n^2)或O(n*logn)排序算法及堆排序结束，意味着有关排序算法已讲解完毕，此篇博文将对这些排序算法进行比较总结，并且学习另一个经典的堆结构，处于二叉堆优化之上的索引堆，最后拓展了解由堆衍生的一些问题。</p><p>此篇涉及的知识点有：</p><ul><li>排序算法总结</li><li>索引堆及其优化</li><li>堆结构衍生的问题</li></ul><a id="more"></a><h2 id="一-排序算法总结"><a href="#一-排序算法总结" class="headerlink" title="一. 排序算法总结"></a>一. 排序算法总结</h2><p>前三篇博文介绍的排序算法及以上讲解完的堆排序完成，意味着有关排序算法已讲解完毕，下面对这些排序算法进行简单总结：<br><img src="/posts/31650/1.png" alt="图片"></p><p><strong>（1）均时间复杂度</strong></p><p>注意，表格中强调的是“平均”时间复杂度，比如说快速排序，待排序数组已经是近乎有序，那么其时间复杂度会退化到O(n^2)，所以使用了随机算法优化使其概率降低到0。<strong>总体而言，快速排序的性能较优，也就是说在O(n*logn)这3种算法而言有常数性的差异，但快速排序较优，所以一般系统级别的排序采用快速排序，而对于含有大量重复元素的数组可采用优化的三路快速排序。</strong></p><p><strong>（2）原地排序</strong></p><p>插入排序、快速排序和堆排序可以直接在待排序数组上交换元素完成排序过程，而归并排序无法完成，它必须开辟额外的空间来辅助完成。正因如此，若一个系统对空间使用比较敏感，并不会采用归并排序。</p><p><strong>（3）额外空间</strong></p><ul><li>对于插入排序和堆排序而言，使用的额外空间就是数组上交换元素，所以所耗空间为O(1)级别，即常数级别。</li><li>归并排序需要O(n)级别空间，即数组同等长度空间来辅助完成归并过程。</li><li>快速排序所需O(logn)额外空间，因为它采用递归方式来进行排序，递归有logn层，所以需要O(logn)空间来保证每一层的临时变量以供递归返回时继续使用。</li></ul><p><strong>（4）稳定排序</strong></p><p>稳定排序：对于相等的元素，在排序后，原来靠前的元素依然靠前，即相等元素的相对位置没有发生改变，此算法才是稳定的。</p><p><img src="/posts/31650/2.png" alt="图片"></p><p>例如上图数组中有3个相同元素3，在排序后，这分开的3个3肯定会排列在一起，但重点依旧按照原来的“红绿蓝”位置排列，这才是稳定排序。</p><p>例如实际应用中，学生名单按照名字字典序排列，现在需要按照成绩重新排列，最后几个同分的同学之间依然还是按照字典序排列。</p><ul><li>稳定排序 <ul><li>插入排序：算法中有后面元素与前面元素相比较，若小于则前移，否则不动。所以相同元素之间位置不会发生改变。</li><li>归并排序：在归并过程中，左右子数组已经有序，需要归并到一起，其核心也是判断当后面元素小于前面元素才前移，否则不动。所以相同元素之间位置不会发生改变。</li></ul></li><li>不稳定排序 <ul><li>快速排序：算法核心中会随机选择一个标志点来进行大于、小于判断排序，所以很有可能使得后面相等元素到前面来。所以相同元素之间位置会发生改变。</li><li>堆排序：将整个数组整理成堆的过程中会破坏掉稳定性。所以相同元素之间位置会发生改变。</li></ul></li></ul><h2 id="二-索引堆（Index-Heap）及优化"><a href="#二-索引堆（Index-Heap）及优化" class="headerlink" title="二. 索引堆（Index Heap）及优化"></a>二. 索引堆（Index Heap）及优化</h2><p>下面依然将重点放到“堆”这个数据结构，以下将介绍一个相比普通的堆更加高级的数据结构——索引堆。</p><h4 id="1-引出问题"><a href="#1-引出问题" class="headerlink" title="1. 引出问题"></a>1. 引出问题</h4><p>首先来分析一下普通的堆有什么问题，才会进而衍生出索引堆：</p><p><img src="/posts/31650/3.png" alt="图片"><br>重点查看以上举例证明一个数组实现堆后元素的变换，可是在构建堆的过程中有局限性：</p><ul><li>如果元素是非常复杂的结构，例如字符串（一篇十万字的文章）等等，这样交换的代价是十分大的。不过这可以通过一些基本手段解决，</li><li>更加致命的是元素在数组中的位置发生改变，使得在堆中很难索引到它！例如元素下标是任务ID，元素值是优先级别。当将数组构建成堆后，下标发生改变，则意味着两者无法产生联系！在原来数组中寻找任务只需O(1)，但是构建成堆后元素位置发生改变后需要遍历数组！所以才会引入“索引堆”这个概念。</li></ul><h4 id="2-结构思想"><a href="#2-结构思想" class="headerlink" title="2. 结构思想"></a>2. 结构思想</h4><ul><li><p>当将此数组构建成堆之前：<strong>对于索引堆来说将数据和索引两部分内容分开存储，而真正表示堆的数组是由索引构建成的，如下图，每一个节点旁标记的是索引1,2,3……</strong></p></li><li><p>当将此数组构建成堆之后：data部分并未发生改变，真正改变的是索引index，index数组发生改变形成堆。<strong>index为10，即真正元素值去找索引10代表的data值62，这样去对应。</strong></p></li></ul><p><img src="/posts/31650/4.png" alt="图片"></p><p>使用“索引堆”有以下两个好处：</p><ul><li>将数组构建成堆之后，只是索引index值发生改变，int型数字之间的交换而不会涉及到data数据类型，提供交换效率。</li><li>重要的一点，如果想对堆中数据进行操作，例如对index为7的数据进行修改，找到对应数据值为28更改，<strong>在修改之后需要继续维护“堆”的性质，这时只需对data数组进行维护即可。</strong></li></ul><p>其实“索引堆”和之前堆的思路类似，<strong>只是在做元素值比较时是比较data数组，而做元素交换时修改的是索引值。</strong></p><h4 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h4><p><strong>（1）基本更改</strong></p><p>在原先MaxHeap基础上修改即可，首先改名为IndexMaxHeap（完整代码请查看github上源码，这里只提供重点部分）：</p><ul><li>在成员变量中需要添加一个数组来存储索引值</li><li>在构造函数中需要开辟索引数组空间</li><li>在析构桉树中也要相信释放掉该空间</li></ul><p><strong>（2）插入和删除函数</strong><br>重点需要修改插入和删除函数：</p><ul><li>插入函数：在调用插入函数时不仅要传数据还要传递索引值。<strong>注意：这里获取data数组的索引值是根据index数组来确定的！在shiftUp函数中交换的是index索引值，并非是data数组。</strong></li></ul><pre class="line-numbers language-C++"><code class="language-C++">    // 索引堆中, 数据之间的比较根据data的大小进行比较, 但实际操作的是索引    void shiftUp( int k ){        while( k > 1 && data[indexes[k/2]] < data[indexes[k]] ){            swap( indexes[k/2] , indexes[k] );            k /= 2;        }    }    // 向最大索引堆中插入一个新的元素, 新元素的索引为i, 元素为item    // 传入的i对用户而言,是从0索引的    void insert(int i, Item item){        assert( count + 1 <= capacity );        assert( i + 1 >= 1 && i + 1 <= capacity );        i += 1;        data[i] = item;        indexes[count+1] = i;        count++;        shiftUp(count);    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>删除函数：</li></ul><pre class="line-numbers language-C++"><code class="language-C++">    // 索引堆中, 数据之间的比较根据data的大小进行比较, 但实际操作的是索引    void shiftDown( int k ){        while( 2*k <= count ){            int j = 2*k;            if( j + 1 <= count && data[indexes[j+1]] > data[indexes[j]] )                j += 1;            if( data[indexes[k]] >= data[indexes[j]] )                break;            swap( indexes[k] , indexes[j] );            k = j;        }    }    // 从最大索引堆中取出堆顶元素, 即索引堆中所存储的最大数据    Item extractMax(){        assert( count > 0 );        //注意：这里获取data数组的索引值是根据index数组来确定的        Item ret = data[indexes[1]];        swap( indexes[1] , indexes[count] );        count--;        shiftDown(1);        return ret;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>（3）更改函数</strong></p><p>在第一点“引出问题”中提到一个问题，就是二叉堆中的某个节点的元素值可能会被改变，（实际应用中：OS中任务的优先级会动态改变）所以提供一个方法仅供修改元素值。</p><p><strong>注意：修改元素值后必然还要维护索引堆的特性，所以该元素的值位置可能会有所改变，具体操作也简单，只需分别调用shiftUp、shiftDown方法即可找到合适位置。</strong></p><pre class="line-numbers language-C++"><code class="language-C++">   // 将最大索引堆中索引为i的元素修改为newItem    void change( int i , Item newItem ){        i += 1;        data[i] = newItem;        // 找到indexes[j] = i, j表示data[i]在堆中的位置        // 之后shiftUp(j), 再shiftDown(j)        for( int j = 1 ; j <= count ; j ++ )            if( indexes[j] == i ){                shiftUp(j);                shiftDown(j);                return;            }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-反向查找优化-——-更改元素值"><a href="#4-反向查找优化-——-更改元素值" class="headerlink" title="4. 反向查找优化 —— 更改元素值"></a>4. 反向查找优化 —— 更改元素值</h4><p><strong>（1）引出问题</strong><br><img src="/posts/31650/5.png" alt="图片"><br>举个例子，如上图，若用户要更改下标4所指向元素的数据，将此数据更爱以后需要维护index数组，此数组本质上是一个堆，其中存储的元素对应着上一层索引。</p><p>所以需要做的是在index数组中找到4的位置，在下标9指向的位置，上一点的实现方法是顺序遍历查找下标9的位置，4指向的data是13，<strong>然后调用shiftUp、shiftDown方法维护二叉堆特征，这样过程的时间复杂度为O(n)级别。</strong></p><p><strong>（2）思想</strong><br>其实对于以上更改元素值思想还有可以优化的地方，此种思想非常经典，被称为“反向查找”，查看下图：<br><img src="/posts/31650/6.png" alt="图片"></p><p>可以看到，多了一行数组rev，rev[i]代表i这个索引在堆中的位置。举个例子，将下标4的data13修改了，接着需要维护索引4在堆中的位置，即维护index数组，怎么找到下标4在堆中的位置？</p><p><strong>查看rev数组，rev数组中对应的是9，所以在index数组中第9个位置存储的索引4。</strong></p><p>rev数组相关性质:</p><p>这样一来只需维护rev数组，在进行元素更新时所耗时间复杂度为O(1)，来了解rev数组相关性质：<br><img src="/posts/31650/7.png" alt="图片"></p><p><strong>（3）代码实现</strong></p><p>如此一来引入了rev数组，就需要在insert、shiftUp、extractMax、shiftDown函数中进行维护，重点代码如下：</p><pre class="line-numbers language-c++"><code class="language-c++">Class{    int *reverse;   // 最大索引堆中的反向索引, reverse[i] = x 表示索引i在x的位置    // 索引堆中, 数据之间的比较根据data的大小进行比较, 但实际操作的是索引    void shiftUp( int k ){        while( k > 1 && data[indexes[k/2]] < data[indexes[k]] ){            swap( indexes[k/2] , indexes[k] );            reverse[indexes[k/2]] = k/2;            reverse[indexes[k]] = k;            k /= 2;        }    }    // 索引堆中, 数据之间的比较根据data的大小进行比较, 但实际操作的是索引    void shiftDown( int k ){        while( 2*k <= count ){            int j = 2*k;            if( j + 1 <= count && data[indexes[j+1]] > data[indexes[j]] )                j += 1;            if( data[indexes[k]] >= data[indexes[j]] )                break;            swap( indexes[k] , indexes[j] );            reverse[indexes[k]] = k;            reverse[indexes[j]] = j;            k = j;        }    }   // 向最大索引堆中插入一个新的元素, 新元素的索引为i, 元素为item    // 传入的i对用户而言,是从0索引的    void insert(int i, Item item){        assert( count + 1 <= capacity );        assert( i + 1 >= 1 && i + 1 <= capacity );        // 再插入一个新元素前,还需要保证索引i所在的位置是没有元素的。        assert( !contain(i) );        i += 1;        data[i] = item;        indexes[count+1] = i;        reverse[i] = count+1;        count++;        shiftUp(count);    }    // 从最大索引堆中取出堆顶元素, 即索引堆中所存储的最大数据    Item extractMax(){        assert( count > 0 );        Item ret = data[indexes[1]];        swap( indexes[1] , indexes[count] );        reverse[indexes[count]] = 0;        reverse[indexes[1]] = 1;        count--;        shiftDown(1);        return ret;    }    // 将最大索引堆中索引为i的元素修改为newItem    void change( int i , Item newItem ){        assert( contain(i) );        i += 1;        data[i] = newItem;        // 有了 reverse 之后,        // 我们可以非常简单的通过reverse直接定位索引i在indexes中的位置        shiftUp( reverse[i] );        shiftDown( reverse[i] );    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五-堆衍生的问题"><a href="#五-堆衍生的问题" class="headerlink" title="五. 堆衍生的问题"></a>五. 堆衍生的问题</h2><h4 id="1-使用堆实现优先队列"><a href="#1-使用堆实现优先队列" class="headerlink" title="1. 使用堆实现优先队列"></a>1. 使用堆实现优先队列</h4><p><strong>在N个元素中选出前M个元素</strong><br>例如在1,000,000个元素中选出前100名，也就是“在N个元素中选出前M个元素”。</p><p>按照之前学习的一些排序算法，性能最优可达到O(n* logn )<strong>但是使用了优先队列，可将时间复杂度从O(n *logn )降低为O(n *logM)</strong>！（若N是百万级别数字，其实这优化的不少）使用一个最小堆，使长度维护在100，将前100个元素放入最小堆之后再插入新的元素，此时只会将堆中最小元素移出去，堆的长度不变，将这1,000,000个元素遍历完后，最小堆中存放的100个元素就是前100名，因为比其小的元素全都请了出去。</p><h4 id="2-多路归并排序"><a href="#2-多路归并排序" class="headerlink" title="2. 多路归并排序"></a>2. 多路归并排序</h4><p>可以使用堆来完成多路归并排序，首先思考归并排序思想，是将数组一分为二，两个子数组分别排序后进行归并，每次归并的过程只有两个子数组元素比较，如下图：<br><img src="/posts/31650/8.png" alt="图片"><br>其实在归并排序过程中可以一次分成多个（大于2，这里是4）子数组，再进行归并，每次比较4个元素的大小关系，理所当然想到逐个元素比较，<strong>但是可以将这4个元素放入堆中，再逐个取出来，取出来的元素属于哪个子数组，再添加这个子数组的下一个元素进入堆中，来维护这个堆。</strong></p><h4 id="3-d叉堆"><a href="#3-d叉堆" class="headerlink" title="3. d叉堆"></a>3. d叉堆</h4><p>此部分主要讲解的是二叉堆，即每个节点最多有两个孩子，其实还有一种思想——d叉堆，下图是三叉堆，依然满足堆的特征。其中d越大，层数越少，同样在Shift Up、Shift Down时比较的次数增多，所以对于这个d的数量，也是性能之间的衡量。（二叉堆是最经典的）<br><img src="/posts/31650/9.png" alt="图片"></p><h4 id="4-堆的实现细节优化"><a href="#4-堆的实现细节优化" class="headerlink" title="4. 堆的实现细节优化"></a>4. 堆的实现细节优化</h4><p>这里这位读者提供对细节优化的思路，切身去体会算法的“优化”，堆的实现细节优化还有：</p><ul><li>ShiftUp 和 ShiftDown 中使用赋值操作替换swap操作</li><li>表示堆的数组从0开始索引</li><li>没有capacity的限制，动态的调整堆中数组的大小</li></ul><h4 id="5-其它"><a href="#5-其它" class="headerlink" title="5. 其它"></a>5. 其它</h4><p>此篇博文主要讲解的是最大堆 和 最大索引堆，与之相对应的还有最小堆、 最小索引堆，可自行查看源码实现。<strong>这其实也对应着最大、最小优先队列，这样的优先队列可轻易找到队列中最大或最小元素，那么是否可以设计一个“最大最小类”，能同时找到最大和最小数据？</strong></p><p>这里仅提供思路，其实可以在这个类中同时放一个最大堆和最小堆，两者维护同一组数据。</p><p>最后此篇文章重点讲解二叉堆和索引堆，但其实有关于堆还衍生出了二项堆和斐波那契堆，有兴趣可自行研究。</p><hr><p>所有以上解决算法详细代码请查看github：<a href="https://github.com/liuyubobobo/Play-with-Algorithms">https://github.com/liuyubobobo/Play-with-Algorithms</a></p><p>以上就是有关于堆的所有内容，堆其实就是一棵“数”，包括之前学习的有关O(n*logn)排序算法，虽然是在数组上进行排序，但是通过其算法使用的递归可画出“树”结构，可见“树”的重要性，下一篇将开始讲解</p><hr><p>转自：<a href="https://blog.csdn.net/ITermeng/article/details/77431945">https://blog.csdn.net/ITermeng/article/details/77431945</a></p>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Play-with-Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Play-with-Algorithms(4)：堆排序之 二叉堆（Heapify、原地堆排序优化）</title>
      <link href="posts/49310/"/>
      <url>posts/49310/</url>
      
        <content type="html"><![CDATA[<p>不同于前面几篇O(n^2)或O(n*logn)排序算法，此篇文章将讲解另一个排序算法——堆排序，也是此系列的第一个数据结构—–堆，需要注意的是在堆结构中排序是次要的，重要的是堆结构及衍生出来的数据结构问题，排序只是堆应用之一。</p><p>此篇涉及的知识点有：</p><ul><li>堆的基本存储</li><li>Shift Up和Shift Down</li><li>基础堆排序和Heapify</li><li>优化的堆排序</li></ul><a id="more"></a><h2 id="一-堆结构"><a href="#一-堆结构" class="headerlink" title="一. 堆结构"></a>一. 堆结构</h2><h4 id="1-优先队列"><a href="#1-优先队列" class="headerlink" title="1. 优先队列"></a>1. 优先队列</h4><p>首先来了解堆的经典应用—–优先队列，此概念并不陌生：</p><ul><li>普通队列：先进先出，后进后出。关键为由时间顺序决定出队顺序。</li><li>优先队列：出队顺序和入队顺序无关，和优先级相关。</li></ul><p><strong>优先队列在OS的使用</strong></p><p>而优先队列这种机制在计算机中被大量使用，最典型应用就是操作系统执行任务，它需要同时执行多个任务，而实际上是将CPU执行周期划分时间片，在时间片中执行一个任务，每一个任务都有优先级，<em>OS动态选择优先级最高的任务执行</em>，所以需要使用优先队列，所有任务进行优先队列，由队列来进行调度需要执行哪个任务。</p><p>为什么使用优先队列？</p><p>注意“动态”的重要性，如果任务是固定的话，可以将这些任务排序好安装优先级最高到最低依次执行，可是实际处理确要复杂得多。如下图：蓝色任务处理中心就类似CPU，由它来处理所有请求（红色代表Request）。<em>选择执行某个请求后，下一步不是简单地选择另一个请求执行，与此同时可能会来新的任务，不仅如此，旧的任务优先级可能会发生改变，所以将所有任务按优先级排序再依次执行是不现实的。</em></p><p>所以优先队列模型不仅适用于OS，更存在与生活中方方面面，例如大家同时请求某个网页，服务器端需要依次回应请求，回应的顺序通常是按照优先队列决定的。</p><p><img src="/posts/49310/1.png" alt="partition"></p><p><strong>优先队列处理“静态问题”</strong></p><p>前面一直在强调优先队列善于处理“动态”的情况，但其实对于“静态”也是十分擅长，例如在1,000,000个元素中选出前100名，也就是“在N个元素中选出前M个元素”。</p><p>在前三篇博文中学习了排序算法后，很快得到将所有元素排序，选出前M个元素即可，时间复杂度为O(n * logn)。 <strong>但是使用了优先队列，可将时间复杂度降低为O(n * logM)！</strong> 具体实现涉及到优先队列实现，后续介绍。</p><p>优先队列主要操作</p><ul><li>入队</li><li>出队（取出优先级最高的元素）</li></ul><p>优先队列采用的数据结构：</p><ul><li>数组：最简单的数据结构实现方式，有两种形式<ul><li>普通数组：入队直接插入数组最后一个位置，而取出优先级最高的元素需要扫描整个数组。</li><li>顺序数组： 维护数组有序性，入队时需要遍历数组找到合适位置，而出队时取出队头即可。</li></ul></li><li>堆：以上两种实现方式有其局限性，无法很好平衡出入对操作。而使用堆这种数据结构虽然出入队时是蛮于前两者的，但是平均而言维持优先队列完成系统任务所用时间大大低于使用数组。</li></ul><p>举个例子，对于总共N个请求：</p><ul><li>使用普通数组或者顺序数组，最差情况：O(n^2)</li><li>使用堆：O(nlgn)</li></ul><p><img src="/posts/49310/2.png" alt="图片"></p><h4 id="2-二叉堆（Binary-Heap）的基本存储"><a href="#2-二叉堆（Binary-Heap）的基本存储" class="headerlink" title="2. 二叉堆（Binary Heap）的基本存储"></a>2. 二叉堆（Binary Heap）的基本存储</h4><p>因此若要实现优先队列，必须采用堆数据结构，下面介绍堆有关知识及如何实现。</p><p><strong>（1）概念特征</strong><br>在以上了解堆中操作都是O(n *logn)级别，应当知道堆相应的是一种树形结构，其中最为经典的是二叉堆，类似于二叉树，每一个节点可以有两个子节点，特点：</p><ul><li><strong>在二叉树上任何一个子节点都不大于其父节点。</strong></li><li>必须是一棵完全的二叉树，即除了最后一层外，以上层数的节点都必须存在并且狐妖集中在左侧。</li></ul><p><img src="/posts/49310/3.png" alt="图片"></p><p>注意：<strong>第一个特征中说明在二叉树上任何一个子节点都不大于其父节点，并不意味着层数越高节点数越大，这都是相对父节点而言的。</strong> 例如第三层的19比第二层的16大。</p><p>这样的二叉堆又被称为“最大堆”，父节点总是比子节点大，同理而言“最小堆”中父节点总是比子节点小，这里只讲解“最大堆”。</p><p><strong>（2）结构实现</strong><br>对于其具体实现，熟悉树形结构的同学可能认为需要两个指针来实现左、右节点，当然可以这样实现，但是还有一个经典实现方式——通过数组实现，正是因为堆是一棵完全的二叉树。</p><p>将这棵二叉树自上到下、自左到右地给每一个节点标上一个序列号，如下图所示。<strong>对于每一个父节点而言：</strong></p><ul><li>它的左孩子序列号都是本身序列号的:2倍</li><li>它的右孩子序列号都是本身序列号的:2倍+1</li></ul><p>（这里的根节点下标是由1开始而得出以上规则，但其实由0开始也可得出相应的规则，此部分重点还是放在下标1开始）<br><img src="/posts/49310/4.png" alt="图片"></p><p><strong>（3）基本结构代码实现</strong></p><pre class="line-numbers language-C++"><code class="language-C++">template<typename Item>class MaxHeap{private:    Item *data;    int count;public:    // 构造函数, 构造一个空堆, 可容纳capacity个元素    MaxHeap(int capacity){        data = new Item[capacity+1];        count = 0;    }    ~MaxHeap(){        delete[] data;    }    // 返回堆中的元素个数    int size(){        return count;    }    // 返回一个布尔值, 表示堆中是否为空    bool isEmpty(){        return count == 0;    }};}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-二叉堆中的-Shift-Up-和-Shift-Down"><a href="#3-二叉堆中的-Shift-Up-和-Shift-Down" class="headerlink" title="3. 二叉堆中的 Shift Up 和 Shift Down"></a>3. 二叉堆中的 Shift Up 和 Shift Down</h4><p>在完成代码的二叉堆基本结构后，需要实现最重要的两个操作逻辑，即Shift Up 和 Shift Down。<br><strong>（1）Shift Up</strong><br>下面就实现在二叉堆中如何插入一个元素，即优先队列中“入队操作”。以下动画中需要插入元素52，由于二叉堆是用数组表示，所以相当于在数组末尾添加一个元素，相当于52是索引值11的元素。<br><strong>算法思想</strong><br> <strong>注意！其实整个逻辑思想完全依赖于二叉树的特征，因为在二叉堆上任何一个子节点都不大于其父节点，</strong> 所以需要将新插入的元素挪到合适位置来维护此特征：</p><ul><li>首先判断新加入的元素（先归到二叉堆中）和其父节点的大小,52比16小，所以交换位置。</li><li>52被换到一个新位置，再继续查看52是否大于其父节点，发现52比41大，继续交换。</li><li>再继续判断，52比62小，无须挪动位置，插入完成。</li></ul><p><img src="/posts/49310/1.gif" alt="图片"></p><p>代码实现</p><p>在MaxHeap中新增一个insert方法，传入新增元素在二叉堆中的下标</p><pre class="line-numbers language-C++"><code class="language-C++">    //将下标k的新增元素放入到二叉堆中合适位置    void shiftUp(int k){        while( k > 1 && data[k/2] < data[k] ){//边界&&循环与父节点比较            swap( data[k/2], data[k] );            k /= 2;        }    }    // 像最大堆中插入一个新的元素 item    void insert(Item item){        assert( count + 1 <= capacity );        data[count+1] = item;//注意下标是从1开始，所以新增元素插入位置为count+1，并非count        count ++;//数量增加1        shiftUp(count);    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：以上代码中严格需要注意边界问题，因为在创建MaxHeap已设置好数组个数MaxHeap<int> maxheap = MaxHeap<int>(100);，所以在上述insert中使用了assert函数来判断，若超过数组长度则不插入。其实这里有另外一种更好的解决方法，就是超过时动态增加数组长度</int></int></p><p><strong>（2）Shift Down</strong></p><p>上一部分讲解了如何从二叉堆中插入一个元素，此部分讲解如何取出一个元素，即优先队列中“出队操作”。</p><p>算法思想</p><ul><li>根据二叉堆的特征，其根节点值最大，<strong>所以直接获取下标1的元素</strong>，但是根节点值空缺处理，需要重新整理整个二叉树。</li><li>将数组中最后一个值替补到根节点，count数组总数量减1。<strong>因为在二叉堆上任何一个子节点都不大于其父节点。</strong> 所以需要调节根节点元素，相应的向下移，不同于Shift Up，它可以向左下移或右下移，这里采用的标准是跟元素值较大的孩子进行交换： <ul><li>根节点与16与52、30比较，将16和52进行交换。</li><li>将交换后的16与两个孩子28、41比较，与41交换。</li><li>交换后的16此时只有一个孩子15，比其大，无需交换。Shift Down过程完成。</li></ul></li></ul><p><img src="/posts/49310/2.gif" alt="图片"></p><p>代码实现:</p><pre class="line-numbers language-C++"><code class="language-C++">    void shiftDown(int k){        while( 2*k <= count ){            int j = 2*k; // 在此轮循环中,data[k]和data[j]交换位置            if( j+1 <= count && data[j+1] > data[j] )                j ++;            // data[j] 是 data[2*k]和data[2*k+1]中的最大值            if( data[k] >= data[j] ) break;            swap( data[k] , data[j] );            k = j;        }    }    // 从最大堆中取出堆顶元素, 即堆中所存储的最大数据    Item extractMax(){        assert( count > 0 );        Item ret = data[1];        swap( data[1] , data[count] );        count --;        shiftDown(1);        return ret;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二-二叉堆优化"><a href="#二-二叉堆优化" class="headerlink" title="二. 二叉堆优化"></a>二. 二叉堆优化</h2><h4 id="1-Heapify"><a href="#1-Heapify" class="headerlink" title="1. Heapify"></a>1. Heapify</h4><p>在学习以上二叉堆实现后，发现它同样可用于排序，不断调用二叉堆的extractMax方法，即可取出数据。（从大到小的顺序）</p><pre class="line-numbers language-C++"><code class="language-C++">// heapSort1, 将所有的元素依次添加到堆中, 在将所有元素从堆中依次取出来, 即完成了排序// 无论是创建堆的过程, 还是从堆中依次取出元素的过程, 时间复杂度均为O(nlogn)// 整个堆排序的整体时间复杂度为O(nlogn)template<typename T>void heapSort1(T arr[], int n){    MaxHeap<T> maxheap = MaxHeap<T>(n);    for( int i = 0 ; i < n ; i ++ )        maxheap.insert(arr[i]);    for( int i = n-1 ; i >= 0 ; i-- )        arr[i] = maxheap.extractMax();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>（1）测试</strong></p><p>所以以下将二叉堆和之前所学到的O(n*logn)排序算法比较测试，分别对</p><p>无序数组<br>近乎有序数组<br>包含大量重复值数组<br>以上3组测试用例进行时间比较，结果如下:</p><p><img src="/posts/49310/5.png" alt="图片"><br>虽然二叉堆排序使用的时间相较于其它排序算法要慢，但使用时间仍在接收范围内。因为整个堆排序的整体时间复杂度为O(nlogn) ，无论是创建堆的过程, 还是从堆中依次取出元素的过程, 时间复杂度均为O(nlogn)。总共循环n此，每次循环二叉树操作消耗O(logn)，所以最后是O(nlogn)。</p><p>但是还可以继续优化，使性能达到更优以上过程创建二叉堆的过程是一个个将元素插入，其实还有更好的方式——Heapify。</p><p><strong>（2）Heapify算法思想</strong></p><p>给定一个数组，使这个数组形成堆的形状，此过程名为Heapify。例如以下数组{15,17,19,13,22,16,28,30,41,62}：</p><p><img src="/posts/49310/6.png" alt="图片"></p><p>此数组形成的二叉树并非最大堆，不满足特征。但是上图中的叶子节点，即最后一层的每个节点可看作是一个最大堆（因为只有它一个节点）。接着再向上递进一层：</p><ul><li>由最后一个节点开始，考察父节点22是否大于孩子62，不满足则交换位置。这样这两个节点组成的子树满足最大堆特征。</li><li>再考虑父节点13是否大于孩子30、41，不满足则与最大值的孩子交换位置。</li><li>依次类推，其实思想与Shift Down相似。</li></ul><p><img src="/posts/49310/3.gif" alt="图片"></p><p>（3）代码实现</p><p>所以，此堆排序的优化就是<strong>修改其创建方法，不通过一个一个元素插入来创建二叉堆，而是通过Heapify方法来完成创建，此过程消耗的时间复杂度为O(n)，性能更优。</strong></p><p>需要修改MaxHeap中的构造函数，传入参数为无序的数组和数组长度，首先开辟空间，下标从1开始将数组元素值赋值到新数组中，再结合Shift Down方法层层递进。</p><pre class="line-numbers language-C++"><code class="language-C++">   // 构造函数, 通过一个给定数组创建一个最大堆    // 该构造堆的过程, 时间复杂度为O(n)    MaxHeap(Item arr[], int n){        data = new Item[n+1];        capacity = n;        for( int i = 0 ; i < n ; i ++ )            data[i+1] = arr[i];        count = n;        for( int i = count/2 ; i >= 1 ; i -- )            shiftDown(i);    }template<typename T>void heapSort2(T arr[], int n){    //优化后的创建二叉堆构造函数    MaxHeap<T> maxheap = MaxHeap<T>(arr,n);    for( int i = n-1 ; i >= 0 ; i-- )        arr[i] = maxheap.extractMax();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（4）测试</p><p>通过优化后的创建二叉堆构造函数再次测试，结果如下：<br><img src="/posts/49310/7.png" alt="图片"></p><p>结论</p><p>将n个元素逐个插入到一个空堆中，算法复杂度是O(nlogn)，而使用Heapify的过程，算法复杂度为O(n)</p><h4 id="2-原地堆排序"><a href="#2-原地堆排序" class="headerlink" title="2. 原地堆排序"></a>2. 原地堆排序</h4><p>不同于其他排序算法，在堆排序中需要将数组元素放入“堆”中，需要开辟新的数组，相当于开了额外的O(n)空间，其实可以继续优化不适用空间原地对元素进行排序。</p><p>引出第二个优化 —— 原地堆排序，事实上，按照堆排序的思想，可以原地进行排序，不需要任何额外空间。</p><p><strong>算法思想</strong></p><p>其思想也很简单，通过之前构造堆这个类的过程已知一个数组可以看成是队列。因此将一个数组构造“最大堆”：</p><ul><li>其第一个元素v就是根节点（最大值），在具体排序过程中最大值应在末尾位置w，将两个值互换位置，此时最大值v在数组末尾。</li><li>那么此时包含w在内的橘黄色部分就不是最大堆了，将w位置的值进行Shift Down操作。</li><li>橘黄色部分再次成为“最大堆”，最大值仍在第一个位置，那堆末尾的元素（即倒数第二个位置）与第一个元素交换位置，再进行Shift Down操作。</li><li>依次类推<br><img src="/posts/49310/4.gif" alt="图片"></li></ul><p>这样所有的元素逐渐排序好，直到整个数组都变成蓝色。使用的空间复杂度是O(1)，但是这里需要注意的是，如此一来下标是从0开始并非1，所以规则需要进行相应的调整：<br><img src="/posts/49310/8.png" alt="图片"></p><p>代码实现</p><pre class="line-numbers language-C++"><code class="language-C++">// 优化的shiftDown过程, 使用赋值的方式取代不断的swap,// 该优化思想和我们之前对插入排序进行优化的思路是一致的template<typename T>void __shiftDown2(T arr[], int n, int k){    T e = arr[k];    while( 2*k+1 < n ){        int j = 2*k+1;        if( j+1 < n && arr[j+1] > arr[j] )            j += 1;        if( e >= arr[j] ) break;        arr[k] = arr[j];        k = j;    }    arr[k] = e;}// 不使用一个额外的最大堆, 直接在原数组上进行原地的堆排序template<typename T>void heapSort(T arr[], int n){    // 注意，此时我们的堆是从0开始索引的,因为是原地排序    // 从(最后一个元素的索引-1)/2开始    // 最后一个元素的索引 = n-1    for( int i = (n-1-1)/2 ; i >= 0 ; i -- )        __shiftDown2(arr, n, i);    for( int i = n-1; i > 0 ; i-- ){        swap( arr[0] , arr[i] );        __shiftDown2(arr, i, 0);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试：</p><p>分别测试原始Shift Down堆排序 和 Heapify堆排序 和 原地堆排序的时间消耗。<br><img src="/posts/49310/9.png" alt="图片"></p><p>从结构得知优化后的原地堆排序快于之前原始Shift Down堆排序和Heapify堆排序，因为新的算法不需要额外的空间，也不需要对这些空间赋值，所以性能有所提高。</p><p>前三篇博文介绍的排序算法及以上讲解完的堆排序完成，意味着有关排序算法已讲解完毕，下面篇博文对这些排序算法进行比较总结，并且学习另一个经典的堆结构，处于二叉堆优化之上的索引堆。</p><p>转自：<a href="https://blog.csdn.net/ITermeng/article/details/77480102">https://blog.csdn.net/ITermeng/article/details/77480102</a></p>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Play-with-Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Play-with-Algorithms(3)：O(n*logn)排序算法之 快速排序（随机化、二路、三路排序） 及衍生算法</title>
      <link href="posts/2307/"/>
      <url>posts/2307/</url>
      
        <content type="html"><![CDATA[<p>在上一篇博文中学习了时间复杂度为 O(n<em>logn) 的归并算法，介绍其两种实现方式——自顶向下和自底向上，不同于O(n^2)排序算法，O(n *logn)在处理百万级数据量上有明显的性能优势。而此篇文章将介绍具有代表性O(n *logn)的另一种算法—— *</em>快速排序，其性能总体还会优于归并排序，但是在最坏情况下时间复杂度会退化为O(n^2)！继而出现了对快速排序的系列优化并衍生出新的实现方式，来一探究竟。**</p><p>此篇博文涉及的知识点如下：</p><ul><li>快速排序法</li><li>随机化快速排序法</li><li>双路快速排序法</li><li>三路快速排序法</li><li>归并排序和快速排序的衍生问题</li></ul><a id="more"></a><h2 id="一-快速排序（Quick-Sort）"><a href="#一-快速排序（Quick-Sort）" class="headerlink" title="一. 快速排序（Quick Sort）"></a>一. 快速排序（Quick Sort）</h2><h4 id="1-算法思想"><a href="#1-算法思想" class="headerlink" title="1. 算法思想"></a>1. 算法思想</h4><p><strong>（1）整体过程</strong></p><p>首先来回顾一下上篇博文讲解的归并排序重点思想：不论数组排序内容，直接一分为二再逐渐归并排序。而<strong>快速排序：</strong></p><ul><li>则每次从当前考虑的数组中选择一个元素，以这个元素为基点，进行处理将此基点放到数组中的合适位置，使得左边的其它元素比此元素小，右边的其它元素比此元素大。</li><li>之后对左、右边这2个子数组分别使用快速排序的思路进行排序，逐渐递归下去完成整个排序过程。</li></ul><p>以下数组{4,6,2,3,1,5,7}为例，选择4为基点，将4放到合适位置，使得4之前的所以元素小于4，后面的所有元素大于4。<br><img src="/posts/2307/1.gif" alt="partition"></p><p><strong>（2）Partition过程</strong><br>对于快速排序过程而言，最重要的是将数组分成两个部分，使得基点元素在分界点。此过程为快速排序的核心，通常称为 Partition，以下动画演示了此过程：</p><ul><li>通常使用数组的第一个元素来作为分界的标志点（基点），记为l（left）</li><li>之后逐渐遍历右边所有未被访问元素</li><li>在遍历的过程中逐渐整理让整个数组左部分小于 v 这个元素值，右部分大于 v。</li><li>在此过程中，用j 来记录左右部分的分界点，当前访问的元素记为 i 。这样整个数组中 arr[l+1……j ] &lt; v，arr[j+1……i-1] &gt;v</li></ul><p>接下来讨论 i 这个元素（即当前访问的元素 e）如何变化才能使整个数组保证 v 的左右两部分刚好代表小于、大于v的位于两侧：</p><ul><li><strong>当 e &gt; v</strong>时：直接将 e 放到大于v右部分的后面，下标i ++，继续判断下一个元素。</li><li><strong>当 e &lt; v</strong>时：需要将e放到橘黄色部分（也就是v的左部分），这时只需要将j所指的最后一个元素与 e进行交换，也就是一个大于v的元素与e进行交换下标j++，代表 橘黄色部分元素新增了一个，再进行i ++，继续判断下一个元素。</li></ul><p><img src="/posts/2307/2.gif" alt="partitiongif"></p><p><strong>最终结果</strong></p><p><img src="/posts/2307/1.png" alt="end"></p><p>经过以上部分对数组进行遍历，完成后就是上图所示，第一个元素是 v ，橘黄色部分小于 v ，紫色部分大于 v ，最后只需要将l下标和j 下标所指的元素交换位置即可。</p><p><strong>整个数组被分成小于v 和大于 v的两部分，而v也放到了合适的位置，如下图所示：</strong></p><p><img src="/posts/2307/2.png" alt="position"></p><hr><h4 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h4><p>以上就是整个Partition的过程，理解透彻后可以轻松实现快速排序的逻辑代码。</p><p><strong>（1）quickSort函数</strong><br><em>目的：主函数中调用此方法即可（暴露给上层调用）</em></p><p>在函数quickSort中定义另一个函数__quickSort，取名代表它其实是一个私有的函数，被quickSort所调用，对于用户而言只需调用quickSort即可。</p><p><strong>（2）__quickSort函数</strong><br><em>目的：使用递归来进行快速排序,对arr[l…r]的范围进行快速排序</em></p><ul><li>首先进行边界判断（即递归到底的情况），若 l 大于或等于 r ，即可停止递归。</li><li>下面开始快速排序核心算法，首先需要调用一个新函数<strong>__partition对arr数组从l 到r 进行partition操作，此函数会返回一个索引值，该值就是arr数组被partition后分成左右两部分的中间分界点下标。</strong></li><li>获取到索引值后，则相当于将此数组分成左右两个部分（即左部分的所有元素值都小于索引值的元素值，右部分的所有元素则大于…），接下来使用递归分别对这两个子数组进行快速排序</li></ul><p><strong>（3）__partition函数</strong><br><em>目的：对arr[l…r]部分进行partition操作，返回p, 使得arr[l…p-1] &lt; arr[p] ; arr[p+1…r] &gt; arr[p]</em></p><p>此函数需要进行的逻辑操作在上一点partition过程思想中已详细讲解，来查看具体实现：</p><ul><li>在快速排序中需要一个标准值来作判断，这里默认为第一个值l ，用临时变量v 记录其元素值。</li><li>通过循环，从l + 1开始遍历整个数组，让整个数组在此循环之后分成两个部分，即arr[l+1…j] &lt; v ; arr[j+1…i) &gt; v。判断当前元素是否大于v<ul><li>当前元素大于v：无需处理，判断下一个元素即可。</li><li>当前元素小于v：需要进行交换操作，交换arr[j+1]和当前元素的值。在循环开始下标j被赋值为l下标，所以j-l代表小于v的元素总数，j+1相当于小于v的元素总数新增一个。</li></ul></li><li>循环结束后，除了第一个元素外，整个数组已经按照第一个元素值为标准，分成了左右两个部分， 即arr[l+1…j] &lt; v ; arr[j+1…i) &gt; v。最后将l 与 j下标的元素交换，因为下一次快速排序还是会以函数中的参数 l 值（即第一个元素）为标准，所以此时应该交换：j下标位置元素值为v，而l 下标的值为小于 v 的一个函数。</li><li>最后返回j 下标，这个下标使得整个数组情况（j相当于p）：arr[l…p-1] &lt; arr[p] ; arr[p+1…r] &gt; arr[p]</li></ul><p>代码为：</p><pre class="line-numbers language-C++"><code class="language-C++">// 对arr[l...r]部分进行partition操作// 返回p, 使得arr[l...p-1] < arr[p] ; arr[p+1...r] > arr[p]template <typename T>int __partition(T arr[], int l, int r){    T v = arr[l];    int j = l; // arr[l+1...j] < v ; arr[j+1...i) > v    for( int i = l + 1 ; i <= r ; i ++ )        if( arr[i] < v ){            j ++;            swap( arr[j] , arr[i] );        }    swap( arr[l] , arr[j]);    return j;}// 对arr[l...r]部分进行快速排序template <typename T>void __quickSort(T arr[], int l, int r){    if( l >= r )        return;    int p = __partition(arr, l, r);    __quickSort(arr, l, p-1 );    __quickSort(arr, p+1, r);}template <typename T>void quickSort(T arr[], int n){    __quickSort(arr, 0, n-1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-比较Merge-Sort和Quick-Sort两种排序算法的性能效率"><a href="#3-比较Merge-Sort和Quick-Sort两种排序算法的性能效率" class="headerlink" title="3. 比较Merge Sort和Quick Sort两种排序算法的性能效率"></a>3. 比较Merge Sort和Quick Sort两种排序算法的性能效率</h4><pre class="line-numbers language-C++"><code class="language-C++">int main() {    int n = 100000;    // 测试1 一般性测试    cout<<"Test for random array, size = "<<n<<", random range [0, "<<n<<"]"<<endl;    int* arr1 = SortTestHelper::generateRandomArray(n,0,n);    int* arr2 = SortTestHelper::copyIntArray(arr1,n);    SortTestHelper::testSort("Merge Sort", mergeSort, arr1, n);    SortTestHelper::testSort("Quick Sort", quickSort, arr2, n);    delete[] arr1;    delete[] arr2;    cout<<endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/2307/3.png" alt="result"></p><p>总结:</p><p><strong>两种排序算法虽然都是O(nlogn)级别的, 但是快速排序（Quick Sort）算法有常数级的优势，比归并排序（Merge Sort） 快，即使已经对  **归并排序</strong>  进行了优化。**</p><h4 id="4-代码优化"><a href="#4-代码优化" class="headerlink" title="4. 代码优化"></a>4. 代码优化</h4><p>熟悉套路的都知道接下来对快速排序进行代码优化，这里主要优化两个部分：</p><p><strong>（1）优化一：</strong><br>在详细学习了上篇博文归并排序讲解后，此点优化并不陌生，那就是<strong>高级的排序算法在底层时可使用插入排序（Insertion Sort）优化快速排序——递归到底优化：</strong>__quickSort函数中的第一个判断是当只剩下一个元素时才返回，事实上当方法递归到元素较少时，可使用插入排序来提高性能，由以下两个原因：</p><ul><li>当待排序的数组元素较少时，<strong>近乎有序的情况概率较大，此时插入排序有优势。</strong></li><li>虽然插入排序的时间复杂度是O(n^2)级别，而归并排序是O(n<em>logn)，*</em>但是别忽视这两者都依赖于常数系数n，当n较小时，插入排序是稍快于归并排序的**</li></ul><p>所以优化一：函数一开始判断当递归到底只剩下一定值时（可自行修改，不要过大，这里设定为15）时，剩下的数组采用插入算法进行排序</p><p><strong>（2）优化二:</strong></p><p>此优化才是快速排序的<strong>重点问题</strong>，首先引出其问题再做一组测试用例，就是归并排序和快速排序对近乎有序的数组进行排序<br>结果如下：<br><img src="/posts/2307/4.png" alt="result"></p><p>查看第二个测试用例结果，发现两种排序在对近乎有序的数组情况时，归并排序很快得出了结果，但是快速排序迟迟未出现结果（最后需要几十秒）！<br><strong>原因分析</strong></p><p>归并排序之所以是一个O(n* logn)的算法，在每次排序的时候都将数组一分为二，这样依次类推下去，整个层数是 logn层，每一层排序消耗O(n)时间，最后时间复杂度为O(n * logn)，如下图所示：</p><p><img src="/posts/2307/5.png" alt="reason"></p><p>对于快速排序而言，也是这样将整个数据一分为二，层层递进下去，只是稍有不同的是需要找到一个标志点，将此点左、右部分的数组进行分别排序。<strong>这样快速排序与归并排序产生不同：归并排序每次都是平均地将整个数组一分为二，而对于快速排序就无法保证，分出来的子数组可能是一大一小情况，进而再次递归时，情况会更严重。（如下图所示：）</strong><br><img src="/posts/2307/6.png" alt="reason2"><br>快速排序最差情况，退化为O(n^2)</p><p>因此快速排序生成的递归树的平衡度比归并排序要差，并且并不难保证树的高度是logn，甚至于高过logn。<strong>最差的情况就是当整个数组近乎有序的情况，生成的递归树如下图所示，每次作为标志点的第一个元素左部分并无小于它的元素（因为是近乎有序数组），从而导致递归树层级很高，到达n层，每一层又消耗O(n)，此时最终时间复杂度为O(n^2)</strong><br><img src="/posts/2307/7.png" alt="reason3"></p><p>解决优化:<br>以上也就是为何快速排序在面对近乎有序数组的情况下性能慢的原因，而解决方法正是对快速排序的第二个优化：<strong>在原有快速排序中，是固定使用最左侧元素作为标志元素，而希望是尽可能地使用整个数组中间的元素，也许不能准确地定位此中间元素。</strong><br><strong>优化二：其实只要随机使用一个标志元素即可，此时快速排序的时间复杂度期望值是O(n*logn)，此时退化成O(n^2)的概率是很小的，因为正好选到最小值作为标志元素的概率是很小的。（第一次选中最小值作为标志点的概率是1/n，第二次是1/(n-1)，依次类推，最后相乘得到结果近乎于0）</strong></p><p>代码如下：</p><pre class="line-numbers language-C++"><code class="language-C++">// 对arr[l...r]部分进行partition操作// 返回p, 使得arr[l...p-1] < arr[p] ; arr[p+1...r] > arr[p]template <typename T>int _partition(T arr[], int l, int r){    // ☆☆☆☆☆ 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot    swap( arr[l] , arr[rand()%(r-l+1)+l] );    T v = arr[l];    int j = l;    for( int i = l + 1 ; i <= r ; i ++ )        if( arr[i] < v ){            j ++;            swap( arr[j] , arr[i] );        }    swap( arr[l] , arr[j]);    return j;}// 对arr[l...r]部分进行快速排序template <typename T>void _quickSort(T arr[], int l, int r){    // 对于小规模数组, 使用插入排序进行优化    if( r - l <= 15 ){        insertionSort(arr,l,r);        return;    }    int p = _partition(arr, l, r);    _quickSort(arr, l, p-1 );    _quickSort(arr, p+1, r);}template <typename T>void quickSort(T arr[], int n){    //设置随机种子    srand(time(NULL));    _quickSort(arr, 0, n-1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优化后的测试<br><img src="/posts/2307/8.png" alt="result4"><br>最后在优化后发现快速排序的性能已经极高地提升起来了，虽然没有快过归并排序，因为归并排序中的第二个优化，在已经排好序的数组中不用再次递归调用了。<strong>但也只是在近乎有序数组的情况下，这里快速排序结合随机算法进行了优化，在大部分情况下性能还是更优的。（此时快速排序的时间复杂度在最坏情况下仍是O(n^2)，但是此概率是极其极其低，近乎为0）</strong></p><h2 id="二-双路快速排序法（Quick-Sort-2-Ways）"><a href="#二-双路快速排序法（Quick-Sort-2-Ways）" class="headerlink" title="二. 双路快速排序法（Quick Sort 2 Ways）"></a>二. 双路快速排序法（Quick Sort 2 Ways）</h2><h4 id="1-快速排序问题"><a href="#1-快速排序问题" class="headerlink" title="1. 快速排序问题"></a>1. 快速排序问题</h4><p><strong>(1）包含大量相同元素的数组测试</strong></p><p>经过上面的优化过程，快速排序算法已是非常稳健了，但是它仍然存在一些问题：再测试一组特殊实例情况，对存在包含大量相同元素的数组（0~10范围内50万个数）进行排序，结果如下。<br><img src="/posts/2307/9.png" alt="result5"></p><p><strong>（2）分析</strong><br><img src="/posts/2307/10.png" alt="result6"><br>上图部分并不陌生，是快速排序的核心部分，即Partition过程，判断当前元素e是否大于v，根据结果放入橘黄色部分或紫色部分。<strong>但是这里有一个隐患，我们并没有判断等于的情况！</strong></p><p>第一反应你可能觉得这很好解决，至于要把相等的部分放入左、右任何一部分即可，数组中含有大量重复元素，<strong>这样会把数组分成极度不平衡的两个部分，在这种情况下快速排序会退化成O(n^2)，结果如下图所示：</strong><br><img src="/posts/2307/11.png" alt="result7"></p><h4 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h4><p>意识到以上问题后，主要需要解决的还是Partition过程，于是我们换一个思路来实现Partition过程，查看以下动画：</p><p>之前快速排序中的Partition过程是将小于v 和大于 v 的两部分放在一起，然后从左到右逐渐遍历整个数组。<strong>现在将这两部分放到数组的两端，下标i、j分别进行扫码：</strong></p><ul><li>从下标 i这个位置向后扫描，<ul><li>当扫描的元素e小于v ：则继续向后扫描。</li><li>当扫描的元素e大于v：</li></ul></li><li>从下标 j这个位置向前扫描，<ul><li>当扫描的元素e大于v ：则继续向前扫描。</li><li>当扫描的元素e小于v：</li></ul></li></ul><p>以上两个下标进行扫码时，有一种情况没有写，<strong>其实就是当下标 i扫描的元素大于v，下标 j扫描的元素小于v时，将两个下标所指的元素值交换即可！</strong><br>最后，当下标i 等于下标j 时，扫描结束。将l 和 j下标所代表的元素交换位置即可。<br><img src="/posts/2307/3.gif" alt="2way"><br>最终结果：<br><img src="/posts/2307/12.png" alt="result8"><br>以上就是Partition后的结果，查看此图你会发现怎么橘黄色部分和紫色部分都含有等于v的元素，这范围设置的是否不对？<strong>其实不然！此种双路快速排序法与之前最大的区别就是：把等于v的元素分散到左右两部分。当下标i、j指向的元素即使与v相等，也要互相交换位置。这样可避免大量等于v的元素集中在一部分，正因如此，这样的算法面临大量重复元素值的情况下，也可以很好的平衡两部分。</strong></p><h4 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h4><p>这里只修改partition函数即可，代码如下：</p><pre class="line-numbers language-C++"><code class="language-C++">【只修改partition函数即可】// 双路快速排序的partition// 返回p, 使得arr[l...p-1] < arr[p] ; arr[p+1...r] > arr[p]template <typename T>int _partition2(T arr[], int l, int r){    // 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot    swap( arr[l] , arr[rand()%(r-l+1)+l] );    T v = arr[l];    // arr[l+1...i) <= v; arr(j...r] >= v    int i = l+1, j = r;    while( true ){        // 注意这里的边界, arr[i] < v, 不能是arr[i] <= v，因为会导致两部分数量不平衡        while( i <= r && arr[i] < v )            i ++;        // 注意这里的边界, arr[j] > v, 不能是arr[j] >= v        while( j >= l+1 && arr[j] > v )            j --;        if( i > j )            break;        swap( arr[i] , arr[j] );        i ++;        j --;    }    swap( arr[l] , arr[j]);    return j;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意<br>以上代码中的重点，也就是<strong>双路快速排序法</strong>的重点，就是判断下标i、j增减的条件边界，之前反复强调的重点就是将重复值平均分配到数组中的两个部分，所以边界判断只能是&lt; 或 &gt;，而不是&lt;= 或&gt;=。<br>下面举个例子来体会，数组 1,0,0, …, 0, 0：</p><ul><li>对于arr[i]&lt; v和arr[j]&gt;v的方式，第一次partition得到的分点是数组中间；</li><li>对于arr[i]&lt;=v和arr[j]&gt;=v的方式，第一次partition得到的分点是数组的倒数第二个。</li></ul><p>因为连续出现相等的情况，第一种会交换i和j的值，而第二种方式则会将连续出现的这些值归为其中一方，使得两棵子树不平衡，这样会导致O(n^2)出现。</p><h4 id="4-测试结果"><a href="#4-测试结果" class="headerlink" title="4. 测试结果"></a>4. 测试结果</h4><p>再次进行测试（测试代码见源码）：<br><img src="/posts/2307/13.png" alt="result9"></p><h2 id="三-三路快速排序法（Quick-Sort-3-Ways）"><a href="#三-三路快速排序法（Quick-Sort-3-Ways）" class="headerlink" title="三. 三路快速排序法（Quick Sort 3 Ways）"></a>三. 三路快速排序法（Quick Sort 3 Ways）</h2><p>以上在面临数组中包含大量重复值排序时，对会沦为O(n^2)的排序算法进行优化，从而避免并更好的提高了其性能，但其实针对快速排序算法还有一个更经典的方法 —– <strong>三路快速排序法</strong></p><h4 id="1-算法思路"><a href="#1-算法思路" class="headerlink" title="1. 算法思路"></a>1. 算法思路</h4><p>在之前进行快速排序时都是将整个数组分成两部分，即小于v 和大于v（两部分都含有等于v的元素值），而三路快速排序法则是多加了一部分—–等于v，将这一部分单独提出来。查看以下动画，这样划分之后，在处理等于v的元素可不管，而是处理小、大于v的元素即可。</p><p>三部分下标划分表示:</p><ul><li>小于v 部分：使用下标 lt （less than）指向小于v数组部分的最后一个位置，这样arr[l+1…lt]&lt;v：</li><li>大于v 部分：使用下标gt （great than）指向大于v数组部分的第一个位置，这样arr[gt…r] &gt; v</li><li>等于v 部分：下标i 指向当前判断的元素下标，所以中间部分表示为arr[lt+1…i-1]==v</li></ul><p>下面要处理i下标代表的元素e，分以下3种情况：</p><ul><li>e 等于v ：直接纳入绿色部分，即无需处理，下标i后移。</li><li>e 小于v ：在学习之前二路快速排序法，应该有思路了，<strong>将下标i的元素值和下标 lt+1（即等于v绿色部分的第一个元素）交换，然后i下标后移，继而判断下一个元素；lt下标后移，代表小于v的元素新增了一个。</strong></li><li>e 大于v ：同理，将下标i的元素值和下标 gt-1（紫色部分的前一个元素）交换，gt下标前移，代表大于v的元素新增了一个。<strong>注意此时下标i 无需后移，因为不同于小于v 部分，此时交换后的元素是未处理过的，所以直接判断即可！</strong></li></ul><p>最后，当下标i 等于下标gt时，扫描结束。将l 和 lt下标所代表的元素交换位置即可。<br><img src="/posts/2307/4.gif" alt="3ways"><br>这种方式的优点就是不需要对等于v的元素进行重复操作，可以一次性少考虑相同元素</p><h4 id="2-代码实现-1"><a href="#2-代码实现-1" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h4><p>这里只修改partition函数即可，代码如下：</p><pre class="line-numbers language-C++"><code class="language-C++">【只修改partition函数即可】// 递归的三路快速排序算法template <typename T>void __quickSort3Ways(T arr[], int l, int r){    // 对于小规模数组, 使用插入排序进行优化    if( r - l <= 15 ){        insertionSort(arr,l,r);        return;    }    // 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot    swap( arr[l], arr[rand()%(r-l+1)+l ] );    T v = arr[l];    int lt = l;     // arr[l+1...lt] < v    int gt = r + 1; // arr[gt...r] > v    int i = l+1;    // arr[lt+1...i) == v    while( i < gt ){        if( arr[i] < v ){            swap( arr[i], arr[lt+1]);            i ++;            lt ++;        }        else if( arr[i] > v ){            swap( arr[i], arr[gt-1]);            gt --;        }        else{ // arr[i] == v            i ++;        }    }    swap( arr[l] , arr[lt] );    __quickSort3Ways(arr, l, lt-1);    __quickSort3Ways(arr, gt, r);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-归并排序、快速排序、三路快速排序比较"><a href="#3-归并排序、快速排序、三路快速排序比较" class="headerlink" title="3. 归并排序、快速排序、三路快速排序比较"></a>3. 归并排序、快速排序、三路快速排序比较</h4><p>下面针对以上讲解的3种快速排序方式分别对随机数组、近乎有序数组、包含大量重复元素数组进行测试，结果如下（测试代码见源码）：<br><img src="/posts/2307/14.png" alt="sort"></p><p>结论:</p><ul><li>测试一：面临大量无序元素时，快速排序最佳。</li><li>测试二：面临近乎有序数组时，归并排序最佳。</li><li>测试三：面临包含大量重复元素数组的情况下，三路快速排序比归并排序、快速排序有质变的超越！<br>总体而言，快速排序的性能是要优于归并排序！一般系统级别的快速排序都会选择三路快速排序，因为它在处理包含大量重复元素时，性能极高，即使不是，它的性能也得到保证，不会太差。</li></ul><h2 id="四-归并排序（Merge-Sort）和快速排序（Quick-Sort）的衍生问题"><a href="#四-归并排序（Merge-Sort）和快速排序（Quick-Sort）的衍生问题" class="headerlink" title="四. 归并排序（Merge Sort）和快速排序（Quick Sort）的衍生问题"></a>四. 归并排序（Merge Sort）和快速排序（Quick Sort）的衍生问题</h2><h4 id="1-分治算法"><a href="#1-分治算法" class="headerlink" title="1. 分治算法"></a>1. 分治算法</h4><p>这两种O(n*logn)高效的排序算法本身背后隐藏着重要的算法思想：其实归并排序和快速排序都使用了分治算法的基本思想。</p><blockquote><p>分治算法：分而治之，就是将原问题分割成同等结构的子问题，之后将子问题逐一解决后，原问题也得到解决。</p></blockquote><p>虽然都使用了分治算法的基本思想，但是归并排序和快速排序依旧代表了不同的实现：</p><ul><li>归并排序：在划分这个问题没有过多考虑，直接一分为二，递归进行归并排序，重点在于递归之后如何归并起来（”合”过程）。</li><li>快速排序：重点在于如何划分这个问题上，采用了标志点，结合Partition过程，使得标志点左部分元素小于标志点元素值，右部分大于。当标志点移到合适位置后，才将整个数组划分成两部分，这样在“合”时就无需多做处理。</li></ul><p>其实后面介绍的树形结构有关内容也使用了 分治思想，所以不要把一些经典的算法实现和算法设计思想拆开。</p><h4 id="2-逆序对"><a href="#2-逆序对" class="headerlink" title="2. 逆序对"></a>2. 逆序对</h4><p>关于归并排序和快速排序的第一个衍生问题就是逆序对，例如下图中的数组{8,6,2,3,1,5,7,4}，其中{2,3}就是一个顺序对，而{2,1}就是一个逆序对。<br><img src="/posts/2307/15.png" alt="sort"><br><strong>一个数组中逆序对的数量最有效的就是衡量这个数组的有序程度，</strong> 例如{1,2,3,4,5,6,7,8,}，这是完全有序数组，逆序对为0；而数组{8,7,6,5,4,3,2,1}完全逆序数组，此时逆序数量达到最大值。</p><p>（1）暴力破解</p><p>最容易解决的方式就是双重循环，考察每一个数对，判断是否逆序，实现简单，效率低，时间复杂度为O(n^2)</p><p>（2）归并排序</p><p>要解决此问题此时可以依赖于归并过程，例如以下动画，两个分别排好序的子数组{2,3,6,8,}和{1,4,5,7,}：</p><ul><li>首先1比2小，意味1比2后面的所有元素都小，计数器可直接加4，指向1的下标后移。</li><li>4大于2，不考虑，指向2的下标后移。</li><li>4大于3，不考虑，指向3的下标后移。</li><li>4小于6，意味4比6后面的所有元素都小，计数器可直接加2，指向4的下标后移。</li><li>依次类推</li></ul><p><img src="/posts/2307/5.gif" alt="sort"></p><pre class="line-numbers language-C++"><code class="language-C++">// 计算逆序数对的结果以long long返回// 对于一个大小为N的数组, 其最大的逆序数对个数为 N*(N-1)/2, 非常容易产生整型溢出// merge函数求出在arr[l...mid]和arr[mid+1...r]有序的基础上, arr[l...r]的逆序数对个数long long __merge( int arr[], int l, int mid, int r){    int *aux = new int[r-l+1];    for( int i = l ; i <= r ; i ++ )        aux[i-l] = arr[i];    // 初始化逆序数对个数 res = 0    long long res = 0;    // 初始化，i指向左半部分的起始索引位置l；j指向右半部分起始索引位置mid+1    int j = l, k = mid + 1;    for( int i = l ; i <= r ; i ++ ){        if( j > mid ){ // 如果左半部分元素已经全部处理完毕            arr[i] = aux[k-l];            k ++;        }        else if( k > r ){ // 如果右半部分元素已经全部处理完毕            arr[i] = aux[j-l];            j ++;        }        else if( aux[j-l] <= aux[k-l] ){ // 左半部分所指元素 <= 右半部分所指元素            arr[i] = aux[j-l];            j ++;        }        else{ // 右半部分所指元素 < 左半部分所指元素            arr[i] = aux[k-l];            k ++;            // 此时, 因为右半部分k所指的元素小            // 这个元素和左半部分的所有未处理的元素都构成了逆序数对            // 左半部分此时未处理的元素个数为 mid - j + 1            res += (long long)(mid - j + 1);        }    }    delete[] aux;    return res;}// 求arr[l..r]范围的逆序数对个数// 思考: 归并排序的优化可否用于求逆序数对的算法? :)long long __inversionCount(int arr[], int l, int r){    if( l >= r )        return 0;    int mid = l + (r-l)/2;    // 求出 arr[l...mid] 范围的逆序数    long long res1 = __inversionCount( arr, l, mid);    // 求出 arr[mid+1...r] 范围的逆序数    long long res2 = __inversionCount( arr, mid+1, r);    return res1 + res2 + __merge( arr, l, mid, r);}// 递归求arr的逆序数对个数long long inversionCount(int arr[], int n){    return __inversionCount(arr, 0, n-1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-取数组中第n大的元素"><a href="#3-取数组中第n大的元素" class="headerlink" title="3. 取数组中第n大的元素"></a>3. 取数组中第n大的元素</h4><p>如果这个问题是取数组中的最大值或最小值，那么时间复杂度为O(n)，可是现在是取第n大的元素，例如在1000000里取第1000个元素。</p><p>此问题的解决思路很简单，就是给整个数组排序再通过下标索引取出元素即可，算法复杂度为O(n*logn)，但是！在本篇博文中学习了快速排序后，可使用O(n)时间获取。</p><p>快速排序的核心过程:<br><strong>每次找到一个标志点，将此点挪到数组中合适的位置，注意此合适位置恰好是数组中排序好后所处的位置。</strong></p><p>示例引导:<br>例如下图示例中的标志点4，最后挪到的位置恰好就是数组最后有序的位置，比如此时我们要获取第6个位置上的元素，那么标志位4之前的元素无需考虑，从后部分处理，继续处理后部分的第二位是谁？<br><img src="/posts/2307/16.png" alt="sort"></p><pre class="line-numbers language-C++"><code class="language-C++">// partition 过程, 和快排的partition一样// 思考: 双路快排和三路快排的思想能不能用在selection算法中? :)template <typename T>int __partition( T arr[], int l, int r ){    int p = rand()%(r-l+1) + l;    swap( arr[l] , arr[p] );    int j = l; //[l+1...j] < p ; [lt+1..i) > p    for( int i = l + 1 ; i <= r ; i ++ )        if( arr[i] < arr[l] )            swap(arr[i], arr[++j]);    swap(arr[l], arr[j]);    return j;}// 求出arr[l...r]范围里第k小的数template <typename T>int __selection( T arr[], int l, int r, int k ){    if( l == r )        return arr[l];    // partition之后, arr[p]的正确位置就在索引p上    int p = __partition( arr, l, r );    if( k == p )    // 如果 k == p, 直接返回arr[p]        return arr[p];    else if( k < p )    // 如果 k < p, 只需要在arr[l...p-1]中找第k小元素即可        return __selection( arr, l, p-1, k);    else // 如果 k > p, 则需要在arr[p+1...r]中找第k小元素        return __selection( arr, p+1, r, k );}// 寻找arr数组中第k小的元素template <typename T>int selection(T arr[], int n, int k) {    assert( k >= 0 && k < n );    srand(time(NULL));    return __selection(arr, 0, n - 1, k);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下一篇博文将讲解另一个排序算法——堆排序，也是此系列的第一个数据结构—–堆，后续学习你会发现对于堆的使用将远超与求解排序。</p><p>转载自：<a href="https://blog.csdn.net/ITermeng/article/details/77397212">https://blog.csdn.net/ITermeng/article/details/77397212</a></p>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Play-with-Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Play-with-Algorithms(2)：O(n*logn)排序算法之 归并排序（自顶向下、自底向上） 及 算法优化</title>
      <link href="posts/24873/"/>
      <url>posts/24873/</url>
      
        <content type="html"><![CDATA[<p>在上一篇博文中学习了时间复杂度为 O(n^2)的几个排序算法（选择、插入、冒泡、希尔排序），其中尤为需要注意的是<strong>插入排序</strong>，在近乎有序的测试用例条件下，此算法的效率会高于 <strong>O(n*logn)</strong> 的排序算法，所以它的效率不容小觑。</p><p>但是 <strong>O(n * logn)</strong> 的排序算法与<strong>O(n* logn)</strong> 之间还是有质变的区别，综合而言性能更优。此篇文章将讲解时间复杂度为 <strong>O(n*logn)</strong> 的有关算法，涉及到的知识点有：</p><ul><li>归并排序法思想、实现、优化</li><li>自底向上的归并排序算法</li><li>自顶向下、自底向上两种归并排序算法比较</li></ul><a id="more"></a><h4 id="O-n-logn-和-O-n-2-算法比较"><a href="#O-n-logn-和-O-n-2-算法比较" class="headerlink" title="O(n*logn) 和 O(n^2)算法比较"></a>O(n*logn) 和 O(n^2)算法比较</h4><p>在讨论排序算法的时间复杂度时，O(n*logn)毫无疑问被视为最优解，而O(n^2)总被大家鄙夷不屑。这两者的差距究竟有多大呢，可查看下图进行了解：</p><p><img src="/posts/24873/1.png" alt="算法复杂度"></p><p>也许你在计算机跑程序时感觉时间消耗得都是差不多，并无太大区别，<strong>那是因为你使用的测试用例数量太小了。</strong>（不背这锅）</p><p>例如上图中当测试数量为10时，O(n* logn)只是比O(n^2)快3倍，<strong>区别并不大，但是随着数量逐渐增大，O(n * logn)的优势会愈加明显!</strong> 当n=10^5时，其实这个测试数量也不是很大，<strong>O(n * logn)</strong> 比O(n^2)快6000倍，相当于使用<strong>O(n * logn)</strong> 算法计算需要1小时，而<strong>O(n^2)</strong> 却需要6000小时，天壤之别已经呈现出来了。</p><p>因此，在算法的世界中才会一直有新的被优化的算法产生，从而达到人们追求高效的理想，我们更应该去学习理解。</p><h2 id="一-归并排序"><a href="#一-归并排序" class="headerlink" title="一. 归并排序"></a>一. 归并排序</h2><h4 id="1-算法思想"><a href="#1-算法思想" class="headerlink" title="1. 算法思想"></a>1. 算法思想</h4><p>首先通过以下动画展示来了解归并排序算法的简单思路，待排序的数组为{8,6,2,3,1,5,7,4}</p><p><strong>（1）整体思想路</strong></p><ul><li>首先将数组对半划分，分别对左、右边的数组进行排序。</li><li>还要分别继续划分左、右边的数组，将左边的数组继续对半划分…</li><li>一直这样划分直到划分的“左边”或“右边”只剩下两个元素，对每一个小部分进行排序。</li><li>小部分排序完后，进行向上归并，即与旁边的“小组”进行归并（注意：此时各小组的排序已经完成，需要做的步骤是将其归并！），层层往上，直到由多个小组归并成一个大组，归并完成，排序也完成。<br><img src="/posts/24873/1.gif" alt="归并"></li></ul><p><strong>（2）算法复杂度</strong><br>为何需要将一个数组分层那个多个小组，再进行一层层向上归并？</p><p>查看下图是对8个元素进行排序、归并一步步划分的过程。<strong>此数组一层层划分下来，总共分成了3级，到第3级时，每个“小组”只剩下1个元素了。8个元素，以2划分，3次下来只剩下1个元素，这个“3”层来源于：log以2为底8 = 3。</strong></p><p>所以如果有n个元素，便有 <strong>log以2为底n</strong>个层级，虽然分成了不同的部分，但是每一层处理的个数是一样的，如果整个归并过程可以O(n)的时间复杂度来解决的话，那么最后整个过程的时间复杂度就是O(n*logn)。</p><p>以上就是O(n* logn)时间复杂度的主要来源:<strong>通过二分法达到 logn的层级，每一个层级使用 O(n)的时间来处理排序，最后总时间复杂度就是O(n * logn)，而这整个过程可以通过递归来完成.</strong></p><p><img src="/posts/24873/2.png" alt="归并排序"></p><p><strong>（3）归并过程的思想</strong><br>接下来需要解决的问题就是<strong>两个已经各自排序好的小组是如何归并到一个大组的？</strong></p><p>这里可不是采用之前学过的插入算法或其它的，毕竟这样做那之前个小组之间的有序性就无其他任何意义了，主要思路通过以下动画来了解（现在已经有两组搁在排序好的数组，需要将其归并到一个数组 {2,3,6,8}，{1,4,5,7}）：</p><ul><li><p><strong>首先需要两个临时数组空间来辅助完成归并过程，这也是归并排序的缺点，虽然减少算法复杂度到O(n * logn)，但是使用了除O(n)之外的额外空间。</strong>（不过在目前计算机中时间效率比空间效率更为重要，可存储的数据规模越来越大，因此设计算法通常优先考虑时间复杂度）</p></li><li><p>紧接着还需要使用3个索引在数组内进行追踪： </p><ul><li>k蓝色箭头：归并过程中最终需要跟踪的位置。</li><li>i、j红色箭头：代表两个排序好的数组当前需要考虑的元素。</li></ul></li><li><p>首先两个红色箭头分别指向数组中的第一个元素，即待比较元素，而蓝色箭头则是指向最终待归并数组的第一个位置，等待合适元素赋值。比较开始，2比1小，将1赋值到待归并数组的第一个位置 </p><ul><li>蓝色箭头所指的第一个位置的合适元素已找到，箭头向后移，等待第二个合适元素。</li><li>而原本指向1的红色箭头向后移，因为1已经找到合适位置了</li><li>而指向2的红色箭头不动，等待下一次比较。</li></ul></li><li><p>后面依次类推。</p></li></ul><p>总之，这个归并排序的过程就是两个已排序好的数组来比较头部的元素，取最小值放入最终数组中。<strong>此过程也依赖于3个索引值，i、j指向两个有序数组中正在比较大小的元素，k代表比较后的元素应当归并的位置 ，即下一个元素应该放入的位置。</strong></p><p><img src="/posts/24873/2.gif" alt="merge"></p><p>另外，为了跟踪i、j、k的出界情况，还需要在数组中间作标记，左、右边两个有序数组分别标记为<strong>l(left)</strong>、<strong>r(right)</strong>，对于中间位置标记为<strong>m(middle)</strong>。</p><h4 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h4><p>接下来，通过以上思路，由递归思想来完成这个归并过程：</p><p><strong>（1）mergeSort函数</strong><br><em>目的：主函数中调用此方法即可（暴露给上层调用）</em></p><p>在函数mergeSort递归中还有一个排序的过程，所以再定义一个函数__mergeSort，取名代表它其实是一个私有的函数，被mergeSort所调用，对于用户而言只需调用mergeSort即可。</p><p><strong>（2）__mergeSort函数</strong><br><em>目的：递归使用归并排序,对arr[l…r]的范围进行排序</em></p><ul><li>首先进行边界判断，若 l 大于或等于 r ，即可停止递归。</li><li>计算中间值，对左右分开的两个部分进行归并排序，即分别递归。</li><li>左、右两部分分别排序好，就要进行归并操作，将两个部分归并到一个数组中。这里需要调用一个新的函数__merge</li></ul><p><strong>（3）__merge函数</strong><br><em>目的：将arr[l…mid]和arr[mid+1…r]两部分进行归并</em><br>此函数需要进行的逻辑操作在上一点归并过程思想中已详细讲解，来查看具体实现：</p><ul><li><p>创建临时空间，大小为两个带归并数组的总长度，将数组中所有元素赋值到临时空间中。</p></li><li><p>通过循环，循环次数为待归并数组长度次数，即r-l，在循环中可按照之前分析的逻辑进行代码实现，<strong>获取两有序数组头部值中较小值赋值到待归并数组，此处判断有4中情况（根据不同情况进行赋值、移动下标）：</strong> </p><ul><li>如果左半部分元素已经全部处理完毕</li><li>如果右半部分元素已经全部处理完毕</li><li>左半部分所指元素 &lt; 右半部分所指元素</li><li>左半部分所指元素 &gt;= 右半部分所指元素</li></ul></li></ul><p>代码为：</p><pre class="line-numbers language-C++"><code class="language-C++">// 将arr[l...mid]和arr[mid+1...r]两部分进行归并template<typename  T>void __merge(T arr[], int l, int mid, int r){    /* VS不支持动态长度数组, 即不能使用 T aux[r-l+1]的方式申请aux的空间    * 使用VS的同学, 请使用new的方式申请aux空间    * 使用new申请空间, 不要忘了在__merge函数的最后, delete掉申请的空间:)    */    T aux[r-l+1];    //T *aux = new T[r-l+1];    for( int i = l ; i <= r; i ++ )        aux[i-l] = arr[i];    // 初始化，i指向左半部分的起始索引位置l；j指向右半部分起始索引位置mid+1    int i = l, j = mid+1;    for( int k = l ; k <= r; k ++ ){        if( i > mid ){  // 如果左半部分元素已经全部处理完毕            arr[k] = aux[j-l]; j ++;        }        else if( j > r ){  // 如果右半部分元素已经全部处理完毕            arr[k] = aux[i-l]; i ++;        }        else if( aux[i-l] < aux[j-l] ) {  // 左半部分所指元素 < 右半部分所指元素            arr[k] = aux[i-l]; i ++;        }        else{  // 左半部分所指元素 >= 右半部分所指元素            arr[k] = aux[j-l]; j ++;        }    }    //delete[] aux;}// 递归使用归并排序,对arr[l...r]的范围进行排序template<typename T>void __mergeSort(T arr[], int l, int r){    if( l >= r )        return;    int mid = (l+r)/2;    __mergeSort(arr, l, mid);    __mergeSort(arr, mid+1, r);    __merge(arr, l, mid, r);}//主函数中调用此方法即可（暴露给上层调用）template<typename T>void mergeSort(T arr[], int n){    __mergeSort( arr , 0 , n-1 );}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-比较归并排序与插入排序的时间效率"><a href="#3-比较归并排序与插入排序的时间效率" class="headerlink" title="3. 比较归并排序与插入排序的时间效率"></a>3. 比较归并排序与插入排序的时间效率</h4><p>以下测试将对比归并排序和插入排序，分别在无序、有序的测试用例下的时间：</p><pre class="line-numbers language-C++"><code class="language-C++">int main() {    int n = 50000;    // 测试1 一般性测试    cout<<"Test for random array, size = "<<n<<", random range [0, "<<n<<"]"<<endl;    int* arr1 = SortTestHelper::generateRandomArray(n,0,n);    int* arr2 = SortTestHelper::copyIntArray(arr1, n);    SortTestHelper::testSort("Insertion Sort", insertionSort, arr1, n);    SortTestHelper::testSort("Merge Sort",     mergeSort,     arr2, n);    delete[] arr1;    delete[] arr2;    cout<<endl; // 测试2 测试近乎有序的数组    int swapTimes = 10;    assert( swapTimes >= 0 );    cout<<"Test for nearly ordered array, size = "<<n<<", swap time = "<<swapTimes<<endl;    arr1 = SortTestHelper::generateNearlyOrderedArray(n,swapTimes);    arr2 = SortTestHelper::copyIntArray(arr1, n);    SortTestHelper::testSort("Insertion Sort", insertionSort, arr1, n);    SortTestHelper::testSort("Merge Sort",     mergeSort,     arr2, n);    delete[] arr1;    delete[] arr2;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果显示:<br><img src="/posts/24873/3.png" alt="merge对比"></p><p>现象分析</p><ul><li>测试一结论：对于无序的数组，归并排序的时间甩插入排序几条街，更加高效！</li><li>测试二结论：对于近乎有序的数组，数组越有序，插入排序的时间性能越趋近于O(n)，比归并排序高效（注意前提，近乎有序数组的条件，这里测试的swap time是10，<strong>即随机将完全有序的数组交换10组数据达到近乎有序的条件，</strong> 此部分在上篇博文有讲解，可查看！）。</li></ul><p><strong>总结</strong><br>比较插入排序（InsertionSort）和归并排序（MergeSort）两种排序算法的性能效率，整体而言， 归并排序的性能最优, 对于近乎有序的数组的特殊情况, 还是之前介绍的插入排序更胜一筹</p><p>归并排序是我们学习的第一个O(nlogn)复杂度的算法，可以在1秒之内轻松处理100万数量级的数据。</p><p>注意</p><p>不要轻易尝试使用选择排序（SelectionSort）、插入排序（InsertionSort）或者冒泡排序（BubbleSort）处理100万级的数据，否则，你就见识了O(n^2)的算法和O(nlogn)算法的本质差异！</p><h4 id="4-代码优化"><a href="#4-代码优化" class="headerlink" title="4. 代码优化"></a>4. 代码优化</h4><p>在实现代码逻辑后，按照我们的套路接下来就要考虑优化问题。<br><strong>（1）优化一</strong><br>其实所有的排序算法中都存在一种优化，就是递归到底优化。_merge函数中的第一个判断是当只剩下一个元素时才返回，事实上当方法递归到元素较少时，可使用<strong>插入排序</strong>来提高性能，由以下两个原因：</p><ul><li>当待排序的数组元素较少时，近乎有序的情况概率较大，此时插入排序有优势。</li><li>虽然插入排序的时间复杂度是O(n^2)级别，而归并排序是O(n* logn)，<strong>但是别忽视这两者都依赖于常数系数n，当n较小时，插入排序是稍快于归并排序的</strong></li></ul><p><strong>（2）优化二</strong></p><p>思考_merge函数中的逻辑，其中对左右两个部分进行了递归之后，没有考虑两部分的大小问题，一律进行归并过程。<strong>事实上有可能出现正好左部分的最后一个值（即最大值）小于右部分的第一个值（即最小值），这样其实整个数组是有序的，无需再进行归并过程，直接跳过即可。</strong></p><p>所以优化二：<strong>在执行merge操作前，判断两个子数组是否需要merge（可能存在本身就有序的情况）</strong></p><p>注意：<strong>这种优化实现就是多加了一个if语句判断，这样在处理近乎有序数组的情况下会节省时间，但是判断本身就是一个新的耗时操作，所以此种优化更适用于近乎有序数组排序。</strong></p><p><strong>（3）代码展示</strong></p><pre class="line-numbers language-C++"><code class="language-C++">【__merge函数不作修改，在此不粘贴了】// 对arr[l...r]范围的数组进行插入排序template<typename T>void insertionSort(T arr[], int l, int r){    for( int i = l+1 ; i <= r ; i ++ ) {        T e = arr[i];        int j;        for (j = i; j > l && arr[j-1] > e; j--)            arr[j] = arr[j-1];        arr[j] = e;    }    return;}// 使用优化的归并排序算法, 对arr[l...r]的范围进行排序template<typename T>void __mergeSort2(T arr[], int l, int r){    // 优化1: 对于小规模数组, 使用插入排序    if( r - l <= 15 ){        insertionSort(arr, l, r);        return;    }    int mid = (l+r)/2;    __mergeSort2(arr, l, mid);    __mergeSort2(arr, mid+1, r);    // 优化2: 对于arr[mid] <= arr[mid+1]的情况,不进行merge    // 对于近乎有序的数组非常有效,但是对于一般情况,有一定的性能损失    if( arr[mid] > arr[mid+1] )        __merge(arr, l, mid, r);}template<typename T>void mergeSort2(T arr[], int n){    __mergeSort2( arr , 0 , n-1 );}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二-自底向上的归并排序"><a href="#二-自底向上的归并排序" class="headerlink" title="二. 自底向上的归并排序"></a>二. 自底向上的归并排序</h2><p><strong>1.算法思想</strong><br>在理解了归并排序的思想后，其实不一定非要按照自顶向下的思路，可以考虑自底向上的过程，查看以下过程：</p><ul><li>将此数组按照从坐到右的顺序两两划分成多个小组来进行归并排序的过程（一个组有2个元素）。</li><li>在两个元素归并排序完成后，再按照从坐到右的顺序将两个组进行归并到一个组（即1个组有4个元素）。</li><li>依次类推。<br><img src="/posts/24873/3.gif" alt="自底向上"></li></ul><hr><p><strong>2. 代码实现</strong><br>在此过程中，并不需要递归，而是采用迭代来实现归并排序，代码如下：</p><ul><li>首先最外层循环需要对归并的个数进行遍历，size从1开始遍历到n，每次循环增加自身值，即（1-&gt;2-&gt;4-&gt;8）</li><li>内存循环就是每一轮在归并过程起始的元素位置，位置从0开始到n - sz，每次循环增加2个size，即第一轮从0<del>size-1、从size</del>2size-1这两部分进行归并，第二轮从2size<del>3size-1、从3size</del>4size-1这两部分进行归并。注意：这里代码编写需要严谨考虑越界问题。</li></ul><p>以下代码中__merge归并过程函数相同</p><pre class="line-numbers language-C++"><code class="language-C++">// 使用自底向上的归并排序算法template <typename T>void mergeSortBU(T arr[], int n){    for( int sz = 1; sz < n ; sz += sz )        for( int i = 0 ; i < n - sz ; i += sz+sz )            // 对 arr[i...i+sz-1] 和 arr[i+sz...i+2*sz-1] 进行归并            __merge(arr, i, i+sz-1, min(i+sz+sz-1,n-1) );}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>以上代码实现过程中有个特点即未使用到数组的特性，即不是通过索引值来获取元素值。正因如此，可使用O(n*logn)的时间对链表这样的数据结构进行排序，这也是个很常见的算法问题，需仔细琢磨！</strong></p><hr><p><strong>3. 代码优化</strong><br>这里可优化的两处同自顶向下归并排序法相同，以下稍作总结：</p><ul><li><strong>对于小数组, 使用插入排序优化。（千万不要轻视插入排序的效率，虽然是O(n^2)，但在数量少、有序数组的前提下，效率不容忽视）</strong></li><li>在内循环中，由于两个小组内部各自已是有序，对于arr[mid] &lt;= arr[mid+1]的情况，所以代表无需进行归并过程。</li></ul><p><strong>优化后代码如下：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">【insertionSort函数前面已经贴出，在此不重复粘贴】template <typename T>void mergeSortBU(T arr[], int n){for( int i = 0 ; i < n ; i += 16 )        insertionSort(arr,i,min(i+15,n-1));    for( int sz = 16; sz < n ; sz += sz )        for( int i = 0 ; i < n - sz ; i += sz+sz )            // 对于arr[mid] <= arr[mid+1]的情况,不进行merge            if( arr[i+sz-1] > arr[i+sz] )                __merge(arr, i, i+sz-1, min(i+sz+sz-1,n-1) );}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong><br>测试数量为100000，比较自顶向下、自底向上两种归并排序在无序和有序数组测试的情况下，两者的测试结果如下：<br><img src="/posts/24873/4.png" alt="两者对比"></p><p><strong>结论</strong></p><p>整体而言， 两种算法的效率是差不多的。但是如果进行仔细测试， 自底向上的归并排序会略胜一筹，而且它更适用于链表这样的数据结构进行排序。<strong>(LeetCode上第148号问题)</strong></p><p><strong>分析</strong></p><blockquote><p>我们对归并排序主要有两个优化。第一，使用插入排序对小数组进行处理。这个优化对两个算法的作用是相同的。<br>关键在于第二条优化。也就是在真正执行merge操作前，先看一下两个子数组是不是真的需要merge。<strong>要注意：在自顶向下的归并排序中。这个优化可以发生在非常高的层次，也就是面对两个很大的数组，也可以通过这步优化，使得我们不需要进一步处理两个大数组！但是在自底向上的归并排序中，我们却不能跨过具有这种性质的大数组，依然要一步一步从小数组向上构造。由于这个原因，自底向上的归并排序的速度被拖慢了，但是自顶向下的归并排序递归调用需要额外的开销！</strong><br>所以，按理说还是自底向上的归并排序较为高效</p></blockquote><p>下一篇文章将介绍O(n*logn)排序算法中的另一个鼎鼎大名的算法——快速排序及其衍生算法。</p><p>原文来自blog：<a href="https://blog.csdn.net/ITermeng/article/details/77326595">https://blog.csdn.net/ITermeng/article/details/77326595</a></p>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Play-with-Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Play-with-Algorithms(1)：O(n^2)排序算法之 选择、插入、冒泡、希尔排序 及 优化</title>
      <link href="posts/44265/"/>
      <url>posts/44265/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h2><h4 id="1-语言要求"><a href="#1-语言要求" class="headerlink" title="1 . 语言要求"></a>1 . 语言要求</h4><p>对于算法而言，它其实是与语言无关的，被誉为算法神书的《算法导论》中都是以伪码的形式进行编写。算法更重要的是一种思想，当你想透彻后编代码实现就不是问题了。由于不同的语言含有独特的特性，在某些语言实现算法过程中可利用其特性可更好地实现算法思想.</p><h4 id="2-基础要求"><a href="#2-基础要求" class="headerlink" title="2 . 基础要求"></a>2 . 基础要求</h4><p>此系列博文重点讲解算法实现，默认读者</p><ul><li>具备基础语言知识</li><li>了解数组、链表、堆栈等线性结构</li><li>对基本算法知识有常识性了解即可，例如递归、遍历、算法复杂度</li></ul><p>对于以上点有基本认识概念即可（后续会介绍重点），将在此基础上进行解析。</p><a id="more"></a><h4 id="3-学习路径"><a href="#3-学习路径" class="headerlink" title="3 .学习路径"></a>3 .学习路径</h4><ul><li>线性（排序）</li></ul><p><img src="/posts/44265/1.gif" alt="排序"><br>此系列首先会讲解线性结构，主要体现在排序算法上，稍有了解的学者应当知晓关于排序的算法并不少，通过此部分学习可深入了解许多算法思想。</p><ul><li>树形结构<br><img src="/posts/44265/2.png" alt="树形结构"></li></ul><p>此部分将介绍几种重要的树形结构的算法思想、应用场景，它们之间的区别、特点、局限性等一一探究。</p><ul><li>图形结构</li></ul><p><img src="/posts/44265/3.png" alt="图形结构"></p><p>此部分主要介绍图论相关的基础算法。</p><p>对于算法而言，编程是次要的，更重要的还是思想，例如面试中的常见的“白板编程”，便是如此，一块白板不可能让你实现多长的代码，通常十几行甚至不足十行就可以考察出你对其算法的思想理解深度。</p><h4 id="4-数据结构的重要性"><a href="#4-数据结构的重要性" class="headerlink" title="4. 数据结构的重要性"></a>4. 数据结构的重要性</h4><p>查看以上学习路径会发现重点更偏向于数据结构，从简单的线性过渡到图结构。确实如此，数据结构在编程中的地位是承上启下的。<br>优秀与平庸的程序员之间的区别就是数据结构的使用上，更重要的是算法与数据结构是融合一体、无法分隔的.<br>其实很多算法是依托于数据结构而存在的，包括面试中很多问题看似算法问题，本质还是数据结构，考察的远比我们想象的要基础，基础的重要性从来无需多言。例如微软曾面试过的代码实现堆、二叉树翻转等，无不是在考察基础。</p><h4 id="5-算法思想"><a href="#5-算法思想" class="headerlink" title="5. 算法思想"></a>5. 算法思想</h4><p>在强调数据结构的重要性后，其中算法思想也是不容忽略：</p><ul><li>分治算法：归并排序、快速排序……</li><li>贪心算法：最小生成树……</li><li>动态规划：最短路径……</li><li>递归搜索：树形结构……</li></ul><p>以上所举的例子可以看出数据结构和算法之间的互相依托程度，例如在学习归并、快速排序时，实则也在探究分治算法……</p><p>每个细分领域都是算法，例如以下例子：</p><ul><li>图形学</li><li>机器学习</li><li>人工智能</li><li>数据挖掘</li><li>操作系统</li><li>网络安全</li><li>高性能计算</li></ul><h2 id="二-选择排序"><a href="#二-选择排序" class="headerlink" title="二 . 选择排序"></a>二 . 选择排序</h2><p>首先开始学习的是排序算法，最基本的 O(n^2)时间复杂度的排序算法，需要了解的是最优解的时间复杂度为 O(n*logn)，那为何还要学习较复杂的算法？</p><p>O(n^2)时间复杂度的排序算法编码简单，易于实现，是一些简单情景的首选！<strong>在一些特殊情况下，简单的排序算法更有效。简单的排序算法思想衍生出复杂的排序算法，作为子过程，改进更复杂的排序算法。</strong> 在面试中若没有思路，不如先简单实现，再从其中优化，找到最优解。</p><h4 id="1-算法思想"><a href="#1-算法思想" class="headerlink" title="1. 算法思想"></a>1. 算法思想</h4><p>选择排序的实现思想较为简单，例如以下gif图示，有一组不规则数字排序{8,6,2,3,1,5,7,4}，需要将它们从小到大进行排序。</p><ul><li>首先在数组中找出第一名的位置（即最小的数字 1），将它与目前数组中第一名（即数字8）进行交换。</li><li>此时数组中第一个位置已是最小数字，接着在其余位置中找寻最小数字，与其数组中目前的第二个位置进行交换。</li><li>后面过程依次类推，直到剩下最后一个位置，已无需排序，已为最大值。</li></ul><p><img src="/posts/44265/4.gif" alt="选择排序"></p><h4 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h4><pre class="line-numbers language-C++"><code class="language-C++">#include <iostream>#include <algorithm>using namespace std;void selectionSort(int arr[], int n){    for(int i = 0 ; i < n ; i ++){        // 寻找[i, n)区间里的最小值        int minIndex = i;        for( int j = i + 1 ; j < n ; j ++ )            if( arr[j] < arr[minIndex] )                minIndex = j; //记录数组中最小值下标        //这里使用的swap交换函数是C++标准库中内置函数，对于C++11而言此函数在命名空间std中（即 using namespace std;），而老的标准需要导入#include <algorithm>        swap( arr[i] , arr[minIndex] );    }}int main() {    int a[10] = {10,9,8,7,6,5,4,3,2,1};    selectionSort(a,10);    for( int i = 0 ; i < 10 ; i ++ )        cout<<a[i]<<" ";    cout<<endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果显示:<br>1 2 3 4 5 6 7 8 9 10</p><h3 id="三-使用优化"><a href="#三-使用优化" class="headerlink" title="三. 使用优化"></a>三. 使用优化</h3><p>在介绍其余算法之前，需要对以上代码稍作优化，此优化并非是算法上，而是在于使用上，为了后续讲解使用更加高效。</p><h4 id="1-使用模板（泛型）编写算法"><a href="#1-使用模板（泛型）编写算法" class="headerlink" title="1. 使用模板（泛型）编写算法"></a>1. 使用模板（泛型）编写算法</h4><p>从以上代码可以看出此算法排序只针对于 int 类型，所以<strong>首先进行优化的便是使用模板（泛型）编写算法，这样针对的范围可扩大于浮点型、字符串，甚至于结构体。</strong></p><p>在C++中声明为模板函数非常简单，只需在函数头前加上template<typename t>，再修改参数类型即可：</typename></p><pre class="line-numbers language-C++"><code class="language-C++">//使用模板（泛型）编写算法template<typename T>void selectionSort(T arr[], int n){    for(int i = 0 ; i < n ; i ++){        int minIndex = i;        for( int j = i + 1 ; j < n ; j ++ )            if( arr[j] < arr[minIndex] )                minIndex = j;        swap( arr[i] , arr[minIndex] );    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-随机生成算法测试用例"><a href="#2-随机生成算法测试用例" class="headerlink" title="2. 随机生成算法测试用例"></a>2. 随机生成算法测试用例</h4><p>在优化了以上一点后，查看测试代码发现其中还有一个隐患，即测试的数据是自定义的，且数量过少，为了后续比较不同算法复杂度测试，需要满足随机生成算法测试用例的条件。</p><p>后续还有多种排序算法的复杂度需要做比较，为此创建一个新的 .h 文件SortTestHelper。</p><p>文件中的generateRandomArray辅助函数将随机生成一个int型数组，即返回值是int型指针，其中函数中的3个参数：</p><ul><li>n：数组中的元素</li><li>rangeL 和 int rangeR：随机范围[rangeL, rangeR]</li></ul><p>此随机数的生成实现是将时间作为种子，来进行随机设置，再通过遍历为数组进行赋值，其中进行取余运算来控制随机范围。代码如下：</p><pre class="line-numbers language-C++"><code class="language-C++">【SortTestHelper.h】/* * 排序测试帮组文件 * */namespace SortTestHelper {    // 生成有n个元素的随机数组,每个元素的随机范围为[rangeL, rangeR]    int *generateRandomArray(int n, int rangeL, int rangeR) {        //使函数健壮，检验rangeL 是否小于rangeR，调用assert函数，需要加载#include <cassert>库        assert(rangeL <= rangeR);        int *arr = new int[n];        //需要加载#include <ctime>库        srand(time(NULL));        for (int i = 0; i < n; i++)            arr[i] = rand() % (rangeR - rangeL + 1) + rangeL;        return arr;    }    // 打印arr数组的所有内容    template<typename T>    void printArray(T arr[], int n) {        for (int i = 0; i < n; i++)            cout << arr[i] << " ";        cout << endl;        return;    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-测试算法性能"><a href="#3-测试算法性能" class="headerlink" title="3. 测试算法性能"></a>3. 测试算法性能</h4><p>接下来需要在测试帮助文件中编写一个辅助函数来比较测试不同算法之间的性能差异，最简单的方式去判断算法性能就是在特定测试集上的执行时间。</p><p>注意，函数testSort中提供的几个参数较为重要</p><ul><li>const string &amp;sortName：采用的排序算法名称。</li><li>void (<em>sort)(T[], int)：*</em>函数指针，由于函数执行时间通过此帮助文件的辅助函数实现，所以需要传入排序函数的指针。**</li><li>T arr[]：待排序数组。</li><li>int n：数组个数。<br>辅助方法中实现具体为:在调用排序函数前后分别获取时间，再相减即可获取排序执行时间。</li></ul><pre class="line-numbers language-C++"><code class="language-C++">【SortTestHelper.h】    // 判断arr数组是否有序    template<typename T>    bool isSorted(T arr[], int n) {        for (int i = 0; i < n - 1; i++)            if (arr[i] > arr[i + 1])                return false;        return true;    }// 测试sort排序算法排序arr数组所得到结果的正确性和算法运行时间    template<typename T>    void testSort(const string &sortName, void (*sort)(T[], int), T arr[], int n) {        clock_t startTime = clock();        sort(arr, n);        clock_t endTime = clock();        //调用isSorted函数测试排序是否正确无误，注意执行顺序不可放入调用clock()之前，否则该检验过程会影响真实排序效率        assert(isSorted(arr, n));        cout << sortName << " : " << double(endTime - startTime) / CLOCKS_PER_SEC << " s" << endl;        return;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>算法测试调用</p><pre class="line-numbers language-C++"><code class="language-C++">int main() {    int n = 20000;    int *arr = SortTestHelper::generateRandomArray(n,0,n);    SortTestHelper::testSort("Selection Sort", selectionSort, arr, n);    delete[] arr;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显示结果（对20000个无序数字进行 选择排序，最终使用时间）：<br><img src="/posts/44265/4.png" alt="用时"><br>此时的main 函数看起来已经十分简洁了，其中的随机生成测试用例及排序函数过程执行时间都依赖于测试帮助文件SortTestHelper完成，而三个优化已经完成。</p><hr><h2 id="三-插入排序"><a href="#三-插入排序" class="headerlink" title="三. 插入排序"></a>三. 插入排序</h2><h4 id="1-算法思想-1"><a href="#1-算法思想-1" class="headerlink" title="1. 算法思想"></a>1. 算法思想</h4><p>插入排序的思想同生活中整理扑克牌顺序有些类似，将后面的牌按照大小顺序插入到前面来。{8,6,2,3,1,5,7,4},</p><ul><li>首先第一个元素8，由于它的位置是第一个，所以保持不动。</li><li>继续看第二个位置的元素是6，比前面的元素8小，两者交换位置。</li><li>继续看第三个元素2，比第二个元素8小，交换位置，此时元素2是第二个位置，再同第一个元素6进行比较，比它小继而交换位置。</li><li>后面过程依次类推。</li></ul><p><img src="/posts/44265/5.gif" alt="插入排序"></p><p>该算法在后面的应用中比较重要</p><h4 id="2-代码实现-1"><a href="#2-代码实现-1" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h4><p>注意：</p><ul><li>插入排序中的外层循环下标不再是从0开始，<strong>而是从1开始（从第二个元素开始对前面的元素进行比较）。</strong></li><li>在每次循环里需要做的是<strong>寻找元素arr[i]前面合适的插入位置。</strong></li></ul><pre class="line-numbers language-C++"><code class="language-C++">template<typename T>void insertionSort(T arr[], int n){    for( int i = 1 ; i < n ; i ++ ) {        // 寻找元素arr[i]合适的插入位置        for( int j = i ; j > 0 ; j-- )            if( arr[j] < arr[j-1] )                swap( arr[j] , arr[j-1] );            else                break;       // 写法2      /*        for( int j = i ; j > 0 && arr[j] < arr[j-1] ; j -- )            swap( arr[j] , arr[j-1] );      */    }    return;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上内容实现你会发现其实内循环中的判断条件有两个，<strong>所以可直接改进为写法2，将两个判断条件放在一起。</strong></p><p>选择排序和插入排序的根本区别:</p><p><strong>插入排序的内循环在满足条件的情况下是可以提前结束的！而选择排序必须遍历每一次循环。</strong>所以<strong>插入排序</strong>理论上比选择排序更快一些。</p><p>测试选择排序和插入排序</p><p>由于测试这两个排序算法效率的准确性，所以两者的测试用例数组应相同，即需要再复制一份，在测试帮助文件中新增一个辅助方法进行数组复制。</p><p>由于测试这两个排序算法效率的准确性，所以两者的测试用例数组应相同，即需要再复制一份，在测试帮助文件中新增一个辅助方法进行数组复制。</p><pre class="line-numbers language-C++"><code class="language-C++">【SortTestHelper.h】// 拷贝整型数组a中的所有元素到一个新的数组, 并返回新的数组    int *copyIntArray(int a[], int n){        int *arr = new int[n];        //命名空间std中的函数        copy(a, a+n, arr);        return arr;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显示结果:<br><img src="/posts/44265/6.png" alt="显示结果"></p><p>从以上结果发现这与之前的理论分析有所出入，插入排序反而比选择排序效率低。具体原因稍后解析，接下来将针对插入排序的特性来进行优化，最后你会发现在某些情况下插入排序的效率不比 O(n*㏒n)差。</p><h4 id="3-代码优化"><a href="#3-代码优化" class="headerlink" title="3. 代码优化"></a>3. 代码优化</h4><p>（1）减少多次交换swap操作</p><p>以上发现插入排序中的内循环可提前结束性质后，可是测试结果却出乎意料。<strong>再仔细观察发现内循环中存在的swap操作比简单的比较操作更加耗时，因为swap交换中其实涉及到了3次赋值步骤，更不用说数组中的索引值访问等消耗时间。</strong></p><p>所以这第一个优化就是<strong>避免在内循环中重复swap，只进行一次赋值操作，在内循环结束后再进行一次赋值操作，彻底避免交换操作。</strong></p><p><img src="/posts/44265/7.gif" alt="优化"></p><ul><li>查看以上GIF演示过程，这里以第三个元素2进行示例讲解（找到元素2应该待的位置）{6,8,2,3,1,5,7,4}：<br>在进行第三个元素2比较之前，先将元素值2复制一份保存起来再开始比较。</li><li>第三个元素2比第二个元素8小，即2不应该在这个位置。此时不进行交换操作，而是进行赋值，将第三个元素赋值为8。</li><li>接下来考虑2是否应该在第二个元素8的位置，将2同第一个元素6比较，比它小，即2不应该在这个位置。此时不进行交换操作，而是进行赋值，将第二个元素赋值为6。<br>最后来看2是否应该放在元素6的位置，发现元素6的位置就是第一个位置，所以最后直接第一个元素赋值为2。</li></ul><p>其实算法的逻辑并无改变，只是将原来满足条件下的一次次交换修改成了赋值操作，性能得到提高。</p><pre class="line-numbers language-C++"><code class="language-C++">    for( int i = 1 ; i < n ; i ++ ) {        // 寻找元素arr[i]合适的插入位置        // 写法3        T e = arr[i];        int j; // j保存元素e应该插入的位置        for (j = i; j > 0 && arr[j-1] > e; j--)            arr[j] = arr[j-1];        arr[j] = e;//赋值操作    }    return;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时再次查看两种算法的时间所耗，发现插入算法已经优于选择排序！</p><p>这里需要注意一点，<strong>插入排序的优异性在于内循环可以提前结束，即在部分有序的数组中进行排序，性能会更加优异，两者的差异会更大。</strong> 而且需要注意的是在处理实际数据时，其实数字之间比较有序，只是个别并无太多无序性，所以插入排序的高效性此时更为有用。</p><p>下面在SortTestHelper中再加入一个辅助函数来生产一个近乎有序的数组供测试用，实现较为简单，代码如下：</p><pre class="line-numbers language-C++"><code class="language-C++">【SortTestHelper.h】// 生成一个近乎有序的数组    // 首先生成一个含有[0...n-1]的完全有序数组, 之后随机交换swapTimes对数据    // swapTimes定义了数组的无序程度:    // swapTimes == 0 时, 数组完全有序    // swapTimes 越大, 数组越趋向于无序    int *generateNearlyOrderedArray(int n, int swapTimes){        int *arr = new int[n];        for(int i = 0 ; i < n ; i ++ )            arr[i] = i;        srand(time(NULL));        for( int i = 0 ; i < swapTimes ; i ++ ){            int posx = rand()%n;            int posy = rand()%n;            swap( arr[posx] , arr[posy] );        }        return arr;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/44265/8.png" alt="结果"></p><p>以上20000个数字，其实任意交换100对数字，最后排序的结果，插入排序明显优于选择排序太多，<strong>这也体现出在特定情况下（近乎有序的数字排序）插入排序的高效性！</strong></p><h2 id="四-冒泡排序"><a href="#四-冒泡排序" class="headerlink" title="四. 冒泡排序"></a>四. 冒泡排序</h2><p>过于简单，就略过了，但是需要注意的是冒泡排序有一个优化版本，叫做梳排序，可以去了解一下。</p><h2 id="五-思维拓展"><a href="#五-思维拓展" class="headerlink" title="五. 思维拓展"></a>五. 思维拓展</h2><h3 id="1-O-n-2-算法思考"><a href="#1-O-n-2-算法思考" class="headerlink" title="1. O(n^2)算法思考"></a>1. O(n^2)算法思考</h3><p>这一篇博文主要学习了O(n^2)的排序算法：</p><ul><li>其中选择排序实现简单，但是弊端明显，两重循环中的每次循环都要完成，效率较慢。</li><li>虽然插入排序的时间复杂度也是O(n^2)，但是在数组近乎有序情况下，效率甚至比 O(n* logn)的还要高，有着重要的实际意义。</li><li>而冒泡排序中不可避免的会有许多交换操作，整体性能没有插入排序好，后续不会经常使用。</li></ul><h3 id="2-希尔排序"><a href="#2-希尔排序" class="headerlink" title="2. 希尔排序"></a>2. 希尔排序</h3><p>在了解了插入排序的优点后，可通过它引出一种新的排序方法，即希尔排序，整体思路就是插入排序衍生，插入排序中是每个元素和之前1个元素进行比较，而希尔排序是每个元素和之前的t个元素进行比较，t从一个大值慢慢缩小成1，无序数组渐变为有序数组，时间复杂度发送质变！时间复杂度为O(n^(3/2))</p><p>注意，希尔排序是不断把步长由长变为短，逻辑分组数量由多变为少，直至步长为1，类比插入排序的两个for循环，希尔排序则是在最后多出了一个控制步长的变量gap，同时里面的递增量也改为了gap，其他和插入排序基本上是相似的</p><pre class="line-numbers language-C++"><code class="language-C++">插入排序:for( int i = 1 ; i < n ; i ++ ) {        // 寻找元素arr[i]合适的插入位置        // 写法3        T e = arr[i];        int j; // j保存元素e应该插入的位置        for (j = i; j > 0 && arr[j-1] > e; j--)            arr[j] = arr[j-1];        arr[j] = e;//赋值操作    }希尔排序:for(int gap=N/2;gap>=1;gap/=2){//此时分好了gap，gap分好后开始执行插入排序    for(int i=gap;i< N; i++){        int tag=a[i];        for(int j=i;a[j-gap]>tag && j>=gap;    j-=gap)            a[j]=a[j-gap]];        a[j]=tag;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>标准代码如下：</p><pre class="line-numbers language-C++"><code class="language-C++">template<typename T>void shellSort(T arr[], int n){    // 计算 increment sequence: 1, 4, 13, 40, 121, 364, 1093...    int h = 1;    while( h < n/3 )        h = 3 * h + 1;    while( h >= 1 ){        // h-sort the array        for( int i = h ; i < n ; i ++ ){            // 对 arr[i], arr[i-h], arr[i-2*h], arr[i-3*h]... 使用插入排序            T e = arr[i];            int j;            for( j = i ; j >= h && e < arr[j-h] ; j -= h )                arr[j] = arr[j-h];            arr[j] = e;        }        h /= 3;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>是不是发现是如此的相似？</p><h4 id="3-下篇预告"><a href="#3-下篇预告" class="headerlink" title="3. 下篇预告"></a>3. 下篇预告</h4><p>虽然ShellSort是这四种排序算法中性能最优的排序算法，但是在排序算法中的最优解还是O(n*logn)，所以在在下一篇博文中进行讲解，涉及的知识点：</p><ul><li>归并排序法思想、实现、优化</li><li>自底向上的归并排序算法</li><li>快速排序法</li><li>随机化快速排序法</li><li>双路快速排序法</li><li>三路快速排序法</li></ul><p>可以说，下一章才是重点~</p><p>该博客转自：<a href="https://blog.csdn.net/ITermeng/article/details/77161877">https://blog.csdn.net/ITermeng/article/details/77161877</a><br>基本上我的笔记内容差不多，方便于大家观看而整理<br>下定决心好好学习这内功心法，算法之路，任重而道远~</p>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Play-with-Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>由Set作业题引发的问题</title>
      <link href="posts/12550/"/>
      <url>posts/12550/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>c++需要着重学指针，引用和动态内存分配，<br>这个问题的背后实际上是C++对象的赋值和复制问题，是Set的成员变量所占内存的销毁问题，因为c++的编码逻辑和内存管理交融在一起，所以这种类型的问题难以发现和解决，而且这个坑也经常遇到，现在记录下来给未来防止踩到类似的这种坑。废话不多说，上代码。</p>   <a id="more"></a><pre class="line-numbers language-C++"><code class="language-C++">Set(Set &s){        n = s.n;        if (n !=0)        {            pS= new  int[n+1];            for (int i =1;i<=n;i++) //集合的下标从1开始，集合中不能有重复元素                pS[i] = s.pS[i];        }    }Set & Set::operator +=(int e){    if(IsEmpty())        pS= new  int[101];    if(!IsElement(e))        pS[++n]=e;    return *this;}    // 向集合中增加元素eSet Set::operator |(const Set &s)const{    Set* re=new Set;    for(int i=1;i<=s.n;i++)            re+=s.pS[i];    for(int i=1;i<=n;i++)        if(!s.IsElement(pS[i]))            (*re)+=pS[i];        return *re;}  //集合并<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p> 所以之前出错的写法 s = s1|s2，就出现了这样的结果：</p><p><img src="/posts/12550/2.png" alt="错误原因"></p><p> 虽然解决方法已经找出来了，就是集合合并的时候返回的是Set的引用即可，但是为什么会发生这种匪夷所思的情况？先上一篇博客康康</p><h3 id="C-：对象的赋值和复制"><a href="#C-：对象的赋值和复制" class="headerlink" title="C++：对象的赋值和复制"></a>C++：对象的赋值和复制</h3><h4 id="3-6-1-对象赋值语句"><a href="#3-6-1-对象赋值语句" class="headerlink" title="3.6.1 对象赋值语句"></a>3.6.1 对象赋值语句</h4><p>如同基本类型赋值语句一样，同类型的对象之间也可以进行赋值，即一个对象的值可以赋给另一个对象。这里所指的对象的赋值是指对其中的数据成员赋值，而不对成员函数赋值。例如：A和B是同一类的两个对象，那么下述对象赋值语句B=A；就能把对象A的数据成员的值逐位复制给对象B</p><pre class="line-numbers language-C++"><code class="language-C++">//例3.24 对象赋值语句示例#include<iostream>using namespace std;class Myclass{ public:       void set(int i,int j)       {        a = i;        b = j;       }       void show()       {        cout<<a<<" "<<b<<endl;       } private:       int a,b;       }; int main(){ Myclass o1,o2; o1.set(20,5); o2 = o1;          //将对象o1的值赋给对象o2  o1.show(); o2.show(); return 0;} 该程序中，语句：   o2 = o1; 等价于语句：   o2.a = o1.a;   o2.b = o1.b;    因此，运行此程序将显示：55  说明：  1、在使用对象赋值语句进行对象赋值时，两个对象的类型必须相同，如对象的类型不同，     编译时将出错。  2、两个对象之间的赋值，仅仅使这些对象中数据成员相同，而两个对象仍是分离的。例如     本例对象后，再调用o1.set()设置o1的值，不会影响o2的值。  3、对象赋值是通过默认赋值运算符函数实现的  4、将一个对象的值赋给另一个对象时，多数情况下都是成功的，但当类中存在指针时，可能     会产生错误。              <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-6-2-拷贝构造函数"><a href="#3-6-2-拷贝构造函数" class="headerlink" title="3.6.2 拷贝构造函数"></a>3.6.2 拷贝构造函数</h4><p>拷贝构造函数是一种特殊的构造函数，其形参是本类对象的引用。拷贝构造函数的作用是，在建立一个新对象时，使用一个已经存在的对象去初始化这个新对象。</p><p>例如： Point p2(p1)；</p><p>其作用是：在建立新对象p2时，用已经存在的对象p1去初始化对象p2，在这个过程中就要调用拷贝构造函数。<br>拷贝构造函数具有以下特点：</p><p>（1）因为该函数也是一种构造函数，所以其函数名与类名相同，并且该函数也没有返回值类型。</p><p>（2）该函数只有一个参数，并且是同类对象的引用</p><p>（3）每一个类都必须有一个拷贝构造函数。程序员可以自定义拷贝构造函数，用于按照需要初始化新对象。如果程序员没有定义类的拷贝构造函数，系统就会自动生成产生一个默认的拷贝构造函数，用于复制出数据成员值完全相同的新对象。</p><ol><li><p>自定义拷贝构造函数<br>一般格式： 类名::类名(const 类名 &amp;对象名)<br>{<br>//拷贝构造函数的函数体<br>}<br>下面是一个用户自定义的拷贝构造函数：<br>class Point<br>{<br>public:<br> Point(int a,int b) //构造函数<br> {<br> x = a;<br> y = b;<br> }<br> Point(const Point &amp;p) //拷贝构造函数<br> {<br> x = 2<em>p.x;<br> y = 2</em>p.y;<br> }<br>  …..<br> private:<br> {<br> int x;<br> int y;<br> }; </p><p> 假如p1为类Point的一个对象，则下述语句可以在建立新对象p2时调用拷贝构造函数初始化p2；Point p2(p1);//例3.25 自定义拷贝构造函数的使用。</p></li></ol><pre class="line-numbers language-C++"><code class="language-C++">#include<iostream>using namespace std;class Point{       public:             Point(int a,int b)  //普通构造函数              {               x = a;               y = b;             }             Point::Point(const Point &p) //自定义的拷贝构造函数              {               x = 2*p.x;               y = 2*p.y;             }             void print()             {              cout<<x<<" "<<y<<endl;              }       private:               int x;               int y;         };int main(){ Point p1(30,40);       //定义对象p1，调用了普通的构造函数 Point p2(p1);          //调用拷贝构造函数，用对象p1初始化对象p2  p1.print(); p2.print(); return 0; }   本例中定义对象p2时，调用了自定义拷贝构造函数。程序运行结果如下：40 80    调用拷贝构造函数的一般形式为：    类名 对象2(对象1);    上面的这种拷贝构造函数的方法称为“代入法”。除了用代入法调用拷贝构造函数外，还可以采用"赋值法"调用拷贝构造函数,与基本类型的变量初始化类似.这种调用方的一般格式为：    类名 对象2=对象1;    当然，这种方法可以在一个语句中进行多个对象的复制。如    Point p2=p1,p3=p1; 如将例3.25主函数main改为如下形式：int main(){ Point p1(10,20); Point p2=p1;  //以赋值法调用拷贝构造函数  p1.print(); p2.print(); return 0; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><p>默认的拷贝构造函数(程序员没有定义，系统会自动生成)</p><p> // 例3.26 默认的拷贝构造函数</p></li></ol><pre class="line-numbers language-C++"><code class="language-C++">#include<iostream>using namespace std;class Point{ public:        Point(int a,int b) //普通的构造函数         {         x = a;         y = b;        }//        Point::Point(const Point &p)//不用写，系统会默认存在（需要用时直接调用） //        {//         x = p.x;//         y = p.y;//        }        void print()        {         cout<<x<<" "<<y<<endl;        }  private:        int x;        int y;};int main(){        Point p1(30,40);  //调用普通构造函数         Point p2(p1);     //用代入法调用默认的拷贝构造函数,用对象p1初始化对象p2         Point p3=p1;      //用赋值法调用默认的拷贝构造函数,用对象p1初始化对象p3        p1.print();        p2.print();        p3.print();        return 0;          }    调用拷贝构造函数的方法有两种：代入法、赋值法   代入法：Point p2(p1)   赋值法：Point p2=p1 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-调用拷贝构造函数的三种情况"><a href="#3-调用拷贝构造函数的三种情况" class="headerlink" title="3.调用拷贝构造函数的三种情况"></a>3.调用拷贝构造函数的三种情况</h5><p>（1）当用类的一个对象去初始化另一个对象时，拷贝构造函数将会被调用，如例3.26主函数中的下属语句<br>Point p2(p1); //用代入法调用默认的拷贝构造函数,用对象p1初始化对象<br>p2 Point p3=p1; //用赋值法调用默认的拷贝构造函数,用对象p1初始化对象p3</p><p>（2）当函数的形参是类的对象，在调用函数进行形参和实参结合时，拷贝构造函数将会被调用例如：</p><p>void fun1(Point p) //形参是类Point的对象p<br>{<br>p.print(); }<br>int main(){<br>point p1(10,20);<br>fun1(p1); //调用函数fun1时，实参p1是类Point的对象<br>//将调用拷贝构造函数，初始化形参对象p<br>return 0; }</p><p><strong>理解：在main函数内，执行语句“fun1(p1)”,便是这种情况。在调用这个函数时，对象p1是实参用它来初始化被调用函数的形参p时，需要调用拷贝构造函数。这时，如果类Point中有自定义的拷贝构造函数时，就调用拷贝的构造函数，否则就调用系统自动生成的默认拷贝构造函数</strong></p><p>（3）当函数的 返回值是类的对象，在函数调用完毕将返回值（对象）带回调用处时。此时将会调用拷贝构造函数，将此对象赋值给一个临时对象并传到该函数的调用处。<br>例如： Point fun2() //函数fun2()的返回值类型是Point类类型 {<br>Point p1(10,30);<br>//定义类Point的对象p1<br>return p1; // 函数的返回值是Point类的对象<br>}<br>int main(){<br>Point p2; //定义类Point的对象p1<br>p2=fun2(); //函数执行完成，返回调用者时，调用拷贝构造函数(赋值法)<br>return 0;<br>} </p><p><strong>理解：由于对象p1是函数fun2中定义的，在调用函数fun2结束时，p1的生命周期结束了，因此在函数fun2结束之前，执行语句”return p1”时，将会调用拷贝构造函数将p1的值复制到一个临时对象中，这个临时对象是系统在主程序中临时创建的。函数运行结束时，p1对象消失，但是临时对象将会通过语句”p2=fun2()”将它的值赋给对象p2，执行完这个语句后，临时对象变自动消失了。</strong></p><hr><blockquote><p>  这里的描述符合我们遇到的这个情况，也就是=赋值，和函数返回时出现的问题，因为按照c++语法，只有用一个新的对象 Class newObj = oldOject 时，才会调用这个类的“拷贝构造函数”，把oldOject 的所有成员变量复制给newObj ，如果是用一个已存在的对象 existObj = oldObject，则不会调用“拷贝构造函数”。<br>   对比 Set tmp = s1|s2 和 s = s1|s2 ，发现主要是函数返回时，前者只销毁了函数内的局部变量re，后者销毁re还销毁了作为返回值的Set对象，这是编译器识别了Set tmp = s1|s2，认为需要替你保留返回值，所以没销毁，而s = s1|s2 这种写法应该本身就是不被语法认可的。<br>   同理，你可以观察(s1|s2).Show() 这种写法，发现返回值是在Show()方法调用后，才被销毁的，所以就能归功到编译器了，是编译器识别了 | 方法被调用的地方的需求，然后对返回值采取了不同的操作。<br>   等学了编译原理，和c++ 的调用惯例就能深刻理解了</p></blockquote><p>   <img src="/posts/12550/3.png" alt="赋值"></p><p>   <img src="/posts/12550/4.png" alt="(s1|s2).Show()"></p><p>最后有两个类似的例子，以供参考</p><hr><pre class="line-numbers language-C++"><code class="language-C++">//例3.27  演示调用拷贝构造函数的3中情况#include<iostream>using namespace std;class Point{  public:          Point(int a=0,int b=0); //声明构造函数          Point::Point(const Point &p); //声明拷贝构造函数        void print()        {          cout<<x<<" "<<y<<endl;         }   private:        int x,y;}; Point::Point(int a,int b)  //定义构造函数 {   x = a;   y = b;   cout<<"Using normal constructor\n";}Point::Point(const Point &p)//定义拷贝构造函数 {   x = 2 * p.x;   y = 2 * p.y;   cout<<"Using copy constructor\n"; } void fun1(Point p)    //形参是类Point的对象p{   p.print(); }Point fun2()  //函数fun2()的返回值类型是Point类类型 {   Point p4(10,30);  //定义类Point的对象p4    return p4;        // 函数的返回值是Point类的对象 } int main(){   Point p1(30,40);//定义对象p1时，第1次调用普通的构造函数    p1.print();         Point p2(p1); //用带入法，用对象p1为对象p2进行初始化。此时会第1次调用拷贝构造函数    p2.print();   Point p3=p1; //用赋值法，用对象p1为对象p3进行初始化。此时会第2次调用拷贝构造函数    p3.print();   fun1(p1);  //在调用fun1函数，实参和形参结合时， 此时会第3次调用拷贝构造函数    p2=fun2(); //在调用fun2函数，在函数内部第2次调用普通构造函数。而且，当调用fun2函数结束时,              //还是用赋值法，用返回的对象p4为对象p2进行赋值，会第4次调用拷贝构造函数    p2.print();   return 0;  } 运行结果：          Using normal constructor           30    40           Using Cpy constructor           60    80           Using Cpy constructor           60    80           Using Cpy constructor           60    80           Using normal constructor          Using Cpy constructor          20    60当没有自定义的拷贝构造函数时的运行结果:        Using normal constructor           30    40           30    40           30    40            30    40           Using normal constructor          10    30         <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="再举一个实例为："><a href="#再举一个实例为：" class="headerlink" title="//再举一个实例为："></a>//再举一个实例为：</h4><pre class="line-numbers language-C++"><code class="language-C++">#include<iostream>using namespace std;class Point{  public:    Point(int a,int b)     {       x = a;       y = b;     }     /* Point::*/Point(const Point &p) //拷贝构造函数(用初始化过的对象为没有初始化过的对象进行初始化)      {       x = 2 * p.x;       y = 2 * p.y;     }     Point& operator = (const Point &p)//赋值运算符重载函数(用初始化过的对象为初始化过的对象进行赋值)      {       x = p.x;       y = p.y;     }     Point fun();     void print()     {       cout<<x<<" "<<y<<endl;     }   private:        int x,y;     };Point::Point fun(Point p4){    return p4; }int main(){  Point p1(10,20);  Point p3(15,15);  p3=p1;//调用赋值运算符重载函数   p3.print();  Point p2 = fun(p1);//调用fun函数时，实参和形参结合，会第1次调用拷贝构造函数；调用fun函数结束时，   p2.print() ;         // 返回的对象p4为未初始化的p2进行初始化，会第2次调用拷贝构造函数 }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>目前已经反馈给教师，等待老师的回答！</p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪吃蛇C++教程</title>
      <link href="posts/3192/"/>
      <url>posts/3192/</url>
      
        <content type="html"><![CDATA[<p>概述</p><blockquote><p>  整个程序设计的原理就是：主函数死循环，不断刷新打印贪吃蛇和食物。这样每循环一次，就类似电影里面的一帧，最终显示的效果就是蛇会动起来。下面会有一一讲解的,主要涉及到一些类的设计</p></blockquote><a id="more"></a><h3 id="01初始化工作-游戏设置"><a href="#01初始化工作-游戏设置" class="headerlink" title="01初始化工作-游戏设置"></a>01初始化工作-游戏设置</h3><hr><blockquote><p>游戏设置和相关初始化放在了一个类里面，并进行了静态声明。主要设置了游戏窗口的长和款。并在GameInit()函数里面设置了窗口大小，隐藏光标，初始化随机数种子等。代码如下：</p></blockquote><pre class="line-numbers language-C++"><code class="language-C++">//游戏设置相关模块，把函数都放到一个类里面了。函数定义为static静态成员，不生成实体也可以直接调用class GameSetting{public:    //游戏窗口的长宽        static const int window_height = 40;        static const int window_width = 80;public:        static void GameInit()    {//设置游戏窗口大小        char buffer[32];              sprintf_s(buffer, "mode con cols=%d lines=%d",window_width, window_height);               system(buffer); //隐藏光标HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE);        CONSOLE_CURSOR_INFO CursorInfo;         GetConsoleCursorInfo(handle, &CursorInfo);//获取控制台光标信息        CursorInfo.bVisible = false; //隐藏控制台光标        SetConsoleCursorInfo(handle, &CursorInfo);//设置控制台光标状态        //初始化随机数种子               srand((unsigned int)time(0));        }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="02-打印信息类"><a href="#02-打印信息类" class="headerlink" title="02 打印信息类"></a>02 打印信息类</h4><p>该类主要是用来打印一些游戏相关信息的。该类大体如下：</p><pre class="line-numbers language-C++"><code class="language-C++">class printInfo{public:         //画地图边界       static void DrawMap();         //游戏结束       static void Gameover(int score);         //画分数       static void DrawScore(int score);         //画游戏操作说明       static void DrawGameInfo(bool model);};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面挑几个重点的来讲：</p><h5 id="2-1-画地图边界"><a href="#2-1-画地图边界" class="headerlink" title="2.1 画地图边界"></a>2.1 画地图边界</h5><blockquote><p>这个函数主要是根据上面所给的游戏窗口长宽来打印地图边界的。其中还划分了几个区域，主要用来放不同的信息的。</p></blockquote><pre class="line-numbers language-C++"><code class="language-C++">//画地图边界static void DrawMap(){        system("cls");        int i, j;        for (i = 0; i < GameSetting::window_width; i++)        cout << "#";    cout << endl;    for (i = 0; i < GameSetting::window_height-2; i++)    {                for (j = 0; j < GameSetting::window_width; j++)        {            if (i == 13 && j >= GameSetting::window_width - 29)                {                    cout << "#";                    continue;                }      if (j == 0 || j == GameSetting::window_width - 29 || j == GameSetting::window_width-1)        {             cout << "#";        }        else             cout << " ";    }    cout << endl;}for (i = 0; i < GameSetting::window_width; i++)    cout << "#";}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h5 id="2-2-画出分数和模式"><a href="#2-2-画出分数和模式" class="headerlink" title="2.2 画出分数和模式"></a>2.2 画出分数和模式</h5><hr><blockquote><p>该函数主要是在右上角画出成绩和游戏模式的，在绘制之前会进行刷新处理。先清除，再重新打印。用到了一个gotoxy()函数。这个函数主要是移动光标到(x, y)坐标处的。关于(x, y)的位置，根据实际情况调整即可。</p></blockquote><pre class="line-numbers language-C++"><code class="language-C++">//画分数static void DrawScore(int score){    gotoxy(GameSetting::window_width - 22+14, 6);    cout << "  ";    gotoxy(GameSetting::window_width - 22+14, 4);    cout << "  ";    gotoxy(GameSetting::window_width - 22, 6);    cout << "当前玩家分数: " << score << endl;    gotoxy(GameSetting::window_width - 22, 4);    cout << "当前游戏速度: " << 10 - speed / 25 << endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="食物类"><a href="#食物类" class="headerlink" title="食物类"></a>食物类</h4><blockquote><p>食物类定义了食物的坐标，随机生成规则，和画出食物等一系列操作。其中食物坐标我们用了一个结构体：</p></blockquote><pre class="line-numbers language-C"><code class="language-C">typedef struct2{    int x;    int y;}COORDINATE;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>该结构体两个成员，分别保存坐标的(x, y)。蛇身的坐标也会用到这个结构体。有关食物类的大体如下：</p></blockquote><pre class="line-numbers language-C++"><code class="language-C++">class Food{private:    //食物坐标     COORDINATE m_coordinate;public:    //坐标范围     //x：1 to gemeSetting::windos_width-30      //y：1 to gemeSetting::windos_width-2    void RandomXY(vector<COORDINATE> &coord) {}    //默认构造函数     Food(){}    //构造函数 传入参数为蛇身坐标     Food(vector<COORDINATE> &coord){}    //画出食物的位置     void DrawFood(){}    //接口,获取食物位置     COORDINATE GetFoodCoordinate(){}};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h5 id="3-1-随机生成食物"><a href="#3-1-随机生成食物" class="headerlink" title="3.1 随机生成食物"></a>3.1 随机生成食物</h5><blockquote><p>随机生成食物，<strong>原则上不允许食物出现在蛇身的位置上</strong>，如果有。我们重新生成。注意地图的范围，就是区域左边一块。实际情况根据自身的地图范围来调整食物坐标的范围，注意不要越界。用rand()函数获得随机坐标。代码如下：</p></blockquote><pre class="line-numbers language-C++"><code class="language-C++">void RandomXY(vector<COORDINATE> & coord) {     m_coordinate.x = rand() % (GameSetting::window_width - 30) + 1;     m_coordinate.y = rand() % (GameSetting::window_height - 2) + 1;     unsigned int i;     //原则上不允许食物出现在蛇的位置上，如果有，重新生成     for (i = 0; i < coord.size(); i++)     {        //食物出现在蛇身的位置上。重新生成        if (coord[i].x == m_coordinate.x && coord[i].y == m_coordinate.y)        {            m_coordinate.x = rand() % (GameSetting::window_width - 30) + 1;            m_coordinate.y = rand() % (GameSetting::window_height - 2) + 1;            i = 0;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h5 id="3-2-画出食物"><a href="#3-2-画出食物" class="headerlink" title="3.2 画出食物"></a>3.2 画出食物</h5><blockquote><p>画出食物比较简单了，gotoxy到随机生成的坐标之后，cout就行。我们在这还设置了一个食物颜色为红色。代码如下：</p></blockquote><pre class="line-numbers language-C"><code class="language-C">void DrawFood(){    setColor(12, 0);    gotoxy(m_coordinate.x, m_coordinate.y);    cout << "@";    setColor(7, 0);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="04-贪吃蛇类"><a href="#04-贪吃蛇类" class="headerlink" title="04 贪吃蛇类"></a>04 贪吃蛇类</h4><blockquote><p>定义贪吃蛇的移动，打印，吃食物等等。这节课我们暂时不讨论AI功能，先把手动操作的贪吃蛇做了跑起来，下节课再做AI功能的介绍。该类大体如下：</p></blockquote><pre class="line-numbers language-C++"><code class="language-C++">//贪吃蛇类，定义贪吃蛇的移动，打印，吃食物等待//地图范围 width: 2 to width-2  height: 2 to height-2class Snake{private:    int m_direction;    bool m_is_alive;public://蛇身坐标     vector<COORDINATE> m_coordinate;public:    Snake(){}    //监听键盘    void listen_key_borad(){}     //检测是否碰到自己    bool self_collision(COORDINATE head){}    //移动贪吃蛇    void move_snake(){}    //判断是否吃到食物    bool is_eat_food(Food &f){}    //判断是否die    bool snake_is_alive(){}    //draw    void draw_snake(){}    //清屏    void ClearSnake(){}    //获取贪吃蛇的长度    int GetSnakeSize(){} };<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h5 id="4-1-成员变量"><a href="#4-1-成员变量" class="headerlink" title="4.1 成员变量"></a>4.1 成员变量</h5><blockquote><p>成员变量m_direction记录每次移动的方向。m_is_alive记录贪吃蛇是否还活着。m_coordinate则是贪吃蛇身体坐标的记录。贪吃蛇是一节一节的，整条蛇必然是由许多节组成的。因此用了一个vector来存储蛇身，每节类型是COORDINATE结构体的。</p></blockquote><hr><h5 id="4-2-默认构造函数"><a href="#4-2-默认构造函数" class="headerlink" title="4.2 默认构造函数"></a>4.2 默认构造函数</h5><blockquote><p>默认构造函数Snake()里面主要是做了初始贪吃蛇的生成，以及移动方向的定义等。初始的蛇为3节。在中间位置，向上移动。代码如下：</p></blockquote><pre class="line-numbers language-C++"><code class="language-C++">Snake(){      //移动方向向上    m_direction = 1;    m_is_alive = true;    COORDINATE snake_head;    //蛇头生成位置    snake_head.x = GameSetting::window_width / 2 - 15;    snake_head.y = GameSetting::window_height / 2;    this->m_coordinate.push_back(snake_head);    snake_head.y++;    this->m_coordinate.push_back(snake_head);    snake_head.y++;    this->m_coordinate.push_back(snake_head); //初始蛇身长度三节}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h5 id="4-3-监听键盘"><a href="#4-3-监听键盘" class="headerlink" title="4.3 监听键盘"></a>4.3 监听键盘</h5><blockquote><p>监听键盘用了C里面的一个库函数。_kbhit()非阻塞函数，可以不断监听键盘的情况从而不产生阻塞。有键盘按下的时候，就获取按下的键盘是哪个。然后做出相应的变化，其实是方向的调整。需要注意的是，当我们的蛇往上走的时候，按下方向的键，我们是不做处理的。其它方向一样。还有一个调整游戏速度的，speed是休眠时间，speed越小，速度越快。反之速度越慢。</p></blockquote><pre class="line-numbers language-C++"><code class="language-C++">    //监听键盘void listen_key_borad(){    char ch;    if (_kbhit())                    //kbhit 非阻塞函数     {        ch = _getch();    //使用 getch 函数获取键盘输入         switch (ch)        {        case 'w':        case 'W':            if (this->m_direction == DOWN)                break;            this->m_direction = UP;            break;        case 's':        case 'S':            if (this->m_direction == UP)                break;            this->m_direction = DOWN;            break;        case 'a':        case 'A':            if (this->m_direction == RIGHT)                break;            this->m_direction = LEFT;            break;        case 'd':        case 'D':            if (this->m_direction == LEFT)                break;            this->m_direction = RIGHT;            break;        case '+':            if (speed >= 25)            {                speed -= 25;            }            break;        case '-':            if (speed < 250)            {                speed += 25;            }            break;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="4-4-移动贪吃蛇"><a href="#4-4-移动贪吃蛇" class="headerlink" title="4.4 移动贪吃蛇"></a>4.4 移动贪吃蛇</h4><blockquote><p><strong>移动贪吃蛇，我们用了一个方向变量，在监听键盘的时候获取移动的方向，然后在根据方向移动贪吃蛇的蛇头。这里的移动我们是这样处理的，首先，贪吃蛇每移动一次，需要改变的只有蛇头和蛇尾两节。我们只需要把新的蛇头插进去，最后再画出来就可以了。至于蛇尾，如果我们不删除蛇尾的话，蛇会不断变长的。因此我们的做法是：吃到食物的时候插入蛇头而不删除蛇尾，没有吃到食物的时候插入蛇头同时删除蛇尾。这样就完美搞定了。</strong></p></blockquote><pre class="line-numbers language-C++"><code class="language-C++">    //移动贪吃蛇void move_snake(){    //监听键盘    listen_key_borad();    //蛇头    COORDINATE head = m_coordinate[0];    //direction方向:1 上  2 下  3 左  4 右    switch (this->m_direction)    {    case UP:        head.y--;        break;    case DOWN:        head.y++;        break;    case LEFT:        head.x--;        break;    case RIGHT:        head.x++;        break;    }    //插入移动后新的蛇头。是否删除蛇尾，在后续吃到食物判断那里做    m_coordinate.insert(m_coordinate.begin(), head);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h5 id="4-5-是否吃到食物"><a href="#4-5-是否吃到食物" class="headerlink" title="4.5 是否吃到食物"></a>4.5 是否吃到食物</h5><blockquote><p>判断是否吃到食物，就是看看蛇头的坐标等不等于食物的坐标。如果等于，就重新生成食物，不删除蛇尾，蛇变长一节。不等于，就删除蛇尾,蛇长不变。</p></blockquote><pre class="line-numbers language-C++"><code class="language-C++">bool is_eat_food(Food & f){    //获取食物坐标    COORDINATE food_coordinate = f.GetFoodCoordinate();    //吃到食物，食物重新生成，不删除蛇尾    if (m_coordinate[HEAD].x == food_coordinate.x && m_coordinate[HEAD].y == food_coordinate.y)    {        f.RandomXY(m_coordinate);        return true;    }    else    {        //没有吃到食物，删除蛇尾        m_coordinate.erase(m_coordinate.end() - 1);        return false;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h5 id="4-6判断蛇是否还存活"><a href="#4-6判断蛇是否还存活" class="headerlink" title="4.6判断蛇是否还存活"></a>4.6判断蛇是否还存活</h5><blockquote><p>判断蛇是否GG，主要是看是否超出边界，是否碰到自己身体其他部分。</p></blockquote><pre class="line-numbers language-C++"><code class="language-C++">//判断贪吃蛇死了没bool snake_is_alive(){    if (m_coordinate[HEAD].x <= 0 ||        m_coordinate[HEAD].x >= GameSetting::window_width - 29 ||        m_coordinate[HEAD].y <= 0 ||        m_coordinate[HEAD].y >= GameSetting::window_height - 1)    {        //超出边界        m_is_alive = false;        return m_is_alive;    }    //和自己碰到一起    for (unsigned int i = 1; i < m_coordinate.size(); i++)    {        if (m_coordinate[i].x == m_coordinate[HEAD].x && m_coordinate[i].y == m_coordinate[HEAD].y)        {            m_is_alive = false;            return m_is_alive;        }    }    m_is_alive = true;    return m_is_alive;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h5 id="4-7-画出贪吃蛇"><a href="#4-7-画出贪吃蛇" class="headerlink" title="4.7 画出贪吃蛇"></a>4.7 画出贪吃蛇</h5><p>画出贪吃蛇比较简单，gotoxy到身体的每一节，然后cout就行。</p><pre class="line-numbers language-C++"><code class="language-C++">//画出贪吃蛇void draw_snake(){    //设置颜色为浅绿色    setColor(10, 0);    for (unsigned int i = 0; i < this->m_coordinate.size(); i++)    {        gotoxy(m_coordinate[i].x, m_coordinate[i].y);        cout << "*";    }    //恢复原来的颜色    setColor(7, 0);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h5 id="4-8-清除屏幕上的贪吃蛇"><a href="#4-8-清除屏幕上的贪吃蛇" class="headerlink" title="4.8 清除屏幕上的贪吃蛇"></a>4.8 清除屏幕上的贪吃蛇</h5><blockquote><p><strong>我们是死循环不断刷新打印贪吃蛇的，因此每移动一次，必然会在屏幕上留下上一次贪吃蛇的痕迹。因此我们每次在画蛇之前，不是添足，而是清理一下上次遗留的蛇身。我们知道，蛇每次移动，变的只有蛇头和蛇尾，因此该函数我们只需要清理蛇尾就行。gotoxy到蛇尾的坐标，cout&lt;&lt;” “;就行。</strong></p></blockquote><pre class="line-numbers language-C"><code class="language-C">void ClearSnake(){gotoxy(m_coordinate[this->m_coordinate.size()-1].x, m_coordinate[this->m_coordinate.size() - 1].y);cout << " ";}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="05-主函数，组装我们的游戏"><a href="#05-主函数，组装我们的游戏" class="headerlink" title="05 主函数，组装我们的游戏"></a>05 主函数，组装我们的游戏</h3><blockquote><p>我们的游戏在主函数里面进行组装。然后开始运行。首先我们做游戏相关的初始化。</p></blockquote><pre class="line-numbers language-C++"><code class="language-C++">GameSetting setting;PrintInfo print_info;Snake  snake;//初始化游戏setting.GameInit();//游戏模式选择print_info.DrawChoiceInfo();char ch = _getch();switch (ch){case '1':    snake.set_model(true);    speed = 50;    break;case '2':    snake.set_model(false);    break;default:    gotoxy(GameSetting::window_width / 2 - 10, GameSetting::window_height / 2 + 3);    cout << "输入错误，Bye！" << endl;    cin.get();    cin.get();    return 0;}gotoxy(GameSetting::window_width / 2 - 10, GameSetting::window_height / 2 + 3);system("pause");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后就是画地图边框，打印游戏相关信息和说明。生成食物了。</p><pre class="line-numbers language-C++"><code class="language-C++">//画地图print_info.DrawMap();print_info.DrawGameInfo(snake.GetModel());//生成食物Food food(snake.m_coordinate);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后就是游戏死循环，在死循环里面，我们需要不断移动蛇，画蛇，判断蛇的状态，判断食物的状态，是否吃到食物等等。具体代码：</p><pre class="line-numbers language-C++"><code class="language-C++">//游戏死循环while (true){    //打印成绩    print_info.DrawScore(snake.GetSnakeSize());    //画出食物    food.DrawFood();    //清理蛇尾，每次画蛇前必做    snake.ClearSnake();    //判断是否吃到食物    snake.is_eat_food(food);    //根据用户模式选择不同的调度方式    if (snake.GetModel() == true)    {        snake.move_snake();    }    else    {        snake.AI_find_path(food);        snake.AI_move_snake();    }    //画蛇    snake.draw_snake();    //判断蛇是否还活着    if (!snake.snake_is_alive())    {        print_info.GameOver(snake.GetSnakeSize());        break;    }    //控制游戏速度    Sleep(speed);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>   转载自：<a href="https://www.cnblogs.com/dengfaheng/p/9384977.html">https://www.cnblogs.com/dengfaheng/p/9384977.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 贪吃蛇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode链表</title>
      <link href="posts/7317/"/>
      <url>posts/7317/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><blockquote><ol><li>了解单链表和双链表的结构;</li><li>在单链表或双链表中实现遍历、插入和删除;</li><li>分析在单链表或双链表中的各种操作的复杂度；</li><li>在链表中使用双指针技巧（快指针慢指针技巧）；</li><li>解决一些经典问题，例如反转链表；</li><li>分析你设计的算法的复杂度；</li><li>积累设计和调试的经验</li></ol></blockquote><a id="more"></a><p>my list：</p><pre class="line-numbers language-C"><code class="language-C">typedef struct Link{    int date;    struct Link* next;} MyLinkedList;/** Initialize your data structure here. */MyLinkedList* myLinkedListCreate() {    MyLinkedList *head=( MyLinkedList*)malloc(sizeof(MyLinkedList));    head->next=NULL;    return head;}/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */int myLinkedListGet(MyLinkedList* obj, int index) {    MyLinkedList *p=obj->next;    int j=0;    while(p!=NULL && j<index) //找到第index个结点    {        j++;        p=p->next;    }    if(p==NULL||index<0)         return -1;    else return p->date;}/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */void myLinkedListAddAtHead(MyLinkedList* obj, int val) {    MyLinkedList* p=obj;    MyLinkedList* newP=( MyLinkedList*)malloc(sizeof(MyLinkedList));    newP->date=val;    newP->next=p->next;    p->next=newP;    return ;}/** Append a node of value val to the last element of the linked list. */void myLinkedListAddAtTail(MyLinkedList* obj, int val) {    MyLinkedList *tmp=obj;    MyLinkedList* newp=( MyLinkedList*)malloc(sizeof(MyLinkedList));    newp->date=val;    newp->next=NULL;    if(tmp==NULL){        obj=newp;        return;    }    while(tmp->next!=NULL){      tmp=tmp->next;    }    tmp->next=newp;    return ;}/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */void myLinkedListAddAtIndex(MyLinkedList* obj, int index, int val) {    MyLinkedList *P=obj->next,*tmp;    if(index<=0)    {        MyLinkedList *newP=( MyLinkedList*)malloc(sizeof( MyLinkedList));        newP->date=val;        newP->next=P;        obj->next=newP;        return;    }    int count=0;    for( ; P!=NULL && count<index-1; count++,P=P->next) ;    if(P==NULL)            return;    if(count<index-1)            return;    MyLinkedList *newP=( MyLinkedList*)malloc(sizeof( MyLinkedList));    newP->date=val;    newP->next=P->next;    P->next=newP;    return;}/** Delete the index-th node in the linked list, if the index is valid. */void myLinkedListDeleteAtIndex(MyLinkedList* obj, int index) {    MyLinkedList *P=obj->next,*deleteP;    int count=0;    if(index<0)        return;    while(P!=NULL && count<index-1){        count++;        P=P->next; }    if(P==NULL)        return;    else{        deleteP=P->next;        if(deleteP==NULL)             return;        else{            if(index==0){                obj->next=obj->next->next;                return;            }            else             P->next=deleteP->next;            free(deleteP);            return;            }        }}void myLinkedListFree(MyLinkedList* obj) {    MyLinkedList *p=obj,*q=obj->next;    while(q!=NULL){    free(p);    p=q;    q=q->next;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><blockquote><p>  设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。<br>  假设链表中的所有节点都是 0-index 的。在链表类中实现这些功能：<br>  get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。<br>  addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。<br>  addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。<br>  deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。 </p></blockquote><hr><h4 id="链表中的双指针"><a href="#链表中的双指针" class="headerlink" title="链表中的双指针"></a>链表中的双指针</h4><blockquote><p>从一个经典问题开始</p><blockquote><p>给定一个链表，判断表中是否有环？<br><em>哈希表中有相应的解决方案，但是这里使用<strong>双指针</strong>有一个更有效的方法</em></p></blockquote><p>想象一下，有两个速度不同的跑步者。如果他们在直路上行驶，快跑者将首先到达目的地。但是，如果它们在圆形跑道上跑步，那么快跑者如果继续跑步就会追上慢跑者。这正是我们在链表中使用两个速度不同的指针时会遇到的情况：<br><strong>1. 如果没有环，快指针将停在链表的末尾。<br>2. 如果有环，快指针最终将与慢指针相遇。</strong><br>所以剩下的问题是：这两个指针的适当速度应该是多少？</p><p>一个安全的选择是每次移动慢指针一步，而移动快指针两步。每一次迭代，快速指针将额外移动一步。如果环的长度为 M，经过 M 次迭代后，快指针肯定会多绕环一周，并赶上慢指针。那其他选择呢？它们有用吗？它们会更高效吗？</p></blockquote><hr><h4 id="判断链表是否交叉"><a href="#判断链表是否交叉" class="headerlink" title="判断链表是否交叉"></a>判断链表是否交叉</h4><p> 因为链表长度是不同的，因此在判断是否交叉的时候，可以设计双指针，即先通篇遍历完两次，看末尾的地址是否相同，若相同则肯定交叉，然后开始判断。因为正如上文所说，链表的长度不一定的，因为必有长短（或者相同），先遍历求出长度，求出长度后，就有长度差，长的链表先移动长度差的距离后，两个链表就在同一个起点上，开始一起遍历，因此时间复杂度是o（n）（遍历了3次）<br> 下面是代码</p><pre class="line-numbers language-C"><code class="language-C">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     struct ListNode *next; * }; */struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {    if(headA==NULL || headB==NULL)        return NULL;    struct ListNode *p1=headA,*p2=headB;    int len1=0,len2=0,diff=0;             while((p1->next)!=NULL){        len1++;        p1=p1->next;    }    while((p2->next)!=NULL){        len2++;        p2=p2->next;    }    if(p1!=p2)        return NULL;          else{        if(len1>len2){        p1=headA;        p2=headB;        diff=len1-len2;        }        else{        p1=headB;        p2=headA;        diff=len2-len1;        }        for(int i=0;i<diff;i++){        p1=p1->next;        }        while(p1!=p2){        p1=p1->next;        p2=p2->next;        }        return p1;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h2 id="图的存储方法"><a href="#图的存储方法" class="headerlink" title="图的存储方法"></a>图的存储方法</h2><blockquote><p><em>在存储无向图和有向图时，其存储方法有所不同</em><br><strong>大致上可以用：</strong></p><ul><li>邻接矩阵：数组表达</li><li>邻接表：链表（多用于有向图）</li><li>十字链表：链表（多用于有向图）</li><li>邻接多重表：链表（无向图）</li></ul></blockquote><h5 id="邻接矩阵–数组存储"><a href="#邻接矩阵–数组存储" class="headerlink" title="邻接矩阵–数组存储"></a>邻接矩阵–数组存储</h5><p><strong>顶点的表达</strong>：由顶点索引和顶点数据构成 因此弧也就与邻接矩阵相关</p><pre class="line-numbers language-C"><code class="language-C">struct Node{    顶点索引;    顶点数据;};struct Map{    顶点数组;//包含顶点    邻接矩阵;//顶点与边的表示都包含了};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h5 id="邻接表–链式存储"><a href="#邻接表–链式存储" class="headerlink" title="邻接表–链式存储"></a>邻接表–链式存储</h5><blockquote><p>邻接表与逆邻接表</p></blockquote><p><strong>顶点的表达</strong>:顶点索引 | <u>出弧链表头指针</u> | 顶点数据<br><strong>弧的表达</strong>：弧头顶点索引 | 下一条弧指针 | 弧数据</p><pre class="line-numbers language-C"><code class="language-C">struct Node{    顶点索引;    该顶点弧链表的头结点    顶点数据;};struct Arc{    指向的顶点索引;    指向下一条弧的指针;    弧信息;};struct Map{    顶点数组;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h5 id="十字链表–链式存储"><a href="#十字链表–链式存储" class="headerlink" title="十字链表–链式存储"></a>十字链表–链式存储</h5><p><strong>顶点的表达</strong>：<br>顶点索引 | 顶点数据 | 以该顶点为弧尾的弧结点指针 | 以该顶点为弧头的弧结点指针<br><strong>弧的表达</strong>：<br>弧尾顶点索引 | 弧头顶点索引 | 弧尾相同的下一条弧的指针 | 弧头相同的下一条弧的指针 | 弧的数据</p><pre class="line-numbers language-C"><code class="language-C">struct Node{    顶点索引;    顶点数据;    第一条入弧结点指针;    第一条出弧结点指针;};struct Arc{    弧尾顶点索引;    弧头顶点索引;    指向下一条弧头相同的弧的指针;    指向下一条弧尾相同的弧的指针;    弧信息;};struct Map{    顶点数组;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h5 id="邻接多重表–链式存储"><a href="#邻接多重表–链式存储" class="headerlink" title="邻接多重表–链式存储"></a>邻接多重表–链式存储</h5><p><strong>顶点的表达</strong>：<br>顶点索引 | 顶点数据 | 连接该顶点的边 |<br><strong>弧的表达</strong>：<br>A顶点索引 | B顶点索引 | 与A顶点相连接的下一条边的指针 | 与B顶点相连接的下一条边的指针 | 弧的数据</p><pre class="line-numbers language-C"><code class="language-C">struct Node{    顶点索引;    顶点数据;    第一条边结点指针;};struct Egde{    顶点A索引;    顶点B索引;    连接A的下一条边的指针;    连接B的下一条边的指针;    弧信息;};struct Map{    顶点数组;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
