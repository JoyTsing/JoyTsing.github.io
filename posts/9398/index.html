<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="MySQL技术内幕-InnoDB存储引擎(一), 博客 joytsing blog"><meta name="description" content="MySQL技术内幕是个啥"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="theme-color" content="white"><title>MySQL技术内幕-InnoDB存储引擎(一) | JoyTsing</title><link rel="apple-touch-icon" href="/"><link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="/favicon.ico"><link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css"><link rel="stylesheet" type="text/css" href="/libs/aos/aos.css"><link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css"><link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" type="text/css" href="/css/matery.css"><link rel="stylesheet" type="text/css" href="/css/my.css"><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style><script src="/libs/jquery/jquery.min.js"></script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="JoyTsing" type="application/atom+xml"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><img src="/apple-touch-icon.png" class="logo-img" alt="LOGO"> <span class="logo-span">JoyTsing</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fa fa-home"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-tags"></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-bookmark"></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-archive"></i> <span>归档</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa fa-user-circle-o"></i> <span>关于</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa fa-envelope"></i> <span>留言</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa fa-address-book"></i> <span>友链</span></a></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fa fa-search" title="搜索"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="/medias/avatars/touxiang2.jpg" class="logo-img circle responsive-img"><div class="logo-name">JoyTsing</div><div class="logo-desc">joytsing的个人博客</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="m-nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-fw fa-bookmark"></i> 分类</a></li><li class="m-nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li class="m-nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa fa-fw fa-user-circle-o"></i> 关于</a></li><li class="m-nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa fa-fw fa-envelope"></i> 留言</a></li><li class="m-nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa fa-fw fa-address-book"></i> 友链</a></li><li><div class="divider"></div></li><li><a href="https://github.com/JoyTsing" class="waves-effect waves-light" target="_blank"><i class="fa fa-github-square fa-fw"></i>Follow Me</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#000;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href="https://github.com/JoyTsing" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Follow Me" data-position="left" data-delay="50"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a></nav></header><div class="bg-cover pd-header post-cover" style="background-image:url(/medias/featureimages/8.jpg)"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">MySQL技术内幕-InnoDB存储引擎(一)</h1></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{width:345px;padding-left:20px}.toc-widget .toc-title{margin:35px 0 15px 0;padding-left:17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content{height:calc(100vh - 250px);overflow:auto}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px;position:absolute;right:23.5vw;display:block}#toc-content .is-active-link{color:#42b983}#floating-toc-btn{position:fixed;right:15px;bottom:76px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"><span class="chip bg-color">原理剖析</span> </a><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="chip bg-color">读书笔记</span> </a><a href="/tags/MySQL/"><span class="chip bg-color">MySQL</span> </a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="chip bg-color">数据库</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/MySQL/" class="post-category">MySQL</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp; 2024-03-20</div><div class="post-date info-break-policy"><i class="fa fa-calendar-check-o fa-fw"></i>更新日期:&nbsp;&nbsp; 2024-03-28</div><div class="info-break-policy"><i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp; 8.7k</div><div class="info-break-policy"><i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp; 30 分</div><div id="busuanzi_container_page_pv" class="info-break-policy"><i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp; <span id="busuanzi_value_page_pv"></span></div></div></div><hr class="clearfix"><div class="card-content article-card-content"><div id="articleContent"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这是一份读书笔记，之前一直写在本地没有上传到博客上，同步一下也方便自己。</p><h2 id="第1章-MYSQL体系结构和存储引擎"><a href="#第1章-MYSQL体系结构和存储引擎" class="headerlink" title="第1章 MYSQL体系结构和存储引擎"></a>第1章 MYSQL体系结构和存储引擎</h2><p><strong>数据库</strong>和<strong>实例</strong>：</p><blockquote><p><code>数据库</code>：物理操作系统文件或者其他形式文件类型的集合。在Mysql中，<strong>数据库文件可以是frm、ibd、MYD等形式的文件。</strong><br><code>实例</code>：<strong>Mysql数据库由后台线程以及一个共享内存区组成</strong>，而共享内存区可以被运行的后台线程共享。（数据库实例才是真正用于操作数据库文件的角色）<br>从概念上来说，数据库是文件的集合；数据库实例则是程序，是位于用户与操作系统之间的一层数据管理软件，所有对数据库的操作都要通过这层抽象层进行</p></blockquote><p>MySQL数据库实例在系统上的表现就是一个进程，<strong>用户对数据库数据的任何操作</strong>，包括数据库定义、数据查询、数据维护、数据库运行控制等<strong>都是在数据库实例下进行的</strong>，<strong>应用程序只有通过数据库实例才能和数据库打交道。</strong></p><p>MySQL具体的体系结构可以分为下面几种：</p><ol><li><strong>连接池</strong>：管理、缓冲用户的连接，线程处理等需要缓存的需求。</li><li><strong>管理服务和工具组件</strong>：系统管理和控制工具，例如备份恢复、Mysql复制、集群等 。</li><li><strong>sql接口</strong>：接受用户的SQL命令，并且返回用户需要查询的结果。</li><li><strong>查询解析器</strong>：SQL命令传递到解析器的时候会被解析器验证和解析。(权限、语法结构)</li><li><strong>查询优化器</strong>：SQL语句在查询之前会使用查询优化器对查询进行优化。</li><li><strong>缓存</strong>：如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。</li><li><strong>插入式存储引擎</strong>：存储引擎说白了就是如何管理操作数据（存储数据、如何更新、查询数据等）的一种方法。因为在关系数据库中数据的存储是以表的形式存储的，所以存储引擎也可以称为表类型。（即存储和操作此表的类型）</li><li><strong>物理文件</strong></li></ol><p>MySQL区别于其他数据的<strong>最重要的特点就是其插件式的表存储引擎</strong>，这个表存储引擎是基于表，而不是数据库，即进行存储操作等都是通过record等来进行操作。在你实际使用的过程中，存储引擎是透明的。</p><h3 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a>InnoDB引擎</h3><p>InnoDB是第一个完整支持ACID事务的Mysql存储引擎（DBD是第一个支持事务的InnoDB存储引擎，但是注意前面还带了个ACID！别搞混了）</p><ol><li><strong>InnoDB存储引擎支持事务</strong>，其特点是<strong>行锁设计、支持外键</strong>、支持非锁定锁（即默认读取操作不会产生锁）。并且Mysql5.5.8版本起，默认的存储引擎就是InnoDB了。</li><li>InnoDB通过<strong>使用多版本并发控制MVCC来获得高并发性，并且实现了SQL标准的4种隔离级别</strong>，默认是Repeatable级别（重复读）。</li><li><strong>使用一种被称为next-key的连接锁策略来避免幻读的产生</strong>。</li><li>InnoDB还<strong>提供了插入缓冲、二次写、自定义哈希索引、预读等4大特性</strong>。</li><li>InnoDB引擎采用了聚集的方式，因此每张表的存储都是按照主键的顺序进行存放。</li><li>如果没有显式的在表中定义主键，那么InnoDB会为每一行生成一个6字节大小的RowId，并以此为主键。（换句话说，无论咋样，一张表必有主键）</li></ol><p>拓展：</p><blockquote><p><code>那么Mysql的事务是怎么实现的？</code><br>Mysql的事务的实现即为ACID的实现：<br><strong>第一：事务的原子性是通过undo log来实现，也就是所谓的回滚操作。</strong> undo log记录了数据被修改之前的信息以及新增、删除的信息。undo log就是通过生成操作相反的sql语句来实现，举几个栗子🌰：<br>1.若undo log中有新增记录，则生成删除该记录的sql。<br>2.若undo log中有删除记录，则生成生成该记录的sql。<br>3.若undo log中有修改记录，则生成修改至原先语句的sql。<br>因此，所谓的回滚操作就是根据undo log做一个逆向操作。<br><strong>第二：事务的持久性</strong>（这里就说几个重要的点，因为说白了，持久性跟存储有关）：<br>1.<strong>redolog在提交commit前会写一次数据</strong>，顺序存储。<br>2.InnoDB的二次写以及自带的buffer pool。<br><strong>第三：事务的隔离性则通过4种隔离级别来实现。</strong><br><strong>第四：事务的一致性：其实现依赖于以上3个特性的实现、即回滚、恢复、隔离机制。</strong></p></blockquote><h4 id="（1）存储策略和存储大小"><a href="#（1）存储策略和存储大小" class="headerlink" title="（1）存储策略和存储大小"></a>（1）存储策略和存储大小</h4><p>InnoDB存储数据的策略有两种：</p><ol><li>共享表空间存储方式。</li></ol><blockquote><p><strong>InnoDB的所有数据保存在一个单独的表空间里面</strong>，而这个表空间可以由很多歌文件组成，一个表可以跨多个文件存在，所以其大小限制不再是文件大小的限制，而是其自身的限制，<strong>官方指出InnoDB表空间的最大限制是64TB。</strong></p></blockquote><ol start="2"><li>独享表空间存储方式。</li></ol><blockquote><p>每个表的数据以一个单独的文件来存放，此时的单表限制，就变成文件系统的大小限制了。</p></blockquote><h4 id="（2）MVCC和隔离级别"><a href="#（2）MVCC和隔离级别" class="headerlink" title="（2）MVCC和隔离级别"></a>（2）MVCC和隔离级别</h4><p>上文提到了InnoDB通过使用多版本并发控制MVCC来获得高并发性，并且实现了SQL标准的4种隔离级别，那接下来就对这两点来进行阐述。</p><p>首先MVCC，全名多版本并发控制（Multi-Version Concurrency Control），是Mysql的InnoDB存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。</p><p><strong>基本思想：</strong> <strong>利用多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系。</strong>（在MVCC中事务的修改操作，delete、insert、update这3个操作会为数据行新增一个版本快照）。</p><p>接下来先把4个事务隔离级别的基本概念说清楚（等级从小到大依次排序）：</p><blockquote><ol><li>Read uncommitted（读未提交）：避免了更新丢失，却可能出现脏读。（<strong>表现：读写并行</strong>）</li><li>Read committed（读提交）：避免了脏读，但是可能出现不可重复度。（<strong>表现：MVCC、读写分离</strong>）</li><li>Repeatable read（重复读）：避免了不可重复读和脏读，但是有可能出现幻读。（默认的隔离级别，<strong>表现：读写锁、MVCC</strong>）</li><li>Serializable（序列化，也叫串行化）：事务只能一个接着一个的执行，不能并发执行，可以解决幻读问题。</li></ol><p>概念解释：<br><code>脏读</code></p><ol><li>A进行了一条数据操作，但是没有提交事务，如果此时B进行这条数据的查询，是可以查到A的数据操作结果的。</li><li>后来A还没有提交事务，反而不提交了或者进行了事务回滚，那么B查询到的数据就是脏数据。<br><code>不可重复读（侧重于修改）</code><br>事务A多次读取到同一个数据，而B在A多次读取的过程中，对数据进行了修改，导致事务A多次多去同一个数据的时候，结果不一致。<br><code>幻读（侧重于增加或者删除）</code><br>再一次事务里面，多次查询之后，结果集的个数不一致的情况叫做幻读。而多或者少的那一行数据叫做幻行。</li></ol></blockquote><h4 id="（3）Next-Key-Locks"><a href="#（3）Next-Key-Locks" class="headerlink" title="（3）Next-Key Locks"></a>（3）Next-Key Locks</h4><p>MVCC不能解决幻读的问题，而Next-Key Locks就是为了解决这个问题而存在的。<strong>在可重复读级别下，使用MVCC+Next-Key Locks可以解决幻读问题。</strong></p><p><strong>一：Record Locks</strong>：<br><strong>锁定一个记录上的索引，而不是记录本身</strong>，如果表没有设置索引，由于InnoDB会自动加一个隐藏的主键，因此Record Locks依然可以使用。<br>记录锁其实很好理解，对表中的记录加锁，叫做记录锁，简称行锁。比如</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token punctuation">`</span>test<span class="token punctuation">`</span> <span class="token keyword">WHERE</span> <span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它会在 id=1 的记录上加上记录锁，以阻止其他事务插入，更新，删除 id=1 这一行。</p><p>需要注意的是：</p><ul><li><strong>id 列必须为唯一索引列或主键列</strong>，否则上述语句加的锁就会变成临键锁(有关临键锁下面会讲)。</li><li><strong>同时查询语句必须为精准匹配（=）</strong>，不能为 &gt;、&lt;、like等，否则也会退化成临键锁。</li></ul><p>其他实现比如，在通过 <strong>主键索引</strong> 与 <strong>唯一索引</strong> 对数据行进行 UPDATE 操作时，也会对该行数据加记录锁：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- id 列为主键列或唯一索引列 </span>
<span class="token keyword">UPDATE</span> <span class="token keyword">SET</span> age <span class="token operator">=</span> <span class="token number">50</span> <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>记录锁是锁住记录，锁住索引记录，而不是真正的数据记录</strong>.如果要锁的列没有索引，则会进行全表记录加锁，同时<code>记录锁也是排它(X)锁</code>,所以会阻塞其他事务对其<strong>插入、更新、删除</strong>。</p><p><strong>二：Gap Locks：</strong><br>锁定索引之间的间隙，但是不包含索引本身。间隙锁是Innodb在RR(可重复读) 隔离级别下为了解决<code>幻读问题</code>时引入的锁机制。<strong>间隙锁是innodb中行锁的一种</strong>。使用间隙锁锁住的是一个<strong>区间</strong>，而<strong>不仅仅是这个区间中的每一条数据</strong>。</p><p>举例来说，假如emp表中只有101条记录，其empid的值分别是1,2,…,100,101，下面的SQL：</p><pre class="line-numbers language-sql"><code class="language-sql">  <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> emp <span class="token keyword">WHERE</span> empid <span class="token operator">></span> <span class="token number">100</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当我们用条件检索数据，并请求共享或排他锁时，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。这个时候如果你插入empid等于102的数据的，如果那边事物还没有提交，那你就会处于等待状态，无法插入数据。</p><p><strong>三：临键锁</strong>：</p><p><strong>Next-key锁是记录锁和间隙锁的组合，它指的是加在某条记录以及这条记录前面间隙上的锁</strong>。即不仅锁定一个记录上的索引，也锁定索引之间的缝隙。他锁定一个前开后闭的区间，例如一个索引包含以下值：10，11，13，20，那么就会锁定这么几个区间：</p><blockquote><p>(-∞，10]，(10,11]，(11,13]，(13,20]，(20,+∞)</p></blockquote><p>也可以理解为一种特殊的<strong>间隙锁</strong>。通过<strong>临建锁</strong>可以解决<code>幻读</code>的问题。 每个数据行上的<strong>非唯一索引列</strong>上都会存在一把<strong>临键锁</strong>，当某个事务持有该数据行的<strong>临键锁</strong>时，会锁住一段<strong>左开右闭区间</strong>的数据。</p><p>需要强调的一点是，InnoDB 中<strong>行级锁</strong>是基于索引实现的，<strong>临键锁</strong>只与<strong>非唯一索引列</strong>有关，在<code>唯一索引列（包括主键列）上不存在临键锁</code>。</p><p><strong>四：总结：</strong></p><p>这里对 <strong>记录锁</strong>、<strong>间隙锁</strong>、<strong>临键锁</strong> 做一个总结</p><ul><li><strong>InnoDB</strong> 中的<strong>行锁</strong>的实现依赖于<strong>索引</strong>，一旦某个加锁操作没有使用到索引，那么该锁就会退化为<code>表锁</code>。</li><li><strong>记录锁</strong>存在于包括<strong>主键索引</strong>在内的<strong>唯一索引</strong>中，锁定单条索引记录。</li><li><strong>间隙锁</strong>存在于<strong>非唯一索引</strong>中，锁定<strong>开区间</strong>范围内的一段间隔，它是基于<strong>临键锁</strong>实现的。</li><li><strong>临键锁</strong>存在于<strong>非唯一索引</strong>中，该类型的每条记录的索引上都存在这种锁，它是一种特殊的<strong>间隙锁</strong>，锁定一段<strong>左开右闭</strong>的索引区间</li></ul><h4 id="（4）InnoDB的4大特性"><a href="#（4）InnoDB的4大特性" class="headerlink" title="（4）InnoDB的4大特性"></a>（4）InnoDB的4大特性</h4><ol><li><strong>插入缓冲</strong>（insert buffer）：对于非聚簇类索引的插入和更新操作，如果该索引页在缓存中，那么直接插入，先插入到缓冲区中，再以一定的频率和索引页合并。</li><li><strong>二次写</strong>（double write）：写数据前，将数据线写入一块独立的物理文件位置（ibdata）然后再写入数据页中。</li><li><strong>自定义哈希索引</strong>（ahi）：自定义哈希索引即将字典类型的索引通过哈希函数映射于一张表，让查询的时候更加迅速。</li><li><strong>预读</strong>（read ahead）：InnoDB在IO的优化上做出了预读机制，就是发起一个IO请求，异步地在缓冲池中预先回迁若干页面，预计把可能用到的数据页返回。</li></ol><h3 id="MyISAM引擎（了解）"><a href="#MyISAM引擎（了解）" class="headerlink" title="MyISAM引擎（了解）"></a>MyISAM引擎（了解）</h3><p>和InnoDB引擎相比，MyISAM不支持事务、表锁设计，但是<strong>支持全文索引</strong>。MyISAM存储引擎的<strong>另一个与众不同的地方是他的缓冲池只缓存索引文件而不缓存数据文件。</strong> 另外，还记得上文提到，InnoDB的最大存储限度有一个64TB，Mysql5以上的时候，<strong>如果用的是MyISAM引擎，那么支持256TB的单表数据。</strong> 并且使用MyISAM存储引擎表，MySQL只缓存索引文件，数据文件缓存则是交给操作系统。</p><h5 id="MyISAM和InnoDB的区别"><a href="#MyISAM和InnoDB的区别" class="headerlink" title="MyISAM和InnoDB的区别"></a>MyISAM和InnoDB的区别</h5><table><thead><tr><th>比较内容</th><th>MyISAM</th><th>InnoDB</th><th></th></tr></thead><tbody><tr><td>构成上的区别</td><td>每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。</td><td>基于磁盘的资源是InnoDB表空间数据文件和它的日志文件，InnoDB 表的大小只受限于操作系统文件的大小，一般为 2GB</td><td></td></tr><tr><td>是否支持事务</td><td>不支持</td><td>支持</td><td></td></tr><tr><td>支持的锁</td><td>行锁</td><td>表锁</td><td></td></tr><tr><td>是否有MVCC</td><td>不支持</td><td>支持</td><td></td></tr><tr><td>是否支持外键</td><td>不支持</td><td>支持</td><td></td></tr><tr><td>是否支持全文索引</td><td>支持</td><td>不支持</td><td></td></tr><tr><td>操作的速度</td><td>建议如果执行大量的select语句，使用MyISAM</td><td>如果数据执行大量的insert和update操作，出于性能考虑，使用InnoDB表</td><td></td></tr><tr><td>表的具体行数</td><td>MyISAM会保存好表中的行数，因此对于count操作很快</td><td>InnoDB则没有，需要扫描一遍全表计算</td><td></td></tr></tbody></table><p>一个极具迷惑性的提问：当表的数据量大于1000万时候MySQL的性能会急剧下降吗？</p><blockquote><p>MySQL是数据库，不是文件，随着数据行数增加性能必然会下降，但这些下降不是线性的，如果在对应业务情况下使用合适的存储引擎与配置，那么这些数据量是能承受住的。如在官方手册上所说的InnoDB 1TB数据。</p></blockquote><h2 id="第2章-InnoDB存储引擎"><a href="#第2章-InnoDB存储引擎" class="headerlink" title="第2章 InnoDB存储引擎"></a>第2章 InnoDB存储引擎</h2><h3 id="InnoDB体系架构"><a href="#InnoDB体系架构" class="headerlink" title="InnoDB体系架构"></a>InnoDB体系架构</h3><p>InnoDB内有多个内存块，这些内存块组成一个大的内存池，负责维护数据的写、访问以及日记的记录，这些内存块由多个后台线程负责处理，来适应不同的任务。</p><p>这些后台线程的任务主要用来：</p><p>（1）Master Thread</p><ul><li>负责将缓冲池的数据异步刷新到磁盘</li><li>保证数据一致性：包括脏页的刷新、合并插入缓冲池、undo页的回收<br>在后续的更新里，Innodb 1.2.x把刷新脏页从主线程里面分离到了PageCleanerTherad线程中</li></ul><p>Master Thread内部由多个循环loop组成，并且在多个循环状态之间切换。</p><ul><li>主循环（loop）</li><li>后台循环（background loop）</li><li>刷新循环（flush loop）</li><li>暂停循环（suspend loop）</li></ul><p>大部分操作在主循环中，分为每秒的操作和每十秒的操作，每秒的操作包括：</p><blockquote><p>1.日志缓冲刷新到磁盘，即使这个事务还没有提交。（总是）<br>2.合并插入缓冲。（可能）<br>3.最多刷新100个InnoDB的缓冲池中的脏页到磁盘。（可能）<br>4.如果当前没有用户活动，则切换到background loop后台循环。（可能）<br>——-background loop执行的操作：<br>——-1.删除无用的Undo页。（总是）<br>——-2.合并20个插入缓冲。（总是）<br>——-3.跳回到主循环。（总是）<br>——-4.不断刷新100个页直到符合条件。（可能）</p></blockquote><p>每十秒的操作包括：</p><blockquote><p>1.刷新100个脏页到磁盘。（可能）<br>2.合并最多5个插入缓冲（总是）<br>3.将日志缓冲刷新到磁盘。（总是）<br>4.删除无用的Undo页。（总是）<br>5.刷新100个或者10个脏页到磁盘。（总是）</p></blockquote><p>（2） IO Thread<br>InnoDB中使用了大量的<strong>AIO来处理写IO请求</strong>，以便提高数据库的性能，<strong>而IO Thread的工作就是负责这些IO请求的回调处理。</strong> 其中比较重要的几个线程为write IO Thread（默认4个）、read IO Thread（默认4个）、insert buffer IO Thread、log IO Thread</p><p>（3)）Purge Thread<br>事务被提交后，其所用的undolog可能不再需要，那么则需要一个线程去回收已经使用并分配的undo页。而做这份工作的线程就叫做Purge Thread。</p><p>（4）Page Cleaner Thread<br>Page Cleaner Thread的作用<strong>是将之前版本中脏页的刷新操作都放入到单独的线程中去完成。</strong> 其目的：减轻原Mster Thread的工作及对于用户查询线程的阻塞，进一步提高InnoDB的性能。</p><h3 id="Innodb内存"><a href="#Innodb内存" class="headerlink" title="Innodb内存"></a>Innodb内存</h3><h4 id="（1）缓冲池"><a href="#（1）缓冲池" class="headerlink" title="（1）缓冲池"></a>（1）缓冲池</h4><p><img src="/posts/9398/image-20231109162323130.png" alt></p><p><strong>InnoDB存储引擎是基于磁盘存储的，并且将其中的记录按照页的方式进行管理。</strong> 而基于磁盘的数据库系统，因为存储设备速率的差距，通常需要使用缓冲池技术来提高数据库的整体性能，从上图可以看到，缓冲池并不是简单的一个k-v map。</p><p>缓冲池作为内存中最大的一块，也包含了很多数据页类型：索引页、数据页、undo页、插入缓冲、自定义哈希索引、锁信息、数据字典信息等。同时InnoDB存储引擎还<strong>允许有多个缓冲池实例，</strong> 相当于自适应哈希索引中的多个哈希桶。</p><h4 id="（2）InnoDB的LRU算法"><a href="#（2）InnoDB的LRU算法" class="headerlink" title="（2）InnoDB的LRU算法"></a>（2）InnoDB的LRU算法</h4><p>InnoDB存储引擎则使用了<strong>一种经过优化的LRU算法</strong>来堆缓冲池进行管理，即在LRU的基础上增加了一个<code>midpoint</code>的位置，新读取到的页并不会直接放入到LRU列表的首部，而是放到LRU列表的<code>midpoint</code>位置。默认情况下，这个位置在LRU列表长度的5/8处。即新读取的页给放在LRU列表尾端3/8的位置，midpoint之后的为old列表，之前的为new列表，new列表为频繁访问的数据。</p><p>问题1：<strong>为什么不采用普通的LRU算法，直接将读取的页放入到LRU列表的首部呢？</strong></p><blockquote><p>如果直接吧读取到的页放入到LRU列表的首部，那么某些SQL操作可能会使缓冲池中的页被刷新出，从而影响缓冲池的效率。</p></blockquote><p>问题2：<strong>所谓的会将缓冲池中的页刷新出的SQL某些操作是什么？为什么会影响呢？</strong></p><blockquote><p>1.如索引或者数据的扫描操作。<br>2.比如全表扫描，需要访问到表中的全部页，<strong>问题是缓冲池的大小是有限的，那么我这次全表扫描，如果全部放入到LRU列表的首部，那么非常可能会将比较重要的热点数据页从LRU列表中移出</strong>，当下一次需要读取热点数据的时候，又得去访问磁盘。<br>3.此外，InnoDB还引入一个时间参数<strong>innodb_old_blocks_time</strong>来保证：页读取到mid位置后需要等待多久会被加入到LRU列表的热端（new部分），以尽可能的让LRU列表中热点数据不被移出。</p></blockquote><p>InnoDB引擎在1.0.x版本就开始支持页的压缩功能了。原本页的大小是16K，现在可以压缩为1、2、4、8KB，而这些非16KB的页，通过unzip_LRU列表来管理。</p><p>unzip_LRU列表对不同压缩页大小的页进行分别管理，例如需要从缓冲池中申请页为4KB的大小，过程如下：</p><ol><li>检查4KB的unzip_LRU列表,检查是否有可用的空闲页。</li><li>如果有，直接使用。</li><li>如果没有，检查8KB的unzip_LRU列表。</li><li>如果能够得到空闲页，将页分成2个4KB页，存放到4KB的unzip_LRU列表。</li><li>如果不能得到空闲页，从LRU列表中申请一个16KB的页，将页分为1个8KB的页、2个4KB的页，分别存放到对应的unzip_LRU列表中。</li></ol><p><strong>在LRU列表中的页如果被修改了，那么这种页叫做脏页。</strong> 即缓冲池中的页he磁盘上的页的数据产生了不一致，而<strong>这个时候数据库会通过Checkpoint机制将脏页刷新到磁盘，而Flush列表中的页即为脏页列表。</strong></p><p><strong>注意：</strong></p><ul><li><strong>脏页既存在于LRU列表，也存在与Flush列表中。</strong></li><li><strong>LRU列表用来管理缓冲池中页的可用性，Flush列表用来管理将页刷新到磁盘，两者是独立的互相不影响的。</strong></li></ul><h4 id="（3）重做日志缓冲"><a href="#（3）重做日志缓冲" class="headerlink" title="（3）重做日志缓冲"></a>（3）重做日志缓冲</h4><p>InnoDB存储引擎的内存区域除了有缓冲池外，还有重做日志缓冲（redo log buffer）。<strong>InnoDB存储引擎首先将重做日志信息放到该缓冲区中，然后按照一定的频率将其刷新到重做日志文件中，默认重做日志缓冲的大小为8MB，参数由innodb_log_buffer_size控制</strong></p><p>缓冲刷新至文件的3种时机：</p><ul><li>Master Thread每秒将重做日志缓冲刷新到重做日志文件。</li><li>每个事务提交的时候会将重做日志缓冲刷新到重做日志文件。</li><li>当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件。</li></ul><h4 id="（4）额外内存池"><a href="#（4）额外内存池" class="headerlink" title="（4）额外内存池"></a>（4）额外内存池</h4><p>在InnoDB存储引擎中，<strong>堆内存的管理是通过一种称为内存堆的方式进行的</strong>。在对一些数据结构本身的内存进行分配的时候，<strong>需要从额外的内存池中进行申请，当该区域的内存不够的时候，才会从缓冲池进行申请。</strong></p><h3 id="Checkpoint"><a href="#Checkpoint" class="headerlink" title="Checkpoint"></a>Checkpoint</h3><p>为了避免数据库发生数据丢失，当前事务数据库系统普遍采用了一种策略叫做：<strong>Write Ahead Log策略。</strong> <strong>即事务提交的时候，先写重做日志，再修改页</strong>。而发生宕机而导致数据丢失的时候，就可以通过重做日志来完成数据的恢复。</p><p>Checkpoint技术的目的就是解决以下几个问题：</p><ol><li>缩短数据库的恢复时间。</li><li>缓冲池不够用，将脏页刷新到磁盘。</li><li>重做日志不可用时，刷新脏页。</li></ol><blockquote><p>重做日志出现不可用的原因？<br>回答：<br>因为当前事务数据库系统对重做日志的设计都是循环使用的，并不是让日志无限增大，重做日志可以被重用的部分是指这些日志已经不再需要了，那么这部分就可以被覆盖。但是万一覆盖之后，之前的部分又需要使用了，那么必须强制产生Checkpoint，将缓冲池中的页至少刷新到当前重做日志的位置。</p></blockquote><p>此外，当数据库发生宕机需要恢复的时候，不需要重做所有的日志，<strong>因为Checkpoint之前的页已经能保证刷新到磁盘中了，所以数据库只需要对之后的重做日志进行恢复即可</strong>，这样大大缩短了恢复的时间。并且，当缓冲池不够用的时候，根据LRU算法会把最近最少使用的页给移除，如果该页为脏页，那么需要强制执行Checkpoint，将脏页刷回磁盘。</p><p>InnoDB存储引擎内部有两种Checkpoint：</p><ul><li><p>Sharp Checkpoint：<strong>发生在数据库关闭时，将所有的脏页刷新到磁盘，默认工作方式。</strong> 通过参数<code>innodb_fast_shutdown=1</code>实现</p></li><li><p>Fuzzy Checkpoint：<strong>只刷新一部分脏页。</strong> 使用Fuzzy Checkpoint的情况：</p></li><li><p>Master Thread Checkpoint</p></li></ul><blockquote><p>以每秒或者每十秒的速度从缓冲池的脏页列表中刷新一定比例的页回到磁盘。</p></blockquote><ul><li>FLUSH_LRU_LIST Checkpoint</li></ul><blockquote><p><strong>因为InnoDB引擎需要保证LRU列表中需要有差不多100个空闲页可供使用，所以如果没有足够的空闲页，那么InnoDB引擎会将LRU列表尾端的页移除，那如果有脏页，则进行Checkpoint。</strong> 通过参数innodb_lru_scan_depth指定，默认1024</p></blockquote><ul><li>Async/Sync Flush Checkpoint</li></ul><blockquote><p>指的是重做日志文件不可用的情况，这时候需要强制将一些页刷新到磁盘，为了保证重做日志的循环使用。</p></blockquote><ul><li>Dirty Page too much Checkpoint</li></ul><blockquote><p>当脏页的数量太多，导致InnoDB存储引擎强制进行Checkpoint，目的是为了保证缓冲池中有足够的可用的页。通过参数innodb_max_dirty_pages_pct控制</p></blockquote><p>默认大小75%，即缓冲池中脏页数量占据75%时候，强制进行Checkpoint，刷新一部分的脏页到磁盘。</p><h3 id="InnoDB关键特性"><a href="#InnoDB关键特性" class="headerlink" title="InnoDB关键特性"></a>InnoDB关键特性</h3><h4 id="插入缓冲"><a href="#插入缓冲" class="headerlink" title="插入缓冲"></a>插入缓冲</h4><h5 id="Insert-Buffer"><a href="#Insert-Buffer" class="headerlink" title="Insert Buffer"></a>Insert Buffer</h5><p>在InnoDB存储引擎中，主键是行唯一的标识符大家都知道，<strong>通常应用程序中行记录的插入顺序是按照主键递增的顺序进行插入的。</strong> 也因此，插入聚簇索引一般是顺序的，不需要磁盘的随机读取。</p><p>问题来了：一张表一般除了一个主键，还有多个非聚簇索引，我这里假设一张表中的聚簇索引为a，非聚簇索引为b，如：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> t<span class="token punctuation">(</span>
<span class="token number">a</span> <span class="token keyword">int</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span> 
<span class="token number">b</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
<span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span><span class="token number">a</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
<span class="token keyword">KEY</span><span class="token punctuation">(</span><span class="token number">b</span><span class="token punctuation">)</span> 
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>那么这张表在进行插入操作的时候，页的存放还是按照主键a进行顺序存放的，但是对于非聚簇索引b的叶子节点的插入不再是顺序的了，这时候需要离散的访问非聚簇索引页，即随机读取。（B+树的特性决定了非聚簇索引插入的离散型）。</strong></p><p>那么，InnoDB存储引擎开创了Insert Buffer的目的是啥呢？</p><blockquote><p>对于非聚簇索引的插入或者更新操作，不是每一次都直接插入到索引页中，<strong>而是先判断插入的非聚簇索引页是否在缓冲池中。</strong><br>如果在——&gt;直接插入。<br><strong>如果不在——&gt;先放入到Insert Buffer对象中，然后再以一定的频率将Insert Buffer和辅助索引页子节点进行合并操作。</strong><br>那么这时候能够将多个插入合并到一个操作中，就大大提高了对于非聚簇索引插入的性能。</p></blockquote><p>那么以我的理解：</p><ol><li>把Insert Buffer<strong>看做是一个大容器</strong>，把每次非聚簇索引的插入当做一次任务。</li><li><strong>因为非聚簇索引的插入具有离散型，那么如果把多个非聚簇索引的插入绑定在一块</strong>，形成一个大的插入事件，提高插入性能。</li></ol><p>使用Insert Buffer需要满足的条件，有俩：</p><ol><li>索引是辅助索引（非聚簇）。</li><li>索引不是唯一的（unique）。</li></ol><h5 id="Change-Buffer"><a href="#Change-Buffer" class="headerlink" title="Change Buffer"></a>Change Buffer</h5><p>前面的Insert Buffer可以说是针对非聚簇索引的插入操作，那么自从InnoDB1.0.x版本后，引入了Insert Buffer的升级版：Change Buffer，可以对DML操作（insert，update，delete）都进行缓冲，这里分别对应了Insert Buffer、Purge Buffer、Delete Buffer，使用参数<code>innodb_change_buffering</code>来开启各种Buffer选项。（默认是all，即全开启）</p><p>值得注意的是，因为Change Buffer是升级版，所以它适用的对象依然是非唯一的辅助索引，比如对一条记录进行update操作可以分为2个过程：</p><ol><li>将记录标记为已删除。（对应Delete Buffer）</li><li>真正将记录删除。（对应Purge Buffer）</li></ol><h5 id="Insert-Buffer的内部实现原理"><a href="#Insert-Buffer的内部实现原理" class="headerlink" title="Insert Buffer的内部实现原理"></a>Insert Buffer的内部实现原理</h5><p><strong>Insert Buffer的数据结构是一颗B+树。</strong> 目前版本全局只有一颗Insert Buffer B+树，<strong>负责对所有的表的辅助索引进行Insert Buffer。这颗B+树存放在共享表空间中，默认是ibdata1中，其非叶子节点存放的是查询的search key（键值）</strong></p><p>search key的结构：<br><img src="/posts/9398/image-20231109210839840.png" alt></p><ol><li>space（4字节）：待插入记录所在表的表空间id（唯一），可以通过该id得知哪张表。</li><li>marker（1字节）：兼容老版本的Insert Buffer。</li><li>offset（4字节）：页所在的偏移量</li></ol><p><strong>插入原理：</strong><br>当一个辅助索引需要插入到页中的时候，<strong>如果这个也不在缓冲池中，那么InnoDB存储引擎首先会根据上述的数据结构构造一个search key</strong>，接下来查询Insert Buffer这颗B+树，然后江浙条记录插入到其叶子节点中。</p><p><strong>插入后的结构：</strong><br>如图：Insert Buffer叶子节点中的记录，相比之前，多了一个metadata<br><img src="/posts/9398/4.png" alt><br>其中metadata的存储内容包括（4字节）：<br><img src="/posts/9398/5.png" alt><br><strong>其中IBUF_REC_OFFSET_COUNT用来排序每个记录进入Insert Buffer的顺序。</strong> 并且这里大家可以看出，Insert Buffer的B+树存储叶子节点，需要额外的13字节的开销（9字节的search key和4字节的metadata），后续的列表就是记录的实际字段了。</p><h4 id="Merge-Insert-Buffer"><a href="#Merge-Insert-Buffer" class="headerlink" title="Merge Insert Buffer"></a>Merge Insert Buffer</h4><p>插入缓冲的时候，如果插入记录的辅助索引页不在缓冲池中，记录将插入到Insert Buffer B+树中。<strong>那么什么时候把Insert Buffer的记录合并到真正的辅助索引中呢？</strong></p><p>直接总的来说，Merge Insert Buffer的时机有这么3种：</p><ol><li>辅助索引页被读取到缓冲池。</li></ol><blockquote><p>比如执行select操作，这时候需要先检查Insert Buffer Bitmap页，确认该辅助索引页是否有记录存放在Insert Buffer B+树中，如果有，则把树中的记录插入到辅助索引页中。<br><strong>注意，注意：大家可以理解为，Insert Buffer B+树只是一个中间件，缓存记录的地方，而辅助索引页是辅助索引记录的最终归宿。</strong></p></blockquote><ol start="2"><li>Insert Buffer Bitmap页追踪到该辅助索引页已经没有可用空间的时候。</li></ol><blockquote><p>若插入辅助索引记录时检测到插入记录后辅助索引页的可用空间小于1/32，那么这个时候会强制进行Merge Insert Buffer。</p></blockquote><ol start="3"><li>Master Thread。</li></ol><blockquote><p>每秒或者每十秒会进行一次Merge Insert Buffer操作。</p></blockquote><p>上文多次提到了Insert Buffer Bitmap，这里来稍微解释下是个啥东西：<br><strong>为了保证每次Merge Insert Buffer页必须成功，需要一个特殊的页来标记每个辅助索引页的可用空间，而这个也的类型为Insert Buffer Bitmap。</strong></p><p>其结构：<br><img src="/posts/9398/20201209145959330.png" alt></p><h4 id="二次写"><a href="#二次写" class="headerlink" title="二次写"></a>二次写</h4><p><strong>Insert Buffer带给InnoDB存储引擎的是性能上的提升，而二次写（doublewrite）带给他的是数据页的可靠性。</strong></p><p>再讲二次写之前，先给解释两个专有名词：<strong>写失效</strong></p><blockquote><p>当发生数据库宕机的时候，可能InnoDB存储引擎正在写入某个页到表中，而这个页中只写了一部分，比如一共16KB的页，只写了前4KB，之后发生了宕机，那么这种情况称之为写失效。</p></blockquote><p>虽然发生写失效的时候，可以通过重做日志来进行恢复，<strong>但是重做日志中记录的是对页的物理操作，如果这个页本身发生了损坏，那么重做是没有意义的。</strong> 因此，我们需要在重做日志前，用户需要一个页的副本，当写入失效发生的时候，<strong>先通过页的副本来还原，再进行重做，这就是二次写。</strong></p><p>doublewrite的结构如下，由两个部分组成：</p><ul><li>一部分是内存中的doublewrite buffer，大小为2MB。</li><li>一部分是物理磁盘上共享表空间中连续的128个页，大小为2MB。</li></ul><p><img src="/posts/9398/6.png" alt></p><p><strong>工作原理：</strong></p><ol><li>在对缓冲池的脏页进行刷新时，并不直接写磁盘，而是通过memcpy函数将脏页<strong>先复制到内存当中的doublewrite buffer。</strong></li><li>之后通过doublewrite buffer分两次操作，每次1MB，<strong>顺序的写入共享表空间的物理磁盘上。</strong></li><li><strong>调用fsync函数，同步磁盘</strong>，避免缓冲写带来的问题。</li><li>完成doublewrite页的写入后，<strong>再将doublewrite buffer中的页写入各个表空间文件中。</strong></li></ol><p>问题：如果操作系统在将页写入磁盘的过程中发生了崩溃，怎么办？</p><blockquote><p>回答：<br>恢复过程中，InnoDB存储引擎可以<strong>从共享表空间中的doublewrite中找到该页的一个副本，将其复制到表空间文件中，再应用重做日志进行恢复。</strong></p></blockquote><h4 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h4><p>首先大家应该知道一点，哈希是一种非常快的查找方法，一般时间复杂度为O（1），B+树的查找次数，取决于B+树的高度。<strong>InnoDB会监控表上各个索引页的查询，如果说观察到建立哈希索引可以带来速度提升，那么会建立一个哈希索引，也就是自适应哈希索引（Adaptive Hash Index ，AHI）。</strong></p><p><strong>AHI是通过缓冲池的B+树页构造而来</strong>，因此建立的速度很快，<strong>InnoDB会自动根据访问的频率和模式来自动的为某一些热点页建立哈希索引，并且默认AHI功能默认开启。</strong></p><h4 id="异步IO和刷新邻接页"><a href="#异步IO和刷新邻接页" class="headerlink" title="异步IO和刷新邻接页"></a>异步IO和刷新邻接页</h4><p>首先说下<strong>异步IO</strong>：<br>很简单，就是用户发起一个IO请求后立即在发送一个IO请求，当所有IO请求发送完毕后，等待所有IO操作的完成，<strong>核心是无需等待第一个IO请求的返回结果。</strong></p><p>AIO的另一个优势就是可以进行IO Merge操作，也就是将多个IO操作合并为1个IO，这样可以提高IOPS（可以视为是每秒的读写次数）的性能。这里举一个书中的例子：</p><blockquote><p>例如用户需要访问页的（space，page_no）为：(8,6)，(8,7)，(8,8)<br>那么每个页的大小为16KB，那么同步IO需要进行3次IO操作，而AIO会判断到这3个页是连续的，因此AIO底层会发送一个IO请求，从（8，6）开始，一次性读取48KB的页。</p></blockquote><p>再来说下<strong>刷新邻接页</strong>：<br>InnoDB存储引擎提供了刷新邻接页（Flush Neighbor Page）的特性，其工作原理为：</p><ol><li>当刷新一个脏页的时候，InnoDB存储引擎<strong>会检测到该页所在区的所有页</strong>。</li><li><strong>如果是脏页，那么一个区的所有页一起进行刷新</strong>。</li></ol><p>通过AIO可以将多个IO写入操作合并为一个IO操作，那么该工作机制在传统的机械硬盘下肯定是有显著的优势，但是也产生了俩问题：</p><ul><li>如果将不怎么脏的页进行了写入，但是之后页又很快变成了脏页咋办？</li><li>固态硬盘有着较高的IOPS，是否还需要这个特性？</li></ul></div><hr><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"><span class="chip bg-color">原理剖析</span> </a><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="chip bg-color">读书笔记</span> </a><a href="/tags/MySQL/"><span class="chip bg-color">MySQL</span> </a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="chip bg-color">数据库</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="wechat,qq" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="/libs/share/js/social-share.min.js"></script></div></div></div></div></div><style>.valine-card{margin:1.5rem auto}.valine-card .card-content{padding:20px 20px 5px 20px}#vcomments textarea{box-sizing:border-box;background:url(/medias/comment_bg.png) 100% 100% no-repeat}#vcomments p{margin:2px 2px 10px;font-size:1.05rem;line-height:1.78rem}#vcomments blockquote p{text-indent:.2rem}#vcomments a{padding:0 2px;color:#4cbf30;font-weight:500;text-decoration:none}#vcomments img{max-width:100%;height:auto;cursor:pointer}#vcomments ol li{list-style-type:decimal}#vcomments ol,ul{display:block;padding-left:2em;word-spacing:.05rem}#vcomments ul li,ol li{display:list-item;line-height:1.8rem;font-size:1rem}#vcomments ul li{list-style-type:disc}#vcomments ul ul li{list-style-type:circle}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}#vcomments table,td,th{border:0}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments h1{font-size:1.85rem;font-weight:700;line-height:2.2rem}#vcomments h2{font-size:1.65rem;font-weight:700;line-height:1.9rem}#vcomments h3{font-size:1.45rem;font-weight:700;line-height:1.7rem}#vcomments h4{font-size:1.25rem;font-weight:700;line-height:1.5rem}#vcomments h5{font-size:1.1rem;font-weight:700;line-height:1.4rem}#vcomments h6{font-size:1rem;line-height:1.3rem}#vcomments p{font-size:1rem;line-height:1.5rem}#vcomments hr{margin:12px 0;border:0;border-top:1px solid #ccc}#vcomments blockquote{margin:15px 0;border-left:5px solid #42b983;padding:1rem .8rem .3rem .8rem;color:#666;background-color:rgba(66,185,131,.1)}#vcomments pre{font-family:monospace,monospace;padding:1.2em;margin:.5em 0;background:#272822;overflow:auto;border-radius:.3em;tab-size:4}#vcomments code{font-family:monospace,monospace;padding:1px 3px;font-size:.92rem;color:#e96900;background-color:#f8f8f8;border-radius:2px}#vcomments pre code{font-family:monospace,monospace;padding:0;color:#e8eaf6;background-color:#272822}#vcomments pre[class*=language-]{padding:1.2em;margin:.5em 0}#vcomments code[class*=language-],pre[class*=language-]{color:#e8eaf6}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}#vcomments b,strong{font-weight:700}#vcomments dfn{font-style:italic}#vcomments small{font-size:85%}#vcomments cite{font-style:normal}#vcomments mark{background-color:#fcf8e3;padding:.2em}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}.v .vlist .vcard{padding-top:2.5em!important}</style><div class="card valine-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;left:20px;top:15px;padding-bottom:5px"><i class="fa fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="vcomments" class="card-content" style="display:grid"></div></div><script src="/libs/valine/av-min.js"></script><script src="/libs/valine/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"98JpzSGcrl9jFqHO13vqxHvX-gzGzoHsz",appKey:"mDmr2h9PB20xvPMNqgyRnNIC",notify:!0,verify:!0,visitor:!0,avatar:"mm",pageSize:"10",lang:"zh-cn",placeholder:"just go go"})</script><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fa fa-chevron-left"></i>&nbsp;上一篇</div><div class="card"><a href="/posts/64584/"><div class="card-image"><img src="/medias/featureimages/11.jpg" class="responsive-img" alt="CMake实战"> <span class="card-title">CMake实战</span></div></a><div class="card-content article-content"><div class="summary block-with-text">实战速查</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2024-03-21 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/Cpp/" class="post-category">Cpp</a></span></div></div><div class="card-action article-tags"><a href="/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"><span class="chip bg-color">工程经验</span> </a><a href="/tags/CMake/"><span class="chip bg-color">CMake</span> </a><a href="/tags/Tool/"><span class="chip bg-color">Tool</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fa fa-chevron-right"></i></div><div class="card"><a href="/posts/34936/"><div class="card-image"><img src="/medias/featureimages/14.jpg" class="responsive-img" alt="如何用lambda表达式快速刷题"> <span class="card-title">如何用lambda表达式快速刷题</span></div></a><div class="card-content article-content"><div class="summary block-with-text">用现代c++优化你的刷题体验</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2024-03-20 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/Cpp/" class="post-category">Cpp</a></span></div></div><div class="card-action article-tags"><a href="/tags/Cpp/"><span class="chip bg-color">Cpp</span> </a><a href="/tags/Leetcode/"><span class="chip bg-color">Leetcode</span></a></div></div></div></div></article></div><script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script><script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script><script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script><script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget"><div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fa fa-list"></i></a></div><script src="/libs/tocbot/tocbot.min.js"></script><script>$(function(){tocbot.init({tocSelector:"#toc-content",contentSelector:"#articleContent",headingsOffset:-(.4*$(window).height()-45),headingSelector:"h2, h3, h4, h5"});let t=0;var e="toc-heading-";$("#toc-content a").each(function(){$(this).attr("href","#"+e+ ++t)}),t=0,$("#articleContent").children("h2, h3, h4, h5").each(function(){$(this).attr("id",e+ ++t)});var n=parseInt(.4*$(window).height()-64);let o=$(".toc-widget");$(window).scroll(function(){var t=$(window).scrollTop();n<t?o.addClass("toc-fixed"):o.removeClass("toc-fixed")});var i="expanded";let a=$("#toc-aside"),c=$("#main-content");$("#floating-toc-btn .btn-floating").click(function(){a.hasClass(i)?(a.removeClass(i).hide(),c.removeClass("l9")):(a.addClass(i).show(),c.addClass("l9")),function(){let e=$("#artDetail");if(0!==e.length){let t=e.width();450<=t?t+=21:350<=t&&t<450?t+=18:300<=t&&t<350?t+=16:t+=14,$("#prenext-posts").width(t)}}()})})</script></main><footer class="page-footer bg-color"><div class="container row center-align"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2019</span> <a href="/about" rel="external nofollow noreferrer">JoyTsing</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br><span id="sitetime">载入运行时间...</span> <span id="busuanzi_container_site_pv">|&nbsp;<i class="fa fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span>&nbsp;次 </span><span id="busuanzi_container_site_uv">|&nbsp;<i class="fa fa-user"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv" class="white-color"></span>&nbsp;人</span><br><script type="text/javascript">var cnzz_protocol="https:"==document.location.protocol?"https://":"http://";document.write(unescape("%3Cspan id='cnzz_stat_icon_1278523400'%3E%3C/span%3E%3Cscript src='"+cnzz_protocol+"s4.cnzz.com/z_stat.php%3Fid%3D1278523400%26online%3D1%26show%3Dline' type='text/javascript'%3E%3C/script%3E"))</script><br>&nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;<span class="white-color">559.1k</span>&nbsp;字 <span id="icp"><img src="/medias/icp.png" style="vertical-align:text-bottom" alt="icp"> <a href="https://beian.miit.gov.cn/" target="_blank">滇ICP备2024026466号-1</a></span><script>function siteTime(){var e=864e5,t="2019",n=(m=new Date).getFullYear(),o=m.getMonth()+1,r=m.getDate(),a=m.getHours(),i=m.getMinutes(),l=m.getSeconds(),m=Date.UTC(t,"7","24","0","0","0"),r=Date.UTC(n,o,r,a,i,l)-m,a=Math.floor(r/31536e6),i=Math.floor(r/e-365*a),l=Math.floor((r-(365*a+i)*e)/36e5),m=Math.floor((r-(365*a+i)*e-36e5*l)/6e4),M=Math.floor((r-(365*a+i)*e-36e5*l-6e4*m)/1e3);t==n?(document.getElementById("year").innerHTML=n,document.getElementById("sitetime").innerHTML="本站已安全运行 "+i+" 天 "+l+" 小时 "+m+" 分钟 "+M+" 秒"):(document.getElementById("year").innerHTML=t+" - "+n,document.getElementById("sitetime").innerHTML="本站已安全运行 "+a+" 年 "+i+" 天 "+l+" 小时 "+m+" 分钟 "+M+" 秒")}setInterval(siteTime,1e3)</script></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/JoyTsing" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fa fa-github"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script src="/js/search.js"></script><script type="text/javascript">$(function(){searchFunc("/search.xml","searchInput","searchResult")})</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fa fa-angle-up"></i></a></div><script src="/libs/materialize/materialize.min.js"></script><script src="/libs/masonry/masonry.pkgd.min.js"></script><script src="/libs/aos/aos.js"></script><script src="/libs/scrollprogress/scrollProgress.min.js"></script><script src="/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="/js/matery.js"></script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?3a39d92b69933ae56c7eb41ffb9aa2e0";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js",(e=document.getElementsByTagName("script")[0]).parentNode.insertBefore(t,e)}()</script><script async src="/libs/others/busuanzi.pure.mini.js"></script><script type="text/javascript">var st,OriginTitile=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="(oﾟvﾟ)ノ Hi",clearTimeout(st)):(document.title="(*´∇｀*) 欢迎回来！",st=setTimeout(function(){document.title=OriginTitile},3e3))})</script><script type="text/javascript" color="0,0,255" pointcolor="0,0,255" opacity="0.8" zindex="-1" count="150" src="/libs/background/canvas-nest.js"></script><script src="/libs/instantpage/instantpage.js" type="module"></script><script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script><script>const hasAttr = (e,a) => a.some(_=> e.attr(_)!==undefined);
        $('a').each(function() {
          const $this = $(this);
          if(hasAttr($this,["data-fancybox","ignore-external-link"])) return;
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== '' || window.location.host) {
                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/shizuku.model.json"},display:{position:"left",width:150,height:200},mobile:{show:!1},react:{opacity:.7}})</script></body></html>