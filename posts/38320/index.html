<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="spdlog库源码阅读, joytsing blog"><meta name="description" content="学习开源项目"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="theme-color" content="white"><title>spdlog库源码阅读 | JoyTsing</title><link rel="apple-touch-icon" href="/"><link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="/favicon.ico"><link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css"><link rel="stylesheet" type="text/css" href="/libs/aos/aos.css"><link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css"><link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" type="text/css" href="/css/matery.css"><link rel="stylesheet" type="text/css" href="/css/my.css"><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style><script src="/libs/jquery/jquery.min.js"></script><script src="https://cdn-go.cn/aegis/aegis-sdk/latest/aegis.min.js"></script><script>const aegis=new Aegis({id:"6ojk8FlnQlqWeL6vQo",uin:"joyblog",reportApiSpeed:!0,reportAssetSpeed:!0,spa:!0,hostUrl:"https://rumt-sg.com"});console.log("aegis load")</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="JoyTsing" type="application/atom+xml"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><img src="/apple-touch-icon.png" class="logo-img" alt="LOGO"> <span class="logo-span">JoyTsing</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fa fa-home"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-tags"></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-bookmark"></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-archive"></i> <span>归档</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa fa-user-circle-o"></i> <span>关于</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa fa-envelope"></i> <span>留言</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa fa-address-book"></i> <span>友链</span></a></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fa fa-search" title="搜索"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="/medias/avatars/touxiang2.jpg" class="logo-img circle responsive-img"><div class="logo-name">JoyTsing</div><div class="logo-desc">joytsing的个人网站</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="m-nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-fw fa-bookmark"></i> 分类</a></li><li class="m-nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li class="m-nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa fa-fw fa-user-circle-o"></i> 关于</a></li><li class="m-nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa fa-fw fa-envelope"></i> 留言</a></li><li class="m-nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa fa-fw fa-address-book"></i> 友链</a></li><li><div class="divider"></div></li><li><a href="https://github.com/JoyTsing" class="waves-effect waves-light" target="_blank"><i class="fa fa-github-square fa-fw"></i>Follow Me</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#000;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href="https://github.com/JoyTsing" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Follow Me" data-position="left" data-delay="50"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a></nav></header><div class="bg-cover pd-header post-cover" style="background-image:url(/medias/featureimages/3.jpg)"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">spdlog库源码阅读</h1></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{width:345px;padding-left:20px}.toc-widget .toc-title{margin:35px 0 15px 0;padding-left:17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content{height:calc(100vh - 250px);overflow:auto}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px;position:absolute;right:23.5vw;display:block}#toc-content .is-active-link{color:#42b983}#floating-toc-btn{position:fixed;right:15px;bottom:76px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/Cpp/"><span class="chip bg-color">Cpp</span> </a><a href="/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"><span class="chip bg-color">源码阅读</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/Cpp/" class="post-category">Cpp</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp; 2024-03-21</div><div class="post-date info-break-policy"><i class="fa fa-calendar-check-o fa-fw"></i>更新日期:&nbsp;&nbsp; 2024-03-22</div><div class="info-break-policy"><i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp; 6.3k</div><div class="info-break-policy"><i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp; 25 分</div><div id="busuanzi_container_page_pv" class="info-break-policy"><i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp; <span id="busuanzi_value_page_pv"></span></div></div></div><hr class="clearfix"><div class="card-content article-card-content"><div id="articleContent"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>阅读源码是学习进阶必须越过的一步，同时也要学习其他人阅读源码的方式和经验，本文内容不全是个人做的<del>比如图就是从网上偷来的</del>，站在巨人肩膀上才能更好地让自己看到更多。</p><p>源码地址在这：<a href="https://github.com/gabime/spdlog">spdlog</a>，同时贴上一个不错的<a href="https://www.cnblogs.com/fortunely/p/17388565.html">笔记帖子</a>。</p><h2 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h2><p>spdlog的是一个支持多平台的日志库，使用十分方便。且既支持header-only version，也支持compiled version。header-only的全部代码都在项目的include文件夹下，直接将里面的内容copy到自己的项目里就能用。spdlog主要由logger（也包括async_logger）、sink、formatter、registry这四个部分组成，它们之间的基本逻辑结构如下图所示:</p><p><img src="/posts/38320/v2-eafecc8f5d2bcbe542691f7fc6d4263e_r.jpg" alt="spdlog基本逻辑结构"></p><ul><li><strong>spdlog log API</strong> —— 是建立在logger之上的，只是对logger使用的封装，目的只是为了能够像官网给的示例代码spdlog::info(“Welcome to spdlog!”);那样，让用户能够以最简单的方式使用spdlog打印出log。这是一种从用户使用维度出发的程序设计思想。</li><li><strong>logger</strong> —— 是spdlog开始处理日志的入口。sync-logger主要负责日志信息的整理，将格式化（通过第三方库fmt）后的日志内容、日志等级、日志时间等信息“整理”到一个名为log_msg结构体的对象中，然后再交给下游的sink进行处理。而对于async-logger，则是在将整理后的log_msg对象交给线程池，让线程池去处理后续的工作。</li><li><strong>sink</strong> —— 接收log_msg对象，并通过formatter将对象中所含有的信息转换成字符串，最后将字符串输出到指定的地方，例如控制台、文件等，甚至通过tcp/udp将字符串发送到指定的地方。sink译为“下沉”，扩展一下可以理解为“落笔”，做的是把日志真正记录下来的事情。</li><li><strong>formatter</strong> —— 负责将log_msg对象中的信息转换成字符串，例如将等级、时间、实际内容等。时间的格式和精度、等级输出显示的颜色等都是由formatter决定的。支持用户自动以格式。</li><li><strong>registry</strong> —— 负责管理所有的logger，包括创建、销毁、获取等。通过registry用户还可以对所有的logger进行一些全局设置，例如设置日志等级。</li></ul><h2 id="sync-logger"><a href="#sync-logger" class="headerlink" title="sync-logger"></a>sync-logger</h2><p>这部分的代码都在logger.h和logger-inl.h中，对应logger类。logger要做的事情就是将要记录的内容通过函数调用层层传递到，最后到sink。以logger中成员函数info两种调用情况为例，展示logger的调用过程。</p><p><img src="/posts/38320/image-20240322162258564.png" alt></p><p>具体函数签名：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 调用例如spdlog::info("Welcome to spdlog!");</span>
<span class="token comment" spellcheck="true">// 或者spdlog::info(num);</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">info</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span>
<span class="token punctuation">{</span> <span class="token function">log</span><span class="token punctuation">(</span>level<span class="token operator">::</span>info<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 确定log等级为info</span>

<span class="token comment" spellcheck="true">// 调用例如spdlog::info("Support for floats {:03.2f}", 1.23456);</span>
<span class="token comment" spellcheck="true">// 或者spdlog::info("Positional args are {1} {0}..", "too", "supported");</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">info</span><span class="token punctuation">(</span>format_string_t<span class="token operator">&lt;</span>Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span> fmt<span class="token punctuation">,</span> Args <span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span>
<span class="token punctuation">{</span> <span class="token function">log</span><span class="token punctuation">(</span>level<span class="token operator">::</span>info<span class="token punctuation">,</span> fmt<span class="token punctuation">,</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Args<span class="token operator">></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 确定log等级为info</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">log</span><span class="token punctuation">(</span>level<span class="token operator">::</span>level_enum lvl<span class="token punctuation">,</span> <span class="token keyword">const</span> T <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span>
<span class="token punctuation">{</span> <span class="token function">log</span><span class="token punctuation">(</span>source_loc<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> lvl<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 接着再确定日志调用的位置（文件、函数名、行号）</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">log</span><span class="token punctuation">(</span>level<span class="token operator">::</span>level_enum lvl<span class="token punctuation">,</span> format_string_t<span class="token operator">&lt;</span>Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span> fmt<span class="token punctuation">,</span> Args <span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span>
<span class="token punctuation">{</span> <span class="token function">log</span><span class="token punctuation">(</span>source_loc<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> lvl<span class="token punctuation">,</span> fmt<span class="token punctuation">,</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Args<span class="token operator">></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 接着再确定日志调用的位置（文件、函数名、行号）</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">log</span><span class="token punctuation">(</span>source_loc loc<span class="token punctuation">,</span> level<span class="token operator">::</span>level_enum lvl<span class="token punctuation">,</span> <span class="token keyword">const</span> T <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span>
<span class="token punctuation">{</span> <span class="token function">log</span><span class="token punctuation">(</span>loc<span class="token punctuation">,</span> lvl<span class="token punctuation">,</span> <span class="token string">"{}"</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 因为spdlog::info(num);可以等价为spdlog::info("{}", num);，所以这里加了一个“{}”</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">log</span><span class="token punctuation">(</span>source_loc loc<span class="token punctuation">,</span> level<span class="token operator">::</span>level_enum lvl<span class="token punctuation">,</span> format_string_t<span class="token operator">&lt;</span>Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span> fmt<span class="token punctuation">,</span> Args <span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span>
<span class="token punctuation">{</span> <span class="token function">log_</span><span class="token punctuation">(</span>loc<span class="token punctuation">,</span> lvl<span class="token punctuation">,</span> details<span class="token operator">::</span><span class="token function">to_string_view</span><span class="token punctuation">(</span>fmt<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Args<span class="token operator">></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 成员函数info两种调用过程都会汇集到此处</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>logger的调用过程是层层传递的，传递过程中不断添加各种信息，最后两种方式的调用都汇集到log_函数中，log_函数实现如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp">    <span class="token comment" spellcheck="true">// common implementation for after templated public api has been resolved</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">log_</span><span class="token punctuation">(</span>source_loc loc<span class="token punctuation">,</span> level<span class="token operator">::</span>level_enum lvl<span class="token punctuation">,</span> string_view_t fmt<span class="token punctuation">,</span> Args <span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">bool</span> log_enabled <span class="token operator">=</span> <span class="token function">should_log</span><span class="token punctuation">(</span>lvl<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">bool</span> traceback_enabled <span class="token operator">=</span> tracer_<span class="token punctuation">.</span><span class="token function">enabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>log_enabled <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>traceback_enabled<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    SPDLOG_TRY <span class="token punctuation">{</span>
        memory_buf_t buf<span class="token punctuation">;</span>
<span class="token macro property">#<span class="token directive keyword">ifdef</span> SPDLOG_USE_STD_FORMAT</span>
        fmt_lib<span class="token operator">::</span><span class="token function">vformat_to</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">back_inserter</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span> fmt<span class="token punctuation">,</span> fmt_lib<span class="token operator">::</span><span class="token function">make_format_args</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property">#<span class="token directive keyword">else</span></span>
        fmt<span class="token operator">::</span><span class="token function">vformat_to</span><span class="token punctuation">(</span>fmt<span class="token operator">::</span><span class="token function">appender</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span> fmt<span class="token punctuation">,</span> fmt<span class="token operator">::</span><span class="token function">make_format_args</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>

        details<span class="token operator">::</span>log_msg <span class="token function">log_msg</span><span class="token punctuation">(</span>loc<span class="token punctuation">,</span> name_<span class="token punctuation">,</span> lvl<span class="token punctuation">,</span> <span class="token function">string_view_t</span><span class="token punctuation">(</span>buf<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> buf<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">log_it_</span><span class="token punctuation">(</span>log_msg<span class="token punctuation">,</span> log_enabled<span class="token punctuation">,</span> traceback_enabled<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">SPDLOG_LOGGER_CATCH</span><span class="token punctuation">(</span>loc<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先判断是否需要记录日志should_log(lvl)，以及是否需要traceback，如果都不需要则直接返回，判断逻辑是当前log等级是否大于logger的log等级。而traceback是spdlog的另一个功能，对我们理解spdlog的调用过程相关程度不高，可不必细究。至于fmt库将输出格式化，C++20中STL库有了自带的fmt和location，在学习之后可以自己试着写一个log库。</p><p>至此logger完成了它的主要工作，最后很剩下的工作就是把log_msg对象交给下游的sink进行处理了，就是上面最后一句代码“<code>log_it_(log_msg, log_enabled, traceback_enabled);”</code>要做的事。这部分代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// protected methods</span>
SPDLOG_INLINE <span class="token keyword">void</span> logger<span class="token operator">::</span><span class="token function">log_it_</span><span class="token punctuation">(</span><span class="token keyword">const</span> spdlog<span class="token operator">::</span>details<span class="token operator">::</span>log_msg <span class="token operator">&amp;</span>log_msg<span class="token punctuation">,</span>
                                   <span class="token keyword">bool</span> log_enabled<span class="token punctuation">,</span>
                                   <span class="token keyword">bool</span> traceback_enabled<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>log_enabled<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">sink_it_</span><span class="token punctuation">(</span>log_msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>traceback_enabled<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        tracer_<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>log_msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

SPDLOG_INLINE <span class="token keyword">void</span> logger<span class="token operator">::</span><span class="token function">sink_it_</span><span class="token punctuation">(</span><span class="token keyword">const</span> details<span class="token operator">::</span>log_msg <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>sink <span class="token operator">:</span> sinks_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>sink<span class="token operator">-</span><span class="token operator">></span><span class="token function">should_log</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>level<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            SPDLOG_TRY <span class="token punctuation">{</span> sink<span class="token operator">-</span><span class="token operator">></span><span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
            <span class="token function">SPDLOG_LOGGER_CATCH</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>source<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">should_flush_</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">flush_</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

SPDLOG_INLINE <span class="token keyword">void</span> logger<span class="token operator">::</span><span class="token function">flush_</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>sink <span class="token operator">:</span> sinks_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        SPDLOG_TRY <span class="token punctuation">{</span> sink<span class="token operator">-</span><span class="token operator">></span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token function">SPDLOG_LOGGER_CATCH</span><span class="token punctuation">(</span><span class="token function">source_loc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>log_it函数又进一步调用了sink_it函数。在sink_it函数中，首先遍历了sinks_中的所有sink，在把msg交由每个sink去处理。</p><blockquote><p>sinks并不是一个类，而是一系列类，以基类-派生类形式组织，一个sink派生类代表了一种输出log消息方式，输出目标可以是普通文件stdout、stderr，或者syslog等等。sink系列类主要负责从logger接收用户log消息，按指定模式（pattern）进行格式化（format），得到一条完整的、格式化后的log消息，然后将其写到目标文件。sink系列类的实现，全部位于include/spdlog/sinks目录。</p></blockquote><p>sinks_是logger的成员变量，其声明为“std::vector&lt;sink_ptr&gt; sinks_;”。可以看出一个logger是可以对应多个sink的，同时sink实际上还是指针形式保存在logger中的，意味着也可以存在多个logger都指向同一个sink的情况。这样日志的输入端（logger）和输出端（sink）就解耦了。这样方便我们扩展，比如现在想让日志同时输出到文件和控制台，只需要在创建logger的时候把两个sink都添加进去就可以了。</p><p><code>sink_it_</code>函数中还调用了<code>flush\_</code>函数，这个函数的作用是让所有sink都进行一次flush操作。前面的<code>sink-&gt;log(msg)</code>这是写入了缓冲区，而sink-&gt;flush()是将缓冲区的内容进一步写入到文件或者控制台等最终目的地。而且在<code>sink_it</code>函数调用<code>flush_</code>函数之前，还调用了<code>should_flush_</code>函数，函数中判断了msg的等级和<code>flush_level_</code>的关系，如果msg的等级大于<code>flush_level_</code>则返回true，否则返回false。这么做的目的是减少不必要的flush操作。例如我们像保存info及其以上等级的日志，但是绝大多数时候我们并会实时地查看info级别的日志，但是error级别的日志我们却希望能够及时展示出来。那么我们可以将<code>flush_level_</code>设置为error，这样只有error级别的日志才会进行flush操作。</p><h3 id="同步工厂方法"><a href="#同步工厂方法" class="headerlink" title="同步工厂方法"></a>同步工厂方法</h3><p>通常，一个工厂方法创建一种对象，如果想创建不同类型的对象，就传入参数，工厂方法内部进行判断后创建不同类型对象。synchronous_factory的精妙之处在于，函数参数用来创建对象，模板参数用来指定要创建的类型（有关的部分）。</p><p>logger_name对于registry全局注册表来说，是唯一标识logger对象的。</p><p>这里有一个潜在的约定，所有工厂方法必须实现一个static create方法，通过模板参数Sink创建不同类型Sink派生类对象，然后绑定到新建的logger对象，从而实现不同的功能。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// Default logger factory-  creates synchronous loggers</span>
<span class="token keyword">class</span> <span class="token class-name">logger</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> synchronous_factory
<span class="token punctuation">{</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Sink<span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> SinkArgs<span class="token operator">></span>
    <span class="token keyword">static</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>spdlog<span class="token operator">::</span>logger<span class="token operator">></span> <span class="token function">create</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string logger_name<span class="token punctuation">,</span>  SinkArgs <span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">auto</span> sink <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>Sink<span class="token operator">></span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>SinkArgs<span class="token operator">></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 模板参数Sink决定了要具体Sink类型</span>
        <span class="token keyword">auto</span> new_logger <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>spdlog<span class="token operator">::</span>logger<span class="token operator">></span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>logger_name<span class="token punctuation">)</span><span class="token punctuation">,</span>  std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>sink<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用logger name及sink来创建logger对象</span>
        details<span class="token operator">::</span>registry<span class="token operator">::</span><span class="token function">instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">initialize_logger</span><span class="token punctuation">(</span>new_logger<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始化logger, 并添加到全局注册表</span>
        <span class="token keyword">return</span> new_logger<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="async-logger"><a href="#async-logger" class="headerlink" title="async-logger"></a>async-logger</h2><p>async-logger的代码在asyn_logger.h和async_looger-inl.h中，对应async_logger类。async_logger继承自logger，前面关于接受日志内容整理log_msg对象中的工作照常做，将对sink的调用（包括sink-&gt;log(msg)和sink-&gt;flush()）都交由线程池去执行了，由此便实现了异步。代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> spdlog<span class="token operator">::</span>async_logger<span class="token operator">::</span><span class="token function">sink_it_</span><span class="token punctuation">(</span><span class="token keyword">const</span> details<span class="token operator">::</span>log_msg <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> pool_ptr <span class="token operator">=</span> thread_pool_<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        pool_ptr<span class="token operator">-</span><span class="token operator">></span><span class="token function">post_log</span><span class="token punctuation">(</span><span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> msg<span class="token punctuation">,</span> overflow_policy_<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
        <span class="token function">throw_spdlog_ex</span><span class="token punctuation">(</span><span class="token string">"async log: thread pool doesn't exist anymore"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// thread_pool_ 的声明</span>
std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span>details<span class="token operator">::</span>thread_pool<span class="token operator">></span> thread_pool_<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>线程池通过<code>pool_ptr-&gt;post_log(shared_from_this(), msg, overflow_policy_);</code>这句代码持有了当前<code>asyn_logger</code>的<code>shared_ptr</code>。那这样asyn_logger就不能再以shared_ptr的形式持有线程池了，因为会存在交叉引用带来的内存泄露问题。所以这里使用weak_ptr来持有线程池。毫无疑问，async_logger实现的重点是线程池。</p><p>线程池里面要有一个多生产多消费的线程安全队列，用来存放日志内容。可以有多个async_logger（即生产者）向里面生产日志，又同时又多个线程（即消费者）从里面消费日志。这个队列的容量应该是有限的，当队列满了之后向里面生产日志可以有不同的策略，spdlog提供了三种策略：阻塞、丢弃新日志和丢弃旧日志。为方便实现这个需求，用循环队列来实现。</p><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>循环队列的代码在circular_q.h中，实现起来不难。这里只提两点可能在没开始动手实现之前可能想不起来的点：</p><ul><li>circular_q应设计成类模板，使其能够支持各种数据类型；</li><li>circular_q中实际存数据的std::vector&lt;T&gt; vec_的大小应该比circular_q能存的数据大小多一个，这样才能队列是满的还是空的，两个状态不会混淆。</li></ul><h3 id="多生产多消费的线程安全队列"><a href="#多生产多消费的线程安全队列" class="headerlink" title="多生产多消费的线程安全队列"></a>多生产多消费的线程安全队列</h3><p>这部分代码在mpmc_blocking_q.h中，我们先来看一下其中的成员变量：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">mpmc_blocking_queue</span>
<span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token operator">::</span>mutex queue_mutex_<span class="token punctuation">;</span>
    std<span class="token operator">::</span>condition_variable push_cv_<span class="token punctuation">;</span>
    std<span class="token operator">::</span>condition_variable pop_cv_<span class="token punctuation">;</span>
    spdlog<span class="token operator">::</span>details<span class="token operator">::</span>circular_q<span class="token operator">&lt;</span>T<span class="token operator">></span> q_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>push_cv_和pop_cv_是用来实现生产者消费者模型的关键，其存在的目的是当q_为空或满时，消费者线程或生产者线程是阻塞式等待，而不是空转。我们看看向mpmc_blocking_queue中生产和消费数据的代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>T <span class="token operator">&amp;&amp;</span>item<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">{</span>
        std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span>queue_mutex_<span class="token punctuation">)</span><span class="token punctuation">;</span>
        pop_cv_<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>q_<span class="token punctuation">.</span><span class="token function">full</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        q_<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    push_cv_<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">dequeue</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span>popped_item<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">{</span>
        std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span>queue_mutex_<span class="token punctuation">)</span><span class="token punctuation">;</span>
        push_cv_<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>q_<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        popped_item <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>q_<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        q_<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    pop_cv_<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="spdlog线程池"><a href="#spdlog线程池" class="headerlink" title="spdlog线程池"></a>spdlog线程池</h3><p>站在数据（环形队列）的角度，线程池不断接收生产者（前端线程）输入的数据，同时不断从队列取出数据，交给消费者处理（后端线程）。</p><p><img src="/posts/38320/741401-20221027012235353-635622687.png" alt></p><p>这里面包含几个重要线程池操作：</p><ul><li>前端线程往线程池插入数据；</li><li>从线程池取出数据交给后端线程处理；</li><li>线程池数据满时，插入数据异常处理；</li><li>线程池空时，取出数据异常处理；</li></ul><p>线程池的代码在<code>thread_pool.h</code>和<code>thread_pool-inl.h</code>中，这里的线程池跟那些通用的线程池实现相比，核心没变，每个线程都是负责从队列里面取东西然后执行，不同是线程池因为是专门做日志输出工作的，所以去从队列里去的东西是日志相关的东西，通用的线程池一般取的是函数指针。由于线程池的唯一需要确保线程安全的数据是环形队列，而环形队列本身提供线程安全支持，因此线程池无需额外支持线程安全。</p><p>简单看看每个线程（worker）做的事情：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> thread_pool<span class="token operator">::</span><span class="token function">worker_loop_</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">process_next_msg_</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">bool</span> thread_pool<span class="token operator">::</span><span class="token function">process_next_msg_</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    async_msg incoming_async_msg<span class="token punctuation">;</span>
    q_<span class="token punctuation">.</span><span class="token function">dequeue</span><span class="token punctuation">(</span>incoming_async_msg<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">switch</span> <span class="token punctuation">(</span>incoming_async_msg<span class="token punctuation">.</span>msg_type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> async_msg_type<span class="token operator">::</span>log<span class="token operator">:</span> <span class="token punctuation">{</span>
            incoming_async_msg<span class="token punctuation">.</span>worker_ptr<span class="token operator">-</span><span class="token operator">></span><span class="token function">backend_sink_it_</span><span class="token punctuation">(</span>incoming_async_msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">case</span> async_msg_type<span class="token operator">::</span>flush<span class="token operator">:</span> <span class="token punctuation">{</span>
            incoming_async_msg<span class="token punctuation">.</span>worker_ptr<span class="token operator">-</span><span class="token operator">></span><span class="token function">backend_flush_</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">case</span> async_msg_type<span class="token operator">::</span>terminate<span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">default</span><span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token function">assert</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的<code>backend_sink_it_</code>和<code>backend_flush_</code>里面的实现跟前面同步logger中的l<code>ogger::sink_it_</code>和<code>logger::flush</code>_是一样的。所以看到这就知道<code>asyn_logger</code>就是把其中调用sink这部分工作交给线程池来做了，仅此而已。</p><h3 id="异步工厂方法"><a href="#异步工厂方法" class="headerlink" title="异步工厂方法"></a>异步工厂方法</h3><p>针对所使用的环形队列，当队列满时，如果插入数据，有两种策略：阻塞、非阻塞，分别对应工厂类型async_factory、async_factory_nonblock：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> async_factory <span class="token operator">=</span> async_factory_impl<span class="token operator">&lt;</span>async_overflow_policy<span class="token operator">::</span>block<span class="token operator">></span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 阻塞策略</span>
<span class="token keyword">using</span> async_factory_nonblock <span class="token operator">=</span>  async_factory_impl<span class="token operator">&lt;</span>async_overflow_policy<span class="token operator">::</span>overrun_oldest<span class="token operator">></span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 非阻塞策略</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以看到上面2种工厂类型，都是通过<code>async_factory_impl</code>来实现的。那么，<code>async_factory_impl</code>是如何实现的呢？<code>async_factory_impl</code>也遵循工厂方法的潜规则：提供<code>static create</code>方法，根据模板参数Sink创建不同类型sink对象并绑定到新建的logger对象。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// async logger factory - creates async loggers backed with thread pool.</span>
<span class="token comment" spellcheck="true">// if a global thread pool doesn't already exist, create it with default queue</span>
<span class="token comment" spellcheck="true">// size of 8192 items and single thread.</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span>async_overflow_policy OverflowPolicy <span class="token operator">=</span> async_overflow_policy<span class="token operator">::</span>block<span class="token operator">></span>
<span class="token keyword">struct</span> async_factory_impl
<span class="token punctuation">{</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Sink<span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> SinkArgs<span class="token operator">></span>
    <span class="token keyword">static</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>async_logger<span class="token operator">></span> <span class="token function">create</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string logger_name<span class="token punctuation">,</span> SinkArgs  <span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">auto</span> <span class="token operator">&amp;</span>registry_inst <span class="token operator">=</span> details<span class="token operator">::</span>registry<span class="token operator">::</span><span class="token function">instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 如果全局线程池不存在，就创建一个</span>
        <span class="token comment" spellcheck="true">// create global thread pool if not already exists..</span>

        <span class="token keyword">auto</span> <span class="token operator">&amp;</span>mutex <span class="token operator">=</span> registry_inst<span class="token punctuation">.</span><span class="token function">tp_mutex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>recursive_mutex<span class="token operator">></span> <span class="token function">tp_lock</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">auto</span> tp <span class="token operator">=</span> registry_inst<span class="token punctuation">.</span><span class="token function">get_tp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>tp <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            tp <span class="token operator">=</span>  std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>details<span class="token operator">::</span>thread_pool<span class="token operator">></span><span class="token punctuation">(</span>details<span class="token operator">::</span>default_async_q_size<span class="token punctuation">,</span> <span class="token number">1U</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            registry_inst<span class="token punctuation">.</span><span class="token function">set_tp</span><span class="token punctuation">(</span>tp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">auto</span> sink <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>Sink<span class="token operator">></span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>SinkArgs<span class="token operator">></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 创建新async_logger对象同时, 绑定线程池</span>
        <span class="token keyword">auto</span> new_logger <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>async_logger<span class="token operator">></span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>logger_name<span class="token punctuation">)</span><span class="token punctuation">,</span>  std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>sink<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>tp<span class="token punctuation">)</span><span class="token punctuation">,</span> OverflowPolicy<span class="token punctuation">)</span><span class="token punctuation">;</span>
        registry_inst<span class="token punctuation">.</span><span class="token function">initialize_logger</span><span class="token punctuation">(</span>new_logger<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> new_logger<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>跟同步工厂方法最大的区别是：异步工厂方法，是依附于一个（registry单例管理的）全局线程池的。创建出来的logger对象真实类型是派生类<code>async_logger</code>。而<code>async_logger</code>通过一个弱指针指向线程池。上面的只是工厂的类型，并非工厂方法。用户想要利用工厂方法创建对象，需要用到下面的<code>create_async</code>, <code>create_async_nb</code>方法：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 采用阻塞策略的异步工厂方法</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Sink<span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> SinkArgs<span class="token operator">></span>
<span class="token keyword">inline</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>spdlog<span class="token operator">::</span>logger<span class="token operator">></span> <span class="token function">create_async</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string logger_name<span class="token punctuation">,</span>  SinkArgs <span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> sink_args<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> async_factory<span class="token operator">::</span>create<span class="token operator">&lt;</span>Sink<span class="token operator">></span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>logger_name<span class="token punctuation">)</span><span class="token punctuation">,</span>  std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>SinkArgs<span class="token operator">></span><span class="token punctuation">(</span>sink_args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 采用非阻塞策略的异步工厂方法</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Sink<span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> SinkArgs<span class="token operator">></span>
<span class="token keyword">inline</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>spdlog<span class="token operator">::</span>logger<span class="token operator">></span> <span class="token function">create_async_nb</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string logger_name<span class="token punctuation">,</span>  SinkArgs <span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> sink_args<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> async_factory_nonblock<span class="token operator">::</span>create<span class="token operator">&lt;</span>Sink<span class="token operator">></span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>logger_name<span class="token punctuation">)</span><span class="token punctuation">,</span>  std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>SinkArgs<span class="token operator">></span><span class="token punctuation">(</span>sink_args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在客户端，比如你想创建一个<code>basic_logger_mt</code>，即一个基本都用于多线程环境的<code>async_logger</code>，可以这样封装工厂方法，然后供APP调用：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// include/spdlog/sinks/basic_file_sink.h</span>

<span class="token comment" spellcheck="true">// 封装工厂方法，供APP调用</span>
<span class="token comment" spellcheck="true">// factory functions</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Factory <span class="token operator">=</span> spdlog<span class="token operator">::</span>synchronous_factory<span class="token operator">></span>
<span class="token keyword">inline</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>logger<span class="token operator">></span> <span class="token function">basic_logger_mt</span><span class="token punctuation">(</span>
    <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>logger_name<span class="token punctuation">,</span> <span class="token keyword">const</span> filename_t <span class="token operator">&amp;</span>filename<span class="token punctuation">,</span> <span class="token keyword">bool</span> truncate <span class="token operator">=</span>  <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">const</span> file_event_handlers <span class="token operator">&amp;</span>event_handlers <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> Factory<span class="token operator">::</span><span class="token keyword">template</span> create<span class="token operator">&lt;</span>sinks<span class="token operator">::</span>basic_file_sink_mt<span class="token operator">></span><span class="token punctuation">(</span>logger_name<span class="token punctuation">,</span>  filename<span class="token punctuation">,</span> truncate<span class="token punctuation">,</span> event_handlers<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// APP端创建async_logger对象</span>
<span class="token comment" spellcheck="true">// spdlog::init_thread_pool(32768, 1); // queue with max 32k items 1 backing  thread.</span>
<span class="token keyword">auto</span> async_file <span class="token operator">=</span>  spdlog<span class="token operator">::</span>basic_logger_mt<span class="token operator">&lt;</span>spdlog<span class="token operator">::</span>async_factory<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"async_file_logger"</span><span class="token punctuation">,</span>  <span class="token string">"logs/async_log.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="sink"><a href="#sink" class="headerlink" title="sink"></a>sink</h2><h3 id="sink-1"><a href="#sink-1" class="headerlink" title="sink"></a>sink</h3><p>sink相关的代码都在sinks文件夹中，有不同种类的sink实现，以满足用户对不同输出目的地的需求，比如有控制台、文件、网络、数据库等。</p><pre class="line-numbers language-text"><code class="language-text">sink 
   | ---> base_sink ---> basic_file_sink
   | ---> stdout_sink_base<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>sink是所有不同类型sink的基类，它提供了统一的接口，实际上并它的实现并没有多少代码量。我们看看它的定义：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> level_t <span class="token operator">=</span> std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">sink</span> 
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">sink</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">const</span> details<span class="token operator">::</span>log_msg <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">set_pattern</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>pattern<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">set_formatter</span><span class="token punctuation">(</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>spdlog<span class="token operator">::</span>formatter<span class="token operator">></span> sink_formatter<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token function">set_level</span><span class="token punctuation">(</span>level<span class="token operator">::</span>level_enum log_level<span class="token punctuation">)</span><span class="token punctuation">;</span>
    level<span class="token operator">::</span>level_enum <span class="token function">level</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    <span class="token keyword">bool</span> <span class="token function">should_log</span><span class="token punctuation">(</span>level<span class="token operator">::</span>level_enum msg_level<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>

<span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token comment" spellcheck="true">// sink log level - default is all</span>
    level_t level_<span class="token punctuation">{</span>level<span class="token operator">::</span>trace<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>sink类只有一个成员变量，level_类型是原子变量。同时之后跟level_相关的成员函数在这里实现了，其他的都是纯虚函数，需要子类去实现。这是因为sink及其子类都要是线程安全的，因为此处level_已经是原子变量了，可以做到线程安全了，所以跟level_相关的成员函数就直接在此处得到实现。</p><p>其他成员函数log()和flush()的功能是将从logger传过来的msg转成字符串然后写到缓冲区和从缓冲区写到目的地（控制台、文件等）。<code>set_pattern()</code>和<code>set_formatter()</code>是用来设置日志格式的，例如显示时间的样式等，这两个函数一定程度上是等价的。具体是怎么格式化的，我们留到将formatter部分的时候再讲，本文不再展开。</p><p>既然sink及其子类都要求线程安全，那么就应该在sink这个基类这里把线程安全相关的代码都写好，这样子类继承时候再写的代码只管逻辑就行，不用再考虑线程安全问题了。这么想是对的，确实应该在父类中把线程安全相关的代码都写好，spdlog也是这么做的。但是是在base_sink类里实现的，而不是sink类。为什么是在base_sink类里，而不是在sink类里？以及为什么stdout_sink_base直接继承自sink而不是base_sink？</p><h3 id="base-sink"><a href="#base-sink" class="headerlink" title="base_sink"></a>base_sink</h3><p>base_sink继承自sink，而且是个类模板，代码也很少，就是对该加锁地方加上了锁，以此来实现线程安全。以下是base_sink部分代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Mutex<span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">base_sink</span> <span class="token operator">:</span> <span class="token keyword">public</span> sink <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">const</span> details<span class="token operator">::</span>log_msg <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span> final <span class="token punctuation">{</span>
        std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>Mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span>mutex_<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sink_it_</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span> final <span class="token punctuation">{</span>
        std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>Mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span>mutex_<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">flush_</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">protected</span><span class="token operator">:</span>
    Mutex mutex_<span class="token punctuation">;</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">sink_it_</span><span class="token punctuation">(</span><span class="token keyword">const</span> details<span class="token operator">::</span>log_msg <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">flush_</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>log和flush函数在sink是纯虚函数，需要在子类中实现。而base_sink的实现仅仅只是加锁之后再进一步调用<code>sink_it_</code>和f<code>lush_</code>，只是做了线程安全方面的处理，没有具体业务逻辑。这里需要强调一下的是，锁mutex_的类型是Mutex是通过模板参数传进来的，也就是说base_sink是支持多种锁类型的。用模板来支持多种锁类型，这还不是这个模板用法的最值得说道的点。最值得说道的点是，这样的实现能够同时让base_sink十分优雅的支持无锁版本。</p><p>需要说明，对于只在单线程中使用spdlog，我们肯定不希望每次写日志还要加锁，毕竟这带来的白白的性能损耗，所以也必须给所有类型的sink至少提供有锁和无锁两种版本。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> basic_file_sink_mt <span class="token operator">=</span> basic_file_sink<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span><span class="token punctuation">;</span>
<span class="token keyword">using</span> basic_file_sink_st <span class="token operator">=</span> basic_file_sink<span class="token operator">&lt;</span>details<span class="token operator">::</span>null_mutex<span class="token operator">></span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> null_mutex <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上是basic_file_sink中的两行代码，basic_file_sink继承自Mutex。<code>basic_file_sink_mt</code>后面的mt就是multi-thread的意思，表示多线程版本，所以模板参数用的是std::mutex。<code>basic_file_sink_st</code>后面的st就是single-thread的意思，表示单线程版本，模板参数用的是<code>details::null_mutex</code>，这个null_mutex是spdlog自己实现的空锁，我的评价是妙啊。</p><h3 id="basic-file-sink"><a href="#basic-file-sink" class="headerlink" title="basic_file_sink"></a>basic_file_sink</h3><p>接着上面，我们继续来看basic_file_sink的代码。就是把base_sink的两个纯虚函数sink_it_和flush_实现了，本身逻辑也是十分简单。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Mutex<span class="token operator">></span>
<span class="token keyword">void</span> basic_file_sink<span class="token operator">&lt;</span>Mutex<span class="token operator">></span><span class="token operator">::</span><span class="token function">sink_it_</span><span class="token punctuation">(</span><span class="token keyword">const</span> details<span class="token operator">::</span>log_msg <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    memory_buf_t formatted<span class="token punctuation">;</span>
    formatter_<span class="token operator">-</span><span class="token operator">></span><span class="token function">format</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> formatted<span class="token punctuation">)</span><span class="token punctuation">;</span>
    file_helper_<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>formatted<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Mutex<span class="token operator">></span>
<span class="token keyword">void</span> basic_file_sink<span class="token operator">&lt;</span>Mutex<span class="token operator">></span><span class="token operator">::</span><span class="token function">flush_</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    file_helper_<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>sink_it_中的<code>formatter_-&gt;format(msg, formatted)</code>就是将msg中的内容格式化成字符串，然后写入到formatted中。<code>file_helper_.write</code>和<code>file_helper_.flush</code>中的核心代码（ubuntu环境下）无非也就是<code>std::fwrite</code>和<code>std::fflush</code>两个库函数。</p><h3 id="stdout-sinks"><a href="#stdout-sinks" class="headerlink" title="stdout_sinks"></a>stdout_sinks</h3><p>前面我们提到，stdout_sink_base直接继承自sink而不是base_sink。stdout_sink_base也是要考虑线程安全的，我们来看看它与base_sink有何不同。作为对比我们把base_sink的部分代码也贴过出来：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Mutex<span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">base_sink</span> <span class="token operator">:</span> <span class="token keyword">public</span> sink <span class="token punctuation">{</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    Mutex mutex_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> ConsoleMutex<span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">stdout_sink_base</span> <span class="token operator">:</span> <span class="token keyword">public</span> sink <span class="token punctuation">{</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    ConsoleMutex<span class="token operator">::</span>mutex_t <span class="token operator">&amp;</span>mutex_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最大的区别就在于成员变量<code>mutex_</code>的类型不同，<code>stdout_sink_base</code>的锁类型是带引用的。因为<code>stdout_sink_base</code>就是输出到控制台，一个程序只能有一个控制台啊，因此<code>stdout_sink_base</code>中的<code>mutex_</code>应该是全局唯一的，是个单例，那么很理所当然的这里用引用类型。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> console_mutex <span class="token punctuation">{</span>
    <span class="token keyword">using</span> mutex_t <span class="token operator">=</span> std<span class="token operator">::</span>mutex<span class="token punctuation">;</span>
    <span class="token keyword">static</span> mutex_t <span class="token operator">&amp;</span><span class="token function">mutex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">static</span> mutex_t s_mutex<span class="token punctuation">;</span>
        <span class="token keyword">return</span> s_mutex<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> console_nullmutex <span class="token punctuation">{</span>
    <span class="token keyword">using</span> mutex_t <span class="token operator">=</span> null_mutex<span class="token punctuation">;</span>
    <span class="token keyword">static</span> mutex_t <span class="token operator">&amp;</span><span class="token function">mutex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">static</span> mutex_t s_mutex<span class="token punctuation">;</span>
        <span class="token keyword">return</span> s_mutex<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="formatter"><a href="#formatter" class="headerlink" title="formatter"></a>formatter</h2><p>不在这里介绍，感兴趣可以好好学学C++20新增的format。</p><h2 id="registry"><a href="#registry" class="headerlink" title="registry"></a><strong>registry</strong></h2><p>spdlog主要由logger（也包括async_logger）、sink、formatter、registry这四个部分组成。实际上这三个已经足够将一条日志输出（记录）下来了，还剩下没介绍的registry则是负责管理前面那三个部件的。当然用户也可以不通过registry来自行管理。所以registry不是必须的，它本身的实现并不涉及spdlog的核心功能，只是为了更好的管理资源。例如通过registry，用户对所有logger设置日志等级、可以创建带有默认设置的logger之类的……</p><h3 id="默认logger和默认sink"><a href="#默认logger和默认sink" class="headerlink" title="默认logger和默认sink"></a>默认logger和默认sink</h3><p>registry的代码主要在registry.h、registry-inl.h。还记得这一句最简单的使用spdlog的代码吗？</p><pre class="line-numbers language-cpp"><code class="language-cpp">spdlog<span class="token operator">::</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Welcome to spdlog!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这里我们既没有创建logger，也没有设置sink，直接就可用了。实际上是registry帮我们创建了默认的logger和默认的sink，方便我们直接使用。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span> 
<span class="token keyword">void</span> <span class="token function">info</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 即spdlog::info</span>
    <span class="token function">default_logger_raw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">info</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

spdlog<span class="token operator">::</span>logger <span class="token operator">*</span><span class="token function">default_logger_raw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> registry<span class="token operator">::</span><span class="token function">instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get_default_raw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

registry <span class="token operator">&amp;</span>registry<span class="token operator">::</span><span class="token function">instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> registry s_instance<span class="token punctuation">;</span>
    <span class="token keyword">return</span> s_instance<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 直接用logger的裸指针的原因，spdlog是这么解释的：</span>
<span class="token comment" spellcheck="true">// To be used directly by the spdlog default api (e.g. spdlog::info)</span>
<span class="token comment" spellcheck="true">// This make the default API faster</span>
logger <span class="token operator">*</span>registry<span class="token operator">::</span><span class="token function">get_default_raw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> default_logger_<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

registry<span class="token operator">::</span><span class="token function">registry</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">auto</span> color_sink <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>sinks<span class="token operator">::</span>ansicolor_stdout_sink_mt<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>default_logger_name <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
    default_logger_ <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>spdlog<span class="token operator">::</span>logger<span class="token operator">></span><span class="token punctuation">(</span>default_logger_name<span class="token punctuation">,</span>
                                                       std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>color_sink<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到<code>spdlog::info</code>中<code>default_logger_raw()</code>得到了默认logger的指针，然后顺理成章就调用info输出日志。默认logger的指针则来自registry对象中的<code>default_logger_</code>成员变量。registry是单例，所以获取registry对象使用的是静态方法<code>registry::instance()</code>。最后我们看到<code>registry::registry()</code>中创建了默认logger，选择的sink是<code>ansicolor_stdout_sink_mt</code>，也就是彩色输出到控制台，最后的“_mt”表示是线程安全的sink。也就是说，当用户什么都没设置时调用spdlog::info时，结果是像控制台输出彩色日志，这也是用户刚上手spdlog最可能希望得到的结果。</p><h3 id="logger工厂"><a href="#logger工厂" class="headerlink" title="logger工厂"></a>logger工厂</h3><p>registry主要作用就是管理logger（例如将所有logger日志等级、格式等统一为相同的），那么logger创建的时候就要将其共享指针存在registry中，这样registry才能管理到。在考虑到简单易用的原则，用户可以不事先了解logger和registry概念，也不必时刻记得要把logger的共享指针存到registry中。因此spdlog提供了一系列获取logger的函数，这些函数除了构造logger对象之外，还将这个logger的共享指针存到registry中。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// stdout_logger_mt返回使用stdout_sink的logger，且多线程版本（线程安全的）</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Factory <span class="token operator">=</span> spdlog<span class="token operator">::</span>synchronous_factory<span class="token operator">></span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>logger<span class="token operator">></span> <span class="token function">stdout_logger_mt</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// basic_logger_st返回使用basic_file_sink的logger，且单线程版本（非线程安全的）</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Factory <span class="token operator">=</span> spdlog<span class="token operator">::</span>synchronous_factory<span class="token operator">></span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>logger<span class="token operator">></span> <span class="token function">basic_logger_st</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// rotating_logger_mt返回使用rotating_file_sink的logger，且多线程版本（线程安全的）</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Factory <span class="token operator">=</span> spdlog<span class="token operator">::</span>synchronous_factory<span class="token operator">></span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>logger<span class="token operator">></span> <span class="token function">rotating_logger_mt</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>spdlog几乎为所有类型的sink都提供了如上类似的logger创建函数。从函数名可以看出这类函数把sink的概念给隐藏了，普通用户只需要知道创建出来的logger能够把日志写到指定地方就行了，根本不需要知道sink这类东西的存在。我们以stdout_logger创建函数为例，看一下具体实现。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> stdout_sink_mt <span class="token operator">=</span> stdout_sink<span class="token operator">&lt;</span>details<span class="token operator">::</span>console_mutex<span class="token operator">></span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 有锁对应多线程版本</span>
<span class="token keyword">using</span> stdout_sink_st <span class="token operator">=</span> stdout_sink<span class="token operator">&lt;</span>details<span class="token operator">::</span>console_nullmutex<span class="token operator">></span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 无锁对应单线程版本</span>

<span class="token comment" spellcheck="true">// 模板参数Factory都默认为spdlog::synchronous_factory</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Factory<span class="token operator">></span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>logger<span class="token operator">></span> <span class="token function">stdout_logger_mt</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>logger_name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Factory<span class="token operator">::</span>create<span class="token operator">&lt;</span>sinks<span class="token operator">::</span>stdout_sink_mt<span class="token operator">></span><span class="token punctuation">(</span>logger_name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Factory<span class="token operator">></span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>logger<span class="token operator">></span> <span class="token function">stdout_logger_st</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>logger_name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Factory<span class="token operator">::</span>create<span class="token operator">&lt;</span>sinks<span class="token operator">::</span>stdout_sink_st<span class="token operator">></span><span class="token punctuation">(</span>logger_name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> synchronous_factory <span class="token punctuation">{</span>
    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Sink<span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> SinkArgs<span class="token operator">></span>
    <span class="token keyword">static</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>spdlog<span class="token operator">::</span>logger<span class="token operator">></span> <span class="token function">create</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string logger_name<span class="token punctuation">,</span> SinkArgs <span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">auto</span> sink <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>Sink<span class="token operator">></span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>SinkArgs<span class="token operator">></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">auto</span> new_logger <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>spdlog<span class="token operator">::</span>logger<span class="token operator">></span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>logger_name<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>sink<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        details<span class="token operator">::</span>registry<span class="token operator">::</span><span class="token function">instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">initialize_logger</span><span class="token punctuation">(</span>new_logger<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> new_logger<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不论是<code>stdout_logger_mt</code>还是<code>stdout_logger_st</code>里面都直接调用了<code>Factory::create</code>。模板参数Factory都默认为<code>spdlog::synchronous_factory</code>，除此之外还可以是<code>async_factory</code>。</p><p>先看<code>synchronous_factory::create</code>的实现，这个函数里做的事情就是先把logger构造出来后，再传进registry的initialize_logger方法中，<code>initialize_logger(new_logger)</code>有做了一些初始化，例如将该logger的formatter（存在logger中的）设置为默认formatter（存在registry中的），因为用户大体上会希望新创建的logger能够在日志格式上在已有或者全局的基础上保持统一。同时<code>initialize_logger(new_logger)</code>也将该logger的shared_ptr存到registry中，这样用户就可以通过registry管理该logger。<code>async_factory::create</code>做的事情基本相同，需要额外做些事情主要就是<code>async_logger</code>中所使用的线程池的创建。这里使用工厂方法的重点不在在于重建对象或者更好的组织代码，而是在创建logger之后将其注册进registry，registry需要注册logger，所以才提供Factory来在创建logger后完成注册。</p></div><hr><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/tags/Cpp/"><span class="chip bg-color">Cpp</span> </a><a href="/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"><span class="chip bg-color">源码阅读</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="wechat,qq" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="/libs/share/js/social-share.min.js"></script></div></div></div></div></div><style>.valine-card{margin:1.5rem auto}.valine-card .card-content{padding:20px 20px 5px 20px}#vcomments textarea{box-sizing:border-box;background:url(/medias/comment_bg.png) 100% 100% no-repeat}#vcomments p{margin:2px 2px 10px;font-size:1.05rem;line-height:1.78rem}#vcomments blockquote p{text-indent:.2rem}#vcomments a{padding:0 2px;color:#4cbf30;font-weight:500;text-decoration:none}#vcomments img{max-width:100%;height:auto;cursor:pointer}#vcomments ol li{list-style-type:decimal}#vcomments ol,ul{display:block;padding-left:2em;word-spacing:.05rem}#vcomments ul li,ol li{display:list-item;line-height:1.8rem;font-size:1rem}#vcomments ul li{list-style-type:disc}#vcomments ul ul li{list-style-type:circle}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}#vcomments table,td,th{border:0}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments h1{font-size:1.85rem;font-weight:700;line-height:2.2rem}#vcomments h2{font-size:1.65rem;font-weight:700;line-height:1.9rem}#vcomments h3{font-size:1.45rem;font-weight:700;line-height:1.7rem}#vcomments h4{font-size:1.25rem;font-weight:700;line-height:1.5rem}#vcomments h5{font-size:1.1rem;font-weight:700;line-height:1.4rem}#vcomments h6{font-size:1rem;line-height:1.3rem}#vcomments p{font-size:1rem;line-height:1.5rem}#vcomments hr{margin:12px 0;border:0;border-top:1px solid #ccc}#vcomments blockquote{margin:15px 0;border-left:5px solid #42b983;padding:1rem .8rem .3rem .8rem;color:#666;background-color:rgba(66,185,131,.1)}#vcomments pre{font-family:monospace,monospace;padding:1.2em;margin:.5em 0;background:#272822;overflow:auto;border-radius:.3em;tab-size:4}#vcomments code{font-family:monospace,monospace;padding:1px 3px;font-size:.92rem;color:#e96900;background-color:#f8f8f8;border-radius:2px}#vcomments pre code{font-family:monospace,monospace;padding:0;color:#e8eaf6;background-color:#272822}#vcomments pre[class*=language-]{padding:1.2em;margin:.5em 0}#vcomments code[class*=language-],pre[class*=language-]{color:#e8eaf6}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}#vcomments b,strong{font-weight:700}#vcomments dfn{font-style:italic}#vcomments small{font-size:85%}#vcomments cite{font-style:normal}#vcomments mark{background-color:#fcf8e3;padding:.2em}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}.v .vlist .vcard{padding-top:2.5em!important}</style><div class="card valine-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;left:20px;top:15px;padding-bottom:5px"><i class="fa fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="vcomments" class="card-content" style="display:grid"></div></div><script src="/libs/valine/av-min.js"></script><script src="/libs/valine/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"98JpzSGcrl9jFqHO13vqxHvX-gzGzoHsz",appKey:"mDmr2h9PB20xvPMNqgyRnNIC",notify:!0,verify:!0,visitor:!0,avatar:"mm",pageSize:"10",lang:"zh-cn",placeholder:"just go go"})</script><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fa fa-chevron-left"></i>&nbsp;上一篇</div><div class="card"><a href="/posts/13644/"><div class="card-image"><img src="/medias/featureimages/1.jpg" class="responsive-img" alt="Cpp20-STL-Cookbook速查"> <span class="card-title">Cpp20-STL-Cookbook速查</span></div></a><div class="card-content article-content"><div class="summary block-with-text">使用 STL 的新特性来解决实际问题</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2024-03-21 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="post-category">读书笔记</a></span></div></div><div class="card-action article-tags"><a href="/tags/Cpp/"><span class="chip bg-color">Cpp</span> </a><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="chip bg-color">读书笔记</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fa fa-chevron-right"></i></div><div class="card"><a href="/posts/64584/"><div class="card-image"><img src="/medias/featureimages/19.jpg" class="responsive-img" alt="CMake实战"> <span class="card-title">CMake实战</span></div></a><div class="card-content article-content"><div class="summary block-with-text">实战速查</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2024-03-21 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/Cpp/" class="post-category">Cpp</a></span></div></div><div class="card-action article-tags"><a href="/tags/CMake/"><span class="chip bg-color">CMake</span> </a><a href="/tags/Tool/"><span class="chip bg-color">Tool</span> </a><a href="/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"><span class="chip bg-color">工程经验</span></a></div></div></div></div></article></div><script>$("#articleContent").on("copy",function(e){var n,t,o,i;void 0!==window.getSelection&&((""+(n=window.getSelection())).length<Number.parseInt("120")||(t=document.getElementsByTagName("body")[0],(o=document.createElement("div")).style.position="absolute",o.style.left="-99999px",t.appendChild(o),o.appendChild(n.getRangeAt(0).cloneContents()),"PRE"===n.getRangeAt(0).commonAncestorContainer.nodeName&&(o.innerHTML="<pre>"+o.innerHTML+"</pre>"),i=document.location.href,o.innerHTML+='<br />来源: JoyTsing<br />文章作者: JoyTsing<br />文章链接: <a href="'+i+'">'+i+"</a><br />本文章著作权归作者joytsing所有，请任何形式的转载都请注明出处并在文章评论区处告知。",n.selectAllChildren(o),window.setTimeout(function(){t.removeChild(o)},200)))})</script><script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script><script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script><script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script><script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget"><div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fa fa-list"></i></a></div><script src="/libs/tocbot/tocbot.min.js"></script><script>$(function(){tocbot.init({tocSelector:"#toc-content",contentSelector:"#articleContent",headingsOffset:-(.4*$(window).height()-45),headingSelector:"h2, h3, h4, h5"});let t=0;var e="toc-heading-";$("#toc-content a").each(function(){$(this).attr("href","#"+e+ ++t)}),t=0,$("#articleContent").children("h2, h3, h4, h5").each(function(){$(this).attr("id",e+ ++t)});var n=parseInt(.4*$(window).height()-64);let o=$(".toc-widget");$(window).scroll(function(){var t=$(window).scrollTop();n<t?o.addClass("toc-fixed"):o.removeClass("toc-fixed")});var i="expanded";let a=$("#toc-aside"),c=$("#main-content");$("#floating-toc-btn .btn-floating").click(function(){a.hasClass(i)?(a.removeClass(i).hide(),c.removeClass("l9")):(a.addClass(i).show(),c.addClass("l9")),function(){let e=$("#artDetail");if(0!==e.length){let t=e.width();450<=t?t+=21:350<=t&&t<450?t+=18:300<=t&&t<350?t+=16:t+=14,$("#prenext-posts").width(t)}}()})})</script></main><footer class="page-footer bg-color"><div class="container row center-align"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2019</span> <a href="/about" rel="external nofollow noreferrer">JoyTsing</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br><span id="sitetime">载入运行时间...</span> <span id="busuanzi_container_site_pv">|&nbsp;<i class="fa fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span>&nbsp;次 </span><span id="busuanzi_container_site_uv">|&nbsp;<i class="fa fa-user"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv" class="white-color"></span>&nbsp;人</span><br>&nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;<span class="white-color">840.9k</span>&nbsp;字 <span id="icp"><img src="/medias/icp.png" style="vertical-align:text-bottom" alt="icp"> <a href="https://beian.miit.gov.cn/" target="_blank">陕公网安备61019002002862号 滇ICP备2024026466号-1</a></span><script>function siteTime(){var e=864e5,t="2019",n=(m=new Date).getFullYear(),o=m.getMonth()+1,r=m.getDate(),a=m.getHours(),i=m.getMinutes(),l=m.getSeconds(),m=Date.UTC(t,"7","24","0","0","0"),r=Date.UTC(n,o,r,a,i,l)-m,a=Math.floor(r/31536e6),i=Math.floor(r/e-365*a),l=Math.floor((r-(365*a+i)*e)/36e5),m=Math.floor((r-(365*a+i)*e-36e5*l)/6e4),M=Math.floor((r-(365*a+i)*e-36e5*l-6e4*m)/1e3);t==n?(document.getElementById("year").innerHTML=n,document.getElementById("sitetime").innerHTML="本站已安全运行 "+i+" 天 "+l+" 小时 "+m+" 分钟 "+M+" 秒"):(document.getElementById("year").innerHTML=t+" - "+n,document.getElementById("sitetime").innerHTML="本站已安全运行 "+a+" 年 "+i+" 天 "+l+" 小时 "+m+" 分钟 "+M+" 秒")}setInterval(siteTime,1e3)</script></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/JoyTsing" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fa fa-github"></i> </a><a href="/medias/wechat.jpg" target="_blank" data-tooltip="添加我的微信: [object Object]" data-position="top" data-delay="50"><i class="fa fa-weixin"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script src="/js/search.js"></script><script type="text/javascript">$(function(){searchFunc("/search.xml","searchInput","searchResult")})</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fa fa-angle-up"></i></a></div><script src="/libs/materialize/materialize.min.js"></script><script src="/libs/masonry/masonry.pkgd.min.js"></script><script src="/libs/aos/aos.js"></script><script src="/libs/scrollprogress/scrollProgress.min.js"></script><script src="/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="/js/matery.js"></script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?3a39d92b69933ae56c7eb41ffb9aa2e0";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="/libs/others/busuanzi.pure.mini.js"></script><script type="text/javascript">var st,OriginTitile=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="(oﾟvﾟ)ノ Hi",clearTimeout(st)):(document.title="(*´∇｀*) 欢迎回来！",st=setTimeout(function(){document.title=OriginTitile},3e3))})</script><script type="text/javascript" color="0,0,255" pointcolor="0,0,255" opacity="0.8" zindex="-1" count="150" src="/libs/background/canvas-nest.js"></script><script src="/libs/instantpage/instantpage.js" type="module"></script><script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script><script>const hasAttr = (e,a) => a.some(_=> e.attr(_)!==undefined);
        $('a').each(function() {
          const $this = $(this);
          if(hasAttr($this,["data-fancybox","ignore-external-link"])) return;
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== '' || window.location.host) {
                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":150,"height":200},"mobile":{"show":false},"react":{"opacity":0.7}});</script></body></html>