<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JoyTsing</title>
  
  <subtitle>深海</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://joytsing.github.io/"/>
  <updated>2024-06-06T08:32:53.404Z</updated>
  <id>https://joytsing.github.io/</id>
  
  <author>
    <name>JoyTsing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Cpp与Callback</title>
    <link href="https://joytsing.github.io/posts/39903/"/>
    <id>https://joytsing.github.io/posts/39903/</id>
    <published>2024-06-06T07:24:34.000Z</published>
    <updated>2024-06-06T08:32:53.404Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>callback的问题可以说老生常谈了，以及怎么通过协程这个语法糖来让异步的代码编写方式变成同步的风格，这个话题在前面的文章已经说过了，这次就谈一谈异步编程必须要跨过的一个槛，沟槽的callback(也是我为什么这样讨厌js的一大原因)，以及怎么让callback写法现代一点(怎么在正儿八经的项目里面用又是另外一个问题了)。</p><h2 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h2><p>一般来说，callback有两种做法：</p><ul><li>一次设置回调，多次调用：主要用于网络编程里面(也是callback最常见的一个地方)，好处显然是不用浪费每次设置回调的开销。但对于复杂逻辑来说，就不太友好了。因为回调入口只有一个，要实现复杂的逻辑，只能自己在回调里想方设法折腾(函数调用链冗长甚至交叉调用)。</li><li>一次设置回调，一次调用：这种模式常用于文件IO，用于异步的写等等，因为这种类似的操作不会有多次结果。坏处是会在设置回调上多了开销，但应对复杂的逻辑来说，具有相当好的深度可供挖掘，同时一次设置，一次调用，还可以根据对失败的处理，细分下使用方式：<ul><li>设置时失败，则返回错误信息，同时不会调用回调接口；</li><li>异步操作失败，不会调用回调接口；</li><li>异步操作失败会调用回调接口，但是取消异步操作则不会调用回调接口；</li><li>任何情况下都会调用回调接口；</li></ul></li></ul><p>怎么处理逻辑就看怎么设计，但是为了接口调用的清爽建议按照第四种情况来，这样就不用将失败处理的逻辑抛给对调用链一无所知的api调用者。</p><h3 id="从例子说起"><a href="#从例子说起" class="headerlink" title="从例子说起"></a>从例子说起</h3><p>通常情况下的异步回调是这个样子的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Input_t<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Callable_t<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">tostring_async</span><span class="token punctuation">(</span>_Input_t<span class="token operator">&amp;&amp;</span> value<span class="token punctuation">,</span> _Callable_t<span class="token operator">&amp;&amp;</span> callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token punctuation">[</span>callback <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">forward</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">,</span> value <span class="token operator">=</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>_Input_t<span class="token operator">></span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// do something</span>            <span class="token function">callback</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">to_string</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体线程里面开什么按照具体业务来定，如果不想麻烦单独开个线程也可以使用<code>std::async</code>配合<code>std::launch::async</code>来使用，他干的事其实就是帮你封装好开个线程。是不是觉得很简单？当业务复杂的时候就不是这样美好了，怎么处理深度连续回调就是当务之急。</p><p>通常是使用调用链来解决，就是future+then方案。代码大致如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Input_t<span class="token operator">></span>std<span class="token operator">::</span>future<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> <span class="token function">tostring_async</span><span class="token punctuation">(</span>_Input_t<span class="token operator">&amp;&amp;</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span><span class="token punctuation">[</span>value <span class="token operator">=</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>_Input_t<span class="token operator">></span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">to_string</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//使用范例代码</span><span class="token function">tostring_async</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string <span class="token operator">&amp;&amp;</span> result<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> result <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可惜标准库里面并没有支持这样的写法，如果使用<code>Boost</code>或者Facebook的<code>folly</code>这样的任务链库就能支持这样的写法。当然这些不是关键，如果只是回调函数比较深，那么做好标记，配合lambda食用，一点点看总能看到头的，然而问题在于用回调模拟循环，然后再涉及到分支去调用其他回调的时候问题就比较大了，同样的这样的逻辑非常丑陋，代码也有一股<code>bad smell</code>，这样的回调函数内部通常是这个样的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">do_accept</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ec<span class="token punctuation">)</span>        <span class="token function">do_read</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">do_read</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ec<span class="token punctuation">)</span>        <span class="token function">do_write</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">do_accept</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">do_write</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ec<span class="token punctuation">)</span>        <span class="token function">do_read</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于经常写异步网络的人来说这样的模式应该是不陌生的，这种代码应该怎么改造，似乎很难回答，当然一个解决方案我们一开始也说过了，利用协程以及<code>co_await</code>改造，但是这样的话就是消灭callback而不是让callback变得更加友好的这个话题了，并且关于现阶段<code>gcc</code>提供的协程栈协议已经在前面说到过了，其实并不完善，就如同<code>gcc</code>下<code>c++20</code>的另一大特性<code>module</code>其实根本用不了一样(import std的支持实在是太差)，其次如果用了一个第三方的异步库，怎么去拓展这个库，怎么适配这个库都是额外引入的开销，所以并没有想象的那么没好。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>之前说了使用原旨callback的异步库所面临的困难：callback本身难于使用，要将异步库改造得支持future-then范式，或者支持协程，需要更改每一个异步函数。而future库/协程库又选择繁多，要全部支持就需要一一的改写每个异步函数，导致工作量是<strong>乘法</strong>数量级。先回到最初的例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Input_t<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Callable_t<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">tostring_async</span><span class="token punctuation">(</span>_Input_t<span class="token operator">&amp;&amp;</span> value<span class="token punctuation">,</span> _Callable_t<span class="token operator">&amp;&amp;</span> callback<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token punctuation">[</span>callback <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">,</span> value <span class="token operator">=</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>_Input_t<span class="token operator">></span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token punctuation">{</span>            <span class="token function">callback</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">to_string</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//使用范例</span><span class="token function">tostring_async</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string <span class="token operator">&amp;&amp;</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>怎么改造成一个更加modern的回调，首先要干的事情和改造function一样，我们得先type erasure</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//回调适配器的模板类</span><span class="token comment" spellcheck="true">//这个默认类以_Callable_t作为真正的回调</span><span class="token comment" spellcheck="true">//返回无意义的int，以便于编译通过</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Callable_t<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Result_t<span class="token operator">></span><span class="token keyword">struct</span> modern_callback_adapter_t<span class="token punctuation">{</span>    <span class="token keyword">using</span> return_type <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">;</span>    <span class="token keyword">using</span> callback_type <span class="token operator">=</span> _Callable_t<span class="token punctuation">;</span>    <span class="token keyword">static</span> std<span class="token operator">::</span>tuple<span class="token operator">&lt;</span>callback_type<span class="token punctuation">,</span> return_type<span class="token operator">></span> <span class="token function">traits</span><span class="token punctuation">(</span>_Callable_t<span class="token operator">&amp;&amp;</span> callback<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>_Callable_t<span class="token operator">></span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后是他的核心部分</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//一个使用回调处理结果的异步函数，会涉及以下概念：</span><span class="token comment" spellcheck="true">//_Input_t...：异步函数的输入参数；</span><span class="token comment" spellcheck="true">//_Signature_t: 此异步回调的函数签名；应当满足‘void(_Exception_t, _Result_t...)’或者‘void(_Result_t...)’类型；</span><span class="token comment" spellcheck="true">//_Callable_t：回调函数或标记，如果是回调函数，则需要符合_Signature_t的签名类型。这个回调，必须调用一次，且只能调用一次；</span><span class="token comment" spellcheck="true">//_Return_t：异步函数的返回值；</span><span class="token comment" spellcheck="true">//_Result_t...：异步函数完成后的结果值，作为回调函数的入参部分；这个参数可以有零至多个；</span><span class="token comment" spellcheck="true">//_Exception_t：回调函数的异常， 如果不喜欢异常的则忽略这个部分，但就得异步代码将异常处置妥当；</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">//在回调适配器模型里，_Input_t/_Result_t/_Exception_t(可选)是异步函数提供的功能所固有的部分；_Callable_t/_Return_t</span><span class="token comment" spellcheck="true">//部分并不直接使用，而是通过适配器去另外处理。这样给予适配器一次扩展到future模式，调用链模式的机会，以及支持协程的机会。</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">//tostring_async 演示了在其他线程里，将_Input_t的输入值，转化为std::string类型的_Result_t。</span><span class="token comment" spellcheck="true">//然后调用_Signature_t为 ‘void(std::string &amp;&amp;)’ 类型的 _Callable_t。</span><span class="token comment" spellcheck="true">//忽视异常处理，故没有_Exception_t。</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Input_t<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Callable_t<span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">tostring_async</span><span class="token punctuation">(</span>_Input_t<span class="token operator">&amp;&amp;</span> value<span class="token punctuation">,</span> _Callable_t<span class="token operator">&amp;&amp;</span> callback<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//-> typename modern_callback_adapter_t&lt;std::decay_t&lt;_Callable_t>, std::string>::return_type</span><span class="token punctuation">{</span>    <span class="token keyword">using</span> _Result_t <span class="token operator">=</span> std<span class="token operator">::</span>string<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//适配器类型</span>    <span class="token keyword">using</span> _Adapter_t <span class="token operator">=</span> modern_callback_adapter_t<span class="token operator">&lt;</span>std<span class="token operator">::</span>decay_t<span class="token operator">&lt;</span>_Callable_t<span class="token operator">></span><span class="token punctuation">,</span> _Result_t<span class="token operator">></span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//通过适配器获得兼容_Callable_t类型的真正的回调，以及返回值_Return_t</span>    <span class="token keyword">auto</span> adapter <span class="token operator">=</span> <span class="token keyword">typename</span> _Adapter_t<span class="token operator">::</span><span class="token function">traits</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>_Callable_t<span class="token operator">></span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//real_callback与callback未必是同一个变量，甚至未必是同一个类型</span>    std<span class="token operator">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token punctuation">[</span>real_callback <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>std<span class="token operator">::</span>get<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">></span><span class="token punctuation">(</span>adapter<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> value <span class="token operator">=</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>_Input_t<span class="token operator">></span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token punctuation">{</span>            <span class="token function">real_callback</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">to_string</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//返回适配器的return_type变量</span>    <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>std<span class="token operator">::</span>get<span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">></span><span class="token punctuation">(</span>adapter<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看似增加了不少代码，但这些代码很模式化，完全可以用宏来简化</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">define</span> MODERN_CALLBACK_TRAITS(type) \    using _Result_t = type; \    using _Adapter_t = modern_callback_adapter_t&lt;std::decay_t&lt;_Callable_t>, _Result_t>; \    auto adapter = typename _Adapter_t::traits(std::forward&lt;_Callable_t>(callback))</span><span class="token macro property">#<span class="token directive keyword">define</span> MODERN_CALLBACK_CALL() callback = std::move(std::get&lt;0>(adapter))</span><span class="token macro property">#<span class="token directive keyword">define</span> MODERN_CALLBACK_RETURN() return std::move(std::get&lt;1>(adapter)) </span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Input_t<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Callable_t<span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">tostring_async</span><span class="token punctuation">(</span>_Input_t<span class="token operator">&amp;&amp;</span> value<span class="token punctuation">,</span> _Callable_t<span class="token operator">&amp;&amp;</span> callback<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">MODERN_CALLBACK_TRAITS</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">MODERN_CALLBACK_CALL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> value <span class="token operator">=</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>_Input_t<span class="token operator">></span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token punctuation">{</span>            <span class="token function">callback</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">to_string</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MODERN_CALLBACK_RETURN</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就能之前怎么用现在还是怎么用，这时候可能就要问了，这样只是换了个包装而已，甚至多了一层开销没有改变本质啊，接下来需要支持future。首先，看看不采用morden callback方案，需要如何支持future-then范式：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Input_t<span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">tostring_async</span><span class="token punctuation">(</span>_Input_t<span class="token operator">&amp;&amp;</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>promise<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> _promise<span class="token punctuation">;</span>    std<span class="token operator">::</span>future<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> _future <span class="token operator">=</span> _promise<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token punctuation">[</span>_promise <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>_promise<span class="token punctuation">)</span><span class="token punctuation">,</span> value <span class="token operator">=</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>_Input_t<span class="token operator">></span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">mutable</span>        <span class="token punctuation">{</span>            _promise<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">to_string</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>_future<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后是继续拓展之前的写法：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//一、做一个辅助类</span><span class="token keyword">struct</span> use_future_t <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//二、申明这个辅助类的全局变量。不申明这个变量也行，就是每次要写use_future_t{}，麻烦些。</span><span class="token comment" spellcheck="true">//以后就使用use_future，替代tostring_async的callback参数了。</span><span class="token comment" spellcheck="true">//这个参数其实不需要实质传参，最后会被编译器优化没了。</span><span class="token comment" spellcheck="true">//仅仅是要指定_Callable_t的类型为use_future_t，</span><span class="token comment" spellcheck="true">//从而在tostring_async函数内，使用偏特化的modern_callback_adapter_t&lt;use_future_t, ...>版本而已。</span><span class="token keyword">inline</span> <span class="token keyword">constexpr</span> use_future_t use_future<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将替换use_future_t的，真正的回调类。</span><span class="token comment" spellcheck="true">//此回调类，符合tostring_async的_Callable_t函数签名。</span><span class="token comment" spellcheck="true">//生成此类的实例作为real_callback交给tostring_async作为异步回调。</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">//future模式下，此类持有一个std::promise&lt;_Result_t>，便于设置值和异常</span><span class="token comment" spellcheck="true">//而将与promise关联的future作为返回值_Return_t，让tostring_async返回。</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Result_t<span class="token operator">></span><span class="token keyword">struct</span> use_future_callback_t<span class="token punctuation">{</span>    <span class="token keyword">using</span> promise_type <span class="token operator">=</span> std<span class="token operator">::</span>promise<span class="token operator">&lt;</span>_Result_t<span class="token operator">></span><span class="token punctuation">;</span>    <span class="token keyword">mutable</span> promise_type _promise<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>_Result_t<span class="token operator">&amp;&amp;</span> value<span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span>        _promise<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>_Result_t<span class="token operator">&amp;&amp;</span> value<span class="token punctuation">,</span> std<span class="token operator">::</span>exception_ptr<span class="token operator">&amp;&amp;</span> eptr<span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>eptr <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>            _promise<span class="token punctuation">.</span><span class="token function">set_exception</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>std<span class="token operator">::</span>exception_ptr<span class="token operator">></span><span class="token punctuation">(</span>eptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            _promise<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>_Result_t<span class="token operator">></span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//偏特化_Callable_t为use_future_t类型的modern_callback_adapter_t</span><span class="token comment" spellcheck="true">//真正的回调类型是use_future_callback_t，返回类型_Return_t是std::future&lt;_Result_t>。</span><span class="token comment" spellcheck="true">//配合use_future_callback_t的std::promise&lt;_Result_t>，正好组成一对promise/future对。</span><span class="token comment" spellcheck="true">//promise在真正的回调里设置结果值；</span><span class="token comment" spellcheck="true">//future返回给调用者获取结果值。</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Result_t<span class="token operator">></span><span class="token keyword">struct</span> modern_callback_adapter_t<span class="token operator">&lt;</span>use_future_t<span class="token punctuation">,</span> _Result_t<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">using</span> return_type <span class="token operator">=</span> std<span class="token operator">::</span>future<span class="token operator">&lt;</span>_Result_t<span class="token operator">></span><span class="token punctuation">;</span>    <span class="token keyword">using</span> callback_type <span class="token operator">=</span> use_future_callback_t<span class="token operator">&lt;</span>_Result_t<span class="token operator">></span><span class="token punctuation">;</span>    <span class="token keyword">static</span> std<span class="token operator">::</span>tuple<span class="token operator">&lt;</span>callback_type<span class="token punctuation">,</span> return_type<span class="token operator">></span> <span class="token function">traits</span><span class="token punctuation">(</span><span class="token keyword">const</span> use_future_t<span class="token operator">&amp;</span><span class="token comment" spellcheck="true">/*没人关心这个变量*/</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        callback_type real_callback<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        return_type future <span class="token operator">=</span> real_callback<span class="token punctuation">.</span>_promise<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>real_callback<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>future<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后改成宏定义就能到处用了，这样的代码只需要针对所选择的future库写一次，就可以支持全部的N个异步函数了。使用范例如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>future<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> f2 <span class="token operator">=</span> <span class="token function">tostring_async</span><span class="token punctuation">(</span><span class="token number">6.0f</span><span class="token punctuation">,</span> use_future<span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> f2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="协程中使用"><a href="#协程中使用" class="headerlink" title="协程中使用"></a>协程中使用</h3><p>只有使用了协程后，才可以非常容易的支持循环+分支逻辑，这个没办法，别的都是治标不治本。以librf为例，看看如何去支持协程：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//同理，可以制作支持C++20的协程的下列一系列类（其实，这才是我的最终目的）</span><span class="token keyword">struct</span> use_awaitable_t <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">inline</span> <span class="token keyword">constexpr</span> use_awaitable_t use_awaitable<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Result_t<span class="token operator">></span><span class="token keyword">struct</span> use_awaitable_callback_t<span class="token punctuation">{</span>    <span class="token keyword">using</span> promise_type <span class="token operator">=</span> librf<span class="token operator">::</span>promise_t<span class="token operator">&lt;</span>_Result_t<span class="token operator">></span><span class="token punctuation">;</span>    <span class="token keyword">using</span> state_type <span class="token operator">=</span> <span class="token keyword">typename</span> promise_type<span class="token operator">::</span>state_type<span class="token punctuation">;</span>    librf<span class="token operator">::</span>counted_ptr<span class="token operator">&lt;</span>state_type<span class="token operator">></span> _state<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>_Result_t<span class="token operator">&amp;&amp;</span> value<span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span>        _state<span class="token operator">-</span><span class="token operator">></span><span class="token function">set_value</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>_Result_t<span class="token operator">></span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>_Result_t<span class="token operator">&amp;&amp;</span> value<span class="token punctuation">,</span> std<span class="token operator">::</span>exception_ptr<span class="token operator">&amp;&amp;</span> eptr<span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>eptr <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>            _state<span class="token operator">-</span><span class="token operator">></span><span class="token function">set_exception</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>std<span class="token operator">::</span>exception_ptr<span class="token operator">></span><span class="token punctuation">(</span>eptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            _state<span class="token operator">-</span><span class="token operator">></span><span class="token function">set_value</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>_Result_t<span class="token operator">></span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Result_t<span class="token operator">></span><span class="token keyword">struct</span> modern_callback_adapter_t<span class="token operator">&lt;</span>use_awaitable_t<span class="token punctuation">,</span> _Result_t<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">using</span> promise_type <span class="token operator">=</span> librf<span class="token operator">::</span>promise_t<span class="token operator">&lt;</span>_Result_t<span class="token operator">></span><span class="token punctuation">;</span>    <span class="token keyword">using</span> return_type <span class="token operator">=</span> librf<span class="token operator">::</span>future_t<span class="token operator">&lt;</span>_Result_t<span class="token operator">></span><span class="token punctuation">;</span>    <span class="token keyword">using</span> callback_type <span class="token operator">=</span> use_awaitable_callback_t<span class="token operator">&lt;</span>_Result_t<span class="token operator">></span><span class="token punctuation">;</span>    <span class="token keyword">static</span> std<span class="token operator">::</span>tuple<span class="token operator">&lt;</span>callback_type<span class="token punctuation">,</span> return_type<span class="token operator">></span> <span class="token function">traits</span><span class="token punctuation">(</span><span class="token keyword">const</span> use_awaitable_t<span class="token operator">&amp;</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        promise_type promise<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span> callback_type<span class="token punctuation">{</span> promise<span class="token punctuation">.</span>_state <span class="token punctuation">}</span><span class="token punctuation">,</span> promise<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后就能直接用了:</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>string result <span class="token operator">=</span> co_await <span class="token function">tostring_async</span><span class="token punctuation">(</span><span class="token number">10.0</span><span class="token punctuation">,</span> use_awaitable<span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> result <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>仅仅是替换callback参数，就达到了使用协程的目的。并且，只需要为选择的协程库写一次适配代码就可以了，假设异步库有N个异步函数，有三种异步支持方案：callback，future-then，coroutine，其中，可选择的库有folly,libco等K个。</p><pre><code>则原旨主义的回调方案，需要做N*K次修改。而采用modern callback方案，只需要做N+K次适配。</code></pre><p>显然，这是一个更好的方案，并且，当异步库修改了M个异步函数后：</p><pre><code>原旨主义的callback方案，需要做M*K次修改；而modern callback不需要在适配上做任何修改，编译一次就好了。</code></pre><p>所以我们进行类型擦除以及包装的最大目的还是为了解耦合，如果有确切的使用的异步库或者不需要支持那么多的适配，其实只用使用最原始的方法就行，没必要过渡包装，毕竟N*1还是N。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;callback的问题可以说老生常谈了，以及怎么通过协程这个语法糖来让异步的代码编写方式变成同步的风格，这个话题在前面的文章已经说过了，这次
      
    
    </summary>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Cpp如何集成Prometheus和Grafana</title>
    <link href="https://joytsing.github.io/posts/45028/"/>
    <id>https://joytsing.github.io/posts/45028/</id>
    <published>2024-06-05T08:59:03.000Z</published>
    <updated>2024-06-05T09:25:44.300Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>监控是非常有必要的，就像打日志对于调试程序一样，日志打得好是可以避免手动gdb一行行排除错误的。同理对于评价一个程序，需要从各个方面的指标去评价，最常见也是最常用的就是QPS的监控了。</p><h2 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h2><p>长话短说，这里用的是<a href="https://github.com/jupp0r/prometheus-cpp">Prometheus Client Library for Modern C++</a>，可以自己make install，不过官方提供了Ubuntu PPA源就直接用Ubuntu PPA源了，添加源后的安装readme里面没说，去ubuntu release看后知道名字叫<code>prometheus-cpp-dev</code>，直接安装即可。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;prometheus/counter.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;prometheus/exposer.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;prometheus/registry.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;array></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;chrono></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">using</span> <span class="token keyword">namespace</span> prometheus<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// create an http server running on port 8080</span>  Exposer exposer<span class="token punctuation">{</span><span class="token string">"127.0.0.1:8080"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// create a metrics registry</span>  <span class="token comment" spellcheck="true">// @note it's the users responsibility to keep the object alive</span>  <span class="token keyword">auto</span> registry <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>Registry<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// add a new counter family to the registry (families combine values with the</span>  <span class="token comment" spellcheck="true">// same name, but distinct label dimensions)</span>  <span class="token comment" spellcheck="true">//</span>  <span class="token comment" spellcheck="true">// @note please follow the metric-naming best-practices:</span>  <span class="token comment" spellcheck="true">// https://prometheus.io/docs/practices/naming/</span>  <span class="token keyword">auto</span><span class="token operator">&amp;</span> packet_counter <span class="token operator">=</span> <span class="token function">BuildCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                             <span class="token punctuation">.</span><span class="token function">Name</span><span class="token punctuation">(</span><span class="token string">"observed_packets_total"</span><span class="token punctuation">)</span>                             <span class="token punctuation">.</span><span class="token function">Help</span><span class="token punctuation">(</span><span class="token string">"Number of observed packets"</span><span class="token punctuation">)</span>                             <span class="token punctuation">.</span><span class="token function">Register</span><span class="token punctuation">(</span><span class="token operator">*</span>registry<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// add and remember dimensional data, incrementing those is very cheap</span>  <span class="token keyword">auto</span><span class="token operator">&amp;</span> tcp_rx_counter <span class="token operator">=</span>      packet_counter<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"protocol"</span><span class="token punctuation">,</span> <span class="token string">"tcp"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"direction"</span><span class="token punctuation">,</span> <span class="token string">"rx"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">auto</span><span class="token operator">&amp;</span> tcp_tx_counter <span class="token operator">=</span>      packet_counter<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"protocol"</span><span class="token punctuation">,</span> <span class="token string">"tcp"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"direction"</span><span class="token punctuation">,</span> <span class="token string">"tx"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">auto</span><span class="token operator">&amp;</span> udp_rx_counter <span class="token operator">=</span>      packet_counter<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"protocol"</span><span class="token punctuation">,</span> <span class="token string">"udp"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"direction"</span><span class="token punctuation">,</span> <span class="token string">"rx"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">auto</span><span class="token operator">&amp;</span> udp_tx_counter <span class="token operator">=</span>      packet_counter<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"protocol"</span><span class="token punctuation">,</span> <span class="token string">"udp"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"direction"</span><span class="token punctuation">,</span> <span class="token string">"tx"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// add a counter whose dimensional data is not known at compile time</span>  <span class="token comment" spellcheck="true">// nevertheless dimensional values should only occur in low cardinality:</span>  <span class="token comment" spellcheck="true">// https://prometheus.io/docs/practices/naming/#labels</span>  <span class="token keyword">auto</span><span class="token operator">&amp;</span> http_requests_counter <span class="token operator">=</span> <span class="token function">BuildCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                                    <span class="token punctuation">.</span><span class="token function">Name</span><span class="token punctuation">(</span><span class="token string">"http_requests_total"</span><span class="token punctuation">)</span>                                    <span class="token punctuation">.</span><span class="token function">Help</span><span class="token punctuation">(</span><span class="token string">"Number of HTTP requests"</span><span class="token punctuation">)</span>                                    <span class="token punctuation">.</span><span class="token function">Register</span><span class="token punctuation">(</span><span class="token operator">*</span>registry<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// ask the exposer to scrape the registry on incoming HTTP requests</span>  exposer<span class="token punctuation">.</span><span class="token function">RegisterCollectable</span><span class="token punctuation">(</span>registry<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">auto</span> random_value <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>random_value <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> tcp_rx_counter<span class="token punctuation">.</span><span class="token function">Increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>random_value <span class="token operator">&amp;</span> <span class="token number">2</span><span class="token punctuation">)</span> tcp_tx_counter<span class="token punctuation">.</span><span class="token function">Increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>random_value <span class="token operator">&amp;</span> <span class="token number">4</span><span class="token punctuation">)</span> udp_rx_counter<span class="token punctuation">.</span><span class="token function">Increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>random_value <span class="token operator">&amp;</span> <span class="token number">8</span><span class="token punctuation">)</span> udp_tx_counter<span class="token punctuation">.</span><span class="token function">Increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> std<span class="token operator">::</span>array<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> <span class="token number">4</span><span class="token operator">></span> methods <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"GET"</span><span class="token punctuation">,</span> <span class="token string">"PUT"</span><span class="token punctuation">,</span> <span class="token string">"POST"</span><span class="token punctuation">,</span> <span class="token string">"HEAD"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> method <span class="token operator">=</span> methods<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>random_value <span class="token operator">%</span> methods<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// dynamically calling Family&lt;T>.Add() works but is slow and should be</span>    <span class="token comment" spellcheck="true">// avoided</span>    http_requests_counter<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"method"</span><span class="token punctuation">,</span> method<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h2><p>想要可视化我们的监控数据，我们还得启动Prometheus服务端，以及可视化的grafana工具，编写个docker-compose脚本拉取最新的就行， node_exporter用来帮助监控系统的数据。</p><pre class="line-numbers language-yml"><code class="language-yml">services:  prometheus:    container_name: prometheus    image: prom/prometheus:latest    network_mode: "host"    volumes:      - prometheus_yml_path :/etc/prometheus/prometheus.yml      - /etc/localtime:/etc/localtime    ports:      - "port1:9090"    restart: on-failure  grafana:    container_name: grafana    image: grafana/grafana:latest    network_mode: "host"    ports:      - "port2:3000"    restart: on-failure    volumes:      - /etc/localtime:/etc/localtime      - ./data/grafana:/var/lib/grafana  # linux node_exporter  node_exporter:    image: quay.io/prometheus/node-exporter:latest    restart: always    container_name: qps_node_exporter    command:      - '--path.rootfs=/host'    ports:      - "port3:9100"    volumes:      - your_path<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后去配置<code>prometheus_yml</code></p><pre class="line-numbers language-yml"><code class="language-yml">global:  scrape_interval: 5s # Set the scrape interval to every 15 seconds. Default is every 1 minute.  evaluation_interval: 10s # Evaluate rules every 15 seconds. The default is every 1 minute.  # scrape_timeout is set to the global default (10s).# Alertmanager configurationalerting:  alertmanagers:    - static_configs:        - targets:          # - alertmanager:9093# Load rules once and periodically evaluate them according to the global 'evaluation_interval'.rule_files:  # - "first_rules.yml"  # - "second_rules.yml"# A scrape configuration containing exactly one endpoint to scrape:# Here it's Prometheus itself.scrape_configs:  # The job name is added as a label `job=<job_name>` to any timeseries scraped from this config.  - job_name: "prometheus"    # metrics_path defaults to '/metrics'    # scheme defaults to 'http'.    static_configs:      - targets: ["ip:port1"]  - job_name: "server"    static_configs:      - targets: ["ip:port2"]  - job_name: "node"    static_configs:      - targets: ["ip:port3"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/45028/9ef52ea3df7ec7aef0164b4d6d81e041.png" alt="docker-compose，启动！"></p><p>一般遇到grafana一直重启的问题，通常是因为文件权限没有给对，直接777即可，一般来说启动成功的结构如下图：</p><p><img src="/posts/45028/2c1125e3629da1c12db3a29da523231d.jpg" alt></p><h2 id="配置-Grafana"><a href="#配置-Grafana" class="headerlink" title="配置 Grafana"></a>配置 Grafana</h2><p>Grafana默认账号密码admin，进去先直接配置数据源。</p><p><img src="/posts/45028/83a422e1cf39e47a9600dc222f384a1f.png" alt></p><p>选择后，在 Prometheus 数据源配置页面，配置这个数据源的 HTTP URL 就可以了。如果你点击“Save &amp; test”按钮后提示成功，那么数据源就配置好了。</p><p>接下来，我们再添加一个 node-exporter 仪表板（dashboard），把从 node-exporter 拉取的度量数据以图形化方式展示出来。这个时候我们不需要手工一个一个设置仪表板上的 panel，Grafana 官方有现成的 node-exporter 仪表板可用，我们只需要在 grafana 的 import 页面中输入相应的 dashboard ID，就可以导入相关仪表板的设置：</p><p><img src="/posts/45028/e483fec0e2a3cfbc258cd92817d820e8.png" alt></p><p>ID 为 1860 的 node-exporter 仪表板，导入成功后，进入这个仪表板页面，等待一段时间后，我们就可以看到类似下面的可视化结果：好了，到这里 node-exporter 的度量数据，已经可以以图形化的形式呈现在我们面前了，至于我们自己的数据怎么添加监控在前面部分就说了。</p><h3 id="添加自定义面板"><a href="#添加自定义面板" class="headerlink" title="添加自定义面板"></a>添加自定义面板</h3><p><a href="https://prometheus.io/docs/prometheus/latest/querying/functions/#rate">rate</a>是我们测试qps等等跟时间有关的部分最常用的函数。以 req_recv_rate 这个 panel 为例，它的 panel 配置是这样：</p><p><img src="https://static001.geekbang.org/resource/image/02/0f/02736fe21512ab8ac983caaa73cc550f.png?wh=1920x1437" alt>****</p><p>我们看到图中的 Metrics Browser 后面的表达式是：rate(tcp_server_demo2_req_recv_total[15s])，这个表达式返回的是在 15 秒内测得的 req_recv_total 的每秒速率，这恰恰是可以反映我们的服务端处理性能的指标。</p><h2 id="配置图"><a href="#配置图" class="headerlink" title="配置图"></a>配置图</h2><p><img src="/posts/45028/6baa8bf8913c317707018875d608561e.png" alt="多指标配置"></p><p>现在可以精准监控了，可喜可贺。</p><p><img src="/posts/45028/0ee46cee59888c30638a64d3774bc288.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;监控是非常有必要的，就像打日志对于调试程序一样，日志打得好是可以避免手动gdb一行行排除错误的。同理对于评价一个程序，需要从各个方面的指标去
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>CMake与Protobuf教程&amp;踩坑日记</title>
    <link href="https://joytsing.github.io/posts/59761/"/>
    <id>https://joytsing.github.io/posts/59761/</id>
    <published>2024-05-30T13:15:28.000Z</published>
    <updated>2024-06-03T11:28:52.018Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>不讲具体的protobuf使用，主要介绍怎么引入到工程中并且怎么方便作为工程的一部分使用。因为当时去搜索引擎上查了一下并没有特别满意的答案，所以决定自己写一个。当然别忘了外面的summary：<code>It just work!</code>，全文充斥着工程妥协的味道。</p><h2 id="问题一：版本冲突"><a href="#问题一：版本冲突" class="headerlink" title="问题一：版本冲突"></a>问题一：版本冲突</h2><p>在之前有关protobuf的blog里面就介绍了当电脑里面存在两个版本的protobuf的时候会冲突，当时为什么没有用grpc自带的那个最新版本？因为我发现那个版本使用的时候absl会提示一堆找不到的报错，并且就算安装了absl的库后也是同理。</p><p><img src="/posts/59761/66f2db0ff9599db168f991216770f647.png" alt="头皮发麻"></p><p>我当时以为是版本冲突的问题，后面单独使用的时候同样编译不了，提示缺少头文件，但是当配合grpc的时候又能够神奇的work了，所以想来想去反正grpc是动态库，直接在cmake里面加两行就行了。<code>It just work!</code></p><pre class="line-numbers language-cmake"><code class="language-cmake">find_package(Protobuf CONFIG REQUIRED)# TODO:消除absl的报错要靠grpc，无语了find_package(gRPC CONFIG REQUIRED)link_libraries(gRPC::grpc++)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="问题二：怎么集成进CMake项目"><a href="#问题二：怎么集成进CMake项目" class="headerlink" title="问题二：怎么集成进CMake项目"></a>问题二：怎么集成进CMake项目</h2><p>当然不是指的手动 <code>protoc --proto_path=xxxx --cpp_out=xxxx xxx.proto</code>，这样不仅麻烦而且每次修改proto都要重新生成，如果我们有多个proto的话岂不是需要一个一个改？无法忍受这样，所以我们要配合CMake的add_custom_command来使用。</p><p>这里以grpc操作redis的项目为例：</p><pre class="line-numbers language-cmake"><code class="language-cmake"># check thirdparty packagesset(protobuf_MODULE_COMPATIBLE true)find_package(Protobuf CONFIG REQUIRED)message(STATUS "Using Protobuf ${Protobuf_VERSION}")find_package(gRPC CONFIG REQUIRED)message(STATUS "Using gRPC ${gRPC_VERSION}")find_package(hiredis CONFIG REQUIRED)message(STATUS "Using hiredis ${hiredis_VERSION}")# include thirdparty includesinclude_directories(${hiredis_INCLUDE_DIRS})include_directories(${PROTOBUF_INCLUDE_DIRS})# # include thirdparty libsset(HREDIS_LIB_DEPS    ${GRPC_LIBRARIES}    ${HIREDIS_LIBRARIES}    ${Protobuf_LIBRARIES})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先引入三方库，记得要把<code>protobuf_MODULE_COMPATIBLE</code>设为<code>true</code>，因为我们要在后续的命令中使用到protobuf的部分模块。后面就是如何去自动生成我们要的proto了，首先我们必然不想自动生成在我们的项目目录中，因为这些代码不应该作为提交的部分（作为一个项目不应把grpc的版本限定死，毕竟grpc仅仅拿来通信版本其实不重要），选择生成到build文件夹中，只要保证每次build的时候都能生成自然也都能找到。</p><pre class="line-numbers language-cmake"><code class="language-cmake"># generate protobuf filesset(PROTO_PATH "${CMAKE_SOURCE_DIR}/protos")set(HREDIS_PROTO "${PROTO_PATH}/hredis.proto")set(GENERATED_PROTOBUF_PATH "${CMAKE_BINARY_DIR}/generated")file(MAKE_DIRECTORY ${GENERATED_PROTOBUF_PATH})set(HREDIS_PB_CPP_FILE "${GENERATED_PROTOBUF_PATH}/hredis.pb.cc")set(HREDIS_PB_H_FILE "${GENERATED_PROTOBUF_PATH}/hredis.pb.h")set(HREDIS_GRPC_PB_CPP_FILE "${GENERATED_PROTOBUF_PATH}/hredis.grpc.pb.cc")set(HREDIS_GRPC_PB_H_FILE "${GENERATED_PROTOBUF_PATH}/hredis.grpc.pb.h")set(HREDIS_GRPC_PB_PY_FILE "${GENERATED_PROTOBUF_PATH}/hredis_pb2.py")set(_GRPC_CPP_PLUGIN_EXECUTABLE $<TARGET_FILE:gRPC::grpc_cpp_plugin>)set(_GRPC_PYTHON_PLUGIN_EXECUTABLE $<TARGET_FILE:gRPC::grpc_python_plugin>)add_custom_command(     OUTPUT "${HREDIS_PB_H_FILE}"     "${HREDIS_PB_CPP_FILE}"     "${HREDIS_GRPC_PB_H_FILE}"     "${HREDIS_GRPC_PB_CPP_FILE}"     "${HREDIS_GRPC_PB_PY_FILE}"     COMMAND ${PROTOBUF_PROTOC_EXECUTABLE}     ARGS "--proto_path=${PROTO_PATH}"     "--cpp_out=${GENERATED_PROTOBUF_PATH}"     "${HREDIS_PROTO}"     COMMAND ${PROTOBUF_PROTOC_EXECUTABLE}     ARGS "--proto_path=${PROTO_PATH}"     "--grpc_out=${GENERATED_PROTOBUF_PATH}"     "--plugin=protoc-gen-grpc=${_GRPC_CPP_PLUGIN_EXECUTABLE}"     "${HREDIS_PROTO}"     COMMAND ${PROTOBUF_PROTOC_EXECUTABLE}     ARGS "--proto_path=${PROTO_PATH}"     "--python_out=${GENERATED_PROTOBUF_PATH}"     "--grpc_out=${GENERATED_PROTOBUF_PATH}"     "--plugin=protoc-gen-grpc=${_GRPC_PYTHON_PLUGIN_EXECUTABLE}"     "${HREDIS_PROTO}")set(GENERATED_PROTOBUF_FILES     ${HREDIS_PB_H_FILE}     ${HREDIS_PB_CPP_FILE}     ${HREDIS_GRPC_PB_H_FILE}     ${HREDIS_GRPC_PB_CPP_FILE}     ${HREDIS_GRPC_PB_PY_FILE})include_directories(${GENERATED_PROTOBUF_PATH})link_libraries(gRPC::grpc++ ${PROTOBUF_LIBRARY} ${hiredis_LIBRARIES})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="add-custom-command命令的基本语法"><a href="#add-custom-command命令的基本语法" class="headerlink" title="add_custom_command命令的基本语法"></a>add_custom_command命令的基本语法</h3><p>在CMake中，<code>add_custom_command</code>命令的基本语法如下：</p><pre class="line-numbers language-cmake"><code class="language-cmake">add_custom_command(    OUTPUT output1 [output2 ...]    COMMAND command1 [ARGS] [args1...]    [COMMAND command2 [ARGS] [args2...] ...]    [MAIN_DEPENDENCY depend]    [DEPENDS [depends...]]    [BYPRODUCTS [files...]]    [WORKING_DIRECTORY dir]    [COMMENT comment]    [VERBATIM])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个命令的主要作用是定义一条自定义的构建规则，这条规则可以在构建过程中执行一系列的命令。下面我们来详细解析这个命令的各个参数。</p><ul><li><code>OUTPUT output1 [output2 ...]</code>：这个参数用于指定自定义命令的输出文件。这些文件在构建过程中会被生成，如果这些文件不存在，那么CMake就会执行这条自定义命令。</li><li><code>COMMAND command1 [ARGS] [args1...]</code>：这个参数用于指定要执行的命令。你可以提供任何有效的命令，包括系统命令、脚本，或者其他的构建工具。<code>ARGS</code>关键字后面可以跟随一系列的参数，这些参数会被传递给命令。</li><li><code>MAIN_DEPENDENCY depend</code>：这个参数用于指定自定义命令的主要依赖。如果这个依赖的文件被修改，那么自定义命令就会被执行。</li><li><code>DEPENDS [depends...]</code>：这个参数用于指定自定义命令的其他依赖。如果这些依赖的文件被修改，那么自定义命令也会被执行。</li><li><code>BYPRODUCTS [files...]</code>：这个参数用于指定自定义命令的副产品。如果你指定了一个或多个文件作为副产品，那么这些文件将会被添加到构建系统的清理列表中。</li><li><code>WORKING_DIRECTORY dir</code>：这个参数用于指定自定义命令的工作目录。如果你没有指定这个参数，那么自定义命令将会在当前的源码目录中执行。</li><li><code>COMMENT comment</code>：这个参数用于指定一个注释，这个注释将会在执行自定义命令时被打印出来。</li><li><code>VERBATIM</code>：这个参数用于控制命令参数的处理方式。如果你指定了<code>VERBATIM</code>，那么命令参数将会被按照字面意义处理，而不会被解析为变量或表达式。</li></ul><h3 id="仍然有问题"><a href="#仍然有问题" class="headerlink" title="仍然有问题"></a>仍然有问题</h3><p>这样就能在build目录下自动生成所需要的pb文件了。至于为什么又说是妥协，上面的cmake代码在仅生成一个目录下的可执行程序是没有问题的，在下面这种目录中，example和src中都依赖我们需要生成的pb文件，那么这个时候该怎么办。</p><p><img src="/posts/59761/image-20240530215447441.png" alt></p><p>我们的主CMAKE结构是这样的：</p><p><img src="/posts/59761/image-20240530215541536.png" alt></p><p>是不是以为在<code>src</code>中生成就好了，因为代码是按顺序执行的，在<code>src</code>中生成后才会去<code>examples</code>里面执行，但现实并不是这样。你会发现ninja会略过src直接前往examples。因为<code>add_custom_command</code>是懒加载的，直到需要的时候才会正常去执行，这也就导致我们缺少头文件<strong>预处理</strong>的时候就会报错，但是当你继续运行的时候cmake就会发现真的需要它了，此时又能够build了（多点几次）。</p><p><img src="/posts/59761/image-20240530215735876.png" alt="suprise"></p><p>这种烦人的依赖问题该怎么解决呢？</p><h3 id="怎么解决的"><a href="#怎么解决的" class="headerlink" title="怎么解决的"></a>怎么解决的</h3><p>本质上是依赖问题，因为<code>add_custom_command</code>是懒加载的，那么需要创建一个依赖去告诉CMake我们什么时候就需要这个PB文件，这时候我们就需要使用<code>add_custom_target</code>,<code>add_custom_target</code> 用于添加自定义构建目标，这个目标通常不与实际的构建文件关联。它主要用于将一组自定义构建步骤组织成一个逻辑组，并在构建时执行这些步骤。这个命令通常与 <code>add_custom_command</code> 配合使用，以实现更复杂的构建过程。</p><pre class="line-numbers language-cmake"><code class="language-cmake">add_custom_target(Name [ALL] [command1 [args1...]]                  [COMMAND command2 [args2...] ...]                  [DEPENDS depend depend depend ... ]                  [BYPRODUCTS [files...]]                  [WORKING_DIRECTORY dir]                  [COMMENT comment]                  [JOB_POOL job_pool]                  [VERBATIM] [USES_TERMINAL]                  [COMMAND_EXPAND_LISTS]                  [SOURCES src1 [src2...]])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例：</strong></p><pre class="line-numbers language-cmake"><code class="language-cmake">add_custom_command(    OUTPUT generated_file.txt    COMMAND echo "Generated content" > generated_file.txt    DEPENDS some_input_file.txt    COMMENT "Generating a file")add_custom_target(    my_custom_target    COMMAND echo "Hello from custom target"    DEPENDS generated_file.txt    COMMENT "Executing a custom target")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，<code>add_custom_target</code> 创建了一个名为 <code>my_custom_target</code> 的自定义构建目标，它执行一个命令，输出 “Hello from custom target”。这个目标依赖于前面 <code>add_custom_command</code> 中生成的 <code>generated_file.txt</code>。</p><ul><li><code>add_custom_command</code> 主要用于定义在构建时执行的具体命令，通常与文件的生成或转换有关。</li><li><code>add_custom_target</code> 主要用于组织一组自定义构建步骤，并为它们创建一个逻辑目标。这个目标本身不与实际文件相关。</li></ul><p>在实际使用中，这两个命令通常结合使用，以创建复杂的构建过程。例如，<code>add_custom_command</code> 生成文件，然后 <code>add_custom_target</code> 创建一个目标，该目标依赖于生成的文件，并可能执行一些其他操作。</p><h2 id="问题三：加入到多目录CMake项目"><a href="#问题三：加入到多目录CMake项目" class="headerlink" title="问题三：加入到多目录CMake项目"></a>问题三：加入到多目录CMake项目</h2><p>既然有了生成的操作和添加依赖的方法，那么我们在src目录以及examples目录里面添加依赖即可：</p><pre class="line-numbers language-cmake"><code class="language-cmake"># 执行需要的依赖add_custom_target(  SRC_GEN_PROTO  DEPENDS ${GENERATED_PROTOBUF_FILES})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在就建立了正常的依赖关系了，可喜可贺。</p><p><img src="/posts/59761/image-20240530225432946.png" alt="可喜可贺"></p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>发现有时候管用有时候不管用，非常奇怪，后面查阅很多资料以及试了很多后，发现跟<code>dependencies</code>有关系，<code>add_custom_target</code>在有些情况下是等价于<code>add_dependencies</code>的，但是对于多目录结构下存在的依赖关系，这种<code>add_custom_target</code>似乎就不能够正确判别了，所以我们应该像链接库一样，手动添加我们的依赖：<code>add_dependencies(TAGETNAME DEPNAME)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;不讲具体的protobuf使用，主要介绍怎么引入到工程中并且怎么方便作为工程的一部分使用。因为当时去搜索引擎上查了一下并没有特别满意的答案，
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="CMake" scheme="https://JoyTsing.github.io/tags/CMake/"/>
    
      <category term="Tool" scheme="https://JoyTsing.github.io/tags/Tool/"/>
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>GitFlow与CMake项目CI集成</title>
    <link href="https://joytsing.github.io/posts/52642/"/>
    <id>https://joytsing.github.io/posts/52642/</id>
    <published>2024-05-21T15:46:36.000Z</published>
    <updated>2024-05-27T13:02:34.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先先把github action的文档放在<a href="https://docs.github.com/zh/actions">这里</a>，总结一下本质上和去一台新机器里构建没有别的区别。</p><h2 id="action"><a href="#action" class="headerlink" title="action"></a>action</h2><p>实现过程可以说非常简单，脚本也很轻松易懂，可以理解为我们要去一个新的容器里面去构建我们的环境并运行我们的测试。也就是说不仅需要构建所需的编译器，还需要去下载所需的包。</p><p><img src="/posts/52642/2aa6305e6b9b082ff9a8405236ee364f.png" alt></p><h3 id="多平台构建"><a href="#多平台构建" class="headerlink" title="多平台构建"></a>多平台构建</h3><p>可以看starter-workflows的<a href="https://github.com/actions/starter-workflows/issues/586">issue586</a>，里面有一个多编译器多平台的暴力<a href="https://github.com/dlang/dmd/blob/86c4cd1819fd26a822e0b1daf09f460dd5a3043e/.github/workflows/runnable_cxx.yml">构建脚本</a>。</p><h3 id="gcc13构建"><a href="#gcc13构建" class="headerlink" title="gcc13构建"></a>gcc13构建</h3><p>首先头疼的是<code>gcc-13</code>的选择，因为需要支持新的std标准，必须使用<code>gcc-13</code>，而<code>gcc-13</code>在ubuntu的apt标准源里面是没有的，从源码构建当然可以，但是这个太麻烦了，后面发现有简单的方法。</p><ol><li>先安装工具源</li></ol><pre><code>sudo add-apt-repository ppa:ubuntu-toolchain-r/test</code></pre><ol start="2"><li>更新源</li></ol><pre><code>sudo apt update</code></pre><ol start="3"><li>安装gcc和g+</li></ol><pre><code>apt install gcc-13 g++-13</code></pre><p>随后记得gcc-13 g++-13为高优先级（优先使用版本13）</p><pre><code> sudo update-alternatives --install `which gcc` gcc `which gcc-13` 99 sudo update-alternatives --install `which g++` g++ `which g++-13` 99</code></pre><p>在workflow脚本中可以这么写：</p><pre class="line-numbers language-yml"><code class="language-yml">    - name: install GCC13      shell:  bash      run:  |        sudo add-apt-repository ppa:ubuntu-toolchain-r/test        sudo apt update && sudo apt-get install gcc-13 g++-13        sudo update-alternatives --install `which gcc` gcc `which gcc-13` 99        sudo update-alternatives --install `which g++` g++ `which g++-13` 99<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/52642/11d93d21317627ab91cfd4a825fe9832.png" alt></p><h2 id="jobs流控制"><a href="#jobs流控制" class="headerlink" title="jobs流控制"></a>jobs流控制</h2><h3 id="job之间相互依赖"><a href="#job之间相互依赖" class="headerlink" title="job之间相互依赖"></a>job之间相互依赖</h3><p>之前配置可以发现是串行的，实际上在test的时候完全可以并行测试，同时对于配置来说，我们很难知道在哪一个环节出了问题，因此将整个大的jobs拆分成小的job就成了要解决的问题。后面查阅官方文档还有搜索资料发现了<a href="https://zhuanlan.zhihu.com/p/348712087">配置技巧</a>，</p><p>如何让Job 编排控制执行顺序，只需要一个tag即可。</p><pre class="line-numbers language-yml"><code class="language-yml">on: pushjobs:  job1:    runs-on: ubuntu-latest    steps:      - run: echo "job1"  job2:    runs-on: ubuntu-latest    steps:      - run: sleep 5    needs: job1  job3:    runs-on: ubuntu-latest    steps:      - run: sleep 10    needs: job1  job4:    runs-on: ubuntu-latest    steps:      - run: echo "job4"    needs: [job2, job3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的 workflows 执行时，job2 和 job3 会等 job1 执行成功时才执行，job4 会等 job2 和 job3 执行成功时才执行。</p><p><img src="/posts/52642/6feef617e30039021cc62190252b63b2.png" alt></p><h3 id="actions-artifact"><a href="#actions-artifact" class="headerlink" title="actions-artifact"></a>actions-artifact</h3><p>后面发现每个任务之前的环境是不互通的，也就是environment这个job配置好后，后续的job是使用不了的，这下难办了，该怎么办呢？因为我们只需要使用对应build的产物进行test，那么我们可以使用Github actions Artifact 可以用来存储action生产出来的产物。<a href="https://docs.github.com/en/actions/using-workflows/storing-workflow-data-as-artifacts">官方文档</a>上有比较详细的说明,同时也有别的<a href="https://cloud.tencent.com/developer/article/1983976">学习资料</a>以及<a href="https://www.cnblogs.com/kklldog/p/github-actions-artifact.html">优质博文</a>。</p><pre class="line-numbers language-yml"><code class="language-yml">  - name: Archive production artifacts    uses: actions/upload-artifact@v4    with:      name: dist-without-markdown      path: |        dist        !dist/**/*.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，你upload后是不能直接用的，还得配合download下载使用(注意也要指定path，官方实例里面没给)，然后指定需要的path，<a href="https://github.com/actions/download-artifact">download的官方文档</a>在这里。</p><pre class="line-numbers language-yml"><code class="language-yml">- name: Download a single artifact  uses: actions/download-artifact@v4  with:    name: dist-without-markdown<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>需要强烈注意的是，<code>这个path是相对repository的路径</code>，所以不要觉得这个上传的path是相对working-directory的。也就是不需要再去加<code>$</code>前缀，否则就会像我一样疯狂报错不知道哪出了问题。</p><p><img src="/posts/52642/image-20240522204936524.png" alt="仔细看下载的路径thread-pool重复了两次"></p><p>所以修改路径后就能正常下载了</p><pre class="line-numbers language-yml"><code class="language-yml">    - name: Download artifacts      uses: actions/download-artifact@v4      with:        name: packing-tests        path: build/test/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/52642/image-20240522210126442.png" alt="修改后"></p><h3 id="path和actions-checkout-v4"><a href="#path和actions-checkout-v4" class="headerlink" title="path和actions/checkout@v4"></a>path和actions/checkout@v4</h3><p>首先又把checkout的<a href="https://github.com/actions/checkout/tree/v4/">文档</a>放在这里，为什么我每次都找不到对应的路径，原来是复制的时候多复制了actions/checkout@v4，作用于checkout，相当于又切回去了最原始的提交，相当于变回去了，一开始不知道在调用test的时候把这个uses上了，于是每次最后调用测试的时候都切回原始状态(难蚌)。</p><p><img src="/posts/52642/image-20240522210822399.png" alt="报错"></p><p>同时下载下来的文件是没有运行权限的，记得修改一下权限：</p><p><img src="/posts/52642/53781919a4de454935e853c0c7163914.png" alt></p><p>试错了很多次终于搞定了，期间改了不少次架构，最后CI集成了还是舒服的。</p><p><img src="/posts/52642/1bf728cbcfa59126a6dbf6645ff3dc7b.png" alt></p><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>每次都要等gcc和boost安装比较耗费时间，不知道有没有方法能够生成一个环境(除了自己搞个docker image)，每次actions直接去环境里面进行即可就好了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;首先先把github action的文档放在&lt;a href=&quot;https://docs.github.com/zh/actions&quot;&gt;这里&lt;
      
    
    </summary>
    
    
      <category term="生产环境" scheme="https://JoyTsing.github.io/categories/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="生产环境" scheme="https://JoyTsing.github.io/tags/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
  <entry>
    <title>如何让clangd支持makefile工程</title>
    <link href="https://joytsing.github.io/posts/26828/"/>
    <id>https://joytsing.github.io/posts/26828/</id>
    <published>2024-05-20T08:59:52.000Z</published>
    <updated>2024-05-20T09:31:06.111Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>使用cmake的时候用vscode带的ninja进行build的时候会自动生成<code>compile_commands.json</code>，一切都是自动化的，此时clangd就能通过<code>compile_commands.json</code>知道我们工程自定义的头文件和源文件位置在哪，同时也就没有烦人的红波浪线，但是如果我们使用的是make呢？</p><h2 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h2><p>CMake维护的工程生成json文件非常简单。</p><pre><code>cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON .</code></pre><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p>很多工程并不会使用CMake维护，同时它们的Makefile可读性比较差，但是目前我们关键是让clangd不会再报错，问题就转化成了如何生成<code>compile_commands.json</code>。这里可以使用Bear工具生成json文件：</p><h2 id="bear"><a href="#bear" class="headerlink" title="bear"></a>bear</h2><p>ubuntu下可以这样操作</p><pre><code>sudo apt install bearbear bear -- make -j8(或者其他参数)</code></pre><p>这样就会bear就会拦截make命令，自动在所有目录生成<code>compile_commands.json</code>，同时我们的clangd也不会再报错了，可喜可贺。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;使用cmake的时候用vscode带的ninja进行build的时候会自动生成&lt;code&gt;compile_commands.json&lt;/co
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>浅析协程与线程与进程的区别和联系</title>
    <link href="https://joytsing.github.io/posts/37357/"/>
    <id>https://joytsing.github.io/posts/37357/</id>
    <published>2024-05-19T15:39:41.000Z</published>
    <updated>2024-05-19T15:50:07.253Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h2><p>内核线程只运行在内核态，不受用户态上下文的拖累。</p><ul><li>处理器竞争：可以在全系统范围内竞争处理器资源；</li><li>使用资源：唯一使用的资源是内核栈和上下文切换时保持寄存器的空间</li><li>调度：调度的开销可能和进程自身差不多昂贵</li><li>同步效率：资源的同步和数据共享比整个进程的数据同步和共享要低一些。</li></ul><h2 id="轻量级进程"><a href="#轻量级进程" class="headerlink" title="轻量级进程"></a>轻量级进程</h2><p>轻量级进程(LWP)是建立在内核之上并由内核支持的用户线程，它是内核线程的高度抽象，每一个轻量级进程都与一个特定的内核线程关联。内核线程只能由内核管理并像普通进程一样被调度。</p><p>轻量级进程由clone()系统调用创建，参数是CLONE_VM，即与父进程是共享进程地址空间和系统资源。</p><p>与普通进程区别：LWP只有一个最小的执行上下文和调度程序所需的统计信息。</p><ul><li>处理器竞争：因与特定内核线程关联，因此可以在全系统范围内竞争处理器资源</li><li>使用资源：与父进程共享进程地址空间</li><li>调度：像普通进程一样调度</li></ul><h3 id="Linux使用的线程库"><a href="#Linux使用的线程库" class="headerlink" title="Linux使用的线程库"></a>Linux使用的线程库</h3><p>LinuxThreads是用户空间的线程库，所采用的是线程-进程1对1模型(即一个用户线程对应一个轻量级进程，而一个轻量级进程对应一个特定 的内核线程)，将线程的调度等同于进程的调度，调度交由内核完成，而线程的创建、同步、销毁由核外线程库完成（LinuxThtreads已绑定到 GLIBC中发行）。</p><p>在LinuxThreads中，由专门的一个管理线程处理所有的线程管理工作。当进程第一次调用pthread_create()创建线程时就会先 创建(clone())并启动管理线程。后续进程pthread_create()创建线程时，都是管理线程作为pthread_create()的调用 者的子线程，通过调用clone()来创建用户线程，并记录轻量级进程号和线程id的映射关系，因此，用户线程其实是管理线程的子线程。</p><p>LinuxThreads只支持调度范围为PTHREAD_SCOPE_SYSTEM的调度，默认的调度策略是SCHED_OTHER。</p><p>用户线程调度策略也可修改成SCHED_FIFO或SCHED_RR方式，这两种方式支持优先级为0-99,而SCHED_OTHER只支持0。</p><ul><li>SCHED_OTHER 分时调度策略，</li><li>SCHED_FIFO  实时调度策略，先到先服务</li><li>SCHED_RR   实时调度策略，时间片轮转</li></ul><p>SCHED_OTHER是普通进程的，后两个是实时进程的（一般的进程都是普通进程，系统中出现实时进程的机会很少）。SCHED_FIFO、 SCHED_RR优先级高于所有SCHED_OTHER的进程，所以只要他们能够运行，在他们运行完之前，所有SCHED_OTHER的进程的都没有得到 执行的机会。</p><h2 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h2><p>用户线程是完全建立在用户空间的线程库，用户线程的创建、调度、同步和销毁全又库函数在用户空间完成，不需要内核的帮助。因此这种线程是极其低消耗和高效的。</p><ul><li>处理器竞争：单纯的用户线程是建立在用户空间，其对内核是透明的，因此其所属进程单独参与处理器的竞争，而进程的所有线程参与竞争该进程的资源。</li><li>使用资源：与所属进程共享进程地址空间和系统资源。</li><li>调度：由在用户空间实现的线程库，在所属进程内进行调度</li></ul><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p><a href="https://joytsing.cn/posts/21849/">什么是协程</a>，协程，又称微线程，是一种用户态的轻量级线程，一个线程可以有多个协程。协程的调度完全由用户控制（也就是在用户态执行）。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到线程的堆区，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以协程的上下文切换非常快。</p><p>协程抽象于线程之上，线程是被分割的CPU资源, 协程是组织好的代码流程, 协程需要线程来承载运行。与线程相比，协程占用资源小，由用户调度，切换开销小，同一个线程中的协程不需要使用锁，执行效率更高。</p><h2 id="进程、线程和协程的区别是什么？"><a href="#进程、线程和协程的区别是什么？" class="headerlink" title="进程、线程和协程的区别是什么？"></a>进程、线程和协程的区别是什么？</h2><p>进程是资源分配的最小单位，每个进程都有自己的独立内存空间，进程由进程控制块、程序段和数据段组成。</p><ul><li>进程控制块（PCB）保存进程运行期间相关的数据，是进程存在的唯一标志。</li><li>程序段是能被进程调度程序调度到CPU 运行的程序的代码段。</li><li>数据段用来存储程序运行期间的相关数据。</li></ul><p>进程是应用程序运行的载体，可看做是正在执行的程序。程序本身是没有生命周期的，只是存在于磁盘上的一些指令集合，但程序一旦被运行起来就是进程。启动后的进程，会依赖操作系统的调度完成生命周期的转换。由于每个进程都有独立的代码和数据空间，所以进程间的切换会有较大的开销。</p><p>线程是CPU任务调度和执行的最小单位，一个进程中可以包含多个线程，这些线程可以并发运行，且共享进程提供的相同的代码和数据空间，每个线程都有自己独立的运行栈和程序计数器，线程间切换的开销小。</p><p>协程，又称微线程，是一种用户态的轻量级线程，一个线程可以有多个协程。协程的调度完全由用户控制（也就是在用户态执行）。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到线程的堆区，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以协程的上下文切换非常快。</p><p>线程在进程的内部，它不能独立执行，必须依存于进程中，由进程提供多个线程的执行控制，进程和线程都可以并发的执行。</p><p>协程抽象于线程之上，线程是被分割的CPU资源, 协程是组织好的代码流程, 协程需要线程来承载运行。与线程相比，协程占用资源小，由用户调度，切换开销小，同一个线程中的协程不需要使用锁，执行效率更高。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;内核线程&quot;&gt;&lt;a href=&quot;#内核线程&quot; class=&quot;headerlink&quot; title=&quot;内核线程&quot;&gt;&lt;/a&gt;内核线程&lt;/h2&gt;&lt;p&gt;内核线程只运行在内核态，不受用户态上下文的拖累。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处理器竞争：可以在全系统范围内竞争处理器资源；&lt;
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://JoyTsing.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
      <category term="C" scheme="https://JoyTsing.github.io/tags/C/"/>
    
      <category term="操作系统" scheme="https://JoyTsing.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Cpp中的ABI探究</title>
    <link href="https://joytsing.github.io/posts/27828/"/>
    <id>https://joytsing.github.io/posts/27828/</id>
    <published>2024-05-18T08:07:59.000Z</published>
    <updated>2024-05-18T08:24:56.597Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Application Binary Interface 也就是我们常说的 ABI，是个让人感觉到既熟悉又陌生的概念。熟悉在哪里？讨论问题的时候经常会讨论到它，看文章的时候经常会提到它，有时候又要处理它导致的兼容性。陌生在哪里？如果有人问你什么是 ABI，你会发现你知道它是怎么一回事，但是要用严谨的语言去描述它有些困难。最后只好照着 WIKI 说：ABI 就是两个二进制程序模块之间的接口。有问题吗？没有问题，但是回答了跟没有回答一样。</p><p>软件工程讲究分层，对于一个 C++ 程序的 ABI 来说，我们也可以从下面这五个层次来看待。</p><h2 id="CPU-amp-OS"><a href="#CPU-amp-OS" class="headerlink" title="CPU &amp; OS"></a>CPU &amp; OS</h2><p>最终的可执行文件最后都是要运行在特定 CPU 上的特定操作系统的。如果 CPU 的指令集不同，那肯定会导致二进制不兼容，比如 ARM 上的程序没法<strong>直接</strong>运行在 x64 处理器上（除非借助一些虚拟化技术）。如果指令集兼容呢？比如 x64 处理器就兼容 x86 的指令集，那 x86 程序一定能运行在 x64 操作系统上吗？这时候就要看操作系统了，具体来说，要考虑到 <strong>Object File Format</strong>（目标文件格式），<strong>Data Representation</strong>（数据表示）， <strong>Function Calling Convention</strong>（函数调用约定）和 <strong>Runtime Library</strong>（运行时库）等因素。这几点就可以看做是操作系统层面的 ABI 规定。第四点我们后面有专门的一节来讨论，下面以 x64 平台为例，就前三点进行讨论。</p><blockquote><p>x64, x86-64, x86_64, AMD64 和 Intel 64 是一个意思，都是指 x86 指令集的 64 位版本。</p></blockquote><p><strong>x64 平台上主要有两套常用的 ABI</strong>：</p><ul><li>用于 64 位 Windows 操作系统上的 Windows x64 ABI</li><li>用于 64 位 Linux 以及一众 UNIX-like 的操作系统上的 x86-64 System V ABI</li></ul><p>而从一个动态库里面调用某个函数可以简单的看成下面这个三个步骤：</p><ul><li>按照某种格式解析动态库</li><li>根据符号名从解析结果中查找函数地址</li><li>函数参数传递，调用函数</li></ul><h3 id="Object-File-Format"><a href="#Object-File-Format" class="headerlink" title="Object File Format"></a>Object File Format</h3><p>以何种格式解析动态库？这就是 ABI 中对 Object File Format 的规定起作用的地方了。如果你希望自己写一个链接器，那么最后生成的可执行文件就需要满足对应平台的格式要求。Windows x64 使用的可执行文件格式是 <a href="https://learn.microsoft.com/en-us/windows/win32/debug/pe-format">PE32+</a> ，也就是 PE32（Portable Executable 32-bit）格式的<code>64</code>位版本。System V ABI 使用的则是 <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">ELF（Executable Linkable Format）</a> 格式的可执行文件。通过使用一些 parse 库（当然感兴趣的话也可以自己写），例如 pe-parse 和 elfio，对实际的可执行文件进行解析，得到其中的符号表，我们便能拿到函数名与函数地址的映射关系了。</p><h3 id="Data-Representation"><a href="#Data-Representation" class="headerlink" title="Data Representation"></a>Data Representation</h3><p>拿到函数地址之后，接下来就是怎么进行调用了。在调用之前，首先得传参对吧。那传参的时候就特别要注意 Data Representation（数据表示）表示的一致性，什么意思呢？</p><p>假设我把下面这个文件编译成动态库</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> X<span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">int</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span>X x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> x<span class="token punctuation">.</span>a <span class="token operator">+</span> x<span class="token punctuation">.</span>b<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果后续版本升级导致结构体内容发生变动了，用户代码里面看到的结构体定义变成了</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> X<span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">int</span> b<span class="token punctuation">;</span>    <span class="token keyword">int</span> c<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后仍然去尝试链接旧版本代码编译出的动态库，并调用里面的函数</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>能成功吗？当然会失败了，这种错误可以看成所谓的 ODR（One Definition Rule）违反。</p><p>上面的情况属于用户主动变更代码导致的 ODR 违反，那如果我不主动变更代码，能确保结构体布局的稳定性吗？那这就由 ABI 中 Data Representation 来进行相关保证了。例如：规定一些基础类型的大小和对齐， Windows x64 规定<code>long</code>是<code>32</code>位，而 System V 则规定<code>long</code>是<code>64</code>位。规定<code>struct</code>和<code>union</code>的大小和对齐等等。</p><blockquote><p>注意 C 语言标准仍然是不规定 ABI 的，对于 System V ABI 来说，其主要使用 C 语言的术语和概念编写，所以可以认为提供了针对 C 语言的 ABI。而 Windows x64 ABI 在 C 和 C++ 之间并没有太过明显的界限。</p></blockquote><h3 id="Function-Calling-Convention"><a href="#Function-Calling-Convention" class="headerlink" title="Function Calling Convention"></a>Function Calling Convention</h3><p>接下来就到函数传参这一步了。我们知道，函数不过就是一段二进制数据，执行函数其实就是跳转到函数的入口地址，然后执行那一段代码，最后执行完了再跳转回来就行了。而传参无非就是找一块地方，存放数据，<strong>使得调用前后都能访问到这个地方来取数据</strong>。有哪些位置可以选择呢？主要有下面四个选项：</p><ul><li>global（全局变量）</li><li>heap（堆）</li><li>register（寄存器）</li><li>stack（栈）</li></ul><p>使用全局变量进行传参，听起来很魔幻，实际上平常写代码的时候经常把一些需要反复传递的参数改成全局变量，例如<code>config</code>这种的。但是，显然不是所有参数都适合使用全局变量传参，如果考虑到线程安全就要更加注意了。</p><p>使用堆进行传参，似乎也很不可思议，但其实 C++20 加入的无栈协程就把协程的状态（函数参数，局部变量）保存在堆上。不过对于普通的函数调用来说，如果每次传参都要动态内存分配，确实有些奢侈了。</p><p>所以我们主要还是考虑使用寄存器和栈进行传参。多一种选择总是好的，但是在这里并不好。如果调用方觉得应该使用寄存器传参，于是把参数存到寄存器里面去了。而被调用方觉得应该使用栈传参，所以取数据的时候是从栈里面取的。不一致就出现了，很可能从栈里面独到的就是垃圾值，导致代码逻辑错误，程序直接崩溃。</p><p>如何保证调用方和被调用方传参的位置一致呢？相信你已经猜到了，这就是 Function Calling Convention（函数调用约定）发挥作用的地方。</p><p>具体来说，调用约定规定下面这些内容：</p><ul><li>函数参数传递顺序，从左到右还是从右到左？</li><li>函数参数和返回值传递的方式，通过栈还是寄存器？</li><li>哪些寄存器在调用者调用前后是保持不变的？</li><li>谁负责清理栈帧，调用者还是被调用者？</li><li><code>...</code></li></ul><p>在<code>32</code>位程序中，有很多调用约定，像什么<code>__cdecl</code>，<code>__stdcall</code>，<code>__fastcall</code>，<code>__thiscall</code>等等，当时的程序可谓是饱受兼容性之苦。而在<code>64</code>位程序中，已经基本完成统一。主要有两种调用约定，也就是 Windows x64 ABI 和 x86-64 System V ABI 分别规定的调用约定（不过并没有个正式的名字）。<strong>需要强调的是函数传参方式只和调用约定有关，和代码优化等级无关。你也不想不同优化等级编译出来的代码，链接到一起之后跑不起来吧。</strong></p><p>介绍具体的规定是有些无聊的，感兴趣的读者可以自行查阅对应文档的相关小节，下面主要讨论一些比较有意思的话题。</p><blockquote><p>注意：下面这些讨论只适用于函数调用实际发生的情况，如果函数被完全内联，函数传参这一行为并不会发生。目前 C++ 代码的内联优化主要发生在同一编译单元内（单个文件），对于跨编译单元的代码，必须要打开 LTO（Link Time Optimization）才行，跨动态库的代码目前还不能内联。</p></blockquote><ul><li><strong>小于<code>16</code>字节大小的结构体值传递效率比引用效率更高</strong></li></ul><p>这个说法由来已久，但是我始终没有找到依据。终于，最近在研究调用约定的时候，让我找到原因了。首先如果结构体大小小于等于<code>8</code>字节，那么可以直接塞进一个<code>64</code>位寄存器里面传参，<strong>通过寄存器传参比通过引用传参要少几次访存</strong>，效率要高一些，没什么问题。那对于<code>16</code>字节呢？System V ABI 允许将一个<code>16</code>字节大小的结构体拆两个<code>8</code>个字节的部分，然后分别使用寄存器传递。那么在这种情况下传值确实比传引用要高一些，观察下面的 <a href="https://godbolt.org/z/5Ph34x1cK">代码</a></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span><span class="token keyword">struct</span> X <span class="token punctuation">{</span>    size_t x<span class="token punctuation">;</span>    size_t y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token keyword">const</span> X<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// pass by value</span>    <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// pass by reference</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后生成的代码如下所示</p><pre class="line-numbers language-nasm"><code class="language-nasm"><span class="token label function">main:</span>        sub     <span class="token register variable">rsp</span>, <span class="token number">24</span>        mov     <span class="token register variable">edi</span>, <span class="token number">1</span>        mov     <span class="token register variable">esi</span>, <span class="token number">2</span>         call    f(X)        movdqa  <span class="token register variable">xmm0</span>, XMMWORD PTR .LC0<span class="token operator">[</span>rip<span class="token operator">]</span>        mov     <span class="token register variable">rdi</span>, <span class="token register variable">rsp</span>        movaps  XMMWORD PTR <span class="token operator">[</span><span class="token register variable">rsp</span><span class="token operator">]</span>, <span class="token register variable">xmm0</span>        call    g(X const<span class="token operator">&amp;</span>)        xor     <span class="token register variable">eax</span>, <span class="token register variable">eax</span>        add     <span class="token register variable">rsp</span>, <span class="token number">24</span>        ret<span class="token label function">.LC0:</span>        .quad   <span class="token number">1</span>        .quad   <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>System V ABI 规定了前六个整形参数，依次可以使用<code>rdi</code>，<code>rsi</code>，<code>rdx</code>，<code>rcx</code>，<code>r8</code>，<code>r9</code>寄存器传递，而 Windows x64 ABI 规定了前四个整形参数，依次可以使用<code>rcx</code>，<code>rdx</code>，<code>r8</code>，<code>r9</code>寄存器传递。如果过寄存器用完了，就通过栈传递。整形参数即<code>char</code>，<code>short</code>，<code>int</code>，<code>long</code>，<code>long long</code>等基础整数类型外加指针类型。浮点参数和 SIMD 类型的参数则有专门的寄存器负责，这里不过多涉及了。</p></blockquote><p>可以发现<code>1</code>,<code>2</code>分别通过寄存器<code>edi</code>和<code>esi</code>传递给了<code>f</code>函数，而<code>g</code>则是把临时变量的地址传递给了<code>g</code>函数。但是这只是 System V ABI，对于 Windows x64 ABI 来说，<strong>只要结构体的大小大于<code>8</code>字节，只能通过引用传递。</strong>同样的代码，在 Windows 上编译的结果如下</p><pre class="line-numbers language-nasm"><code class="language-nasm"><span class="token label function">main:</span>        sub     <span class="token register variable">rsp</span>, <span class="token number">56</span>                                     lea     <span class="token register variable">rcx</span>, QWORD PTR <span class="token operator">[</span><span class="token register variable">rsp</span><span class="token operator">+</span><span class="token number">32</span><span class="token operator">]</span>        mov     QWORD PTR <span class="token operator">[</span><span class="token register variable">rsp</span><span class="token operator">+</span><span class="token number">32</span><span class="token operator">]</span>, <span class="token number">1</span>        mov     QWORD PTR <span class="token operator">[</span><span class="token register variable">rsp</span><span class="token operator">+</span><span class="token number">40</span><span class="token operator">]</span>, <span class="token number">2</span>        call    void f(X)                           lea     <span class="token register variable">rcx</span>, QWORD PTR <span class="token operator">[</span><span class="token register variable">rsp</span><span class="token operator">+</span><span class="token number">32</span><span class="token operator">]</span>        mov     QWORD PTR <span class="token operator">[</span><span class="token register variable">rsp</span><span class="token operator">+</span><span class="token number">32</span><span class="token operator">]</span>, <span class="token number">1</span>        mov     QWORD PTR <span class="token operator">[</span><span class="token register variable">rsp</span><span class="token operator">+</span><span class="token number">40</span><span class="token operator">]</span>, <span class="token number">2</span>        call    void g(X const <span class="token operator">&amp;</span>)        xor     <span class="token register variable">eax</span>, <span class="token register variable">eax</span>        add     <span class="token register variable">rsp</span>, <span class="token number">56</span>                                ret     <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到两次函数调用产生的代码完全相同，也就是说对于 Windows x64 ABI 来说，大于<code>8</code>字节的结构体无论是通过引用传递还是值传递，生成的代码都是一样的。</p><ul><li><strong>unique_ptr 和 raw_ptr 的效率</strong></li></ul><p><code>unique_ptr</code>只是对裸指针简单包装一层嘛，所以他们效率应该一致？ CPPCON 上 <a href="https://www.bilibili.com/video/BV1qp421y75W/?spm_id_from=333.999.0.0">There are no zero-cost abstractions</a> 就讨论这个问题。这里不谈异常导致的额外开销（析构函数导致编译器必须额外生成清理栈帧的代码），仅仅讨论一个 C++ 对象（小于<code>8</code>字节）能使用寄存器传参吗？对于一个完全 <a href="https://en.cppreference.com/w/cpp/language/classes#Trivial_class">trivial</a> 的类型来说，是没问题的，它表现得和一个 C 语言的结构体几乎完全一样。但是如果不满足呢？</p><p>比如自定义了拷贝构造函数，还能放寄存器里面吗？其实从逻辑上就不能，为什么呢？C++ 是允许我们对函数参数取地址的，那如果参数是整形，那么它通过寄存器传参，那取地址的结果哪里来的呢？实验一下，就知道了</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>生成的对应汇编如下</p><pre class="line-numbers language-nasm"><code class="language-nasm">g(int):        sub     <span class="token register variable">rsp</span>, <span class="token number">24</span>        mov     DWORD PTR <span class="token operator">[</span><span class="token register variable">rsp</span><span class="token operator">+</span><span class="token number">12</span><span class="token operator">]</span>, <span class="token register variable">edi</span>        lea     <span class="token register variable">rdi</span>, <span class="token operator">[</span><span class="token register variable">rsp</span><span class="token operator">+</span><span class="token number">12</span><span class="token operator">]</span>        call    f(int<span class="token operator">&amp;</span>)        mov     <span class="token register variable">eax</span>, DWORD PTR <span class="token operator">[</span><span class="token register variable">rsp</span><span class="token operator">+</span><span class="token number">12</span><span class="token operator">]</span>        add     <span class="token register variable">rsp</span>, <span class="token number">24</span>        ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现，这里把<code>edi</code>（用于传递第一个整形参数）里面的值拷贝到了 <code>rsp+12</code> 这个地址，也就是栈上，之后把这个地址传递给了<code>f</code>。也就是说，如果一个函数参数通过寄存器传递，如果在某些情况下需要它的地址，编译器会把这个参数拷贝到栈上。<strong>但是无论如何，用户是观察不到这些拷贝过程的，因为它们的拷贝构造函数是<code>trivial</code>的。不影响最终代码执行结果的任何优化都是符合 as if 原则的。</strong></p><p>那么如果这个对象有用户定义的拷贝构造函数，假设参数通过寄存器传递，就可能会导致额外的拷贝构造函数调用，并且用户可以观察到这个副作用。显然这是不合理的，所以不允许拥有自定义拷贝构造函数的对象通过寄存器传参，那通过栈传递呢？实际上也会遇到类似的拷贝困境。于是最终这类对象只能通过引用传递了。<strong>注意，给拷贝构造显式标记为<code>delete</code>也算是自定义拷贝构造函数。</strong></p><p>所以对于<code>unique_ptr</code>来说，只能通过引用传递，无论你函数签名写成<code>void f(unique_ptr&lt;int&gt;)</code>还是<code>void f(unique_ptr&lt;int&gt;&amp;)</code>，最后在传参处生成的二进制代码都是一样的。但是裸指针却可以通过寄存器安全的传递。综上所述，<code>unique_ptr</code>和裸指针的效率并不是完全一致的。</p><blockquote><p>实际上对于一个非 trivial 的 C++ 对象，究竟能否使用寄存器传参的实际情况更复杂一些，相关的内容参考对应 ABI 中的相关小节，这里不过多描述。另外 C++ 对象如何传递这部分规定，究竟属于操作系统的 ABI 还是 C++ 编译器 ABI 这个问题也并不是很明确。</p></blockquote><h2 id="C-Standard"><a href="#C-Standard" class="headerlink" title="C++ Standard"></a>C++ Standard</h2><p>终于说完了操作系统层面的保证，由于偏向底层，涉及到较多汇编，对于不那么熟悉汇编的读者，读起来可能有些困难。不过接下来的内容基本就和汇编没什么关系了，可以放心阅读。</p><p>我们都知道 C++ 标准没有明确规定 ABI，但并不是完全没有规定，它对于编译器的实现是有一些要求的，例如：</p><ul><li>结构体成员地址按照声明顺序 <a href="https://en.cppreference.com/w/c/language/struct#Explanation">递增</a>，这保证了编译器不会对结构体成员进行重新排序</li><li>满足 <a href="https://en.cppreference.com/w/cpp/language/data_members#Standard-layout">Standard Layout</a> 约束的结构体需要与相应的 C 结构体布局兼容</li><li>满足 <a href="https://en.cppreference.com/w/cpp/types/is_trivially_copyable">Trivially Copyable</a> 约束的结构体可以使用<code>memmove</code>或者<code>memcpy</code>进行拷贝得到一个完全相同的全新对象</li><li><code>...</code></li></ul><p>另外，由于 C++ 一直在推出新的版本。同一份代码，我使用新标准和旧标准分别进行编译，得到的结果相同吗（不考虑使用宏控制 C++ 版本进行条件编译的影响）？这就要看 C++ 标准层面对 ABI 兼容性的保证了，事实上，C++ 标准尽可能的保证<strong>向后兼容性</strong>。也就是说，两段代码，使用旧标准和新标准编译出来的代码是完全一样的。</p><p>然而，也有极少数的例外，例如（我只找得到这些，欢迎评论区补充）：</p><ul><li>C++17 把<code>noexcept</code>作为函数类型的一部分，这会影响函数最后生成的 mangling name</li><li>C++20 引入的<code>no_unique_address</code>，MSVC 目前仍然没直接支持，因为会导致 ABI Broken</li></ul><p>更多时候，C++ 新版本会在加入新的语言特性的同时带来新的 ABI，而不会影响旧的代码，例如 C++23 加入的两个新特性：</p><h3 id="Explicit-Object-Parameter"><a href="#Explicit-Object-Parameter" class="headerlink" title="Explicit Object Parameter"></a><a href="https://en.cppreference.com/w/cpp/language/member_functions#Explicit_object_parameter">Explicit Object Parameter</a></h3><p>在 C++23 之前，事实上没有<strong>合法</strong>的手段获取一个成员函数的地址，我们唯一能做的就是获取成员指针（关于成员指针是什么，可以参考这篇 <a href="https://zhuanlan.zhihu.com/p/659510753">文章</a> 的内容）</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> X <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">auto</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>X<span class="token operator">::</span>f<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// p is a pointer to member function of X</span><span class="token comment" spellcheck="true">// type of p is void (X::*)(int)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>想要获取使用成员函数作为回调函数，只能使用 lambda 表达式包装一层</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> X <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">using</span> Fn <span class="token operator">=</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>X<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Fn p <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>A<span class="token operator">*</span> self<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> self<span class="token operator">-</span><span class="token operator">></span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这其实很麻烦，没有任何必要，而且这层包装可能会导致额外的函数调用开销。某种程度上这算是个历史遗留问题，<code>32</code>位系统上对成员函数的调用约定有些特殊（广为人知的<code>thiscall</code>），而 C++ 中并没有调用约定相关的内容，所以搞了个成员函数指针这么个东西。旧的代码为了 ABI 兼容性已经无法改变，但是新的可以，C++23 加入了显式对象参数，我们现在可以明确<code>this</code>的传入方式了，甚至可以使用值传递</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> X <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 这里的 this 只是个标记作用，为了和旧语法区分开来</span>    <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">this</span> X self<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// pass by value</span>    <span class="token keyword">void</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token keyword">this</span> X<span class="token operator">&amp;</span> self<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// pass by reference</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>被显式<code>this</code>标记的函数也可以直接获取函数地址了，就和普通的函数一样</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token operator">&amp;</span>X<span class="token operator">::</span>f<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// type of f is void(*)(X, int)</span><span class="token keyword">auto</span> g <span class="token operator">=</span> <span class="token operator">&amp;</span>X<span class="token operator">::</span>g<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// type of g is void(*)(X*, int)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>所以新代码可以都采用这种写法，只有好处，没有坏处。</p><h3 id="Static-Operator"><a href="#Static-Operator" class="headerlink" title="Static Operator()"></a><a href="https://en.cppreference.com/w/cpp/feature_test#cpp_static_call_operator">Static Operator()</a></h3><p>标准库中有一些仿函数，里面什么成员都没有，只有一个<code>operator()</code>，例如<code>std::hash</code></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">struct</span> hash <span class="token punctuation">{</span>    std<span class="token operator">::</span>size_t <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>T <span class="token keyword">const</span><span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>尽管这是个空的结构体，但是由于<code>operator()</code>是成员函数，所以有一个隐式<code>this</code>参数。在非内联调用的情况下仍然需要传递一个无用的空指针。这个问题在 C++23 中得到了解决，可以直接定义<code>static operator()</code>，从而避免这个问题</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">struct</span> hash <span class="token punctuation">{</span>    <span class="token keyword">static</span> std<span class="token operator">::</span>size_t <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>T <span class="token keyword">const</span><span class="token operator">&amp;</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>static</code>也就意味着这是个静态函数了，使用上还是和原来一样</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>hash<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> h<span class="token punctuation">;</span>std<span class="token operator">::</span>size_t n <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>但这里只是拿<code>hash</code>举个例子，实际上标准库的代码为了 ABI 兼容性已经不会改动了。新代码可以使用这个特性，来避免不必要的<code>this</code>传递。</p><h2 id="Compiler-Specific"><a href="#Compiler-Specific" class="headerlink" title="Compiler Specific"></a>Compiler Specific</h2><p>接下来就到了重头戏了，实现定义的部分，这部分似乎是被人诟病最多的内容了。然而事实真的如此吗？让我们一点点往下看。</p><h3 id="De-Facto-Standard"><a href="#De-Facto-Standard" class="headerlink" title="De Facto Standard"></a>De Facto Standard</h3><p>C++ 中的一些抽象最终是要落实到实现上的，而标准有没有规定如何实现，那这部分内容就由编译器自由发挥，例如：</p><ul><li>name mangling 的规则（为了实现函数重载和模板函数）</li><li>复杂类型的布局（例如含有虚继承）</li><li>虚函数表的布局</li><li>RTTI 的实现</li><li>异常处理</li><li><code>...</code></li></ul><p>如果编译器对这些部分的实现不同，那么最后不同编译器编译出的二进制产物自然是互不兼容，不能混用的。</p><blockquote><p>在上世纪<code>90</code>年代，那时候还是 C++ 发展的黄金时期，各个厂商都致力于实现自己的编译器并扩大基本盘，争夺用户。出于竞争关系，不同编译器之间使用不同的 ABI 是很常见的行为。随着时代的发展，它们中的大多数已经退出了历史舞台，要么停止更新，要么仅做维护，不再跟进 C++ 的新标准。浪潮过后，留下的只有 GCC，Clang 和 MSVC 这三大编译器。</p></blockquote><p>在今天，C++ 编译器的 ABI 已经基本得到统一，主流的 ABI 只有两套：</p><ul><li>Itanium C++ ABI，具有公开透明的文档</li><li>MSVC C++ ABI，并没有官方的文档</li></ul><blockquote><p>尽管名为 Itanium C++ ABI，但它实际上是用于 C++ 的跨架构 ABI，除了 MSVC 之外，几乎所有的 C++ 编译器都在使用它，尽管在异常处理方面的细节略有不同。历史上，C++ 编译器都以各自的方式处理 C++ ABI。当英特尔大力推广 Itanium 时，他们希望避免不兼容问题，因此，他们为 Itanium 上的所有 C++ 供应商创建了一个标准化的 ABI。后来，由于各种原因，GCC 需要修改其内部 ABI，而且鉴于它已经支持了 Itanium ABI（为 Itanium 处理器），他们选择将 ABI 定义扩展到所有架构，而不是创建自己的 ABI。从那时起，所有主要的编译器除了 MSVC 都采用了跨架构的 Itanium ABI，并且即使 Itanium 处理器本身不再接收维护，该 ABI 仍然得到了维护。</p></blockquote><p>在 Linux 平台上，GCC 和 Clang 都使用 Itanium ABI，所以两个编译器编译出来的代码就具有互操作性，可以链接到一起并运行。而在 Windows 平台上，情况则稍微复杂些，默认的 MSVC 工具链使用自己的 ABI。但是除了 MSVC 工具链以外，还有人把 GCC 移植到 Windows 上了，也就是我们熟知的 <a href="https://www.mingw-w64.org//">MinGW</a> 工具链，它使用的仍然是 Itanium ABI。这两套 ABI 互不兼容，编译出来的代码不能直接链接到一起。而 Windows 平台上的 Clang 可以通过编译选项控制使用这两种 ABI 的其中的一种。</p><blockquote><p>注意：MinGW 既然在 Windows 上运行，那它生成的代码的调用约定自然是尽量遵守 Windows x64 ABI 的，最终生成的可执行文件格式也是 PE32+。但是它的使用的 C++ ABI 仍然是 Itanium ABI，这两者并没有必然关联。</p></blockquote><p>考虑到 C++ 巨大的 codebase，这两套 C++ ABI 已经基本稳定，不会再改动了，<strong>所以我们现在其实可以说 C++ 编译器具有稳定的 ABI</strong>。怎么样，是不是和网上主流的说法不同？但是事实的确就摆在这里。</p><blockquote><p>MSVC 从 <a href="https://learn.microsoft.com/en-us/cpp/porting/binary-compat-2015-2017?view=msvc-170">2015</a> 的版本往后开始保证 ABI 稳定。GCC 从 3.4 开始使用 Itanium ABI 并保证 ABI 稳定。</p></blockquote><h3 id="Workaround"><a href="#Workaround" class="headerlink" title="Workaround"></a>Workaround</h3><p>尽管基础的 ABI 不再改变，但是升级编译器版本仍然可能会导致编译出来的库发生 ABI Broken，为什么呢？</p><p>这其实不难理解，首先编译器也是软件，只要是软件就可能有 BUG。有时候为了修复 BUG，会被迫做出一些 ABI Broken（一般会在新版本的发行介绍中详细说明）。例如 GCC 有一个编译选项 <code>-fabi-version</code> 用于专门控制这些不同的版本，其中一些内容如下：</p><ul><li>版本<code>7</code>首次出现在 G++ 4.8 中，它将<code>nullptr_t</code>视为内建类型，并修正了默认参数作用域中 Lambda 表达式的名称编码</li><li>版本<code>8</code>首次出现在 G++ 4.9 中，修正了带有函数 CV 限定符的函数类型的替换行为</li><li>版本<code>9</code>首次出现在 G++ 5.2 中，修正了<code>nullptr_t</code>的对齐方式</li></ul><p>另外对于用户来说，也可能之前为了绕过编译器的 BUG，编写了一些特殊的代码，我们一般把这个叫做 workaround。当 BUG 被修复之后，这些 workaround 很可能起到反作用。从而导致 ABI 出现不兼容</p><h3 id="Important-Options"><a href="#Important-Options" class="headerlink" title="Important Options"></a>Important Options</h3><p>除此之外，编译器还提供了一些列选项用来控制编译器的行为，这些选项可能会影响 ABI，比如：</p><ul><li><code>-fno-strict-aliasing</code>：关闭严格别名</li><li><code>-fno-exceptions</code>：关闭异常</li><li><code>-fno-rtti</code>：关闭 RTTI</li><li><code>...</code></li></ul><p>给不同选项编译出来的库链接到一起的时候，尤其要兼容性问题。例如你的代码关闭了严格别名，但是依赖的外部库开启了严格别名，很可能指针错误的传播，从而导致程序出错。</p><p>我最近就遇到了这种情况，我在给 LLVM 的一些函数编写 Python Wrapper，通过 <a href="https://github.com/pybind/pybind11">pybind11</a>。而 pybind11 要求必须打开 RTTI，但是 LLVM 默认构建是关闭异常和 RTTI 的，所以最后代码就链接不到一块去了。一开始我是自己编译了一份开 RTTI 的 LLVM，这会导致二进制膨胀，后来发现没必要这样做。我其实没有用到 LLVM 里面类型的 RTTI 信息，只是由于写在同一个文件里面，编译器认为我用到了。于是把使用到 LLVM 部分的代码单独编译成一个动态库，再和使用 pybind11 部分的代码一起链接就解决了。</p><h2 id="Runtime-amp-Library"><a href="#Runtime-amp-Library" class="headerlink" title="Runtime &amp; Library"></a>Runtime &amp; Library</h2><p>这一小节主要讨论的就是，一个 C++ 程序依赖的库的 ABI 稳定性。<strong>理想情况下是，对于一个可执行程序，使用新版本的动态库替换旧版本的动态库，仍然不影响它运行。</strong></p><p>三大 C++ 编译器都有自己的标准库</p><ul><li>MSVC 对应的是 msvc stl</li><li>GCC 对应的是 libstdc++</li><li>Clang 对应的是 libc++</li></ul><p>我们在前面提到过，C++ 标准尽量保证 ABI 向后兼容。即使是从 C++98 到 C++11 这样的大更新，旧代码的 ABI 也没有受到太大影响，导致 ABI Break Change 的措辞改变更是完全找不到。</p><p>但是对于 C++ 标准库来说情况就有些不一样了，从 C++98 到 C++11，标准库经历了一次大的 ABI Break Change。标准库中修改了对一些容器实现的要求，例如<code>std::string</code>。这导致原来广泛使用的 COW 实现不符合新标准，于是在 C++11 中不得不采用新实现。这也就导致了 C++98 和 C++11 之间的标准库 ABI Broken。不过在这之后，标准库的 ABI 一般相对稳定，各家实现也尽量保证。</p><p>另外由于 RTTI 和 Exception 一般可以关掉，所以这两项功能可能由单独的运行时库来负责，比如 MSVC 的 vcruntime和 libc++ 的 libcxxabi。</p><blockquote><p>值得一提的是，libcxxabi 中还包含了对静态局部变量初始化的支持，涉及到的主要函数是 <strong>cxa_guard_acquire,</strong> cxa_guard_release。使用它们来保证静态局部变量只在运行时初始化一次，如果对具体的实现感到好奇，可以查阅相关源码。</p></blockquote><p>还有就是负责一些底层功能的运行时库，除了标准库以外，C++ 程序一般还需要链接 C 运行时：</p><ul><li>在 Windows 上，必须链接 CRT</li><li>在 Linux 上 取决于所使用的发行版和编译环境，可能会链接 glibc或者 musl</li></ul><p>C 运行时除了提供 C 标准库的实现外，还负责程序的初始化和清理。它负责调用<code>main</code>函数，并管理程序的启动和终止过程，包括执行一些必要的初始化和清理工作。对于大多数在操作系统上的软件来说，链接它是必须的。</p><p>最理想的状态自然是，升级编译器的时候把这些对应的运行时库版本也升级，避免不必要的麻烦。但是在实际项目中，依赖关系可能十分复杂，可能会引发连锁反应。</p><h2 id="User-Code"><a href="#User-Code" class="headerlink" title="User Code"></a>User Code</h2><p>最后我们来谈谈用户代码自身的改变导致的 ABI 问题，如果希望将你的库以二进制形式进行分发，那么当用户量达到一定程度之后，ABI 兼容性就很重要了。</p><p>在第一小节讨论调用约定的时候，就提到过变更结构体定义导致的 ABI 不兼容问题。那如果既想要保证 ABI 兼容，又想要为以后得扩展留下空间怎么办呢？答案就是在运行时处理了</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> X<span class="token punctuation">{</span>    size_t x<span class="token punctuation">;</span>    size_t y<span class="token punctuation">;</span>    <span class="token keyword">void</span><span class="token operator">*</span> reserved<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过一个<code>void*</code>指针为以后的扩展预留空间。可以根据它来判断不同的版本，比如</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>X<span class="token operator">*</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Reserved<span class="token operator">*</span> r <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Reserved<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token operator">></span>reserved<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token operator">-</span><span class="token operator">></span>version <span class="token operator">==</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// do something</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token operator">-</span><span class="token operator">></span>version <span class="token operator">==</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// do something else</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就能在添加新的功能的同时而不影响原有的代码。</p><p>在对外暴露接口的时候，对于函数参数中有自定义析构函数的类型，也要格外注意。假设我们要暴露<code>std::vector</code>作为返回值，例如把下面这个简单的代码编译成动态库，并且使用<code>\MT</code>选项来静态链接 Windows CRT。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">__declspec</span><span class="token punctuation">(</span>dllexport<span class="token punctuation">)</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后我们写一个源文件，链接到刚才编译的这个动态库，调用这个函数</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> vec <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译运行，发现直接崩溃了。如果关闭<code>\MT</code>重新编译一遍动态库，然后运行，发现一切正常。很奇怪，为什么依赖的动态库静态链接 CRT 会导致代码崩溃？</p><p>思考一下上面的代码不难发现，<code>vec</code>的构造实际上发生在动态库里面，而析构则是发生在<code>main</code>函数里面。更进一步，其实就是内存是在动态库里面分配的，释放是在<code>main</code>函数里面。但是每一份 CRT 都有自己的<code>malloc</code>，<code>free</code>（类似于不同进程间的内存）。<strong>你不能把 CRT A 分配的内存交给 CRT B 释放</strong>，这就是问题的根源。所以之后不静态链接到 CRT 就没事了，它们用的都是同一个<code>malloc</code>，<code>free</code>。不仅仅是 WIndows CRT，对于 Linux 上的 glibc 或者 musl 也是一样的。</p><h3 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h3><p>对于任何带有自定义析构函数的 C++ 类型都可能出现上面那种情况，<strong>由于种种原因，构造函数和析构函数的调用跨越动态库边界，RAII 的约定被打破，导致严重的错误。</strong></p><p>如何解决呢？那自然是函数参数和返回值都不使用带有析构函数的类型了，只使用 POD 类型。例如上面那个例子需要改成</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> Vec <span class="token operator">=</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token function">__declspec</span><span class="token punctuation">(</span>dllexport<span class="token punctuation">)</span> Vec <span class="token function">create_Vec</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">__declspec</span><span class="token punctuation">(</span>dllexport<span class="token punctuation">)</span> <span class="token keyword">void</span> <span class="token function">destroy_Vec</span><span class="token punctuation">(</span>Vec vec<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">delete</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>vec<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后使用就得这样</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> Vec <span class="token operator">=</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">;</span>Vec <span class="token function">create_Vec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">destroy_Vec</span><span class="token punctuation">(</span>Vec vec<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Vec vec <span class="token operator">=</span> <span class="token function">create_Vec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">destroy_Vec</span><span class="token punctuation">(</span>vec<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实我们就是在按照 C 风格的 RAII 来进行封装。更进一步，如果想要解决 C 和 C++ 由于 mangling 不同而导致的链接问题，可以使用<code>extern &quot;C&quot;</code>来修饰函数</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">extern</span> <span class="token string">"C"</span> <span class="token punctuation">{</span>    Vec <span class="token function">create_Vec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">destroy_Vec</span><span class="token punctuation">(</span>Vec vec<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样的话 C 语言也可以使用上述的导出函数了，但是如果代码量很大的话，把全部的函数都封装成这样的 API 显然不太现实，那就只能把 C++ 的类型暴露在导出接口中，然后小心地管理依赖项（比如所有依赖库全都静态链接）。具体选择哪一种方式，还是要看项目大小和复杂度，然后再做定夺。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>到这里，我们终于讨论完了影响 C++ 程序 ABI 的主要因素。可以清楚地看到，C++ 标准、编译器厂商和运行时库都在尽力维护 ABI 的稳定性，C++ ABI 并没有很多人说的那么不堪，那么不稳定。对于小型项目而言，带源码静态链接，几乎不会有任何的兼容性问题。对于那些历史悠久的大型项目来说，由于复杂的依赖关系，升级某些库的版本可能会导致程序崩溃。<strong>但这并不是 C++ 的错，对于大型项目的管理，早已超出了单纯的语言层面，不能指望通过更换编程语言来解决这些问题</strong>。实际上，学习软件工程就是在学习如何应对巨大的复杂度，如何保证复杂系统的稳定性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Application Binary Interface 也就是我们常说的 ABI，是个让人感觉到既熟悉又陌生的概念。熟悉在哪里？讨论问题的
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="读书笔记" scheme="https://JoyTsing.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>grpc与CMake中find_package()命令神奇的寻址</title>
    <link href="https://joytsing.github.io/posts/48298/"/>
    <id>https://joytsing.github.io/posts/48298/</id>
    <published>2024-05-17T12:33:13.000Z</published>
    <updated>2024-05-17T13:36:21.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>问题总是在你意想不到的地方出现。</p><h2 id="重启了个电脑怎么就报错了呢"><a href="#重启了个电脑怎么就报错了呢" class="headerlink" title="重启了个电脑怎么就报错了呢"></a>重启了个电脑怎么就报错了呢</h2><p>昨天还在用，更新了一下写了个</p><p><img src="/posts/48298/faf973679d56abb145795bcf0223f26d.png" alt="有毛病"></p><h2 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2><p>长话短说，我一开始以为是谷歌的锅，看了一圈issue还去Stack Overflow上差了发现没人遇到我这个问题，当时我就怀疑是不是版本的问题，然后我把版本号打出来一看20230802（没意识到用的是最新的absl）</p><p>在这之后去还去看了absl的abslTargets.cmake，确实是有的，那么其实可以知道不是谷歌的锅，肯定又是和之前protobuf一样的全局变量的问题，但是这次问题就诡异在我没有显示或者隐式的引入过任何absl的库，那么为什么会报错。</p><p><img src="/posts/48298/f1fbd7ec93ad84e5608ffe2dfdc16c1e.png" alt="确实有"></p><p>后面还下了最新的absl加入到全局环境变量里面也不行（太神奇了），到后面想到可以看它引用的库地址在哪，一看发现非常神秘的找到了我曾经make过的库，但是这个库和grpc库是同级的。</p><p><img src="/posts/48298/1e41604d21dcc682b4c454b5b2bcf652.png" alt="要不是我版本名字取错了我还真没意识到"></p><p>直接删掉一试，发现就好了。</p><p><img src="/posts/48298/06da1d76fb8edc247c1b6e2cf8229da7.png" alt="尝试修改"></p><p>通过编译。</p><p><img src="/posts/48298/8a5d98be8540f8c41a082bb8510cd364.png" alt="终于解决了"></p><p>那么为什么grpc库会找到同级目录下的其他absl？</p><p><img src="/posts/48298/5f8f7c535e66dbc0c3ca6aedb553afea.png" alt="原来是你"></p><h2 id="find-package-查找逻辑"><a href="#find-package-查找逻辑" class="headerlink" title="find_package()查找逻辑"></a>find_package()查找逻辑</h2><p>CMAKE<strong>先在CMAKE_MODULE_PATH变量对应的路径中查找。如果路径为空，或者路径中查找失败，则在cmake module directory（cmake安装时的Modules目录，比如/usr/local/share/cmake/Modules）查找。</strong></p><p>搜索标准的系统环境变量PATH，其中如果是以/bin或者/sbin结尾的，会自动转化为其父目录，发现没有，makeInstall下面有一个bin文件夹，所以会自动转换，在同级文件夹下去找，而不是去子文件夹中寻找（优先级低）。</p><p>CMake为该软件包构造了一组可能的安装前缀。在每个前缀下的几个目录中搜索配置文件。下表显示了搜索的目录。每个条目均用于遵循Windows（<code>W</code>），UNIX（<code>U</code>）或Apple（<code>A</code>）约定的安装树：</p><pre class="line-numbers language-css"><code class="language-css">&lt;prefix>/                                                       <span class="token punctuation">(</span>W<span class="token punctuation">)</span>&lt;prefix>/<span class="token punctuation">(</span>cmake|CMake<span class="token punctuation">)</span>/                                         <span class="token punctuation">(</span>W<span class="token punctuation">)</span>&lt;prefix>/&lt;name>*/                                               <span class="token punctuation">(</span>W<span class="token punctuation">)</span>&lt;prefix>/&lt;name>*/<span class="token punctuation">(</span>cmake|CMake<span class="token punctuation">)</span>/                                 <span class="token punctuation">(</span>W<span class="token punctuation">)</span>&lt;prefix>/<span class="token punctuation">(</span>lib/&lt;arch>|lib*|share<span class="token punctuation">)</span>/cmake/&lt;name>*/                 <span class="token punctuation">(</span>U<span class="token punctuation">)</span>&lt;prefix>/<span class="token punctuation">(</span>lib/&lt;arch>|lib*|share<span class="token punctuation">)</span>/&lt;name>*/                       <span class="token punctuation">(</span>U<span class="token punctuation">)</span>&lt;prefix>/<span class="token punctuation">(</span>lib/&lt;arch>|lib*|share<span class="token punctuation">)</span>/&lt;name>*/<span class="token punctuation">(</span>cmake|CMake<span class="token punctuation">)</span>/         <span class="token punctuation">(</span>U<span class="token punctuation">)</span>&lt;prefix>/&lt;name>*/<span class="token punctuation">(</span>lib/&lt;arch>|lib*|share<span class="token punctuation">)</span>/cmake/&lt;name>*/         <span class="token punctuation">(</span>W/U<span class="token punctuation">)</span>&lt;prefix>/&lt;name>*/<span class="token punctuation">(</span>lib/&lt;arch>|lib*|share<span class="token punctuation">)</span>/&lt;name>*/               <span class="token punctuation">(</span>W/U<span class="token punctuation">)</span>&lt;prefix>/&lt;name>*/<span class="token punctuation">(</span>lib/&lt;arch>|lib*|share<span class="token punctuation">)</span>/&lt;name>*/<span class="token punctuation">(</span>cmake|CMake<span class="token punctuation">)</span>/ <span class="token punctuation">(</span>W/U<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以会去搜索标准的系统环境变量，在bin的同级目录中就找到了老版本的absl，所以编译就失败了。说实话我没想到影响今天编译的会是昨晚上添加的可执行bin路径，令人感叹。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;问题总是在你意想不到的地方出现。&lt;/p&gt;
&lt;h2 id=&quot;重启了个电脑怎么就报错了呢&quot;&gt;&lt;a href=&quot;#重启了个电脑怎么就报错了呢&quot; c
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>RPC的基本原理和层次架构</title>
    <link href="https://joytsing.github.io/posts/17654/"/>
    <id>https://joytsing.github.io/posts/17654/</id>
    <published>2024-05-14T13:02:16.000Z</published>
    <updated>2024-05-14T13:26:20.350Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>本文来自srpc作者李颖欣。</strong></p><p>只要涉及到网络通信，必然涉及到网络协议，应用层也是一样。在应用层最标准和常用的就是HTTP协议。但在很多性能要求较高的场景各大企业内部也会自定义的 RPC 协议。举个例子，就是相当于各个省不但用官方普通话，还都有自己的方言，RPC就相当于是一个方言。</p><p><strong>RPC</strong> 的全称是 <strong>Remote Procedure Call</strong>，翻译过来就是远程过程调用，其实这个名称过分强调了和LPC（本地过程调用）的对比。没有突出出来 RPC 本身涉及到的一些技术特点。现在从三个角度聊聊 RPC</p><ul><li>RPC是什么：通过和HTTP的对比来帮大家了解RPC</li><li>RPC有什么：介绍了RPC用到的用户桩代码、IDL序列化、压缩、协议、通信等技术点</li><li>RPC生命周期：详细探讨RPC从请求发出到收到返回的全过程</li></ul><h2 id="RPC是什么"><a href="#RPC是什么" class="headerlink" title="RPC是什么"></a>RPC是什么</h2><p>RPC可以分为两部分：<strong>用户调用接口</strong> + <strong>具体网络协议</strong>。前者为开发者需要关心的，后者由框架来实现。</p><h3 id="1-用户调用接口"><a href="#1-用户调用接口" class="headerlink" title="1. 用户调用接口"></a>1. 用户调用接口</h3><p>举个例子，定义一个函数希望函数如果输入为“Hello World”的话，输出给一个“OK”，那么这个函数是个本地调用。如果一个远程服务收到“Hello World”可以给我们返回一个“OK”，那么这是一个远程调用。我们会和服务约定好远程调用的函数名。因此，我们的用户接口就是：<strong>输入</strong>、<strong>输出</strong>、<strong>远程函数名</strong>。</p><h3 id="2-具体网络协议"><a href="#2-具体网络协议" class="headerlink" title="2. 具体网络协议"></a>2. 具体网络协议</h3><p>这是框架来实现的，把开发者要发出和接收的内容以某种应用层协议打包进行网络收发。这里可以和HTTP进行一个明显的对比：</p><ul><li><p>RPC是一种自定义网络协议，由具体框架来定，比如SRPC里支持的RPC协议有：SRPC / thrift / BRPC / tRPC，并且也是<strong>tRPC</strong>协议目前唯一的开源实现，拿其中的SogouRPC-std protocol为例给大家看看RPC协议的大概样子：</p><p><img src="/posts/17654/640-1715693046838-12.webp" alt></p></li><li><p>HTTP也是一种网络协议，但包的内容是固定的，必须是：请求行 + 请求头 + 请求体；</p><p><img src="/posts/17654/640.webp" alt></p></li></ul><h3 id="3-进一步思考"><a href="#3-进一步思考" class="headerlink" title="3. 进一步思考"></a>3. 进一步思考</h3><p>上图对应的颜色，所实现的功能是类似的。为什么大家都长差不多呢？</p><p>这里就需要搞清楚，我们想要实现用户接口，需要怎么做？最重要需要支持以下三个功能：</p><ul><li>定位要调用的服务；</li><li>把完整的消息切下来；</li><li>让我们的消息向前/向后兼容；</li></ul><p>这样既可以让消息内保证一定的灵活性，又可以方便拿下一块数据，去调用用户想要的服务。</p><p>我们用一个表格来看一下HTTP和RPC分别是怎么解决的：</p><table><thead><tr><th align="left"></th><th align="left">定位要调用的服务</th><th align="left">消息长度</th><th align="left">消息前后兼容</th></tr></thead><tbody><tr><td align="left">HTTP</td><td align="left">URL</td><td align="left">header里Content-Length</td><td align="left">body里自己解决</td></tr><tr><td align="left">RPC</td><td align="left">指定Service和Method名</td><td align="left">协议header里自行约定</td><td align="left">交给具体IDL</td></tr></tbody></table><p>因此，大家都会需要类似的结构去组装一条完整的用户请求，而第三部分的body只要框架支持，RPC协议和HTTP是可以互通的！因此开发者完全可以根据自己的业务需求进行选型，接下来我们看一下RPC的层次架构，就可以明白为什么不同RPC框架之间的互通、以及RPC和HTTP协议又是如何做到互通的。</p><h2 id="RPC有什么"><a href="#RPC有什么" class="headerlink" title="RPC有什么"></a>RPC有什么</h2><p>我们可以借SRPC的架构，看一下RPC框架从用户到系统都有哪些层次，以及SRPC目前所横向支持的功能是什么：</p><ul><li><strong>用户代码</strong>（client的发送函数/server的函数实现）</li><li><strong>IDL序列化</strong>（protobuf/thrift serialization）</li><li><strong>数据组织</strong> （protobuf/thrift/json）</li><li><strong>压缩</strong>（none/gzip/zlib/snappy/lz4）</li><li><strong>协议</strong> （Sogou-std/Baidu-std/Thrift-framed/TRPC）</li><li><strong>通信</strong> （TCP/HTTP）</li></ul><p>我们先关注以下三个层级：</p><p><img src="/posts/17654/640-1715692787329-3.webp" alt></p><p>如图从左到右，是用户接触的最多到最少的层次。IDL层会根据开发者定义的请求/回复结构进行代码生成，目前用得比较多的是protobuf和thrift，而刚才说到的用户接口和前后兼容问题，都是IDL层来解决的。SRPC对于这两个IDL的用户接口实现方式是：</p><ul><li>thrift：IDL纯手工解析，用户使用srpc是不需要链thrift的库的</li><li>protobuf：service的定义部分纯手工解析</li></ul><p>中间那列是具体的网络协议，而各RPC能互通，就是因为大家实现了对方的“语言”，因此可以协议互通。</p><p>而RPC作为和HTTP并列的层次，第二列和第三列理论上是可以两两结合的，只需要第二列的具体RPC协议在发送时，把HTTP相关的内容进行特化，不要按照自己的协议去发，而按照HTTP需要的形式去发，就可以实现RPC与HTTP互通。</p><h2 id="RPC的生命周期"><a href="#RPC的生命周期" class="headerlink" title="RPC的生命周期"></a>RPC的生命周期</h2><p>到此我们可以通过SRPC看一下，把request通过method发送出去并处理response再回来的整件事情是怎么做的：</p><p><img src="/posts/17654/640-1715692932973-6.webp" alt></p><p>根据上图，可以更清楚地看到刚才提及的各个层级，其中压缩层、序列化层、协议层其实是互相解耦打通的，在SRPC代码上实现得非常统一，横向增加任何一种压缩算法或IDL或协议都不需要也不应该改动现有的代码。</p><p><img src="/posts/17654/640-1715692973908-9.webp" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本文来自srpc作者李颖欣。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只要涉及到网络通信，必然涉及到网络协议，应用层也是一样。在应用
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Redis单线程高性能解密</title>
    <link href="https://joytsing.github.io/posts/55825/"/>
    <id>https://joytsing.github.io/posts/55825/</id>
    <published>2024-05-12T13:48:11.000Z</published>
    <updated>2024-05-15T09:04:00.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>仅仅靠单线程就可以支撑起每秒数万 QPS 的高处理能力，今天重点来看一下Redis 核心网络模块，很多时候网络是限制性能的重要因素。</p><h2 id="一、多路复用原理"><a href="#一、多路复用原理" class="headerlink" title="一、多路复用原理"></a>一、多路复用原理</h2><p>epoll可以说是老生常谈了，这里就放一张图吧。</p><p>性能提升思路很简单，就是让很多的用户连接来复用同一个进(线)程，这就是<strong>多路复用</strong>。<strong>多路</strong>指的是许许多多个用户的网络连接。<strong>复用</strong>指的是对进(线)程的复用。换到牧羊人的例子里，就是一群羊只要一个牧羊人来处理就行了。</p><p>不过复用实现起来是需要特殊的 socket 事件管理机制的，最典型和高效的方案就是 epoll。放到牧羊人的例子来，epoll 就相当于一只牧羊犬。</p><p>在 epoll 的系列函数里， epoll_create 用于创建一个 epoll 对象，epoll_ctl 用来给 epoll 对象添加或者删除一个 socket。epoll_wait 就是查看它当前管理的这些 socket 上有没有可读可写事件发生。</p><p><img src="/posts/55825/640-1715754558858-5.webp" alt></p><p>当网卡上收到数据包后，Linux 内核进行一系列的处理后把数据放到 socket 的接收队列。然后会检查是否有 epoll 在管理它，如果是则在 epoll 的就绪队列中插入一个元素。epoll_wait 的操作就非常的简单了，就是到 epoll 的就绪队列上来查询有没有事件发生就行了。关于 epoll 这只“牧羊犬”的工作原理参见：<a href="https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&mid=2247484905&idx=1&sn=a74ed5d7551c4fb80a8abe057405ea5e&scene=21#wechat_redirect">深入揭秘 epoll 是如何实现 IO 多路复用的</a> （或者深入理解Linux网络内核这本书）。</p><p>在基于 epoll 的编程中，和传统的函数调用思路不同的是，我们并不能主动调用某个 API 来处理。因为无法知道我们想要处理的事件啥时候发生。所以只好提前把想要处理的事件的处理函数注册到一个<strong>事件分发器</strong>上去。当事件发生的时候，由这个事件分发器调用回调函数进行处理。这类基于实现注册事件分发器的开发模式也叫 Reactor 模型。</p><h2 id="二、Redis-服务启动初始化"><a href="#二、Redis-服务启动初始化" class="headerlink" title="二、Redis 服务启动初始化"></a>二、Redis 服务启动初始化</h2><p>其中整个 Redis 服务的代码总入口在 src/server.c 文件中，如下。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: src/server.c</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 启动初始化</span>    <span class="token function">initServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 运行事件处理循环，一直到服务器关闭为止</span>    <span class="token function">aeMain</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>整个 Redis 的工作过程，就只需要理解清楚 main 函数中调用的 initServer 和 aeMain 这两个函数就足够了。在 initServer 这个函数内，Redis 做了这么三件重要的事情。</p><p><img src="/posts/55825/640.webp" alt></p><ul><li>创建一个 epoll 对象</li><li>对配置的监听端口进行 listen</li><li>把 listen socket 让 epoll 给管理起来</li></ul><h3 id="2-1-创建-epoll-对象"><a href="#2-1-创建-epoll-对象" class="headerlink" title="2.1 创建 epoll 对象"></a>2.1 创建 epoll 对象</h3><p>Redis 在操作系统提供的 epoll 对象基础上又封装了一个 eventLoop 出来，所以创建的时候是先申请和创建 eventLoop。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/ae.c</span>aeEventLoop <span class="token operator">*</span><span class="token function">aeCreateEventLoop</span><span class="token punctuation">(</span><span class="token keyword">int</span> setsize<span class="token punctuation">)</span> <span class="token punctuation">{</span>    aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">;</span>    eventLoop <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//将来的各种回调事件就都会存在这里</span>    eventLoop<span class="token operator">-></span>events <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>aeFileEvent<span class="token punctuation">)</span><span class="token operator">*</span>setsize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">aeApiCreate</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> eventLoop<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-绑定监听服务端口"><a href="#2-2-绑定监听服务端口" class="headerlink" title="2.2 绑定监听服务端口"></a>2.2 绑定监听服务端口</h3><p> Redis 中的 listen 过程，它在 listenToPort 函数中。虽然调用链条很长，但其实主要就是执行了个简单 listen 而已。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: src/redis.c</span><span class="token keyword">int</span> <span class="token function">listenToPort</span><span class="token punctuation">(</span><span class="token keyword">int</span> port<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>fds<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>count<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>bindaddr_count <span class="token operator">||</span> j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        fds<span class="token punctuation">[</span><span class="token operator">*</span>count<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">anetTcpServer</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>neterr<span class="token punctuation">,</span>port<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>                server<span class="token punctuation">.</span>tcp_backlog<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Redis 是支持开启多个端口的，所以在 listenToPort 中我们看到是启用一个循环来调用 anetTcpServer。在 anetTcpServer 中，逐步会展开调用，直到执行到 bind 和 listen 系统调用。</p><h3 id="2-3-注册事件回调函数"><a href="#2-3-注册事件回调函数" class="headerlink" title="2.3 注册事件回调函数"></a>2.3 注册事件回调函数</h3><p> initServer里面调用 aeCreateEventLoop 创建了 epoll，调用 listenToPort 进行了服务端口的 bind 和 listen。接着就开始调用 aeCreateFileEvent 来注册一个 accept 事件处理器。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: src/server.c</span><span class="token keyword">void</span> <span class="token function">initServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 2.1.1 创建 epoll</span>    server<span class="token punctuation">.</span>el <span class="token operator">=</span> <span class="token function">aeCreateEventLoop</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxclients<span class="token operator">+</span>CONFIG_FDSET_INCR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2.1.2 监听服务端口</span>    <span class="token function">listenToPort</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>port<span class="token punctuation">,</span>server<span class="token punctuation">.</span>ipfd<span class="token punctuation">,</span><span class="token operator">&amp;</span>server<span class="token punctuation">.</span>ipfd_count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2.1.3 注册 accept 事件处理器</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>ipfd_count<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span> server<span class="token punctuation">.</span>ipfd<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> AE_READABLE<span class="token punctuation">,</span>            acceptTcpHandler<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用 aeCreateFileEvent 时传的重要参数是 acceptTcpHandler，它表示将来在 listen socket 上有新用户连接到达的时候，该函数将被调用执行。我们来看 aeCreateFileEvent 具体代码。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: src/ae.c</span><span class="token keyword">int</span> <span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">,</span>        aeFileProc <span class="token operator">*</span>proc<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 取出一个文件事件结构</span>    aeFileEvent <span class="token operator">*</span>fe <span class="token operator">=</span> <span class="token operator">&amp;</span>eventLoop<span class="token operator">-></span>events<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 监听指定 fd 的指定事件</span>    <span class="token function">aeApiAddEvent</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> mask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 设置文件事件类型，以及事件的处理器</span>    fe<span class="token operator">-></span>mask <span class="token operator">|</span><span class="token operator">=</span> mask<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mask <span class="token operator">&amp;</span> AE_READABLE<span class="token punctuation">)</span> fe<span class="token operator">-></span>rfileProc <span class="token operator">=</span> proc<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mask <span class="token operator">&amp;</span> AE_WRITABLE<span class="token punctuation">)</span> fe<span class="token operator">-></span>wfileProc <span class="token operator">=</span> proc<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 私有数据</span>    fe<span class="token operator">-></span>clientData <span class="token operator">=</span> clientData<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数 aeCreateFileEvent 一开始，从 eventLoop-&gt;events 获取了一个 aeFileEvent 对象， eventLoop-&gt;events 数组，注册的各种事件处理器会保存在这个地方。接下来调用 aeApiAddEvent。这个函数其实就是对 epoll_ctl 的一个封装。主要就是实际执行 epoll_ctl EPOLL_CTL_ADD。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/ae_epoll.c</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">aeApiAddEvent</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// add or mod</span>    <span class="token keyword">int</span> op <span class="token operator">=</span> eventLoop<span class="token operator">-></span>events<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">.</span>mask <span class="token operator">==</span> AE_NONE <span class="token operator">?</span>            EPOLL_CTL_ADD <span class="token punctuation">:</span> EPOLL_CTL_MOD<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// epoll_ctl 添加事件</span>    <span class="token function">epoll_ctl</span><span class="token punctuation">(</span>state<span class="token operator">-></span>epfd<span class="token punctuation">,</span>op<span class="token punctuation">,</span>fd<span class="token punctuation">,</span><span class="token operator">&amp;</span>ee<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每一个 eventLoop-&gt;events 元素都指向一个 aeFileEvent 对象。在这个对象上，设置了三个关键东西</p><ul><li>rfileProc：读事件回调</li><li>wfileProc：写事件回调</li><li>clientData：一些额外的扩展数据</li></ul><p>当 epoll_wait 发现某个 fd 上有事件发生的时候，这样 redis 首先根据 fd 到 eventLoop-&gt;events 中查找 aeFileEvent 对象，然后再看 rfileProc、wfileProc 就可以找到读、写回调处理函数。回头看 initServer 调用 aeCreateFileEvent 时传参来看。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: src/server.c</span><span class="token keyword">void</span> <span class="token function">initServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 2.1.3 注册 accept 事件处理器</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>ipfd_count<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span> server<span class="token punctuation">.</span>ipfd<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> AE_READABLE<span class="token punctuation">,</span>            acceptTcpHandler<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>listen fd 对应的读回调函数 rfileProc 事实上就被设置成了 acceptTcpHandler，写回调没有设置，私有数据 client_data 也为 null。</p><h2 id="三、Redis-事件处理循环"><a href="#三、Redis-事件处理循环" class="headerlink" title="三、Redis 事件处理循环"></a>三、Redis 事件处理循环</h2><p>接下来，Redis 就会进入 aeMain 开始进行真正的用户请求处理了。在 aeMain 函数中，是一个无休止的循环。在每一次的循环中，要做如下几件事情。</p><p><img src="/posts/55825/640-1715755732174-8.webp" alt></p><ul><li>通过 epoll_wait 发现 listen socket 以及其它连接上的可读、可写事件</li><li>若发现 listen socket 上有新连接到达，则接收新连接，并追加到 epoll 中进行管理</li><li>若发现其它 socket 上有命令请求到达，则读取和处理命令，把命令结果写到缓存中，加入写任务队列</li><li>每一次进入 epoll_wait 前都调用 beforesleep 来将写任务队列中的数据实际进行发送</li><li>如若有首次未发送完毕的，当写事件发生时继续发送</li></ul><p>以上就是 aeMain 函数的核心逻辑所在，接下来我们分别对如上提到的四件事情进行详细的阐述。</p><h3 id="3-1-epoll-wait-发现事件"><a href="#3-1-epoll-wait-发现事件" class="headerlink" title="3.1  epoll_wait 发现事件"></a>3.1  epoll_wait 发现事件</h3><p>Redis 不管有多少个用户连接，都是通过 epoll_wait 来统一发现和管理其上的可读（包括 liisten socket 上的 accept事件）、可写事件的。甚至连 timer，也都是交给 epoll_wait 来统一管理的。</p><p><img src="/posts/55825/640-1715756405877-11.webp" alt></p><p>每当 epoll_wait 发现特定的事件发生的时候，就会调用相应的事先注册好的事件处理函数进行处理。aeProcessEvents 就是调用 epoll_wait 来发现事件。当发现有某个 fd 上事件发生以后，则调为其事先注册的事件处理器函数 rfileProc 和 wfileProc。</p><h3 id="3-2-处理新连接请求"><a href="#3-2-处理新连接请求" class="headerlink" title="3.2 处理新连接请求"></a>3.2 处理新连接请求</h3><p>我们假设现在有新用户连接到达了。前面在我们看到 listen socket 上的 rfileProc 注册的是 acceptTcpHandler。也就是说，如果有连接到达的时候，会回调到 acceptTcpHandler。</p><p>在 acceptTcpHandler 中，主要做了几件事情</p><p><img src="/posts/55825/640-1715756436233-14.webp" alt></p><ul><li>调用 accept 系统调用把用户连接给接收回来</li><li>为这个新连接创建一个唯一 redisClient 对象</li><li>将这个新连接添加到 epoll，并注册一个读事件处理函数</li></ul><h3 id="3-3-处理客户连接上的可读事件"><a href="#3-3-处理客户连接上的可读事件" class="headerlink" title="3.3 处理客户连接上的可读事件"></a>3.3 处理客户连接上的可读事件</h3><p>现在假设该用户连接有命令到达了，就假设用户发送了<code>GET XXXXXX_KEY</code> 命令。那么在 Redis 的时间循环中调用 epoll_wait 发现该连接上有读时间后，会调用在上一节中讨论的为其注册的读处理函数 readQueryFromClient。</p><p><img src="/posts/55825/640-1715760737074-17.webp" alt></p><p>在读处理函数 readQueryFromClient 中主要做了这么几件事情。</p><ul><li>解析并查找命令</li><li>调用命令处理</li><li>添加写任务到队列</li><li>将输出写到缓存等待发送</li></ul><h3 id="3-4-beforesleep-处理写任务队列"><a href="#3-4-beforesleep-处理写任务队列" class="headerlink" title="3.4 beforesleep 处理写任务队列"></a>3.4 beforesleep 处理写任务队列</h3><p>次在进入 aeProcessEvents 前都需要先进行 beforesleep 处理。这个函数名字起的怪怪的，但实际上大有用处。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/ae.c</span><span class="token keyword">void</span> <span class="token function">aeMain</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">{</span>    eventLoop<span class="token operator">-></span>stop <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>eventLoop<span class="token operator">-></span>stop<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// beforesleep 处理写任务队列并实际发送之</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>eventLoop<span class="token operator">-></span>beforesleep <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            eventLoop<span class="token operator">-></span><span class="token function">beforesleep</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">aeProcessEvents</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> AE_ALL_EVENTS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该函数处理了许多工作，其中一项便是遍历发送任务队列，并将 client 发送缓存区中的处理结果通过 write 发送到客户端手中。</p><p><img src="/posts/55825/640-1715761315329-20.webp" alt></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/server.c</span><span class="token keyword">void</span> <span class="token function">beforeSleep</span><span class="token punctuation">(</span><span class="token keyword">struct</span> aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">handleClientsWithPendingWrites</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//file:src/networking.c</span><span class="token keyword">int</span> <span class="token function">handleClientsWithPendingWrites</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    listIter li<span class="token punctuation">;</span>    listNode <span class="token operator">*</span>ln<span class="token punctuation">;</span>    <span class="token keyword">int</span> processed <span class="token operator">=</span> <span class="token function">listLength</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_write<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//遍历写任务队列 server.clients_pending_write</span>    <span class="token function">listRewind</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_write<span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>        c<span class="token operator">-></span>flags <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token operator">~</span>CLIENT_PENDING_WRITE<span class="token punctuation">;</span>        <span class="token function">listDelNode</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_write<span class="token punctuation">,</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//实际将 client 中的结果数据发送出去</span>        <span class="token function">writeToClient</span><span class="token punctuation">(</span>c<span class="token operator">-></span>fd<span class="token punctuation">,</span>c<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//如果一次发送不完则准备下一次发送</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">clientHasPendingReplies</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//注册一个写事件处理器，等待 epoll_wait 发现可写后再处理 </span>            <span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span> c<span class="token operator">-></span>fd<span class="token punctuation">,</span> ae_flags<span class="token punctuation">,</span>                sendReplyToClient<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>handleClientsWithPendingWrites</code> 中，遍历了发送任务队列 <code>server.clients_pending_write</code>，并调用 writeToClient 进行实际的发送处理。值得注意的是，发送 write 并不总是能一次性发送完的。假如要发送的结果太大，而系统为每个 socket 设置的发送缓存区又是有限的。</p><p>在这种情况下，<code>clientHasPendingReplies</code> 判断仍然有未发送完的数据的话，就需要注册一个写事件处理函数到 epoll 上。等待 epoll 发现该 socket 可写的时候再次调用 <code>sendReplyToClient</code>进行发送。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/networking.c</span><span class="token keyword">int</span> <span class="token function">writeToClient</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> client <span class="token operator">*</span>c<span class="token punctuation">,</span> <span class="token keyword">int</span> handler_installed<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">clientHasPendingReplies</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 先发送固定缓冲区</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>bufpos <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            nwritten <span class="token operator">=</span> <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>c<span class="token operator">-></span>buf<span class="token operator">+</span>c<span class="token operator">-></span>sentlen<span class="token punctuation">,</span>c<span class="token operator">-></span>bufpos<span class="token operator">-</span>c<span class="token operator">-></span>sentlen<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nwritten <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true">// 再发送回复链表中数据</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            o <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span><span class="token function">listFirst</span><span class="token punctuation">(</span>c<span class="token operator">-></span>reply<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            nwritten <span class="token operator">=</span> <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> o<span class="token operator">-></span>buf <span class="token operator">+</span> c<span class="token operator">-></span>sentlen<span class="token punctuation">,</span> objlen <span class="token operator">-</span> c<span class="token operator">-></span>sentlen<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>writeToClient 中的主要逻辑就是调用 write 系统调用让内核帮其把数据发送出去即可。由于每个命令的处理结果大小是不固定的。所以 Redis 采用的做法用固定的 buf + 可变链表来储存结果字符串。这里自然发送的时候就需要分别对固定缓存区和链表来进行发送了。</p><h2 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h2><p>到了喜闻乐见的小结时间，Redis 服务器端只需要单线程可以达到非常高的处理能力，每秒可以达到数万 QPS 的高处理能力。如此高性能的程序其实就是对 Linux 提供的多路复用机制 epoll 的一个较为完美的运用。</p><p>在 Redis 源码中，核心逻辑其实就是两个，一个是 initServer 启动服务，另外一个就是 aeMain 事件循环。在 initServer 这个函数内，Redis 做了这么三件重要的事情。</p><ul><li>创建一个 epoll 对象</li><li>对配置的监听端口进行 listen</li><li>把 listen socket 让 epoll 给管理起来</li></ul><p>在 aeMain 函数中，是一个无休止的循环，它是 Redis 中最重要的部分。在每一次的循环中，要做的事情可以总结为如下图。</p><p><img src="/posts/55825/640-1715761585179-23.webp" alt></p><ul><li>通过 epoll_wait 发现 listen socket 以及其它连接上的可读、可写事件</li><li>若发现 listen socket 上有新连接到达，则接收新连接，并追加到 epoll 中进行管理</li><li>若发现其它 socket 上有命令请求到达，则读取和处理命令，把命令结果写到缓存中，加入写任务队列</li><li>每一次进入 epoll_wait 前都调用 beforesleep 来将写任务队列中的数据实际进行发送</li></ul><p>其实事件分发器还处理了一个不明显的逻辑，那就是如果 beforesleep 在将结果写回给客户端的时候，如果由于内核 socket 发送缓存区过小而导致不能一次发送完毕的时候，也会注册一个写事件处理器。等到 epoll_wait 发现对应的 socket 可写的时候，再执行 write 写处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;仅仅靠单线程就可以支撑起每秒数万 QPS 的高处理能力，今天重点来看一下Redis 核心网络模块，很多时候网络是限制性能的重要因素。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://JoyTsing.github.io/categories/Redis/"/>
    
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="Redis" scheme="https://JoyTsing.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>重新认识端口重用</title>
    <link href="https://joytsing.github.io/posts/48/"/>
    <id>https://joytsing.github.io/posts/48/</id>
    <published>2024-05-12T12:08:25.000Z</published>
    <updated>2024-05-14T13:55:49.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>如果服务器上已经有个进程在 listen 6000 这个端口号了。那么该服务器上其它进程是否还能 bind 和 listen 该端口呢？相信学过一些的一定会答说是不能的。因为很多人都遇到过“Address already in use”这个错误。而这个错误产生的原因就是端口已经被占用。</p><p>但其实在 Linux 3.9 以上的内核版本里，是允许多个进程绑定到同一个端口号上(其实在使用<code>boost asio</code>的时候你就会发现我们并没有显式调用bind)。这就是今天要说的 REUSEPORT 新特性。那么REUSEPORT 是为了解决什么问题而产生的。如果有多个进程复用同一个端口，当用户请求到达时内核是如何选一个进程进行响应的。</p><h2 id="REUSEPORT-要解决的问题"><a href="#REUSEPORT-要解决的问题" class="headerlink" title="REUSEPORT 要解决的问题"></a>REUSEPORT 要解决的问题</h2><p>关于 REUSEPORT 特性产生的背景其实在 linux 的 <a href="https://github.com/torvalds/linux/commit/da5e36308d9f7151845018369148201a5d28b46d">commit</a> 中提供的足够详细了，本质上与PV4向IPV6转变的理由是相同的，都是端口(IP)不够满足现在的发展。如今互联网澎湃发展，应对海量流量的主要措施就是应用多进程模型。在端口不可被重复 bind 和 listen 的年代里，提供海量服务的多进程 Server 提供一般是采用如下两种进程模型来工作。</p><p>第一种是专门搞一个或多个进程服务 accept 新连接，接收请求，然后将请求转给其它的 worker 进程来处理。</p><p><img src="/posts/48/640.webp" alt></p><p>这种多进程模型有两个问题，首先第一个是 dispatcher 进程并不处理任务，需要转交给 worker 进程来处理和响应。这会导致一次额外的进程上下文切换的开销。第二个问题是如果流量特别大的时候 dispatcher 进程很容易成为制约整个服务 qps 提升的瓶颈。</p><p>还有另一种多进程模型是多个进程复用一个 listen 状态的 socket，多个进程同时从一个 socket 中 accept 请求来处理。Nginx 就采用的是这种模型。</p><p><img src="/posts/48/640-1715688988548-1.webp" alt></p><p>这种进程模型解决了第一个模型的问题。但是又带来了新的问题。当 socket 收到一条连接的时候，不能把所有的 worker 进程都招呼起来。需要用锁来保证唯一性，这样就会有锁竞争的问题。</p><h2 id="REUSEPORT-的诞生"><a href="#REUSEPORT-的诞生" class="headerlink" title="REUSEPORT 的诞生"></a>REUSEPORT 的诞生</h2><p>为了更高效地让多个用户态的进程接收和响应客户端的请求。Linux 在 2013 年的 3.9 版本中提供了 REUSEPORT 新特性。</p><p><img src="/posts/48/640-1715689168184-6.webp" alt></p><p>该特性允许同一机器上的多个进程同时创建<strong>不同的 socket 来 bind 和 listen 在相同的端口上</strong>。然后在<strong>内核层面实现多个用户进程的负载均衡</strong>。</p><h3 id="SO-REUSEPORT-设置"><a href="#SO-REUSEPORT-设置" class="headerlink" title="SO_REUSEPORT 设置"></a>SO_REUSEPORT 设置</h3><p>想给自己的服务开启 REUSEPORT 很简单，就是给自己 server 里 listen 用的 socket 上加这么一句。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">setsockopt</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> SOL_SOCKET<span class="token punctuation">,</span> SO_REUSEPORT<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这行代码在内核中对应的处理步骤就是把内核 socket 的 sk_reuseport 字段设置为相应的值，开启的话是 1。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: net/core/sock.c</span><span class="token keyword">int</span> <span class="token function">sock_setsockopt</span><span class="token punctuation">(</span><span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">int</span> level<span class="token punctuation">,</span> <span class="token keyword">int</span> optname<span class="token punctuation">,</span>      <span class="token keyword">char</span> __user <span class="token operator">*</span>optval<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> optlen<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">switch</span> <span class="token punctuation">(</span>optname<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token keyword">case</span> SO_REUSEPORT<span class="token punctuation">:</span>   sk<span class="token operator">-></span>sk_reuseport <span class="token operator">=</span> valbool<span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="bind-时的处理"><a href="#bind-时的处理" class="headerlink" title="bind 时的处理"></a>bind 时的处理</h3><p>内核在 inet_bind 时会调用到 inet_csk_get_port 函数。bind 时对 reuseport 的处理过程。来看源码：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: net/ipv4/inet_connection_sock.c</span><span class="token keyword">int</span> <span class="token function">inet_csk_get_port</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">short</span> snum<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true">//在绑定表（bhash）中查找，</span> head <span class="token operator">=</span> <span class="token operator">&amp;</span>hashinfo<span class="token operator">-></span>bhash<span class="token punctuation">[</span><span class="token function">inet_bhashfn</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> snum<span class="token punctuation">,</span>   hashinfo<span class="token operator">-></span>bhash_size<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token function">inet_bind_bucket_for_each</span><span class="token punctuation">(</span>tb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>head<span class="token operator">-></span>chain<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//找到了，在一个命名空间下而且端口号一致，表示该端口已经绑定</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">net_eq</span><span class="token punctuation">(</span><span class="token function">ib_net</span><span class="token punctuation">(</span>tb<span class="token punctuation">)</span><span class="token punctuation">,</span> net<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> tb<span class="token operator">-></span>port <span class="token operator">==</span> snum<span class="token punctuation">)</span>   <span class="token keyword">goto</span> tb_found<span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>内核通过拉链哈希表的方式来管理所有的 bind 的 socket。其中 inet_bhashfn 是计算哈希值的函数。</p><p><img src="/posts/48/640-1715689472912-9.webp" alt></p><p>当计算找到哈希槽位以后，通过<code>inet_bind_bucket_for_each</code> 来遍历所有的 bind 状态的 socket，目的是为了判断是否冲突。</p><p><code>net_eq(ib_net(tb), net)</code> 这个条件表示网络命名空间匹配，tb-&gt;port == snum 表示端口号匹配。这两个条件加起来，就是说在同一个命名空间下，该端口已经被绑定过了。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: net/ipv4/inet_connection_sock.c</span><span class="token keyword">int</span> <span class="token function">inet_csk_get_port</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">short</span> snum<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>tb<span class="token operator">-></span>fastreuse <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>       sk<span class="token operator">-></span>sk_reuse <span class="token operator">&amp;&amp;</span> sk<span class="token operator">-></span>sk_state <span class="token operator">!=</span> TCP_LISTEN<span class="token punctuation">)</span> <span class="token operator">||</span>      <span class="token punctuation">(</span>tb<span class="token operator">-></span>fastreuseport <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>       sk<span class="token operator">-></span>sk_reuseport <span class="token operator">&amp;&amp;</span> <span class="token function">uid_eq</span><span class="token punctuation">(</span>tb<span class="token operator">-></span>fastuid<span class="token punctuation">,</span> uid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>     smallest_size <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">goto</span> success<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//绑定冲突</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看<code>tb-&gt;fastreuseport &gt; 0</code>和 <code>sk-&gt;sk_reuseport</code> 这两个条件。</p><p>这两个条件的意思是已经 bind 的 socket 和正在 bind 的 socket 都开启了 SO_REUSEPORT 特性。符合条件的话，将会跳转到 success 进行绑定成功的处理。<strong>也就是说，这个端口可以重复绑定使用！</strong></p><p><code>uid_eq(tb-&gt;fastuid, uid)</code>这个条件目的是安全性，必须要求相同的用户进程下的 socket 才可以复用端口。<strong>避免跨用户启动相同端口来窃取另外用户服务上的流量。</strong></p><h3 id="accept-响应新连接"><a href="#accept-响应新连接" class="headerlink" title="accept 响应新连接"></a>accept 响应新连接</h3><p>当有多个进程都 bind 和 listen 了同一个端口的时候。有客户端连接请求到来的时候就涉及到选择哪个 socket（进程）进行处理的问题。我们再简单看一下，响应连接时的处理过程。</p><p>内核仍然是通过 hash + 拉链的方式来保存所有的 listen 状态的 socket。</p><p><img src="/posts/48/640-1715689472912-10.webp" alt></p><p>查找 listen 状态的 socket 的时候需要查找该哈希表。进入响应握手请求的时候进入的一个关键函数<code>__inet_lookup_listener</code> 。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: net/ipv4/inet_hashtables.c</span><span class="token keyword">struct</span> sock <span class="token operator">*</span><span class="token function">__inet_lookup_listener</span><span class="token punctuation">(</span><span class="token keyword">struct</span> net <span class="token operator">*</span>net<span class="token punctuation">,</span>        <span class="token keyword">struct</span> inet_hashinfo <span class="token operator">*</span>hashinfo<span class="token punctuation">,</span>        <span class="token keyword">const</span> __be32 saddr<span class="token punctuation">,</span> __be16 sport<span class="token punctuation">,</span>        <span class="token keyword">const</span> __be32 daddr<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">short</span> hnum<span class="token punctuation">,</span>        <span class="token keyword">const</span> <span class="token keyword">int</span> dif<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//所有 listen socket 都在这个 listening_hash 中</span> <span class="token keyword">struct</span> inet_listen_hashbucket <span class="token operator">*</span>ilb <span class="token operator">=</span> <span class="token operator">&amp;</span>hashinfo<span class="token operator">-></span>listening_hash<span class="token punctuation">[</span>hash<span class="token punctuation">]</span><span class="token punctuation">;</span>begin<span class="token punctuation">:</span> result <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> hiscore <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token function">sk_nulls_for_each_rcu</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> node<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ilb<span class="token operator">-></span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>  score <span class="token operator">=</span> <span class="token function">compute_score</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> net<span class="token punctuation">,</span> hnum<span class="token punctuation">,</span> daddr<span class="token punctuation">,</span> dif<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>score <span class="token operator">></span> hiscore<span class="token punctuation">)</span> <span class="token punctuation">{</span>   result <span class="token operator">=</span> sk<span class="token punctuation">;</span>   hiscore <span class="token operator">=</span> score<span class="token punctuation">;</span>   reuseport <span class="token operator">=</span> sk<span class="token operator">-></span>sk_reuseport<span class="token punctuation">;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>reuseport<span class="token punctuation">)</span> <span class="token punctuation">{</span>    phash <span class="token operator">=</span> <span class="token function">inet_ehashfn</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> daddr<span class="token punctuation">,</span> hnum<span class="token punctuation">,</span>           saddr<span class="token punctuation">,</span> sport<span class="token punctuation">)</span><span class="token punctuation">;</span>    matches <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>score <span class="token operator">==</span> hiscore <span class="token operator">&amp;&amp;</span> reuseport<span class="token punctuation">)</span> <span class="token punctuation">{</span>   matches<span class="token operator">++</span><span class="token punctuation">;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>u64<span class="token punctuation">)</span>phash <span class="token operator">*</span> matches<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">32</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    result <span class="token operator">=</span> sk<span class="token punctuation">;</span>   phash <span class="token operator">=</span> <span class="token function">next_pseudo_random32</span><span class="token punctuation">(</span>phash<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 sk_nulls_for_each_rcu 是在遍历所有 hash 值相同的 listen 状态的 socket。注意看 compute_score 这个函数，这里是计算匹配分。当有多个 socket 都命中的时候，匹配分高的优先命中。我们来看一下这个函数里的一个细节。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: net/ipv4/inet_hashtables.c</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">compute_score</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">int</span> score <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">struct</span> inet_sock <span class="token operator">*</span>inet <span class="token operator">=</span> <span class="token function">inet_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">net_eq</span><span class="token punctuation">(</span><span class="token function">sock_net</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> net<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> inet<span class="token operator">-></span>inet_num <span class="token operator">==</span> hnum <span class="token operator">&amp;&amp;</span>   <span class="token operator">!</span><span class="token function">ipv6_only_sock</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//如果服务绑定的是 0.0.0.0，那么 rcv_saddr 为假</span>  __be32 rcv_saddr <span class="token operator">=</span> inet<span class="token operator">-></span>inet_rcv_saddr<span class="token punctuation">;</span>  score <span class="token operator">=</span> sk<span class="token operator">-></span>sk_family <span class="token operator">==</span> PF_INET <span class="token operator">?</span> <span class="token number">2</span> <span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>rcv_saddr<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>rcv_saddr <span class="token operator">!=</span> daddr<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>   score <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">}</span> <span class="token keyword">return</span> score<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么匹配分解决的是什么问题呢？为了描述的更清楚，我们假设某台服务器有两个 ip 地址，分别是 10.0.0.2 和 10.0.0.3。我们启动了如下三个服务器进程。</p><pre><code>A 进程：./test-server 10.0.0.2 6000B 进程：./test-server 0.0.0.0 6000C 进程：./test-server 127.0.0.1 6000</code></pre><p>那么你的客户端如果指定是连接 10.0.0.2:6000，那么 A 进程会优先执行。因为当匹配到 A 进程的 socket 的时候，需要看一下握手包中的目的 ip 和这个地址是否匹配，确实匹配那得分就是 4 分，最高分。</p><p>如果你指定连接的是 10.0.0.3，那么 A 进程就无法被匹配到。这个时候 B 进程监听时指定的是 0.0.0.0（rcv_saddr 为 false），则不需要进行目的地址的比对，得分为 2。由于没有更高分，所以这次命中的是 B 进程。</p><p>C 进程只有你在本机访问，且指定 ip 使用 127.0.0.1 才能命中，得分也是为 4 分。外部服务器或者是在本机使用其它 ip 都无法访问的到。</p><p>如果当多个 socket 的匹配分一致，通过调用 next_pseudo_random32 进行随机的选择。<strong>在内核态做了负载均衡的事情，选定一个具体的 socket，避免了多个进程在同一个 socket 上的锁竞争。</strong></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在 Linux 3.9 以前的版本中，一个端口只能被一个 socket 绑定。在多进程的场景下，无论是使用一个进程来在这个 socket 上 accept，还是说用多个 worker 来 accept 同一个 socket，在高并发的场景下性能都显得有那么一些低下。</p><p>在 2013 年发布的 3.9 中添加了 reuseport 的特性。该特定允许多个进程分别用不同的 socket 绑定到同一个端口。当有流量到达的时候，在内核态以随机的方式进行负载均衡。避免了锁的开销。</p><p>如果使用的是nginx，只需要一行简单的配置就可以体验这个特性。</p><pre class="line-numbers language-cpp"><code class="language-cpp">server <span class="token punctuation">{</span>  listen <span class="token number">80</span> reuseport<span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;如果服务器上已经有个进程在 listen 6000 这个端口号了。那么该服务器上其它进程是否还能 bind 和 listen 该端口呢？相信
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>std::enable_shared_from_this():诞生和作用</title>
    <link href="https://joytsing.github.io/posts/5981/"/>
    <id>https://joytsing.github.io/posts/5981/</id>
    <published>2024-05-11T07:35:50.000Z</published>
    <updated>2024-05-14T13:55:27.126Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>std::shared_from_this()</code>是 C++11 标准引入的功能，但之前一直都没用到过，直到在boost中使用asio需要异步保存回调函数时为了保存io_context，防止提前析构才了解到这个。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>简单地说就是帮助你怎么在class内部拿到this的shared_ptr版本。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">></span> <span class="token function">local_sp_a</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// do something with local_sp_a</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  A<span class="token operator">*</span> a<span class="token punctuation">;</span>  std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">></span> <span class="token function">sp_a</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  a<span class="token operator">-</span><span class="token operator">></span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// sp_a becomes dangling.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上述方式拿的话，表面上看起来你是拿到了一个this的shared_ptr版本，但是由于<strong>计数器和被管理的对象是分离</strong>的，因此相当于2个计数器（reference count都=1），同时只有一个被管理的对象。函数内部的那个计数器，在函数调用完成之后，认为reference count变成0了，于是释放掉了对应的object。main里构造的计数器当然不知道对应的object已经被释放了，于是就会二重释放宕掉,换句话说：<strong>智能共享指针不能够直接从this对象进行构造。</strong></p><p>C++解决方案是通过继承一个类（该方法是侵入式的，也可以手动保证只有构造第一个指向被持有对象的shared_ptr实例是由原始指针构造的），这个类本质上会给被管理的object上加一个指向计数器的weak ptr，于是就可以正确地增加引用计数而不是搞出2个独立的计数器。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="/posts/5981/v2-e9eefb114e3e371ac246ee8d9714b681_720w.webp" alt></p><p>该类是一个类模版，通过模版参数TP将被持有对象的类型传递进来，然后在类的内部构件一个weak_ptr<T>类型的成员变量。该成员变量用来保存指向自身的指针以及控制块相关信息，外部使用的时候如前一章节示例代码一样，为方便讨论代码重复贴出代码如下，采用继承的方式来扩展派生类的功能。</T></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token operator">:</span> <span class="token keyword">public</span> std<span class="token operator">::</span>enable_shared_from_this<span class="token operator">&lt;</span>Test<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面这种继承自一个类模版，将自身类型以模版参数的形式传入派生类的方式有一个专有名词对应，那就是CRTP，英文全称curious recurring template pattern，中文译名是奇异递归模版模式。可以通过该模式将派生类的类型信息通过模版参数的方式传入enable_shared_from_this类模版中，在enable_shared_from_this类模版中，将用该类型信息声明内部的用于管理派生类对象的成员变量__weak_this，并且声明相关成员方法，从而扩展派生类的功能。</p><p>该类的方法可以通过调用基类提供的成员函数shared_from_this来获取一个指向自身的shared_ptr对象，通过weak_from_this方法来获取一个指向自身的weak_ptr对象，其中weak_ptr对象也是指向被管理对象的智能指针，只不过该智能指针是<a href="https://www.zhihu.com/search?q=弱引用&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={" sourcetype"%3a"answer"%2c"sourceid"%3a3079826725}">弱引用</a>关系，不管理“被持有”对象的声明周期（这里被持有是带有引号的，用来表示区别于shared_ptr，这里是弱引用，不具有被管理对象的所有权），只提供访问对象数据的功能，但是和裸指针(raw pointer)功能类似，但是可以通过该指针的成员方法expire来判断被指向对象是否还有效（是否已经被销毁）。</p><p>核心逻辑在shared_from_this函数内部,该函数的内部逻辑不复杂，仅仅是通过成员变量__weak_this_来构建一个shared_ptr对象，然后将该对象返回:</p><pre class="line-numbers language-cpp"><code class="language-cpp">shared_ptr<span class="token operator">&lt;</span>_Tp<span class="token operator">></span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> shared_ptr<span class="token operator">&lt;</span>_Tp<span class="token operator">></span><span class="token punctuation">(</span>__weak_this_<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="enable-shared-from-this在异步求值中的应用"><a href="#enable-shared-from-this在异步求值中的应用" class="headerlink" title="enable_shared_from_this在异步求值中的应用"></a>enable_shared_from_this在异步求值中的应用</h2><p>enable_shared_from_this真实的应用场景是什么？如果只是需要正常让shared_ptr计数的话完全有其他更简单的方法（工厂方法），之前提到的应用场景大部分是在类的外部，可以通过对已有的shared_ptr进行复制，来共享所有权。在类的内部如果想安全的实现所有权的共享，并且和外部的shared_ptr来共同的管理对象，这个时候就需要使用enable_shared_from_this模版类了。</p><p>看一下下面的例子，定义了一个Process类，该类通过SetContext设置了一些上下文信息，然后保存在类的内部，然后在内部通过lambda函数捕捉自身this指针，并且封装一个求值的操作，然后将该lambda函数交给一个线程池来进行异步的执行：</p><p><img src="/posts/5981/v2-60007984ac84fd2552268f4c2742c317_720w.webp" alt></p><p>在异步执行的时候，调用它</p><p><img src="/posts/5981/v2-2d99285ca4ade1f1fd5ba7bd1a224157_720w.webp" alt></p><p>运行上述代码，会发现运行异常，异常结果如下图所示</p><p><img src="/posts/5981/v2-70077f07c846bf45cf47b0c3a0f31060_720w.webp" alt></p><p>之所以会产生异常，是因为当异步调用开始执行的时候，Process对象实例_process已经被释放了，此时加入线程池的lambda函数对象内捕捉的this指针指向的对象已经被释放了，此时异步执行的时候，会导致未定义行为。</p><p><img src="/posts/5981/v2-2e956c602a3784b3ac47da321b308467_720w.webp" alt="解决"></p><p>如上图中间红框部分，在进行异步调用函数封装的时候，不直接去捕捉this指针，而通过shared_from_this函数来构造一个shared_ptr对象，来捕捉这个shared_ptr对象，从而达到异步调用中使用的shared_ptr对象和外部的（通过Create创建以及后续从已有shared_ptr对象拷贝复制的）shared_ptr对象共享所有权，共同管理被指向对象的生命周期。从而避免异步执行时，捕捉的对象被释放的问题。</p><h2 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h2><p>像下面这样的写法是不正确的，</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyCar</span><span class="token operator">:</span><span class="token keyword">public</span> std<span class="token operator">::</span>enable_shared_from_this<span class="token operator">&lt;</span>MyCar<span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  shared_ptr<span class="token operator">&lt;</span>MyCar<span class="token operator">></span> <span class="token function">get_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token operator">~</span><span class="token function">MyCar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"free ~Mycar()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  MyCar<span class="token operator">*</span> _myCar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">MyCar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  shared_ptr<span class="token operator">&lt;</span>MyCar<span class="token operator">></span> _myCar1 <span class="token operator">=</span> _myCar<span class="token operator">-</span><span class="token operator">></span><span class="token function">get_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  shared_ptr<span class="token operator">&lt;</span>MyCar<span class="token operator">></span> _myCar2 <span class="token operator">=</span> _myCar<span class="token operator">-</span><span class="token operator">></span><span class="token function">get_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> _myCar1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> _myCar2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>区别在于在调用时候没有对智能指针进行构造，而是想通过get直接得到（符合直觉），但是这样的写法是会报错的：</p><p><img src="/posts/5981/13a914c223ade96d1a1dbdc2b97c3528.png" alt="报错内容"></p><p>如上图所示，异常位置是在弱指针处，弱指针实际上是智能共享指针的伴随指针，它主要负责监控智能指针的声明周期，弱指针本身的构造和析构都不会对引用计数进行修改，纯粹是作为一个助手监视shared_ptr管理的资源是否存在。因此弱指针的初始化是通过智能指针的构造函数来实现的，在上面的代码中对智能指针初始化时并没有使用构造函数的方式，因为弱指针是没有正常进行初始化的，所以抛出了异常。</p><p>这也是为什么推荐和工程模式一起使用，避免了这种问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;code&gt;std::shared_from_this()&lt;/code&gt;是 C++11 标准引入的功能，但之前一直都没用到过，直到在boos
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>MySQL技术内幕-InnoDB存储引擎(四)</title>
    <link href="https://joytsing.github.io/posts/8527/"/>
    <id>https://joytsing.github.io/posts/8527/</id>
    <published>2024-05-10T13:10:38.000Z</published>
    <updated>2024-05-14T13:55:40.344Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>事务是保证数据库不会出错的重要机制。</p><h2 id="一-事务"><a href="#一-事务" class="headerlink" title="一.事务"></a>一.事务</h2><p>数据库系统引入事务的目的：</p><p><strong>事务会把数据库从一种一致状态转换为另一种一致状态。</strong>在数据库提交工作的时候，可以确保要么所有修改已经保存了，要么所有修改都不保存。InnoDB存储引擎中的事务符合ACID特性：</p><ul><li>原子性：事务是不可分割的工作单位。</li><li>一致性：事务会把数据库从一种一致状态转换为另一种一致状态。</li><li>隔离性：要求每个读写事务的对象和其他事务的操作对象能够相互分离，事务提交之前对其他事务不可见。</li><li>持久性：事务一旦提交，其结果就是永久性的。</li></ul><p><strong>事务的分类：</strong></p><ul><li>扁平事务：</li></ul><blockquote><p>最简单也是使用最频繁的一种，所有操作都处于同一个层次。<br>由Begin Work开始，Commit Work或者Rollback Work结束，其间的操作都是原子性的，要么都执行要么都回滚。</p></blockquote><ul><li>带有保存点的扁平事务：允许事务执行过程中回滚到同一个事务中较早的一个状态。</li></ul><blockquote><p>意思是，一个事务的执行过程中出现的错误<strong>并不会导致所有的操作都无效，放弃整个事务并不符合要求，开销太大。</strong></p><p>那么就用保存点（Savepoint）来通知系统应该记住事务当前的状态，以便之后发生错误时，事务可以回到保存点当时的状态。</p></blockquote><ul><li>链事务：保存点模式的一种变种。</li></ul><blockquote><p>提交一个事务的时候，释放不需要的数据对象，将必要的处理上下文隐式地传给下一个要开始的事务。</p></blockquote><ul><li>嵌套事务：是一个层次结构框架。</li></ul><blockquote><p><strong>由一个顶层事务控制着各个层次的事务</strong>，顶层事务之下嵌套的事务被称为子事务，其控制每一个局部的变换。</p></blockquote><ul><li>分布式事务：通常是在一个分布式环境下运行的扁平事务。</li></ul><blockquote><p>要保证分布式事务正常运行比较复杂，这个就是另一个专题了</p></blockquote><p><strong>事务的实现：</strong></p><ol><li><strong>事务的原子性是通过undo log来实现</strong>，也就是所谓的回滚操作。 undo log记录了数据被修改之前的信息以及新增、删除的信息。undo log就是通过生成操作相反的sql语句来实现。</li><li>事务的持久性：<br>1.redolog在提交commit前会写一次数据，顺序存储。<br>2.InnoDB的二次写以及自带的buffer pool。</li><li><strong>事务的隔离性则通过4种隔离级别来实现。</strong></li><li>事务的一致性：其实现依赖于以上3个特性的实现、即回滚、恢复、隔离机制。</li></ol><h3 id="1-1-purge"><a href="#1-1-purge" class="headerlink" title="1.1 purge"></a>1.1 purge</h3><p>purge用于最终完成delete和update操作。因为InnoDB存储引擎支持MVCC，所以记录不能再事务提交的时候立即进行处理，因为这个时候其他的事务肯呢个正在读取这一行数据，因此需要InnoDB保存记录之前的版本。<strong>而是否删除该记录则是通过purge来进行判断。</strong></p><p>为了节省存储空间，InnoDB存储引擎的undo log的设计为：</p><ol><li>一个页上允许多个事务的undo log存在，后面的事务产生的undo log总是在最后。</li><li>用一个history列表，根据事务提交的顺序，将undo log进行链接。</li><li>purge的时候，<strong>先从history list中寻找undo log，然后再从undo page中找undo log。</strong></li></ol><p>当InnoDB存储引擎压力非常大的时候，并不能高效的进行purge操作，那么history list的长度会变的越来越长，因此可以使用全局动态参数<code>innodb_max_purge_lag</code>来控制history list的长度，如果长度大于该参数的时候，会延缓DML的操作。其算法为：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># delay单位是毫秒，并且其作用对象是一行数据，而不是一个DML操作。</span><span class="token comment" spellcheck="true"># 例如，一个update操作需要更新5行数据，那么每行数据的操作都会被delay，因此总的延长时间为5*delay</span>delay<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">(</span>length<span class="token punctuation">(</span>history list<span class="token punctuation">)</span><span class="token operator">-</span>innodb_max_purge_lag<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">5</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="1-2-group-commit"><a href="#1-2-group-commit" class="headerlink" title="1.2 group commit"></a>1.2 group commit</h3><p>为了提高磁盘的fsync（持久化到日志）效率，当前数据库都提供了group commit的功能，<strong>即一次fsync可以刷新确保多个多个事务日志被写入文件。</strong> 对于InnoDB存储引擎来说，事务提交的时候会进行两个阶段的操作：</p><ol><li><strong>修改内存中事务对应的信息，并且将日志写入重做日志缓冲中。</strong></li><li><strong>调用fsync确保日志都从重做日志缓冲中写入到磁盘。</strong></li></ol><p>步骤2是一个较慢的过程（因为需要存储引擎需要和磁盘打交道），因此如果通过group commit使用一次fsync刷新到磁盘，可以大大减少了磁盘的压力。Mysql在5.6之后，采用了BLGC的实现方式（Binary Log Group Commit），将事务提交的过程分为几个步骤来完成：</p><p><img src="/posts/8527/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pvbmdfMDkxNQ==,size_16,color_FFFFFF,t_70.png" alt></p><p>在Mysql数据库上层进行提交时首先按顺序将其放入一个队列中，<strong>队列中的第一个事务称为leader，其他事务叫follower，leader控制着follower的行为</strong>。BLGL的步骤分为三个阶段：</p><ol><li>Flush阶段：将每个事务的二进制日志写入文件中。</li><li>Sync阶段：将内存中的二进制日志刷新到磁盘，若队列有多个事务，那么仅一次fsync操作就可以完成二进制日志的写入，这就是BLGC。</li><li>Commit阶段：leader根据顺序调用存储引擎层事务的提交。</li></ol><h3 id="1-3-事务控制语句"><a href="#1-3-事务控制语句" class="headerlink" title="1.3 事务控制语句"></a>1.3 事务控制语句</h3><p>Mysql默认配置下，事务都是自动提交的（auto commit），即执行SQL语句后会马上执行commit操作。接下来看一看还有哪些有关事务的控制语句：</p><ul><li>Start | Begin Transaction：显式地开启一个事务。</li><li>Commit：提交事务，并使得已对数据库做的所有修改成为永久性的。</li><li>Rollback：回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。</li><li>Savepoint identifier：Savepoint允许在事务中创建一个保存点，一个事务中可以有多个Savepoint。</li><li>Release Savepoint identifier：删除一个事务的保存点。</li><li>Rollback To [Savepoint] identifier：可以把事务回滚到保存点。</li><li>Set Transaction：设置事务的隔离级别。</li></ul><p>注意：<strong>回滚至保存点的时候，事务并不会真正的回滚，即没有结束，需要运行Rollback后，事务才会完整的回滚。</strong></p><p>接下来再讲一下一些会隐式提交事务的SQL语句：</p><ul><li>DDL语句。</li></ul><blockquote><p>Alter Database | Event | Procedure | Table | View等<br>Create Database | Event | Index | Trigger | View | Table等<br>Drop Database | Event | Index | Trigger | View | Table等</p></blockquote><ul><li>用来隐式地修改Mysql架构的语句。</li></ul><blockquote><p>Create | Drop | Rename User 、Grant、 Revoke、Set Password。</p></blockquote><ul><li>管理语句。</li></ul><blockquote><p>Analyze Table、Cache Index、Check Table、Load Index Into Cache等</p></blockquote><h3 id="1-4-事务隔离级别"><a href="#1-4-事务隔离级别" class="headerlink" title="1.4 事务隔离级别"></a>1.4 事务隔离级别</h3><p>事务的隔离级别有4个：</p><ul><li>READ UNCOMMITTED</li><li>READ COMMITTED</li><li>REPEATABLE READ</li><li>SERIALIZABLE</li></ul><p>注意的点：</p><ol><li>InnoDB存储引擎默认的隔离级别是REPEATABLE READ，<strong>并且在该隔离级别下，使用Next-Key Lock锁的算法，避免幻读的产生。</strong></li><li>隔离级别越低，<strong>事务请求的锁越少或者保持锁的时间越短。</strong></li><li><strong>SERIALIZABLE的事务隔离级别，InnoDB存储引擎会对每个Select语句后自动加上Lock In Share Mode。</strong></li><li>在READ COMMITTED的隔离级别下，<strong>除了唯一性的约束检查以及外键约束的检查需要gap lock，InnoDB存储引擎不会使用gap lock的锁算法。</strong></li></ol><p>查看当前会话的事务隔离级别：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> @<span class="token variable">@tx_isolation</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看全局的事务隔离级别：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> @<span class="token variable">@global.tx_isolation</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="二-备份与恢复"><a href="#二-备份与恢复" class="headerlink" title="二.备份与恢复"></a>二.备份与恢复</h2><p>1.根据<strong>备份的方法不同</strong>可以将备份划分为：</p><ul><li>Hot Backup（热备）：数据库<strong>运行时</strong>直接备份，<strong>对正在运行放的数据库操作没有任何的影响。</strong></li><li>Cold Backup（冷备）：<strong>在数据库停止的情况下备份，只需要复制相关的数据库物理文件即可。</strong></li><li>Warm Backup（温备）：运行时备份，但是会对当前数据库的操作有影响。</li></ul><p>2.按照<strong>备份后文件的内容</strong>可以将备份划分为：</p><ul><li>逻辑备份：指的是文件内容可读，一般是文本文件，内容为SQL语句或者实际表内数据。</li><li>裸文件备份：指的是复制数据库的物理文件，<strong>这种备份的恢复时间往往要短很多。</strong></li></ul><p>3.按照<strong>备份数据库的内容</strong>可以将备份划分为：</p><ul><li>完全备份：指的是对数据库进行一个完整的备份。</li><li>增量备份：指的是在上次完全备份的基础上，<strong>对于更改的数据进行备份。</strong></li><li>日志备份：主要是针对二进制日志的备份。</li></ul><h3 id="2-1-冷备和逻辑备份"><a href="#2-1-冷备和逻辑备份" class="headerlink" title="2.1 冷备和逻辑备份"></a>2.1 冷备和逻辑备份</h3><p>对于InnoDB存储引擎的冷备非常简单，只需要备份Mysql数据库中的<code>frm</code>文件、共享表空间文件、独立表空间文件（<code>*.ibd</code>）、重做日志文件。<br>冷备的优点：</p><ul><li>备份简单，只需要复制相关文件即可。</li><li>备份文件易于在不同操作系统，不同Mysql版本上进行恢复。</li><li>恢复操作容易，只需要把文件移动到相应的位置即可。</li><li>恢复速度快，不需要执行任何SQL语句，也不需要重建索引。</li></ul><p>冷备的缺点：</p><ul><li>InnoDB存储引擎<strong>冷备的文件通常比逻辑文件大很多</strong>，因为表空间中存放着很多其他的数据。</li></ul><p>逻辑备份：使用<strong>mysqldump</strong><br>例子：想要对test数据库做一个备份：</p><pre class="line-numbers language-sql"><code class="language-sql">mysqldump <span class="token operator">-</span>uroot <span class="token operator">-</span>p <span class="token comment" spellcheck="true">--single-transaction test > test_backup.sql     </span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>mysqldump的重要参数：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>--single-transaction</code></td><td>在备份开始前，先执行Start Transaction命令，以此来获得备份的一致性（该参数只对InnoDB有效）</td></tr><tr><td><code>--lock-tables(-l)</code></td><td>在备份中，<strong>依次</strong>锁住每个架构下的所有表。</td></tr><tr><td><code>--lock-all-tables(-x)</code></td><td>在备份过程中，对所有架构中的表上锁。</td></tr><tr><td><code>--add-drop-database</code></td><td>在Create Database之前线运行Drop Database。</td></tr><tr><td><code>--master-data [=value]</code></td><td>通过该参数产生的备份转存文件主要用来建立一个replication，该参数会自动忽略 –lock-tables选项。</td></tr><tr><td><code>--events(-E)</code></td><td>备份时间调度器</td></tr><tr><td><code>--rountines（-R）</code></td><td>备份存储过程和函数</td></tr><tr><td><code>--triggers</code></td><td>备份触发器</td></tr><tr><td><code>--hex-blob</code></td><td>将BitNary、VarBinary、Blog、Bit列类型备份为十六进制的格式。<strong>因为mysqldump导出的文件一般是文本文件</strong>，而如果导出的数据包含上述类型，在文本文件模式下可能有些字符不可见，加上这个参数，可以以十六进制的方式显示。</td></tr><tr><td><code>--where=&#39;[条件语句]&#39;</code></td><td>例如：mysqldump –where=‘b&gt;2’ test a &gt; a.sql意思是导出数据库test下表a中列b&gt;2的数据</td></tr></tbody></table><hr><p>上面讲了如何使用mysqldump进行备份，那么来看看具体数据库中如何操作：<br>直接使用该文件即可。</p><pre class="line-numbers language-sql"><code class="language-sql">mysql <span class="token operator">-</span>uroot <span class="token operator">-</span>p <span class="token operator">&lt;</span> test_backup<span class="token punctuation">.</span>sql<span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-2-热备"><a href="#2-2-热备" class="headerlink" title="2.2 热备"></a>2.2 热备</h3><p>这里讲一下<strong>ibbackup</strong>，不过不会讲具体的操作方式（百度都有）。</p><p>ibbackup是InnoDB存储引擎官方提供的热备工具，同时可以备份MyISAM存储引擎和InnoDB存储引擎表。那么对于InnoDB的备份工作原理如下：</p><ol><li>记录备份开始时，InnoDB存储引擎重做日志文件检查点的LSN。</li><li>复制共享表空间文件以及独立表空间文件。</li><li>记录复制完表空间文件后，InnoDB存储引擎重做日志文件检查点的LSN。</li><li>复制在备份时候产生的重做日志。</li></ol><p>其优点：</p><ul><li>在线备份，<strong>不阻塞任何的SQL语句。</strong></li><li>备份性能好，<strong>备份的实质是复制数据库文件和重做日志文件</strong>。</li><li>支持压缩备份。</li></ul><p>而ibbackup对InnoDB存储引擎的恢复步骤大概为2步：</p><ol><li>恢复表空间文件。</li><li>应用重做日志文件。</li></ol><h3 id="2-3-复制（主从架构）"><a href="#2-3-复制（主从架构）" class="headerlink" title="2.3 复制（主从架构）"></a>2.3 复制（主从架构）</h3><p>复制（replication）是Mysql数据库提供的一种高可用高性能的解决方案。其工作原理分为3个步骤：</p><ol><li>主服务器（master）<strong>把数据更改记录到二进制日志中。</strong></li><li>从服务器（slave）<strong>把master的二进制日志复制到自己的中继日志中</strong>。（relay log）</li><li><strong>slave重做中继日志中的内容，把更改应用到自己的数据库上</strong>，以达到数据的一致性。</li></ol><p>总的来说<strong>就是一个完全备份加上二进制日志备份的还原。</strong></p><p>注意：复制的流程不是完全实时的同步进行的，而是<strong>异步实时</strong>。其工作原理图如下：<br><img src="/posts/8527/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pvbmdfMDkxNQ==,size_16,color_FFFFFF,t_70-1715607367125-3.png" alt><br>从服务器有2个线程：</p><ul><li>IO线程：<strong>负责读取主服务器的二进制日志，并把它保存为自己的中继日志。</strong></li><li>SQL线程：<strong>负责执行中继日志。</strong></li></ul><p>用户可以通过<code>Show Slave Status</code>来查看当前复制的运行状态，变量表如下：<br><img src="/posts/8527/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pvbmdfMDkxNQ==,size_16,color_FFFFFF,t_70-1715607367125-4.png" alt><br>与之对应的，则可以使用<code>Show Master Status</code>来查看主服务器中二进制日志的状态。</p><hr><p><strong>复制</strong>除了可以用来作为备份，还可以有其他的功能，如下：</p><ul><li>数据分布。</li><li>读取的负载均衡。</li><li>数据库备份。</li><li>高可用性和故障转移。</li></ul><p>最后，还应该注意：<br>建议从服务器上启用<code>read-only</code>选项，<strong>这样能够保证从服务器上的数据仅仅与主服务器进行同步，避免其他线程修改数据。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;事务是保证数据库不会出错的重要机制。&lt;/p&gt;
&lt;h2 id=&quot;一-事务&quot;&gt;&lt;a href=&quot;#一-事务&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://JoyTsing.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="读书笔记" scheme="https://JoyTsing.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数据库" scheme="https://JoyTsing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>聊聊Linux缺页异常处理</title>
    <link href="https://joytsing.github.io/posts/29394/"/>
    <id>https://joytsing.github.io/posts/29394/</id>
    <published>2024-05-10T08:20:29.000Z</published>
    <updated>2024-05-19T12:46:59.476Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/posts/29394/640.webp" alt></p><p>无论是匿名映射还是文件映射，内核在处理 mmap 映射过程中貌似都是在进程的虚拟地址空间中和虚拟内存打交道，仅仅只是为 mmap 映射分配出一段虚拟内存而已，整个映射过程我们并没有看到物理内存的身影。那么大家所关心的物理内存到底是什么时候映射进来的呢 ？</p><h2 id="1-缺页中断产生的原因"><a href="#1-缺页中断产生的原因" class="headerlink" title="1. 缺页中断产生的原因"></a>1. 缺页中断产生的原因</h2><p>如下图所示，当 mmap 系统调用成功返回之后，内核只是为进程分配了一段 [vm_start , vm_end] 范围内的虚拟内存区域 vma ，由于还未与物理内存发生关联，所以此时进程页表中与 mmap 映射的虚拟内存相关的各级页目录和页表项还都是空的。</p><p><img src="/posts/29394/640-1716106999361-3.webp" alt></p><p>当 CPU 访问这段由 mmap 映射出来的虚拟内存区域 vma 中的任意虚拟地址时，MMU 在遍历进程页表的时候就会发现，该虚拟内存地址在进程顶级页目录 PGD（Page Global Directory）中对应的页目录项 pgd_t 是空的，该 pgd_t 并没有指向其下一级页目录 PUD（Page Upper Directory）。也就是说，此时进程页表中只有一张顶级页目录表 PGD，而上层页目录 PUD（Page Upper Directory），中间页目录 PMD（Page Middle Directory），一级页表（Page Table）内核都还没有创建。</p><p>由于现在被访问到的虚拟内存地址对应的  pgd_t 是空的，进程的四级页表体系还未建立，所以 MMU 会产生一个缺页中断，进程从用户态转入内核态来处理这个缺页异常。此时 CPU 会将发生缺页异常时，进程正在使用的相关寄存器中的值压入内核栈中。比如，引起进程缺页异常的虚拟内存地址会被存放在 CR2 寄存器中。同时 CPU 还会将缺页异常的错误码 error_code 压入内核栈中。其中error_code用于对出发的缺页异常的种类的权限进行坚定。</p><h2 id="2-内核处理缺页中断的入口-——-do-page-fault"><a href="#2-内核处理缺页中断的入口-——-do-page-fault" class="headerlink" title="2. 内核处理缺页中断的入口 —— do_page_fault"></a>2. 内核处理缺页中断的入口 —— do_page_fault</h2><p>缺页中断产生的根本原因是由于 CPU 访问的这段虚拟内存背后没有物理内存与之映射，表现的具体形式主要有三种：</p><ol><li>虚拟内存对应在进程页表体系中的相关各级页目录或者页表是空的，也就是说这段虚拟内存完全没有被映射过。</li><li>虚拟内存之前被映射过，其在进程页表的各级页目录以及页表中均有对应的页目录项和页表项，但是其对应的物理内存被内核 swap out 到磁盘上了。</li><li>虚拟内存虽然背后映射着物理内存，但是由于对物理内存的访问权限不够而导致的保护类型的缺页中断。比如，尝试去写一个只读的物理内存页。</li></ol><p>一切的起点都是从 CPU 访问虚拟内存开始的，回顾一下进程虚拟内存空间的布局：</p><p><img src="/posts/29394/640-1716107768857-6.webp" alt></p><p>在 64 位体系结构下，进程虚拟内存空间总体上分为两个部分，一部分是 128T 的用户空间，地址范围为：0x0000 0000 0000 0000 - 0x0000 7FFF FFFF FFFF 。但实际上，Linux 内核是用 TASK_SIZE_MAX 来定义用户空间的末尾的，<strong>也就是说 Linux 内核是使用 TASK_SIZE_MAX 来分割用户虚拟地址空间与内核虚拟地址空间的</strong>。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> TASK_SIZE_MAX  task_size_max()</span><span class="token macro property">#<span class="token directive keyword">define</span> task_size_max()  ((_AC(1,UL) &lt;&lt; __VIRTUAL_MASK_SHIFT) - PAGE_SIZE)</span><span class="token macro property">#<span class="token directive keyword">define</span> __VIRTUAL_MASK_SHIFT 47</span><span class="token macro property">#<span class="token directive keyword">define</span> PAGE_SHIFT  12</span><span class="token macro property">#<span class="token directive keyword">define</span> PAGE_SIZE  (_AC(1,UL) &lt;&lt; PAGE_SHIFT)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>进程用户空间实际可用的虚拟地址范围是：0x0000 0000 0000 0000 - 0x0000 7FFF FFFF F000</strong>。<strong>以内核空间实际可用的虚拟地址范围是：0xFFFF 8800 0000 0000 - 0xFFFF FFFF FFFF FFFF</strong>。</p><p>既然进程虚拟内存地址范围有用户空间与内核空间之分，那么当 CPU 访问虚拟内存地址时产生的缺页中断也要区分下是用户空间产生的缺页还是内核空间产生的缺页。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">fault_in_kernel_space</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> address<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*     * On 64-bit systems, the vsyscall page is at an address above     * TASK_SIZE_MAX, but is not considered part of the kernel     * address space.     */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">IS_ENABLED</span><span class="token punctuation">(</span>CONFIG_X86_64<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">is_vsyscall_vaddr</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 在进程虚拟内存空间中，TASK_SIZE_MAX 以上的虚拟地址均属于内核空间</span>    <span class="token keyword">return</span> address <span class="token operator">>=</span> TASK_SIZE_MAX<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>当引起缺页中断的虚拟内存地址 address 是在 TASK_SIZE_MAX 之上时，表示该缺页地址是属于内核空间的，内核的缺页处理程序 __do_page_fault 就要进入 do_kern_addr_fault 分支去处理内核空间的缺页中断。</li><li>当引起缺页中断的虚拟内存地址 address 是在 TASK_SIZE_MAX 之下时，表示该缺页地址是属于用户空间的，内核则进入 do_user_addr_fault 分支处理用户空间的缺页中断。</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> noinline <span class="token keyword">void</span><span class="token function">__do_page_fault</span><span class="token punctuation">(</span><span class="token keyword">struct</span> pt_regs <span class="token operator">*</span>regs<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> hw_error_code<span class="token punctuation">,</span>        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> address<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// mmap_sem 是进程虚拟内存空间 mm_struct 的读写锁</span>    <span class="token comment" spellcheck="true">// 内核这里将 mmap_sem 预取到 cacheline 中，并标记为独占状态（ MESI 协议中的 X 状态）</span>    <span class="token function">prefetchw</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>current<span class="token operator">-></span>mm<span class="token operator">-></span>mmap_sem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这里判断引起缺页异常的虚拟内存地址 address 是属于内核空间的还是用户空间的</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token function">fault_in_kernel_space</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 如果缺页异常发生在内核空间，则由 vmalloc_fault 进行处理</span>        <span class="token comment" spellcheck="true">// 这里使用 unlikely 的原因是，内核对内存的使用通常是高优先级的而且使用比较频繁，所以内核空间一般很少发生缺页异常。</span>        <span class="token function">do_kern_addr_fault</span><span class="token punctuation">(</span>regs<span class="token punctuation">,</span> hw_error_code<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token comment" spellcheck="true">// 缺页异常发生在用户态</span>        <span class="token function">do_user_addr_fault</span><span class="token punctuation">(</span>regs<span class="token punctuation">,</span> hw_error_code<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">NOKPROBE_SYMBOL</span><span class="token punctuation">(</span>__do_page_fault<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进程工作在内核空间，由于内核负责的是整个系统最为核心的任务，基本上系统中所有的资源都会向内核倾斜，物理内存资源也是一样。内核对内存的申请优先级是最高的，使用频率也是最频繁的。所以在为内核分配完虚拟内存之后，都会立即分配物理内存，而且是申请多少给多少，最大程度上优先保证内核的工作稳定进行。因此通常在内核中，缺页中断一般很少发生。</p><p>而在用户空间，进程在使用 mmap 申请内存的时候，内核仅仅只是为进程在文件映射与匿名映射区分配一段虚拟内存，重要的物理内存资源不会马上分配，而是延迟到进程真正使用的时候，才会通过缺页中断 __do_page_fault 进入到 do_user_addr_fault 分支进行物理内存资源的分配。</p><h2 id="3-内核态缺页异常处理-——-do-kern-addr-fault"><a href="#3-内核态缺页异常处理-——-do-kern-addr-fault" class="headerlink" title="3. 内核态缺页异常处理 —— do_kern_addr_fault"></a>3. 内核态缺页异常处理 —— do_kern_addr_fault</h2><p>内核空间中的缺页异常主要发生在进程内核虚拟地址空间中 32T 的 vmalloc 映射区，这段区域的虚拟内存地址范围为：0xFFFF C900 0000 0000 - 0xFFFF E900 0000 0000。内核中的 vmalloc 内存分配接口就工作在这个区域，它用于将那些不连续的物理内存映射到连续的虚拟内存上。</p><p>do_kern_addr_fault 函数的工作主要就是处理内核虚拟内存空间中 vmalloc 映射区里的缺页异常，</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span><span class="token function">do_kern_addr_fault</span><span class="token punctuation">(</span><span class="token keyword">struct</span> pt_regs <span class="token operator">*</span>regs<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> hw_error_code<span class="token punctuation">,</span>           <span class="token keyword">unsigned</span> <span class="token keyword">long</span> address<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 该缺页的内核地址 address 在内核页表中对应的 pte 不能使用保留位(X86_PF_RSVD = 0)</span>    <span class="token comment" spellcheck="true">// 不能是用户态的缺页中断(X86_PF_USER = 0)</span>    <span class="token comment" spellcheck="true">// 且不能是保护类型的缺页中断 (X86_PF_PROT = 0)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>hw_error_code <span class="token operator">&amp;</span> <span class="token punctuation">(</span>X86_PF_RSVD <span class="token operator">|</span> X86_PF_USER <span class="token operator">|</span> X86_PF_PROT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 处理 vmalloc 映射区里的缺页异常</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">vmalloc_fault</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之前提到在内核空间申请虚拟内存的时候，都会马上分配物理内存资源，而且申请多少给多少。既然物理内存会马上被分配，那为什么内核空间中的 vmalloc 映射区还会发生缺页中断呢 ？</p><p>事实上，内核空间里 vmalloc 映射区中发生的缺页中断与用户空间里文件映射与匿名映射区以及堆中发生的缺页中断是不一样的。进程在用户空间中无论是通过 brk 系统调用在堆中申请内存还是通过 mmap 系统调用在文件与匿名映射区中申请内存，内核都只是在相应的虚拟内存空间中划分出一段虚拟内存来给进程使用。</p><p>当进程真正访问到这段虚拟内存地址的时候，才会产生缺页中断，近而才会分配物理内存，最后将引起本次缺页的虚拟地址在进程页表中对应的全局页目录项 pgd，上层页目录项 pud，中间页目录 pmd，页表项 pte 都创建好，然后在 pte 中将虚拟内存地址与物理内存地址映射起来。</p><p><img src="/posts/29394/640-1716108548456-9.webp" alt></p><p>而内核通过 vmalloc 内存分配接口在 vmalloc 映射区申请内存的时候，首先也会在 32T 大小的 vmalloc 映射区中划分出一段未被使用的虚拟内存区域出来，我们暂且叫这段虚拟内存区域为 vmalloc 区，与mmap其实比较相似，只不过 mmap 工作在用户空间的文件与匿名映射区，vmalloc 工作在内核空间的 vmalloc 映射区。</p><p>内核空间中的 vmalloc 映射区就是由这样一段一段的 vmalloc 区组成的，每调用一次 vmalloc 内存分配接口，就会在  vmalloc 映射区中映射出一段 vmalloc 虚拟内存区域，而且每个 vmalloc 区之间隔着一个 4K 大小的 guard page（虚拟内存），用于防止内存越界，将这些非连续的物理内存区域隔离起来。</p><p><img src="/posts/29394/640-1716108710387-12.webp" alt></p><p>和 mmap 不同的是，vmalloc 在分配完虚拟内存之后，会马上为这段虚拟内存分配物理内存，内核会首先计算出由 vmalloc 内存分配接口映射出的这一段虚拟内存区域 vmalloc 区中包含的虚拟内存页数，然后调用伙伴系统依次为这些虚拟内存页分配物理内存页。</p><h3 id="3-1-vmalloc"><a href="#3-1-vmalloc" class="headerlink" title="3.1 vmalloc"></a>3.1 vmalloc</h3><p>源码就不看了，直到同 mmap 用 vm_area_struct 结构来描述其在用户空间的文件与匿名映射区分配出来的虚拟内存区域一样，内核空间的 vmalloc 动态映射区也有一种数据结构来专门描述该区域中的虚拟内存区，这个结构就是 vm_struct。由于内核在分配完 vmalloc 虚拟内存区之后，会马上为其分配物理内存，所以在 vm_struct 结构中有一个 struct page 结构的数组指针 pages，用于指向该虚拟内存区域背后映射的物理内存页。nr_pages 则是数组的大小，也表示该虚拟内存区域包含的物理内存页个数。</p><p><img src="/posts/29394/640-1716108825185-15.webp" alt></p><p>在内核中所有的这些 vm_struct 均是被一个单链表串联组织的，在早期的内核版本中就是通过遍历这个单向链表来在 vmalloc 动态映射区中寻找空闲的虚拟内存区域的，后来为了提高查找效率引入了红黑树以及双向链表来重新组织这些 vmalloc 区域，于是专门引入了一个 vmap_area 结构来描述 vmalloc 区域的组织形式。</p><p><img src="/posts/29394/640-1716108899173-18.webp" alt></p><p>看起来和用户空间中虚拟内存区域的组织形式越来越像了，不同的是由于用户空间是进程间隔离的，所以组织用户空间虚拟内存区域的红黑树以及双向链表是进程独占的。而内核空间是所有进程共享的，所以组织内核空间虚拟内存区域的红黑树以及双向链表是全局的。</p><p>在了解了 vmalloc 动态映射区中的相关数据结构与组织形式之后，接下来我们看一看为 vmalloc 区分配物理内存的过程：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">__vmalloc_area_node</span><span class="token punctuation">(</span><span class="token keyword">struct</span> vm_struct <span class="token operator">*</span>area<span class="token punctuation">,</span> gfp_t gfp_mask<span class="token punctuation">,</span>                 pgprot_t prot<span class="token punctuation">,</span> <span class="token keyword">int</span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 指向即将为 vmalloc 区分配的物理内存页</span>    <span class="token keyword">struct</span> page <span class="token operator">*</span><span class="token operator">*</span>pages<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nr_pages<span class="token punctuation">,</span> array_size<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 计算 vmalloc 区所需要的虚拟内存页个数</span>    nr_pages <span class="token operator">=</span> <span class="token function">get_vm_area_size</span><span class="token punctuation">(</span>area<span class="token punctuation">)</span> <span class="token operator">>></span> PAGE_SHIFT<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// vm_struct 结构中的 pages 数组大小，用于存放指向每个物理内存页的指针</span>    array_size <span class="token operator">=</span> <span class="token punctuation">(</span>nr_pages <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> page <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 首先要为 pages 数组分配内存</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>array_size <span class="token operator">></span> PAGE_SIZE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// array_size 超过 PAGE_SIZE 大小则递归调用 vmalloc 分配数组所需内存</span>        pages <span class="token operator">=</span> <span class="token function">__vmalloc_node</span><span class="token punctuation">(</span>array_size<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> nested_gfp<span class="token operator">|</span>highmem_mask<span class="token punctuation">,</span>                PAGE_KERNEL<span class="token punctuation">,</span> node<span class="token punctuation">,</span> area<span class="token operator">-></span>caller<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 直接调用 kmalloc 分配数组所需内存</span>        pages <span class="token operator">=</span> <span class="token function">kmalloc_node</span><span class="token punctuation">(</span>array_size<span class="token punctuation">,</span> nested_gfp<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 初始化 vm_struct</span>    area<span class="token operator">-></span>pages <span class="token operator">=</span> pages<span class="token punctuation">;</span>    area<span class="token operator">-></span>nr_pages <span class="token operator">=</span> nr_pages<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 依次为 vmalloc 区中包含的所有虚拟内存页分配物理内存</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> area<span class="token operator">-></span>nr_pages<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">struct</span> page <span class="token operator">*</span>page<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> NUMA_NO_NODE<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 如果没有特殊指定 numa node，则从当前 numa node 中分配物理内存页</span>            page <span class="token operator">=</span> <span class="token function">alloc_page</span><span class="token punctuation">(</span>alloc_mask<span class="token operator">|</span>highmem_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token comment" spellcheck="true">// 否则就从指定的 numa node 中分配物理内存页</span>            page <span class="token operator">=</span> <span class="token function">alloc_pages_node</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> alloc_mask<span class="token operator">|</span>highmem_mask<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将分配的物理内存页依次存放到 vm_struct 结构中的 pages 数组中</span>        area<span class="token operator">-></span>pages<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> page<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">atomic_long_add</span><span class="token punctuation">(</span>area<span class="token operator">-></span>nr_pages<span class="token punctuation">,</span> <span class="token operator">&amp;</span>nr_vmalloc_pages<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 修改内核主页表，将刚刚分配出来的所有物理内存页与 vmalloc 虚拟内存区域进行映射</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">map_vm_area</span><span class="token punctuation">(</span>area<span class="token punctuation">,</span> prot<span class="token punctuation">,</span> pages<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">goto</span> fail<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 返回 vmalloc 虚拟内存区域起始地址</span>    <span class="token keyword">return</span> area<span class="token operator">-></span>addr<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在内核中，凡是有物理内存出现的地方，就一定伴随着页表的映射，vmalloc 也不例外，当分配完物理内存之后，就需要修改内核页表，然后将物理内存映射到 vmalloc 虚拟内存区域中，当然了，这个过程也伴随着 vmalloc 区域中的这些虚拟内存地址在内核页表中对应的 pgd，pud，pmd，pte 相关页目录项以及页表项的创建。</p><p><img src="/posts/29394/640-1716109001246-21.webp" alt></p><p>普通进程在内核态亦或是内核线程都是无法直接访问内核主页表的，它们只能访问内核主页表的 copy 副本，于是进程页表体系就分为了两个部分，一个是进程用户态页表（用户态缺页处理的就是这部分），另一个就是内核页表的 copy 部分（内核态缺页处理的是这部分）。</p><p>在 fork 系统调用创建进程的时候，进程的用户态页表拷贝自他的父进程，而进程的内核态页表则从内核主页表中拷贝，后续进程陷入内核态之后，访问的就是内核主页表中拷贝的这部分。</p><p>这也引出了一个新的问题，就是内核主页表与其在进程中的拷贝副本如何同步呢 ？ 这也是内核态缺页异常的处理。</p><h3 id="3-2-vmalloc-fault"><a href="#3-2-vmalloc-fault" class="headerlink" title="3.2 vmalloc_fault"></a>3.2 vmalloc_fault</h3><p>当内核通过 vmalloc 内存分配接口修改完内核主页表之后，主页表中的相关页目录项以及页表项的内容就发生了改变，而这背后的一切，进程现在还被蒙在鼓里，一无所知，此时，进程页表中的内核部分相关的页目录项以及页表项还都是空的。</p><p><img src="/posts/29394/640-1716109121624-24.webp" alt="图片"></p><p>当进程陷入内核态访问这部分页表的的时候，会发现相关页目录或者页表项是空的，就会进入缺页中断的内核处理部分，也就是 vmalloc_fault，如果发现缺页的虚拟地址在内核主页表顶级全局页目录表中对应的页目录项 pgd 存在，而缺页地址在进程页表内核部分对应的 pgd 不存在，那么内核就会把内核主页表中 pgd 页目录项里的内容复制给进程页表内核部分中对应的 pgd。</p><p><img src="/posts/29394/640-1716109296770-27.webp" alt></p><p>事实上，同步内核主页表的工作只需要将缺页地址对应在内核主页表中的顶级全局页目录项 pgd 同步到进程页表内核部分对应的 pgd 地址处就可以了，后面只要与该 pgd 相关的页目录表以及页表发生任何变化，由于是引用的关系，这些改变都会立刻自动反应到进程页表的内核部分中，后面就不需要同步了。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* * 64-bit: * *   Handle a fault on the vmalloc area */</span><span class="token keyword">static</span> noinline <span class="token keyword">int</span> <span class="token function">vmalloc_fault</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> address<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 分别是缺页虚拟地址 address 对应在内核主页表的全局页目录项 pgd_k ，以及进程页表中对应的全局页目录项 pgd</span>    pgd_t <span class="token operator">*</span>pgd<span class="token punctuation">,</span> <span class="token operator">*</span>pgd_k<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// p4d_t 用于五级页表体系，当前 cpu 架构体系下一般采用的是四级页表</span>    <span class="token comment" spellcheck="true">// 在四级页表下 p4d 是空的，pgd 的值会赋值给 p4d</span>    p4d_t <span class="token operator">*</span>p4d<span class="token punctuation">,</span> <span class="token operator">*</span>p4d_k<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 缺页虚拟地址 address 对应在进程页表中的上层目录项 pud</span>    pud_t <span class="token operator">*</span>pud<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 缺页虚拟地址 address 对应在进程页表中的中间目录项 pmd</span>    pmd_t <span class="token operator">*</span>pmd<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 缺页虚拟地址 address 对应在进程页表中的页表项 pte</span>    pte_t <span class="token operator">*</span>pte<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 确保缺页发生在内核 vmalloc 动态映射区</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>address <span class="token operator">>=</span> VMALLOC_START <span class="token operator">&amp;&amp;</span> address <span class="token operator">&lt;</span> VMALLOC_END<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取缺页虚拟地址 address 对应在进程页表的全局页目录项 pgd</span>    pgd <span class="token operator">=</span> <span class="token punctuation">(</span>pgd_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">__va</span><span class="token punctuation">(</span><span class="token function">read_cr3_pa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">pgd_index</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取缺页虚拟地址 address 对应在内核主页表的全局页目录项 pgd_k</span>    pgd_k <span class="token operator">=</span> <span class="token function">pgd_offset_k</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果内核主页表中的 pgd_k 本来就是空的，说明 address 是一个非法访问的地址，返回 -1 </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pgd_none</span><span class="token punctuation">(</span><span class="token operator">*</span>pgd_k<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果开启了五级页表，那么顶级页表就是 pgd，这里只需要同步顶级页表项就可以了</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pgtable_l5_enabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 内核主页表中的 pgd_k 不为空，进程页表中的 pgd 为空，那么就同步页表</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pgd_none</span><span class="token punctuation">(</span><span class="token operator">*</span> <span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 将主内核页表中的 pgd_k 内容复制给进程页表对应的 pgd</span>            <span class="token function">set_pgd</span><span class="token punctuation">(</span>pgd<span class="token punctuation">,</span> <span class="token operator">*</span>pgd_k<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 刷新 mmu</span>            <span class="token function">arch_flush_lazy_mmu_mode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">BUG_ON</span><span class="token punctuation">(</span><span class="token function">pgd_page_vaddr</span><span class="token punctuation">(</span><span class="token operator">*</span>pgd<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">pgd_page_vaddr</span><span class="token punctuation">(</span><span class="token operator">*</span>pgd_k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 四级页表体系下，p4d 是顶级页表项，同样也是只需要同步顶级页表项即可，同步逻辑和五级页表一模一样</span>    <span class="token comment" spellcheck="true">// 因为是四级页表，所以这里会将 pgd 赋值给 p4d，p4d_k ，后面就直接把 p4d 看做是顶级页表了。</span>    p4d <span class="token operator">=</span> <span class="token function">p4d_offset</span><span class="token punctuation">(</span>pgd<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>    p4d_k <span class="token operator">=</span> <span class="token function">p4d_offset</span><span class="token punctuation">(</span>pgd_k<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 内核主页表为空，则停止同步，返回 -1 ，表示正在访问一个非法地址</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">p4d_none</span><span class="token punctuation">(</span><span class="token operator">*</span>p4d_k<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 内核主页表不为空，进程页表为空，则同步内核顶级页表项 p4d_k 到进程页表对应的 p4d 中，然后刷新 mmu</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">p4d_none</span><span class="token punctuation">(</span><span class="token operator">*</span>p4d<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">pgtable_l5_enabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">set_p4d</span><span class="token punctuation">(</span>p4d<span class="token punctuation">,</span> <span class="token operator">*</span>p4d_k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">arch_flush_lazy_mmu_mode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">BUG_ON</span><span class="token punctuation">(</span><span class="token function">p4d_pfn</span><span class="token punctuation">(</span><span class="token operator">*</span>p4d<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">p4d_pfn</span><span class="token punctuation">(</span><span class="token operator">*</span>p4d_k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 到这里，页表的同步工作就完成了，下面代码用于检查内核地址 address 在进程页表内核部分中是否有物理内存进行映射</span>    <span class="token comment" spellcheck="true">// 如果没有，则返回 -1 ,说明进程在访问一个非法的内核地址，进程随后会被 kill 掉</span>    <span class="token comment" spellcheck="true">// 返回 0 表示表示地址 address 背后是有物理内存映射的， vmalloc 动态映射区的缺页处理到此结束。</span>    <span class="token comment" spellcheck="true">// 根据顶级页目录项 p4d 获取 address 在进程页表中对应的上层页目录项 pud</span>    pud <span class="token operator">=</span> <span class="token function">pud_offset</span><span class="token punctuation">(</span>p4d<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pud_none</span><span class="token punctuation">(</span><span class="token operator">*</span>pud<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 该 pud 指向的是 1G 大页内存</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pud_large</span><span class="token punctuation">(</span><span class="token operator">*</span>pud<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 根据 pud 获取 address 在进程页表中对应的中间页目录项 pmd</span>    pmd <span class="token operator">=</span> <span class="token function">pmd_offset</span><span class="token punctuation">(</span>pud<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pmd_none</span><span class="token punctuation">(</span><span class="token operator">*</span>pmd<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 该 pmd 指向的是 2M 大页内存</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pmd_large</span><span class="token punctuation">(</span><span class="token operator">*</span>pmd<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 根据 pmd 获取 address 对应的页表项 pte</span>    pte <span class="token operator">=</span> <span class="token function">pte_offset_kernel</span><span class="token punctuation">(</span>pmd<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 页表项 pte 并没有映射物理内存</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pte_present</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">NOKPROBE_SYMBOL</span><span class="token punctuation">(</span>vmalloc_fault<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>既然已经有了内核主页表，而且内核地址空间包括内核页表又是所有进程共享的，那进程为什么不能直接访问内核主页表而是要访问主页表的拷贝部分呢 ？ 这样还能省去拷贝内核主页表（fork 时候）以及同步内核主页表（缺页时候）这些个开销。</p><p>之所以这样设计一方面有硬件限制的原因，毕竟每个 CPU 核心只会有一个 CR3 寄存器来存放进程页表的顶级页目录起始物理内存地址，没办法同时存放进程页表和内核主页表。另一方面的原因则是操作页表都是需要对其进行加锁的，无论是操作进程页表还是内核主页表。而且在操作页表的过程中可能会涉及到物理内存的分配，这也会引起进程的阻塞。</p><p>而进程本身可能处于中断上下文以及竞态区中，不能加锁，也不能被阻塞，如果直接对内核主页表加锁的话，那么系统中的其他进程就只能阻塞等待了。所以只能而且必须是操作主内核页表的拷贝，不能直接操作内核主页表。</p><h2 id="4-用户态缺页异常处理-——-do-user-addr-fault"><a href="#4-用户态缺页异常处理-——-do-user-addr-fault" class="headerlink" title="4. 用户态缺页异常处理 —— do_user_addr_fault"></a>4. 用户态缺页异常处理 —— do_user_addr_fault</h2><p>在处理用户态缺页异常之前，内核需要在进程用户空间众多的虚拟内存区域 vma 之中找到引起缺页的内存地址 address 究竟是属于哪一个 vma 。如果没有一个 vma 能够包含 address ， 那么就说明该 address 是一个还未被分配的虚拟内存地址，进程对该地址的访问是非法的，自然也就不用处理缺页了。</p><p>所以内核就需要根据缺页地址 address 通过 find_vma 函数在进程地址空间中找出符合 <code>address &lt; vma-&gt;vm_end</code> 条件的第一个 vma 出来，也就是挨着 address 最近的一个 vma。而缺页地址 address 可以出现在进程地址空间中的任意位置，根据 address 的分布会有下面三种情况：</p><p>第一种情况就是 address 的后面没有一个 vma 出现，也就是说进程地址空间中没有一个 vma 符合条件：<code>address &lt; vma-&gt;vm_end</code>。进程访问的是一个还未分配的虚拟内存地址，属于非法地址访问，不需要处理缺页。</p><p><img src="/posts/29394/640-1716115139736-30.webp" alt></p><p>第二种情况就是 address 恰巧包含在一个 vma 中，这个自然是正常情况，内核开始处理该 vma 区域的缺页异常。</p><p><img src="/posts/29394/640-1716115139736-31.webp" alt></p><p>第三种情况是 address 不巧落在了 find_vma 的前面，也就是 <code>address &lt; find_vma-&gt;vm_start</code>。这种情况自然也是非法地址访问，不需要处理缺页。</p><p><img src="/posts/29394/640-1716115139736-32.webp" alt></p><p>在处理这个缺页的过程中函数会返回一个 unsigned int 类型的位图 vm_fault_t，通过这个位图可以简要描述一下在整个缺页异常处理的过程中究竟发生了哪些状况，方便内核对各种状况进行针对性处理。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * Page fault handlers return a bitmask of %VM_FAULT values. */</span><span class="token keyword">typedef</span> __bitwise <span class="token keyword">unsigned</span> <span class="token keyword">int</span> vm_fault_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>比如，位图 vm_fault_t 的第三个比特位置为 1 表示 VM_FAULT_MAJOR，置为 0 表示 VM_FAULT_MINOR。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">enum</span> vm_fault_reason <span class="token punctuation">{</span> VM_FAULT_MAJOR          <span class="token operator">=</span> <span class="token punctuation">(</span>__force vm_fault_t<span class="token punctuation">)</span><span class="token number">0x000004</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>VM_FAULT_MAJOR 的意思是本次缺页所需要的物理内存页还不在内存中，需要重新分配以及需要启动磁盘 IO，从磁盘中 swap in 进来。</li><li>VM_FAULT_MINOR 的意思是本次缺页所需要的物理内存页已经加载进内存中了，缺页处理只需要修改页表重新映射一下就可以了。</li></ul><p>来看一个具体的例子，多个进程调用 mmap 对磁盘上的同一个文件进行共享文件映射的时候，此时在各个进程的地址空间中都只是各自分配了一段虚拟内存用于共享文件映射而已，还没有分配物理内存页。</p><p>当第一个进程开始访问这段虚拟内存映射区时，由于没有物理内存页，页表还是空的，于是产生缺页中断，内核则会在伙伴系统中分配一个物理内存页，然后将新分配的内存页加入到 page cache 中。然后调用  readpage 激活块设备驱动从磁盘中读取映射的文件内容，用读取到的内容填充新分配的内存页，最后在进程 1 页表中建立共享映射的这段虚拟内存与 page cache 中缓存的文件页之间的关联。</p><p><img src="/posts/29394/640-1716116149984-39.webp" alt></p><p>由于进程 1 的缺页处理发生了物理内存的分配以及磁盘 IO ，所以本次缺页处理属于 VM_FAULT_MAJOR。</p><p>当进程 2 访问其地址空间中映射的这段虚拟内存时，由于页表是空的，也会发生缺页，但是当进程 2 进入内核中发现所映射的文件页已经被进程 1 加载进 page cache 中了，进程 2 的缺页处理只需要将这个文件页映射进自己的页表就可以了，不需要重新分配内存以及发生磁盘 IO 。这种情况就属于  VM_FAULT_MINOR。</p><h2 id="5-handle-mm-fault-完善进程页表体系"><a href="#5-handle-mm-fault-完善进程页表体系" class="headerlink" title="5. handle_mm_fault 完善进程页表体系"></a>5. handle_mm_fault 完善进程页表体系</h2><p>起缺页中断的原因大概有三种：</p><ul><li>第一种是 CPU 访问的虚拟内存地址 address 之前完全没有被映射过，其在页表中对应的各级页目录项以及页表项都还是空的。</li><li>第二种是 address 之前被映射过，但是映射的这块物理内存被内核 swap out 到磁盘上了。</li><li>第三种是 address 背后映射的物理内存还在，只是由于访问权限不够引起的缺页中断，比如，后面要为大家介绍的写时复制（COW）机制就属于这一种。</li></ul><p><img src="/posts/29394/640-1716116214802-42.webp" alt></p><p>由于现在正在被访问的虚拟内存地址 address 之前从来没有被映射过，所以该虚拟内存地址在进程页表中的各级页目录表中的目录项以及页表中的页表项都是空的。内核的首要任务就是先要将这些缺失的页目录项和页表项一一补齐。</p><p>48 位的虚拟内存地址内又分为五个部分，它们分别是虚拟内存地址在全局页目录表 PGD 中对应的页目录项 pgd_t 的偏移，在上层页目录表 PUD 中对应的页目录项 pud_t 的偏移，在中间页目录表 PMD 中对应的页目录项 pmd_t 的偏移，在页表中对应的页表项 pte_t 的偏移，以及在其背后映射的物理内存页中的偏移。</p><p><img src="/posts/29394/640-1716116296401-45.webp" alt></p><p>而各级页目录表以及页表在内核中其实本质上都是一个 4K 物理内存页，只不过这些物理内存页存放的内容比较特殊，它们存放的是页目录项和页表项。一张页目录表可以存放 512 个页目录项，一张页表可以存放 512 个页表项。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 全局页目录表 PGD 可以容纳的页目录项 pgd_t 的个数</span><span class="token macro property">#<span class="token directive keyword">define</span> PTRS_PER_PGD  512</span><span class="token comment" spellcheck="true">// 上层页目录表 PUD 可以容纳的页目录项 pud_t 的个数</span><span class="token macro property">#<span class="token directive keyword">define</span> PTRS_PER_PUD  512</span><span class="token comment" spellcheck="true">// 中间页目录表 PMD 可以容纳的页目录项 pmd_t 的个数</span><span class="token macro property">#<span class="token directive keyword">define</span> PTRS_PER_PMD  512</span><span class="token comment" spellcheck="true">// 页表可以容纳的页表项 pte_t 的个数</span><span class="token macro property">#<span class="token directive keyword">define</span> PTRS_PER_PTE  512</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此我们可以把全局页目录表 PGD 看做是一个能够存放 512 个 pgd_t 的数组 —— pgd_t[PTRS_PER_PGD]，虚拟内存地址对应在 pgd_t[PTRS_PER_PGD] 数组中的索引使用 9 个比特位就可以表示了。在内核中使用 pgd_offset 函数来定位虚拟内存地址在全局页目录表 PGD 中对应的页目录项 pgd_t，这个过程和访问数组一模一样，事实上整个 PGD  就是一个 pgd_t[PTRS_PER_PGD] 数组。</p><p>首先我们通过 mm_struct-&gt; pgd 获取 pgd_t[PTRS_PER_PGD] 数组的首地址（全局页目录表 PGD 的起始内存地址），然后将虚拟内存地址右移 PGDIR_SHIFT（39）位再用掩码 <code>PTRS_PER_PGD - 1</code> 将高位全部掩去，只保留低 9 位得到虚拟内存地址在 pgd_t[PTRS_PER_PGD] 数组中的索引偏移 pgd_index。然后将 mm_struct-&gt; pgd 与 pgd_index 相加就可以定位到虚拟内存地址在全局页目录表 PGD 中的页目录项 pgd_t 了。现在我们已经通过 pgd_offset 定位到虚拟内存地址 address 对应在全局页目录 PGD 的页目录项 pgd_t（p4d_t）了。</p><p><img src="/posts/29394/640-1716116480861-48.webp" alt></p><p>接下来的任务就是根据这个 p4d_t 定位虚拟内存对应在上层页目录 PUD 中的页目录项 pud_t。但在定位之前，我们需要首先判断这个 p4d_t 是否是空的，如果是空的，说明在目前的进程页表中还不存在对应的 PUD，需要马上创建一个新的出来。如果我们通过 <strong>p4d_none</strong> 函数判断出顶级页目录项 p4d 是空的，那么就需要调用 <strong>__pud_alloc</strong> 函数分配一个新的上层页目录表 PUD 出来，然后用 PUD 的起始物理内存地址以及页目录项的初始权限位 _PAGE_TABLE 填充 p4d。</p><p><img src="/posts/29394/640-1716116520229-51.webp" alt="图片"></p><p>由于页目录项所承担的一项最重要的工作就是定位其下一级页目录表的起始物理内存地址，这里的下一级页目录表就是刚刚我们新创建出来的 PUD。所以第一件重要的事情就是通过 <code>__pa(pud)</code> 来获取 PUD 的起始物理内存地址，然后将 PUD 的物理内存地址填充到顶级页目录项 p4d 中的对应比特位上。</p><p>由于物理内存地址在内核中都是按照 4K 对齐的，所以 PUD 物理内存地址的低 12 位全部都是 0 ，我们可以利用这 12 个比特位存放一些权限标记位，页目录项在初始化时需要置为 1 的权限标记位定义在 _PAGE_TABLE 中。也就是说 _PAGE_TABLE 定义了页目录项初始权限标记位集合。</p><p>我们通过 _PAGE_TABLE 和 __pa(pud) 进行或运算 —— <code>_PAGE_TABLE | __pa(pud)</code>，这样就可以按照上图中的比特位布局构造出一个 8 字节的 <code>unsigned long</code> 类型的整数了，这个整数的第 12 到 35 比特位通过 __pa(pud) 填充进来，低 12 位比特通过 _PAGE_TABLE 填充进来。最后我们通过 set_p4d 将我们刚刚构造出来的 p4d_t 赋值给原始的 p4d_t。</p><p>这样一来，缺页的虚拟内存地址对应在顶级页目录表中的页目录项 p4d_t 就被填充好了，现在它已经指向了刚刚新创建出来的 PUD，并且拥有了初始的权限位。目前为止，我们只是完善了缺页虚拟内存地址对应在进程页表顶级页目录中的目录项 p4d_t，在四级页表体系下，我们还需要继续向下逐级的去补齐虚拟内存地址对应在其他页目录中的目录项，处理逻辑上都是一模一样的。</p><p>顶级页目录项 p4d 中包含了其下一级页目录 PUD 的相关信息，在内核中使用 pud_offset 函数来定位虚拟内存地址 address 对应在 PUD 中的页目录项 pud_t。和顶级页目录 PGD 一样，上层页目录 PUD 也可以看做是一个能够存放 512 个 pud_t 的数组 ——  pud_t[PTRS_PER_PUD] 。</p><p>我们有了 pud_index，如果我们还能够知道上层页目录表 PUD 的虚拟内存地址，两者一相加就能得到页目录项 pud_t 了。而 PUD 的物理内存地址恰好保存在刚刚填充好的顶级页目录项 p4d 中，我们可以从 p4d 中将 PUD 的物理内存地址提取出来，然后通过 <code>__va</code> 转换成虚拟内存地址不就行了么。</p><p><img src="/posts/29394/640-1716117343357-54.webp" alt></p><p>后面也是类似的，在我们获取到 pmd_t 之后，接下来就该处理页表了，而页表是直接与物理内存页进行映射的，后续我们需要到页表项中，根据权限位的设置来解析出具体的缺页原因，然后进行针对性的缺页处理。</p><h2 id="6-handle-pte-fault"><a href="#6-handle-pte-fault" class="headerlink" title="6. handle_pte_fault"></a>6. handle_pte_fault</h2><h3 id="物理内存页不在内存"><a href="#物理内存页不在内存" class="headerlink" title="物理内存页不在内存"></a>物理内存页不在内存</h3><p>缺页异常主要的三种原因，要么缺页的虚拟内存地址从来还没有被映射过，要么是虽然之前映射过，但是物理内存页被 swap 到磁盘上了，要么是因为访问权限不够的原因引起的缺页。</p><p>从总体上来讲引起缺页中断的原因分为两大类，一类是缺页虚拟内存地址背后映射的物理内存页不在内存中，另一类是缺页虚拟内存地址背后映射的物理内存页在内存中，而每一类下边又包含若干种缺页的场景：</p><p>第一种场景是，缺页虚拟内存地址 address 在进程页表中间页目录对应的页目录项 pmd_t 是空的，我们可以通过 pmd_none 方法来判断。</p><p><img src="/posts/29394/640-1716117549741-57.webp" alt></p><p>这种情况表示缺页地址 address 对应的 pmd 目前还没有对应的页表，连页表都还没有，那么自然 pte 也是空的，物理内存页就更不用说了，肯定还没有。</p><p>第二种场景是，缺页地址 address 对应的 pmd_t 虽然不是空的，页表也存在，但是 address 对应在页表中的 pte 是空的。内核中通过 pte_offset_map 定位 address 在页表中的 pte 。这个过程和前面介绍的定位页目录项的过程一模一样。</p><p><img src="/posts/29394/640-1716117575393-60.webp" alt></p><p>这种情况下，虽然页表是存在的，但是奈何 address 在页表中的 pte 是空的，和第一种场景一样，都说明了该 address 之前从来还没有被映射过。既然之前都没有被映射，那么现在就该把这块内容补齐，对于mmap来说分别为：私有匿名映射，私有文件映射，共享文件映射，共享匿名映射。这四种内存映射方式从总体上来说分为两类：一类是匿名映射，另一类是文件映射。</p><p>所以在处理虚拟内存映射区 vma 中的缺页时，也需要分为匿名映射区的缺页处理以及文件映射区的缺页处理。那么在这里，我们该如何区分这个缺页的 vma 到底是属于匿名映射区还是文件映射区呢 ？</p><p>在mmap内存映射核心函数 mmap_region 中，在处理文件映射的代码中，内核调用了一个叫 call_mmap 的函数，内核在该函数中将虚拟内存的相关操作函数 vma-&gt;vm_ops 映射成了文件相关的操作函数 ext4_file_vm_ops。正因为如此，后续进程读写这块虚拟内存就相当于读写文件了。</p><p><img src="/posts/29394/640.webp" alt></p><p>而在处理匿名映射的代码中，内核调用了一个叫做 vma_set_anonymous 的函数，在这里会将 vma-&gt;vm_ops 设置为 null ，因为这里映射的匿名内存页，背后并没有文件来支撑。所以判断一个虚拟内存区域 vma 到底是文件映射区还是匿名映射区就是要看这个 vma 的 vm_ops 是否为 null。</p><ul><li>如果 vma_is_anonymous 返回 true，那么内核就会在 handle_pte_fault 函数中调用 do_anonymous_page 进行匿名映射区的缺页处理。</li><li>如果 vma_is_anonymous 返回 false，那么内核就调用 do_fault 进行文件映射区的缺页处理。</li></ul><p>第三种缺页场景是，虚拟内存地址 address 在进程页表中的页表项 pte 不是空的，但是其背后映射的物理内存页被内核 swap out 到磁盘上了，CPU 访问的时候依然会产生缺页。</p><p><img src="/posts/29394/640-1716117882574-65.webp" alt></p><p>那么我们如何知道 pte 背后映射的物理内存页在不在内存中呢 ？查看表头的比特位布局，其中 pte 的第 0 个比特位表示该 pte 映射的物理内存页是否在内存中，值为 1 表示物理内存页在内存中驻留，值为 0 表示物理内存页不在内存中，可能被 swap 到磁盘上了。如果我们通过 pte_present 判断映射的物理内存页不在内存中了，说明它已经被内核 swap out 到磁盘上了，这种情况下的缺页处理就需要调用 do_swap_page 函数，将磁盘上的物理内存页重新 swap in 到内存中来。</p><pre class="line-numbers language-c"><code class="language-c">   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pte_present</span><span class="token punctuation">(</span>vmf<span class="token operator">-></span>orig_pte<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 将之前映射的物理内存页从磁盘中重新 swap in 到内存中</span>        <span class="token keyword">return</span> <span class="token function">do_swap_page</span><span class="token punctuation">(</span>vmf<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>以上介绍的这三种缺页场景都是属于缺页内存地址 address 背后映射的物理内存页不在内存中的类别。</p><h3 id="物理内存页在内存中"><a href="#物理内存页在内存中" class="headerlink" title="物理内存页在内存中"></a>物理内存页在内存中</h3><p>下面我们来看下另一类别，也就是缺页虚拟内存地址背后映射的物理内存页在内存中的情况 ，这里又会近一步分为两种缺页场景。</p><p>在 NUMA 架构下，我们缺页处理的场景中就是缺页虚拟内存地址背后映射的物理内存页虽然在内存中，但是它可能是进程所在 CPU 中的本地 NUMA 节点上的内存，也可能是其他 NUMA 节点上的内存。因为 CPU 对不同 NUMA 节点上的内存有访问速度上的差异，所以内核通常倾向于让 CPU 尽量访问本地 NUMA 节点上的内存。NUMA Balancing 机制就是用来解决这个问题的。</p><p>通俗来讲，NUMA Balancing 主要干两件事情，一件事是让内存跟着 CPU 走，另一件事是让 CPU 跟着内存走。进程申请到的物理内存页可能在当前 CPU 的本地 NUMA 节点上，也可能在其他 NUMA 节点上。</p><ul><li>所谓让内存跟着 CPU 走的意思就是，当进程访问的物理内存页不在当前 CPU 的本地 NUMA 节点上时，NUMA Balancing 就会尝试将远程 NUMA 节点上的物理内存页迁移到本地 NUMA 节点上，加快进程访问内存的速度。</li><li>所谓让 CPU 跟着内存走的意思就是，当进程经常访问的大部分物理内存页均不在当前 CPU 的本地 NUMA 节点上时，NUMA Balancing 干脆就把进程重新调度到这些物理内存页所在的 NUMA 节点上。当然整个 NUMA Balancing 的过程会根据我们设置的 NUMA policy 以及各个 NUMA 节点上缺页的次数来综合考虑是否迁移内存页。</li></ul><p>说回来，这种情况下调用 pte_present 依然很返回 true ，因为当前的物理内存页毕竟是在内存中的，只不过不在当前 CPU 的本地 NUMA 节点上而已。当 pte 被标记为 _PAGE_PROTNONE 之后，这意味着该 pte 背后映射的物理内存页进程对其没有读写权限，也没有可执行的权限。进程在访问这段虚拟内存地址的时候就会发生缺页。</p><p>当进入缺页异常的处理程序之后，内核会在 handle_pte_fault 函数中通过 pte_protnone 函数判断，缺页的 pte 是否被标记了 _PAGE_PROTNONE 标识。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">pte_protnone</span><span class="token punctuation">(</span>pte_t pte<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">pte_flags</span><span class="token punctuation">(</span>pte<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>_PAGE_PROTNONE <span class="token operator">|</span> _PAGE_PRESENT<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token operator">==</span> _PAGE_PROTNONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当 pte 被标记为 _PAGE_PROTNONE 之后，这意味着该 pte 背后映射的物理内存页进程对其没有读写权限，也没有可执行的权限。进程在访问这段虚拟内存地址的时候就会发生缺页。如果 pte 被标记了 _PAGE_PROTNONE，并且对应的虚拟内存区域是一个具有读写，可执行权限的 vma。这就说明该 vma 背后映射的物理内存页不在当前 CPU 的本地 NUMA 节点上。这里需要调用 do_numa_page，将这个远程 NUMA 节点上的物理内存页迁移到当前 CPU 的本地 NUMA 节点上，从而加快进程访问内存的速度。</p><p>第二种场景就是写时复制了（Copy On Write， COW），这种场景和 NUMA Balancing 一样，都属于缺页虚拟内存地址背后映射的物理内存页在内存中而引起的缺页中断。</p><p>COW 在内核的内存管理子系统中很常见了，比如，父进程通过 fork 系统调用创建子进程之后，父子进程的虚拟内存空间完全是一模一样的，包括父子进程的页表内容都是一样的，父子进程页表中的 PTE 均指向同一物理内存页面，此时内核会将父子进程页表中的 PTE 均改为只读的，并将父子进程共同映射的这个物理页面引用计数 + 1。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token function">copy_one_pte</span><span class="token punctuation">(</span><span class="token keyword">struct</span> mm_struct <span class="token operator">*</span>dst_mm<span class="token punctuation">,</span> <span class="token keyword">struct</span> mm_struct <span class="token operator">*</span>src_mm<span class="token punctuation">,</span>        pte_t <span class="token operator">*</span>dst_pte<span class="token punctuation">,</span> pte_t <span class="token operator">*</span>src_pte<span class="token punctuation">,</span> <span class="token keyword">struct</span> vm_area_struct <span class="token operator">*</span>vma<span class="token punctuation">,</span>        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> addr<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>rss<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*     * If it's a COW mapping, write protect it both     * in the parent and the child     */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_cow_mapping</span><span class="token punctuation">(</span>vm_flags<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">pte_write</span><span class="token punctuation">(</span>pte<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 设置父进程的 pte 为只读</span>        <span class="token function">ptep_set_wrprotect</span><span class="token punctuation">(</span>src_mm<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> src_pte<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 设置子进程的 pte 为只读</span>        pte <span class="token operator">=</span> <span class="token function">pte_wrprotect</span><span class="token punctuation">(</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 获取 pte 中映射的物理内存页（此时父子进程共享该页）</span>    page <span class="token operator">=</span> <span class="token function">vm_normal_page</span><span class="token punctuation">(</span>vma<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> pte<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 物理内存页的引用计数 + 1</span>    <span class="token function">get_page</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当父进程或者子进程对该页面发生写操作的时候，我们现在假设子进程先对页面发生写操作，随后子进程发现自己页表中的 PTE 是只读的，于是产生缺页中断，子进程进入内核态，内核会在本小节介绍的缺页中断处理程序中发现，访问的这个物理页面引用计数大于 1，说明此时该物理内存页面存在多进程共享的情况，于是发生写时复制（Copy On Write， COW），内核为子进程重新分配一个新的物理页面，然后将原来物理页中的内容拷贝到新的页面中，最后子进程页表中的 PTE 指向新的物理页面并将 PTE 的 R/W 位设置为 1，原来物理页面的引用计数 - 1。</p><p>后面父进程在对页面进行写操作的时候，同样也会发现父进程的页表中 PTE 是只读的，也会产生缺页中断，但是在内核的缺页中断处理程序中，发现访问的这个物理页面引用计数为 1 了，那么就只需要将父进程页表中的 PTE 的 R/W 位设置为 1 就可以了。</p><p><strong>在以上介绍的两种写时复制应用场景中，他们都有一个共同的特点，就是进程的虚拟内存区域 vma 的权限是可写的，但是其对应在页表中的 pte 却是只读的，而 pte 映射的物理内存页也在内存中</strong>。内核正是利用这个特点来判断本次缺页中断是否是由写时复制引起的。如果是，则调用 do_wp_page 进行写时复制的缺页处理。</p><p>在我们清楚了以上背景知识之后，再来看 handle_pte_fault 的缺页处理逻辑就很清晰了：</p><p><img src="/posts/29394/640-1716118652145-68.webp" alt></p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> vm_fault_t <span class="token function">handle_pte_fault</span><span class="token punctuation">(</span><span class="token keyword">struct</span> vm_fault <span class="token operator">*</span>vmf<span class="token punctuation">)</span><span class="token punctuation">{</span>    pte_t entry<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token function">pmd_none</span><span class="token punctuation">(</span><span class="token operator">*</span>vmf<span class="token operator">-></span>pmd<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果 pmd 是空的，说明现在连页表都没有，页表项 pte 自然是空的</span>        vmf<span class="token operator">-></span>pte <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// vmf->pte 表示缺页虚拟内存地址在页表中对应的页表项 pte</span>        <span class="token comment" spellcheck="true">// 通过 pte_offset_map 定位到虚拟内存地址 address 对应在页表中的 pte</span>        <span class="token comment" spellcheck="true">// 这里根据 address 获取 pte_index，然后从 pmd 中提取页表起始虚拟内存地址相加获取 pte</span>        vmf<span class="token operator">-></span>pte <span class="token operator">=</span> <span class="token function">pte_offset_map</span><span class="token punctuation">(</span>vmf<span class="token operator">-></span>pmd<span class="token punctuation">,</span> vmf<span class="token operator">-></span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//  vmf->orig_pte 表示发生缺页时，address 对应的 pte 值</span>        vmf<span class="token operator">-></span>orig_pte <span class="token operator">=</span> <span class="token operator">*</span>vmf<span class="token operator">-></span>pte<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 这里 pmd 不是空的，表示现在是有页表存在的，但缺页虚拟内存地址在页表中的 pte 是空值</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pte_none</span><span class="token punctuation">(</span>vmf<span class="token operator">-></span>orig_pte<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">pte_unmap</span><span class="token punctuation">(</span>vmf<span class="token operator">-></span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>            vmf<span class="token operator">-></span>pte <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// pte 是空的，表示缺页地址 address 还从来没有被映射过，接下来就要处理物理内存的映射</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vmf<span class="token operator">-></span>pte<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 判断缺页的虚拟内存地址 address 所在的虚拟内存区域 vma 是否是匿名映射区</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">vma_is_anonymous</span><span class="token punctuation">(</span>vmf<span class="token operator">-></span>vma<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 处理匿名映射区发生的缺页</span>            <span class="token keyword">return</span> <span class="token function">do_anonymous_page</span><span class="token punctuation">(</span>vmf<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token comment" spellcheck="true">// 处理文件映射区发生的缺页</span>            <span class="token keyword">return</span> <span class="token function">do_fault</span><span class="token punctuation">(</span>vmf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 走到这里表示 pte 不是空的，但是 pte 中的 p 比特位是 0 值，表示之前映射的物理内存页已不在内存中（swap out）</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pte_present</span><span class="token punctuation">(</span>vmf<span class="token operator">-></span>orig_pte<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 将之前映射的物理内存页从磁盘中重新 swap in 到内存中</span>        <span class="token keyword">return</span> <span class="token function">do_swap_page</span><span class="token punctuation">(</span>vmf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这里表示 pte 背后映射的物理内存页在内存中，但是 NUMA Balancing 发现该内存页不在当前进程运行的 numa 节点上</span>    <span class="token comment" spellcheck="true">// 所以将该 pte 标记为 _PAGE_PROTNONE（无读写，可执行权限）</span>    <span class="token comment" spellcheck="true">// 进程访问该内存页时发生缺页中断，在这里的 do_numa_page 中，内核将该 page 迁移到进程运行的 numa 节点上。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pte_protnone</span><span class="token punctuation">(</span>vmf<span class="token operator">-></span>orig_pte<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">vma_is_accessible</span><span class="token punctuation">(</span>vmf<span class="token operator">-></span>vma<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">do_numa_page</span><span class="token punctuation">(</span>vmf<span class="token punctuation">)</span><span class="token punctuation">;</span>    entry <span class="token operator">=</span> vmf<span class="token operator">-></span>orig_pte<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果本次缺页中断是由写操作引起的</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>vmf<span class="token operator">-></span>flags <span class="token operator">&amp;</span> FAULT_FLAG_WRITE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 这里说明 vma 是可写的，但是 pte 被标记为不可写，说明是写保护类型的中断</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pte_write</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 进行写时复制处理，cow 就发生在这里</span>            <span class="token keyword">return</span> <span class="token function">do_wp_page</span><span class="token punctuation">(</span>vmf<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果 pte 是可写的，就将 pte 标记为脏页</span>        entry <span class="token operator">=</span> <span class="token function">pte_mkdirty</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 将 pte 的 access 比特位置 1 ，表示该 page 是活跃的。避免被 swap 出去</span>    entry <span class="token operator">=</span> <span class="token function">pte_mkyoung</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 经过上面的缺页处理，这里会判断原来的页表项 entry（orig_pte） 值是否发生了变化</span>    <span class="token comment" spellcheck="true">// 如果发生了变化，就把 entry 更新到 vmf->pte 中。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ptep_set_access_flags</span><span class="token punctuation">(</span>vmf<span class="token operator">-></span>vma<span class="token punctuation">,</span> vmf<span class="token operator">-></span>address<span class="token punctuation">,</span> vmf<span class="token operator">-></span>pte<span class="token punctuation">,</span> entry<span class="token punctuation">,</span>                vmf<span class="token operator">-></span>flags <span class="token operator">&amp;</span> FAULT_FLAG_WRITE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// pte 既然变化了，则刷新 mmu （体系结构相关）</span>        <span class="token function">update_mmu_cache</span><span class="token punctuation">(</span>vmf<span class="token operator">-></span>vma<span class="token punctuation">,</span> vmf<span class="token operator">-></span>address<span class="token punctuation">,</span> vmf<span class="token operator">-></span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果 pte 内容本身没有变化，则不需要刷新任何东西</span>        <span class="token comment" spellcheck="true">// 但是有个特殊情况就是写保护类型中断，产生的写时复制，产生了新的映射关系，需要刷新一下 tlb</span>  <span class="token comment" spellcheck="true">/*   * This is needed only for protection faults but the arch code   * is not yet telling us if this is a protection fault or not.   * This still avoids useless tlb flushes for .text page faults   * with threads.   */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>vmf<span class="token operator">-></span>flags <span class="token operator">&amp;</span> FAULT_FLAG_WRITE<span class="token punctuation">)</span>            <span class="token function">flush_tlb_fix_spurious_fault</span><span class="token punctuation">(</span>vmf<span class="token operator">-></span>vma<span class="token punctuation">,</span> vmf<span class="token operator">-></span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-do-anonymous-page-处理匿名页缺页"><a href="#7-do-anonymous-page-处理匿名页缺页" class="headerlink" title="7. do_anonymous_page 处理匿名页缺页"></a>7. do_anonymous_page 处理匿名页缺页</h2><p><img src="/posts/29394/640-1716118701691-71.webp" alt></p><p>在之前完成了各级页目录的补齐填充工作，但是现在最后一级页表还没有着落，所以在处理缺页之前，我们需要调用 pte_alloc 继续把页表补齐了。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> pte_alloc(mm, pmd) (unlikely(pmd_none(*(pmd))) &amp;&amp; __pte_alloc(mm, pmd))</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>首先我们通过 pmd_none 判断缺页地址 address 在进程页表中间页目录 PMD 中对应的页目录项 pmd 是否是空的，如果 pmd 是空的，说明此时还不存在一级页表，这样一来，就需要调用 <code>__pte_alloc</code> 来分配一张页表，然后用页表的 pfn 以及初始权限位 <code>_PAGE_TABLE</code> 来填充 pmd。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">pmd_populate</span><span class="token punctuation">(</span><span class="token keyword">struct</span> mm_struct <span class="token operator">*</span>mm<span class="token punctuation">,</span> pmd_t <span class="token operator">*</span>pmd<span class="token punctuation">,</span>                <span class="token keyword">struct</span> page <span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 通过页表 page 获取对应的 pfn</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> pfn <span class="token operator">=</span> <span class="token function">page_to_pfn</span><span class="token punctuation">(</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将页表 page 的 pfn 以及初始权限位 _PAGE_TABLE 填充到 pmd 中</span>    <span class="token function">set_pmd</span><span class="token punctuation">(</span>pmd<span class="token punctuation">,</span> <span class="token function">__pmd</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pteval_t<span class="token punctuation">)</span>pfn <span class="token operator">&lt;&lt;</span> PAGE_SHIFT<span class="token punctuation">)</span> <span class="token operator">|</span> _PAGE_TABLE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>都是创建其下一级页目录或者页表，然后填充对应的页目录项:</p><p><img src="/posts/29394/640-1716118835843-74.webp" alt></p><p>现在我们已经有了一级页表，但是页表中的 pte 还都是空的，接下来就该用这个空的 pte 来映射物理内存页了。首先我们通过 <code>alloc_zeroed_user_highpage_movable</code> 来分配一个物理内存页出来。这个物理内存页就是为缺页地址 address 映射的物理内存了，随后我们通过 mk_pte 利用物理内存页 page 的 pfn 以及缺页内存区域 vma 中记录的页属性 vma-&gt;vm_page_prot 填充一个新的页表项 entry 出来。</p><blockquote><p>entry 这里只是一个临时的值，后续会将 entry 的值设置到真正的 pte 中。</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> mk_pte(page, pgprot)   pfn_pte(page_to_pfn(page), (pgprot))</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/29394/640-1716118943581-77.webp" alt></p><p>如果缺页内存地址 address 所在的虚拟内存区域 vma 是可写的，那么我们就通过 pte_mkwrite 和 pte_mkdirty 将临时页表项 entry 的 <code>R/W(1)</code> 比特位和<code>D(6)</code> 比特位置为 1 。表示该页表项背后映射的物理内存页 page 是可写的，并且标记为脏页。注意，此时缺页内存地址 address 在页表中的 pte 还是空的，我们还没有设置呢，目前只是先将值初始化到临时的页表项 entry 中，下面才到设置真正的 pte 的时候。</p><p>调用 pte_offset_map_lock，首先获取 address 在一级页表中的真正 pte，然后将一级页表锁定。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> pte_offset_map_lock(mm, pmd, address, ptlp) \({                          \    </span><span class="token comment" spellcheck="true">// 获取 pmd 映射的一级页表锁</span>    spinlock_t <span class="token operator">*</span>__ptl <span class="token operator">=</span> <span class="token function">pte_lockptr</span><span class="token punctuation">(</span>mm<span class="token punctuation">,</span> pmd<span class="token punctuation">)</span><span class="token punctuation">;</span>   \    <span class="token comment" spellcheck="true">// 获取 pte</span>    pte_t <span class="token operator">*</span>__pte <span class="token operator">=</span> <span class="token function">pte_offset_map</span><span class="token punctuation">(</span>pmd<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>    \    <span class="token operator">*</span><span class="token punctuation">(</span>ptlp<span class="token punctuation">)</span> <span class="token operator">=</span> __ptl<span class="token punctuation">;</span>                \    <span class="token comment" spellcheck="true">// 锁定一级页表</span>    <span class="token function">spin_lock</span><span class="token punctuation">(</span>__ptl<span class="token punctuation">)</span><span class="token punctuation">;</span>               \    __pte<span class="token punctuation">;</span>                      \<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>按理说此时获取到的 pte 应该是空的，如果 pte 不为空，说明已经有其他线程把缺页处理好了，pte 已经被填充了，那么本次缺页处理就该停止，不能在往下走了，直接跳转到 release 处，释放页表锁，释放新分配的物理内存页 page。</p><pre class="line-numbers language-c"><code class="language-c">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pte_none</span><span class="token punctuation">(</span><span class="token operator">*</span>vmf<span class="token operator">-></span>pte<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">goto</span> release<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果 pte 为空，说明此时没有其他线程对缺页进行并发处理，我们可以接着处理缺页。</p><p>进程使用到的常驻内存等相关统计信息保存在 task-&gt;rss_stat 字段中：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> task_struct <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 统计进程常驻内存信息</span>    <span class="token keyword">struct</span> task_rss_stat rss_stat<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>由于这里我们新分配一个匿名内存页用于缺页处理，所以相关 rss_stat 统计信息 —— task-&gt;rss_stat.count[MM_ANONPAGES] 要加 1 。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// MM_ANONPAGES —— Resident anonymous pages </span><span class="token function">inc_mm_counter_fast</span><span class="token punctuation">(</span>vma<span class="token operator">-></span>vm_mm<span class="token punctuation">,</span> MM_ANONPAGES<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">define</span> inc_mm_counter_fast(mm, member) add_mm_counter_fast(mm, member, 1)</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">add_mm_counter_fast</span><span class="token punctuation">(</span><span class="token keyword">struct</span> mm_struct <span class="token operator">*</span>mm<span class="token punctuation">,</span> <span class="token keyword">int</span> member<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">struct</span> task_struct <span class="token operator">*</span>task <span class="token operator">=</span> current<span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>task<span class="token operator">-></span>mm <span class="token operator">==</span> mm<span class="token punctuation">)</span><span class="token punctuation">)</span>  task<span class="token operator">-></span>rss_stat<span class="token punctuation">.</span>count<span class="token punctuation">[</span>member<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> val<span class="token punctuation">;</span> <span class="token keyword">else</span>  <span class="token function">add_mm_counter</span><span class="token punctuation">(</span>mm<span class="token punctuation">,</span> member<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>随后调用 page_add_new_anon_rmap 建立匿名页的反向映射关系，反向映射建立好之后，调用 lru_cache_add_active_or_unevictable 将匿名内存页加入到 LRU 活跃链表中。最后调用 set_pte_at 将之间我们临时填充的页表项 entry 赋值给缺页 address 真正对应的 pte。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">set_pte_at</span><span class="token punctuation">(</span>vma<span class="token operator">-></span>vm_mm<span class="token punctuation">,</span> vmf<span class="token operator">-></span>address<span class="token punctuation">,</span> vmf<span class="token operator">-></span>pte<span class="token punctuation">,</span> entry<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">define</span> set_pte_at(mm, addr, ptep, pte) native_set_pte_at(mm, addr, ptep, pte)</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">native_set_pte_at</span><span class="token punctuation">(</span><span class="token keyword">struct</span> mm_struct <span class="token operator">*</span>mm<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> addr<span class="token punctuation">,</span>         pte_t <span class="token operator">*</span>ptep <span class="token punctuation">,</span> pte_t pte<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">native_set_pte</span><span class="token punctuation">(</span>ptep<span class="token punctuation">,</span> pte<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">native_set_pte</span><span class="token punctuation">(</span>pte_t <span class="token operator">*</span>ptep<span class="token punctuation">,</span> pte_t pte<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">WRITE_ONCE</span><span class="token punctuation">(</span><span class="token operator">*</span>ptep<span class="token punctuation">,</span> pte<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到这里我们才算是真正把进程的页表体系给补齐了。</p><p><img src="/posts/29394/640-1716119309679-80.webp" alt></p><h2 id="8-do-fault-处理文件页缺页"><a href="#8-do-fault-处理文件页缺页" class="headerlink" title="8. do_fault 处理文件页缺页"></a>8. do_fault 处理文件页缺页</h2><p>之前提到 mmap 文件映射的源码实现时，特别强调了一下，mmap 内存文件映射的本质其实就是将虚拟映射区 vma 的相关操作 vma-&gt;vm_ops 映射成文件的相关操作 ext4_file_vm_ops。</p><p>在 vma-&gt;vm_ops 中有个重要的函数 fault，在 ext4 文件系统中的实现是：ext4_filemap_fault 函数。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> vm_operations_struct ext4_file_vm_ops <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span>fault      <span class="token operator">=</span> ext4_filemap_fault<span class="token punctuation">,</span>    <span class="token punctuation">.</span>map_pages  <span class="token operator">=</span> filemap_map_pages<span class="token punctuation">,</span>    <span class="token punctuation">.</span>page_mkwrite   <span class="token operator">=</span> ext4_page_mkwrite<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>vma-&gt;vm_ops-&gt;fault 函数就是专门用于处理文件映射区缺页的。而文件页的缺页处理的核心就是依赖这个函数完成的。我们知道 mmap 进行文件映射的时候只是单纯地建立了虚拟内存与文件之间的映射关系，此时并没有物理内存分配。当进程对这段文件映射区进行读取操作的时候，会触发缺页，然后分配物理内存（文件页），这一部分逻辑在下面的 do_read_fault 函数中完成，它主要处理的是由于对文件映射区的读取操作而引起的缺页情况。</p><p>而 mmap 文件映射又分为私有文件映射与共享文件映射两种映射方式，而私有文件映射的核心特点是读共享的，当任意进程对私有文件映射区发生写入操作时候，就会发生写时复制 COW，这一部分逻辑在下面的 do_cow_fault 函数中完成。</p><p>对共享文件映射区进行的写入操作而引起的缺页，内核放在 do_shared_fault 函数中进行处理。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> vm_fault_t <span class="token function">do_fault</span><span class="token punctuation">(</span><span class="token keyword">struct</span> vm_fault <span class="token operator">*</span>vmf<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> vm_area_struct <span class="token operator">*</span>vma <span class="token operator">=</span> vmf<span class="token operator">-></span>vma<span class="token punctuation">;</span>    <span class="token keyword">struct</span> mm_struct <span class="token operator">*</span>vm_mm <span class="token operator">=</span> vma<span class="token operator">-></span>vm_mm<span class="token punctuation">;</span>    vm_fault_t ret<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 处理 vm_ops->fault 为 null 的异常情况</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vma<span class="token operator">-></span>vm_ops<span class="token operator">-></span>fault<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果中间页目录 pmd 指向的一级页表不在内存中，则返回 SIGBUS 错误</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pmd_present</span><span class="token punctuation">(</span><span class="token operator">*</span>vmf<span class="token operator">-></span>pmd<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            ret <span class="token operator">=</span> VM_FAULT_SIGBUS<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 获取缺页的页表项 pte</span>            vmf<span class="token operator">-></span>pte <span class="token operator">=</span> <span class="token function">pte_offset_map_lock</span><span class="token punctuation">(</span>vmf<span class="token operator">-></span>vma<span class="token operator">-></span>vm_mm<span class="token punctuation">,</span>                               vmf<span class="token operator">-></span>pmd<span class="token punctuation">,</span>                               vmf<span class="token operator">-></span>address<span class="token punctuation">,</span>                               <span class="token operator">&amp;</span>vmf<span class="token operator">-></span>ptl<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// pte 为空，则返回 SIGBUS 错误</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token function">pte_none</span><span class="token punctuation">(</span><span class="token operator">*</span>vmf<span class="token operator">-></span>pte<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                ret <span class="token operator">=</span> VM_FAULT_SIGBUS<span class="token punctuation">;</span>            <span class="token keyword">else</span>                <span class="token comment" spellcheck="true">// pte 不为空，返回 NOPAGE，即本次缺页处理不会分配物理内存页</span>                ret <span class="token operator">=</span> VM_FAULT_NOPAGE<span class="token punctuation">;</span>            <span class="token function">pte_unmap_unlock</span><span class="token punctuation">(</span>vmf<span class="token operator">-></span>pte<span class="token punctuation">,</span> vmf<span class="token operator">-></span>ptl<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>vmf<span class="token operator">-></span>flags <span class="token operator">&amp;</span> FAULT_FLAG_WRITE<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 缺页如果是读操作引起的，进入 do_read_fault 处理</span>        ret <span class="token operator">=</span> <span class="token function">do_read_fault</span><span class="token punctuation">(</span>vmf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>vma<span class="token operator">-></span>vm_flags <span class="token operator">&amp;</span> VM_SHARED<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 缺页是由私有映射区的写入操作引起的，则进入 do_cow_fault 处理写时复制</span>        ret <span class="token operator">=</span> <span class="token function">do_cow_fault</span><span class="token punctuation">(</span>vmf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token comment" spellcheck="true">// 处理共享映射区的写入缺页</span>        ret <span class="token operator">=</span> <span class="token function">do_shared_fault</span><span class="token punctuation">(</span>vmf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-1-do-read-fault-处理读操作引起的缺页"><a href="#8-1-do-read-fault-处理读操作引起的缺页" class="headerlink" title="8.1 do_read_fault 处理读操作引起的缺页"></a>8.1 do_read_fault 处理读操作引起的缺页</h3><p>当我们调用 mmap 对文件进行映射的时候，无论是采用私有文件映射的方式还是共享文件映射的方式，内核都只是会在进程的地址空间中为本次映射创建出一段虚拟映射区 vma 出来，然后将这段虚拟映射区 vma 与映射文件关联起来就结束了，整个映射过程并未涉及到物理内存的分配。</p><p>下面是多进程对同一文件中的同一段文件区域进行私有映射后，内核中的结构图：</p><p><img src="/posts/29394/640-1716119772306-83.webp" alt></p><p>当任意进程开始访问其地址空间中的这段虚拟内存区域 vma 时，由于背后没有对应文件页进行映射，所以会发生缺页中断，在缺页中断中内核会首先分配一个物理内存页并加入到 page  cache 中，随后将映射的文件内容读取到刚刚创建出来的物理内存页中，然后将这个物理内存页映射到缺页虚拟内存地址 address 对应在进程页表中的 pte 中。</p><p><img src="/posts/29394/640-1716119856850-86.webp" alt></p><p>除此之外，内核还会考虑到进程访问内存的空间局部性，所以内核除了会映射本次缺页需要的文件页之外，还会将其相邻的文件页读取到 page cache 中，然后将这些相邻的文件页映射到对应的 pte 中。这一部分预先提前映射的逻辑在 map_pages 函数中实现。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> vm_operations_struct ext4_file_vm_ops <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span>fault      <span class="token operator">=</span> ext4_filemap_fault<span class="token punctuation">,</span>    <span class="token punctuation">.</span>map_pages  <span class="token operator">=</span> filemap_map_pages<span class="token punctuation">,</span>    <span class="token punctuation">.</span>page_mkwrite   <span class="token operator">=</span> ext4_page_mkwrite<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果不满足预先提前映射的条件，那么内核就只会专注处理映射本次缺页所需要的文件页。首先通过上面的 fault 函数，当映射文件所在文件系统是 ext4 时，该函数的实现为 ext4_filemap_fault，该函数只负责获取本次缺页所需要的文件页。</p><p>当获取到文件页之后，内核会调用 finish_fault 函数，将文件页映射到缺页地址 address 在进程页表中对应的 pte 中，<strong>do_read_fault</strong> 函数处理就完成了，不过需要注意的是，对于私有文件映射的话，此时的这个 pte 还是只读的，多进程之间读共享，当任意进程尝试写入的时候，会发生写时复制。内核在这里首先会调用 find_get_page 从 page cache 中尝试获取文件页，如果文件页存在，则继续调用 do_async_mmap_readahead 启动异步预读机制，将相邻的若干文件页一起预读进 page cache 中。</p><p>如果文件页不在 page cache 中，内核则会调用 do_sync_mmap_readahead 来同步预读，这里首先会分配一个物理内存页出来，然后将新分配的内存页加入到 page cache 中，并增加页引用计数。</p><p>随后会通过 address_space_operations 中定义的 readpage 激活块设备驱动从磁盘中读取映射的文件内容，然后将读取到的内容填充新分配的内存页中。并同步预读若干相邻的文件页到 page cache 中。文件页现在有了，接下来内核就会调用 finish_fault 将文件页映射到 pte 中。通过alloc_set_pte 将之前我们准备好的文件页，映射到缺页地址 address 在进程页表对应的 pte 中。</p><h3 id="8-2-do-cow-fault-处理私有文件映射的写时复制"><a href="#8-2-do-cow-fault-处理私有文件映射的写时复制" class="headerlink" title="8.2 do_cow_fault 处理私有文件映射的写时复制"></a>8.2 do_cow_fault 处理私有文件映射的写时复制</h3><p>上小节 do_read_fault 函数处理的场景是，进程在调用 mmap 对文件进行私有映射或者共享映射之后，立马进行读取的缺页场景。</p><p><img src="/posts/29394/640-1716120163381-89.webp" alt></p><p>但是如果当我们采用的是 mmap 进行私有文件映射时，在映射之后，立马进行写入操作时，就会发生写时复制，写时复制的缺页处理流程内核封装在 do_cow_fault 函数中。由于我们这里要进行写时复制，所以首先要调用 alloc_page_vma 从伙伴系统中重新申请一个物理内存页出来，我们先把这个刚刚新申请出来用于写时复制的内存页称为 cow_page。</p><p>然后调用 __do_fault 函数，将原来的文件页从 page cache 中读取出来，我们把原来的文件页称为 page 。最后调用 copy_user_highpage 将原来文件页 page 中的内容拷贝到刚刚新申请的内存页 cow_page 中，完成写时复制之后，接着调用 finish_fault 将 cow_page 映射到缺页地址 address 在进程页表中的 pte 上。</p><p><img src="/posts/29394/640-1716120371743-92.webp" alt></p><p>这样一来，进程的这段虚拟文件映射区就映射到了专属的物理内存页 cow_page 上，而且内容和原来文件页 page 中的内容一模一样，进程对各自虚拟内存区的修改只能反应到各自对应的 cow_page上，而且各自的修改在进程之间是互不可见的。</p><p>由于 cow_page 已经脱离了 page cache，所以这些修改也都不会回写到磁盘文件中，这就是私有文件映射的核心特点。</p><h3 id="8-3-do-shared-fault-处理对共享文件映射区写入引起的缺页"><a href="#8-3-do-shared-fault-处理对共享文件映射区写入引起的缺页" class="headerlink" title="8.3 do_shared_fault 处理对共享文件映射区写入引起的缺页"></a>8.3 do_shared_fault 处理对共享文件映射区写入引起的缺页</h3><p>如果我们调用 mmap 对文件进行共享文件映射之后，然后立即对虚拟映射区进行写入操作，这背后的缺页处理逻辑又是怎样的呢 ？</p><p>其实和之前的文件缺页处理逻辑的核心流程都差不多，不同的是由于这里我们进行的共享文件映射，所以多个进程中的虚拟文件映射区都会映射到 page cache 中的文件页上，由于没有写时复制，所以进程对文件页的修改都会直接反映到 page cache 中，近而后续会回写到磁盘文件上。</p><p>由于共享文件映射涉及到脏页回写，所以在共享文件映射的缺页处理场景中，为了防止数据的丢失会额外有一些文件系统日志的记录工作。</p><h2 id="9-do-wp-page-进行写时复制"><a href="#9-do-wp-page-进行写时复制" class="headerlink" title="9. do_wp_page 进行写时复制"></a>9. do_wp_page 进行写时复制</h2><p>do_wp_page 函数和之前介绍的 do_cow_fault 函数都是用于处理写时复制的，其最为核心的逻辑都是差不多的，只是在触发场景上会略有不同：</p><ul><li>do_cow_fault 函数主要处理的写时复制场景是，当我们使用 mmap 进行私有文件映射时，在刚映射完之后，此时进程的页表或者相关页表项 pte 还是空的，就立即进行写入操作。</li><li>do_wp_page 函数主要处理的写时复制场景是，访问的这块虚拟内存背后是有物理内存页映射的，对应的 pte 不为空，只不过相关 pte 的权限是只读的，而虚拟内存区域 vma 是有写权限的，在这种类型的虚拟内存进行写入操作的时候，触发的写时复制就在 do_wp_page 函数中处理。</li></ul><p>比如，我们使用 mmap 进行私有文件映射之后，此时只是分配了虚拟内存，进程页表或者相关 pte 还是空的，这时对这块映射的虚拟内存进行访问的时候就会触发缺页中断，最后在之前介绍的 do_read_fault 函数中将映射的文件内容加载到 page cache 中，pte 指向 page cache 中的文件页。</p><p>但此时的 pte 是只读的，如果我们对这块映射的虚拟内存进行写入操作，就会发生写时复制，由于现在 pte 不为空，背后也映射着文件页，所以会在 do_wp_page 函数中进行处理。除了私有映射的文件页之外，do_wp_page 还会对匿名页相关的写时复制进行处理。比如，我们通过 fork 系统调用创建子进程的时候，内核会拷贝父进程占用的所有资源到子进程中，其中也包括了父进程的地址空间以及父进程的页表。</p><p>一个进程中申请的物理内存页既会有文件页也会有匿名页，而这些文件页和匿名页既可以是私有的也可以是共享的，当内核在拷贝父进程的页表时，如果遇到私有的匿名页或者文件页，就会将其对应在父子进程页表中的 pte 设置为只读，进行写保护。并将父子进程共同引用的匿名页或者文件页的引用计数加 1。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token function">copy_one_pte</span><span class="token punctuation">(</span><span class="token keyword">struct</span> mm_struct <span class="token operator">*</span>dst_mm<span class="token punctuation">,</span> <span class="token keyword">struct</span> mm_struct <span class="token operator">*</span>src_mm<span class="token punctuation">,</span>        pte_t <span class="token operator">*</span>dst_pte<span class="token punctuation">,</span> pte_t <span class="token operator">*</span>src_pte<span class="token punctuation">,</span> <span class="token keyword">struct</span> vm_area_struct <span class="token operator">*</span>vma<span class="token punctuation">,</span>        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> addr<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>rss<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*     * If it's a COW mapping, write protect it both     * in the parent and the child     */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_cow_mapping</span><span class="token punctuation">(</span>vm_flags<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">pte_write</span><span class="token punctuation">(</span>pte<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 设置父进程的 pte 为只读</span>        <span class="token function">ptep_set_wrprotect</span><span class="token punctuation">(</span>src_mm<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> src_pte<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 设置子进程的 pte 为只读</span>        pte <span class="token operator">=</span> <span class="token function">pte_wrprotect</span><span class="token punctuation">(</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 获取 pte 中映射的物理内存页（此时父子进程共享该页）</span>    page <span class="token operator">=</span> <span class="token function">vm_normal_page</span><span class="token punctuation">(</span>vma<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> pte<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 物理内存页的引用技术 + 1</span>    <span class="token function">get_page</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">inline</span> bool <span class="token function">is_cow_mapping</span><span class="token punctuation">(</span>vm_flags_t flags<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// vma 是私有可写的</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> <span class="token punctuation">(</span>VM_SHARED <span class="token operator">|</span> VM_MAYWRITE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> VM_MAYWRITE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在父子进程拥有了一模一样的地址空间，页表是一样的，页表中的 pte 均指向同一个物理内存页面，对于私有的物理内存页来说，父子进程的相关 pte 此时均变为了只读的，私有物理内存页的引用计数为 2 。而对于共享的物理内存页来说，内核就只是简单的将父进程的 pte 拷贝到子进程页表中即可，然后将子进程 pte 中的脏页标记清除，其他的不做改变。</p><p>当父进程或者子进程对该页面发生写操作的时候，我们现在假设子进程先对页面发生写操作，随后子进程发现自己页表中的 pte 是只读的，于是就会产生写保护类型的缺页中断，由于子进程页表中的 pte 不为空，所以会进入到 do_wp_page 函数中处理。</p><p>由于现在子进程和父子进程页表中的相关 pte 指向的均是同一个物理内存页，内核在 do_wp_page 函数中会发现这个物理内存页的引用计数大于 1，存在多进程共享的情况，所以就会触发写时复制，这一过程在 wp_page_copy 函数中处理。</p><p>在 wp_page_copy 函数中，内核会首先为子进程分配一个新的物理内存页 new_page，然后调用 cow_user_page 将原有内存页 old_page 中的内容全部拷贝到新内存页中。创建一个临时的页表项 entry，然后让 entry 指向新的内存页，将 entry 重新设置为可写，通过 set_pte_at_notify 将 entry 值设置到子进程页表中的 pte 上。最后将原有内存页 old_page 的引用计数减 1 。</p><p>现在子进程处理完了，下面我们再来看当父进程发生写入操作的时候会发生什么 ？</p><p>首先和子进程一样，现在父进程页表中的相关 pte 仍然是只读的，访问这段虚拟内存地址依然会产生写保护类型的缺页中断，和子进程不同的是，此时父进程 pte 中指向的原有物理内存页 old_page 的引用计数已经变为 1 了，说明父进程是独占的，复用原来的 old_page 即可，不必进行写时复制，只是简单的将父进程页表中的相关 pte 改为可写就行了。</p><p>理解了上面的核心内容，我们再来看 do_wp_page 的处理逻辑就很清晰了：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> vm_fault_t <span class="token function">do_wp_page</span><span class="token punctuation">(</span><span class="token keyword">struct</span> vm_fault <span class="token operator">*</span>vmf<span class="token punctuation">)</span>    <span class="token function">__releases</span><span class="token punctuation">(</span>vmf<span class="token operator">-></span>ptl<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> vm_area_struct <span class="token operator">*</span>vma <span class="token operator">=</span> vmf<span class="token operator">-></span>vma<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取 pte 映射的物理内存页</span>    vmf<span class="token operator">-></span>page <span class="token operator">=</span> <span class="token function">vm_normal_page</span><span class="token punctuation">(</span>vma<span class="token punctuation">,</span> vmf<span class="token operator">-></span>address<span class="token punctuation">,</span> vmf<span class="token operator">-></span>orig_pte<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 省略处理特殊映射相关逻辑 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 物理内存页为匿名页的情况</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">PageAnon</span><span class="token punctuation">(</span>vmf<span class="token operator">-></span>page<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 省略处理 ksm page 相关逻辑 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true">// reuse_swap_page 判断匿名页的引用计数是否为 1</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">reuse_swap_page</span><span class="token punctuation">(</span>vmf<span class="token operator">-></span>page<span class="token punctuation">,</span> <span class="token operator">&amp;</span>total_map_swapcount<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果当前物理内存页的引用计数为 1 ，并且只有当前进程在引用该物理内存页</span>            <span class="token comment" spellcheck="true">// 则不做写时复制处理，而是复用当前物理内存页，只是将 pte 改为可写即可 </span>            <span class="token function">wp_page_reuse</span><span class="token punctuation">(</span>vmf<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> VM_FAULT_WRITE<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">unlock_page</span><span class="token punctuation">(</span>vmf<span class="token operator">-></span>page<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token punctuation">(</span>vma<span class="token operator">-></span>vm_flags <span class="token operator">&amp;</span> <span class="token punctuation">(</span>VM_WRITE<span class="token operator">|</span>VM_SHARED<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span>                    <span class="token punctuation">(</span>VM_WRITE<span class="token operator">|</span>VM_SHARED<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 处理共享可写的内存页</span>        <span class="token comment" spellcheck="true">// 由于大家都可写，所以这里也只是调用 wp_page_reuse 复用当前内存页即可，不做写时复制处理</span>        <span class="token comment" spellcheck="true">// 由于是共享的，对于文件页来说是可以回写到磁盘上的，所以会额外调用一次 fault_dirty_shared_page 判断是否进行脏页的回写</span>        <span class="token keyword">return</span> <span class="token function">wp_page_shared</span><span class="token punctuation">(</span>vmf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>copy<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">// 走到这里表示当前物理内存页的引用计数大于 1 被多个进程引用</span>    <span class="token comment" spellcheck="true">// 对于私有可写的虚拟内存区域来说，就要发生写时复制</span>    <span class="token comment" spellcheck="true">// 而对于私有文件页的情况来说，不必判断内存页的引用计数</span>    <span class="token comment" spellcheck="true">// 因为是私有文件页，不管文件页的引用计数是不是 1 ，都要进行写时复制</span>    <span class="token keyword">return</span> <span class="token function">wp_page_copy</span><span class="token punctuation">(</span>vmf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-do-swap-page-处理-swap-缺页异常"><a href="#10-do-swap-page-处理-swap-缺页异常" class="headerlink" title="10. do_swap_page 处理 swap 缺页异常"></a>10. do_swap_page 处理 swap 缺页异常</h2><p>如果在遍历进程页表的时候发现，虚拟内存地址 address 对应的页表项 pte 不为空，但是 pte 中第 0 个比特位置为 0 ，则表示该 pte 之前是被物理内存映射过的，只不过后来被内核 swap out 出去了。</p><p><img src="/posts/29394/640-1716120968863-95.webp" alt></p><p>我们需要的物理内存页不在内存中反而在磁盘中，现在我们就需要将物理内存页从磁盘中 swap in 进来。但在 swap in 之前内核需要知道该物理内存页的内容被保存在磁盘的什么位置上。</p><p>64 位的 pte 主要用来表示物理内存页的地址以及相关的权限标识位，但是当物理内存页不在内存中的时候，这些比特位就没有了任何意义。我们何不将这些已经没有任何意义的比特位利用起来，在物理内存页被 swap out 到磁盘上的时候，将物理内存页在磁盘上的位置保存在这些比特位中。本质上还利用的是之前 pte 中的那 64 个比特，为了区别 swap 的场景，内核使用了一个新的结构体  <code>swp_entry_t</code> 来包装。</p><p><img src="/posts/29394/640-1716121149738-98.webp" alt></p><p>swap in 的首要任务就是先要从进程页表中将这个 swp_entry_t 读取出来，然后从 swp_entry_t 中解析出内存页在 swap 交换区中的位置，根据磁盘位置信息将内存页的内容读取到内存中。由于产生了新的物理内存页，所以就要创建新的 pte 来映射这个物理内存页，然后将新的 pte 设置到页表中，替换原来的 swp_entry_t。</p><h3 id="10-1-交换区的布局及其组织结构"><a href="#10-1-交换区的布局及其组织结构" class="headerlink" title="10.1 交换区的布局及其组织结构"></a>10.1 交换区的布局及其组织结构</h3><p>要明白这个，我们就需要先了解一下 swap 交换区（swap area）的布局，swap 交换区共有两种类型，一种是 swap 分区（swap partition），另一种是 swap 文件（swap file）。</p><ul><li>swap partition 可以认为是一个没有文件系统的裸磁盘分区，分区中的磁盘块在磁盘中是连续分布的。</li><li>swap file 可以认为是在某个现有的文件系统上，创建的一个定长的普通文件，专门用于保存匿名页被 swap 出来的内容。背后的磁盘块是不连续的。</li></ul><p>Linux 系统中可以允许多个这样的 swap 交换区存在，我们可以同时使用多个交换区，也可以为这些交换区指定优先级，优先级高的会被内核优先使用。这些交换区都可以被灵活地添加，删除，而不需要重启系统。多个交换区可以分散在不同的磁盘设备上，这样可以实现硬件的并行访问。</p><p>在使用交换区之前，我们可以通过 <code>mkswap</code> 首先创建一个交换区出来，如果我们创建的是 swap partition，则在 <code>mkswap</code> 命令后面直接指定分区的设备文件名称即可。</p><pre><code>mkswap /dev/sdb7</code></pre><p>如果我们创建的是 swap file，则需要额外先使用 <code>dd</code> 命令在现有文件系统中创建出一个定长的文件出来。比如下面通过 <code>dd</code> 命令从 <code>/dev/zero</code> 中拷贝创建一个 <code>/swapfile</code> 文件，大小为 4G。</p><pre><code>dd if=/dev/zero of=/swapfile bs=1M count=4096</code></pre><p>然后使用 <code>mkswap</code> 命令创建 swap file ：</p><pre><code>mkswap /swapfile</code></pre><p>当 swap partition 或者 swap file 创建好之后，我们通过 <code>swapon</code> 命令来初始化并激活这个交换区。</p><pre><code>swapon /swapfile</code></pre><p>在每个交换区 swap area 内部又会分为很多连续的  slot (槽)，每个 slot 的大小刚好和一个物理内存页的大小相同都是 4K，物理内存页在被 swap out 到交换区时，就会存放在 slot 中。交换区中的这些 slot 会被组织在一个叫做 swap_map 的数组中，数组中的索引就是 slot 在交换区中的 offset （这个位置信息很重要），数组中的值表示该 slot 总共被多少个进程同时引用。</p><p>什么意思呢 ？ 比如现在系统中一共有三个进程同时共享一个物理内存页（内存中的概念），当这个物理内存页被 swap out 到交换区上时，就变成了 slot （内存页在交换区中的概念），现在物理内存页没了，这三个共享进程就只能在各自的页表中指向这个 slot，因此该 slot 的引用计数就是 3，对应在数组 swap_map 中的值也是 3 。</p><p><img src="/posts/29394/640-1716121323721-101.webp" alt></p><p>交换区中的第一个 slot 用于存储交换区的元信息，比如交换区对应底层各个磁盘块的坏块列表。swap_map 数组中的值表示的就是对应 slot 被多少个进程同时引用，值为 0 表示该 slot 是空闲的，下次 swap out 的时候首先查找的就是空闲 slot 。 查找范围就是 lowest_bit 到 highest_bit 之间的 slot。当查找到空闲 slot 之后，就会将整个物理内存页回写到这个 slot 中。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> swap_info_struct <span class="token punctuation">{</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>swap_map<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* vmalloc'ed array of usage counts */</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> lowest_bit<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* index of first free in swap_map */</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> highest_bit<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* index of last free in swap_map */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但是这里会有一个问题就是交换区面向的是整个系统，而系统中会有很多进程，如果多个进程并发进行 swap 的时候，swap_map 数组就会面临并发操作的问题，这样一来就不得不需要一个全局锁来保护，但是这也导致了多个 CPU 只能串行访问，大大降低了并发度。</p><p>于是内核会将锁分段，这样可以将锁竞争分散开来，大大提升并发度。将 swap_map 数组中的这些 slot，按照常量 <code>SWAPFILE_CLUSTER</code> 指定的个数，256 个 slot 分为一个 cluster。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> SWAPFILE_CLUSTER 256</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>每个 cluster 中包含一把 spinlock_t 锁，如果 cluster 是空闲的，那么 swap_cluster_info 结构中的 data 指向下一个空闲的 cluster，如果 cluster 不是空闲的，那么 data 保存的是该 cluster 中已经分配的 slot 个数。为了进一步利用 cpu cache，以及实现无锁化查找 slot，内核会给每个 cpu 分配一个 cluster —— percpu_cluster，cpu 直接从自己的 cluster 中查找空闲 slot，近一步提高了 swap out 的吞吐。当 cpu 自己的 percpu_cluster 用尽之后，内核则会调用 swap_alloc_cluster 函数从 free_clusters 中获取一个新的 cluster。</p><p>现在交换区的整体布局为大家介绍完了，这里我们把交换区 swap_info_struct 与进程的内存空间 mm_struct 放到一起一对比：</p><p>首先进程虚拟内存空间中的虚拟内存别管说的如何天花乱坠，说到底还是要保存在真实的物理内存中的，虚拟内存与物理内存通过页表来关联起来。同样的道理，别管交换区布局的如何天花乱坠，swap out 出来的数据说到底还是要保存在真实的磁盘中的，而交换区中是按照 slot 为单位进行组织管理的，磁盘中是按照磁盘块来组织管理的，大小都是 4K 。</p><p>交换区中的 slot 就好比于虚拟内存空间中的虚拟内存，都是虚拟的概念，物理内存页与磁盘块才是真实本质的东西。虚拟内存是连续的，但其背后映射的物理内存可能是不连续，交换区中的 slot 也都是连续的，但磁盘中磁盘块的扇区地址却不一定是连续的。页表可以将不连续的物理内存映射到连续的虚拟内存上，内核也需要一种机制，将不连续的磁盘块映射到连续的 slot 中。</p><p>当我们使用 <code>swapon</code> 命令来初始化激活交换区时，内核会扫描交换区中各个磁盘块的扇区地址，以确定磁盘块与扇区的对应关系，然后搜集扇区地址连续的磁盘块，将这些连续的磁盘块组成一个块组，slot 就会一个一个的映射到这些块组上，块组之间的扇区地址是不连续的，但是 slot 是连续的。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* * A swap extent maps a range of a swapfile's PAGE_SIZE pages onto a range of * disk blocks.  A list of swap extents maps the entire swapfile.  (Where the * term `swapfile' refers to either a blockdevice or an IS_REG file.  Apart * from setup, they're handled identically. * * We always assume that blocks are of size PAGE_SIZE. */</span><span class="token keyword">struct</span> swap_extent <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 红黑树节点</span>    <span class="token keyword">struct</span> rb_node rb_node<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 块组内，第一个映射的 slot 编号</span>    pgoff_t start_page<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 映射的 slot 个数</span>    pgoff_t nr_pages<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 块组内第一个磁盘块</span>    sector_t start_block<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于一个块组内的磁盘块都是连续的，slot 本来又是连续的，所以 swap_extent 结构中只需要保存映射到该块组内第一个 slot 的编号 （start_page），块组内第一个磁盘块在磁盘上的块号，以及磁盘块个数就可以了。</p><p>虚拟内存页类比 slot，物理内存页类比磁盘块，这里的 swap_extent 可以看做是虚拟内存区域 vma，进程的虚拟内存空间正是由一段一段的 vma 组成，这些 vma 被组织在一颗红黑树上。</p><p>交换区也是一样，它是由一段一段的 swap_extent 组成，同样也会被组织在一颗红黑树上。我们可以通过 slot 在交换区中的 offset，在这颗红黑树中快速查找出 slot 背后对应的磁盘块。</p><p><img src="/posts/29394/640-1716121865496-104.webp" alt></p><h3 id="10-2-swp-entry-t"><a href="#10-2-swp-entry-t" class="headerlink" title="10.2  swp_entry_t"></a>10.2  swp_entry_t</h3><p><img src="/posts/29394/640-1716121906271-107.webp" alt></p><p>匿名内存页在被内核 swap out 到磁盘上之后，内存页中的内容保存在交换区的 slot 中，在 swap in 的场景中，内核需要根据 swp_entry_t 里的信息找到这个 slot，进而找到其对应的磁盘块，然后从磁盘块中读取出被 swap out 出去的内容。</p><p>我们首先需要知道匿名内存页到底被 swap out 到哪个交换区里了，所以 swp_entry_t 里必须包含交换区在 swap_info 数组中的索引，而这个索引正是 swap_info_struct 结构中的 type 字段。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> swap_info_struct <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 该交换区在 swap_info 数组中的索引</span>    <span class="token keyword">signed</span> <span class="token keyword">char</span> type<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在确定了交换区的位置后，我们需要知道匿名页被 swap out 到交换区中的哪个 slot 中，所以 swp_entry_t 中也必须包含 slot 在交换区中的 offset，这个 offset 就是 swap_info_struct 结构里 slot 所在 swap_map 数组中的下标。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> swap_info_struct <span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>swap_map<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>所以总结下来 swp_entry_t 中需要包含以下三种信息：</p><ul><li>第一， swp_entry_t 需要标识该页表项是一个 pte 还是 swp_entry_t，因为它俩本质上是一样的，都是 <code>unsigned long</code> 类型的无符号整数，是可以相互转换的。第 0 个比特位置 1 表示是一个 pte，背后映射的物理内存页存在于内存中。如果第 0 个比特位置 0 则表示该 pte 背后映射的物理内存页已经被 swap out 出去了，那么它就是一个 swp_entry_t，指向内存页在交换区中的位置。</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> __pte_to_swp_entry(pte) ((swp_entry_t) { pte_val(pte) })</span><span class="token macro property">#<span class="token directive keyword">define</span> __swp_entry_to_pte(swp) ((pte_t) { (swp).val })</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>第二，swp_entry_t 需要包含被 swap 出去的匿名页所在交换区的索引 type，第 2 个比特位到第 7 个比特位，总共使用 6 个比特来表示匿名页所在交换区的索引。</li><li>第三，swp_entry_t 需要包含匿名页所在 slot 的位置 offset，第 8 个比特位到第 57 个比特位，总共 50 个比特来表示匿名页对应的 slot 在交换区的 offset 。</li></ul><p>内核提供了宏 <code>__swp_type</code> 用于从  swp_entry_t 中将匿名页所在交换区编号提取出来，还提供了宏 <code>__swp_offset</code> 用于从 swp_entry_t 中将匿名页所在 slot 的 offset 提取出来。先获取交换区所在磁盘分区底层的块设备，然后利用 offset 在红黑树 swap_extent_root 中查找其对应的 swap_extent。</p><p>前面我们提到过 swap file 背后所在的磁盘块不一定是连续的，而 swap file 中的 slot 却是连续的，内核需要用 swap_extent 结构来描述 slot 与磁盘块的映射关系。所以对于 swap file 来说，我们找到了 swap_extent 也就确定了 slot 对应的磁盘块了。终于我们就获得了slot 对应的磁盘块 sector_t 。有了 sector_t，内核接着就会利用 bdev_read_page 函数将 slot 对应在 sector 中的内容读取到物理内存页 page 中，这就是整个 swap in 的过程。</p><p><code>swap_readpage</code> 函数负责将匿名页中的内容从交换区中读取到物理内存页中来，这里也是 swap in  的核心实现：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">swap_readpage</span><span class="token punctuation">(</span><span class="token keyword">struct</span> page <span class="token operator">*</span>page<span class="token punctuation">,</span> bool synchronous<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> bio <span class="token operator">*</span>bio<span class="token punctuation">;</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> swap_info_struct <span class="token operator">*</span>sis <span class="token operator">=</span> <span class="token function">page_swap_info</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span>    blk_qc_t qc<span class="token punctuation">;</span>    <span class="token keyword">struct</span> gendisk <span class="token operator">*</span>disk<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 处理交换区是 swap file 的情况</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sis<span class="token operator">-></span>flags <span class="token operator">&amp;</span> SWP_FS<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 从交换区中获取交换文件 swap_file</span>        <span class="token keyword">struct</span> file <span class="token operator">*</span>swap_file <span class="token operator">=</span> sis<span class="token operator">-></span>swap_file<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// swap_file 本质上还是文件系统中的一个文件，所以它也会有 page cache</span>        <span class="token keyword">struct</span> address_space <span class="token operator">*</span>mapping <span class="token operator">=</span> swap_file<span class="token operator">-></span>f_mapping<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 利用 page cache 中的 readpage 方法，从 swap_file 所在的文件系统中读取匿名页内容到 page 中。</span>        <span class="token comment" spellcheck="true">// 注意这里只是利用 page cache 的 readpage 方法从文件系统中读取数据，内核并不会把 page 加入到 page cache 中</span>        <span class="token comment" spellcheck="true">// 这里 swap_file 和普通文件的读取过程是不一样的，page cache 不缓存内存页。</span>        <span class="token comment" spellcheck="true">// 对于 swap out 的场景来说，内核也只是利用 page cache 的 writepage 方法将匿名页的内容写入到 swap_file 中。</span>        ret <span class="token operator">=</span> mapping<span class="token operator">-></span>a_ops<span class="token operator">-></span><span class="token function">readpage</span><span class="token punctuation">(</span>swap_file<span class="token punctuation">,</span> page<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ret<span class="token punctuation">)</span>            <span class="token function">count_vm_event</span><span class="token punctuation">(</span>PSWPIN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果交换区是 swap partition，则直接从磁盘块中读取</span>    <span class="token comment" spellcheck="true">// 对于 swap out 的场景，内核调用 bdev_write_page，直接将匿名页的内容写入到磁盘块中</span>    ret <span class="token operator">=</span> <span class="token function">bdev_read_page</span><span class="token punctuation">(</span>sis<span class="token operator">-></span>bdev<span class="token punctuation">,</span> <span class="token function">swap_page_sector</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">,</span> page<span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">:</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>swap_readpage 是内核 swap 机制的最底层实现，直接和磁盘打交道，负责搭建磁盘与内存之间的桥梁。虽然直接调用 swap_readpage 可以基本完成 swap in 的目的，但在某些特殊情况下会导致 swap 的性能非常糟糕。</p><p>比如下图所示，假设当前系统中存在三个进程，它们共享引用了同一个物理内存页 page。</p><p><img src="/posts/29394/640-1716122304523-110.webp" alt></p><p>当这个被共享的 page 被内核 swap out 到交换区之后，三个共享进程的页表会发生如下变化：</p><p><img src="/posts/29394/640-1716122317587-113.webp" alt></p><p>当 进程1 开始读取这个共享 page 的时候，由于 page 已经 swap out 到交换区了，所以会发生 swap 缺页异常，进入内核通过 swap_readpage 将共享  page 的内容从磁盘中读取进内存，此时三个进程的页表结构变为下图所示：</p><p><img src="/posts/29394/640-1716122339424-116.webp" alt></p><p>现在共享 page 已经被 进程1 swap in 进来了，但是 进程2 和 进程 3 是不知道的，它们的页表中还储存的是 swp_entry_t，依然指向 page 所在交换区的位置。</p><p>按照之前的逻辑，当 进程2 以及 进程3 开始读取这个共享 page 的时候，其实 page 已经在内存了，但是它们此刻感知不到，因为 进程2 和 进程3 的页表中存储的依然是 swp_entry_t，还是会产生 swap 缺页中断，重新通过 swap_readpage 读取交换区中的内容，这样一来就产生了额外重复的磁盘 IO。</p><p>除此之外，更加严重的是，由于 进程2 和 进程3 的 swap 缺页，又会产生两个新的内存页用来存放从 swap_readpage 中读取进来的交换区数据。怎么解决这个问题呢？还有一种极端场景是一个进程试图读取一个正在被 swap out 的 page ，由于 page 正在被内核 swap out，此时进程页表指向该 page 的 pte 已经变成了 swp_entry_t。很简单，没有什么问题是加cache解决不了的。</p><h3 id="10-3-swap-cache"><a href="#10-3-swap-cache" class="headerlink" title="10.3 swap cache"></a>10.3 swap cache</h3><p>有了 swap cache 之后，情况就会变得大不相同，我们在回过头来看第一个问题 —— 多进程共享内存页。进程1 在 swap in 的时候首先会到 swap cache 中去查找，看看是否有其他进程已经把内存页 swap in 进来了，如果  swap  cache 中没有才会调用 swap_readpage 从磁盘中去读取。</p><p>当内核通过 swap_readpage 将内存页中的内容从磁盘中读取进内存之后，内核会把这个匿名页先放入 swap cache 中。进程 1 的页表将原来的 swp_entry_t 填充为 pte 并指向 swap cache 中的这个内存页。由于进程1 页表中对应的页表项现在已经从 swp_entry_t 变为 pte 了，指向的是 swap  cache 中的内存页而不是 swap 交换区，所以对应 slot 的引用计数就要减 1 。</p><p>还记得我们之前介绍的 swap_map 数组吗 ？slot 被进程引用的计数就保存在这里，现在这个 slot 在 swap_map 数组中保存的引用计数从 3 变成了 2 。表示还有两个进程也就是 进程2 和 进程3 仍在继续引用这个 slot 。</p><p>当进程2 发生 swap 缺页中断的时候进入内核之后，也是首先会到 swap cache 中查找是否现在已经有其他进程把共享的内存页 swap in 进来了，内存页 page 在 swap cache 的索引就是页表中的 swp_entry_t。由于这三个进程共享的同一个内存页，所以三个进程页表中的 swp_entry_t 都是相同的，都是指向交换区的同一位置。</p><p>由于共享内存页现在已经被 进程1 swap in 进来了，并存放在 swap cache 中，所以 进程2 通过 swp_entry_t 一下就在 swap cache 中找到了，同理，进程 2 的页表也会将原来的 swp_entry_t 填充为 pte 并指向 swap cache 中的这个内存页。slot 的引用计数减 1。</p><p><img src="/posts/29394/640-1716122481856-119.webp" alt></p><p>现在这个 slot 在 swap_map 数组中保存的引用计数从 2 变成了 1 。表示只有 进程3 在引用这个 slot 了。</p><p>当 进程3 发生 swap 缺页中断的之后，内核还是先通过 swp_entry_t 到 swap cache 中去查找，找到之后，将 进程 3 页表原来的 swp_entry_t 填充为 pte 并指向 swap cache 中的这个内存页，slot 的引用计数减 1。</p><p>现在 slot 的引用计数已经变为 0 了，这意味着所有共享该内存页的进程已经全部知道了新内存页的地址，它们的 pte 已经全部指向了新内存页，不在指向 slot 了，此时内核便将这个内存页从 swap cache 中移除。</p><p>针对第二个问题 —— 进程试图 swap in 这个正在被内核 swap out 的 page，内核的处理方法也是一样，内核在 swap out 的时候首先会在交换区中为这个 page 分配 slot 确定其在交换区的位置，通过匿名页反向映射机制找到所有引用该内存页的进程，将它们页表中的 pte 修改为指向 slot 的 swp_entry_t。</p><p>然后将匿名页 page 先是放入到 swap cache 中，慢慢地通过 swap_writepage 回写。当匿名页被完全回写到交换区中时，内核才会将 page 从 swap cache 中移除。</p><p><img src="/posts/29394/640-1716122579784-122.webp" alt></p><p>如果当内核正在回写的过程中，不巧有一个进程又要访问该内存页，同样也会发生 swap 缺页中断，但是由于此时没有回写完成，内存页还保存在 swap cache 中，内核通过进程页表中的 swp_entry_t 一下就在 swap cache 中找到了，避免了再次发生磁盘 IO，后面的过程就和第一个问题一样了。</p><h3 id="10-4-swap-预读"><a href="#10-4-swap-预读" class="headerlink" title="10.4 swap 预读"></a>10.4 swap 预读</h3><p>现在我们已经清楚了当进程虚拟内存空间中的某一段 vma 发生 swap 缺页异常之后，内核的 swap in 核心处理流程。但是整个完整的 swap 流程还没有结束，内核还需要考虑内存访问的空间局部性原理。</p><p>当进程访问某一段内存的时候，在不久之后，其附近的内存地址也将被访问。对应于本小节的 swap 场景来说，当进程地址空间中的某一个虚拟内存地址 address 被访问之后，那么其周围的虚拟内存地址在不久之后，也会被进程访问。</p><p>而那些相邻的虚拟内存地址，在进程页表中对应的页表项也都是相邻的，当我们处理完了缺页地址 address 的 swap 缺页异常之后，如果其相邻的页表项均是 swp_entry_t，那么这些相邻的 swp_entry_t 所指向交换区的内容也需要被内核预读进内存中。</p><p>这样一来，当 address 附近的虚拟内存地址发生 swap 缺页的时候，内核就可以直接从 swap cache 中读到了，避免了磁盘 IO，使得 swap in 可以快速完成，这里和文件的预读机制有点类似。</p><p>swap 预读在 Linux 内核中由 swapin_readahead 函数负责，它有两种实现方式：</p><ul><li>第一种是根据缺页地址 address 周围的虚拟内存地址进行预读，但前提是它们必须属于同一个 vma，这个逻辑在 swap_vma_readahead 函数中完成。</li><li>第二种是根据内存页在交换区中周围的磁盘地址进行预读，但前提是它们必须属于同一个交换区，这个逻辑在 swap_cluster_readahead 函数中完成。</li></ul><p>当要 swap in 的内存页在交换区的位置已经接近末尾了，则需要减少预读页的个数，防止预读超出交换区的边界。如果预读的页表项不是 swp_entry_t，则说明该页表项是一个空的还没有进行过映射或者页表项指向的内存页还在内存中，这种情况下则跳过，继续预读后面的 swp_entry_t。这样一来，经过 swap_vma_readahead 预读之后，缺页内存地址 address 周围的页表项所指向的内存页就全部被加载到 swap cache 中了。当进程下次访问 address 周围的内存地址时，虽然也会发生 swap 缺页异常，但是内核直接从 swap cache 中就可以读取到了，避免了磁盘 IO。</p><h3 id="10-5-还原-do-swap-page-完整面貌"><a href="#10-5-还原-do-swap-page-完整面貌" class="headerlink" title="10.5 还原 do_swap_page 完整面貌"></a>10.5 还原 do_swap_page 完整面貌</h3><p><img src="/posts/29394/640-1716122686964-125.webp" alt></p><p>当我们明白了前面介绍的这些背景知识之后，再回过头来看内核完整的 swap in 过程就很清晰了</p><ol><li>首先内核会通过 pte_to_swp_entry 将进程页表中的 pte 转换为 swp_entry_t</li><li>通过 lookup_swap_cache 根据 swp_entry_t 到 swap cache 中查找是否已经有其他进程将内存页 swap 进来了。</li><li>如果 swap cache 没有对应的内存页，则调用 swapin_readahead 启动预读，在这个过程中，内核会重新分配物理内存页，并将这个物理内存页加入到 swap cache 中，随后通过 swap_readpage 将交换区的内容读取到这个内存页中。</li><li>现在我们需要的内存页已经 swap in 到内存中了，后面的流程就和普通的缺页处理一样了，根据 swap in 进来的内存页地址重新创建初始化一个新的 pte，然后用这个新的 pte，将进程页表中原来的  swp_entry_t 替换掉。</li><li>为新的内存页建立反向映射关系，加入 lru active list 中，最后 swap_free 释放交换区中的资源。</li></ol><p><img src="/posts/29394/640-1716122702195-128.webp" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/posts/29394/640-1716122726438-131.webp" alt></p><p>从 Linux 内核如何通过缺页中断将进程页表从 0 到 1 一步一步的完整构建出来。从进程虚拟内存空间布局的角度来讲，缺页中断主要分为两个方面：</p><ul><li>内核态缺页异常处理 —— do_kern_addr_fault，这里主要是处理 vmalloc 虚拟内存区域的缺页异常，其中涉及到主内核页表与进程页表内核部分的同步问题。</li><li>用户态缺页异常处理 —— do_user_addr_fault，其中涉及到的主内容是如何从 0 到 1 一步一步构建完善进程页表体系。</li></ul><p>总体上来讲引起缺页中断的原因分为两大类：</p><ul><li>第一类是缺页虚拟内存地址背后映射的物理内存页不在内存中</li><li>第二类是缺页虚拟内存地址背后映射的物理内存页在内存中。</li></ul><p>第一类缺页中断的原因涉及到三种场景：</p><ol><li>缺页虚拟内存地址 address 在进程页表中间页目录对应的页目录项 pmd_t 是空的。</li><li>缺页地址 address 对应的 pmd_t 虽然不是空的，页表也存在，但是 address 对应在页表中的 pte 是空的。</li><li>虚拟内存地址 address 在进程页表中的页表项 pte 不是空的，但是其背后映射的物理内存页被内核 swap out 到磁盘上了。</li></ol><p>第二类缺页中断的原因涉及到两种场景：</p><ol><li>NUMA Balancing。</li><li>写时复制了（Copy On Write， COW）。</li></ol><p>最后我们介绍了内核整个 swap in 的完整过程，其中涉及到的重要内容包括交换区的布局以及在内核中的组织结构，swap cache 与 page cache 之间的区别，swap 预读机制。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/posts/29394/640.webp&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;无论是匿名映射还是文件映射，内核在处理 mmap 
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://JoyTsing.github.io/categories/Linux/"/>
    
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
      <category term="操作系统" scheme="https://JoyTsing.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>探究分布式架构的理论基石</title>
    <link href="https://joytsing.github.io/posts/9434/"/>
    <id>https://joytsing.github.io/posts/9434/</id>
    <published>2024-05-09T08:51:17.000Z</published>
    <updated>2024-05-09T09:14:27.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>现如今的服务已经很少是仅由单机提供的了，这些系统为了同时服务大量的客户，都需要依靠分布式系统以突破单机的瓶颈。CAP 定理决定了分布式系统天生上的限制，通过 CAP 定理我们可以理解为什么共识机制如此复杂，以及系统如何在强一致性与最终一致性间做取舍。</p><p><img src="/posts/9434/v2-5baf23193b56b3a76a987e20c84972fa_720w.webp" alt="青蛙图"></p><h3 id="分布式有多难？"><a href="#分布式有多难？" class="headerlink" title="分布式有多难？"></a>分布式有多难？</h3><p>不管设计什么架构，我们都希望满足 <strong>高性能</strong> 且 <strong>高可用</strong> 的系统，为了突破性能的瓶颈，我们从单核走向了多核，从单机走向了多机；为了防止意外造成系统无法运作，我们通过「备份」来对抗各种天灾人祸。分布式的目的就在于 <strong>突破单机的性能瓶颈</strong> 并 <strong>建立不间断的服务</strong> ，而分布式设计带来的好处，恰恰也是分布式设计的困难点。拓展阅读：<a href="https://zhuanlan.zhihu.com/p/387487859">分布式事务最经典的七种解决方案</a></p><p><img src="/posts/9434/v2-70196133172a61ad7056fdce813d5d54_r.jpg" alt></p><h2 id="CAP-定理"><a href="#CAP-定理" class="headerlink" title="CAP 定理"></a>CAP 定理</h2><h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><p><strong>一致性（C：Consistency）</strong></p><p>一致性意思就是写操作之后进行读操作无论在哪个节点都需要返回写操作的值。</p><blockquote><p>对于一个将数据副本分布在不同分布式节点上的系统来说，如果对第一个节点的数据更新后，却没有使得第二个节点上的数据得到更新，于是在对第二个节点的数据进行读取时，获取的依然是老数据，这就是典型的分布式数据不一致的情况。</p></blockquote><p><img src="/posts/9434/v2-acb72c0b044953442a914a8bae237d1e_720w.webp" alt></p><p><strong>可用性（A：Availability）</strong></p><p>指系统提供的服务一直处于可用的状态，每次请求都能获取到非错的响应（不保证获取的数据为最新数据）。</p><p><strong>分区容错性（P：Partition tolerance）</strong></p><p>分布式系统在遇到任何网络分区（个别节点通信异常）故障的时候，仍然能够对外提供服务。</p><blockquote><p>网络分区是指在分布式系统中，不同的节点分布在不同的子网络（机房或异地网络）中，由于一些特殊的原因导致这些子网络出现网络不连通的状况，但各个子网络的内部网络是正常的，从而导致整个系统的网络环境被切分成了若干个孤立的区域。</p></blockquote><p>对于分布式系统而言，网络问题是一个必定会出现的异常情况，因此分区容错性也就成为了一个分布式系统必然要解决的问题。因此往往需要根据业务特点在一致性和可用性之间寻求平衡，也就是说理论上不可能选择 CA 架构，而必须选择 CP 或 AP 架构。</p><h3 id="分布式的不可能三角-—-CAP-三元取舍"><a href="#分布式的不可能三角-—-CAP-三元取舍" class="headerlink" title="分布式的不可能三角 — CAP 三元取舍"></a>分布式的不可能三角 — CAP 三元取舍</h3><p>CAP 定理乍看之下，三个任取两个都可以，但在现实世界中，网络是最无法被保证的，所以分区容错性（P）是一定要被保障的，所以实际设计系统时，我们要在一致性（C）跟可用性（A）之间做取舍。</p><p><img src="/posts/9434/v2-67ca99570376cd4bd087f201a2a76396_720w.webp" alt></p><h3 id="强一致性-—-CP-与-ACID"><a href="#强一致性-—-CP-与-ACID" class="headerlink" title="强一致性 — CP 与 ACID"></a>强一致性 — CP 与 ACID</h3><p>ACID 是关系型数据库的基石，代表每次事务（Transaction）需要满足原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）及持久性（Durability）。CAP 定理是对于系统的描述，而 ACID 是对于事务（Transaction）的描述，虽然两种对于不同层面描述的理论不应该被放在一起讨论，但这里想强调的是 ACID 是强一致性的描述，如果在分布式情况下满足了，也等于满足了 CP 模型。</p><p>分布式要在系统层面满足强一致性，通常会使用两阶段提交（Two-Phase Commit, 2PC），通常步骤如下：</p><ol><li>使用者向协调者（Coordinator）发起一个写操作</li><li>准备阶段（Prepare Phase）: 协调者向其他所有节点询问是否可以进行此操作</li><li>执行阶段（Commit Phase）: 若所有节点都回复可以执行操作，则协调者向所有节点发送执行此操作</li></ol><p>设计两阶段提交时要注意，在准备阶段（Prepare Phase），节点如果回复「允许」进行操作，那么不管发生什么意外，节点都要能保证在执行阶段（Commit Phase）进行此操作，即使准备阶段后，节点因意外关机，节点也要在意外恢复后，也需要依据协调者的指令完成准备阶段答应的操作。另外因为是强一致性的关系，所以协调者会在执行阶段（Commit Phase）结束才回复使用者，因为如果协调者在准备阶段（Prepare Phase）结束就回复给使用者，那可能因为协调者还没发送执行信息给其他节点前，就意外关机，造成使用者接收到的信息与整个集群不一致。</p><p><img src="/posts/9434/v2-e61c06ca7974075f39582321a82ba5d9_720w.webp" alt="Prepare Phase"></p><p><img src="/posts/9434/v2-2cec963d794c8cb8e6439fb873c38bcf_720w.webp" alt="Commit Phase"></p><p>两阶段操作被应用在许多分布式算法及系统中，比较出名的像是 MySQL XA 、 Raft 等。在更复杂的情况，使用三阶段提交（Three-Phase Commit, 3PC）来解决。</p><h3 id="高可用性-—-AP-与-BASE"><a href="#高可用性-—-AP-与-BASE" class="headerlink" title="高可用性 — AP 与 BASE"></a>高可用性 — AP 与 BASE</h3><p>BASE 是 Basically Available（基本可用）、Soft State（软状态）和 Eventually Consistent（最终一致性）三个短语的缩写。BASE 理论是对 CAP 中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结。BASE 强调牺牲高一致性，从而获取可用性，数据允许在一段时间内不一致，只要保证最终一致性就可以了。</p><p>对于互联网的用户来说，如果一个系统不可用，那即使应用内部的状态有多么的一致，对用户来说都是坏掉的，所以我们很常在互联网应用中看到基础可用（Basically Available）的手法，以 微博点赞数为例，热门的贴文刚发表时，就会涌入一堆人按赞，每一次按赞对系统来说都是一次写入，如果系统为了强一致性让一部份人暂时无法写入的话，那大家一定会觉得是不是系统坏掉了，所以微博并不需要急著统计出一个精确的数字，因为对大多数人来说 8 个赞跟 10 个赞没什么区别，只要系统可以在最后保持最终一致性即可。</p><p>不过只满足了基础可用，系统还是要有方法可以恢复最终一致性（Eventually Consistent），常见的做法有读时修复（Read Repair）、写时修复（Write Repair）以及反熵（Anti-Entropy）。读时修复在读取时同时到多个节点读取，并以最新的节点为主；写时修复，同时写入多个节点，若发现有写入失败则记录下来，定时重传，直到写入成功，或是有新的写入为止；最后反熵则是定期检查状态是否一致，如果不一致则通过特定的修复顺序，修正每个节点的数据。</p><h2 id="NPC-挑战"><a href="#NPC-挑战" class="headerlink" title="NPC 挑战"></a>NPC 挑战</h2><p>NPC是<strong>Network Delay</strong>, <strong>Process Pause</strong>, <strong>Clock Drift</strong>的首字母缩写。我们先看看具体的NPC问题是什么：</p><ul><li><strong>Network Delay</strong>，网络延迟。虽然网络在多数情况下工作的还可以，虽然TCP保证传输顺序和不会丢失，但它无法消除网络延迟问题。</li><li><strong>Process Pause</strong>，进程暂停。有很多种原因可以导致进程暂停：比如编程语言中的GC（垃圾回收机制）会暂停所有正在运行的线程；再比如，我们有时会暂停云服务器，从而可以在不重启的情况下将云服务器从一台主机迁移到另一台主机。我们无法确定性预测进程暂停的时长，你以为持续几百毫秒已经很长了，但实际上持续数分钟之久进程暂停并不罕见。</li><li><strong>Clock Drift</strong>，时钟漂移。现实生活中我们通常认为时间是平稳流逝，单调递增的，但在计算机中不是。计算机使用时钟硬件计时，通常是石英钟，计时精度有限，同时受机器温度影响。为了在一定程度上同步网络上多个机器之间的时间，通常使用NTP协议将本地设备的时间与专门的时间服务器对齐，这样做的一个直接结果是设备的本地时间可能会突然向前或向后跳跃。</li></ul><h3 id="TCC的空补偿与悬挂"><a href="#TCC的空补偿与悬挂" class="headerlink" title="TCC的空补偿与悬挂"></a>TCC的空补偿与悬挂</h3><p>以分布式事务中的TCC作为例子，看看NP带来的影响。一般情况下，一个TCC回滚时的执行顺序是，先执行完Try，再执行Cancel，但是由于N，则有可能Try的网络延迟大，导致先执行Cancel，再执行Try。这种情况就引入了分布式事务中的两个难题：</p><ol><li>空补偿：Cancel执行时，Try未执行，事务分支的Cancel操作需要判断出Try未执行，这时需要忽略Cancel中的业务数据更新，直接返回</li><li>悬挂：Try执行时，Cancel已执行完成，事务分支的Try操作需要判断出Cancel一致性，这时需要忽略Try中的业务数据更新，直接返回</li></ol><p>分布式事务还有一类需要处理的常见问题，就是重复请求，业务需要做幂等处理。因为空补偿、悬挂、重复请求都跟NP有关，我们把他们统称为子事务乱序问题。在业务处理中，需要小心处理好这三种问题，否则会出现错误数据。</p><h3 id="现有方案的问题"><a href="#现有方案的问题" class="headerlink" title="现有方案的问题"></a>现有方案的问题</h3><ul><li>空补偿：“针对该问题，在服务设计时，需要允许空补偿，即在没有找到要补偿的业务主键时，返回补偿成功，并将原业务主键记录下来，标记该业务流水已补偿成功。”</li><li>防悬挂：“需要检查当前业务主键是否已经在空补偿记录下来的业务主键中存在，如果存在则要拒绝执行该笔服务，以免造成数据不一致。”</li></ul><p>上述的这种实现，能够在大部分情况下正常运行，但是上述做法中的“先查后改”在并发情况下是容易掉坑里的，我们分析一下如下场景：</p><ul><li>正常执行顺序下，Try执行时，在查完没有空补偿记录的业务主键之后，事务提交之前，如果发生了进程暂停P，或者事务内部进行网络请求出现了拥塞，导致本地事务等待较久</li><li>全局事务超时后，Cancel执行，因为没有查到要补偿的业务主键，因此判断是空补偿，直接返回</li><li>Try的进程暂停结束，最后提交本地事务</li><li>全局事务回滚完成后，Try分支的业务操作没有被回滚，产生了悬挂</li></ul><p>事实上，NPC里的P和C，以及P和C的组合，有很多种的场景，都可以导致上述竞态情况，情况发生的概率不高，但是在分布式只要有概率发生的事情那就一定会发生。当然现在也有一些更优的解决方案，如阿里开源的seata。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;现如今的服务已经很少是仅由单机提供的了，这些系统为了同时服务大量的客户，都需要依靠分布式系统以突破单机的瓶颈。CAP 定理决定了分布式系统天
      
    
    </summary>
    
    
      <category term="分布式" scheme="https://JoyTsing.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="https://JoyTsing.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis 6与多线程探析</title>
    <link href="https://joytsing.github.io/posts/24194/"/>
    <id>https://joytsing.github.io/posts/24194/</id>
    <published>2024-05-09T08:28:23.000Z</published>
    <updated>2024-05-15T09:04:18.775Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>为什么会开始像多线程转变，最大的原因还是因为两个问题：一个问题是没有办法充分发挥现代 CPU 的多核处理能力，一个实例只能使用一个核的能力。二是如果某个用户请求的处理过程卡住一段时间，会导致其它所有的请求都会出现超时的情况，所以在6.0后Reids也引入了多线程。</p><p><img src="/posts/24194/640-1715762677853-12.webp" alt="单线程"></p><h2 id="一、多线程-Redis-服务启动"><a href="#一、多线程-Redis-服务启动" class="headerlink" title="一、多线程 Redis 服务启动"></a>一、多线程 Redis 服务启动</h2><p>默认情况下多线程是默认关闭的。如果想要启动多线程，需要在配置文件中做适当的修改。相关的配置项是 io-threads 和 io-threads-do-reads 两个。</p><pre><code>io-threads 4 #启用的 io 线程数量io-threads-do-reads yes #读请求也使用io线程</code></pre><p>其中 io-threads 表示要启动的 io 线程的数量。io-threads-do-reads 表示是否在读阶段也使用 io 线程，默认是只在写阶段使用 io 线程的(避免阻塞)。现在假设我们已经打开了如上两项多线程配置。重新看一下Redis 的 main 入口函数。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: src/server.c</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 1.1 主线程初始化</span>    <span class="token function">initServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1.2 启动 io 线程</span>    <span class="token function">InitServerLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 进入事件循环</span>    <span class="token function">aeMain</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-1-主线程初始化"><a href="#1-1-主线程初始化" class="headerlink" title="1.1 主线程初始化"></a>1.1 主线程初始化</h3><p>在 initServer 这个函数内，Redis 主线程做了这么几件重要的事情。</p><p><img src="/posts/24194/640.webp" alt></p><ul><li>初始化读任务队列、写任务队列</li><li>创建一个 epoll 对象</li><li>对配置的监听端口进行 listen</li><li>把 listen socket 让 epoll 给管理起来</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: src/server.c</span><span class="token keyword">void</span> <span class="token function">initServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 1 初始化 server 对象</span>    server<span class="token punctuation">.</span>clients_pending_write <span class="token operator">=</span> <span class="token function">listCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>clients_pending_read <span class="token operator">=</span> <span class="token function">listCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 2 初始化回调 events，创建 epoll</span>    server<span class="token punctuation">.</span>el <span class="token operator">=</span> <span class="token function">aeCreateEventLoop</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxclients<span class="token operator">+</span>CONFIG_FDSET_INCR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 3 绑定监听服务端口</span>    <span class="token function">listenToPort</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>port<span class="token punctuation">,</span>server<span class="token punctuation">.</span>ipfd<span class="token punctuation">,</span><span class="token operator">&amp;</span>server<span class="token punctuation">.</span>ipfd_count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 4 注册 accept 事件处理器</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>ipfd_count<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span> server<span class="token punctuation">.</span>ipfd<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> AE_READABLE<span class="token punctuation">,</span>            acceptTcpHandler<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来我们分别来看。</p><h4 id="初始化-server-对象"><a href="#初始化-server-对象" class="headerlink" title="初始化 server 对象"></a>初始化 server 对象</h4><p>在 initServer 的一开头，先是对 server 的各种成员变量进行初始化。值得注意的是 clients_pending_write 和 clients_pending_read 这两个成员，它们分别是写任务队列和读任务队列。将来主线程产生的任务都会放在放在这两个任务队列里。</p><p>主线程会根据这两个任务队列来进行任务哈希散列，以将任务分配到多个线程中进行处理。</p><h4 id="aeCreateEventLoop-处理"><a href="#aeCreateEventLoop-处理" class="headerlink" title="aeCreateEventLoop 处理"></a>aeCreateEventLoop 处理</h4><p>aeCreateEventLoop会初始化事件回调 event，并且创建了一个 epoll 对象出来。具体创建 epoll 的过程在 ae_epoll.c 文件下的 aeApiCreate 中。在这里，真正调用了 epoll_create</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/ae_epoll.c</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">aeApiCreate</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">{</span>    aeApiState <span class="token operator">*</span>state <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>aeApiState<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    state<span class="token operator">-></span>epfd <span class="token operator">=</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     eventLoop<span class="token operator">-></span>apidata <span class="token operator">=</span> state<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="绑定监听服务端口"><a href="#绑定监听服务端口" class="headerlink" title="绑定监听服务端口"></a>绑定监听服务端口</h4><p>我们再来看 Redis 中的 listen 过程，它在 listenToPort 函数中。调用链条很长，依次是 listenToPort =&gt; anetTcpServer =&gt; _anetTcpServer =&gt; anetListen。在 anetListen 中，就是简单的 bind 和 listen 的调用。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/anet.c</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">anetListen</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">bind</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>sa<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">listen</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> backlog<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="注册事件回调函数"><a href="#注册事件回调函数" class="headerlink" title="注册事件回调函数"></a>注册事件回调函数</h4><p>前面我们调用 aeCreateEventLoop 创建了 epoll，调用 listenToPort 进行了服务端口的 bind 和 listen。接着就调用的 aeCreateFileEvent 就是来注册一个 accept 事件处理器。 aeCreateFileEvent 具体代码:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: src/ae.c</span><span class="token keyword">int</span> <span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">,</span>        aeFileProc <span class="token operator">*</span>proc<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 取出一个文件事件结构</span>    aeFileEvent <span class="token operator">*</span>fe <span class="token operator">=</span> <span class="token operator">&amp;</span>eventLoop<span class="token operator">-></span>events<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 监听指定 fd 的指定事件</span>    <span class="token function">aeApiAddEvent</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> mask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 设置文件事件类型，以及事件的处理器</span>    fe<span class="token operator">-></span>mask <span class="token operator">|</span><span class="token operator">=</span> mask<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mask <span class="token operator">&amp;</span> AE_READABLE<span class="token punctuation">)</span> fe<span class="token operator">-></span>rfileProc <span class="token operator">=</span> proc<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mask <span class="token operator">&amp;</span> AE_WRITABLE<span class="token punctuation">)</span> fe<span class="token operator">-></span>wfileProc <span class="token operator">=</span> proc<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 私有数据</span>    fe<span class="token operator">-></span>clientData <span class="token operator">=</span> clientData<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数 aeCreateFileEvent 一开始，从 eventLoop-&gt;events 获取了一个 aeFileEvent 对象。接下来调用 aeApiAddEvent。这个函数其实就是对 epoll_ctl 的一个封装。主要就是实际执行 epoll_ctl <code>EPOLL_CTL_ADD</code>。</p><p>每一个 eventLoop-&gt;events 元素都指向一个 aeFileEvent 对象。在这个对象上，设置了三个关键东西</p><ul><li>rfileProc：读事件回调</li><li>wfileProc：写事件回调</li><li>clientData：一些额外的扩展数据</li></ul><p>将来 当 epoll_wait 发现某个 fd 上有事件发生的时候，这样 redis 首先根据 fd 到 eventLoop-&gt;events 中查找 aeFileEvent 对象，然后再看 rfileProc、wfileProc 就可以找到读、写回调处理函数。</p><h3 id="1-2-io-线程启动"><a href="#1-2-io-线程启动" class="headerlink" title="1.2 io 线程启动"></a>1.2 io 线程启动</h3><p>回顾完后，接下来是重点。在主线程启动以后，会调用 InitServerLast =&gt; initThreadedIO 来创建多个 io 线程。</p><p><img src="/posts/24194/640-1715762635473-3.webp" alt></p><p>将来这些 IO 线程会配合主线程一起共同来处理所有的 read 和 write 任务。</p><p><img src="/posts/24194/640-1715762635473-4.webp" alt></p><p>我们来看 InitServerLast 创建 IO 线程的过程：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/server.c</span><span class="token keyword">void</span> <span class="token function">InitServerLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">initThreadedIO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//file:src/networking.c</span><span class="token keyword">void</span> <span class="token function">initThreadedIO</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//如果没开启多 io 线程配置就不创建了</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>io_threads_num <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//开始 io 线程的创建</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>io_threads_num<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        pthread_t tid<span class="token punctuation">;</span>        <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tid<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>IOThreadMain<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>i<span class="token punctuation">)</span>        io_threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tid<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 initThreadedIO 中调用 pthread_create 库函数创建线程，并且注册线程回调函数 IOThreadMain。 IOThreadMain将当前线程等待队列 io_threads_list[id] 里所有的请求 client，依次取出处理。其中读操作通过 readQueryFromClient 处理， 写操作通过 writeToClient 处理，其中 io_threads_list[id] 中的任务是主线程分配过来的。</p><h2 id="二、主线程事件循环"><a href="#二、主线程事件循环" class="headerlink" title="二、主线程事件循环"></a>二、主线程事件循环</h2><p>接着我们进入到 Redis 最重要的 aeMain，这个函数就是一个死循环（Redis 不退出的话），不停地执行 aeProcessEvents 函数。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">aeMain</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">{</span>    eventLoop<span class="token operator">-></span>stop <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>eventLoop<span class="token operator">-></span>stop<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">aeProcessEvents</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> AE_ALL_EVENTS<span class="token operator">|</span>                                   AE_CALL_BEFORE_SLEEP<span class="token operator">|</span>                                   AE_CALL_AFTER_SLEEP<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 aeProcessEvents 就是所谓的事件分发器。它通过调用 epoll_wait 来发现所发生的各种事件，然后调用事先注册好的处理函数进行处理。</p><p><img src="/posts/24194/640-1715763062870-15.webp" alt></p><p>接着看 aeProcessEvents 函数。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/ae.c</span><span class="token keyword">int</span> <span class="token function">aeProcessEvents</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 2.3 事件循环处理3：epoll_wait 前进行读写任务队列处理</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>eventLoop<span class="token operator">-></span>beforesleep <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> flags <span class="token operator">&amp;</span> AE_CALL_BEFORE_SLEEP<span class="token punctuation">)</span>            eventLoop<span class="token operator">-></span><span class="token function">beforesleep</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//epoll_wait发现事件并进行处理</span>    numevents <span class="token operator">=</span> <span class="token function">aeApiPoll</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> tvp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 从已就绪数组中获取事件</span>    aeFileEvent <span class="token operator">*</span>fe <span class="token operator">=</span> <span class="token operator">&amp;</span>eventLoop<span class="token operator">-></span>events<span class="token punctuation">[</span>eventLoop<span class="token operator">-></span>fired<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>fd<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果是读事件，并且有读回调函数</span>    <span class="token comment" spellcheck="true">//2.1 如果是 listen socket 读事件，则处理新连接请求</span>    <span class="token comment" spellcheck="true">//2.2 如果是客户连接socket 读事件，处理客户连接上的读请求</span>    fe<span class="token operator">-></span><span class="token function">rfileProc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//如果是写事件，并且有写回调函数</span>    fe<span class="token operator">-></span><span class="token function">wfileProc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 aeApiPoll 就是对 epoll_wait 的一个封装而已。所以aeProcessEvents 就是调用 epoll_wait 来发现事件，当发现有某个 fd 上事件发生以后，则调为其事先注册的事件处理器函数 rfileProc 和 wfileProc。</p><h3 id="2-1-事件循环处理1：新连接到达"><a href="#2-1-事件循环处理1：新连接到达" class="headerlink" title="2.1 事件循环处理1：新连接到达"></a>2.1 事件循环处理1：新连接到达</h3><p>主线程初始化的时候，将 listen socket 上的读事件处理函数注册成了 acceptTcpHandler。也就是说如果有新连接到达的时候，acceptTcpHandler 将会被执行到。</p><p><img src="/posts/24194/640-1715763179991-18.webp" alt></p><p>在这个函数内，主要完成如下几件事情。</p><ul><li>调用 accept 接收连接</li><li>创建一个 redisClient对象</li><li>添加到 epoll</li><li>注册读事件处理函数，将这个新连接的读事件处理函数设置成了 readQueryFromClient。</li></ul><h3 id="2-2-事件循环处理2：用户命令请求到达"><a href="#2-2-事件循环处理2：用户命令请求到达" class="headerlink" title="2.2 事件循环处理2：用户命令请求到达"></a>2.2 事件循环处理2：用户命令请求到达</h3><p> Redis 把用户连接上的读请求处理函数设置成了 readQueryFromClient，这意味着当用户连接上有命令发送过来的时候，会进入 readQueryFromClient 开始执行。在多线程版本的 readQueryFromClient 中，处理逻辑非常简单，仅仅只是将发生读时间的 client 放到了任务队列里而已。</p><p><img src="/posts/24194/640-1715763235459-21.webp" alt></p><p>来详细看 readQueryFromClient 代码。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/networking.c</span><span class="token keyword">void</span> <span class="token function">readQueryFromClient</span><span class="token punctuation">(</span>connection <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token punctuation">{</span>    client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">connGetPrivateData</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果启动 threaded I/O 的话，直接入队</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">postponeClientRead</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//处理用户连接读请求</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    c<span class="token operator">-></span>querybuf <span class="token operator">=</span> <span class="token function">sdsMakeRoomFor</span><span class="token punctuation">(</span>c<span class="token operator">-></span>querybuf<span class="token punctuation">,</span> readlen<span class="token punctuation">)</span><span class="token punctuation">;</span>    nread <span class="token operator">=</span> <span class="token function">connRead</span><span class="token punctuation">(</span>c<span class="token operator">-></span>conn<span class="token punctuation">,</span> c<span class="token operator">-></span>querybuf<span class="token operator">+</span>qblen<span class="token punctuation">,</span> readlen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">processInputBuffer</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 postponeClientRead 中判断，是不是开启了多 io 线程，如果开启了的话，那就将有请求数据到达的 client 直接放到读任务队列（server.clients_pending_read）中就算是完事。</p><h3 id="2-3-事件循环处理3：epoll-wait-前进行任务处理"><a href="#2-3-事件循环处理3：epoll-wait-前进行任务处理" class="headerlink" title="2.3 事件循环处理3：epoll_wait 前进行任务处理"></a>2.3 事件循环处理3：epoll_wait 前进行任务处理</h3><p>在 aeProcessEvents 中假如 aeApiPoll(epoll_wait)中的事件都处理完了以后，则会进入下一次的循环再次进入 aeProcessEvents。而这一次中 beforesleep 将会处理前面读事件处理函数添加的读任务队列了。</p><p>在 beforeSleep 里会依次处理两个任务队列。先处理读任务队列，解析其中的请求，并处理之。然后将处理结果写到缓存中，同时写到写任务队列中。紧接着 beforeSleep 会进入写任务队列处理，会将处理结果写到 socket 里，进行真正的数据发送。</p><p><img src="/posts/24194/640-1715763342627-24.webp" alt></p><p> beforeSleep 的代码，这个函数中最重要的两个调用是 handleClientsWithPendingReadsUsingThreads（处理读任务队列），handleClientsWithPendingWritesUsingThreads（处理写任务队列）</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/server.c</span><span class="token keyword">void</span> <span class="token function">beforeSleep</span><span class="token punctuation">(</span><span class="token keyword">struct</span> aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//处理读任务队列</span>    <span class="token function">handleClientsWithPendingReadsUsingThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//处理写任务队列</span>    <span class="token function">handleClientsWithPendingWritesUsingThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>值得注意的是，如果开启了多 io 线程的话，handleClientsWithPendingReadsUsingThreads 和 handleClientsWithPendingWritesUsingThreads 中将会是主线程、io 线程一起配合来处理的。</p><h2 id="三、主线程-amp-amp-io-线程处理读请求"><a href="#三、主线程-amp-amp-io-线程处理读请求" class="headerlink" title="三、主线程 &amp;&amp; io 线程处理读请求"></a>三、主线程 &amp;&amp; io 线程处理读请求</h2><p>在 handleClientsWithPendingReadsUsingThreads 中，主线程会遍历读任务队列 server.clients_pending_read，把其中的请求分配到每个 io 线程的处理队列 io_threads_list[target_id] 中。然后通知各个 io 线程开始处理。</p><p><img src="/posts/24194/640-1715763385277-27.webp" alt="图片"></p><h3 id="3-1-主线程分配任务"><a href="#3-1-主线程分配任务" class="headerlink" title="3.1 主线程分配任务"></a>3.1 主线程分配任务</h3><p> handleClientsWithPendingReadsUsingThreads 详细代码。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/networking.c</span><span class="token comment" spellcheck="true">//当开启了 reading + parsing 多线程 I/O </span><span class="token comment" spellcheck="true">//read handler 仅仅只是把 clients 推到读队列里</span><span class="token comment" spellcheck="true">//而这个函数开始处理该任务队列</span><span class="token keyword">int</span> <span class="token function">handleClientsWithPendingReadsUsingThreads</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//访问读任务队列 server.clients_pending_read</span>    <span class="token function">listRewind</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_read<span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//把每一个任务取出来</span>    <span class="token comment" spellcheck="true">//添加到指定线程的任务队列里 io_threads_list[target_id]</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> target_id <span class="token operator">=</span> item_id <span class="token operator">%</span> server<span class="token punctuation">.</span>io_threads_num<span class="token punctuation">;</span>        <span class="token function">listAddNodeTail</span><span class="token punctuation">(</span>io_threads_list<span class="token punctuation">[</span>target_id<span class="token punctuation">]</span><span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        item_id<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//启动Worker线程，处理读请求</span>    io_threads_op <span class="token operator">=</span> IO_THREADS_OP_READ<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>io_threads_num<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token function">listLength</span><span class="token punctuation">(</span>io_threads_list<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setIOPendingCount</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//主线程处理 0 号任务队列</span>    <span class="token function">listRewind</span><span class="token punctuation">(</span>io_threads_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//需要先干掉 CLIENT_PENDING_READ 标志</span>        <span class="token comment" spellcheck="true">//否则 readQueryFromClient 并不处理，而是入队</span>        client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">readQueryFromClient</span><span class="token punctuation">(</span>c<span class="token operator">-></span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//主线程等待其它线程处理完毕</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> pending <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>io_threads_num<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            pending <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">getIOPendingCount</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pending <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//再跑一遍任务队列，目的是处理输入</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">listLength</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_read<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token function">processInputBuffer</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>c<span class="token operator">-></span>flags <span class="token operator">&amp;</span> CLIENT_PENDING_WRITE<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">clientHasPendingReplies</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">clientInstallWriteHandler</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在主线程中将任务分别放到了 io_threads_list 的第 0 到第 N 个元素里。并对 1 : N 号线程通过 setIOPendingCount 发消息，告诉他们起来处理。这时候 io 线程将会在 IOThreadMain 中收到消息并开始处理读任务。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/networking.c</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">IOThreadMain</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>myid<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//遍历当前线程等待队列里的请求 client</span>        <span class="token function">listRewind</span><span class="token punctuation">(</span>io_threads_list<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>io_threads_op <span class="token operator">==</span> IO_THREADS_OP_WRITE<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">writeToClient</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>io_threads_op <span class="token operator">==</span> IO_THREADS_OP_READ<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">readQueryFromClient</span><span class="token punctuation">(</span>c<span class="token operator">-></span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token function">serverPanic</span><span class="token punctuation">(</span><span class="token string">"io_threads_op value is unknown"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 io 线程中，从自己的 io_threads_list[id] 中遍历获取待处理的 client。如果发现是读请求处理，则进入 readQueryFromClient 开始处理特定的 client。而主线程在分配完 1 ：N 任务队列让其它 io 线程处理后，自己则开始处理第 0 号任务池。同样是会进入到 readQueryFromClient 中来执行。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/networking.c</span><span class="token keyword">int</span> <span class="token function">handleClientsWithPendingReadsUsingThreads</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">//主线程处理 0 号任务队列</span>    <span class="token function">listRewind</span><span class="token punctuation">(</span>io_threads_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//需要先干掉 CLIENT_PENDING_READ 标志</span>        <span class="token comment" spellcheck="true">//否则 readQueryFromClient 并不处理，而是入队</span>        client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">readQueryFromClient</span><span class="token punctuation">(</span>c<span class="token operator">-></span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以无论是主线程还是 io 线程，处理客户端的读事件都是会进入 readQueryFromClient。</p><h3 id="3-2-读请求处理"><a href="#3-2-读请求处理" class="headerlink" title="3.2 读请求处理"></a>3.2 读请求处理</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/networking.c</span><span class="token keyword">void</span> <span class="token function">readQueryFromClient</span><span class="token punctuation">(</span>connection <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//读取请求</span>    nread <span class="token operator">=</span> <span class="token function">connRead</span><span class="token punctuation">(</span>c<span class="token operator">-></span>conn<span class="token punctuation">,</span> c<span class="token operator">-></span>querybuf<span class="token operator">+</span>qblen<span class="token punctuation">,</span> readlen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//处理请求</span>    <span class="token function">processInputBuffer</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 connRead 中就是调用 read 将 socket 中的命令读取出来。接着在 processInputBuffer 中将输入缓冲区中的数据解析成对应的命令。解析完命令后真正开始处理它。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/networking.c</span><span class="token keyword">void</span> <span class="token function">processInputBuffer</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>c<span class="token operator">-></span>qb_pos <span class="token operator">&lt;</span> <span class="token function">sdslen</span><span class="token punctuation">(</span>c<span class="token operator">-></span>querybuf<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//解析命令</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true">//真正开始处理 command</span>        <span class="token function">processCommandAndResetClient</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数 processCommandAndResetClient 会调用 processCommand，查询命令并开始执行，执行的核心方法是 call 函数。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/server.c</span><span class="token keyword">void</span> <span class="token function">call</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 查找处理命令，</span>    <span class="token keyword">struct</span> redisCommand <span class="token operator">*</span>real_cmd <span class="token operator">=</span> c<span class="token operator">-></span>cmd<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用命令处理函数</span>    c<span class="token operator">-></span>cmd<span class="token operator">-></span><span class="token function">proc</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-写处理结果到发送缓存区"><a href="#3-3-写处理结果到发送缓存区" class="headerlink" title="3.3 写处理结果到发送缓存区"></a>3.3 写处理结果到发送缓存区</h3><p>其主体是调用 addReply 来设置回复数据。在 addReply 方法中做了两件事情：</p><ul><li>prepareClientToWrite 判断是否需要返回数据，并且将当前 client 添加到等待写返回数据队列中。</li><li>调用 _addReplyToBuffer 和 _addReplyObjectToList 方法将返回值写入到输出缓冲区中，等待写入 socekt</li></ul><p>读请求处理过程是主线程和 io 线程在并行执行的。主线程在处理完后会等待其它的 io 线程处理。在所有的读请求都处理完后，主线程 beforeSleep 中对 handleClientsWithPendingReadsUsingThreads 的调用就结束了。</p><h2 id="四、主线程-amp-amp-io-线程配合处理写请求"><a href="#四、主线程-amp-amp-io-线程配合处理写请求" class="headerlink" title="四、主线程 &amp;&amp; io 线程配合处理写请求"></a>四、主线程 &amp;&amp; io 线程配合处理写请求</h2><p>当所有的读请求处理完后，handleClientsWithPendingReadsUsingThreads 会退出。主线程会紧接着进入 handleClientsWithPendingWritesUsingThreads 中来处理。</p><p><img src="/posts/24194/640-1715763641211-30.webp" alt></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/server.c</span><span class="token keyword">void</span> <span class="token function">beforeSleep</span><span class="token punctuation">(</span><span class="token keyword">struct</span> aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//处理读任务队列</span>    <span class="token function">handleClientsWithPendingReadsUsingThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//处理写任务队列</span>    <span class="token function">handleClientsWithPendingWritesUsingThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-1-主线程分配任务"><a href="#4-1-主线程分配任务" class="headerlink" title="4.1 主线程分配任务"></a>4.1 主线程分配任务</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/networking.c</span><span class="token keyword">int</span> <span class="token function">handleClientsWithPendingWritesUsingThreads</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//没有开启多线程的话，仍然是主线程自己写</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>io_threads_num <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> <span class="token function">stopThreadedIOIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">handleClientsWithPendingWrites</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">//获取待写任务</span>    <span class="token keyword">int</span> processed <span class="token operator">=</span> <span class="token function">listLength</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_write<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//在N个任务列表中分配该任务</span>    listIter li<span class="token punctuation">;</span>    listNode <span class="token operator">*</span>ln<span class="token punctuation">;</span>    <span class="token function">listRewind</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_write<span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> item_id <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>        c<span class="token operator">-></span>flags <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token operator">~</span>CLIENT_PENDING_WRITE<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* Remove clients from the list of pending writes since         * they are going to be closed ASAP. */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>flags <span class="token operator">&amp;</span> CLIENT_CLOSE_ASAP<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">listDelNode</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_write<span class="token punctuation">,</span> ln<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//hash的方式进行分配</span>        <span class="token keyword">int</span> target_id <span class="token operator">=</span> item_id <span class="token operator">%</span> server<span class="token punctuation">.</span>io_threads_num<span class="token punctuation">;</span>        <span class="token function">listAddNodeTail</span><span class="token punctuation">(</span>io_threads_list<span class="token punctuation">[</span>target_id<span class="token punctuation">]</span><span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        item_id<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//告诉对应的线程该开始干活了</span>    io_threads_op <span class="token operator">=</span> IO_THREADS_OP_WRITE<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>io_threads_num<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token function">listLength</span><span class="token punctuation">(</span>io_threads_list<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setIOPendingCount</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//主线程自己也会处理一些</span>    <span class="token function">listRewind</span><span class="token punctuation">(</span>io_threads_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">writeToClient</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">listEmpty</span><span class="token punctuation">(</span>io_threads_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//循环等待其它线程结束处理</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> pending <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>io_threads_num<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            pending <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">getIOPendingCount</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pending <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 io 线程中收到消息后，开始遍历自己的任务队列 io_threads_list[id]，并将其中的 client 挨个取出来开始处理。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/networking.c</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">IOThreadMain</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>myid<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//遍历当前线程等待队列里的请求 client</span>        <span class="token function">listRewind</span><span class="token punctuation">(</span>io_threads_list<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>io_threads_op <span class="token operator">==</span> IO_THREADS_OP_WRITE<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">writeToClient</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>io_threads_op <span class="token operator">==</span> IO_THREADS_OP_READ<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">readQueryFromClient</span><span class="token punctuation">(</span>c<span class="token operator">-></span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>         <span class="token punctuation">}</span>        <span class="token function">listEmpty</span><span class="token punctuation">(</span>io_threads_list<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-写请求处理"><a href="#4-2-写请求处理" class="headerlink" title="4.2 写请求处理"></a>4.2 写请求处理</h3><p>由于这次任务队列里都是写请求，所以 io 线程会进入 writeToClient。而主线程在分配完任务以后，自己开始处理起了 io_threads_list[0]，并也进入到 writeToClient。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file:src/networking.c</span><span class="token keyword">int</span> <span class="token function">writeToClient</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> client <span class="token operator">*</span>c<span class="token punctuation">,</span> <span class="token keyword">int</span> handler_installed<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">clientHasPendingReplies</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 先发送固定缓冲区</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>bufpos <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            nwritten <span class="token operator">=</span> <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>c<span class="token operator">-></span>buf<span class="token operator">+</span>c<span class="token operator">-></span>sentlen<span class="token punctuation">,</span>c<span class="token operator">-></span>bufpos<span class="token operator">-</span>c<span class="token operator">-></span>sentlen<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nwritten <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true">// 再发送回复链表中数据</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            o <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span><span class="token function">listFirst</span><span class="token punctuation">(</span>c<span class="token operator">-></span>reply<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            nwritten <span class="token operator">=</span> <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> o<span class="token operator">-></span>buf <span class="token operator">+</span> c<span class="token operator">-></span>sentlen<span class="token punctuation">,</span> objlen <span class="token operator">-</span> c<span class="token operator">-></span>sentlen<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>writeToClient 中的主要逻辑就是调用 write 系统调用让内核帮其把数据发送出去即可。由于每个命令的处理结果大小是不固定的。所以 Redis 采用的做法用固定的 buf + 可变链表来储存结果字符串。这里自然发送的时候就需要分别对固定缓存区和链表来进行发送了。</p><p>当所有的写请求也处理完后，beforeSleep 就退出了。主线程将会再次调用 epoll_wait 来发现请求，进入下一轮的用户请求处理。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: src/server.c</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 1.1 主线程初始化</span>    <span class="token function">initServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1.2 启动 io 线程</span>    <span class="token function">InitServerLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 进入事件循环</span>    <span class="token function">aeMain</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 initServer 这个函数内，Redis 做了这么三件重要的事情。</p><ul><li>创建一个 epoll 对象</li><li>对配置的监听端口进行 listen</li><li>把 listen socket 让 epoll 给管理起来</li></ul><p>在 initThreadedIO 中调用 pthread_create 库函数创建线程，并且注册线程回调函数 IOThreadMain。在 IOThreadMain 中等待其队列 io_threads_list[id] 产生请求，当有请求到达的时候取出 client，依次处理。其中读操作通过 readQueryFromClient 处理， 写操作通过 writeToClient 处理。</p><p>主线程在 aeMain 函数中，是一个无休止的循环，它是 Redis 中最重要的部分。它先是调用事件分发器发现事件。如果有新连接请求到达的时候，执行 accept 接收新连接，并为其注册事件处理函数。</p><p>当用户连接上有命令请求到达的时候，主线程在 read 处理函数中将其添加到读发送队列中。然后接着在 beforeSleep 中开启对读任务队列和写任务队列的处理。总体工作过程如下图所示。</p><p><img src="/posts/24194/640-1715763674958-33.webp" alt></p><p>在这个处理过程中，对读任务队列和写任务队列的处理都是多线程并行进行的（前提是开篇我们开启了多 IO 线程并且也并发处理读）。当读任务队列和写任务队列的都处理完的时候，主线程再一次调用 epoll_wait 去发现新的待处理事件，如此往复循环进行处理。</p><p>但这并不是说就不会阻塞了，原因是主线程是在处理读、写任务队列的时候还要等待其它的 io 线程处理完才能进入下一步。假设这时有 10 个用户请求到达，其中 9 个处理耗时需要 1 ms，而另外一个命令需要 1 s。则这时主线程仍然会等待这个 io 线程处理 1s 结束后才能进入后面的处理。整个 Redis 服务还是被一个耗时的命令给 block 住了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;为什么会开始像多线程转变，最大的原因还是因为两个问题：一个问题是没有办法充分发挥现代 CPU 的多核处理能力，一个实例只能使用一个核的能力。
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://JoyTsing.github.io/categories/Redis/"/>
    
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
      <category term="Redis" scheme="https://JoyTsing.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL技术内幕-InnoDB存储引擎(三)</title>
    <link href="https://joytsing.github.io/posts/47027/"/>
    <id>https://joytsing.github.io/posts/47027/</id>
    <published>2024-05-07T12:38:06.000Z</published>
    <updated>2024-05-14T13:46:51.716Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>可以说是核心部分了，很多时候我们谈数据库其实大部分时间谈的都是其存储引擎。</p><h2 id="一-索引算法"><a href="#一-索引算法" class="headerlink" title="一.索引算法"></a>一.索引算法</h2><h3 id="1-1-B-树"><a href="#1-1-B-树" class="headerlink" title="1.1 B+树"></a>1.1 B+树</h3><p>就不在这科普了，可以看看相关的文章。</p><h4 id="1-1-1-B-树索引"><a href="#1-1-1-B-树索引" class="headerlink" title="1.1.1 B+树索引"></a>1.1.1 B+树索引</h4><p>B+树索引在数据库当中有一个特点是<strong>高扇出性</strong>，其高度一般在2 ~ 4层，也就是说查找某一个键值的行记录时最多只需要2 ~ 4次IO。B+树索引可以分为聚簇索引和辅助索引。</p><h5 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h5><p><strong>聚簇索引就是按照每张表的主键构造一颗B+树，叶子节点存放的是整张表的行记录数据</strong>，其叶子节点也称为数据页，而在非数据页的索引页中，存放的仅仅是键值以及指向数据页的偏移量，此外，每个数据页都通过一个双向链表来进行连接。由于实际的数据页只能按照一颗B+树进行排序，因此每张表只能拥有一个聚簇索引。</p><p>聚簇索引的存储并不是物理上连续的，而是逻辑上连续的，其中包含两点：</p><ul><li>页通过双向列表连接，页按照主键的顺序排序。</li><li><strong>每个页中的记录也是通过双向链表进行维护的，物理存储上可以同样不按照主键存储。</strong></li></ul><p>聚簇索引的好处：</p><ul><li>对于主键的排序查找和范围查找速度非常快，<strong>因为叶子节点的数据就是用户所需要查询的数据。</strong></li><li>如果想要查找主键某一范围内的数据，<strong>通过叶子节点的上层中间节点就可以得到页的范围，之后直接读取数据页即可。</strong></li></ul><h5 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h5><p>辅助索引也就是非聚簇索引，<strong>叶子节点不包含行记录的全部数据</strong>。叶子节点除了包含键值以外，每个叶子节点的索引行中还包含了一个书签（bookmark）</p><blockquote><p>书签：<strong>用来告诉InnoDB存储引擎哪里可以找到与索引相对应的行数据，书签作为一个行标识符（Row Identified RID），可以用如“文件号：页号：槽号”的格式来定位实际的行数据。</strong></p><p>由于InnoDB存储引擎表是索引组织表，因此InnoDB存储引擎的辅助索引的书签就是相对应的行数据的聚簇索引键。</p></blockquote><p>大家知道，聚簇索引是顺序读，非聚簇索引是离散读，<strong>而一般数据库就通过预读的方式来避免多次的离散操作。</strong></p><h4 id="1-1-2-B-树索引的分裂"><a href="#1-1-2-B-树索引的分裂" class="headerlink" title="1.1.2 B+树索引的分裂"></a>1.1.2 B+树索引的分裂</h4><p>首先大家应该了解到，B+树的索引页的分裂并不总是从页的中间记录开始，因为这样可能导致页空间的浪费，举个例子：</p><blockquote><p>数据页中的记录为：1，2，3，4，5，6，7，8，9。此时要插入记录10<br>假设插入操作会引起页的分裂，那么此时会将记录5作为分裂点记录，分裂后得到两个页：<br>P1：1，2，3，4<br>P2：5，6，7，8，9，10<br>又因为<strong>插入是根据自增顺序进行的，P1这个也中将不会在有记录被插入，从而导致空间的浪费</strong>，而P2又会再次进行分裂（当需要分裂的时候）。</p></blockquote><p>然后对于InnoDB存储引擎而言，<strong>通过Page Header保存的插入顺序信息来决定是向左还是向右进行分裂，同时决定将哪一个点作为分裂点（若插入是随机的，则取页的中检记录作为分裂点的记录），</strong> 保存的信息如下：</p><ul><li>PAGE_LAST_INSERT</li><li>PAGE_DIRECTION</li><li>PAGE_N_DIRECTION</li></ul><h4 id="1-1-3-B-树索引的管理"><a href="#1-1-3-B-树索引的管理" class="headerlink" title="1.1.3 B+树索引的管理"></a>1.1.3 B+树索引的管理</h4><h5 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h5><p>索引的创建和删除可以通过两种方法：</p><ul><li>Alter Table</li></ul><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token punctuation">[</span>表名<span class="token punctuation">]</span> <span class="token keyword">ADD</span> <span class="token punctuation">[</span><span class="token keyword">INDEX</span> <span class="token operator">|</span> <span class="token keyword">key</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>索引名称<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">[</span>需要加索引的列名称<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>Create/Drop Index</li></ul><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> <span class="token punctuation">[</span>索引名称<span class="token punctuation">]</span> <span class="token keyword">on</span> <span class="token punctuation">[</span>表名<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">[</span>需要加索引的列名称<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如，我有一张login表(主键为id)：<br><img src="/posts/47027/20201215151943898.png" alt><br>我通过两种方式进行添加索引：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># username(10)表示只对前10个字段索引</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> login <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> myindex<span class="token punctuation">(</span>username<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>；<span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> unioIndex <span class="token keyword">on</span> login<span class="token punctuation">(</span>username<span class="token punctuation">,</span>login_time<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以通过命令<code>SHOW INDEX FROM [表名];</code>的方式查看索引信息</p><p>参考表：</p><table><thead><tr><th>属性名</th><th>含义</th></tr></thead><tbody><tr><td>Table</td><td>索引所在的表名</td></tr><tr><td>Non_unique</td><td>非唯一的索引，可以看到primary key是0，因为其必须是唯一</td></tr><tr><td>Key_name</td><td>索引的名字，用户可以通过这个名字来执行Drop Index</td></tr><tr><td>Seq_in_index</td><td>索引中该列的位置（直观的看联合索引）</td></tr><tr><td>Column_name</td><td>索隐列的名称</td></tr><tr><td>Collation</td><td>列以什么方式存储在索引中，可以为A（B+树索引总是A）或者NULL（使用Heap存储引擎并且简历了Hash索引）</td></tr><tr><td><strong>Cardinality</strong></td><td>很重要，表示索引中唯一值的数目的估计值，需要其尽可能接近1，若非常小，可以考虑删除该索引</td></tr><tr><td>Sub_part</td><td>是否是列的部分被索引,参考username(10)</td></tr><tr><td>Packed</td><td>关键字如何被压缩，若没有被压缩，则为NULL</td></tr><tr><td>Null</td><td>是否索引的列中含有Null值</td></tr><tr><td>Index_type</td><td>索引的类型，包含BTREE和HASH</td></tr><tr><td>Comment</td><td>注释</td></tr></tbody></table><p>Cardinality这个值非常关键，优化器会根据这个值来判断是否使用这个索引。这个值是不太准确的，也并非实时更新，若需要更新索引Cardinality的信息，可以使用<code>ANALYZE TABLE [表名];</code>进行刷新。</p><h5 id="Fast-Index-Creation（FIC）"><a href="#Fast-Index-Creation（FIC）" class="headerlink" title="Fast Index Creation（FIC）"></a>Fast Index Creation（FIC）</h5><p>在Mysql5.5版本之前，Mysql数据库对于索引的添加或者删除的这类DDL操作，其操作过程为：</p><ol><li>首先创建一张新的临时表，表结构为通过命令Alter Table新定义的结构。</li><li>然后把原表中的数据导入到临时表中。</li><li>接着删除原表。</li><li>最后把临时表重命名为原来的表名。</li></ol><p>那么，如果一张表存放着大量的数据，进行删除或者添加索引的操作，这肯定会消耗很长的时间。因此有了一种快速索引创建的方式：FIC。</p><blockquote><p>对于辅助索引的创建，<strong>InnoDB存储引擎会对创建索引的表加上一个S锁</strong>。而在创建过程中，不需要新建一个临时表。<br>对于其删除，<strong>InnoDB存储引擎只需要更新内部视图，并将辅助索引的空间标记为可用，同时删除Mysql数据库内部视图上对该表的索引定义即可。</strong></p></blockquote><p><strong>注意：<br>FIC方式只限定于辅助索引，对主键的创建和删除同样需要重建一张表。</strong></p><h3 id="1-2-Cardinality值"><a href="#1-2-Cardinality值" class="headerlink" title="1.2 Cardinality值"></a>1.2 Cardinality值</h3><p>先来说下什么时候用B+树索引？在访问表中很少一部分时使用B+树索引才有意义，对于性别字段这一类取值范围小的，也就是低选择性的，添加B+树索引是没有必要的。那么怎样查看索引是否是高选择性呢？通过Cardinality来观察。</p><p>Cardinality表示索引中不重复记录数量的<strong>预估值</strong>，在InnoDB存储引擎中，Cardinality统计信息的更新发生在两个操作中：<code>INSERT</code>和<code>UPDATE</code>。但同时，也不可能每次发生这俩操作就去更新Cardinality信息，这样会增加数据库系统的负荷。因此InnoDB存储引擎有一个更新策略：</p><ul><li>表中1/16的数据已发生过变化。</li><li>stat_modified_counter（表示发生变化的次数） &gt; 2 000 000 000。</li></ul><p>再来说一下Cardinality的统计，通过<strong>采样</strong>的方法来完成：</p><ol><li>取得B+树索引中叶子节点的数量，记为A。</li><li>随机取得B+树索引中的8个叶子节点，统计每个页不同记录的个数，记为P1,P2……P8。</li><li>根据采样信息给出Cardinality的预估值：Cardinality=（P1+P2……+P8）*A/8</li></ol><p>备注：<strong>InnoDB存储引擎默认对8个叶子节点进行采用。</strong></p><h3 id="1-3-B-树索引的使用"><a href="#1-3-B-树索引的使用" class="headerlink" title="1.3 B+树索引的使用"></a>1.3 B+树索引的使用</h3><p><strong>联合索引</strong><br>联合索引是指对表上的多个列进行索引。例如：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> test<span class="token punctuation">(</span>    <span class="token number">a</span> <span class="token keyword">INT</span><span class="token punctuation">,</span>    <span class="token number">b</span> <span class="token keyword">INT</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token number">a</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> unioIdx<span class="token punctuation">(</span><span class="token number">a</span><span class="token punctuation">,</span><span class="token number">b</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 联合索引</span><span class="token punctuation">)</span><span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">INNODB</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>联合索引的构造：<br>从本质来说，联合索引也是一颗B+树，但不同的是联合索引的简直的数量不是1，而是大于等于2。</p><p>下面假设给定两个键值的名称，分别为a，b，使用B+树索引，如图：<img src="/posts/47027/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pvbmdfMDkxNQ==,size_16,color_FFFFFF,t_70.png" alt><br>那么数据（1，1）,（1，2）,（2，1）,（2，4）,（1，1）,（3，2）是根据（a，b)的顺序进行存放的，这里直接说结论：</p><ul><li>对于查询<code>select * from table where a=xxx and b=xxx</code>是可以使用联合索引（a，b）的。</li><li>对于单个的a列查询<code>select * from table where a=xxx</code>也可以使用联合索引（a，b）的。</li><li>对于单个b列查询<code>select * from table where b=xxx</code>不可以使用B+树索引。（因为每个数据对的第二个数字单独拿出来的顺序是：1，2，1，4，1，2显然不是排序的）</li></ul><p>那么回过头说联合索引，<strong>联合索引的好处就是对上述情况的第二个键值进行了排序处理。</strong></p><p><strong>覆盖索引</strong><br>覆盖索引即：<strong>从辅助索引中就可以得到查询的记录，而不需要查询聚集索引中的记录。</strong></p><p>其次，我们知道辅助索引不包含整行记录的所有信息，<strong>因此其大小要远小于聚簇索引，因此可以减少大量IO的操作。</strong></p><h3 id="1-4-InnoDB中的哈希算法"><a href="#1-4-InnoDB中的哈希算法" class="headerlink" title="1.4 InnoDB中的哈希算法"></a>1.4 InnoDB中的哈希算法</h3><p>InnoDB存储引擎中：</p><ul><li><strong>使用哈希算法来对字典进行查找。</strong></li><li><strong>哈希的冲突机制（哈希碰撞）使用链表方式解决</strong>。</li><li><strong>哈希函数采用除法散列方式。</strong></li></ul><blockquote><p>对于缓冲池页的哈希表来说，在缓冲池中的Page页都有一个chain指针，它指向相同哈希函数值的页。<br>对于除法散列来说，m（槽数）的取值为略大于2倍的缓冲池页数量的质数。<br>例如：若当前缓冲池大小为10M，则共有640个16KB的页，对于哈希表来说，需要分配640*2=1280个槽，然后离1280最近的质数为1399，那么在启动的时候会分配1399个槽的哈希表，用来哈希查询所在缓冲池中的页。</p></blockquote><p>InnoDB存储引擎的缓冲池对于其中的页是怎么进行查找的？</p><blockquote><p>InnoDB存储引擎的表空间都有一个space_id，用户所要查询的应该是某个表空间的某个连续16KB的页，即偏移量offset。InnoDB存储引擎将space_id左移20位，然后加上这个space_id和offset，即关键字<code>K=space_id&lt;&lt;20+space_id+offset</code>，然后通过除法散列到各个槽中。</p></blockquote><h3 id="1-5-InnoDB全文检索"><a href="#1-5-InnoDB全文检索" class="headerlink" title="1.5 InnoDB全文检索"></a>1.5 InnoDB全文检索</h3><p><strong>全文检索通常使用倒排索引来实现。它在辅助表中存储了单词与单词自身在一个或者多个文档所在位置之间的映射。</strong> 这通常利用关联数组来实现，拥有两种表现形式：</p><ul><li>inverted file index：表现形式为：{单词，单词所在文档的ID}</li><li>full inverted index：表现形式为：{单词，(单词所在文档的ID，在具体文档中的位置)}</li></ul><p>Mysql在1.2.x版本开始，才开始支持全文检索，采用的是<code>full inverted index</code>的方式。</p><blockquote><p>在InnoDB存储引擎中，<strong>将(DocumentId，Position)视为一个ilist</strong>。因此在全文检索的表中，有两个列，一个是word字段，一个是ilist字段，<strong>并且在word字段上有索引。</strong><br>此外，<strong>InnoDB存储引擎在ilist字段中存放了Position信息（存储位置），因此可以进行Proximity Search(近似搜索)</strong>，比如<code>SELECT * from login where username LIKE &#39;%3&#39;;</code></p></blockquote><p><strong>倒排索引需要将word存放在一张表上，这个表叫做Auxiliary Table（辅助表），并且共有6张表，存放于磁盘上。</strong></p><p>InnoDB中的全文索引有俩重要概念：</p><ul><li>FTS Index Cache：全文检索索引缓存。</li></ul><blockquote><p>FTS Index Cache是一个<strong>红黑树结构</strong>，根据（word，ilist）进行排序，<strong>意味着插入的数据已经更新了对应的表。</strong> 同时，在缓存中的word字段要想合并到Auxiliary Table（辅助表，存放word的表）中，这个合并过程类似于前面文章讲的Insert Buffer，<strong>批量插入。</strong><br>当然，当需要进行全文检索的时候，辅助表会先把缓存中的word整合在一起，再从表中查询结果。</p></blockquote><ul><li>FTS Document ID：</li></ul><blockquote><p>为了支持全文检索，必须有一个列和word进行映射，在InnoDB中这个列被命名为FTS_DOC_ID，其类型必须是BIGINT UNSIGNED NOT NULL，并且InnoDB会自动在该列上添加一个名为FTS_DOC_ID_INDEX的唯一索引。</p></blockquote><p>InnoDB存储引擎的全文检索存在的限制：</p><ul><li>每张表只能有一个全文检索的索引。</li><li>由多列组合而成的全文检索的索引列必须使用相同的字符集和排序规则。</li><li>不支持没有单词界定符的语言，如中文、日语。</li></ul><p><strong>全文检索的使用：</strong><br>1.先创建表和插入数据。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> fts_a<span class="token punctuation">(</span>    FTS_DOC_ID <span class="token keyword">BIGINT</span> UNSIGNED <span class="token keyword">AUTO_INCREMENT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    body <span class="token keyword">TEXT</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>FTS_DOC_ID<span class="token punctuation">)</span><span class="token punctuation">)</span>；<span class="token keyword">INSERT</span> <span class="token keyword">into</span> fts_a <span class="token keyword">SELECT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token string">'Pease porridge in the pot'</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">into</span> fts_a <span class="token keyword">SELECT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token string">'Pease porridge hot,pease porridge cold'</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">into</span> fts_a <span class="token keyword">SELECT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token string">'Nine days old'</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">into</span> fts_a <span class="token keyword">SELECT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token string">'Some like it hot, some like it cold'</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">into</span> fts_a <span class="token keyword">SELECT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token string">'Some like it int the pot'</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">into</span> fts_a <span class="token keyword">SELECT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token string">'Nine days old'</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">into</span> fts_a <span class="token keyword">SELECT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token string">'I like code days'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># body字段是进行全文检索的字段，因此创建一个类型为FULLTEXT的索引。</span><span class="token keyword">CREATE</span> FULLTEXT <span class="token keyword">INDEX</span> idx_fts <span class="token keyword">ON</span> fts_a<span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.通过设置参数<code>innodb_ft_aux_table</code>来查看分词对应的信息，注意数据库的名称要对上</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SET</span> <span class="token keyword">GLOBAL</span> innodb_ft_aux_table<span class="token operator">=</span><span class="token string">'test/fts_a'</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> information_schema<span class="token punctuation">.</span>INNODB_FT_INDEX_TABLE<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>部分结果：</p><p><img src="/posts/47027/image-20240513205829440.png" alt></p><p>可以看到每个word都对应了一个DOC_ID和POSITION，并且还记录了这么几个重要的信息：</p><ul><li>FIRST_DOC_ID：该word第一次出现的文档ID。</li><li>LAST_DOC_ID：最后一次出现的文档ID。</li><li>DOC_COUNT：该word在多少个文档中存在。</li></ul><p>3.全文检索的使用：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># 全文检索通过Match函数进行查询，默认采用NATURAL LANGUAGE模式</span><span class="token comment" spellcheck="true"># 代表查询代带有指定word的文档。</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> fts_a <span class="token keyword">WHERE</span> <span class="token keyword">MATCH</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span> AGAINST<span class="token punctuation">(</span><span class="token string">'Porridge'</span> <span class="token operator">IN</span> <span class="token keyword">NATURAL</span> LANGUAGE MODE<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里再来讲一讲全文检索的另一个模式：<strong>Boolean</strong>，<strong>当使用该修饰符的时候，查询字符串的前后字符会有特殊的含义</strong>。例如：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># +代表这个单词必须出现，-代表这个单词一定不存在</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> fts_a <span class="token keyword">WHERE</span> <span class="token keyword">MATCH</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span> AGAINST<span class="token punctuation">(</span><span class="token string">'+Pease -hot'</span> <span class="token operator">IN</span> <span class="token keyword">BOOLEAN</span> MODE<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其余的操作符还有：（只列举几个好记的）</p><table><thead><tr><th>操作符</th><th>含义</th></tr></thead><tbody><tr><td>+</td><td>该word必须存在</td></tr><tr><td>-</td><td>该word必须被排除</td></tr><tr><td>&gt;</td><td>表示出现该单词时增加相关性</td></tr><tr><td>&lt;</td><td>表示出现该单词时降低相关性</td></tr><tr><td>~</td><td>允许出现该单词，但是出现时相关性为负</td></tr><tr><td>*</td><td>表示以该单词开头的单词</td></tr></tbody></table><p>全文检索相关性的计算依据：</p><ul><li>word是否在文档中出现。</li><li>word在文档中出现的次数。</li><li>word在索引列中的数量。</li><li>多少个文档包含该word。</li></ul><p>最后再总结式的讲一下文档中分词的插入和删除操作。</p><p>插入：</p><blockquote><p>在事务提交的时候完成。</p></blockquote><p>删除：</p><blockquote><p>在事务提交的时候，<strong>不删除磁盘中辅助表Auxiliary Table的记录，而是删除FTS Cache Index中的记录，对于辅助表中被删除的记录，InnoDB会记录他的FTS Document ID，并把它保存在一张表中（DELETED Auxiliary Table）中</strong></p></blockquote><p>当然，也可以彻底删除倒排索引中该文档的分词信息：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SET</span> <span class="token keyword">GLOBAL</span> innodb_optimize_fulltext_only<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">OPTIMIZE</span> <span class="token keyword">TABLE</span> fts_a<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="二-锁"><a href="#二-锁" class="headerlink" title="二. 锁"></a>二. 锁</h2><p>InnoDB存储引擎锁的实现提供一致性的非锁定读、行级锁支持，还可以同时得到并发性和一致性。在数据库中，lock和latch都可以被称之为“锁”。</p><ul><li>latch：<strong>轻量级锁，要求锁定的时间必须非常短，目的是保证并发线程操作临界资源的正确性。可以分为<code>mutex（互斥量）</code>和<code>rwlock（读写锁）</code></strong></li><li>lock：<strong>对象：事务，</strong> 锁定的是数据库中的对象，如表、页。</li></ul><p>两者对比表：</p><table><thead><tr><th></th><th>lock</th><th>latch</th></tr></thead><tbody><tr><td>对象</td><td>事务</td><td>线程</td></tr><tr><td>保护</td><td>数据库内容</td><td>内存数据结构</td></tr><tr><td>持续时间</td><td>整个事务过程</td><td>临界资源</td></tr><tr><td>模式</td><td>行锁、表锁、意向锁</td><td>读写锁、互斥量</td></tr><tr><td>死锁</td><td>通过waits-for graph、time out等机制进行死锁检测与处理</td><td>没有死锁检测和处理机制。仅通过应用程序加锁的顺序来保证没有死锁的情况发生。</td></tr><tr><td>存在于</td><td>Lock Manager的哈希表中</td><td>每个数据结构的对象中</td></tr></tbody></table><p>一般也从物理锁和逻辑锁这两种概念来区分。</p><h3 id="2-1-InnoDB存储引擎中的锁"><a href="#2-1-InnoDB存储引擎中的锁" class="headerlink" title="2.1 InnoDB存储引擎中的锁"></a>2.1 InnoDB存储引擎中的锁</h3><h4 id="2-1-1-锁的类型"><a href="#2-1-1-锁的类型" class="headerlink" title="2.1.1 锁的类型"></a>2.1.1 锁的类型</h4><p>InnoDB存储引擎实现了如下两种标准的行级锁：</p><ul><li>共享锁（S Lock），允许事务读一行数据。</li><li>排他锁（X Lock），允许事务删除或者更新一行数据。</li></ul><p>再来说下两个概念，锁的兼容和不兼容。</p><blockquote><p>锁兼容：如果一个事务T1已经获得了行m的S锁，那么事务T2可以立即获得行m的S锁。（因为读取并不会改变行m的数据）<br>锁不兼容：若有其他的事务T3想要获得行m的X锁，那必须等待事务T1和T2释放掉行m上的S锁。</p></blockquote><p>注意：兼容是指对<strong>同一记录</strong>（row）锁的兼容性情况。<br><img src="/posts/47027/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pvbmdfMDkxNQ==,size_16,color_FFFFFF,t_70-1715605242597-5.png" alt></p><p>此外，InnoDB存储引擎还支持多粒度缩影，即允许事务在行级上的锁和表级上的锁同时存在，而为了支持在不同粒度上的加锁操作，InnoDB推出了意向锁，其锁定的对象可以分为多个层次，目前支持两种意向锁：</p><ul><li>意向共享锁（IS Lock）：事务想要获得一张表中某几行的共享锁。</li><li>意向排他锁（IX Lock）：事务想要获得一张表中某几行的排他锁。</li></ul><p>由于InnoDB支持的是行级锁，<strong>因此意向锁并不会堵塞除全表扫描以外的任何请求。</strong> <strong>表级意向锁</strong>和<strong>行级锁</strong>的兼容性如下图：<br><img src="/posts/47027/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pvbmdfMDkxNQ==,size_16,color_FFFFFF,t_70-1715605284972-8.png" alt><br>在InnoDB1.0开始，我们可以通过3张表来监控当前事务并分析可能存在的锁问题。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> information_schema<span class="token punctuation">.</span>INNODB_TRX<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/47027/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pvbmdfMDkxNQ==,size_16,color_FFFFFF,t_70-1715605284972-9.png" alt="表1：INNODB_TRX"></p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> information_schema<span class="token punctuation">.</span>INNODB_LOCKS<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/47027/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pvbmdfMDkxNQ==,size_16,color_FFFFFF,t_70-1715605284972-10.png" alt="表2：INNODB_LOCKS"></p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> information_schema<span class="token punctuation">.</span>INNODB_LOCK_WAITS<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结构：<br><img src="/posts/47027/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pvbmdfMDkxNQ==,size_16,color_FFFFFF,t_70-1715605284972-11.png" alt="表3：INNODB_LOCK_WAITS"></p><h4 id="2-1-2-一致性非读定锁"><a href="#2-1-2-一致性非读定锁" class="headerlink" title="2.1.2 一致性非读定锁"></a>2.1.2 一致性非读定锁</h4><p>一致性非读定锁是指InnoDB存储引擎<strong>通过多版本控制的方式来读取当前执行时间数据库中行的数据。</strong> <strong>作为InnoDB存储引擎的默认读取方式。</strong></p><p>如果读取的行正在执行Delete或者Update操作，那<strong>么这时候读取操作不会因此去等待锁的释放，而是去读取该行的一个快照数据。</strong> 因为不需要等待访问的行上的X锁的释放，也因此叫非读定锁。</p><p>快照数据指的是该行的之前版本的数据（通过undo log来实现），<strong>一行记录可能有多个快照数据，一般称这种技术为行多版本技术，而由此带来的并发控制，称之为多版本并发控制，也就是我们听烂了的MVCC！</strong></p><p>虽然一致性非读定锁作为默认的读取方式，但是在不同的事务隔离级别下，读取方式还是不一样的。事务隔离级别在<strong>重复读</strong>和<strong>读提交</strong>两个级别下，使用的是一致性非读定锁。并且这两个级别下的快照数据定义也不一样：</p><ul><li>Read Committed（读提交）：非一致性读<strong>总是读取被锁定行的最新一份快照数据。</strong></li><li>Repeatable Read（重复读）：<strong>总是读取事务开始时的行数据版本。</strong></li></ul><h4 id="2-1-3-一致性读定锁"><a href="#2-1-3-一致性读定锁" class="headerlink" title="2.1.3 一致性读定锁"></a>2.1.3 一致性读定锁</h4><p>默认配置下，即事务的隔离级别为重复读模式下，InnoDB存储引擎的Select操作使用一致性非锁定读，但是某些情况下，用户需要<strong>显式地对数据库读取操作进行加锁以保证数据逻辑的一致性。</strong> 因此InnoDB存储引擎对于Select语句支持了两种一致性的锁定读操作：</p><ul><li><code>Select ··· For Update</code>：对读取的行记录加一个X锁，则其他事务不能对已经锁定的行加上任何锁。</li><li><code>Select ··· Lock In Share Mode</code>：对读取的行记录加一个S锁，其他事务则只能加S锁，若加X锁，则被堵塞。</li></ul><h4 id="2-1-4-自增长和锁"><a href="#2-1-4-自增长和锁" class="headerlink" title="2.1.4 自增长和锁"></a>2.1.4 自增长和锁</h4><p>在InnoDB存储引擎的内存结构中，<strong>对每个含有自增长值的表都有一个自增长计数器（auto-increment counter）</strong> ，当对含有自增长计数器的表进行插入操作时，这个计数器会被初始化。</p><p>插入操作会依据这个自增长的计数器值来加1进行赋值，这个实现方式叫做AUTO-INC Locking。</p><blockquote><p>其实这是一种特殊的表锁机制，为了提高插入的性能，<strong>锁不是在一个事务完成后才释放的，而是在完成对自增长值插入的SQL语句后立即释放</strong>。</p></blockquote><p>从Mysql5.1.22开始，InnoDB存储引擎提供了一种轻量级互斥量的自增长实现机制，该版本提供了参数<code>innodb_autoinc_lock_mode</code>来控制自增长的模式，默认值为1。</p><p>先来看下自增长的插入类型：<br><img src="/posts/47027/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pvbmdfMDkxNQ==,size_16,color_FFFFFF,t_70-1715605284973-12.png" alt><br>再来看下不同参数下的自增影响：<br><img src="/posts/47027/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pvbmdfMDkxNQ==,size_16,color_FFFFFF,t_70-1715605284973-13.png" alt><br>此外，在InnoDB存储引擎中，<strong>自增长值的列必须是索引，同时也必须是索引的第一个列</strong>。</p><h4 id="2-1-5-外键和锁"><a href="#2-1-5-外键和锁" class="headerlink" title="2.1.5 外键和锁"></a>2.1.5 外键和锁</h4><p><strong>外键主要是用于引用完整性的约束检查。</strong> 并且，如果对于一个外键列，如果没有显式地对这个列加索引，InnoDB会自动对其加一个索引，从而避免表锁。</p><p>对于外键值的插入或者更新操作：</p><blockquote><p>1.首先查询父表中的记录，select。<br>2.select操作通过select xxx lock in share mode的方式。<br>3.即主动对父表加一个S锁。</p></blockquote><p>试想下，为什么外键值的插入或者更新不是使用一致性非锁定读的方式呢？举个例子：（一致性读锁定）<br><img src="/posts/47027/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pvbmdfMDkxNQ==,size_16,color_FFFFFF,t_70-1715605284973-14.png" alt><br>若是一致性非读锁定，那么此时会话B会对父表中id为3的记录，是可以进行插入操作的，但如果A的事务提交，那么对于A来说，id为3的记录是删除的，对于B来说是存在的，那么就出现了不一致的情况。因此需要一致性读锁定。</p><h3 id="2-2-锁的算法"><a href="#2-2-锁的算法" class="headerlink" title="2.2 锁的算法"></a>2.2 锁的算法</h3><p>InnoDB存储引擎共有3种行锁的算法，分别是：</p><ul><li>Record Lock：单个行记录上的锁。</li><li>Gap Lock：间隙锁，锁定一个范围，但不包含记录本身。</li><li>Next-Key Lock：Record Lock+Gap Lock，锁定一个范围，并且锁定记录本身。</li></ul><p>Record Lock<strong>总是会去锁住索引记录</strong>，如果InnoDB存储引擎表在简历的时候没有设置任何一个索引，那么他会<strong>使用隐式的主键来进行锁定。</strong></p><p>Next-Key Lock算法下，例如一个索引有10，11，13，20这4个值，那么这个索引可能被Next-Key Locking的区间为：<br><img src="/posts/47027/20201216104921320.png" alt></p><p>当然，既然有Next-Key Lock，也存在一个<code>Previous-Key Lock</code>。如果采用这种锁定技术，同样的上述索引，可锁定的区间为：<br><img src="/posts/47027/20201216104908758.png" alt></p><p>为什么要采用这个锁技术？其<strong>目的是为了解决Phantom Problem</strong></p><blockquote><p>Phantom Problem即幻像问题，也就是所谓的<strong>幻读</strong>，<strong>是指在同一个事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL语句可能会返回之前不存在的行。</strong><br>举个例子：</p><p><img src="/posts/47027/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pvbmdfMDkxNQ==,size_16,color_FFFFFF,t_70-1715605284973-15.png" alt>)<img src="/posts/47027/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pvbmdfMDkxNQ==,size_16,color_FFFFFF,t_70-1715605284973-16.png" alt><br><strong>可以看到，会话A执行第二次SQL的时候，会把会话B插入的语句返回给结果</strong></p></blockquote><p>那么Next-Key Locking算法怎么避免幻读？</p><blockquote><p>对于上述的SQL语句<code>Select * from t where a &gt; 2 for update;</code> 锁住的不是5这个单个值，而是对(2，+∞)这个范围都加了X锁，因此对于这个范围的任何插入都是不被允许的，从而避免了幻读的产生。</p></blockquote><p>InnoDB存储引擎默认的事务隔离级别是重复读，在该隔离级别下，采用的是Next-Key Lock。<strong>而在事务隔离级别为提交读的情况下，仅仅采用Record Lock。</strong></p><p><strong>注意</strong>：对于唯一键值的锁定，Next-Key Lock会降级为Record Lock，仅存在于查询所有的唯一索引列。</p><h3 id="2-3-锁问题"><a href="#2-3-锁问题" class="headerlink" title="2.3 锁问题"></a>2.3 锁问题</h3><p><strong>1.脏读</strong>：在不同的事务下，当前事务可以读到另外事务未提交的数据。</p><p><img src="/posts/47027/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pvbmdfMDkxNQ==,size_16,color_FFFFFF,t_70-1715605284973-17.png" alt><br><strong>2.不可重复读</strong>：在一个事务内多次读取同一个数据集合，而第二次读取的数据和第一次读取的数据不是一样的。</p><p><img src="/posts/47027/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pvbmdfMDkxNQ==,size_16,color_FFFFFF,t_70-1715605284973-18.png" alt><br>这里需要做一个区分（因为两个例子很像)：</p><ul><li><strong>脏读是读到未提交的数据。</strong></li><li><strong>不可重复读读到的是已经提交的数据。</strong></li></ul><p><strong>3.丢失更新</strong>：<br>丢失更新简单来说就是<strong>一个事务的更新操作会被另一个事务的更新操作所覆盖。</strong> ，从而导致数据的不一致。</p><ol><li>事务T1将记录m更新为n1，但是事务T1没有提交。</li><li>与此同时，事务T2将记录m更新为n2，事务T2没有提交。</li><li>事务T1提交。</li><li>事务T2提交。</li></ol><p>而为了避免这种丢失更新发生，需要让事务在这种情况下的操作变成串行化，而不是并行的操作。对于上述操作，可以给步骤1和2分别加一个X锁，那么事务T2就会进入堵塞。</p><h3 id="2-4-死锁"><a href="#2-4-死锁" class="headerlink" title="2.4 死锁"></a>2.4 死锁</h3><p>死锁是指两个以及以上的事务在执行过程中，<strong>因争夺锁资源而造成的一种互相等待的现象。</strong></p><p>解决死锁的方式：</p><ul><li><strong>time out</strong>：即<strong>超时机制</strong>，当两个事务互相等待时，当一个等待时间超过<code>innodb_lock_wait_timeout</code>设置的某一个阈值时，<strong>其中一个事务进行回滚，另一个等待的事务就能够继续进行。</strong></li></ul><blockquote><p>超时机制的优点：简单。<br>缺点：根据FIFO的顺序选择回滚对象，如果超时的事务所占的权重比较大（比如事务操作更新了很多行），那么此时占用的undo log比较大，若此事进行回滚，那么回滚的时间相比另一个事务所占用的时间可能要多很多。即不合理。</p></blockquote><ul><li><strong>wait-for graph：等待图（InnoDB也采用这种方式）</strong></li></ul><p>wait-for graph要求数据库保存两种信息：</p><ul><li>锁的信息链表。</li><li>事务等待链表。</li></ul><p>其中，wait-for graph中，<strong>事务为图的节点</strong>。并且事务T1指向T2边的定义为：</p><ul><li>事务T1等待事务T2所占用的资源。</li><li>事务T1最终等待T2所占用的资源。也就是事务之间在等待相同的资源，<strong>而事务T1发生在事务T2的后面。</strong></li></ul><p>事务发生死锁的概率与以下几点因素有关：</p><ul><li>系统中事务的数量（n），n越多发生死锁的概率越大。</li><li>每个事务操作的数量（r），r越多发生思索的概率越大。</li><li>操作数据的集合（R)，越小则发生死锁的概率越大。</li></ul><blockquote><p>题外话，<strong>操作系统</strong>发生死锁的条件：</p><ul><li>互斥条件：某一个资源在一段时间内只能由一个进程占有，不能被两个及以上进程占有。</li><li>不可抢占条件：进程所占有的资源在使用完毕之前，不会被其他的资源申请者占有，除非该资源自行释放。</li><li>占有且申请条件：进程至少占有一个资源，但是又申请新的资源。</li><li>循环等待条件：存在一个进程等待序列{P1,P2,…Pn}，P1等待P2的资源，P2等待P3的资源…Pn等待P1的资源。即形成环。</li></ul></blockquote><h3 id="2-5-锁升级"><a href="#2-5-锁升级" class="headerlink" title="2.5 锁升级"></a>2.5 锁升级</h3><p>锁升级是指<strong>将当前锁的粒度降低。</strong> 如把一个表的1000个行锁升级为一个页锁。 <strong>但是InnoDB存储引擎不存在锁升级的问题，因为他并不是根据每个记录来产生行锁的，相反，它是根据每个事务访问的每个页对锁进行管理的，采用的位图的方式。</strong></p><p><strong>因此不管一个事务锁住页中一个记录还是多个记录，其开销都是一致的。</strong></p><h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h2><p>最后总结一些事情：</p><ol><li><strong>首先，InnoDB是一种存储引擎，不是索引，不是索引，不是索引。</strong></li><li>其次，InnoDB存储引擎下，包含两种索引类型，一个是BTREE（就是B+树），一个是HASH。</li><li>4个事务隔离级别：读未提交，读提交，重复读，串行化。</li><li>InnoDB是行级锁：包括<strong>共享锁</strong>和<strong>排他锁</strong>，MyISAM是表级锁。</li><li>3种锁问题：脏读、不可重复读（<strong>切忌不要和事务隔离级别中的重复读搞串了</strong>）、幻读。</li><li>3种锁算法：<code>Record Lock</code>、<code>Gap Lock</code>、<code>Next-Key Lock</code>（<strong>解决幻读</strong>）。</li><li>锁类型：一致性非读定锁（<strong>MVCC</strong>）、一致性读定锁（<strong>悲观锁，for update</strong>）、自增长锁（<strong>特殊的锁机制，锁不是在一个事务完成后才释放的，而是在完成对自增长值插入的SQL语句后立即释放</strong>）、外键锁（插入操作时，对父表进行<code>lock in share mode</code>操作）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;可以说是核心部分了，很多时候我们谈数据库其实大部分时间谈的都是其存储引擎。&lt;/p&gt;
&lt;h2 id=&quot;一-索引算法&quot;&gt;&lt;a href=&quot;#一-
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://JoyTsing.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="读书笔记" scheme="https://JoyTsing.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数据库" scheme="https://JoyTsing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>从百行线程池了解线程池相关技术</title>
    <link href="https://joytsing.github.io/posts/14242/"/>
    <id>https://joytsing.github.io/posts/14242/</id>
    <published>2024-05-06T11:01:25.000Z</published>
    <updated>2024-05-06T12:03:00.174Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在实际编程实践的过程中，一个应用通常由多个线程组成，这些线程通常可以分成两类</p><ol><li>常驻线程：这种线程的生命周期通常和应用的生命周期大致相同，在应用运行的期间，这些线程就一直存在。通常这些线程负责的是应用整个生命周期内，需要不断运行的任务。比如，用于负责整个应用的日志记录的线程、负责通讯的线程、负责<code>UI</code>交互的线程</li><li>非常驻线程：用于执行异步操作任务，该任务的执行周期较短，并且不是周期性的任务，没有必要建立一个常驻线程。比如，进行计算量比较大的任务，比如矩阵分块运算的时候，可以将一个任务拆分给多个线程进行计算，然后在汇总结果从而提高计算速度。此时这些拆分出来的任务，可以为其创建新的线程来进行计算，当计算完成返回计算结果之后，线程销毁</li></ol><p>第<code>2</code>种通过创建一个线程，对异步任务进行计算然后在计算完成返回结果之后再销毁线程。这种设计在硬件资源比较充足或者这种”临时性”的异步需求不是特别频繁的时候，是无需特别在意的，但是如果需要频繁地请求创建任务和销毁任务，那么由此带来的额外开销可能会比执行任务本身的开销更大（比如简单地计算任务），那么这种情况下使用线程池可以缓解这个问题。</p><h2 id="一些关键点"><a href="#一些关键点" class="headerlink" title="一些关键点"></a>一些关键点</h2><p>实现一个线程池通常需要以下几个关键点：</p><ol><li>线程池中的池，即预先创建的若干线程的存储</li><li>线程池中线程的状态管理，即线程未执行异步任务时需要阻塞，执行异步任务的时候需要唤醒。以及识别当前线程中线程处于何种状态（空闲/忙碌）</li><li>通用任务的封装，线程池通常不是为执行单一某种异步任务而设计的，是为了多种异步任务而设计的，此时需要将任务进行封装，从而使得这些任务可以以一种统一的方式传递给线程池，供线程池进行执行</li></ol><p>7.5k star的轻量级<a href="https://github.com/progschj/ThreadPool">线程池</a>，算上头文件代码行数也就100行。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="数据成员"><a href="#数据成员" class="headerlink" title="数据成员"></a>数据成员</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">ThreadPool</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">ThreadPool</span><span class="token punctuation">(</span>size_t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">F</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span>    <span class="token keyword">auto</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>F<span class="token operator">&amp;&amp;</span> f<span class="token punctuation">,</span> Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span>         <span class="token operator">-</span><span class="token operator">></span> std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token keyword">typename</span> std<span class="token operator">::</span>result_of<span class="token operator">&lt;</span><span class="token function">F</span><span class="token punctuation">(</span>Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">></span><span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">ThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">// need to keep track of threads so we can join them</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span> std<span class="token operator">::</span>thread <span class="token operator">></span> workers<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// the task queue</span>    std<span class="token operator">::</span>queue<span class="token operator">&lt;</span> std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> <span class="token operator">></span> tasks<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// synchronization</span>    std<span class="token operator">::</span>mutex queue_mutex<span class="token punctuation">;</span>    std<span class="token operator">::</span>condition_variable condition<span class="token punctuation">;</span>    <span class="token keyword">bool</span> stop<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数据成员其实不算多，仅仅5个</p><ul><li><code>workers</code>：用来存储预先创建（<code>pre-allocate</code>）的线程对象的，是用来保存线程对象的容器</li><li><code>tasks</code>：任务队列（<code>queue</code>），用来存储接受到异步任务的。当有任务需要该线程池来执行时，将任务放入该队列中。线程池中有空闲的线程时，从中唤醒一个空闲的线程，然后从该队列中取出一个任务，将该任务交给该线程来执行</li><li><code>queue_mutex</code>：互斥锁，用来保证任务队列<code>tasks</code>以及控制线程池停止的<code>stop</code>标志位的多线程并发安全的</li><li><code>condition</code>：条件变量，用来实现线程池内的线程的休眠（阻塞）和运行（唤醒）的</li><li><code>stop</code>：用来结束线程池的运行，用来控制线程池停止，线程池内的线程的退出和销毁</li></ul><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p>讨论完线程池的内部数据成员，我们看一下该线程池对象<code>ThreadPool</code>的构造函数的代码实现，代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// the constructor just launches some amount of workers</span><span class="token keyword">inline</span> ThreadPool<span class="token operator">::</span><span class="token function">ThreadPool</span><span class="token punctuation">(</span>size_t threads<span class="token punctuation">)</span>    <span class="token operator">:</span>   <span class="token function">stop</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>threads<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>        workers<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>            <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span>            <span class="token punctuation">{</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> task<span class="token punctuation">;</span>                    <span class="token punctuation">{</span>                        std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>queue_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>condition<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span>                            <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>stop <span class="token operator">||</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>tasks<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>stop <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>tasks<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                            <span class="token keyword">return</span><span class="token punctuation">;</span>                        task <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>tasks<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>tasks<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token function">task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在构造函数处通过for循环创建完指定数量线程，同时在线程内部启动一个工作函数，保证线程安全的同时用来不断消费任务队列里的任务。同时调用线程池类的<code>condition</code>条件变量的<code>wait</code>函数，等待条件变量的满足。如果线程池内存在线程由于任务队列为空时，进入阻塞等待状态时，此时如果有新的任务添加到任务队列，在接受任务的函数内会调用条件变量的通知函数，此时线程池内会有一个线程在此行函数，判定被通知为条件变量满足，退出等待条件变量的阻塞状态，唤醒开始执行该任务。</p><h3 id="异步任务接受函数"><a href="#异步任务接受函数" class="headerlink" title="异步任务接受函数"></a>异步任务接受函数</h3><p>大部分线程池的核心部分，如何添加异步任务，首先我们看一下函数签名</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// add new work item to the pool</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">F</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span><span class="token keyword">auto</span> ThreadPool<span class="token operator">::</span><span class="token function">enqueue</span><span class="token punctuation">(</span>F<span class="token operator">&amp;&amp;</span> f<span class="token punctuation">,</span> Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span>     <span class="token operator">-</span><span class="token operator">></span> std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token keyword">typename</span> std<span class="token operator">::</span>result_of<span class="token operator">&lt;</span><span class="token function">F</span><span class="token punctuation">(</span>Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">using</span> return_type <span class="token operator">=</span> <span class="token keyword">typename</span> std<span class="token operator">::</span>result_of<span class="token operator">&lt;</span><span class="token function">F</span><span class="token punctuation">(</span>Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">::</span>type<span class="token punctuation">;</span>    <span class="token keyword">auto</span> task <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span> std<span class="token operator">::</span>packaged_task<span class="token operator">&lt;</span><span class="token function">return_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> <span class="token operator">></span><span class="token punctuation">(</span>            std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>F<span class="token operator">></span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Args<span class="token operator">></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>future<span class="token operator">&lt;</span>return_type<span class="token operator">></span> res <span class="token operator">=</span> task<span class="token operator">-</span><span class="token operator">></span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span>queue_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// don't allow enqueueing after stopping the pool</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>stop<span class="token punctuation">)</span>            <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"enqueue on stopped ThreadPool"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tasks<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span><span class="token punctuation">[</span>task<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">(</span><span class="token operator">*</span>task<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    condition<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>函数返回值：<code>std::future&lt;typename std::result_of&lt;F(Args...)&gt;::type&gt;</code>，返回一个<code>future</code>类型的对象，该对象可以用于异步任务创建方来获取异步调用结果。</li><li>函数形参：<code>f</code>用于接受携带异步任务的可调用对象，<code>args</code>用来携带执行异步调用需要的函数调用的参数信息。</li></ol><blockquote><p>更推荐用 <code>std::invoke_result_t&lt;F, Args...&gt;&gt;</code>去取代<code>std::result_of&lt;F(Args...)&gt;::type</code></p></blockquote><p>重点在task是怎么被包装的，通过构建一个<code>shared_ptr</code>指针，该指针指向一个<code>packaged_task</code>对象，同时参数通过<code>std::bind()</code>，对可调用对象<code>f</code>进行柯里化，将可调用对象和其执行时需要的函数参数，封装成一个新的可调用对象，这个新的可调用对象进行函数调用的时候，无需进行函数传参。当然使用lambda表达式同样也可以进行绑定（asio中可以减少bind的使用）。</p><p>在这之后通过 <code>task-&gt;get_future()</code>获取异步调用的结果<code>future</code>对象并将这个<code>future</code>返回，同时不要忘记将task入队列，通过lambda包装后统一为<code>void()</code>函数类型。入队列后通知线程去取用，这里需要注意最好要等锁结束后再去通知，不然可能有极小概率出现通知结束后取不到锁的问题。</p><p>上面代码行中涉及到了我们前面讨论到的任务的统一化存储，我们集中梳理讨论一下。先说一下为什么要做任务的统一化存储？通常线程池是用来接受不同的异步操作任务的，每一个异步操作（异步调用）任务，通常是有一个可调用对象来存储的，这些可调用对象的进行函数调用的时候需要的参数和返回值的类型，是有差异的。如果直接对原始的异步操作任务进行存储，由于<code>C++</code>是强类型语言，是不能将有差异的异步操作类型保存到同一个容器中的。所以需要对异步操作任务进行封装，将其封装成统一的任务进行存储。</p><p>首先，通过<code>std::bind</code>对可调用对象进行柯里化，将带参数的可调用对象封装成无参数的可调用对象，从而磨平可调用对象在参数上的差异。这里<code>std::bind</code>通过接受初始可调用对象以及参数，然后根据两者构建出一个新的可调用对象，并将这个新的可调用对象返回完成柯里化操作。最后，通过<code>lambda</code>将<code>packaged_task</code>封装成一个无返回值，无参数的<code>lambda</code>对象，此时该<code>lambda</code>对象将最后一个差异，即返回值的差异，磨平从而可以达到统一存储到一个容器（任务队列）的目的。</p><blockquote><p>为什么这里不将<code>package_task</code>对象直接存储到任务队列中？</p></blockquote><p>这事因为<code>packaged_task</code>对象的类型是一个类模版<code>std::packaged_task&lt;return_type&gt;</code>，其模版实例化之后的类型信息中包含了原始可调用对象的返回值的类型信息。当可调用对象的返回值类型不同的时候，对应的<code>packaged_task</code>的类型信息是不相同的，无法存储到同一个容器中</p><h3 id="析构"><a href="#析构" class="headerlink" title="析构"></a><strong>析构</strong></h3><p>上面已经将线程池运行的时候的主要代码都讨论完毕，下面只剩下一个析构函数的代码实现。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// the destructor joins all threads</span><span class="token keyword">inline</span> ThreadPool<span class="token operator">::</span><span class="token operator">~</span><span class="token function">ThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span>queue_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        stop <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    condition<span class="token punctuation">.</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>std<span class="token operator">::</span>thread <span class="token operator">&amp;</span>worker<span class="token operator">:</span> workers<span class="token punctuation">)</span>        worker<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="思考一个问题"><a href="#思考一个问题" class="headerlink" title="思考一个问题"></a>思考一个问题</h2><p>当调用条件变量的<code>notify_one</code>函数的时候，该操作仅仅会唤醒在该条件变量上处于等待阻塞的其他线程。当其他线程未处于等待阻塞状态的时候，此时此次通知不会传递到该线程。</p><p>比如有一个主线程和两个工作线程，当主线程调用条件变量的<code>notify_one</code>函数的时候，另外两个线程都处于工作状态，即没有阻塞在<code>condition.wait</code>函数上的时候，此时此次对于条件变量的这次<code>notify_once</code>函数的调用将会是无效的，后续这两个线程工作完成之后，重新等待该条件变量满足的时候，这两个线程都会阻塞在<code>wait</code>函数位置。</p><p>如果一瞬间异步调用的任务来的比较密集，造成异步调用队列的任务堆积，即所有的线程都处于工作状态，此时调用<code>ThreadPool</code>的<code>enqueue</code>成员函数将任务入任务队列的时候，此时当所有工作线程处理完当前的异步任务之后是否会处理这个新入队的异步任务？</p><pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span>            <span class="token punctuation">{</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> task<span class="token punctuation">;</span>                    <span class="token punctuation">{</span>                        std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>queue_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>condition<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span>                            <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>stop <span class="token operator">||</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>tasks<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>stop <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>tasks<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                            <span class="token keyword">return</span><span class="token punctuation">;</span>                        task <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>tasks<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>tasks<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token function">task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>问题的关键之处，就在于<code>std::condition_variable::wait</code>这个函数的实现，我们看一下<a href="https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/thread/condition_variable/wait">CPP Reference</a>关于这个函数的相关描述</p><p><img src="/posts/14242/image-20240506195846086.png" alt></p><p>可以看见与这种写法是等价的，注意，也就是其会先判断传入的<code>stop_waiting</code>谓词判别式，当该判别式返回<code>true</code>的时候，意味着不需要在此条件变量上进行等待。此时不会进入<code>while</code>循环，不进行条件变量的<code>wait</code>操作。<code>stop_waiting</code>条件判别式在<code>ThreadPool</code>传入的是，如果当前线程池处于停止状态或者当前异步调用任务队列不为空（还有待执行的异步任务）的时候，该判别式返回<code>true</code>。</p><p>因此当正在工作的工作线程结束当前工作的时候，重新进入下一次<code>for</code>循环的时候，如果此时异步调用队列不为空的时候，不会在条件变量上调用<code>wait</code>函数，此时会继续从异步任务队列中获取任务并对获取到的任务进行处理。</p><h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><pre class="line-numbers language-cpp"><code class="language-cpp"> ThreadPool <span class="token function">pool</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span> std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> results<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        results<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>            pool<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">{</span>                std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>                std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"world "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>                <span class="token keyword">return</span> i<span class="token operator">*</span>i<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;&amp;</span> result<span class="token operator">:</span> results<span class="token punctuation">)</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;在实际编程实践的过程中，一个应用通常由多个线程组成，这些线程通常可以分成两类&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;常驻线程：这种线程的生命周期通常和应
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
      <category term="源码阅读" scheme="https://JoyTsing.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>从示例到源码探究std::ref</title>
    <link href="https://joytsing.github.io/posts/36267/"/>
    <id>https://joytsing.github.io/posts/36267/</id>
    <published>2024-05-06T09:04:18.000Z</published>
    <updated>2024-05-06T11:01:43.277Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>相信大部分人在使用的时候是从多线程那了解的，在启动一个线程的时候如果要执行的函数是一个引用，这时候就需要我们使用<code>std::ref</code>进行包裹，那么究竟是怎么起作用的呢。先看一下官方手册里面的定义是什么。</p><p><img src="/posts/36267/image-20240506170901054.png" alt></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="自定义值传递函数模板"><a href="#自定义值传递函数模板" class="headerlink" title="自定义值传递函数模板"></a>自定义值传递函数模板</h3><p>我们先引入代码，观察并思考如下代码</p><pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Fn<span class="token punctuation">,</span><span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token operator">></span> <span class="token keyword">auto</span> <span class="token function">call_by_value</span><span class="token punctuation">(</span>Fn <span class="token operator">&amp;&amp;</span>fn<span class="token punctuation">,</span>Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>     a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token function">call_by_value</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于模板函数<code>call_by_value</code>是以值传递的方式接受参数的，所以该模板函数在调用的时候，首先会对参数进行一次值拷贝，构造一个临时的实参对象，然后将实参对象传递给<code>func</code>函数。</p><p><code>func</code>函数开始执行的时候，函数形参接受的是外部传入变量的引用，然后在函数内部将这个引用对应的变量赋值为1。由于这里面在外部函数<code>call_by_value</code>函数调用中，参数是以值传递的方式进行实现的。所以<code>func</code>函数内变量<code>a</code>这个引用指向的是<code>call_by_value</code>的函数实参，即临时构造的变量</p><p>所以，经过函数调用，变量并不会被修改。值还是0。所以上述代码运行之后的终端输出如下</p><pre class="line-numbers language-text"><code class="language-text"> 0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在实际的编程实践中，我们使用其他模板函数的时候，有时会遇到该模板函数是通过值的方式对参数进行接受的。但是我们希望希望该模板函数接受的是引用。比如上边的代码中，我们的<code>func</code>代码接受的是引用，目的是在函数内部对变量进行计算更改。比如在使用<code>std::bind</code>进行柯里化函数的时候，待柯里化的函数形参是引用，这个时候就无法进行形参的有效传递。</p><h3 id="bind工具函数模板"><a href="#bind工具函数模板" class="headerlink" title="bind工具函数模板"></a><strong>bind工具函数模板</strong></h3><p>我们在实际的编程实践中，经常需要通过<code>bind</code>进行函数柯里化，比如<code>std::find_if</code>的谓词函数仅仅接受一个参数的函数，如果你的比较函数是二元谓词函数，则需要进行柯里化，示例如下</p><pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">bool</span> <span class="token function">great_than</span><span class="token punctuation">(</span><span class="token keyword">int</span> first<span class="token punctuation">,</span><span class="token keyword">int</span> second<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> first <span class="token operator">></span> second<span class="token punctuation">;</span> <span class="token punctuation">}</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//找到第一个大于3的元素</span> <span class="token keyword">auto</span> it <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find_if</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">cbegin</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">,</span>std<span class="token operator">::</span><span class="token function">cend</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">,</span>std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>great_than<span class="token punctuation">,</span>std<span class="token operator">::</span>placeholders<span class="token operator">::</span>_1<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>考虑如下代码，实现了一个函数<code>func</code>在函数函数的形参是引用类型的，函数的目的是对传递进来的变量进行值的修改，修改成1:</p><pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>     a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">auto</span> wrap_func <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后答案与之前一样，都是0，原因也是因为在函数包装的过程中，将引用类型的参数进行了值的传递导致的，但是<code>bind</code>模板函数略有不同。</p><p>直接进去看函数定义：</p><p><img src="/posts/36267/image-20240506182733520.png" alt></p><p>这个函数模板的签名中用来传递参数的<code>__bound_args</code>是一个转发引用(forwarding reference，在以前的叫法为万能引用，但这种叫法已经过时，在现有的C++标准中叫转发引用)。当我们传递一个变量名的标识符进来的时候，该参数是以引用的形式传递的。没错，在这一层的函数调用中当传递一个函数名的时候，变量是通过左值引用的方式进行传递。</p><p>但是，由于柯里化的需求上面的<code>bind</code>函数需要做的是，将可调用对象<code>__f</code>和参数进行一个收集，构建并且返回另一个可调用对象给调用者，由调用者对这个调用对象进行调用并且传入剩余参数（也可以在调用<code>bind</code>函数进行柯里化的时候一次性将所有参数传递进来，这样在调用得到的可调用对象的时候就不需要传递剩余参数了，但是这样就失去了柯里化的意义）。</p><p>问题关键就是这个可调用对象的构建以及参数收集上，也就是这里面的<code>__bind</code>的对象的构建，下面我们看一下这个对象的构造函数相关代码：</p><p><img src="/posts/36267/image-20240506183107881.png" alt="注意两个成员变量"></p><p><img src="/posts/36267/image-20240506183133123.png" alt="构造函数"></p><p>该函数内部通过<code>__bound_args_</code>成员变量对函数参数的值进行存储，并且是值的方式通过一个元组<code>tuple</code>进行存储的。这会导致当我们使用<code>bind</code>对一个具有引用类型形参的函数进行柯里化的时候，传入的引用类型的形参将会以值传递的形式进行参数收集保存。这与我们想要传递变量的引用，并且在函数内部对该变量进行值的修改的需求不符合。</p><h2 id="std-ref"><a href="#std-ref" class="headerlink" title="std::ref"></a>std::ref</h2><p>当我们需要使用可能上面两种进行值传递的方式进行函数参数转发的进行带引用函数形参的的时候，就不能对直接传递原始的数据了。为了解决这个问题，C++标准库提供了一个帮助函数模板<code>std::ref</code>，相当于打了个补丁。该帮助函数模板通过左值引用类型的形参接受变量，并且将该变量包装成一个另外的类型返回。</p><p><img src="/posts/36267/image-20240506183529734.png" alt></p><p>函数内部构造了一个<code>reference_wrapper</code>类型对象并且将变量的左值引用传入到该类型的构造函数，让该对象持有这个左值引用。</p><p><img src="/posts/36267/image-20240506183700824.png" alt></p><ul><li>首先是指针引用部分<code>_TP* _M_data</code>，用来持有这个被修饰对象的相关信息的。</li><li>构造函数通过<code>addressof(__f)</code>函数取出该变量的地址，将这个地址信息存入成员变量中</li></ul><p>为了保证引用类型在经过函数模板或者类模板中的值传递过程中可以保持引用信息。这里面采用将传入变量包装成另外一个新的对象，在这个新的对象中持有被包装对象的地址信息。</p><p>在函数模板和类模板的值传递过程中，对这个新的对象进行值传递，其内部的被包装的对象地址信息可以得到保存。在函数模板或者内模板内部使用这个新的对象的时候，可以通过重载的类型转换函数将被包装变量的地址信息转换还原成相应的引用，对这个引用进行操作。从而达到操作外部变量的作用。</p><blockquote><p><code>addressof</code>这个函数用来取对象的地址。如果一个类型没有重载取地址操作符&amp;，则使用该函数和使用取地址操作符效果是一致的。如果这个类型重载了取地址操作符（这种情况不常见，但是也有），则想取得对象的内存地址则无法通过取地址操作符，只能通过这个函数。函数库里面使用这个函数是为了可以兼容所有的情况。我们在自己的代码中如果是确认取实际的内存地址信息，也因该使用<code>addressof</code></p></blockquote><h3 id="通过std-ref修改示例代码"><a href="#通过std-ref修改示例代码" class="headerlink" title="通过std::ref修改示例代码"></a><strong>通过std::ref修改示例代码</strong></h3><p>下面我们通过<code>std::ref</code>对上面的代码进行修改，首先是自定义值传递函数模板示例代码的修改:</p><pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Fn<span class="token punctuation">,</span><span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token operator">></span> <span class="token keyword">auto</span> <span class="token function">call_by_value</span><span class="token punctuation">(</span>Fn <span class="token operator">&amp;&amp;</span>fn<span class="token punctuation">,</span>Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>     a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token function">call_by_value</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span>std<span class="token operator">::</span><span class="token function">ref</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码中将第13行中的第2个参数<code>a</code>通过<code>std::ref</code>进行包装传入，代码运行结果如下</p><pre><code>1</code></pre><p>另一个示例代码修改同理，在使用上可以说是非常方便。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;相信大部分人在使用的时候是从多线程那了解的，在启动一个线程的时候如果要执行的函数是一个引用，这时候就需要我们使用&lt;code&gt;std::ref
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>如何在Linux下让grpc与protobuf多版本共存</title>
    <link href="https://joytsing.github.io/posts/9331/"/>
    <id>https://joytsing.github.io/posts/9331/</id>
    <published>2024-05-05T16:00:02.000Z</published>
    <updated>2024-05-30T15:00:06.239Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://joytsing.cn/posts/24753/">前情提要</a>，之前配置了比较低版本的protobuf，当时我就有预感肯定有伏笔，没想到伏笔来得这么快，因为grpc是需要配合protobuf使用的，也就是你单独弄的protobuf和grpc大概率版本是不统一的，这时候你去使用两者都会有问题，并且如果你按照前情提要配置的话大概率会遇到这个问题，其实这个问题只要不在全局配置问题都不大。</p><h2 id="grpc"><a href="#grpc" class="headerlink" title="grpc"></a>grpc</h2><p>安装过程就不必多说了，配置完后为了方便给加到了<code>.zshrc</code>里（不推荐，但是经常使用的话可以加，去掉也简单）。这时候因为protobuf版本冲突会导致有一者无法正常编译（版本出问题）。这时候我选择的是留下grpc而把老的protobuf版本去掉，因为grpc其实里面包含了protobuf,还有很多其他三方库（re2，abseil等等），在使用上可以用grpc里带的protobuf代替。当然，如果像我一样遇到这种问题要给解决，可以尝试一下。</p><p>配置好后的grpc使用：</p><p><img src="/posts/9331/349e76de8ff10715ccdad6dbc227013e.png" alt="方便？下面就有伏笔了"></p><pre class="line-numbers language-cmake"><code class="language-cmake">find_package(Protobuf CONFIG REQUIRED)find_package(gRPC CONFIG REQUIRED)message(STATUS "Using protobuf-${Protobuf_VERSION}")message(STATUS "Using gRPC-${gRPC_VERSION}")set(PROTO_PATH ${PROJECT_SOURCE_DIR}/proto)file(GLOB_RECURSE PROTO_FILES ${PROTO_PATH}/*.cc)file(GLOB_RECURSE all_srcs CONFIGURE_DEPENDS *.cpp)include_directories(${PROTO_PATH})add_executable(main ${all_srcs} ${PROTO_FILES})target_link_libraries(main PUBLIC gRPC::grpc++ protobuf)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/9331/image-20240506002754665.png" alt="猜猜直接找到了配套的老的会怎么样"></p><h2 id="版本冲突"><a href="#版本冲突" class="headerlink" title="版本冲突"></a>版本冲突</h2><p>当版本冲突时候的报错让人头皮发麻：</p><p><img src="/posts/9331/66f2db0ff9599db168f991216770f647.png" alt="头皮发麻"></p><p>如果像下面一样两个都留着的话，按照添加path的递归方式会选择使用grpc的，那么自然老的protobuf就不能够编译，那么如果我想使用前文提到过的直接手动指定行不行？</p><p><img src="/posts/9331/image-20240506001306510.png" alt></p><p>也就是将CMakeLists这样编写手动指定应该就行了吧？</p><pre><code>set(Protobuf_PREFIX_PATH  &quot;/home/joytsing/makeInstall/protobuf3.21.12/include&quot;  &quot;/home/joytsing/makeInstall/protobuf3.21.12/lib&quot;  &quot;/home/joytsing/makeInstall/protobuf3.21.12/bin&quot;)list(APPEND CMAKE_PREFIX_PATH &quot;${Protobuf_PREFIX_PATH}&quot;)find_package(Protobuf 3.21.12 REQUIRED)</code></pre><p>很遗憾，答案是不行，因为在我们全局配置完后，你只要使用<code>target_link_libraries(main PUBLIC protobuf)</code>，那么它默认会使用我们添加在全局PATH里的路径（而且我们已经在全局配置完lib和include，也就是说只需要link就能使用），只有当它在全局路径中找不到的时候它才会使用我们指定的路径，就是这么霸道。也就是说，在link的时候的protobuf都是默认指的grpc的（这取决于你），那么在把留在<code>.zshrc</code>老的<code>protobuf</code>去掉后我们还需要做什么，其实需要做的并不多，只需要稍稍修改就行。</p><p>再提一嘴为什么要把老的protobuf配置给去掉（很重要，不去掉的话一样会报错），因为现在版本有冲突，留着不仅没有用还会造成命名空间污染。所以现在相当于要配置一个安在其他地方的第三方库，仅此而已，稍稍配置就行了（除了库名因为被grpc污染不能使用）。</p><pre class="line-numbers language-cmake"><code class="language-cmake">set(Protobuf_PREFIX_PATH  "/home/joytsing/makeInstall/protobuf3.21.12/include"  "/home/joytsing/makeInstall/protobuf3.21.12/lib"  "/home/joytsing/makeInstall/protobuf3.21.12/bin")list(APPEND CMAKE_PREFIX_PATH "${Protobuf_PREFIX_PATH}")find_package(Protobuf 3.21.12 REQUIRED)include_directories(${Protobuf_INCLUDE_DIRS})include_directories(${PROJECT_SOURCE_DIR}/pb)file(GLOB_RECURSE all_srcs ${PROJECT_SOURCE_DIR}/src/*.cpp ${PROJECT_SOURCE_DIR}/pb/*.cc)add_executable(server ${all_srcs})target_link_libraries(server PUBLIC ${Protobuf_LIBRARIES})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把需要链接的库名protobuf改成对应cmake变量就行，同时加上对应的include，和正常使用三方库没区别（其实就是）。</p><p><img src="/posts/9331/image-20240506002501985.png" alt></p><p>好了，可喜可贺，一些可能有用的文档：</p><p><a href="https://www.jianshu.com/p/ae5c56845896">多个Protobuf版本时让find_package正确选择</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>另外在运行的时候发现一件事情，顺便还把k8s在最后<code>kubeadm init</code>时最后的通信连接不上的问题给解决了。</p><p><img src="/posts/9331/image-20240506221042708.png" alt="无响应"></p><p>因为之前在配置<code>minikube</code>的时候，官方推荐添加<code>NO_PROXY</code>,于是我图方便写了个脚本又给加入了全局环境中</p><p><img src="/posts/9331/image-20240506221343597.png" alt="孩子们，又是我"></p><p>所以现在的情况就是grpc依然走的代理，但是实际上我们把对应的代理地址给关闭了，自然也就连接不上，解决方法很简单，再写个脚本用<code>unset</code>，有同样的情况直接取消代理就行。</p><p><img src="/posts/9331/image-20240506221413586.png" alt="第六行"></p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="https://www.cnblogs.com/dangerman/p/6529742.html">CMake add_custom_command 使用</a></p><p><a href="https://samthursfield.wordpress.com/2015/11/21/cmake-dependencies-between-targets-and-files-and-custom-commands/">CMake: dependencies between targets and files and custom commands</a></p><p><a href="https://stackoverflow.com/questions/2937128/cmake-add-custom-command-not-being-run">stackoverflow: CMake add_custom_command not being run</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://joytsing.cn/posts/24753/&quot;&gt;前情提要&lt;/a&gt;，之前配置了比较低版本的protobu
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://JoyTsing.github.io/categories/Linux/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
  </entry>
  
</feed>
