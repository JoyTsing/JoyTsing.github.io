<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="进程和进程的基本操作, joytsing blog"><meta name="description" content="那么什么又是进程？"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="theme-color" content="white"><title>进程和进程的基本操作 | JoyTsing</title><link rel="apple-touch-icon" href="/"><link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="/favicon.ico"><link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css"><link rel="stylesheet" type="text/css" href="/libs/aos/aos.css"><link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css"><link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" type="text/css" href="/css/matery.css"><link rel="stylesheet" type="text/css" href="/css/my.css"><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style><script src="/libs/jquery/jquery.min.js"></script><script src="https://cdn-go.cn/aegis/aegis-sdk/latest/aegis.min.js"></script><script>const aegis=new Aegis({id:"6ojk8FlnQlqWeL6vQo",uin:"joyblog",reportApiSpeed:!0,reportAssetSpeed:!0,spa:!0,hostUrl:"https://rumt-sg.com"});console.log("aegis load")</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="JoyTsing" type="application/atom+xml"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><img src="/apple-touch-icon.png" class="logo-img" alt="LOGO"> <span class="logo-span">JoyTsing</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fa fa-home"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-tags"></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-bookmark"></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-archive"></i> <span>归档</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa fa-user-circle-o"></i> <span>关于</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa fa-envelope"></i> <span>留言</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa fa-address-book"></i> <span>友链</span></a></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fa fa-search" title="搜索"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="/medias/avatars/touxiang2.jpg" class="logo-img circle responsive-img"><div class="logo-name">JoyTsing</div><div class="logo-desc">joytsing的个人网站</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="m-nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-fw fa-bookmark"></i> 分类</a></li><li class="m-nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li class="m-nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa fa-fw fa-user-circle-o"></i> 关于</a></li><li class="m-nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa fa-fw fa-envelope"></i> 留言</a></li><li class="m-nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa fa-fw fa-address-book"></i> 友链</a></li><li><div class="divider"></div></li><li><a href="https://github.com/JoyTsing" class="waves-effect waves-light" target="_blank"><i class="fa fa-github-square fa-fw"></i>Follow Me</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#000;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href="https://github.com/JoyTsing" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Follow Me" data-position="left" data-delay="50"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a></nav></header><div class="bg-cover pd-header post-cover" style="background-image:url(/medias/featureimages/17.jpg)"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">进程和进程的基本操作</h1></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{width:345px;padding-left:20px}.toc-widget .toc-title{margin:35px 0 15px 0;padding-left:17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content{height:calc(100vh - 250px);overflow:auto}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px;position:absolute;right:23.5vw;display:block}#toc-content .is-active-link{color:#42b983}#floating-toc-btn{position:fixed;right:15px;bottom:76px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"><span class="chip bg-color">原理剖析</span> </a><a href="/tags/Linux/"><span class="chip bg-color">Linux</span> </a><a href="/tags/C/"><span class="chip bg-color">C</span> </a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="chip bg-color">操作系统</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-category">操作系统</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp; 2020-12-24</div><div class="post-date info-break-policy"><i class="fa fa-calendar-check-o fa-fw"></i>更新日期:&nbsp;&nbsp; 2024-04-20</div><div class="info-break-policy"><i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp; 5.7k</div><div class="info-break-policy"><i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp; 21 分</div><div id="busuanzi_container_page_pv" class="info-break-policy"><i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp; <span id="busuanzi_value_page_pv"></span></div></div></div><hr class="clearfix"><div class="card-content article-card-content"><div id="articleContent"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>进程作为程序真正发挥作用时的“形态”，我们有必要对它的一些相关操作非常熟悉，这一节主要描述进程相关的概念和操作，将介绍包括程序、进程、作业等基本概念以及进程状态查询、进程通信等相关的操作。</p><h2 id="什么是程序，什么又是进程"><a href="#什么是程序，什么又是进程" class="headerlink" title="什么是程序，什么又是进程"></a>什么是程序，什么又是进程</h2><p>程序是指令的集合，而进程则是程序执行的基本单元。为了让程序完成它的工作，必须让程序运行起来成为进程，进而利用处理器资源、内存资源，进行各种 <code>I/O</code> 操作，从而完成某项特定工作。</p><p>从这个意思上说，程序是静态的，而进程则是动态的。</p><p>进程有区别于程序的地方还有：进程除了包含程序文件中的指令数据以外，还需要在内核中有一个数据结构用以存放特定进程的相关属性，以便内核更好地管理和调度进程，从而完成多进程协作的任务。因此，从这个意义上可以说“高于”程序，超出了程序指令本身。</p><p>如果进行过多进程程序的开发，又会发现，一个程序可能创建多个进程，通过多个进程的交互完成任务。在 Linux 下，多进程的创建通常是通过 <code>fork</code> 系统调用来实现。从这个意义上来说程序则”包含”了进程。</p><p>另外一个需要明确的是，程序可以由多种不同程序语言描述，包括 C 语言程序、汇编语言程序和最后编译产生的机器指令等。</p><p>下面简单讨论 Linux 下面如何通过 Shell 进行进程的相关操作。</p><h2 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h2><p>通常在命令行键入某个程序文件名以后，一个进程就被创建了。例如，</p><h3 id="让程序在后台运行"><a href="#让程序在后台运行" class="headerlink" title="让程序在后台运行"></a>让程序在后台运行</h3><pre><code>$ sleep 100 &amp;
[1] 9298</code></pre><h3 id="查看进程-ID"><a href="#查看进程-ID" class="headerlink" title="查看进程 ID"></a>查看进程 ID</h3><p>用<code>pidof</code>可以查看指定程序名的进程ID：</p><pre><code>$ pidof sleep
9298</code></pre><h3 id="查看进程的内存映像"><a href="#查看进程的内存映像" class="headerlink" title="查看进程的内存映像"></a>查看进程的内存映像</h3><pre><code>$ cat /proc/9298/maps
08048000-0804b000 r-xp 00000000 08:01 977399     /bin/sleep
0804b000-0804c000 rw-p 00003000 08:01 977399     /bin/sleep
0804c000-0806d000 rw-p 0804c000 00:00 0          [heap]
b7c8b000-b7cca000 r--p 00000000 08:01 443354     
...
bfbd8000-bfbed000 rw-p bfbd8000 00:00 0          [stack]
ffffe000-fffff000 r-xp 00000000 00:00 0          [vdso]</code></pre><p>程序被执行后，就被加载到内存中，成为了一个进程。上面显示了该进程的内存映像（虚拟内存），包括程序指令、数据，以及一些用于存放程序命令行参数、环境变量的栈空间，用于动态内存申请的堆空间都被分配好。</p><p>实际上，创建一个进程，也就是说让程序运行，还有其他的办法，比如，通过一些配置让系统启动时自动启动程序（具体参考 <code>man init</code>），或者是通过配置 <code>crond</code> （或者 <code>at</code>）让它定时启动程序。除此之外，还有一个方式，那就是编写 Shell 脚本，把程序写入一个脚本文件，当执行脚本文件时，文件中的程序将被执行而成为进程。这些方式的细节就不介绍，下面了解如何查看进程的属性。</p><p>需要补充一点的是：在命令行下执行程序，可以通过 <code>ulimit</code> 内置命令来设置进程可以利用的资源，比如进程可以打开的最大文件描述符个数，最大的栈空间，虚拟内存空间等。具体用法见 <code>help ulimit</code> 。</p><h2 id="查看进程的属性和状态"><a href="#查看进程的属性和状态" class="headerlink" title="查看进程的属性和状态"></a>查看进程的属性和状态</h2><p>可以通过 <code>ps</code> 命令查看进程相关属性和状态，这些信息包括进程所属用户，进程对应的程序，进程对 <code>cpu</code> 和内存的使用情况等信息。熟悉如何查看它们有助于进行相关的统计分析等操作。</p><h3 id="通过-ps-命令查看进程属性"><a href="#通过-ps-命令查看进程属性" class="headerlink" title="通过 ps 命令查看进程属性"></a>通过 ps 命令查看进程属性</h3><p>查看系统当前所有进程的属性：</p><pre><code>$ ps -ef</code></pre><p>查看命令中包含某字符的程序对应的进程，进程 <code>ID</code> 是 1 。 <code>TTY</code> 为？表示和终端没有关联：</p><pre><code>$ ps -C init
  PID TTY          TIME CMD
    1 ?        00:00:01 init</code></pre><p>选择某个特定用户启动的进程：</p><pre><code>$ ps -U falcon</code></pre><p>按照指定格式输出指定内容，下面输出命令名和 <code>cpu</code> 使用率：</p><pre><code>$ ps -e -o &quot;%C %c&quot;</code></pre><p>打印 <code>cpu</code> 使用率最高的前 4 个程序：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ps</span> -e -o <span class="token string">"%C %c"</span> <span class="token operator">|</span> <span class="token function">sort</span> -u -k1 -r <span class="token operator">|</span> <span class="token function">head</span> -5
 7.5 firefox-bin
 1.1 Xorg
 0.8 scim-panel-gtk
 0.2 scim-bridge<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>获取使用虚拟内存最大的 5 个进程：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ps</span> -e -o <span class="token string">"%z %c"</span> <span class="token operator">|</span> <span class="token function">sort</span> -n -k1 -r <span class="token operator">|</span> <span class="token function">head</span> -5
349588 firefox-bin
 96612 xfce4-terminal
 88840 xfdesktop
 76332 gedit
 58920 scim-panel-gtk<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="通过-pstree-查看进程亲缘关系"><a href="#通过-pstree-查看进程亲缘关系" class="headerlink" title="通过 pstree 查看进程亲缘关系"></a>通过 pstree 查看进程亲缘关系</h3><p>系统所有进程之间都有“亲缘”关系，可以通过 <code>pstree</code> 查看这种关系：</p><pre><code>$ pstree</code></pre><p>上面会打印系统进程调用树，可以非常清楚地看到当前系统中所有活动进程之间的调用关系。</p><h3 id="用top动态查看进程信息"><a href="#用top动态查看进程信息" class="headerlink" title="用top动态查看进程信息"></a>用top动态查看进程信息</h3><pre><code>$ top</code></pre><p>该命令最大特点是可以动态地查看进程信息，当然，它还提供了一些其他的参数，比如 <code>-S</code> 可以按照累计执行时间的大小排序查看，也可以通过 <code>-u</code> 查看指定用户启动的进程等。</p><p>补充： <code>top</code> 命令支持交互式，比如它支持 <code>u</code> 命令显示用户的所有进程，支持通过 <code>k</code> 命令杀掉某个进程；如果使用 <code>-n 1</code> 选项可以启用批处理模式，具体用法为：</p><pre><code>$ top -n 1 -b</code></pre><h3 id="确保特定程序只有一个副本在运行"><a href="#确保特定程序只有一个副本在运行" class="headerlink" title="确保特定程序只有一个副本在运行"></a>确保特定程序只有一个副本在运行</h3><p>下面来讨论一个有趣的问题：如何让一个程序在同一时间只有一个在运行。</p><p>这意味着当一个程序正在被执行时，它将不能再被启动。那该怎么做呢？</p><p>假如一份相同的程序被复制成了很多份，并且具有不同的文件名被放在不同的位置，这个将比较糟糕，所以考虑最简单的情况，那就是这份程序在整个系统上是唯一的，而且名字也是唯一的。这样的话，有哪些办法来回答上面的问题呢？</p><p>总的机理是：在程序开头检查自己有没有执行，如果执行了则停止否则继续执行后续代码。</p><p>策略则是多样的，由于前面的假设已经保证程序文件名和代码的唯一性，所以通过 <code>ps</code> 命令找出当前所有进程对应的程序名，逐个与自己的程序名比较，如果已经有，那么说明自己已经运行了。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">ps</span> -e -o <span class="token string">"%c"</span> <span class="token operator">|</span> <span class="token function">tr</span> -d <span class="token string">" "</span> <span class="token operator">|</span> <span class="token function">grep</span> -q ^init$   <span class="token comment" spellcheck="true">#查看当前程序是否执行</span>
<span class="token punctuation">[</span> <span class="token variable">$?</span> -eq 0 <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">exit</span>   <span class="token comment" spellcheck="true">#如果在，那么退出, $?表示上一条指令是否执行成功</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>每次运行时先在指定位置检查是否存在一个保存自己进程 <code>ID</code> 的文件，如果不存在，那么继续执行，如果存在，那么查看该进程 <code>ID</code> 是否正在运行，如果在，那么退出，否则往该文件重新写入新的进程 <code>ID</code>，并继续。</p><pre class="line-numbers language-bash"><code class="language-bash">pidfile<span class="token operator">=</span>/tmp/<span class="token variable">$0</span><span class="token string">".pid"</span> 
<span class="token keyword">if</span> <span class="token punctuation">[</span> -f <span class="token variable">$pidfile</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
       OLDPID<span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">cat</span> $pidfile<span class="token variable">)</span></span>
    <span class="token function">ps</span> -e -o <span class="token string">"%p"</span> <span class="token operator">|</span> <span class="token function">tr</span> -d <span class="token string">" "</span> <span class="token operator">|</span> <span class="token function">grep</span> -q <span class="token string">"^<span class="token variable">$OLDPID</span>$"</span>
    <span class="token punctuation">[</span> <span class="token variable">$?</span> -eq 0 <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">exit</span>
<span class="token keyword">fi</span>

<span class="token keyword">echo</span> $$ <span class="token operator">></span> <span class="token variable">$pidfile</span>

<span class="token comment" spellcheck="true">#... 代码主体</span>

<span class="token comment" spellcheck="true">#设置信号0的动作，当程序退出时触发该信号从而删除掉临时文件</span>
<span class="token function">trap</span> <span class="token string">"rm <span class="token variable">$pidfile</span>"</span>      0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="调整进程的优先级"><a href="#调整进程的优先级" class="headerlink" title="调整进程的优先级"></a>调整进程的优先级</h2><p>在保证每个进程都能够顺利执行外，为了让某些任务优先完成，那么系统在进行进程调度时就会采用一定的调度办法，比如常见的有按照优先级的时间片轮转的调度算法。这种情况下，可以通过 <code>renice</code> 调整正在运行的程序的优先级，例如：`</p><h3 id="获取进程优先级"><a href="#获取进程优先级" class="headerlink" title="获取进程优先级"></a>获取进程优先级</h3><pre><code>$ ps -e -o &quot;%p %c %n&quot; | grep xfs
 5089 xfs               0</code></pre><h3 id="调整进程的优先级-1"><a href="#调整进程的优先级-1" class="headerlink" title="调整进程的优先级"></a>调整进程的优先级</h3><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">renice</span> 1 -p 5089
renice: 5089: setpriority: Operation not permitted
$ <span class="token function">sudo</span> <span class="token function">renice</span> 1 -p 5089   <span class="token comment" spellcheck="true">#需要权限才行</span>
<span class="token punctuation">[</span>sudo<span class="token punctuation">]</span> password <span class="token keyword">for</span> falcon:
5089: old priority 0, new priority 1
$ <span class="token function">ps</span> -e -o <span class="token string">"%p %c %n"</span> <span class="token operator">|</span> <span class="token function">grep</span> xfs  <span class="token comment" spellcheck="true">#再看看，优先级已经被调整过来了</span>
 5089 xfs               1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h2><p>既然可以通过命令行执行程序，创建进程，那么也有办法结束它。可以通过 <code>kill</code> 命令给用户自己启动的进程发送某个信号让进程终止，当然“万能”的 <code>root</code> 几乎可以 <code>kill</code> 所有进程（除了 <code>init</code> 之外）。例如，</p><h3 id="结束进程-1"><a href="#结束进程-1" class="headerlink" title="结束进程"></a>结束进程</h3><pre><code>$ sleep 50 &amp;   #启动一个进程
[1] 11347
$ kill 11347</code></pre><p><code>kill</code> 命令默认会发送终止信号（ <code>SIGTERM</code> ）给程序，让程序退出，但是 <code>kill</code> 还可以发送其他信号，这些信号的定义可以通过 <code>man 7 signal</code> 查看到，也可以通过 <code>kill -l</code> 列出来。</p><pre><code>$ man 7 signal
$ kill -l
 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL
 5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE
 9) SIGKILL     10) SIGUSR1     11) SIGSEGV     12) SIGUSR2
13) SIGPIPE     14) SIGALRM     15) SIGTERM     16) SIGSTKFLT
17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU
25) SIGXFSZ     26) SIGVTALRM   27) SIGPROF     28) SIGWINCH
29) SIGIO       30) SIGPWR      31) SIGSYS      34) SIGRTMIN
35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3  38) SIGRTMIN+4
39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12
47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14
51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10
55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7  58) SIGRTMAX-6
59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX</code></pre><h3 id="暂停某个进程"><a href="#暂停某个进程" class="headerlink" title="暂停某个进程"></a>暂停某个进程</h3><p>例如，用 <code>kill</code> 命令发送 <code>SIGSTOP</code> 信号给某个程序，让它暂停，然后发送 <code>SIGCONT</code> 信号让它继续运行。</p><pre><code>$ sleep 50 &amp;
[1] 11441
$ jobs
[1]+  Running                 sleep 50 &amp;
$ kill -s SIGSTOP 11441   #这个等同于我们对一个前台进程执行CTRL+Z操作
$ jobs
[1]+  Stopped                 sleep 50
$ kill -s SIGCONT 11441   #这个等同于之前我们使用bg %1操作让一个后台进程运行起来
$ jobs
[1]+  Running                 sleep 50 &amp;
$ kill %1                  #在当前会话(session)下，也可以通过作业号控制进程
$ jobs
[1]+  Terminated              sleep 50</code></pre><p>可见 <code>kill</code> 命令提供了非常好的功能，不过它只能根据进程的 <code>ID</code> 或者作业来控制进程，而 <code>pkill</code> 和 <code>killall</code> 提供了更多选择，它们扩展了通过程序名甚至是进程的用户名来控制进程的方法。更多用法请参考它们的手册。</p><h3 id="查看进程退出状态"><a href="#查看进程退出状态" class="headerlink" title="查看进程退出状态"></a>查看进程退出状态</h3><p>当程序退出后，如何判断这个程序是正常退出还是异常退出呢？还记得 Linux 下，那个经典 <code>hello world</code> 程序吗？在代码的最后总是有条 <code>return 0</code> 语句。这个 <code>return 0</code> 实际上是让程序员来检查进程是否正常退出的。如果进程返回了一个其他的数值，那么可以肯定地说这个进程异常退出了，因为它都没有执行到 <code>return 0</code> 这条语句就退出了。</p><p>那怎么检查进程退出的状态，即那个返回的数值呢？</p><p>在 <code>Shell</code> 中，可以检查这个特殊的变量 <code>$?</code>，它存放了上一条命令执行后的退出状态。</p><pre class="line-numbers language-bash"><code class="language-bash">$ test1
bash: test1: <span class="token function">command</span> not found
$ <span class="token keyword">echo</span> <span class="token variable">$?</span>
127
$ <span class="token function">cat</span> ./test.c <span class="token operator">|</span> <span class="token function">grep</span> hello
$ <span class="token keyword">echo</span> <span class="token variable">$?</span>
1
$ <span class="token function">cat</span> ./test.c <span class="token operator">|</span> <span class="token function">grep</span> hi
    printf<span class="token punctuation">(</span><span class="token string">"hi, myself!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
$ <span class="token keyword">echo</span> <span class="token variable">$?</span>
0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>貌似返回 0 成为了一个潜规则，虽然没有标准明确规定，不过当程序正常返回时，总是可以从 <code>$?</code> 中检测到 0，但是异常时，总是检测到一个非 0 值。这就告诉我们在程序的最后最好是跟上一个 <code>exit 0</code> 以便任何人都可以通过检测 <code>$?</code> 确定程序是否正常结束。如果有一天，有人偶尔用到你的程序，试图检查它的退出状态，而你却在程序的末尾莫名地返回了一个 <code>-1</code> 或者 1，那么他将会很苦恼，会怀疑他自己编写的程序到底哪个地方出了问题，检查半天却不知所措，因为他太信任你了，竟然从头至尾都没有怀疑你的编程习惯可能会与众不同！</p><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>为便于设计和实现，通常一个大型的任务都被划分成较小的模块。不同模块之间启动后成为进程，它们之间如何通信以便交互数据，协同工作呢？在APUE一书中提到很多方法，诸如管道（无名管道和有名管道）、信号（<code>signal</code>）、报文（<code>Message</code>）队列（消息队列）、共享内存（<code>mmap/munmap</code>）、信号量（<code>semaphore</code>，主要是同步用，进程之间，进程的不同线程之间）、套接口（<code>Socket</code>，支持不同机器之间的进程通信）等，而在 Shell 中，通常直接用到的就有管道和信号等。下面主要介绍管道和信号机制在 Shell 编程时的一些用法。</p><h3 id="无名管道（pipe）"><a href="#无名管道（pipe）" class="headerlink" title="无名管道（pipe）"></a>无名管道（pipe）</h3><p>在 Linux 下，可以通过 <code>|</code> 连接两个程序，这样就可以用它来连接后一个程序的输入和前一个程序的输出，因此被形象地叫做个管道。在 C 语言中，创建无名管道非常简单方便，用 <code>pipe</code> 函数，传入一个具有两个元素的 <code>int</code> 型的数组就可以。这个数组实际上保存的是两个文件描述符，父进程往第一个文件描述符里头写入东西后，子进程可以从第一个文件描述符中读出来。</p><p>如果用多了命令行，这个管子 <code>|</code> 应该会经常用。比如上面有个演示把 <code>ps</code> 命令的输出作为 <code>grep</code> 命令的输入：</p><pre><code>$ ps -ef | grep init</code></pre><p>也许会觉得这个“管子”好有魔法，竟然真地能够链接两个程序的输入和输出，它们到底是怎么实现的呢？实际上当输入这样一组命令时，当前 Shell 会进行适当的解析，把前面一个进程的输出关联到管道的输出文件描述符，把后面一个进程的输入关联到管道的输入文件描述符，这个关联过程通过输入输出重定向函数 <code>dup</code> （或者 <code>fcntl</code> ）来实现。</p><h3 id="有名管道（named-pipe）"><a href="#有名管道（named-pipe）" class="headerlink" title="有名管道（named pipe）"></a>有名管道（named pipe）</h3><p>有名管道实际上是一个文件（无名管道也像一个文件，虽然关系到两个文件描述符，不过只能一边读另外一边写），不过这个文件比较特别，操作时要满足先进先出，而且，如果试图读一个没有内容的有名管道，那么就会被阻塞，同样地，如果试图往一个有名管道里写东西，而当前没有程序试图读它，也会被阻塞。下面看看效果。</p><pre><code>$ mkfifo fifo_test    #通过mkfifo命令创建一个有名管道
$ echo &quot;fewfefe&quot; &gt; fifo_test
#试图往fifo_test文件中写入内容，但是被阻塞，要另开一个终端继续下面的操作
$ cat fifo_test        #另开一个终端，记得，另开一个。试图读出fifo_test的内容
fewfefe</code></pre><p>这里的 <code>echo</code> 和 <code>cat</code> 是两个不同的程序，在这种情况下，通过 <code>echo</code> 和 <code>cat</code> 启动的两个进程之间并没有父子关系。不过它们依然可以通过有名管道通信。</p><p>这样一种通信方式非常适合某些特定情况：例如有这样一个架构，这个架构由两个应用程序构成，其中一个通过循环不断读取 <code>fifo_test</code> 中的内容，以便判断，它下一步要做什么。如果这个管道没有内容，那么它就会被阻塞在那里，而不会因死循环而耗费资源，另外一个则作为一个控制程序不断地往 <code>fifo_test</code> 中写入一些控制信息，以便告诉之前的那个程序该做什么。下面写一个非常简单的例子。可以设计一些控制码，然后控制程序不断地往 <code>fifo_test</code> 里头写入，然后应用程序根据这些控制码完成不同的动作。当然，也可以往 <code>fifo_test</code> 传入除控制码外的其他数据。</p><ul><li><p>应用程序的代码</p><pre class="line-numbers language-bash"><code class="language-bash">  $ <span class="token function">cat</span> app.sh
  <span class="token comment" spellcheck="true">#!/bin/bash</span>

  FIFO<span class="token operator">=</span>fifo_test
  <span class="token keyword">while</span> <span class="token keyword">:</span><span class="token punctuation">;</span>
  <span class="token keyword">do</span>
      CI<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">cat</span> $FIFO<span class="token variable">`</span></span>  <span class="token comment" spellcheck="true">#CI --> Control Info</span>
      <span class="token keyword">case</span> <span class="token variable">$CI</span> <span class="token keyword">in</span>
          0<span class="token punctuation">)</span> <span class="token keyword">echo</span> <span class="token string">"The CONTROL number is ZERO, do something ..."</span>
              <span class="token punctuation">;</span><span class="token punctuation">;</span>
          1<span class="token punctuation">)</span> <span class="token keyword">echo</span> <span class="token string">"The CONTROL number is ONE, do something ..."</span>
              <span class="token punctuation">;</span><span class="token punctuation">;</span>
          *<span class="token punctuation">)</span> <span class="token keyword">echo</span> <span class="token string">"The CONTROL number not recognized, do something else..."</span>
              <span class="token punctuation">;</span><span class="token punctuation">;</span>
      esac
  <span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>控制程序的代码</p><pre class="line-numbers language-bash"><code class="language-bash">  $ <span class="token function">cat</span> control.sh
  <span class="token comment" spellcheck="true">#!/bin/bash</span>

  FIFO<span class="token operator">=</span>fifo_test
  CI<span class="token operator">=</span><span class="token variable">$1</span>

  <span class="token punctuation">[</span> -z <span class="token string">"<span class="token variable">$CI</span>"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">echo</span> <span class="token string">"the control info should not be empty"</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">exit</span> 

  <span class="token keyword">echo</span> <span class="token variable">$CI</span> <span class="token operator">></span> <span class="token variable">$FIFO</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>一个程序通过管道控制另外一个程序的工作</p><pre class="line-numbers language-bash"><code class="language-bash">  $ <span class="token function">chmod</span> +x app.sh control.sh    <span class="token comment" spellcheck="true">#修改这两个程序的可执行权限，以便用户可以执行它们</span>
  $ ./app.sh  <span class="token comment" spellcheck="true">#在一个终端启动这个应用程序，在通过./control.sh发送控制码以后查看输出</span>
  The CONTROL number is ONE, <span class="token keyword">do</span> something <span class="token punctuation">..</span>.    <span class="token comment" spellcheck="true">#发送1以后</span>
  The CONTROL number is ZERO, <span class="token keyword">do</span> something <span class="token punctuation">..</span>.    <span class="token comment" spellcheck="true">#发送0以后</span>
  The CONTROL number not recognized, <span class="token keyword">do</span> something else<span class="token punctuation">..</span>.  <span class="token comment" spellcheck="true">#发送一个未知的控制码以后</span>
  $ ./control.sh 1            <span class="token comment" spellcheck="true">#在另外一个终端，发送控制信息，控制应用程序的工作</span>
  $ ./control.sh 0
  $ ./control.sh 4343<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>这样一种应用架构非常适合本地的多程序任务设计，如果结合 <code>web cgi</code>，那么也将适合远程控制的要求。引入 <code>web cgi</code> 的唯一改变是，要把控制程序 <code>./control.sh</code> 放到 <code>web</code> 的 <code>cgi</code> 目录下，并对它作一些修改，以使它符合 <code>CGI</code> 的规范，这些规范包括文档输出格式的表示（在文件开头需要输出 <code>content-tpye: text/html</code> 以及一个空白行）和输入参数的获取 <code>(web</code> 输入参数都存放在 <code>QUERY_STRING</code> 环境变量里头）。因此一个非常简单的 <code>CGI</code> 控制程序可以写成这样：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

FIFO<span class="token operator">=</span>./fifo_test
CI<span class="token operator">=</span><span class="token variable">$QUERY_STRING</span>

<span class="token punctuation">[</span> -z <span class="token string">"<span class="token variable">$CI</span>"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">echo</span> <span class="token string">"the control info should not be empty"</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">exit</span> 

<span class="token keyword">echo</span> -e <span class="token string">"content-type: text/html\n\n"</span>
<span class="token keyword">echo</span> <span class="token variable">$CI</span> <span class="token operator">></span> <span class="token variable">$FIFO</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在实际使用时，请确保 <code>control.sh</code> 能够访问到 <code>fifo_test</code> 管道，并且有写权限，以便通过浏览器控制 <code>app.sh</code> ：</p><pre><code>http://ipaddress\_or\_dns/cgi-bin/control.sh?0</code></pre><p>问号 <code>?</code> 后面的内容即 <code>QUERY_STRING</code>，类似之前的 <code>$1</code> 。</p><p>这样一种应用对于远程控制，特别是嵌入式系统的远程控制很有实际意义。在去年的暑期课程上，我们就通过这样一种方式来实现马达的远程控制。首先，实现了一个简单的应用程序以便控制马达的转动，包括转速，方向等的控制。为了实现远程控制，我们设计了一些控制码，以便控制马达转动相关的不同属性。</p><p>在 C 语言中，如果要使用有名管道，和 Shell 类似，只不过在读写数据时用 <code>read</code>，<code>write</code> 调用，在创建 <code>fifo</code> 时用 <code>mkfifo</code> 函数调用。</p><h3 id="信号（Signal）"><a href="#信号（Signal）" class="headerlink" title="信号（Signal）"></a>信号（Signal）</h3><p>信号是软件中断，Linux 用户可以通过 <code>kill</code> 命令给某个进程发送一个特定的信号，也可以通过键盘发送一些信号，比如 <code>CTRL+C</code> 可能触发 <code>SGIINT</code> 信号，而 <code>CTRL+\</code> 可能触发 <code>SGIQUIT</code> 信号等，除此之外，内核在某些情况下也会给进程发送信号，比如在访问内存越界时产生 <code>SGISEGV</code> 信号，当然，进程本身也可以通过 <code>kill</code>，<code>raise</code> 等函数给自己发送信号。对于 Linux 下支持的信号类型，大家可以通过 <code>man 7 signal</code> 或者 <code>kill -l</code> 查看到相关列表和说明。</p><p>对于有些信号，进程会有默认的响应动作，而有些信号，进程可能直接会忽略，当然，用户还可以对某些信号设定专门的处理函数。在 Shell 中，可以通过 <code>trap</code> 命令（Shell 内置命令）来设定响应某个信号的动作（某个命令或者定义的某个函数），而在 C 语言中可以通过 <code>signal</code> 调用注册某个信号的处理函数。这里仅仅演示 <code>trap</code> 命令的用法。</p><pre><code>$ function signal_handler { echo &quot;hello, world.&quot;; } #定义signal_handler函数
$ trap signal_handler SIGINT  #执行该命令设定：收到SIGINT信号时打印hello, world
$ hello, world     #按下CTRL+C，可以看到屏幕上输出了hello, world字符串</code></pre><p>类似地，如果设定信号 0 的响应动作，那么就可以用 <code>trap</code> 来模拟 C 语言程序中的 <code>atexit</code> 程序终止函数的登记，即通过 <code>trap signal_handler SIGQUIT</code> 设定的 <code>signal_handler</code> 函数将在程序退出时执行。信号 0 是一个特别的信号，在 <code>POSIX.1</code> 中把信号编号 0 定义为空信号，这常被用来确定一个特定进程是否仍旧存在。当一个程序退出时会触发该信号。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> sigexit.sh
<span class="token comment" spellcheck="true">#!/bin/bash</span>

<span class="token keyword">function</span> signal_handler <span class="token punctuation">{</span>
    <span class="token keyword">echo</span> <span class="token string">"hello, world"</span>
<span class="token punctuation">}</span>
<span class="token function">trap</span> signal_handler 0
$ <span class="token function">chmod</span> +x sigexit.sh
$ ./sigexit.sh    <span class="token comment" spellcheck="true">#实际Shell编程会用该方式在程序退出时来做一些清理临时文件的收尾工作</span>
hello, world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="作业和作业控制"><a href="#作业和作业控制" class="headerlink" title="作业和作业控制"></a>作业和作业控制</h2><p>当我们为完成一些复杂的任务而将多个命令通过 <code>|,\&gt;,&lt;, ;, (,)</code> 等组合在一起时，通常这个命令序列会启动多个进程，它们间通过管道等进行通信。而有时在执行一个任务的同时，还有其他的任务需要处理，那么就经常会在命令序列的最后加上一个&amp;，或者在执行命令后，按下 <code>CTRL+Z</code> 让前一个命令暂停。以便做其他的任务。等做完其他一些任务以后，再通过 <code>fg</code> 命令把后台任务切换到前台。这样一种控制过程通常被成为作业控制，而那些命令序列则被成为作业，这个作业可能涉及一个或者多个程序，一个或者多个进程。下面演示一下几个常用的作业控制操作。</p><h3 id="创建后台进程，获取进程的作业号和进程号"><a href="#创建后台进程，获取进程的作业号和进程号" class="headerlink" title="创建后台进程，获取进程的作业号和进程号"></a>创建后台进程，获取进程的作业号和进程号</h3><pre><code>$ sleep 50 &amp;
[1] 11137</code></pre><h3 id="把作业调到前台并暂停"><a href="#把作业调到前台并暂停" class="headerlink" title="把作业调到前台并暂停"></a>把作业调到前台并暂停</h3><p>使用 Shell 内置命令 <code>fg</code> 把作业 1 调到前台运行，然后按下 <code>CTRL+Z</code> 让该进程暂停</p><pre><code>$ fg %1
sleep 50
^Z
[1]+  Stopped                 sleep 50</code></pre><h3 id="查看当前作业情况"><a href="#查看当前作业情况" class="headerlink" title="查看当前作业情况"></a>查看当前作业情况</h3><pre><code>$ jobs            #查看当前作业情况，有一个作业停止
[1]+  Stopped                 sleep 50
$ sleep 100 &amp;     #让另外一个作业在后台运行
[2] 11138         
$ jobs            #查看当前作业情况，一个正在运行，一个停止
[1]+  Stopped                 sleep 50
[2]-  Running                 sleep 100 &amp;</code></pre><h3 id="启动停止的进程并运行在后台"><a href="#启动停止的进程并运行在后台" class="headerlink" title="启动停止的进程并运行在后台"></a>启动停止的进程并运行在后台</h3><pre><code>$ bg %1
[2]+ sleep 50 &amp;</code></pre><p>不过，要在命令行下使用作业控制，需要当前 Shell，内核终端驱动等对作业控制支持才行。</p></div><hr><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"><span class="chip bg-color">原理剖析</span> </a><a href="/tags/Linux/"><span class="chip bg-color">Linux</span> </a><a href="/tags/C/"><span class="chip bg-color">C</span> </a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="chip bg-color">操作系统</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="wechat,qq" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="/libs/share/js/social-share.min.js"></script></div></div></div></div></div><style>.valine-card{margin:1.5rem auto}.valine-card .card-content{padding:20px 20px 5px 20px}#vcomments textarea{box-sizing:border-box;background:url(/medias/comment_bg.png) 100% 100% no-repeat}#vcomments p{margin:2px 2px 10px;font-size:1.05rem;line-height:1.78rem}#vcomments blockquote p{text-indent:.2rem}#vcomments a{padding:0 2px;color:#4cbf30;font-weight:500;text-decoration:none}#vcomments img{max-width:100%;height:auto;cursor:pointer}#vcomments ol li{list-style-type:decimal}#vcomments ol,ul{display:block;padding-left:2em;word-spacing:.05rem}#vcomments ul li,ol li{display:list-item;line-height:1.8rem;font-size:1rem}#vcomments ul li{list-style-type:disc}#vcomments ul ul li{list-style-type:circle}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}#vcomments table,td,th{border:0}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments h1{font-size:1.85rem;font-weight:700;line-height:2.2rem}#vcomments h2{font-size:1.65rem;font-weight:700;line-height:1.9rem}#vcomments h3{font-size:1.45rem;font-weight:700;line-height:1.7rem}#vcomments h4{font-size:1.25rem;font-weight:700;line-height:1.5rem}#vcomments h5{font-size:1.1rem;font-weight:700;line-height:1.4rem}#vcomments h6{font-size:1rem;line-height:1.3rem}#vcomments p{font-size:1rem;line-height:1.5rem}#vcomments hr{margin:12px 0;border:0;border-top:1px solid #ccc}#vcomments blockquote{margin:15px 0;border-left:5px solid #42b983;padding:1rem .8rem .3rem .8rem;color:#666;background-color:rgba(66,185,131,.1)}#vcomments pre{font-family:monospace,monospace;padding:1.2em;margin:.5em 0;background:#272822;overflow:auto;border-radius:.3em;tab-size:4}#vcomments code{font-family:monospace,monospace;padding:1px 3px;font-size:.92rem;color:#e96900;background-color:#f8f8f8;border-radius:2px}#vcomments pre code{font-family:monospace,monospace;padding:0;color:#e8eaf6;background-color:#272822}#vcomments pre[class*=language-]{padding:1.2em;margin:.5em 0}#vcomments code[class*=language-],pre[class*=language-]{color:#e8eaf6}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}#vcomments b,strong{font-weight:700}#vcomments dfn{font-style:italic}#vcomments small{font-size:85%}#vcomments cite{font-style:normal}#vcomments mark{background-color:#fcf8e3;padding:.2em}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}.v .vlist .vcard{padding-top:2.5em!important}</style><div class="card valine-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;left:20px;top:15px;padding-bottom:5px"><i class="fa fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="vcomments" class="card-content" style="display:grid"></div></div><script src="/libs/valine/av-min.js"></script><script src="/libs/valine/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"98JpzSGcrl9jFqHO13vqxHvX-gzGzoHsz",appKey:"mDmr2h9PB20xvPMNqgyRnNIC",notify:!0,verify:!0,visitor:!0,avatar:"mm",pageSize:"10",lang:"zh-cn",placeholder:"just go go"})</script><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fa fa-chevron-left"></i>&nbsp;上一篇</div><div class="card"><a href="/posts/58644/"><div class="card-image"><img src="/medias/featureimages/23.jpg" class="responsive-img" alt="可执行ELF文件的编写"> <span class="card-title">可执行ELF文件的编写</span></div></a><div class="card-content article-content"><div class="summary block-with-text">所以啥是ELF？</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2020-12-24 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/Linux/" class="post-category">Linux</a></span></div></div><div class="card-action article-tags"><a href="/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"><span class="chip bg-color">原理剖析</span> </a><a href="/tags/Linux/"><span class="chip bg-color">Linux</span> </a><a href="/tags/C/"><span class="chip bg-color">C</span> </a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="chip bg-color">操作系统</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fa fa-chevron-right"></i></div><div class="card"><a href="/posts/46405/"><div class="card-image"><img src="/medias/featureimages/19.jpg" class="responsive-img" alt="程序执行时发生了什么"> <span class="card-title">程序执行时发生了什么</span></div></a><div class="card-content article-content"><div class="summary block-with-text">当我们在 Linux 下的命令行输入一个命令之后，这背后发生了什么？</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2020-12-24 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-category">操作系统</a></span></div></div><div class="card-action article-tags"><a href="/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"><span class="chip bg-color">原理剖析</span> </a><a href="/tags/Linux/"><span class="chip bg-color">Linux</span> </a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="chip bg-color">操作系统</span></a></div></div></div></div></article></div><script>$("#articleContent").on("copy",function(e){var n,t,o,i;void 0!==window.getSelection&&((""+(n=window.getSelection())).length<Number.parseInt("120")||(t=document.getElementsByTagName("body")[0],(o=document.createElement("div")).style.position="absolute",o.style.left="-99999px",t.appendChild(o),o.appendChild(n.getRangeAt(0).cloneContents()),"PRE"===n.getRangeAt(0).commonAncestorContainer.nodeName&&(o.innerHTML="<pre>"+o.innerHTML+"</pre>"),i=document.location.href,o.innerHTML+='<br />来源: JoyTsing<br />文章作者: JoyTsing<br />文章链接: <a href="'+i+'">'+i+"</a><br />本文章著作权归作者joytsing所有，请任何形式的转载都请注明出处并在文章评论区处告知。",n.selectAllChildren(o),window.setTimeout(function(){t.removeChild(o)},200)))})</script><script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script><script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script><script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script><script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget"><div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fa fa-list"></i></a></div><script src="/libs/tocbot/tocbot.min.js"></script><script>$(function(){tocbot.init({tocSelector:"#toc-content",contentSelector:"#articleContent",headingsOffset:-(.4*$(window).height()-45),headingSelector:"h2, h3, h4, h5"});let t=0;var e="toc-heading-";$("#toc-content a").each(function(){$(this).attr("href","#"+e+ ++t)}),t=0,$("#articleContent").children("h2, h3, h4, h5").each(function(){$(this).attr("id",e+ ++t)});var n=parseInt(.4*$(window).height()-64);let o=$(".toc-widget");$(window).scroll(function(){var t=$(window).scrollTop();n<t?o.addClass("toc-fixed"):o.removeClass("toc-fixed")});var i="expanded";let a=$("#toc-aside"),c=$("#main-content");$("#floating-toc-btn .btn-floating").click(function(){a.hasClass(i)?(a.removeClass(i).hide(),c.removeClass("l9")):(a.addClass(i).show(),c.addClass("l9")),function(){let e=$("#artDetail");if(0!==e.length){let t=e.width();450<=t?t+=21:350<=t&&t<450?t+=18:300<=t&&t<350?t+=16:t+=14,$("#prenext-posts").width(t)}}()})})</script></main><footer class="page-footer bg-color"><div class="container row center-align"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2019</span> <a href="/about" rel="external nofollow noreferrer">JoyTsing</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br><span id="sitetime">载入运行时间...</span> <span id="busuanzi_container_site_pv">|&nbsp;<i class="fa fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span>&nbsp;次 </span><span id="busuanzi_container_site_uv">|&nbsp;<i class="fa fa-user"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv" class="white-color"></span>&nbsp;人</span><br>&nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;<span class="white-color">840.9k</span>&nbsp;字 <span id="icp"><img src="/medias/icp.png" style="vertical-align:text-bottom" alt="icp"> <a href="https://beian.miit.gov.cn/" target="_blank">陕公网安备61019002002862号 滇ICP备2024026466号-1</a></span><script>function siteTime(){var e=864e5,t="2019",n=(m=new Date).getFullYear(),o=m.getMonth()+1,r=m.getDate(),a=m.getHours(),i=m.getMinutes(),l=m.getSeconds(),m=Date.UTC(t,"7","24","0","0","0"),r=Date.UTC(n,o,r,a,i,l)-m,a=Math.floor(r/31536e6),i=Math.floor(r/e-365*a),l=Math.floor((r-(365*a+i)*e)/36e5),m=Math.floor((r-(365*a+i)*e-36e5*l)/6e4),M=Math.floor((r-(365*a+i)*e-36e5*l-6e4*m)/1e3);t==n?(document.getElementById("year").innerHTML=n,document.getElementById("sitetime").innerHTML="本站已安全运行 "+i+" 天 "+l+" 小时 "+m+" 分钟 "+M+" 秒"):(document.getElementById("year").innerHTML=t+" - "+n,document.getElementById("sitetime").innerHTML="本站已安全运行 "+a+" 年 "+i+" 天 "+l+" 小时 "+m+" 分钟 "+M+" 秒")}setInterval(siteTime,1e3)</script></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/JoyTsing" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fa fa-github"></i> </a><a href="/medias/wechat.jpg" target="_blank" data-tooltip="添加我的微信: [object Object]" data-position="top" data-delay="50"><i class="fa fa-weixin"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script src="/js/search.js"></script><script type="text/javascript">$(function(){searchFunc("/search.xml","searchInput","searchResult")})</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fa fa-angle-up"></i></a></div><script src="/libs/materialize/materialize.min.js"></script><script src="/libs/masonry/masonry.pkgd.min.js"></script><script src="/libs/aos/aos.js"></script><script src="/libs/scrollprogress/scrollProgress.min.js"></script><script src="/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="/js/matery.js"></script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?3a39d92b69933ae56c7eb41ffb9aa2e0";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="/libs/others/busuanzi.pure.mini.js"></script><script type="text/javascript">var st,OriginTitile=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="(oﾟvﾟ)ノ Hi",clearTimeout(st)):(document.title="(*´∇｀*) 欢迎回来！",st=setTimeout(function(){document.title=OriginTitile},3e3))})</script><script type="text/javascript" color="0,0,255" pointcolor="0,0,255" opacity="0.8" zindex="-1" count="150" src="/libs/background/canvas-nest.js"></script><script src="/libs/instantpage/instantpage.js" type="module"></script><script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script><script>const hasAttr = (e,a) => a.some(_=> e.attr(_)!==undefined);
        $('a').each(function() {
          const $this = $(this);
          if(hasAttr($this,["data-fancybox","ignore-external-link"])) return;
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== '' || window.location.host) {
                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/shizuku.model.json"},display:{position:"left",width:150,height:200},mobile:{show:!1},react:{opacity:.7}})</script></body></html>